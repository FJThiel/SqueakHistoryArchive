'From Squeak 2.3 beta of Nov 25, 1998 on 9 January 1999 at 3:57:05 pm'!"Change Set:		Jitter2Date:			5 January 1999Author:			Ian PiumartaThe totality of the changes to the 2.3beta-e image required to support the Jitter2.NOTE: this change set includes the UncacheMethod changes from Dan which werenot in the base 2.3e image from which I started.NOTE: this change set also includes two additional methods in InterpreterSimulator, which broke for me with a couple of #doesNotUnderstand:s due to the missing methods.NOTE: there are also a couple of methods in SystemDictionary which call named primitives in the squeakCompiler module.  These are for enabling and disabling runtime compilation, and are entirely optional (but rather useful, especially for InterpreterSupportCode class>>comparativeBenchmarks).NOTE: there are two optional methods in InterpreterSupportCode which run slightly more realistic benchmarks using Integer>>benchFib and Integer>>benchmark, called several times with larger than normal arguments.NOTE: there are new versions of the squeakVirtualMachine[Header]File methods which inlude the jitter hook support.  I've bumped the minor version to 1.1."!ObjectMemory subclass: #Interpreter	instanceVariableNames: 'activeContext theHomeContext method receiver instructionPointer stackPointer localIP localSP localHomeContext messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache atCache lkupClass reclaimableContextCount nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignal semaphoresToSignalCount savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals compilerInitialized compilerHooks '	classVariableNames: 'ActiveProcessIndex AtCacheEntries AtCacheFixedFields AtCacheFmt AtCacheMask AtCacheOop AtCacheSize AtCacheTotalSize AtPutBase BlockArgumentCountIndex BytecodeTable CacheProbeMax CallerIndex CharacterValueIndex CompilerHooksSize DirBadPath DirEntryFound DirNoMoreEntries ExcessSignalsIndex FirstLinkIndex HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageSelectorIndex MessageSize MethodArrayIndex MethodCacheClass MethodCacheEntries MethodCacheEntrySize MethodCacheMask MethodCacheMethod MethodCachePrim MethodCacheSelector MethodCacheSize MethodIndex MyListIndex NextLinkIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'Squeak-Interpreter'!InterpreterSimulator subclass: #InterpreterSimulatorLSB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Interpreter'!!Behavior methodsFor: 'creating method dictionary' stamp: 'di 1/2/1999 15:52'!addSelector: selector withMethod: compiledMethod 	"Add the message selector with the corresponding compiled method to the 	receiver's method dictionary."	| oldMethod |	oldMethod _ self lookupSelector: selector.	methodDict at: selector put: compiledMethod.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod == nil ifFalse: [oldMethod flushCache].	selector flushCache! !!Behavior methodsFor: 'creating method dictionary' stamp: 'di 1/2/1999 15:16'!removeSelector: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	^ self removeSelectorSimply: selector! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 1/2/1999 15:45'!lookupSelector: selector	"Look up the given selector in my methodDictionary.	Return the corresponding method if found.	Otherwise chase the superclass chain and try again.	Return nil if no method is found."	| lookupClass |	lookupClass _ self.	[lookupClass == nil]		whileFalse: 			[(lookupClass includesSelector: selector)				ifTrue: [^ lookupClass compiledMethodAt: selector].			lookupClass _ lookupClass superclass].	^ nil! !!Behavior methodsFor: 'private' stamp: 'di 1/2/1999 16:06'!removeSelectorSimply: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |	oldMethod _ methodDict at: selector ifAbsent: [^ self].	methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache.! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'ikp 1/3/1999 16:58'!emitCCodeOn: aStream doInlining: inlineFlag doAssertions: assertionFlag	"Emit C code for all methods in the code base onto the given stream. All inlined method calls should already have been expanded."	| verbose |	"method preparation"	verbose _ false.	self prepareMethods.	verbose ifTrue: [		self printUnboundCallWarnings.		self printUnboundVariableReferenceWarnings.		Transcript cr.	].	assertionFlag ifFalse: [ self removeAssertions ].	self doInlining: inlineFlag.	"experimental""--- ikp: temporarily disabled for jitter port to 2.3beta-e	self useStructNamed: 'vm' forAllGlobalsExcept: #(		memory interpreterProxy interruptCheckCounter successFlag compilerHooks		maskTable opTable fullScreenFlag interruptKeycode interruptPending savedWindowSize		currentBytecode localIP localSP localHomeContext localMethod localReceiver localCP localTP). ---"	"code generation"	methods _ methods asSortedCollection: [ :m1 :m2 | m1 selector < m2 selector ].	self emitCHeaderOn: aStream.	self emitCVariablesOn: aStream.	self emitCFunctionPrototypesOn: aStream.'Writing Translated Code...'displayProgressAt: Sensor cursorPointfrom: 0 to: methods sizeduring: [:bar |	methods doWithIndex: [ :m :i | bar value: i.		m emitCCodeOn: aStream generator: self.]].! !!CompiledMethod methodsFor: 'accessing' stamp: 'di 1/2/1999 17:00'!flushCache	"Tell the interpreter to remove all references to this method from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.	NOTE:  Only one of two selective flush methods needs to be used.	Squeak 2.2 and earlier uses 119 (See Symbol flushCache).	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."	<primitive: 116>! !!ContextPart methodsFor: 'controlling' stamp: 'di 1/2/1999 15:50'!send: selector to: rcvr with: args super: superFlag 	"Simulate the action of sending a message with selector, selector, and 	arguments, args, to receiver. The argument, superFlag, tells whether the 	receiver of the message was specified with 'super' in the source method."	| class meth val |	class _ superFlag			ifTrue: [(self method literalAt: self method numLiterals) value superclass]			ifFalse: [rcvr class].	meth _ class lookupSelector: selector.	meth == nil		ifTrue: [^ self send: #doesNotUnderstand:					to: rcvr					with: (Array with: (Message selector: selector arguments: args))					super: superFlag]		ifFalse: [val _ self tryPrimitiveFor: meth						receiver: rcvr						args: args.				val == #simulatorFail ifFalse: [^ val].				(selector == #doesNotUnderstand: and: [class == Object]) ifTrue:					[^ self error: 'Simulated message ' , (args at: 1) selector									, ' not understood'].				^ self activateMethod: meth					withArgs: args					receiver: rcvr					class: class]! !!Interpreter class methodsFor: 'initialization' stamp: 'ikp 1/3/1999 17:16'!initialize	"Interpreter initialize"	super initialize.  "initialize ObjectMemory constants"	self initializeAssociationIndex.	self initializeBytecodeTable.	self initializeCaches.	self initializeCharacterIndex.	self initializeClassIndices.	self initializeCompilerHooks.	self initializeContextIndices.	self initializeDirectoryLookupResultCodes.	self initializeMessageIndices.	self initializeMethodIndices.	self initializePointIndices.	self initializePrimitiveTable.	self initializeSchedulerIndices.	self initializeSmallIntegers.	self initializeStreamIndices.	SemaphoresToSignalSize _ 25.! !!Interpreter class methodsFor: 'initialization' stamp: 'ikp 1/3/1999 18:02'!initializeCompilerHooks	"Interpreter initializeCompilerHooks"	"compilerHooks[] indices:	1	bool compilerActivateMethodHook(void)	2	bool compilerFlushCacheHook(CompiledMethod *oldMethod)	3	void compilerPreGCHook(int fullGCFlag)	4	void compilerMapHook(int memStart, int memEnd)	5	void compilerPostGCHook(void)	6	void compilerProcessChangeHook(void)	7	void compilerPreSnapshotHook(void)	8	void compilerPostSnapshotHook(void)	9	void compilerMarkHook(void)"	CompilerHooksSize _ 10.! !!Interpreter class methodsFor: 'initialization' stamp: 'di 1/2/1999 16:52'!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFlushCacheByMethod)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)			"Squeak 2.2 and earlier use 119.  Squeak 2.3 and later use 116.			Both are supported for backward compatibility."		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 primStringfindSubstringinstartingAtmatchTable)		(247 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveInstVarsPutFromStack) "Never used except in Disney tests.  Remove after 2.3 release."		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!Interpreter class methodsFor: 'translation' stamp: 'ikp 1/3/1999 17:15'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'methodCache'		declareC: 'int methodCache[', (MethodCacheSize + 1) printString, ']'.	aCCodeGenerator var: 'atCache'		declareC: 'int atCache[', (AtCacheTotalSize + 1) printString, ']'.	aCCodeGenerator var: 'localIP' declareC: 'char * localIP'.	aCCodeGenerator var: 'localSP' declareC: 'char * localSP'.	aCCodeGenerator var: 'semaphoresToSignal'		declareC: 'int semaphoresToSignal[', (SemaphoresToSignalSize + 1) printString, ']'.	aCCodeGenerator var: 'compilerHooks'		declareC: 'int (*compilerHooks[', (CompilerHooksSize + 1) printString, '])()'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ikp 1/5/1999 16:21'!squeakVirtualMachineFile^'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqVirtualMachine.h"/*** Function prototypes ***//* InterpreterProxy methodsFor: ''stack access'' */int pop(int nItems);int popthenPush(int nItems, int oop);int push(int object);int pushBool(int trueOrFalse);int pushFloat(double f);int pushInteger(int integerValue);double stackFloatValue(int offset);int stackIntegerValue(int offset);int stackObjectValue(int offset);int stackValue(int offset);/*** variables ***/extern int (*compilerHooks[])();extern int setCompilerInitialized(int flagValue);/* InterpreterProxy methodsFor: ''object access'' */int argumentCountOf(int methodPointer);void * arrayValueOf(int oop);int byteSizeOf(int oop);void * fetchArrayofObject(int fieldIndex, int objectPointer);int fetchClassOf(int oop);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);int fetchPointerofObject(int index, int oop);int fetchWordofObject(int fieldIndex, int oop);void * firstFixedField(int oop);void * firstIndexableField(int oop);int literalofMethod(int offset, int methodPointer);int literalCountOf(int methodPointer);int methodArgumentCount(void);int methodPrimitiveIndex(void);int primitiveIndexOf(int methodPointer);int sizeOfSTArrayFromCPrimitive(void *cPtr);int slotSizeOf(int oop);int stObjectat(int array, int index);int stObjectatput(int array, int index, int value);int stSizeOf(int oop);int storeIntegerofObjectwithValue(int index, int oop, int integer);int storePointerofObjectwithValue(int index, int oop, int valuePointer);/* InterpreterProxy methodsFor: ''testing'' */int isKindOf(int oop, char *aString);int isMemberOf(int oop, char *aString);int isBytes(int oop);int isFloatObject(int oop);int isIndexable(int oop);int isIntegerObject(int objectPointer);int isIntegerValue(int intValue);int isPointers(int oop);int isWeak(int oop);int isWords(int oop);int isWordsOrBytes(int oop);/* InterpreterProxy methodsFor: ''converting'' */int booleanValueOf(int obj);int checkedIntegerValueOf(int intOop);int floatObjectOf(double aFloat);double floatValueOf(int oop);int integerObjectOf(int value);int integerValueOf(int oop);int positive32BitIntegerFor(int integerValue);int positive32BitValueOf(int oop);/* InterpreterProxy methodsFor: ''special objects'' */int characterTable(void);int displayObject(void);int falseObject(void);int nilObject(void);int trueObject(void);/* InterpreterProxy methodsFor: ''special classes'' */int classArray(void);int classBitmap(void);int classByteArray(void);int classCharacter(void);int classFloat(void);int classLargePositiveInteger(void);int classPoint(void);int classSemaphore(void);int classSmallInteger(void);int classString(void);/* InterpreterProxy methodsFor: ''instance creation'' */int clone(int oop);int instantiateClassindexableSize(int classPointer, int size);int makePointwithxValueyValue(int xValue, int yValue);int popRemappableOop(void);int pushRemappableOop(int oop);/* InterpreterProxy methodsFor: ''other'' */int becomewith(int array1, int array2);int byteSwapped(int w);int failed(void);int fullDisplayUpdate(void);int fullGC(void);int incrementalGC(void);int primitiveFail(void);int showDisplayBitsLeftTopRightBottom(int aForm, int l, int t, int r, int b);int signalSemaphoreWithIndex(int semaIndex);int success(int aBoolean);int superclassOf(int classPointer);struct VirtualMachine *VM = NULL;static int majorVersion(void) {	return VM_PROXY_MAJOR;}static int minorVersion(void) {	return VM_PROXY_MINOR;}static CompilerHook *compilerHookVector(void) {  return compilerHooks;}struct VirtualMachine* sqGetInterpreterProxy(void){	if(VM) return VM;	VM = (struct VirtualMachine *) calloc(1, sizeof(VirtualMachine));	/* Initialize Function pointers */	VM->majorVersion = majorVersion;	VM->minorVersion = minorVersion;	/* InterpreterProxy methodsFor: ''stack access'' */	VM->pop = pop;	VM->popthenPush = popthenPush;	VM->push = push;	VM->pushBool = pushBool;	VM->pushFloat = pushFloat;	VM->pushInteger = pushInteger;	VM->stackFloatValue = stackFloatValue;	VM->stackIntegerValue = stackIntegerValue;	VM->stackObjectValue = stackObjectValue;	VM->stackValue = stackValue;		/* InterpreterProxy methodsFor: ''object access'' */	VM->argumentCountOf = argumentCountOf;	VM->arrayValueOf = arrayValueOf;	VM->byteSizeOf = byteSizeOf;	VM->fetchArrayofObject = fetchArrayofObject;	VM->fetchClassOf = fetchClassOf;	VM->fetchFloatofObject = fetchFloatofObject;	VM->fetchIntegerofObject = fetchIntegerofObject;	VM->fetchPointerofObject = fetchPointerofObject;	VM->fetchWordofObject = fetchWordofObject;	VM->firstFixedField = firstFixedField;	VM->firstIndexableField = firstIndexableField;	VM->literalofMethod = literalofMethod;	VM->literalCountOf = literalCountOf;	VM->methodArgumentCount = methodArgumentCount;	VM->methodPrimitiveIndex = methodPrimitiveIndex;	VM->primitiveIndexOf = primitiveIndexOf;	VM->sizeOfSTArrayFromCPrimitive = sizeOfSTArrayFromCPrimitive;	VM->slotSizeOf = slotSizeOf;	VM->stObjectat = stObjectat;	VM->stObjectatput = stObjectatput;	VM->stSizeOf = stSizeOf;	VM->storeIntegerofObjectwithValue = storeIntegerofObjectwithValue;	VM->storePointerofObjectwithValue = storePointerofObjectwithValue;		/* InterpreterProxy methodsFor: ''testing'' */	VM->isKindOf = isKindOf;	VM->isMemberOf = isMemberOf;	VM->isBytes = isBytes;	VM->isFloatObject = isFloatObject;	VM->isIndexable = isIndexable;	VM->isIntegerObject = isIntegerObject;	VM->isIntegerValue = isIntegerValue;	VM->isPointers = isPointers;	VM->isWeak = isWeak;	VM->isWords = isWords;	VM->isWordsOrBytes = isWordsOrBytes;		/* InterpreterProxy methodsFor: ''converting'' */	VM->booleanValueOf = booleanValueOf;	VM->checkedIntegerValueOf = checkedIntegerValueOf;	VM->floatObjectOf = floatObjectOf;	VM->floatValueOf = floatValueOf;	VM->integerObjectOf = integerObjectOf;	VM->integerValueOf = integerValueOf;	VM->positive32BitIntegerFor = positive32BitIntegerFor;	VM->positive32BitValueOf = positive32BitValueOf;		/* InterpreterProxy methodsFor: ''special objects'' */	VM->characterTable = characterTable;	VM->displayObject = displayObject;	VM->falseObject = falseObject;	VM->nilObject = nilObject;	VM->trueObject = trueObject;		/* InterpreterProxy methodsFor: ''special classes'' */	VM->classArray = classArray;	VM->classBitmap = classBitmap;	VM->classByteArray = classByteArray;	VM->classCharacter = classCharacter;	VM->classFloat = classFloat;	VM->classLargePositiveInteger = classLargePositiveInteger;	VM->classPoint = classPoint;	VM->classSemaphore = classSemaphore;	VM->classSmallInteger = classSmallInteger;	VM->classString = classString;		/* InterpreterProxy methodsFor: ''instance creation'' */	VM->clone = clone;	VM->instantiateClassindexableSize = instantiateClassindexableSize;	VM->makePointwithxValueyValue = makePointwithxValueyValue;	VM->popRemappableOop = popRemappableOop;	VM->pushRemappableOop = pushRemappableOop;		/* InterpreterProxy methodsFor: ''other'' */	VM->becomewith = becomewith;	VM->byteSwapped = byteSwapped;	VM->failed = failed;	VM->fullDisplayUpdate = fullDisplayUpdate;	VM->fullGC = fullGC;	VM->incrementalGC = incrementalGC;	VM->primitiveFail = primitiveFail;	VM->showDisplayBitsLeftTopRightBottom = showDisplayBitsLeftTopRightBottom;	VM->signalSemaphoreWithIndex = signalSemaphoreWithIndex;	VM->success = success;	VM->superclassOf = superclassOf;		VM->compilerHookVector= compilerHookVector;	VM->setCompilerInitialized= setCompilerInitialized;	return VM;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ikp 1/5/1999 16:20'!squeakVirtualMachineHeaderFile^ '#ifndef _SqueakVM_H#define _SqueakVM_H/* Increment the following number if you change the order of   functions listed or if you remove functions */#define VM_PROXY_MAJOR 1/* Increment the following number if you add functions at the end */#define VM_PROXY_MINOR 1typedef int (*CompilerHook)();struct VirtualMachine* sqGetInterpreterProxy(void);typedef struct VirtualMachine {	int (*minorVersion) (void);	int (*majorVersion) (void);	/* InterpreterProxy methodsFor: ''stack access'' */	int (*pop)(int nItems);	int (*popthenPush)(int nItems, int oop);	int (*push)(int object);	int (*pushBool)(int trueOrFalse);	int (*pushFloat)(double f);	int (*pushInteger)(int integerValue);	double (*stackFloatValue)(int offset);	int (*stackIntegerValue)(int offset);	int (*stackObjectValue)(int offset);	int (*stackValue)(int offset);		/* InterpreterProxy methodsFor: ''object access'' */	int (*argumentCountOf)(int methodPointer);	void * (*arrayValueOf)(int oop);	int (*byteSizeOf)(int oop);	void * (*fetchArrayofObject)(int fieldIndex, int objectPointer);	int (*fetchClassOf)(int oop);	double (*fetchFloatofObject)(int fieldIndex, int objectPointer);	int (*fetchIntegerofObject)(int fieldIndex, int objectPointer);	int (*fetchPointerofObject)(int index, int oop);	int (*fetchWordofObject)(int fieldIndex, int oop);	void * (*firstFixedField)(int oop);	void * (*firstIndexableField)(int oop);	int (*literalofMethod)(int offset, int methodPointer);	int (*literalCountOf)(int methodPointer);	int (*methodArgumentCount)(void);	int (*methodPrimitiveIndex)(void);	int (*primitiveIndexOf)(int methodPointer);	int (*sizeOfSTArrayFromCPrimitive)(void *cPtr);	int (*slotSizeOf)(int oop);	int (*stObjectat)(int array, int index);	int (*stObjectatput)(int array, int index, int value);	int (*stSizeOf)(int oop);	int (*storeIntegerofObjectwithValue)(int index, int oop, int integer);	int (*storePointerofObjectwithValue)(int index, int oop, int valuePointer);		/* InterpreterProxy methodsFor: ''testing'' */	int (*isKindOf)(int oop, char *aString);	int (*isMemberOf)(int oop, char *aString);	int (*isBytes)(int oop);	int (*isFloatObject)(int oop);	int (*isIndexable)(int oop);	int (*isIntegerObject)(int objectPointer);	int (*isIntegerValue)(int intValue);	int (*isPointers)(int oop);	int (*isWeak)(int oop);	int (*isWords)(int oop);	int (*isWordsOrBytes)(int oop);		/* InterpreterProxy methodsFor: ''converting'' */	int (*booleanValueOf)(int obj);	int (*checkedIntegerValueOf)(int intOop);	int (*floatObjectOf)(double aFloat);	double (*floatValueOf)(int oop);	int (*integerObjectOf)(int value);	int (*integerValueOf)(int oop);	int (*positive32BitIntegerFor)(int integerValue);	int (*positive32BitValueOf)(int oop);		/* InterpreterProxy methodsFor: ''special objects'' */	int (*characterTable)(void);	int (*displayObject)(void);	int (*falseObject)(void);	int (*nilObject)(void);	int (*trueObject)(void);		/* InterpreterProxy methodsFor: ''special classes'' */	int (*classArray)(void);	int (*classBitmap)(void);	int (*classByteArray)(void);	int (*classCharacter)(void);	int (*classFloat)(void);	int (*classLargePositiveInteger)(void);	int (*classPoint)(void);	int (*classSemaphore)(void);	int (*classSmallInteger)(void);	int (*classString)(void);		/* InterpreterProxy methodsFor: ''instance creation'' */	int (*clone)(int oop);	int (*instantiateClassindexableSize)(int classPointer, int size);	int (*makePointwithxValueyValue)(int xValue, int yValue);	int (*popRemappableOop)(void);	int (*pushRemappableOop)(int oop);		/* InterpreterProxy methodsFor: ''other'' */	int (*becomewith)(int array1, int array2);	int (*byteSwapped)(int w);	int (*failed)(void);	int (*fullDisplayUpdate)(void);	int (*fullGC)(void);	int (*incrementalGC)(void);	int (*primitiveFail)(void);	int (*showDisplayBitsLeftTopRightBottom)(int aForm, int l, int t, int r, int b);	int (*signalSemaphoreWithIndex)(int semaIndex);	int (*success)(int aBoolean);	int (*superclassOf)(int classPointer);		/* InterpreterProxy methodsFor: ''compiler'' */	CompilerHook *(*compilerHookVector)(void);	int (*setCompilerInitialized)(int initFlag);} VirtualMachine;#endif /* _SqueakVM_H */'! !!InterpreterSupportCode class methodsFor: 'compiler' stamp: 'ikp 1/4/1999 01:36'!comparativeBenchmarks	"InterpreterSupportCode comparativeBenchmarks"	Smalltalk compilerDisable.	self compilerBenchmarks.	Transcript show: '  interpreted'.	Smalltalk compilerEnable.	self compilerBenchmarks.	Transcript show: '  compiled'.! !!InterpreterSupportCode class methodsFor: 'compiler' stamp: 'ikp 1/5/1999 03:43'!compilerBenchmarks	"InterpreterSupportCode compilerBenchmarks"	| r t f b |	f _ SortedCollection new.	5 timesRepeat:		[t _ Time millisecondsToRun: [r _ 30 benchFib].		 f add: r*1000//t].	b _ SortedCollection new.	5 timesRepeat:		[b add: (20000000 * 1000 // (Time millisecondsToRun: [40 benchmark]))].	Transcript cr; print: f; cr; print: b.	f _ (f removeFirst; removeLast; inject: 0 into: [:sum :elt | sum + elt]) // f size.	b _ (b removeFirst; removeLast; inject: 0 into: [:sum :elt | sum + elt]) // b size.	Transcript cr;		show: f printString; tab;		show: b printString! !!InterpreterSupportCode class methodsFor: 'compiler'!primitiveTableDeclaration	"InterpreterSupportCode primitiveTableDeclaration"	| primitives internal external declared |	primitives _ Interpreter initialize; primitiveTable.	internal _ #(		primitiveBlockCopy primitiveDoPrimitiveWithArgs		primitivePerform primitivePerformWithArgs		primitiveValue primitiveValueWithArgs).	external _ Interpreter primitiveTable reject: [:prim | internal includes: prim].	declared _ IdentitySet new.	^String streamContents: [:str |	str	nextPutAll:	'// generated automatically at ';		print:		Time now;		nextPutAll:	' on ';		print:		Date today;		cr;		nextPutAll:	'// DO NOT EDIT!!!!!!';		cr; cr;		nextPutAll:	'#define MaxPrimitiveIndex ';		print:		primitives size - 1;		cr; cr.	internal do: [:prim |		str	nextPutAll: 'extern void ';			nextPutAll: prim;			nextPutAll: '(void);'; cr].	str	cr;		nextPutAll:	'extern "C" {'; cr;		nextPutAll:	'  void primitiveFail(void);'; cr.	external do: [:prim |	(declared includes: prim)		ifFalse: [str	nextPutAll: '  void ';					nextPutAll:	prim;					nextPutAll: '(void);'; cr].	declared add: prim].	str	nextPutAll:	'};'; cr.	]! !!InterpreterSupportCode class methodsFor: 'compiler'!primitiveTableDefinition	"InterpreterSupportCode primitiveTableDefinition"	| primitives |	primitives _ Interpreter initialize; primitiveTable.	^String streamContents: [:str |	str	nextPutAll:	'// generated automatically at ';		print:		Time now;		nextPutAll:	' on ';		print:		Date today;		cr;		nextPutAll:	'// DO NOT EDIT!!!!!!';		cr; cr;		nextPutAll:	'primitive primitiveTable[MaxPrimitiveIndex + 1]= {'; cr.	primitives doWithIndex: [:prim :index |		str nextPutAll: '  '; print: prim.		index == primitives size ifFalse: [str nextPut: $,].		str cr].	str	nextPutAll:	'};'; cr.	]! !!InterpreterSupportCode class methodsFor: 'compiler'!writeCompilerSourceFiles	"Store into this image's directory the C sources files required to support the runtime compiler."	"InterpreterSupportCode writeCompilerSourceFiles"	self storeString: self primitiveTableDeclaration	onFileNamed: 'primitiveTable.decl'.	self storeString: self primitiveTableDefinition		onFileNamed: 'primitiveTable.defn'.! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'ikp 12/18/1998 22:49'!mapPointersInObjectsFrom: memStart to: memEnd	"Use the forwarding table to update the pointers of all non-free objects in the given range of memory. Also remap pointers in root objects which may contains pointers into the given memory range."	| oop |	self inline: false.	self compilerMapHookFrom: memStart to: memEnd.	"update interpreter variables"	self mapInterpreterOops.	"update pointers in root objects"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		((oop < memStart) or: [oop >= memEnd]) ifTrue: [			"Note: must not remap the fields of any object twice!!"			"remap this oop only if not in the memory range covered below"			self remapFieldsAndClassOf: oop.		].	].	"update pointers in the given memory range"	oop _ self oopFromChunk: memStart.	[oop < memEnd] whileTrue: [		(self isFreeObject: oop) ifFalse: [			self remapFieldsAndClassOf: oop.		].		oop _ self objectAfterWhileForwarding: oop.	].! !!Interpreter methodsFor: 'initialization' stamp: 'ikp 12/12/1998 16:09'!initializeInterpreter: bytesToShift	"Initialize Interpreter state before starting execution of a new image."	self initializeObjectMemory: bytesToShift.	self initBBOpTable.	self initCompilerHooks.	activeContext	_ nilObj.	theHomeContext	_ nilObj.	method			_ nilObj.	receiver		_ nilObj.	messageSelector	_ nilObj.	newMethod		_ nilObj.	self flushMethodCache.	self loadInitialContext.	interruptCheckCounter _ 0.	nextPollTick _ 0.	nextWakeupTick _ 0.	lastTick _ 0.	interruptKeycode _ 2094.  "cmd-."	interruptPending _ false.	semaphoresToSignalCount _ 0.	deferDisplayUpdates _ false.	pendingFinalizationSignals _ 0.! !!Interpreter methodsFor: 'utilities' stamp: 'ikp 12/12/1998 14:35'!transfer: count from: src to: dst	| in out lastIn |	self inline: true.	in _ src - 4.	lastIn _ in + (count * 4).	out _ dst - 4.	[in < lastIn] whileTrue: [		self longAt: (out _ out + 4) put: (self longAt: (in _ in + 4)).	].! !!Interpreter methodsFor: 'object memory support' stamp: 'ikp 12/19/1998 17:09'!markAndTraceInterpreterOops	"Mark and trace all oops in the interpreter's state."	"Assume: All traced variables contain valid oops."	| oop |	self compilerMarkHook.	self markAndTrace: specialObjectsOop.		"also covers nilObj, trueObj, falseObj, and compact classes"	self markAndTrace: activeContext.  "traces entire stack"		"also covers theHomeContext, receiver, method"	self markAndTrace: messageSelector.	self markAndTrace: newMethod.	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			self markAndTrace: oop.		].	].! !!Interpreter methodsFor: 'object memory support' stamp: 'ikp 12/12/1998 16:40'!postGCAction	"Mark the active and home contexts as roots if old. This allows the interpreter to use storePointerUnchecked to store into them."	self compilerPostGCHook.	(activeContext    < youngStart) ifTrue: [ self beRootIfOld: activeContext ].	(theHomeContext < youngStart) ifTrue: [ self beRootIfOld: theHomeContext ].! !!Interpreter methodsFor: 'object memory support' stamp: 'ikp 1/3/1999 17:22'!preGCAction: fullGCFlag	self compilerPreGCHook: fullGCFlag.	activeContext == nilObj ifFalse: [self storeContextRegisters: activeContext].! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 12/15/1998 23:19'!activateNewMethod	self inline: true.	self compilerActivateMethodHook		ifFalse: [self bytecodeActivateNewMethod].! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 1/3/1999 17:28'!bytecodeActivateNewMethod	| newContext methodHeader initialIP tempCount nilOop |	methodHeader _ self headerOf: newMethod.	newContext _ self allocateOrRecycleContext.	initialIP _		((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1.	tempCount _		(methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf: initialIP).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	0 to: argumentCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self stackValue: argumentCount-i)].	"clear remaining temps to nil in case it has been recycled"	nilOop _ nilObj.	argumentCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: nilOop].	self pop: argumentCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self newActiveContext: newContext.! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 12/12/1998 14:03'!createActualMessage	| argumentArray message |	argumentArray _		self instantiateClass: (self splObj: ClassArray) indexableSize: argumentCount.	"remap argumentArray in case GC happens during allocation"	self pushRemappableOop: argumentArray.	message _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	argumentArray _ self popRemappableOop.	(argumentArray < youngStart) ifTrue: [ self beRootIfOld: argumentArray ].	self storePointer: MessageSelectorIndex		ofObject: message		withValue: messageSelector.	self storePointer: MessageArgumentsIndex		ofObject: message		withValue: argumentArray."---	ikp: replaced with #transfer:from:to: for optimiser compatibility	self transfer: argumentCount		fromIndex: self stackPointerIndex - (argumentCount - 1)		ofObject: activeContext		toIndex: 0		ofObject: argumentArray.---"	self transfer: argumentCount		from: stackPointer - ((argumentCount - 1) * 4)		to: argumentArray + BaseHeaderSize.	self pop: argumentCount.	self push: message.	argumentCount _ 1.! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 1/3/1999 17:29'!executeNewMethod	primitiveIndex > 0 ifTrue: [		self primitiveResponse.		successFlag ifTrue: [^ nil]].	"if not primitive, or primitive failed, activate the method"	self activateNewMethod.	"check for possible interrupts at each real send"	self quickCheckForInterrupts.! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 12/15/1998 23:07'!internalActivateNewMethod	self inline: true.	compilerInitialized		ifTrue: 			[self externalizeIPandSP.			 self activateNewMethod.			 self internalizeIPandSP]		ifFalse:			[self internalBytecodeActivateNewMethod]! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 1/3/1999 17:30'!internalBytecodeActivateNewMethod	| tmp newContext tempCount argCount |	self inline: true.	tmp _ self headerOf: newMethod.	freeContexts ~= NilContext		ifTrue: [newContext _ freeContexts.				freeContexts _ self fetchPointer: 0 ofObject: newContext]		ifFalse: [self externalizeIPandSP.				newContext _ self allocateOrRecycleContext.				self internalizeIPandSP].	tempCount _ (tmp >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf:			(((LiteralStart + (self literalCountOfHeader: tmp)) * 4) + 1)).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	argCount _ argumentCount.	0 to: argCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self internalStackValue: argCount-i)].	"clear remaining temps to nil in case it has been recycled"	tmp _ nilObj.	argCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: tmp].	self internalPop: argCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self internalNewActiveContext: newContext.! !!Interpreter methodsFor: 'control primitives' stamp: 'ikp 12/15/1998 23:12'!primitivePerform	| performSelector newReceiver selectorIndex lookupClass |	performSelector _ messageSelector.	messageSelector _ self stackValue: argumentCount - 1.	newReceiver _ self stackValue: argumentCount.	"NOTE: the following lookup may fail and be converted to #doesNotUnderstand:,		so we must adjust argument count now, so that would work."	argumentCount _ argumentCount - 1.	lookupClass _ self fetchClassOf: newReceiver.	self findNewMethodInClass: lookupClass.	self success: (self argumentCountOf: newMethod) = argumentCount.	successFlag		ifTrue: [selectorIndex _ self stackPointerIndex - argumentCount.				self transfer: argumentCount					fromIndex: selectorIndex + 1					ofObject: activeContext					toIndex: selectorIndex					ofObject: activeContext.				self pop: 1.				self executeNewMethod.  "Recursive xeq affects successFlag"				successFlag _ true]		ifFalse: [argumentCount _ argumentCount + 1.				messageSelector _ performSelector]! !!Interpreter methodsFor: 'control primitives' stamp: 'ikp 12/15/1998 23:13'!primitivePerformWithArgs	| thisReceiver performSelector argumentArray arraySize index cntxSize lookupClass |	argumentArray _ self popStack.	arraySize _ self fetchWordLengthOf: argumentArray.	cntxSize _ self fetchWordLengthOf: activeContext.	self success: (self stackPointerIndex + arraySize) < cntxSize.	self assertClassOf: argumentArray is: (self splObj: ClassArray).	successFlag		ifTrue: [performSelector _ messageSelector.				messageSelector _ self popStack.				thisReceiver _ self stackTop.				argumentCount _ arraySize.				index _ 1.				[index <= argumentCount]					whileTrue:					[self push: (self fetchPointer: index - 1 ofObject: argumentArray).					index _ index + 1].				lookupClass _ self fetchClassOf: thisReceiver.				self findNewMethodInClass: lookupClass.				self success: (self argumentCountOf: newMethod) = argumentCount.				successFlag					ifTrue: [self executeNewMethod.  "Recursive xeq affects successFlag"							successFlag _ true]					ifFalse: [self pop: argumentCount.							self push: messageSelector.							self push: argumentArray.							argumentCount _ 2.							messageSelector _ performSelector]]	ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'processes' stamp: 'ikp 12/19/1998 03:44'!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now index |	self inline: false.	interruptCheckCounter _ 1000.  "reset the interrupt check counter"	"Mask so same wrap as primitiveMillisecondClock"	now _ self ioMSecs bitAnd: 16r1FFFFFFF. 	now < lastTick ifTrue: [		"millisecond clock wrapped"		nextPollTick _ now + (nextPollTick - lastTick).		nextWakeupTick ~= 0			ifTrue: [nextWakeupTick _ now + (nextWakeupTick - lastTick)]].	lastTick _ now.  "used to detect millisecond clock wrapping"	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500].  "msecs to wait before next call to ioProcessEvents"	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	"signal any pending finalizations"	pendingFinalizationSignals > 0 ifTrue:[		sema _ self splObj: TheFinalizationSemaphore.		(self fetchClassOf: sema) = (self splObj: ClassSemaphore) 			ifTrue:[self synchronousSignal: sema].		pendingFinalizationSignals _ 0.	].	"signal all semaphores in semaphoresToSignal" 	semaphoresToSignalCount > 0 ifTrue: [		1 to: semaphoresToSignalCount do: [:i |			index _ semaphoresToSignal at: i.			sema _ self fetchPointer: index - 1 ofObject: (self splObj: ExternalObjectsArray).				"Note: semaphore indices are 1-based"			(self fetchClassOf: sema) = (self splObj: ClassSemaphore)				ifTrue: [self synchronousSignal: sema]].		semaphoresToSignalCount _ 0].! !!Interpreter methodsFor: 'processes' stamp: 'ikp 12/19/1998 03:46'!transferTo: aProc	"Record a process to be awoken on the next interpreter cycle."	| sched oldProc newProc |	newProc _ aProc.	compilerInitialized ifTrue: [		self pushRemappableOop: newProc.		self compilerProcessChangeHook.		newProc _ self popRemappableOop.	].	sched _ self schedulerPointer.	oldProc _ self fetchPointer: ActiveProcessIndex ofObject: sched.	self storePointer: SuspendedContextIndex ofObject: oldProc withValue: activeContext.	self storePointer: ActiveProcessIndex      ofObject:   sched withValue: newProc.	self newActiveContext:		(self fetchPointer: SuspendedContextIndex ofObject: newProc).	reclaimableContextCount _ 0.! !!Interpreter methodsFor: 'other primitives' stamp: 'ikp 1/4/1999 11:31'!primitiveFlushCacheByMethod	"The receiver is a compiledMethod.  Clear all entries in the method lookup cache that refer to this method, presumably because it has been redefined, overridden or removed."	| probe oldMethod |	oldMethod _ self stackTop.	probe _ 0.	1 to: MethodCacheEntries do:		[:i | (methodCache at: probe + MethodCacheMethod) = oldMethod ifTrue:			[methodCache at: probe + MethodCacheSelector put: 0].		probe _ probe + MethodCacheEntrySize].	self compilerFlushCacheHook: oldMethod.		"Flush the dynamic compiler's inline caches."! !!Interpreter methodsFor: 'other primitives' stamp: 'ikp 12/18/1998 22:51'!primitiveSnapshot	| activeProc dataSize rcvr |	self compilerPreSnapshotHook.	"save the state of the current process and save it on the scheduler queue"	self storeContextRegisters: activeContext.	activeProc _		self fetchPointer: ActiveProcessIndex ofObject: self schedulerPointer.	self storePointer: SuspendedContextIndex		    ofObject: activeProc		  withValue: activeContext.	"compact memory and compute the size of the memory actually in use"	self incrementalGC.  "maximimize space for forwarding table"	self fullGC.	dataSize _ freeBlock - (self startOfMemory).	"Assume: all objects are below the start of the free block"	successFlag ifTrue: [		rcvr _ self popStack.  "pop rcvr"		self push: trueObj.		self writeImageFile: dataSize.		self pop: 1.  "pop true"	].	successFlag		ifTrue: [ self push: falseObj ]		ifFalse: [ self push: rcvr ].	self compilerPostSnapshotHook.! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:02'!compilerActivateMethod	^self cCode: 'compilerHooks[1]()'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:01'!compilerActivateMethodHook	self inline: true.	^compilerInitialized and: [self compilerActivateMethod]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 1/3/1999 18:00'!compilerFlushCache: aCompiledMethod	^self cCode: 'compilerHooks[2](aCompiledMethod)'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 1/3/1999 17:59'!compilerFlushCacheHook: aCompiledMethod	self inline: true.	compilerInitialized ifTrue: [self compilerFlushCache: aCompiledMethod]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:00'!compilerMapFrom: memStart to: memEnd	^self cCode: 'compilerHooks[4](memStart, memEnd)'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:03'!compilerMapHookFrom: memStart to: memEnd	self inline: true.	compilerInitialized ifTrue: [self compilerMapFrom: memStart to: memEnd]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/19/1998 17:08'!compilerMark	^self cCode: 'compilerHooks[9]()'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/19/1998 17:08'!compilerMarkHook	self inline: true.	compilerInitialized ifTrue: [self compilerMark]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:00'!compilerPostGC	^self cCode: 'compilerHooks[5]()'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:04'!compilerPostGCHook	self inline: true.	compilerInitialized ifTrue: [self compilerPostGC]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/15/1998 12:43'!compilerPostSnapshot	^self cCode: 'compilerHooks[8]()'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/15/1998 12:43'!compilerPostSnapshotHook	self inline: true.	compilerInitialized ifTrue: [self compilerPostSnapshot]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:01'!compilerPreGC: fullGCFlag	^self cCode: 'compilerHooks[3](fullGCFlag)'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:03'!compilerPreGCHook: fullGCFlag	self inline: true.	compilerInitialized ifTrue: [self compilerPreGC: fullGCFlag]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/15/1998 13:10'!compilerPreSnapshot	^self cCode: 'compilerHooks[7]()'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/15/1998 13:10'!compilerPreSnapshotHook	self inline: true.	compilerInitialized ifTrue: [self compilerPreSnapshot]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:01'!compilerProcessChange	^self cCode: 'compilerHooks[6]()'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:04'!compilerProcessChangeHook	self inline: true.	compilerInitialized ifTrue: [self compilerProcessChange]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 21:44'!disableCompiler	compilerInitialized _ false! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 21:45'!enableCompiler	"Calling this before loading the compiler will provoke a nullCompilerHook error"	compilerInitialized _ true! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/15/1998 12:44'!initCompilerHooks	"Initialize hooks for the 'null compiler'"	self cCode: 'compilerHooks[1]= nullCompilerHook'.	self cCode: 'compilerHooks[2]= nullCompilerHook'.	self cCode: 'compilerHooks[3]= nullCompilerHook'.	self cCode: 'compilerHooks[4]= nullCompilerHook'.	self cCode: 'compilerHooks[5]= nullCompilerHook'.	self cCode: 'compilerHooks[6]= nullCompilerHook'.	self cCode: 'compilerHooks[7]= nullCompilerHook'.	self cCode: 'compilerHooks[8]= nullCompilerHook'.	compilerInitialized _ false! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/12/1998 17:08'!nullCompilerHook	"This should never be called: either the compiler is uninitialised (in which case the hooks should never be reached) or the compiler initialisation should have replaced all the hook with their external implementations."	self error: 'uninitialised compiler hook called'.	^false! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 12/16/1998 01:35'!setCompilerInitialized: newFlag	| oldFlag |	oldFlag _ compilerInitialized.	compilerInitialized _ newFlag.	^oldFlag! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'ikp 12/15/1998 23:33'!ioForceDisplayUpdate	"no-op"! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'ikp 12/15/1998 23:30'!primStringfindSubstringinstartingAtmatchTable	^self primitiveFail! !!InterpreterSimulatorLSB commentStamp: 'ikp 1/3/1999 22:43' prior: 0!This class overrides a few methods in InterpreterSimulator required for simulation to work on little-endian architectures (such as the x86 family of processors).  To start it up simply use InterpreterSimulatorLSB instead of InterpreterSimulator (see the class comment there for more details).  For example:	(InterpreterSimulatorLSB new openOn: Smalltalk imageName) testNote that the image must have been saved at least once on the local architecture, since the compiled VM performs some byte swapping that the simulator cannot cope with.!!InterpreterSimulatorLSB methodsFor: 'initialization' stamp: 'ikp 12/11/1998 01:35'!nextLongFrom: aStream	"Read a 32-bit quantity from the given (binary) stream."	| bytes |	bytes _ aStream nextInto: (ByteArray new: 4).	^ Integer		byte1: (bytes at: 1)		byte2: (bytes at: 2)		byte3: (bytes at: 3)		byte4: (bytes at: 4)! !!InterpreterSimulatorLSB methodsFor: 'memory access' stamp: 'ikp 12/11/1998 01:35'!byteAt: byteAddress	| lowBits |	lowBits _ byteAddress bitAnd: 3.	^((self longAt: byteAddress - lowBits)		bitShift: (0 - lowBits) * 8)		bitAnd: 16rFF! !!InterpreterSimulatorLSB methodsFor: 'memory access' stamp: 'ikp 12/11/1998 01:35'!byteAt: byteAddress put: byte	| longWord shift lowBits |	lowBits _ byteAddress bitAnd: 3.	longWord _ self longAt: byteAddress - lowBits.	shift _ lowBits * 8.	longWord _ longWord - (longWord bitAnd: (16rFF bitShift: shift)) + (byte bitShift: shift).	self longAt: byteAddress - lowBits put: longWord! !!InterpreterSimulatorLSB methodsFor: 'debug support' stamp: 'ikp 12/11/1998 01:35'!charsOfLong: long	^ (1 to: 4) collect:		[:i | ((long digitAt: i) between: 14 and: 126)					ifTrue: [(long digitAt: i) asCharacter]					ifFalse: [$?]]! !!Symbol methodsFor: 'system primitives' stamp: 'di 1/2/1999 17:00'!flushCache	"Tell the interpreter to remove all entries with this symbol as a selector from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.	NOTE:  Only one of the two selective flush methods needs to be used.	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."	<primitive: 119>! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ikp 12/30/1998 05:16'!compilerDisable	"Smalltalk compilerDisable"	<primitive: 'squeakCompilerDisable' module: 'squeakCompiler'>! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ikp 12/30/1998 05:15'!compilerEnable	"Smalltalk compilerEnable"	<primitive: 'squeakCompilerEnable' module: 'squeakCompiler'>! !CompiledMethod removeSelector: #bePrimitive:!Interpreter initialize!Interpreter removeSelector: #compilerFlushCache!Interpreter removeSelector: #executeNewMethod:!Interpreter removeSelector: #compilerFlushCacheHook!Interpreter removeSelector: #compilerExecuteMethodHook!Interpreter removeSelector: #compilerExecuteMethod!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."!