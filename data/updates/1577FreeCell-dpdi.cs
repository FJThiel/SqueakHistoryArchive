'From Squeak2.6 of 11 October 1999 [latest update: #1559] on 24 October 1999 at 10:14:03 pm'!"Change Set:		FreeCellDate:			19 October 1999Author:			David PennellA Squeak implementation of FreeCell by David Pennell with a number of features added by Dan Ingalls."!AlignmentMorph subclass: #FreeCell	instanceVariableNames: 'board cardsRemainingDisplay elapsedTimeDisplay gameNumberDisplay lastGameLost '	classVariableNames: 'Statistics '	poolDictionaries: ''	category: 'Morphic-Games'!AlignmentMorph subclass: #FreeCellBoard	instanceVariableNames: 'cardDeck lastCardDeck freeCells homeCells stacks target actionSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games'!Object subclass: #FreeCellStatistics	instanceVariableNames: 'sessionWins sessionLosses totalWins totalLosses streakWins streakLosses currentCount currentType window statsMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games'!LedMorph subclass: #LedTimerMorph	instanceVariableNames: 'counting startSeconds '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games'!Object subclass: #PlayingCard	instanceVariableNames: 'cardNo suit suitNo cardForm '	classVariableNames: 'ASpadesLoc CachedBlank CachedDepth CardSize FaceForms FaceLoc FaceSuitLoc MidSpotLocs NumberForms NumberLoc SuitForms SuitLoc TopSpotLocs '	poolDictionaries: ''	category: 'Morphic-Games'!PlayingCard class	instanceVariableNames: ''!AlignmentMorph subclass: #PlayingCardDeck	instanceVariableNames: 'layout stackingPolicy stackingOrder emptyDropPolicy target acceptCardSelector cardDroppedSelector cardDoubleClickSelector cardDraggedSelector seed '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games'!PlayingCardDeck class	instanceVariableNames: ''!ImageMorph subclass: #PlayingCardMorph	instanceVariableNames: 'cardNumber suitNumber '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games'!PlayingCardMorph class	instanceVariableNames: ''!!FreeCell reorganize!('initialization' initialize makeCardsRemainingDisplay makeControlBar makeControls makeElapsedTimeDisplay makeGameNumberDisplay makeHelpButton makeNewGameButton makePickGameButton makeQuitButton makeSameGameButton makeStatisticsButton)('accessing' board currentGame helpText)('actions' cardMovedHome gameLost gameWon help newGame pickGame promptForSeed quit sameGame statistics)('private' buildButton:target:label:selector: wrapPanel:label:)!!FreeCell methodsFor: 'initialization' stamp: 'djp 10/24/1999 19:14'!initialize	super initialize.	Statistics newSession.	orientation _ #vertical.	centering _ #center.	vResizing _ #shrinkWrap.	hResizing _ #shrinkWrap.	self		color: Color green darker;		borderWidth: 2;		addMorph: self makeControls;		addMorph: self board;		newGame.! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/16/1999 17:17'!makeCardsRemainingDisplay	cardsRemainingDisplay _ LedMorph new		digits: 2;		extent: (2*10@15).	^self wrapPanel: cardsRemainingDisplay label: 'Cards Left: '! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/16/1999 16:15'!makeControlBar	^AlignmentMorph newRow		color: Color green darker;		borderColor: #inset;		borderWidth: 2;		inset: 0;		hResizing: #spaceFill; vResizing: #shrinkWrap; centering: #center;		yourself.! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/24/1999 14:38'!makeControls	^self makeControlBar		addMorph: AlignmentMorph newVariableTransparentSpacer;		addMorph: self makeHelpButton;		addMorph: self makeQuitButton;		addMorph: self makeStatisticsButton;		addMorph: self makeGameNumberDisplay;		addMorph: self makePickGameButton;		addMorph: self makeSameGameButton;		addMorph: self makeNewGameButton;		addMorph: self makeElapsedTimeDisplay;		addMorph: self makeCardsRemainingDisplay;		yourself.! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/23/1999 21:27'!makeElapsedTimeDisplay	elapsedTimeDisplay _ LedTimerMorph new		digits: 3;		extent: (3*10@15).	^self wrapPanel: elapsedTimeDisplay label: 'Elapsed Time: '! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/23/1999 22:45'!makeGameNumberDisplay	gameNumberDisplay _ LedMorph new		digits: 5;		extent: (5*10@15).	^self wrapPanel: gameNumberDisplay label: 'Game #: '! !!FreeCell methodsFor: 'initialization' stamp: 'di 10/19/1999 01:12'!makeHelpButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'Help'		selector: #help! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/16/1999 15:05'!makeNewGameButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'New game'		selector: #newGame! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/23/1999 22:46'!makePickGameButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'Pick game'		selector: #pickGame! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/23/1999 21:18'!makeQuitButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'Quit'		selector: #quit! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/17/1999 17:44'!makeSameGameButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'Same game'		selector: #sameGame! !!FreeCell methodsFor: 'initialization' stamp: 'djp 10/24/1999 14:38'!makeStatisticsButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'Statistics'		selector: #statistics! !!FreeCell methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:16'!board	board ifNil: 		[board _ FreeCellBoard new			target: self;			actionSelector: #cardMovedHome].	^board! !!FreeCell methodsFor: 'accessing' stamp: 'djp 10/24/1999 21:36'!currentGame	^self board cardDeck seed! !!FreeCell methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:02'!helpText	^'The objective of FreeCell is to move all of the cards to the four "home cells" in the upper right corner.  Each home cell will hold one suit and must be filled sequentially starting with the Ace.There are four "free cells" in the upper left corner that can each hole one card.  Cards can be moved from the bottom of a stack to a free cell or to another stack.  When moving a card to another stack, it must have a value that is one less than the exposed card and of a different suit.'! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/24/1999 17:19'!cardMovedHome	cardsRemainingDisplay value: (cardsRemainingDisplay value - 1).	cardsRemainingDisplay value = 0 		ifTrue: [self gameWon]! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/24/1999 21:36'!gameLost	lastGameLost _ self currentGame.	elapsedTimeDisplay stop.	cardsRemainingDisplay flash: true.	Statistics gameLost.! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/24/1999 21:35'!gameWon	elapsedTimeDisplay stop.	cardsRemainingDisplay flash: true.	Statistics gameWon.! !!FreeCell methodsFor: 'actions' stamp: 'di 10/19/1999 01:12'!help	| window helpMorph |	window _ SystemWindow labelled: 'FreeCell Help'.	window model: self.	helpMorph _ (PluggableTextMorph new editString: self helpText)				 lock.	window addMorph: helpMorph frame: (0@0 extent: 1@1).	window openInWorld.! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/24/1999 21:37'!newGame	(cardsRemainingDisplay value ~~ 0) ifTrue: [self gameLost].	cardsRemainingDisplay value: 52; flash: false.	self board newGame.	elapsedTimeDisplay reset; start.	gameNumberDisplay value: self currentGame.! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/24/1999 21:37'!pickGame	| seed |	seed _ self promptForSeed.	cardsRemainingDisplay value: 52; flash: false.	self board pickGame: seed.	elapsedTimeDisplay reset; start.	gameNumberDisplay value: self currentGame.! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/23/1999 23:37'!promptForSeed 	| s i |		[s _ (FillInTheBlank request: 'Pick a game number between 1 and 32000').	[i _ s asNumber asInteger] on: Error do: [i_0].	i between: 1 and: 32000] whileFalse.	^i.! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/24/1999 19:20'!quit	self owner == self world 		ifTrue: [self delete]		ifFalse: [self owner delete].	Statistics close.! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/24/1999 21:39'!sameGame	(cardsRemainingDisplay value ~~ 0) ifTrue: [		lastGameLost 			ifNil: [self gameLost]			ifNotNil: [lastGameLost ~~ self currentGame ifTrue: [self gameLost]]].	cardsRemainingDisplay value: 52; flash: false.	self board sameGame.	elapsedTimeDisplay reset; start.! !!FreeCell methodsFor: 'actions' stamp: 'djp 10/24/1999 15:07'!statistics	Statistics display! !!FreeCell methodsFor: 'private' stamp: 'djp 10/16/1999 16:07'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to provide some space around the button"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: Color gray.	a _ AlignmentMorph newColumn		centering: #center;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: Color transparent;		inset: 1.	a addMorph: aButton.	^ a! !!FreeCell methodsFor: 'private' stamp: 'djp 10/16/1999 16:04'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a _ AlignmentMorph newRow		centering: #center;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		inset: 5;		color: Color transparent.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!FreeCell class methodsFor: 'class initialization' stamp: 'djp 10/24/1999 14:50'!initialize	Statistics _ FreeCellStatistics new.! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 17:35'!initialize	super initialize.	orientation := #vertical.	hResizing _ #shrinkWrap.	vResizing _ #rigid.	self height: 500.	borderWidth _ 0.	color _ Color green darker.	self layout.! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/23/1999 22:36'!newGame	cardDeck _ PlayingCardDeck newDeck shuffle.	self		resetBoard.! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/23/1999 22:52'!pickGame: aSeed	cardDeck _ (PlayingCardDeck newDeck seed: aSeed) shuffle.	self		resetBoard.! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/11/1999 16:40'!resetBoard	self 		resetFreeCells;		resetHomeCells;		resetStacks;		changed.! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!resetFreeCells	freeCells do: [:deck | deck removeAllCards]! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!resetHomeCells	homeCells do: [:deck | deck removeAllCards]! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/16/1999 20:06'!resetStacks	| card stackStream stack |	stacks do: [:deck | deck removeAllCards].	stackStream _ ReadStream on: stacks.	[card _ cardDeck deal.	card notNil] whileTrue: [		stack _ stackStream next ifNil: [stackStream reset; next].		stack addCard: card].! !!FreeCellBoard methodsFor: 'initialization' stamp: 'djp 10/23/1999 22:37'!sameGame	cardDeck _ (PlayingCardDeck newDeck seed: cardDeck seed) shuffle.	self		resetBoard.! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/16/1999 18:23'!cardCell	^PlayingCardDeck new		layout: #pile; 		orientation: #vertical;		openToDragNDrop: true;		color: Color transparent;		borderColor: #inset;		borderWidth: 2;		yourself! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/15/1999 15:25'!cellsRow	| row |	row := (AlignmentMorph newRow)		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		color: self color;		addAllMorphs: self freeCells;		addMorphBack: self cellsRowSpacer;		addAllMorphs: self homeCells;		yourself.	^row! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/17/1999 18:25'!cellsRowSpacer	| column |	column := (AlignmentMorph newColumn)		vResizing: #rigid;		hResizing: #rigid;		color: Color transparent;		extent: PlayingCardMorph cardSize;		yourself.	^column! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/16/1999 19:35'!freeCell	| freeCell |	freeCell _ self cardCell.	freeCell 		stackingPolicy: #single;		emptyDropPolicy: #any;		target: self;		cardDroppedSelector: #cardMovedToFreeCell.	^freeCell.! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!freeCells	^freeCells ifNil: [freeCells := (1 to: 4) collect: [:i | self freeCell]]! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/24/1999 02:14'!homeCell	| homeCell |	homeCell _ self cardCell.	homeCell  		stackingPolicy: #straight;		stackingOrder: #ascending;		emptyDropPolicy: #inOrder;		target: self;		cardDroppedSelector: #cardMovedHome;		cardDraggedSelector: #dragCard:fromHome:;		acceptCardSelector: #acceptCard:onHome:.	^homeCell.! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!homeCells	^homeCells ifNil: [homeCells := (1 to: 4) collect: [:i | self homeCell]]! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 18:27'!layout	self 		addMorphBack: self cellsRow;		addMorphBack: self stacksRow.! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/24/1999 03:30'!stack	^PlayingCardDeck new		color: self color;		layout: #stagger;		orientation: #vertical;		openToDragNDrop: true;		stackingPolicy: #altStraight;		stackingOrder: #descending;		emptyDropPolicy: #any;		target: self;		cardDroppedSelector: #cardMovedToStack;		cardDraggedSelector: #dragCard:fromStack:;		acceptCardSelector: #acceptCard:onStack:;		cardDoubleClickSelector: #doubleClickInStack:OnCard:.! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/11/1999 16:41'!stacks	^stacks ifNil: [stacks:= (1 to: 8) collect: [:i | self stack]]! !!FreeCellBoard methodsFor: 'layout' stamp: 'djp 10/16/1999 14:18'!stacksRow	| row |	row := (AlignmentMorph newRow)		vResizing: #spaceFill;		hResizing: #spaceFill;		centering: #topLeft;		color: self color;		yourself.	self stacks do: [:stack |		row 			addMorphBack: AlignmentMorph newVariableTransparentSpacer;			addMorphBack: stack].	row addMorphBack: AlignmentMorph newVariableTransparentSpacer.	^row! !!FreeCellBoard methodsFor: 'private' stamp: 'djp 10/24/1999 02:20'!autoMoveCardsHome	| top |	(self stacks, self freeCells) do: 		[:deck | self homeCells do: 			[:homeCell | deck hasCards ifTrue: [				(homeCell repelCard: deck topCard) ifFalse: 					[(self isPlayableCardInHomeCells: deck topCard) ifTrue: [						self visiblyMove: (top _ deck topCard) to: homeCell.						homeCell acceptDroppingMorph: top event: nil]]]]].! !!FreeCellBoard methodsFor: 'private' stamp: 'djp 10/16/1999 21:24'!isPlayableCardInHomeCells: aPlayingCard	| count | 	" are all cards that could be played on this card if it stayed on the stack present in the	home cells?"	aPlayingCard cardNumber <= 2 ifTrue: [^true].	"special case for Aces and 2's"	count _ 0.	self homeCells do: 		[:deck | deck hasCards ifTrue: 			[deck topCard suitColor ~~ aPlayingCard suitColor ifTrue:				[deck topCard cardNumber >= (aPlayingCard cardNumber-1) ifTrue:					[count _ count + 1]]]].	^count = 2.! !!FreeCellBoard methodsFor: 'private' stamp: 'djp 10/24/1999 00:50'!maxDraggableStackSize: dropIntoEmptyStack	"Note: dropIntoEmptyStack, means one less empty stack to work with.		This needs to be reevaluated at time of drop."	"Not super smart - doesn't use stacks that are buildable though not empty"	| nFree nEmptyStacks |	nFree _ (freeCells select: [:d | d hasCards not]) size.	nEmptyStacks _ (stacks select: [:d | d hasCards not]) size.	dropIntoEmptyStack ifTrue: [nEmptyStacks _ nEmptyStacks - 1].	^ (1 + nFree) * (2 raisedTo: nEmptyStacks)! !!FreeCellBoard methodsFor: 'private' stamp: 'di 10/21/1999 18:16'!visiblyMove: aCard to: aCell	| p1 p2 nSteps |	"Should be tweaked with graduated motion"	owner owner addMorphFront: aCard.	p1 _ aCard position.	p2 _ aCell position.	nSteps _ 10.	1 to: nSteps-1 do: "Note final step happens with actual drop"		[:i | aCard position: ((p2*i) + (p1*(nSteps-i))) // nSteps.		self world displayWorld]! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/24/1999 02:09'!acceptCard: aCard onHome: aDeck	"don't accept multiple cards on a home cell, defer to deck for other cases"	aCard hasSubmorphs 		ifTrue: [^ false]		ifFalse: [^ nil].! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/24/1999 18:31'!acceptCard: aCard onStack: aDeck	" assumes that number of cards was check at drag time, need to reduce count if dropping	into an empty stack"	aCard hasSubmorphs 		ifTrue: [			aDeck ifEmpty: [				(aCard submorphCount+1) > (self maxDraggableStackSize: true)					ifTrue: [^true]]]		ifFalse: [^ nil].	^nil.! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/16/1999 18:19'!cardMovedHome	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [target perform: actionSelector].	self autoMoveCardsHome.! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/16/1999 19:34'!cardMovedToFreeCell	self autoMoveCardsHome.! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/16/1999 19:56'!cardMovedToStack	self autoMoveCardsHome.! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/24/1999 03:29'!doubleClickInStack: aDeck OnCard: aCard	(aCard == aDeck firstSubmorph)		ifTrue:			[freeCells do:				[:freeCell | freeCell ifEmpty:							[self visiblyMove: aCard to: freeCell.							freeCell acceptDroppingMorph: aCard event: nil.							^ aCard]]]! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/24/1999 03:08'!dragCard: aCard fromHome: aCardDeck	^nil		"don't allow any cards to be dragged from a home cell"! !!FreeCellBoard methodsFor: 'actions' stamp: 'djp 10/24/1999 00:46'!dragCard: aCard fromStack: aCardDeck	| i cards |	cards _ aCardDeck cards.	i _ cards indexOf: aCard ifAbsent: [^ nil].	i > (self maxDraggableStackSize: false) ifTrue: [^ nil].	[i > 1] whileTrue:		[(aCardDeck inStackingOrder: (cards at: i-1) 					onTopOf: (cards at: i)) ifFalse: [^ nil].		i _ i-1].	^ aCard! !!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/16/1999 16:21'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/11/1999 15:51'!cardDeck	^cardDeck! !!FreeCellBoard methodsFor: 'accessing' stamp: 'djp 10/16/1999 15:33'!target: anObject	target _ anObject! !!FreeCellStatistics reorganize!('initialization' initialize)('printing' printLosses:on: printOn: printSessionOn: printStreaksOn: printTotalOn: printWins:on:)('actions' changed gameLost gameWon newSession ok reset updateStreakLosses updateStreakWins)('user interface' buildButton:target:label:selector: close color display makeControls makeOkButton makeResetButton makeStatistics statsText stringMorphFromPrintOn:)!!FreeCellStatistics methodsFor: 'initialization' stamp: 'djp 10/24/1999 17:26'!initialize	self reset.! !!FreeCellStatistics methodsFor: 'printing' stamp: 'djp 10/24/1999 18:52'!printLosses: anInteger on: aStream	aStream print: anInteger.	anInteger = 1		ifTrue: [aStream nextPutAll: ' loss']		ifFalse: [aStream nextPutAll: ' losses']! !!FreeCellStatistics methodsFor: 'printing' stamp: 'djp 10/24/1999 16:10'!printOn: aStream	self printSessionOn: aStream.	aStream cr.	self printTotalOn: aStream.	aStream cr.	self printStreaksOn: aStream.! !!FreeCellStatistics methodsFor: 'printing' stamp: 'djp 10/24/1999 18:52'!printSessionOn: aStream	| total |	aStream nextPutAll: 'This session: ',String tab.	self printWins: sessionWins on: aStream.	aStream nextPutAll: ', '.	self printLosses: sessionLosses on: aStream.	total _ sessionWins + sessionLosses.	total ~~ 0 ifTrue: [		aStream nextPutAll: ', '; print: (sessionWins/total*100) asInteger; nextPut: $%].! !!FreeCellStatistics methodsFor: 'printing' stamp: 'djp 10/24/1999 18:54'!printStreaksOn: aStream	aStream nextPutAll: 'Streaks: '; 	tab; tab.	self printWins: streakWins on: aStream.	aStream nextPutAll: ', '.	self printLosses: streakLosses on: aStream.	currentType ifNotNil: [		aStream cr; tab; tab; tab; tab; nextPutAll: 'Current: '.		currentType = #wins ifTrue: [self printWins: currentCount on: aStream].		currentType = #losses ifTrue: [self printLosses: currentCount on: aStream]].! !!FreeCellStatistics methodsFor: 'printing' stamp: 'djp 10/24/1999 18:53'!printTotalOn: aStream	| total |	aStream nextPutAll: 'Total: ';	tab; tab; tab.	self printWins: totalWins on: aStream.	aStream nextPutAll: ', '.	self printLosses: totalLosses on: aStream.	total _ totalWins + totalLosses.	total ~~ 0 ifTrue: [		aStream nextPutAll: ', '; print: (totalWins/total*100) asInteger; nextPut: $%].! !!FreeCellStatistics methodsFor: 'printing' stamp: 'djp 10/24/1999 18:53'!printWins: anInteger on: aStream	aStream print: anInteger.	anInteger = 1		ifTrue: [aStream nextPutAll: ' win']		ifFalse: [aStream nextPutAll: ' wins']! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 19:04'!changed	window ifNotNil: [		statsMorph ifNotNil: [statsMorph contents: self statsText]]! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 19:12'!gameLost	sessionLosses _ sessionLosses + 1.	totalLosses	 _ totalLosses + 1.	currentType = #losses		ifTrue: [			currentCount _ currentCount + 1]		ifFalse: [			currentCount _ 1.			currentType _ #losses]..	self updateStreakLosses.	self changed.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 19:09'!gameWon	sessionWins _ sessionWins + 1.	totalWins	_ totalWins + 1.	currentType = #wins 		ifTrue: [			currentCount _ currentCount + 1]		ifFalse: [			currentCount _ 1.			currentType _ #wins].	self updateStreakWins.	self changed.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 19:21'!newSession	sessionWins _ 0.	sessionLosses _ 0.	currentCount _ 0.	currentType _ nil.	self changed.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 17:15'!ok	window delete.	window _ nil.! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 17:26'!reset	sessionWins 		_ 0.	sessionLosses 	_ 0.	totalWins 		_ 0.	totalLosses 		_ 0.	streakWins		_ 0. 	streakLosses 	_ 0.	currentCount 	_ 0.	currentType		_ nil.	self changed.		! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 17:46'!updateStreakLosses	currentType = #losses ifTrue: [		streakLosses _ streakLosses max: currentCount]! !!FreeCellStatistics methodsFor: 'actions' stamp: 'djp 10/24/1999 17:46'!updateStreakWins	currentType = #wins ifTrue: [		streakWins _ streakWins max: currentCount] ! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 16:49'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to provide some space around the button"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: Color gray.	a _ AlignmentMorph newColumn		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: Color transparent;		inset: 1.	a addMorph: aButton.	^ a! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 19:20'!close	window ifNotNil: [		window delete.		window _ nil].! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 16:42'!color	^Color green darker! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 19:17'!display	| panel |	window ifNotNil: [window activate. ^nil].	panel _ AlignmentMorph newColumn.	panel		centering: #center;		hResizing: #rigid;		vResizing: #rigid;		extent: 250@150;		color: self color;		addMorphBack: self makeStatistics;		addMorphBack: self makeControls.	window _ panel openInWindowLabeled: 'FreeCell Statistics'.! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 16:56'!makeControls	| row |	row _ AlignmentMorph newRow.	row		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: self color;		borderWidth: 2;		borderColor: #inset;		addMorphBack: self makeOkButton;		addMorphBack: self makeResetButton.	^row.! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 16:34'!makeOkButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'OK'		selector: #ok! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 17:07'!makeResetButton	^self		buildButton: SimpleButtonMorph new		target: self		label: 'Reset'		selector: #reset! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 19:10'!makeStatistics	| row |	row _ AlignmentMorph newRow.	row		centering: #center;		hResizing: #spaceFill;		vResizing: #spaceFill;		color: self color;		borderWidth: 2;		borderColor: #inset;		addMorphBack: (AlignmentMorph newColumn			centering: #center;			color: self color;			addMorph: (statsMorph _ TextMorph new contents: self statsText)).	^row.! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 19:04'!statsText	^ String cr,self printString,String cr! !!FreeCellStatistics methodsFor: 'user interface' stamp: 'djp 10/24/1999 15:56'!stringMorphFromPrintOn: aSelector		^StringMorph new 		contents: (String streamContents: [:s | self perform: aSelector with: s]);		yourself.! !!FreeCellStatistics class methodsFor: 'instance creation' stamp: 'djp 10/24/1999 17:03'!new	^super new initialize! !!LedTimerMorph reorganize!('accessing' reset start stop)('initialization' initialize)('stepping' step stepTime updateTime)!!LedTimerMorph methodsFor: 'accessing' stamp: 'djp 10/23/1999 21:46'!reset	startSeconds _ Time totalSeconds.	self value: 0.! !!LedTimerMorph methodsFor: 'accessing' stamp: 'djp 10/23/1999 21:35'!start	counting _ true! !!LedTimerMorph methodsFor: 'accessing' stamp: 'djp 10/24/1999 01:13'!stop	counting _ false.	self updateTime.! !!LedTimerMorph methodsFor: 'initialization' stamp: 'djp 10/23/1999 21:43'!initialize	super initialize.	counting _ false.	startSeconds _ Time totalSeconds.! !!LedTimerMorph methodsFor: 'stepping' stamp: 'djp 10/24/1999 01:12'!step	flash		ifTrue: [super step]		ifFalse: [			counting ifTrue: [self updateTime]]! !!LedTimerMorph methodsFor: 'stepping' stamp: 'djp 10/23/1999 21:27'!stepTime	^ 1000! !!LedTimerMorph methodsFor: 'stepping' stamp: 'djp 10/24/1999 01:12'!updateTime	self value:  Time totalSeconds - startSeconds.	self changed! !!PlayingCard commentStamp: '<historical>' prior: 0!This class assembles card images from their parts.  The images are broken down so that the image data is very compact, and the code is written to display properly at all color depths.  The method imageData may be removed after initialization to save space, but must be re-built prior to fileOut if you wish to retain the images.To use in morphic, one can simply put these forms into ImageMorphs (see example in buildImage).  However it should be possible to define a subclass of ImageMorph that simply creates playingCard instances on the fly whenever the image form is needed.  This would avoid storing all the images.!!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:38'!blankCard 	CachedDepth = Display depth ifFalse:		[CachedDepth _ Display depth.		CachedBlank _ Form extent: CardSize depth: CachedDepth.		CachedBlank fillWhite; border: CachedBlank boundingBox width: 1.		CachedBlank fill: (0@0 extent: 2@2) fillColor: Color transparent.  "Round the top corners"		CachedBlank fill: (1@1 extent: 1@1) fillColor: Color black.		CachedBlank fill: (CachedBlank width-2@0 extent: 2@2) fillColor: Color transparent.		CachedBlank fill: (CachedBlank width-2@1 extent: 1@1) fillColor: Color black].	^ CachedBlank! !!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:31'!buildImage     "(PlayingCard the: 12 of: #hearts) cardForm display"	"World addMorph: (ImageMorph new image: (PlayingCard the: 12 of: #hearts) cardForm)"	"PlayingCard test"	| blt numForm suitForm spot face ace sloc colorMap fillColor |		"Set up blt to copy in color for 1-bit forms"	blt _ BitBlt toForm: cardForm.	fillColor _ self color.	colorMap _ (((Array with: Color white with: fillColor)				collect: [:c | c pixelWordForDepth: cardForm depth])					 as: Bitmap).	blt copy: cardForm boundingBox from: 0@0 in: self blankCard.  "Start with a blank card image"	numForm _ NumberForms at: cardNo.  "Put number in topLeft"	blt copyForm: numForm to: NumberLoc rule: Form over colorMap: colorMap.	suitForm _ SuitForms at: suitNo*3-2.   "Put small suit just below number"	sloc _ SuitLoc.	cardNo > 10 ifTrue:		[suitForm _ SuitForms at: suitNo*3-1.   "Smaller for face cards"		sloc _ SuitLoc - (1@0)].	blt copyForm: suitForm to: sloc rule: Form over colorMap: colorMap.	cardNo <= 10	ifTrue:		["Copy top-half spots to the number cards"		spot _ SuitForms at: suitNo*3.   "Large suit spots"		(TopSpotLocs at: cardNo) do:			[:loc | blt copyForm: spot to: loc rule: Form over colorMap: colorMap]]	ifFalse:		["Copy top half of face cards"		face _ FaceForms at: suitNo-1*3 + 14-cardNo.		blt colorMap: self faceColorMap;			copy: (FaceLoc extent: face extent) from: 0@0 in: face].	"Now copy top half to bottom"	self copyTopToBottomHalf.	cardNo <= 10 ifTrue:		["Copy middle spots to the number cards"		(MidSpotLocs at: cardNo) do:			[:loc | blt copyForm: spot to: loc rule: Form over colorMap: colorMap]].	(cardNo = 1 and: [suitNo = 4]) ifTrue:		["Special treatment for the ace of spades"		ace _ FaceForms at: 13.		blt colorMap: self faceColorMap;			copy: (ASpadesLoc extent: ace extent) from: 0@0 in: ace]	! !!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:31'!cardForm	^ cardForm! !!PlayingCard methodsFor: 'all' stamp: 'di 10/15/1999 09:12'!color	CachedDepth = 1 ifTrue: [^ Color black].	CachedDepth = 2 ifTrue: [^ Color perform: (#(black gray gray black) at: suitNo)].	^ Color perform: (#(black red red black) at: suitNo)! !!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:30'!copyTopToBottomHalf	"The bottom half is a 180-degree rotation of the top half (except for 7)"	| topHalf corners |	topHalf _ 0@0 corner: cardForm width@(cardForm height+1//2).	corners _ topHalf corners.	(WarpBlt toForm: cardForm)		sourceForm: cardForm;		combinationRule: 3;		copyQuad: ((3 to: 6) collect: [:i | corners atWrap: i])		toRect: (CardSize - topHalf extent corner: CardSize).	! !!PlayingCard methodsFor: 'all' stamp: 'di 10/14/1999 20:17'!faceColorMap	| map |	map _ Color colorMapIfNeededFrom: 4 to: Display depth.	^ map! !!PlayingCard methodsFor: 'all' stamp: 'di 10/18/1999 23:23'!setCardNo: c suitNo: s cardForm: f	cardNo _ c.	suitNo _ s.	cardForm _ f.	self buildImage! !!PlayingCard class methodsFor: 'all' stamp: 'di 10/13/1999 17:26'!imageData ^ 'AgQALwAlAAAAAIDjaN4VEeFDEREREBIiIiIiIiIiIYiBiIGIgYiIiIgSIiIiEBIiIiIREiIiIhgRGBEYERiBiIEiIiIiEBIiIiERESIiIiFEREREREQRGBIiIiIiEBIiIhERERIiIiIRERERERFEQSIiIiISEBIiIhERERIiIiIRERERERERESIiIiEREBIiIhERERIiIiESIiIiISERESIiIhIUEBIiIiERESIiIhISIiIiISEhESIiIhIUEBIiERIREhESIhIRESERESEhISIiIhIUEBIhERERERERIhEREhESESEhISIiIhIUEBIREREREREREhISIhIiISEhISIiIhIUEBIREREREREREhISIhIiISEhISIiIhIUEBIREREREREREhISIhIiISEhISIiIhIUEBIhEREhIRERIhISIREiISEhISIiIhIUEBIiERIKISIREuIfIhEhISEhESIiEhQQEiIiIhESIiIhERIhESIhISEhIhIiEhQQEiIiIRERIiIiEhIiIiIhISISEhEiEhQQEiIiIiIiIiIREhISIhIRISERIRQREhQQEiIiIiIiIiEiEhISEhISESEhIUREEhQQEiIiIiIiIiEhIhISEhIRISIhFIREEhQQEiIiIiIiEREiISEhQSEiFBEUSIREEhQQEiIiIiERERERERQURBQRREQURESBEhQQEiIiERRBiBEhGBFERERERBFIREQSEhQQEiIhREREGIEREYERREREERSIRIEiEhQQEiEUJCQkIYgRIYGBEUQRGBRERBIhEhQQEhEURERERBiBERgYERERgUREgSIREhQQFBESQkJCQkGIERgYgREYgUhEQSEREhQQFBEUREREREEYQRGBGBGBFIhEEiEREhQQFBEUJCQkJCERhBGBiIiIFERIEhFBEhQQFBEUREQREUEUGBEYERQRFEREEhEREhQQEYgRQkEiIhEREYEYGIiIFISBIhFBEhQQGIiBRBIhEiEUQYEYERQRSIRBIREREhQQEYgRFBIUQSERERgRgYiBRESBIRERERQQERERERIUQSEURBgRgRQRRERBIREiEiEQEUQRERIhEiERERGBgYiBRISBIRIiIREQEREREREiIhERERERERERSIRBIRIRIiEQESISIREREUQSIiFEQRERFESBIRIiEREQBAAvACUAAAAAgONk3hURExERERAYiIiIiIQRQhISESEJIuNPIiIiEBGIiIiIhBFCESEhESIiIiIiIhESIiIiEBIYiIgRhBFCEiESESIiIiIiIRERIiIiEBIhiIgYRBFCEhIhISIiIiIiEREREiIiEBIhiIiEQRRCESIiERIiIiIiEREREiIiEBIiGIiEQRQiEiIiIRIiIiIiEREREiIiEBIiGBGEERQiERIREUEiIiIiIRERIiIiEBIiGBhEEUQhIRIhEUEiIiIREhESERIiEBIhiIRBEUIhIiEiIRQSIiEREREREREiEBIhiIRBFEISIiEiIRQSIhERERERERESEBIYEUQRRCISIiEiIRFBIhERERERERESEBGIFEERQiEiIhESIUFEEhERERERERESEBIRRBEUQiEiIiIiIUQUQSERESEhEREiEBIiERFEIhQSIhESERQRRBIREiEiERIiEBIiIRFCIhFBIiEiERFBFEEiIhESIiIiEBIiERRCIRgREiIhgREUEUQSIRERIiIiEBIhEUQhFISBgREYFIhBRBFBIiIiIiIiEBIRFEISIUhEgYGESIQSFEEUEiIRIiIiEBERQRERERSIRERIiEEREUQUEiFEESIiEBEUiIERESEUiIiIRBISGBQUEhQRRBIiEBGIGIgSISIRFBEUESIRgYFBIUREQSIiEBiIgYGBISERIURBIREYiBESIhEUEhESEBRERBiIEREhIUhBISGBgRGBIiIhIYiBEBREREGIGBEhIURBIRiIFBGBEhESGIESEBREREQRiIgRERQREYGBRBGBEYiBEREiEBgYGBREEYGIiBEYiIERhBGBGIgSEiISEBGBgYGBRBEYiIiIgRERhEEYERESIRESEBgYEREREUSBERERERgRhEERRBQRISISEBGBGIiIiBFEgREYEYEYREQUIkERERESEBgYiBERGIgUQRERgYEYREGBQkQUEiISEBGIERgYERiBSBERGBEYRBiBFERBEREiEBQRGBgYGBGIFBERgYEYRBgYgUIkFBIiEBRBGBEREYgYFIEYERgYQYgRERQkQREiEBQkEUREQREYgUGBEREYQYGIFEFERBQSEBQiQUIiRBiBgRERGIEREYERFCIUIkEREBFERBIRJBERgURBREQYgYGIFCEhQkQUEAQALwAlAAAAAIDjaN4VEeE/EREREBIiIiEUFEFEQUFEFBREFBIiIiIiIiIiEBEiIiIRQUQUQUFEFBRBQSIiIhESIiIiEBQSIiIhFBRBEUERFBEUEiIiIRERIiIiEBRBIiIiFERERERERERBEiIiEREREiIiEBREEiIiERERERERERERIiIiEREREiIiEBERESIiGBIiIiIhgYGBIiIiEREREiIiEBiIEiIiGBIiIiIhgYGBIiIiIRERIiIiEBGIEiIiGBERIREhgYGBIiIREhESERIiEBiIEiIiGBESERIRgYGBIiEREREREREiEBGIEiIiGBIiEiIhgYGBIhERERERERESEBiIEiIhGBIiEiIhgYGBIhERERERERESEBGIEiIYGBIiEiIhgYGBIhERERERERESEBiIEiIYGBIhESIhgYGBEiERESEhEREiEAoRGBIi4iMiIiGBgRiBIhESISIREiIQGIgSIYgYISERIiGBEYgRIiIiERIiIiIQERgSIYGIESIiIhGBiBERESIhEREiIiIQGIgSIYiBFBIiIUGBGBESEhIiIiIiIiIQGIgRIhEUFEERFEQYiBEhEkESIiIiIiEQEYEiEUFBFERBFEQREREYEkRBEiIiIhgQEhIiIRQUFIhBEUESIRIYEkSEIRIiIYgQERERIUFBFERBIREiESGIEkiIQhERGIgQEiESIRQUFIhBIhIhEhiIEohIghERGIgQERgSIUFBFERBEiIRIYgREkiIQhERGIgQEhgSIRQUFIhBESESQYiIEkSEQhERGIgQEYgSIUFBFERBIREkGIEREkREQhERGIgQEhgSFBQRFIhBEhIRiIiIEkSEQhERGIgQEYgREUERFERBQSFBgYEREkiIQhERGIgQGIgRERERSIQYFBQYiIiIEohIghERGIgQGIgRIREhREQRgUGBgREREkiIQRFEGIgQGIgSIhIhSIQYiBiIiIiIEkSEQUSIGIgQGIgSEiIRREQREYgYEREREhERREREGIgQGIgRISEhSIQYiIiIiIiIESIUSIREGIgQGIgSEhIRREQRhBgRGBSBIiFEREQRGIgQGIgRISEkiEGIgUEiIUESIiFIhEESGIgQGIgSEhIUREEYiBIREhIiIhRERBISGIgQGIgRISEUiEGBESFEQSEiIRSIQSEhGIgQBAAvACUAAAAAgONg3hUR4dsREREQEiIiIiIiIhiIgYiBiIiIiIiIgSIiIiIQEiIiIkIiIiGIERgRGIGIiIiIEiIREiEQEiIiJEQiIiIURERESBEYgYiBIiGBIhQQEiIiRERCIiIRERERFERIERgRIhiBIhQQEiIpRERJIiIhEREREREUREQSIhiBIhQQEiKUREREkiIhIiIiESERERESIYgSEREQEiKUREREkiIhIRIiEhIRERESIYEiQkIQEiRERERERCIhESEiEhISEhISIRIiQkIQEkREREREREImIiIiEhISEhISIYEiEhIQEiRERERERCISIiIiEhISEhISIYgSEREQEiKUREREkiEiIiIiEhISEhISIhiBIhQQEiKUREREkiEWIiIiISEhISEhIhiBIhQQEiIpRERJIiIhERISISEhISEhIiGBIhQQEiIiRERCIiIhIhESIhISEhISEiIREhQQEiIiJEQiIiIiESIiIiEhISEhISIiIhQQEiIiIkIiIiIhIiIiERIhISEhISIiIhQQEiERIiIiIiIhEiIhIiEhISEhISIiIhQQEhISERIiIhEhIiIhIRIhISEhISIiIhQQEhEhISEiISESIiIhEiISEhISEiIiIhQQERISEhISISIiIiIiCRFbIiIUEBEhISIiIRgSIiIRERERiBIiGIEiEREREBISEiIhERGBEREREREhGIEhEYgSIYgSEBIhIhERFEEYERRBERIRIYgREhiBIRiBEBIiEUEYFEERgUFEEQkR4ScRIYIQEhFEREGBEhGBRBQRiIiIiIiIiBEREREQEUREQRgYEUQRFEESEhISEhISIYEREREQFERBGIiBgUQYERIiIiIiIiIiGBRBEiEQFEEYiIERGBEYEiIRERERERIhgYFEESEQFBiIgRERGBIYEhGIiIiIiBIYEUgUQREQEYiBEREhGBEYEYgRERERgSGBiBSBRBEQGIgRESIhEYERGBERREQYEiGBGIFIFEEQGIFEERIiEYERgRFEREQYEhgREYEREREQGBQUQREiEYERgRERERGBIhgRERSBSBQQEYhBRBESERgRgUREREGBIYERGBSBSBQQEUiEFEERIRgRgRERERgSIYEUSBQREREQFEFIhBERERERGBIiIhgRERERERSIQUQQBAAvACUAAAAAgONo3hUR4bsREREQEhiIiIiIFEEiEhIRgSIiIiIiIiIiIiIQEiGIiIEYFEEhISEhiBIiIiIiIkIiIiIQEiGIiIiIFEEiIRIRGBIiIiIiJEQiIiIQEiIYiIEYFEEiEiEhEYEiIiIiRERCIiIQEiIYiIiBFBIRIiIRERgSIiIpRERJIiIQEiIYiBGBRBEiIiIhQRgSIiKUREREkiIQEiIYiIgRQSIREhERQRGBIiKUREREkiIQEiIYgRgUQSEhESERRBGBIiRERERERCIQEiIYiIEUESIiISIhRBEYEkREREREREIQEiGIEYFEEhIiISIhREEYEiRERERERCIQEiGIiBFBISEiISIhREEYEiKUREREkiIQEhiBgRRBIRIiERIhREEYEiKUREREkiIQEiGIEUQSISIiIiIhREQRgSIpRERJIiIQEiIRFEEiFBIiERIYFEQRgSIiRERCIiIQEiIhRBIiEUEiISIYEUQRgSIiJEQiIiIQEiIUQSIhiBESIiGIEhQRgSIiIkIiIiIQEiFEERESGIgRERGIEhERgSIiIiIiIiIQEhRBEhERIREYiIERIRERgSIiIhESIiIQEUQRIQohERIi4acREhGBIiIRiBEiIhAUQSESERERESIiIhESERgRIiIYEYgSEhAUGBIRESESEREREREhIRGBIiGIiIEiERAREYEhEREhIRESERESERIYEiIRGBIhgRARGBgSEREhISEhISERESGIESIiIRIYgRARgRGBIhESEREhIREREhiBERIiIhGBEhAYEUEYESERERESERESIYGBEhEiIRERIhARFBGBiBEYERERERIhGBGBIRESEiIREhARQRgUEYgRESIiIiEYgRGBIRERIhESEhAUEYERQhGIgRERERiBEUGBIREYEiEhEhARGBFBFCERGIiIiIEYEUGBEhGIESISEhARgRgUEUJBgRERERiIEUIYERiBERISEhAYERgRQSQhGBERGIEYEUIYgYgSEhEhIhASEhGBQUJCGBJBGIiIEUJBiIERERESIhARERGBQSQhGBJBGBEYEUEUGBESEhIRIhASEhIYEUJCGBJBGIiIERRBgRgREREREhAREREYFCQhGBERERERREhBgUGBEhISERASEhIRgUJCGBREREREiIQYESQYERERERAEAC8AJQAAAACA42neFRHjZxERERASIiIiIhQkRCRCRCRCRCQRIiIiIiIiIhASIiIiIiFCRCRCRCRCQkESIiIiQiIiIhASIiIiIiIUIiRCIiRCJBEiIiIkRCIiIhARIiIiIiIhRERERERERBIiIiJEREIiIhAREiIiIiIhERERERERERIiIilEREkiIhARgSIiIiIhERGBIiIiIhEiIpRERESSIhARgSIiIiIhEYGBIiIiIhEiIpRERESSIhARgSIiIiIhgYGBIREhERgSJEREREREIhARgSIiEiIhgYGBEhESERgSREREREREQhARgSIhEiIhgYGBIiISIhgSJEREREREIhARgSEYEiIhgYGBIiISIhgSIpRERESSIhARERiBIiIhgYGBIiISIhgSIpRERESSIhAUiIERIiIhgYGBIiERIhgSIilEREkiIhARgRESIiIhgYGBIiIiIhgREiJEREIiIhAUgRIiIiEYgYGBIiERISgYgSIkRCIiIhARgSIiIhiBgYGBEiIiIRiBgSIiQiIiIhAUgSIiIhgRgRgUISIiEkGIgSIiIiIiIRARgSIiIhiIGIFERBERREQRERIiIiIiFBAUgSIiIhERERFEREREREESGBESIiIhgRARgSIiEUERIRERREREQRERGBIREiIhhBAUgSIRGBQRESEREREREREhGBEYgRIhgRARgREREYFBEREhERERESERGBIYgUERhBAUgRERERgUERERISEhIRFBGBERgURBgRARgRFBERGBQREREREREUFBGIEhiBFBhBARESEUEREYFBFBQUFBQUFBIYERGIgRgRASISGBQRERgUEUhISEhISBIYgSERiBhBARESEYFBERGBQRQUFBQUFBIRiBEhERgRASIRGBgUEREYFBEUFBQUFBIRGIgREhhBAREUQYERgRERgUEUFBQUFBIRIRiIERgRASESQYGIFBERGBQRSEhISBIRISEYiBhBARgURBgRFIEREYFBFBQUFBIRIRgRERgRARgSJBgYFIQRERgUERQUFBIRIREYFBhBAUgURBgRFISBEhGBQRQUFBIRIYgYEhgRARgSJBgYFIQRERFIFBFISBERIRGBRBhBAUgURBgRFIESERhEgUEUFBERGIGBQhgRARgSJBgYFBEREUGESBQRQRIRERgURBhBAEAC8AJQAAAACA42neFRHjZxERERASIiIiIiIiIhgYiBiIGIgYiIiBIiIiIhASIkRJIilEQiERgRGBEYERgRgSIiIiIhASJEREkpRERCIYiIiIiIiBiBEiESIiIhASREREQkREREIhREREREiIiBIhiBIiIhASREREREREREIhERERERRERBIhiBESIhASREREREREREIhIiIiIhERERERgSIRIhASREREREREREIhIiIiIhISEhIhgSIYEhASlERERERERJIRERIRERISEhEYgREYEhASKURERERESSEhESERIRISEhEYgRIhIhASKURERERESSEhIiEiIhISEhIYgSIhIhASIpREREREQiEhIiEiIhISEhIhERERIhASIiREREREIiEhIiEiIhISEiEiFERBIhASIiJERERCIhISIhESIiEhISEhEREREhASIiIkREQiIhISIiIiIiEiEhIRQUFBQRASIiIiREIiIiESEhESIiISEhIUREREERASIiIiJCIhEREiEiIiISEhISIRRERBIhASIiIiIiERQRIhISIhISEhIiEiERQSRBASIiIiERERFBESISEhIREiIRISIhEUQRASIiIRFBIhFEEhEiEhIhIREiIiEUERERASIhEiFBIiEUQRIhEhEhiBIhIhQUGBERASERISFBISIRRBEYESEYiBISIUgUERgRARiEEhIUEhIhRBGBgRiIgSIiFIFBERGBAYREESIUEiIhFEEYEYiIgRIiGEFBgRERAUQRERIhQSEiFEQRGIiIgSIhhBQRSIERAUEREUEhRBISEUQRiIiIEiEhQUQREYgRARgRFEQSFEEiIURBiIiBEhIhFEERFEiBAYRIERRBIURBIRQYiIgUEiIRRBERRESBAUSIhBEREhFEESEYiIgRIhFEEREUSEGBAUiIFIgRESIREREREREREUQRERFEREiBAYiBQRGBEREiIiRERERERBERERRIQYgRAYiBSIiBgSIiQRERERERESEREURESIgRAYiBQRGBgSIiIiIhREQSIiERFEhBiIERAYiBSIiBgSIiIiERJEQSEhERSERIiBERARiIFIgRERERERIRERQRIREREUGIgRFBARGIiBERERESIhGIiIESIREUQYiIERQRAUEYEREYiIgSIhGBQYEiEhiIiIiBERRBAEAC8AJQAAAACA42neFRHjZxERERASIiIiIiIRISEiERSIiIEiIiIiIiIiIhASIiIiIiESEhISERSBiBIiREkiKURCIhASIiIiIhERIRIiERSIiBIkRESSlEREIhASIiIiIhgSEiEiIRSBgSJERERCREREQhASIiIiIRgRIiIRIRRIgSJEREREREREQhASIiIiIYQSIiIiERFIgSJEREREREREQhASIiIiEYQRESERIRFEiBJEREREREREQhASIiIiGEQREhESEREUSBKUREREREREkhASIiIhGEQSIhIiISERQSIpRERERERJIhASIiIhhEgSIhIiISEREiIpRERERERJIhASIiIhhEgSIhIiISIRESIiRERERESSIhASIiIhhEgSIREiIhIRERIiJEREREQiIhASIiIYRIgSIiIiIhIhEREiIkREREIiIhASIiIYRIERIREiIYEiERESIiRERCIiIhASIiIYRBGBIhIiGIEiIREREiJEQiIiIhASIiIYQYEYEiIhiBESIhERERIkIiIiIhASIiIYEoERgREYgRGBIiERERIiIiIiIhASIiIRghgRGIiBERgSEiIRESIiESESIhASIiEYGEKBEREREYQoERIiEiIhiBiBIhASIhiIgYIYgREYiBKBEREREiIhhEQSIhASIRGBGBhCGIiBJIgRESIiISIiGEiBIhASGIiIiIGIhCFIiBEhEiEhIRIREYgSEhARERgRGIERGIiBERgRISIiFEGIgRGBEhAYiIiIiBEiEREYERgRIiIRRBiIEiEYEhAREYERGBISERERgYESEhFEERERIiGIEhAYiIiIgRIRESIRgYESIURBiIEhERGBIhARgYERgREhEiEhGBEhIUQYREEhQSESIhAYiIiIgSEhQRIhGBEiFEGESEESESESIhARGBgRgREhhEEiGBISFEGERBESEhIhIhAYiIiIgRIRiEQSERIhRBhEhBEhEhIhIhARgREYESEYGIQRERIhRBhERBIREiERIhAYiIiIESEYEYQRiBERRBhIRBISEiIUEhARgRiBESEYQYhBEYiBFBhEERIREhFEQRAYiIgUERIYQYRBgREYgRERRBEhEURERBAREYFEEhIYEYhBgYiBGIFESBISFEREQRAYiBREESEYGIQYGERIERRIiBESFERBGBAEAC8AJQAAAACA42jeFRHiZxERERASIiIiIhRCREJCRCQkRCQSIiIiIiIiIhARIhESIiFEJEJCRCQkQkEiREkiKURCIhAUEiGBIiIUQiJCIiQiJBEkRESSlEREIhAUEiGIEiIUREREREREQRJERERCREREQhAUEiGIEiIRERERERERERJEREREREREQhARERIYgSIhgYGBgSIiISJEREREREREQhASQkIhgSIhgYGBgSIRISJEREREREREQhASQkIiESIYGBgYEhEhISKUREREREREkhASEhIhgSIYGBgYEiIiJiIpRERERERJIhARERIYgSIYGBgYEiIiIhIpRERERERJIhAUEiGIEiIYGBgYEiIiIiEiRERERESSIhAUEiGIEiIYGBgYEiIRJhEiJEREREQiIhAUEiGBIiIYGBgYEhESISIiIkREREIiIhAUEhESIhEYGBgYEiIiISIiIiRERCIiIhAUEiIiIYiBGBgYEiIhESIiIiJEQiISIhAUEiIiGIGBgYEYEiIiISIiIiIkIhFBEhAUEiIiGBiBgYGBREIiIREREiIiIhREEhAUEiIiGIEYgYEUREQRGIGIgSIiIiFBIhAUEiIiIYiIGBFEREREQYgRgSIiERFBIhAUEiIiIREREYgRREREQRiIgSIhIiFBIhAUEiIhFCQYiIiIERERiIGIESISIiIREhAUEiERERQhGIiIiIiIiIgRJBESIRISEhAUERIkQREUIRGIiIiIgREkRBERIhEREhAUFEIiJEERFCQRERERFCREERFEEiEiEhARERRCIiRBERQkJCQkJEQREUQiIREREhAYiBEUQiIkQQoRFBER4PtEIiJBESEiEBiBiIEUQiIkQRFBIiFBEUQiIkQRIhEiEBgYiBiBFEIiJEEUEhQRRCIiRBGBISESEBERgYhBERRCIiQRQUEUIiJEEYiBIiIREBIiGIQRiIEUQiJBFBFCIiQRiIiBISEREBEiIUEYiIiBRCIkERQiJEGIiIiBIiIREBIhIRGBEREREUIiQUIiQRERERGBISEREBEiIhiBIiIiIUQiERIkQSIiIiGBIiIREBESEhiBIRERIRRBIiFEESERESGBISEREBESIiGBIYgRESESERIRIREYgSGBIiIREBERISGBIYgRIhEhREEhEiEYgSGBISEREAQALwAlAAAAAIDjad4VEeNnEREREBIiIiIiIiIiGIiIiIiIiIiIiIEiIiIiEBIiIiIhIiIiIYiIiIGBgYGBgRIiIiIiEBIiIiIREiIiIhGBgYFBQUFBQSIiIiIiEBIiIiERESIiIkFBQUREREREEiIiIiIhEBIiIhERERIiIiFEREEREREREiIiIiIREBIiIREREREiIiEREREiIiIiESIiIiGBEBIiERERERESIiEhISEiIiIiEhIiIiGBEBIhERERERERIiEhISERESEREhIiIiGBEBIhERERERERIiEhISESERIRESIiIiGBEBIREREREREREiEhISEiIhIiEhIiIiGBEBIREREREREREiEhISEiIhIiEhIiIiGBEBIREREREREREiEhISEiIhIiEhIiIiGBEBIREREhIREREiEhISEiIREiEhIiIiGBEBIhERIhIhERIiEhISEhEiISEhIiIiGBEBIiIiIREiIiIREhISEhIREiESESIiGBEBIiIiERESIiEiEhISEiIiIiEhIhIiGBEBIiIiIiIiIhISEhISEiEiISEhIhIiGBEBIiIiIiIiERIRIhISESEhISEiEYESGBEBIiIiIiIRGBEiISISEiEhESIRGBEhGBEBIiIiIhGBSBEREhEhIhISGBQRgRIUGBEBIiIiERGBEYEYERERESEhGBEYESERGBEBIiIRgYEYEYFBGBgYERERgUGBEhREGBEBIhFEEREYFBgUQRERGBgRgRGBEhQRGBEBIUiBGBEYERgURIiIEREYFBgRIUREGBEBGEQRERgRgRgURIERiEQYERgRIUERGBEBSIQRgYGBgUGBRIiIiEQYEYESFEREGBEBRIEREYERgRGBERERERGBQYESFBEREREBhEEYGBiIGBGBEiISIhGBEYESFBiIgREBiEERGBgRGBGBIhIiEiGBGBEhQYERiIEBSIEYGBiIGBQYEhISEiGBGBEhQYgSGIEBRIERGBgRGBEYEiISIhgUGBERRBERIREBhEEYGBiIgYEYEhIiEhgRGBgRFEREEREBSEERGBgREYEYERERERgRgRERERERIiEBRIEYEYGIgYEYGIiIiIgRgRERERIiEREBEUEREYGBEYEYERERERgRgYgRGBEhIiEBIhIRgRgYgYFIERREERgRgRGIEREiEREAQALwAlAAAAAIDjWd4VEeMnEREREBIiIiIiIRIRISEkGBGIiBIiIiIiIiIiEBIhIiIiERESEhEkGIGIgSIiIiEiIiIiEBIhIiIiESEhEiEkGIiIgSIiIhESIiIiEBIhIiIiERISISIUGBGIEiIiIRERIiIiEBIYEiIiEhEiIhIUGIGIEiIiEREREiIiEBIYEiIhEhIiIiEUQYiIgSIhERERESIiEBIYEiIhQhERIREUQYEYgSIRERERERIiEBIYEiIhQhESERIURBgYEiEREREREREiEBGIgSIhQhIiEiISRBiBIiEREREREREiEBGBgSIhQhIiEiIhREGBIhERERERERESEBGIgSIUQhIiEiIhJEQRIhERERERERESEBIYEiIUIRIhESIiFEQRIhERERERERESEBIYEiIUIRIiIiIiEkRBIhERESEhERESEBERESISEREhESIhQSREEiEREiEiEREiEBGIgSFCEREiEiIUESREESIiIhESIiIiEBIREiFCERgSIiERgRJEQRIiIRERIiIiEBGIgSFCGBGBERgYGIEkRBEiIiIiIiIiEBGIgSERGIEYGBgRiBESIiESIiIiRCIiEBIREiERGIiBERGIgRERERQRIiJEEUQiEBIUEhESEYGIiIgYERIhFERBgiRBiBRCEBIYEYESEYgYGBiBEiERREIYESJEEUQhEBIYFIgRERiIiIgRIRFERCGBGBEiRCIUEBEYFEgRIRgYGIESERREIhgRGIgSEiGEEBEYFEgRERGIiBEhFERCIYFBEYiBEhEYEBEYFEiBEhGIgRIRREQkQYEREREYEREYEBEYEkSBESERgSEURCJEQYFEQRERIiIYEBEYEUSIERGIEhFEQkRBEYERERESIiIYEBEYEhRIERhEgRREJEEREYgUREEiIiIYEBEYESRIgRhEgURCQREiERgRERIhIhGEEBEYEhFEiBhEgUQkERIiIRGBRBIREREUEBEYESFESIGIFEIRFCIRIhEYEREYEREREBEYEhIURIgRFCERIhEREiERgUGIGBEYEBEYESEhRERERBESIiIiIiIRGBiIGIiBEBEYEhISERERCRETERERiIiBGBARGBEhIURERAlED0REQRERGIEQERgSEg4REhESCxESERiIgREQBAAvACUAAAAAgONM3hUR4dcREREQEiIRIiFBREFBRBQURBRBIiIiIiIiIiIQEiGIEiIUFEFBRBQUQUQSIiIiISIiIiIQEhgUgSIhQRFBERQRFEEiIiIiERIiIiIQEhgUgSIiFEREREREREEiIiIhEREiIiIQEhgUgSIiEREREREREREiIiIRERESIiIQEiGIEiIiEiIiGBgYGBIiIiERERERIiIQEiIRIiIiEhEiGBgYGBIiIhEREREREiIQEiGIEiIiEhIRIYGBgYEiIRERERERESIQEhgUgSIiYiIiIYGBgYEiIRERERERESIQEiGIEiIhIiIiIYGBgYEiERERERERERIQEiIRIiISIiIiIYGBgYEiERERERERERIQEiGIEiIRIhEmIYGBgYEiERERERERERIQEhgUgSIiEiEWIYGBgYEiERERISERERIQEhgUgSIiEiIiIYGBgYgRIRESISIRESIQEhgUgSIiERIiGIGBgYiIEiIiERIiIiIQEiGIEiIiEiIiGIGIGBgYgSIhEREiIiIQEhEREiIhEiIiQRgYGBiBgSIiIiIiIiIQEhIiESERFiJERBgRgYEYgSIiIiIiIiIQEiESIRERERRERBGIGBiIESIiIiIiIiIQEhIhERIREREJEeDrESIiIiIiIhASEhESEhEREREREREREREhIREiIiIiIhASERIRESGBgYGBgYGBgYEhESERIiIiIhARQREhISEREREREREREREhISEUESIiIhAUEUEhERIUREREREREREEhESFEQREiERARFBESEhIRSESESESESEEhISFBEUQRgRARQRgSEREhREgYSEgYREEhESERRBGIgRAUEYGBISEhFIGEiISBhEEhISFEEYgRERARGBgRIRERgUhEgYRIREEhESERGIiIERARgYGBEhGBERESERIREhEhISERiBERGBAYGBgRERgRgQkhKxERGIiIgRgQEYGBFBGBGIESERIREhERISERiBgREYEQGIgRJBgREYEJERMRGIiIiBGBEBgRFEGBGIiBCSITIhiBgREYFBARESQYEYERgQlEE0GIiIiBGEQQERRBgRiIiBEJESMRgYEREYFEEBGEGBERgRgRGBEhIiESESEYiIiIGEREEAQAJwAnAAAAAIDi8MMJIg8iISIiIiIiIiIiIiAJIg8iERIiIiIiIiIiIiAJIg8hEREiIiIiIiIiIiAJIuJ7EREREiIiIiIiIiIgIiIiIiIiIiEREhERIiIiIiIiIiAiIiIiIiIiEREhIRESIiIiIiIiICIiIiIiIiEREhESEREiIiIiIiIgIiIiIiIiEREhEREhERIiIiIiIiAiIiIiIiEREhERERIRESIiIiIiICIiIiIiEREhERIRESEREiIiIiIgIiIiIiEREhERISEREhERIiIiIiAiIiIiEREhERIREhERIRESIiIiICIiIiEREhERIRIRIRESEREiIiIgIiIiEREhERIRISESEREhERIiIiAiIiEREhERIRIREhEhERIRESIiICIiEREhERIREhESERIRESEREiIgIiEREhERIRERISERESEREhERIiAiEREhERESERESERESERERIRESICIREhEREREhESEhESERERESERIgIRESERIRERISERISERESERIRESAhESERESESESESESESESERESERICERIRERIRESEhESEhERIRERIREgERIRESIRESERISERIRESIRESERAREhESERESERESERESERESERIREBESERIRESEREREREREhERIREhEQERIREhESERESERIRERIREhESERAREhERIiERESEhISERESIhERIREBESERERERESERIREhEREREREhEQERIRERERESERERERIRERERESERARESERERESERERERESERERESERECERIhEREiEREhESEREiERESIREgIRERIiIhEREiERIhEREiIiERESAiEREREREREiIREiIRERERERESICIhEREREREiIRERIiERERERESIgIiIhERERIiIhEREiIiEREREiIiAJIg8RERESIiIiIiIiIiAJIjcRERESIiIiIiIiIiAiIiIiIiIiIREREREiIiIiIiIiICIiIiIiIiIRERERERIiIiIiIiIgAQALAAsAAAAAgB8LBw4AAAAOHwAAAAduwAAADv/gAAAHdcAAAAoOAAAAAQAJAAoAAAAAgB8KBxwAAAAKPgAAAAddAAAADv+AAAAHawAAAAocAAAAAQAPAA8AAAAAgDIPCwOAAAAHwAAADg/gAAAPB8AAADu4AAB//AAADv/+AAATfXwAADk4AAADgAAAB8AAAAEACwALAAAAAIAiCw8IAAAAHAAAAD4AAAAOfwAAAA8+AAAAHAAAAAgAAAAJAAEACQAKAAAAAIAkCg8IAAAAHAAAAD4AAAAOfwAAABM+AAAAHAAAAAgAAAAAAAAAAQAPAA8AAAAAgDoPEwEAAAADgAAAB8AAAA/gAAAKH/AAAA8/+AAAf/wAAD/4AAAKH/AAABMP4AAAB8AAAAOAAAABAAAAAQALAAsAAAAAgCYLBQALdwAAAPeAAAAO/4AAABd/AAAAPgAAABwAAAAIAAAAAAAAAAEACQAKAAAAAIAkCgt3AAAA94AAAA7/gAAAF38AAAA+AAAAHAAAAAgAAAAAAAAAAQAPAA8AAAAAgDEPDzx4AAB+/AAA/v4AABL//gAACn/8AAAbP/gAAB/wAAAP4AAAB8AAAAOAAAABAAAAAQALAAsAAAAAgCMLBQATCAAAABwAAAA+AAAAfwAAAA7/gAAAB2sAAAAKHAAAAAEACQAKAAAAAIAhChMIAAAAHAAAAD4AAAB/AAAADv+AAAAHawAAAAocAAAAAQAPAA8AAAAAgDUPGwEAAAADgAAAB8AAAA/gAAAf8AAAP/gAAAp//AAADv/+AAAT/X4AAHk8AAADgAAAB8AAAAEADAAMAAAAAIAmDAoCAAAACgcAAAAKDYAAABMYwAAAH8AAAD/gAAAwYAAACnjwAAABAAoADAAAAACALwwrHwAAAD+AAAAxgAAAAYAAAAOAAAAHAAAADgAAABwAAAA5gAAAMYAAAAo/gAAAAQAKAAwAAAAAgC0MCj+AAAAXMwAAAAYAAAAMAAAAHwAAAB+AAAAKAYAAAA8xgAAAP4AAAB8AAAABAAoADAAAAACAKQwbAwAAAAcAAAAPAAAAHwAAADsAAABzAAAACn/AAAAKAwAAAAoHgAAAAQAKAAwAAAAAgCcMCn8AAAAKYAAAAAt+AAAAfwAAAAoDAAAACmMAAAALfwAAAD4AAAABAAoADAAAAACAKAwbDwAAAB8AAAA4AAAAMAAAAD8AAAA/gAAAEjGAAAALP4AAAB8AAAABAAoADAAAAACAGgwKP4AAAAcxgAAACgMAAAAOBgAAABIMAAAAAQAKAAwAAAAAgCYMCx8AAAA/gAAADjGAAAALHwAAAD+AAAAOMYAAAAs/gAAAHwAAAAEACgAMAAAAAIAoDAsfAAAAP4AAABIxgAAAGz+AAAAfgAAAAYAAAAOAAAAfAAAAHgAAAAEACgAMAAAAAIAYDAtngAAAb8AAACJswAAAC2/AAABngAAAAQAKAAwAAAAAgBkMCg8AAAAaBgAAAApmAAAAC34AAAA8AAAAAQAKAA4AAAAAgCAOCz4AAAB/AAAAImMAAAATfwAAAD4AAAAHAAAAAwAAAAEACgAMAAAAAIAsDAr3gAAAI2YAAABsAAAAeAAAAHAAAAB4AAAAbAAAAGYAAABjAAAACveAAAA='! !!PlayingCard class methodsFor: 'all' stamp: 'di 10/18/1999 11:01'!initialize  "PlayingCard initialize"	| forms f |	"Read the stored forms from mime-encoded data in imageData."	f _ Base64MimeConverter mimeDecodeToBytes: (ReadStream on: self imageData).	forms _ OrderedCollection new.	f next = 2 ifFalse: [self error: 'corrupted imageData'].	[f atEnd] whileFalse: [forms add: (Form new readFrom: f)].	"1/2 image of Kc, Qc, Jc, ... d, h, s, and center image of As"	FaceForms _ forms copyFrom: 1 to: 13.	"Images of small club, smaller club (for face cards), large club (for 2-10, A),	followed by 3 more each for diamonds, heardt, spaces, all as 1-bit forms."	SuitForms _ forms copyFrom: 14 to: 25.	"Images of A, 2, 3 ... J, Q, K as 1-bit forms"	NumberForms _ forms copyFrom: 26 to: 38.	CardSize _ 71@96.	FaceLoc _ 12@11.	NumberLoc _ 2@4.	SuitLoc _ 3@18.	FaceSuitLoc _ 2@18.	TopSpotLocs _ {{}.  "A"				{28@10}.  "2"				{28@10}.  "3"				{15@10. 41@10}.  "4"				{15@10. 41@10}.  "5"				{14@10. 42@10}.  "6"				{14@10. 42@10}.  "7"				{14@10. 28@26. 42@10}.  "8"				{14@10. 14@30. 42@10. 42@30}.  "9"				{14@10. 14@30. 42@10. 42@30. 28@21}}.   "10"	MidSpotLocs _ {{28@40}.  "A"				{}.  "2"				{28@40}.  "3"				{}.  "4"				{28@40}.  "5"				{14@40. 42@40}.  "6"				{14@40. 42@40. 28@26}.  "7"				{14@40. 42@40}.  "8"				{28@40}.  "9"				{}  "10"}.	ASpadesLoc _ 16@27.	"self class removeSelector: #imageData"  "Can save space""	NOTE:  If you wish to save this class with new data,	be sure to execute this doit before fileOut.  It will generate the method, #imageData	| rws mimeData | 	rws _ ReadWriteStream on: (ByteArray new: 18000).	rws nextPut: 2.	FaceForms , SuitForms , NumberForms do: [:f | f writeOn: rws].	mimeData _ (Base64MimeConverter mimeEncode: rws) contents.	PlayingCard class compile: 'imageData ^ ' , mimeData printString classified: 'all'"! !!PlayingCard class methodsFor: 'all' stamp: 'di 10/18/1999 23:36'!test    "Display all cards in the deck"	"MessageTally spyOn: [20 timesRepeat: [PlayingCard test]]"	1 to: 13 do: [:i | 1 to: 4 do: [:j |		(PlayingCard the: i of: (#(clubs diamonds hearts spades) at: j)) cardForm				displayAt: (i-1*CardSize x)@(j-1*CardSize y)]]! !!PlayingCard class methodsFor: 'all' stamp: 'di 10/18/1999 23:22'!the: cardNo of: suitOrNumber	^ self new setCardNo: cardNo		suitNo: (suitOrNumber isNumber				ifTrue: [suitOrNumber]				ifFalse: [#(clubs diamonds hearts spades) indexOf: suitOrNumber])		cardForm: (Form extent: CardSize depth: Display depth)! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 01:40'!acceptCardSelector: aSymbolOrString	acceptCardSelector _ self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 11:07'!addCard: aPlayingCard	self addMorph: aPlayingCard! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 03:13'!cardDoubleClickSelector: aSymbolOrString	cardDoubleClickSelector _ self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 01:39'!cardDraggedSelector: aSymbolOrString	cardDraggedSelector _ self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:27'!cardDroppedSelector: aSymbolOrString	cardDroppedSelector _ self nilOrSymbol: aSymbolOrString.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 10:46'!cards	^submorphs! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 13:18'!emptyDropPolicy: aSymbol	"#any #inOrder #anyClub #anyDiamond #anyHeart #anySpade"	emptyDropPolicy _ aSymbol! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 19:41'!hasCards	^self hasSubmorphs! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 11:02'!layout: aSymbol	" #grid #pile #stagger"	layout _ aSymbol.! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:44'!newSeed	seed _ (1 to: 32000) atRandom! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 20:05'!removeAllCards	self removeAllMorphs! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:22'!seed		^seed! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/23/1999 22:21'!seed: anInteger		seed _ anInteger! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/15/1999 16:39'!stackingOrder: aSymbol	"#ascending #descending"	stackingOrder _ aSymbol! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 00:08'!stackingPolicy	^ stackingPolicy! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 00:08'!stackingPolicy: aSymbol	"#straight #altStraight #single #none"	stackingPolicy _ aSymbol! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/24/1999 20:20'!subDeckStartingAt: aCard	| i subDeck |	i _ submorphs indexOf: aCard ifAbsent: [^ aCard].	i = 1 ifTrue: [^aCard].	subDeck _ PlayingCardDeck new.	(submorphs copyFrom: 1 to: i-1) do:			[:m | m class = aCard class ifTrue: [subDeck addMorphBack: m]].	^subDeck.	! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 17:21'!target: anObject	target _ anObject! !!PlayingCardDeck methodsFor: 'accessing' stamp: 'djp 10/16/1999 19:24'!topCard	^self firstSubmorph! !!PlayingCardDeck methodsFor: 'events' stamp: 'djp 10/24/1999 03:29'!doubleClickOnCard: aCard	(target ~~ nil and: [cardDoubleClickSelector ~~ nil]) 		ifTrue: [^ target perform: cardDoubleClickSelector with: self with: aCard]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 04:16'!acceptCard: aCard default: aBoolean	"if target and acceptCardSelector are both not nil, send to target, if not nil answer	else answer aBoolean"	| answer |	(target ~~ nil and: [acceptCardSelector ~~ nil]) 		ifTrue: [			answer _ target perform: acceptCardSelector with: aCard with: self.			answer ifNil: [answer _ aBoolean]]		ifFalse: [answer _ aBoolean].	^answer! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 10/18/1999 13:30'!acceptDroppingMorph: aMorph event: evt	super acceptDroppingMorph: aMorph event: evt.	aMorph hasSubmorphs ifTrue:		["Just dropped a sub-deck of cards"		aMorph submorphs reverseDo: [:m | self addMorphFront: m]].	(target ~~ nil and: [cardDroppedSelector ~~ nil]) ifTrue: [target perform: cardDroppedSelector]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:14'!emptyDropNotOk: aPlayingCard	^(self emptyDropOk: aPlayingCard) not! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:15'!emptyDropOk: aPlayingCard	emptyDropPolicy = #any 			ifTrue: [^true].	emptyDropPolicy = #inOrder			ifTrue: [^self inStackingOrder: aPlayingCard].	emptyDropPolicy = #anyClub 		ifTrue: [^aPlayingCard suit = #club].	emptyDropPolicy = #anyDiamond		ifTrue: [^aPlayingCard suit = #diamond].	emptyDropPolicy = #anyHeart		ifTrue: [^aPlayingCard suit = #heart].	emptyDropPolicy = #anySpade		ifTrue: [^aPlayingCard suit = #spade].! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 13:10'!ifEmpty: aBlock	self hasSubmorphs not ifTrue: [^aBlock value]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 02:17'!ifEmpty: aBlock1 ifNotEmpty: aBlock2	self hasSubmorphs not 		ifTrue: [^aBlock1 value]		ifFalse: [^aBlock2 value]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/16/1999 21:54'!inStackingOrder: aPlayingCard	^self inStackingOrder: aPlayingCard event: nil! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 10/19/1999 15:45'!inStackingOrder: aCard event: evt	self hasSubmorphs 		ifTrue: [^ self inStackingOrder: aCard onTopOf: self topCard]		ifFalse: [stackingOrder = #ascending ifTrue: [^ aCard cardNumber = 1].				stackingOrder = #descending ifTrue: [^ aCard cardNumber = 13]].	^ false.! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 10/21/1999 22:03'!inStackingOrder: aCard onTopOf: cardBelow	| diff |	(stackingPolicy = #altStraight and: [aCard suitColor = cardBelow suitColor]) ifTrue: [^ false].	(stackingPolicy = #straight and: [aCard suit ~= cardBelow suit]) ifTrue: [^ false].	diff _ aCard cardNumber - cardBelow cardNumber.	stackingOrder = #ascending 	ifTrue: [^ diff = 1].	stackingOrder = #descending	ifTrue: [^ diff = -1].	^ false.! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/15/1999 12:43'!insertionIndexFor: aMorph	"Return the index at which the given morph should be inserted into the submorphs of the receiver."	^1! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 02:23'!repelCard: aCard	(stackingPolicy = #none) ifTrue: [^self repelCard: aCard default: true].	(stackingPolicy = #single) 		ifTrue: [aCard hasSubmorphs ifTrue: [^self repelCard: aCard default: true]].	(stackingPolicy = #altStraight or: [stackingPolicy = #straight]) ifTrue:		[self 			ifEmpty: [(self emptyDropNotOk: aCard) ifTrue: [^self repelCard: aCard default: true]]			ifNotEmpty: [(self inStackingOrder: aCard onTopOf: self topCard) 				ifFalse: [^self repelCard: aCard default: true]]].	^ false! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 04:09'!repelCard: aCard default: aBoolean		^(self acceptCard: aCard default: aBoolean not) not! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 02:20'!repelsMorph: aMorph event: evt	(aMorph isKindOf: PlayingCardMorph) 		ifTrue: [^self repelCard: aMorph]		ifFalse: [^true]! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'djp 10/24/1999 20:34'!rootForGrabOf: aCard	self hasSubmorphs ifFalse: [^ nil].	(target ~~ nil and: [cardDraggedSelector ~~ nil]) 		ifTrue: [^target perform: cardDraggedSelector with: aCard with: self]		ifFalse: [^self firstSubmorph]! !!PlayingCardDeck methodsFor: 'layout' stamp: 'djp 10/15/1999 14:27'!fixLayout	layout = #stagger 	ifTrue: [^self fixLayoutStagger].	layout= #pile		ifTrue: [^self fixLayoutPile].	^super fixLayout.! !!PlayingCardDeck methodsFor: 'layout' stamp: 'djp 10/15/1999 14:28'!fixLayoutPile	| nextPlace |	orientation = #horizontal		ifTrue: [nextPlace _ bounds left + inset + borderWidth]		ifFalse: [nextPlace _ bounds top + inset + borderWidth].	submorphs reverseDo: [:m |		self placeAndSize: m at: nextPlace padding: 0].! !!PlayingCardDeck methodsFor: 'layout' stamp: 'djp 10/15/1999 14:24'!fixLayoutStagger	| nextPlace |	orientation = #horizontal		ifTrue: [nextPlace _ bounds left + inset + borderWidth]		ifFalse: [nextPlace _ bounds top + inset + borderWidth].	submorphs reverseDo: [:m |		self placeAndSize: m at: nextPlace padding: 0.		nextPlace _ nextPlace + self staggerOffset].! !!PlayingCardDeck methodsFor: 'layout' stamp: 'djp 10/17/1999 18:25'!minHeight	"Return the minimum height for this morph."	| spaceNeeded |	vResizing = #shrinkWrap ifFalse: [^super minHeight].	submorphs isEmpty ifTrue: [^ self minHeightWhenEmpty].	orientation == #horizontal ifTrue: [^super minHeight].	orientation == #vertical ifTrue:		[spaceNeeded _ 2 * (inset + borderWidth).		spaceNeeded _ spaceNeeded + (PlayingCardMorph height).		layout = #stagger ifTrue: [spaceNeeded _ spaceNeeded + 									((self submorphCount - 1) * self staggerOffset)]].	^ spaceNeeded! !!PlayingCardDeck methodsFor: 'layout' stamp: 'djp 10/17/1999 18:25'!minHeightWhenEmpty	^(PlayingCardMorph height) + (2*(borderWidth + inset))! !!PlayingCardDeck methodsFor: 'layout' stamp: 'djp 10/17/1999 18:25'!minWidthWhenEmpty	^(PlayingCardMorph width) + (2*(borderWidth + inset))! !!PlayingCardDeck methodsFor: 'layout' stamp: 'djp 10/15/1999 11:25'!staggerOffset	^18! !!PlayingCardDeck methodsFor: 'initialization' stamp: 'djp 10/23/1999 22:22'!initialize	super initialize.	layout _ #grid.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	borderWidth _ 0.	inset _ 0.	stackingPolicy _ #stagger.	stackingOrder _ #ascending.	emptyDropPolicy _ #any.	self newSeed.	^self! !!PlayingCardDeck methodsFor: 'initialization' stamp: 'djp 10/17/1999 18:25'!newDeck	| cards |	cards := OrderedCollection new: 52.	PlayingCardMorph suits 		do: [:suit | 1 to: 13			do: [:cardNo | cards add: (PlayingCardMorph the: cardNo of: suit)]].	self addAllMorphs: cards.	^self! !!PlayingCardDeck methodsFor: 'initialization' stamp: 'djp 10/17/1999 18:25'!newSuit: suit	| cards |	cards := OrderedCollection new: 13.	1 to: 13 do: [:cardNo | cards add: (PlayingCardMorph the: cardNo of: suit)].	self addAllMorphs: cards.	^self! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'di 10/19/1999 15:44'!deal	| card |	self cards size > 0 		ifTrue: [			card _ self topCard.			card delete.			^card]		ifFalse: [^nil]! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'djp 10/10/1999 18:48'!deal: anInteger	^(1 to: anInteger) collect: [:i | self deal]! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'djp 10/16/1999 20:40'!reverse	submorphs _ submorphs reversed.	self layoutChanged.! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'djp 10/23/1999 22:23'!shuffle	submorphs _ submorphs shuffledBy: (Random new seed: seed).	self layoutChanged.! !!PlayingCardDeck methodsFor: 'printing' stamp: 'djp 10/15/1999 10:47'!printOn: aStream	| cards |	cards _ self cards.	aStream nextPutAll: 'aCardDeck('.	cards size > 1 		ifTrue: [			cards allButLast do: [:card |				aStream					print: card;					nextPutAll: ', ']].	cards size > 0 ifTrue: [aStream print: cards last].	aStream nextPut: $).! !!PlayingCardDeck methodsFor: 'private' stamp: 'djp 10/16/1999 17:27'!nilOrSymbol: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^nil]		ifFalse: [^aSymbolOrString asSymbol]! !!PlayingCardDeck class methodsFor: 'symbols' stamp: 'djp 10/10/1999 18:06'!suits	^{#Clubs. #Diamonds. #Hearts. #Spades}! !!PlayingCardDeck class methodsFor: 'symbols' stamp: 'djp 10/17/1999 18:05'!values	^#(Ace),((2 to: 9) collect: [:i | i printString asSymbol]), #(Jack Queen King)! !!PlayingCardDeck class methodsFor: 'instance creation' stamp: 'djp 10/15/1999 11:01'!newDeck	^self new newDeck! !!PlayingCardDeck class methodsFor: 'instance creation' stamp: 'djp 10/15/1999 09:53'!newSuit: suit	^self new newSuit: suit! !!PlayingCardMorph commentStamp: '<historical>' prior: 0!This class displays images from the PlayingCard class as morphs.  It attempts to be space-efficient by only producing its images on demand.!!PlayingCardMorph methodsFor: 'printing' stamp: 'djp 10/17/1999 20:27'!printOn: aStream	aStream		print: cardNumber;		nextPutAll: ' of ';		print: (self class suits at: suitNumber).! !!PlayingCardMorph methodsFor: 'access' stamp: 'di 10/21/1999 21:41'!board	^ owner owner owner! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/24/1999 03:11'!cardDeck	^self owner! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!cardNumber	^cardNumber! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!cardNumber: c suitNumber: s	cardNumber _ c.	suitNumber _ s.! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!suit	^self class suits at: suitNumber! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!suitColor	^#(black red red black) at: suitNumber! !!PlayingCardMorph methodsFor: 'access' stamp: 'djp 10/17/1999 18:37'!suitNumber	^suitNumber! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 10/21/1999 19:00'!aboutToBeGrabbedBy: aHand	"I'm about to be grabbed by the hand.  If other cards are above me in a deck,	then move them from the deck to being submorphs of me"	| i |	i _ owner submorphs indexOf: self ifAbsent: [^ self].	i = 1 ifTrue: [^ self].	(owner submorphs copyFrom: 1 to: i-1) do:		[:m | m class = self class ifTrue: [self addMorphBack: m]].! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 10/19/1999 15:48'!justDroppedInto: newOwner event: evt	(newOwner isKindOf: PlayingCardDeck)		ifFalse: ["Can't drop a card anywhere but on a deck"				evt hand rejectDropMorph: self event: evt].! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'djp 10/15/1999 13:52'!rootForGrabOf: aMorph	^owner rootForGrabOf: aMorph.! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 10/19/1999 01:23'!slideBackToFormerSituation: evt	super slideBackToFormerSituation: evt.	self hasSubmorphs ifTrue:		["Just cancelled a drop of multiple cards -- have to unload submorphs"		self submorphs reverseDo: [:m | owner addMorphFront: m]].! !!PlayingCardMorph methodsFor: 'events' stamp: 'djp 10/24/1999 03:12'!doubleClick: evt	^self cardDeck doubleClickOnCard: self! !!PlayingCardMorph methodsFor: 'events' stamp: 'di 10/21/1999 21:47'!drag: evt	| root popUp |	evt isMouseDown ifTrue:		[root _ owner rootForGrabOf: self.		root == nil			ifTrue: ["Display hidden card in front"					popUp _ self copy.					self board owner owner addMorphFront: popUp.					self world displayWorld.					(Delay forMilliseconds: 750) wait.					popUp delete]			ifFalse: [evt hand grabMorph: root]]! !!PlayingCardMorph methodsFor: 'events' stamp: 'di 10/19/1999 00:01'!handlesMouseDown: evt	^ true! !!PlayingCardMorph methodsFor: 'events' stamp: 'di 10/21/1999 21:22'!mouseDown: evt	"Do nothing upon mouse-down except inform the hand to watch for a double-click; wait until an ensuing click:, doubleClick:, or drag: message gets dispatched"	evt hand waitForClicksOrDrag: self event: evt! !!PlayingCardMorph class methodsFor: 'initialize-release' stamp: 'di 10/18/1999 23:45'!the: cardNumber of: suit	^ self new 		image: (PlayingCard the: cardNumber of: suit) cardForm;		cardNumber: cardNumber suitNumber: (self suits indexOf: suit)! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/17/1999 18:39'!cardSize	" a real hack, but I don't want to muck with Dan's class "	^71@96.! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/17/1999 18:32'!height	^self cardSize y! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/15/1999 07:14'!suits	^ #(clubs diamonds hearts spades)! !!PlayingCardMorph class methodsFor: 'access' stamp: 'djp 10/17/1999 18:32'!width	^self cardSize x! !!PlayingCardMorph class methodsFor: 'testing' stamp: 'djp 10/17/1999 18:24'!test    "Display all cards in the deck"	"MessageTally spyOn: [20 timesRepeat: [PlayingCardMorph test]]"	| table row |	table _ AlignmentMorph newColumn.	self suits do: [:suit | 		row _ AlignmentMorph newRow.		table addMorph: row.		1 to: 13 do: [:cn |			row addMorph: 			(PlayingCardMorph the: cn of: suit)]].	table openInWorld.! !FreeCell initialize!FreeCellStatistics removeSelector: #makeSessionSummary!FreeCellStatistics removeSelector: #sessionWon:!PlayingCard initialize!