InterpreterPlugin subclass: #FFIPlugin	instanceVariableNames: 'ffiLastError ffiArgClass ffiArgSpec ffiArgSpecSize ffiArgHeader ffiRetOop ffiRetClass ffiRetSpec ffiRetSpecSize ffiRetHeader '	classVariableNames: ''	poolDictionaries: 'FFIConstants '	category: 'FFI-Plugin'!!FFIPlugin methodsFor: 'primitives' stamp: 'ar 11/28/1999 19:25'!primitiveCallout	"IMPORTANT: IF YOU CHANGE THE NAME OF THIS METHOD YOU MUST CHANGE		Interpreter>>primitiveCalloutToFFI	TO REFLECT THE CHANGE."	"Perform a function call to a foreign function.	Only invoked from method containing explicit external call spec."	| lit address flags argTypes litClass nArgs meth |	self export: true.	self inline: false.	self ffiSetLastError: FFIErrorGenericError. "educated guess if we fail silently"	lit _ nil.	"Look if the method is itself a callout function"	meth _ interpreterProxy primitiveMethod.	(interpreterProxy literalCountOf: meth) > 0 ifFalse:[^interpreterProxy primitiveFail].	lit _ interpreterProxy literal: 0 ofMethod: meth.	litClass _ interpreterProxy fetchClassOf: lit.	(interpreterProxy includesBehavior: litClass 						ThatOf: interpreterProxy classExternalFunction) 		ifFalse:[^self ffiFail: FFIErrorNotFunction].	address _ self ffiLoadCalloutAddress: lit.	interpreterProxy failed ifTrue:[^0].	"Load and check the other values before we call out"	flags _ interpreterProxy fetchInteger: 1 ofObject: lit.	interpreterProxy failed ifTrue:[^self ffiFail: FFIErrorBadArgs].	argTypes _ interpreterProxy fetchPointer: 2 ofObject: lit.	"must be array of arg types"	(interpreterProxy fetchClassOf: argTypes) == interpreterProxy classArray 		ifFalse:[^self ffiFail: FFIErrorBadArgs].	nArgs _ interpreterProxy slotSizeOf: argTypes.	"must be argumentCount+1 arg types"	nArgs = (interpreterProxy methodArgumentCount+1) 		ifFalse:[^self ffiFail: FFIErrorBadArgs].	self ffiInitialize. "announce the execution of an external call"	self ffiCall: address 		WithFlags: flags 		AndTypes: argTypes.	self ffiCleanup. "cleanup temp allocations"	^0! !!FFIPlugin methodsFor: 'primitives' stamp: 'ar 11/28/1999 19:26'!primitiveCalloutWithArgs	"Perform a function call to a foreign function.	Only invoked from ExternalFunction>>invokeWithArguments:"	| lit address flags argTypes litClass nArgs argArray |	self export: true.	self inline: false.	self ffiSetLastError: FFIErrorGenericError. "educated guess if we fail silently"	lit _ nil.	"Look if the method is itself a callout function"	lit _ interpreterProxy stackValue: interpreterProxy methodArgumentCount.	litClass _ interpreterProxy fetchClassOf: lit.	(interpreterProxy includesBehavior: litClass 						ThatOf: interpreterProxy classExternalFunction) 		ifFalse:[^self ffiFail: FFIErrorNotFunction].	address _ self ffiLoadCalloutAddress: lit.	interpreterProxy failed ifTrue:[^nil].	"Load and check the other values before we call out"	flags _ interpreterProxy fetchInteger: 1 ofObject: lit.	interpreterProxy failed ifTrue:[^self ffiFail: FFIErrorBadArgs].	argTypes _ interpreterProxy fetchPointer: 2 ofObject: lit.	"must be array of arg types"	(interpreterProxy fetchClassOf: argTypes) == interpreterProxy classArray 		ifFalse:[^self ffiFail: FFIErrorBadArgs].	nArgs _ interpreterProxy slotSizeOf: argTypes.	(interpreterProxy methodArgumentCount = 1) 		ifFalse:[^self ffiFail: FFIErrorBadArgs].	argArray _ interpreterProxy stackValue: 0.	(interpreterProxy fetchClassOf: argArray) = (interpreterProxy classArray)		ifFalse:[^self ffiFail: FFIErrorBadArgs].	nArgs = ((interpreterProxy slotSizeOf: argArray) + 1)		ifFalse:[^self ffiFail: FFIErrorBadArgs].	self ffiInitialize. "announce the execution of an external call"	self ffiCall: address 		WithFlags: flags 		Args: argArray		AndTypes: argTypes		OfSize: nArgs-1.	self ffiCleanup. "cleanup temp allocations"	^0! !!FFIPlugin methodsFor: 'primitives' stamp: 'ar 12/1/1999 16:08'!primitiveFFIAllocate	"Primitive. Allocate an object on the external heap."	| byteSize addr oop ptr |	self export: true.	self inline: false.	self var: #ptr declareC:'int *ptr'.	byteSize _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue:[^nil].	addr _ self ffiAlloc: byteSize.	addr = 0 ifTrue:[^interpreterProxy primitiveFail].	oop _ interpreterProxy 			instantiateClass: interpreterProxy classExternalAddress 			indexableSize: 4.	ptr _ interpreterProxy firstIndexableField: oop.	ptr at: 0 put: addr.	interpreterProxy pop: 2.	^interpreterProxy push: oop.! !!FFIPlugin methodsFor: 'primitives' stamp: 'ar 11/29/1999 00:07'!primitiveFFIDoubleAt	"Return a (signed or unsigned) n byte integer from the given byte offset."	| byteOffset rcvr addr floatValue |	self export: true.	self inline: false.	self var: #floatValue declareC:'double floatValue'.	byteOffset _ interpreterProxy stackIntegerValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^0].	addr _ self addressOf: rcvr startingAt: byteOffset size: 8.	interpreterProxy failed ifTrue:[^0].	self cCode:'((int*)(&floatValue))[0] = ((int*)addr)[0]'.	self cCode:'((int*)(&floatValue))[1] = ((int*)addr)[1]'.	interpreterProxy pop: 2.	^interpreterProxy pushFloat: floatValue! !!FFIPlugin methodsFor: 'primitives' stamp: 'ar 11/29/1999 10:10'!primitiveFFIDoubleAtPut	"Return a (signed or unsigned) n byte integer from the given byte offset."	| byteOffset rcvr addr floatValue floatOop |	self export: true.	self inline: false.	self var: #floatValue declareC:'double floatValue'.	floatOop _ interpreterProxy stackValue: 0.	(interpreterProxy isIntegerObject: floatOop)		ifTrue:[floatValue _ self cCoerce: (interpreterProxy integerValueOf: floatOop) to:'double']		ifFalse:[floatValue _ self cCoerce: (interpreterProxy floatValueOf: floatOop) to:'double'].	byteOffset _ interpreterProxy stackIntegerValue: 1.	rcvr _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^0].	addr _ self addressOf: rcvr startingAt: byteOffset size: 8.	interpreterProxy failed ifTrue:[^0].	self cCode:'((int*)addr)[0] = ((int*)(&floatValue))[0]'.	self cCode:'((int*)addr)[1] = ((int*)(&floatValue))[1]'.	interpreterProxy pop: 3.	^interpreterProxy push: floatOop! !!FFIPlugin methodsFor: 'primitives' stamp: 'ar 11/29/1999 00:07'!primitiveFFIFloatAt	"Return a (signed or unsigned) n byte integer from the given byte offset."	| byteOffset rcvr addr floatValue |	self export: true.	self inline: false.	self var: #floatValue declareC:'float floatValue'.	byteOffset _ interpreterProxy stackIntegerValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^0].	addr _ self addressOf: rcvr startingAt: byteOffset size: 4.	interpreterProxy failed ifTrue:[^0].	self cCode:'((int*)(&floatValue))[0] = ((int*)addr)[0]'.	interpreterProxy pop: 2.	^interpreterProxy pushFloat: floatValue! !!FFIPlugin methodsFor: 'primitives' stamp: 'ar 11/29/1999 10:10'!primitiveFFIFloatAtPut	"Return a (signed or unsigned) n byte integer from the given byte offset."	| byteOffset rcvr addr floatValue floatOop |	self export: true.	self inline: false.	self var: #floatValue declareC:'float floatValue'.	floatOop _ interpreterProxy stackValue: 0.	(interpreterProxy isIntegerObject: floatOop)		ifTrue:[floatValue _ self cCoerce: (interpreterProxy integerValueOf: floatOop) to:'float']		ifFalse:[floatValue _ self cCoerce: (interpreterProxy floatValueOf: floatOop) to:'float'].	byteOffset _ interpreterProxy stackIntegerValue: 1.	rcvr _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^0].	addr _ self addressOf: rcvr startingAt: byteOffset size: 4.	interpreterProxy failed ifTrue:[^0].	self cCode:'((int*)addr)[0] = ((int*)(&floatValue))[0]'.	interpreterProxy pop: 3.	^interpreterProxy push: floatOop! !!FFIPlugin methodsFor: 'primitives' stamp: 'ar 12/1/1999 16:08'!primitiveFFIFree	"Primitive. Free the object pointed to on the external heap."	| addr oop ptr |	self export: true.	self inline: false.	self var: #ptr declareC:'int *ptr'.	oop _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy fetchClassOf: oop) = (interpreterProxy classExternalAddress)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy byteSizeOf: oop) = 4		ifFalse:[^interpreterProxy primitiveFail].	ptr _ interpreterProxy firstIndexableField: oop.	addr _ ptr at: 0.	"Don't you dare to free Squeak's memory!!"	(addr = 0 or:[interpreterProxy isInMemory: addr])		ifTrue:[^interpreterProxy primitiveFail].	self ffiFree: addr.	^ptr at: 0 put: 0. "cleanup"! !!FFIPlugin methodsFor: 'primitives' stamp: 'ar 11/28/1999 19:26'!primitiveFFIGetLastError	"Primitive. Return the error code from a failed call to the foreign function interface."	self export: true.	self inline: false.	interpreterProxy pop: 1.	^interpreterProxy pushInteger: self ffiGetLastError.! !!FFIPlugin methodsFor: 'primitives' stamp: 'ar 12/1/1999 18:55'!primitiveFFIIntegerAt	"Return a (signed or unsigned) n byte integer from the given byte offset."	| isSigned byteSize byteOffset rcvr addr value mask |	self export: true.	self inline: false.	isSigned _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).	byteSize _ interpreterProxy stackIntegerValue: 1.	byteOffset _ interpreterProxy stackIntegerValue: 2.	rcvr _ interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^0].	(byteOffset > 0 and:[byteSize = 1 or:[byteSize = 2 or:[byteSize = 4]]])		ifFalse:[^interpreterProxy primitiveFail].	addr _ self addressOf: rcvr startingAt: byteOffset size: byteSize.	interpreterProxy failed ifTrue:[^0].	byteSize < 4 ifTrue:[		"short/byte"		byteSize = 1 			ifTrue:[value _ interpreterProxy byteAt: addr]			ifFalse:[	value _ self cCode: '*((short int *) addr)' 								inSmalltalk: [interpreterProxy halfWordAt: addr]].		isSigned ifTrue:["sign extend value"			mask _ 1 << (byteSize * 8 - 1).			value _ (value bitAnd: mask-1) - (value bitAnd: mask)].		"note: byte/short never exceed SmallInteger range"		value _ interpreterProxy integerObjectOf: value.	] ifFalse:[		"general 32 bit integer"		value _ interpreterProxy longAt: addr.		isSigned			ifTrue:[value _ interpreterProxy signed32BitIntegerFor: value]			ifFalse:[value _ interpreterProxy positive32BitIntegerFor: value].	].	interpreterProxy pop: 4.	^interpreterProxy push: value! !!FFIPlugin methodsFor: 'primitives' stamp: 'ar 12/1/1999 18:55'!primitiveFFIIntegerAtPut	"Store a (signed or unsigned) n byte integer at the given byte offset."	| isSigned byteSize byteOffset rcvr addr value max valueOop |	self export: true.	self inline: false.	isSigned _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).	byteSize _ interpreterProxy stackIntegerValue: 1.	valueOop _ interpreterProxy stackValue: 2.	byteOffset _ interpreterProxy stackIntegerValue: 3.	rcvr _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^0].	(byteOffset > 0 and:[byteSize = 1 or:[byteSize = 2 or:[byteSize = 4]]])		ifFalse:[^interpreterProxy primitiveFail].	addr _ self addressOf: rcvr startingAt: byteOffset size: byteSize.	interpreterProxy failed ifTrue:[^0].	isSigned 		ifTrue:[value _ interpreterProxy signed32BitValueOf: valueOop]		ifFalse:[value _ interpreterProxy positive32BitValueOf: valueOop].	interpreterProxy failed ifTrue:[^0].	byteSize < 4 ifTrue:[		isSigned ifTrue:[			max _ 1 << (8 * byteSize - 1).			value >= max ifTrue:[^interpreterProxy primitiveFail].			value < (0 - max) ifTrue:[^interpreterProxy primitiveFail].		] ifFalse:[			value >= (1 << (8*byteSize)) ifTrue:[^interpreterProxy primitiveFail].		].		"short/byte"		byteSize = 1 			ifTrue:[interpreterProxy byteAt: addr put: value]			ifFalse:[	self cCode: '*((short int *) addr) = value' 						inSmalltalk: [interpreterProxy halfWordAt: addr put: value]].	] ifFalse:[interpreterProxy longAt: addr put: value].	interpreterProxy pop: 5.	^interpreterProxy push: valueOop.! !!FFIPlugin methodsFor: 'primitives' stamp: 'ar 12/8/1999 22:03'!primitiveForceLoad	"Primitive. Force loading the receiver (an instance of ExternalLibrary)."	| rcvr theClass moduleHandlePtr moduleHandle moduleName moduleLength ptr |	self export: true.	self inline: false.	self var: #ptr declareC:'int *ptr'.	self ffiSetLastError: FFIErrorGenericError. "educated guess if we fail silently"	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	rcvr _ interpreterProxy stackValue: 0.	theClass _ interpreterProxy fetchClassOf: rcvr.	(interpreterProxy includesBehavior: theClass 			ThatOf: interpreterProxy classExternalLibrary) 				ifFalse:[^self ffiFail: FFIErrorBadExternalLibrary].	moduleHandlePtr _ interpreterProxy fetchPointer: 0 ofObject: rcvr.	moduleHandle _ self ffiContentsOfHandle: moduleHandlePtr errCode: FFIErrorBadExternalLibrary.	interpreterProxy failed ifTrue:[^0].	moduleName _ interpreterProxy fetchPointer: 1 ofObject: rcvr.	(interpreterProxy isBytes: moduleName) 		ifFalse:[^self ffiFail: FFIErrorBadExternalLibrary].	moduleLength _ interpreterProxy byteSizeOf: moduleName.	moduleHandle _ interpreterProxy ioLoadModule: (self cCoerce: (interpreterProxy firstIndexableField: moduleName) to:'int') OfLength: moduleLength.	interpreterProxy failed ifTrue:[^self ffiFail: FFIErrorModuleNotFound]. "failed"	"and store back"	ptr _ interpreterProxy firstIndexableField: moduleHandlePtr.	ptr at: 0 put: moduleHandle.	^0 "done"! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 1/26/2000 19:24'!ffiArgByValue: oop	"Support for generic callout. Prepare an argument by value for a callout."	| atomicType intValue floatValue |	self inline: true.	atomicType _ self atomicTypeOf: ffiArgHeader.	"check if the range is valid"	(atomicType < 0 or:[atomicType > FFITypeDoubleFloat])		ifTrue:[^self ffiFail: FFIErrorBadAtomicType].	atomicType < FFITypeSingleFloat ifTrue:["integer types"		(atomicType >> 1) = (FFITypeSignedLongLong >> 1)			ifTrue:[intValue _ oop] "ffi support code must coerce longlong"			ifFalse:[intValue _ self ffiIntegerValueOf: oop]. "does all the coercions"		interpreterProxy failed ifTrue:[^self ffiFail: FFIErrorCoercionFailed].		self dispatchOn: atomicType			in: #(				ffiPushVoid:				ffiPushUnsignedInt:				ffiPushUnsignedByte:				ffiPushSignedByte:				ffiPushUnsignedShort:				ffiPushSignedShort:				ffiPushUnsignedInt:				ffiPushSignedInt:				ffiPushUnsignedLongLongOop:				ffiPushSignedLongLongOop:				ffiPushUnsignedChar:				ffiPushSignedChar:)		with: intValue.	] ifFalse:[		"either float or double"		floatValue _ self ffiFloatValueOf: oop.		interpreterProxy failed ifTrue:[^self ffiFail: FFIErrorCoercionFailed].		atomicType = FFITypeSingleFloat			ifTrue:[self ffiPushSingleFloat: floatValue]			ifFalse:[self ffiPushDoubleFloat: floatValue].	].	^0! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 1/27/2000 00:06'!ffiArgument: oop Spec: argSpec Class: argClass	"Callout support. Prepare the given oop as argument.	argSpec defines the compiled spec for the argument.	argClass (if non-nil) defines the required (super)class for the argument."	| valueOop oopClass isStruct nilOop |	self inline: false.	oopClass _ interpreterProxy fetchClassOf: oop. "Prefetch class (we'll need it)"	nilOop _  interpreterProxy nilObject.	"Do the necessary type checks"	argClass == nilOop ifFalse:[		"Type check 1: 		Is the required class of the argument a subclass of ExternalStructure?"		(interpreterProxy includesBehavior: argClass 						ThatOf: interpreterProxy classExternalStructure)			ifFalse:[^self ffiFail: FFIErrorWrongType]. "Nope. Fail."		"Type check 2:		Is the class of the argument a subclass of required class?"		((nilOop == oop) or:[interpreterProxy includesBehavior: oopClass ThatOf: argClass])				ifFalse:[^self ffiFail: FFIErrorCoercionFailed]. "Nope. Fail."		"Okay, we've passed the type check (so far)"	].	"Check if oopClass is a subclass of ExternalStructure.	If this is the case we'll work on it's handle and not the actual oop."	isStruct _ false.	((interpreterProxy isIntegerObject: oop) or:[oop == nilOop]) ifFalse:[		"#isPointers: will fail if oop is SmallInteger so don't even attempt to use it"		(interpreterProxy isPointers: oop) 			ifTrue:[isStruct _ interpreterProxy includesBehavior: oopClass 								ThatOf: interpreterProxy classExternalStructure.					(argClass == nilOop or:[isStruct]) 						ifFalse:[^self ffiFail: FFIErrorCoercionFailed]].		"note: the test for #isPointers: above should speed up execution since no pointer type ST objects are allowed in external calls and thus if #isPointers: is true then the arg must be ExternalStructure to work. If it isn't then the code fails anyways so speed isn't an issue"	].	"Determine valueOop (e.g., the actual oop to pass as argument)"	isStruct		ifTrue:[valueOop _ interpreterProxy fetchPointer: 0 ofObject: oop]		ifFalse:[valueOop _ oop].	ffiArgClass _ argClass.	"Fetch and check the contents of the compiled spec"	(interpreterProxy isIntegerObject: argSpec)		ifTrue:[self ffiFail: FFIErrorWrongType. ^nil].	(interpreterProxy isWords: argSpec)		ifFalse:[self ffiFail: FFIErrorWrongType. ^nil].	ffiArgSpecSize _ interpreterProxy slotSizeOf: argSpec.	ffiArgSpecSize = 0 ifTrue:[self ffiFail: FFIErrorWrongType. ^nil].	ffiArgSpec _ self cCoerce: (interpreterProxy firstIndexableField: argSpec) to: 'int'.	ffiArgHeader _ interpreterProxy longAt: ffiArgSpec.	"Do the actual preparation of the argument"	"Note: Order is important since FFIFlagStructure + FFIFlagPointer is used to represent 'typedef void* VoidPointer' and VoidPointer really is *struct* not pointer."	(ffiArgHeader anyMask: FFIFlagStructure) ifTrue:[		"argument must be ExternalStructure"		isStruct ifFalse:[^self ffiFail: FFIErrorCoercionFailed].		(ffiArgHeader anyMask: FFIFlagAtomic) 			ifTrue:[^self ffiFail: FFIErrorWrongType]. "bad combination"		^self ffiPushStructureContentsOf: valueOop].	(ffiArgHeader anyMask: FFIFlagPointer) ifTrue:[		"no integers for pointers please"		(interpreterProxy isIntegerObject: oop) 			ifTrue:[^self ffiFail: FFIErrorIntAsPointer].		"but allow passing nil pointer for any pointer type"		oop == interpreterProxy nilObject ifTrue:[^self ffiPushPointer: nil].		"argument is reference to either atomic or structure type"		(ffiArgHeader anyMask: FFIFlagAtomic) ifTrue:[			isStruct "e.g., ExternalData"				ifTrue:[^self ffiAtomicStructByReference: oop Class: oopClass]				ifFalse:[^self ffiAtomicArgByReference: oop Class: oopClass].			"********* NOTE: The above uses 'oop' not 'valueOop' (for ExternalData) ******"		].		"Needs to be external structure here"		isStruct ifFalse:[^self ffiFail: FFIErrorCoercionFailed].		^self ffiPushPointerContentsOf: valueOop].	(ffiArgHeader anyMask: FFIFlagAtomic) ifTrue:[		"argument is atomic value"		self ffiArgByValue: valueOop.		^0].	"None of the above - bad spec"	^self ffiFail: FFIErrorWrongType! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 1/26/2000 22:38'!ffiAtomicArgByReference: oop Class: oopClass	"Support for generic callout. Prepare a pointer reference to an atomic type for callout. Note: for type 'void*' we allow either one of ByteArray/String/Symbol or wordVariableSubclass."	| atomicType isString |	self inline: true.	atomicType _ self atomicTypeOf: ffiArgHeader.	(atomicType = FFITypeBool) "No bools on input"		ifTrue:[^self ffiFail: FFIErrorCoercionFailed].	((atomicType >> 1) = (FFITypeSignedChar >> 1)) ifTrue:["string value (char*)"		"note: the only types allowed for passing into char* types are		ByteArray, String, Symbol and *no* other byte indexed objects		(e.g., CompiledMethod, LargeInteger). We only check for strings		here and fall through to the byte* check otherwise."		isString _ interpreterProxy 					includesBehavior: oopClass 					ThatOf: interpreterProxy classString.		isString ifTrue:["String/Symbol"			"Strings must be allocated by the ffi support code"			^self ffiPushString: (self cCoerce: (interpreterProxy firstIndexableField: oop) to: 'int') OfLength: (interpreterProxy byteSizeOf: oop)].		"Fall through to byte* test"		atomicType _ FFITypeUnsignedByte].	(atomicType = FFITypeVoid or:[(atomicType >> 1) = (FFITypeSignedByte >> 1)]) ifTrue:[		"byte* -- see comment on string above"		oopClass = interpreterProxy classByteArray ifTrue:["ByteArray"			^self ffiPushPointer: (self cCoerce: (interpreterProxy firstIndexableField: oop) to:'int')].		isString _ interpreterProxy includesBehavior: oopClass 					ThatOf: interpreterProxy classString.		isString ifTrue:["String/Symbol"			^self ffiPushPointer: (self cCoerce: (interpreterProxy firstIndexableField: oop) to:'int')].		atomicType = FFITypeVoid ifFalse:[^self ffiFail: FFIErrorCoercionFailed].		"note: type void falls through"	].	(atomicType <= FFITypeSignedInt "void/short/int"		or:[atomicType = FFITypeSingleFloat]) ifTrue:[			"require a word subclass to work"			(interpreterProxy isWords: oop) ifTrue:[				^self ffiPushPointer: (self cCoerce: (interpreterProxy firstIndexableField: oop) to:'int')]].	^self ffiFail: FFIErrorCoercionFailed.! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 1/26/2000 23:43'!ffiAtomicStructByReference: oop Class: oopClass	"Support for generic callout. Prepare an external pointer reference to an atomic type for callout."	| atomicType valueOop |	self inline: true.	"must be external data to pass pointers to atomic type"	oopClass == interpreterProxy classExternalData 		ifFalse:[^self ffiFail: FFIErrorCoercionFailed].	atomicType _ self atomicTypeOf: ffiArgHeader.	"no type checks for void pointers"	atomicType ~= FFITypeVoid ifTrue:[		self ffiValidateExternalData: oop AtomicType: atomicType.		interpreterProxy failed ifTrue:[^nil].	].	"and push pointer contents"	valueOop _ interpreterProxy fetchPointer: 0 ofObject: oop.	^self ffiPushPointerContentsOf: valueOop! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 12/2/1999 22:19'!ffiCall: address WithFlags: callType AndTypes: argTypeArray	"Generic callout. Does the actual work."	| stackIndex argType argTypes oop nArgs argClass argSpec |	self inline: true.	"check if the calling convention is supported"	(self ffiSupportsCallingConvention: callType)		ifFalse:[^self ffiFail: FFIErrorCallType].	argTypes _ argTypeArray.	"Fetch return type and args"	argType _ interpreterProxy fetchPointer: 0 ofObject: argTypes.	argSpec _ interpreterProxy fetchPointer: 0 ofObject: argType.	argClass _ interpreterProxy fetchPointer: 1 ofObject: argType.	self ffiCheckReturn: argSpec With: argClass.	interpreterProxy failed ifTrue:[^0]. "cannot return"	ffiRetOop _ argType.	nArgs _ interpreterProxy methodArgumentCount.	stackIndex _ nArgs - 1. "stack index goes downwards"	1 to: nArgs do:[:i|		argType _ interpreterProxy fetchPointer: i ofObject: argTypes.		argSpec _ interpreterProxy fetchPointer: 0 ofObject: argType.		argClass _ interpreterProxy fetchPointer: 1 ofObject: argType.		oop _ interpreterProxy stackValue: stackIndex.		self ffiArgument: oop Spec: argSpec Class: argClass.		interpreterProxy failed ifTrue:[^0]. "coercion failed"		stackIndex _ stackIndex - 1.	].	"Go out and call this guy"	^self ffiCalloutTo: address WithFlags: callType! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 12/2/1999 22:19'!ffiCall: address WithFlags: callType Args: argArray AndTypes: argTypeArray OfSize: nArgs	"Generic callout. Does the actual work."	| argType argTypes oop argSpec argClass |	self inline: true.	"check if the calling convention is supported"	(self ffiSupportsCallingConvention: callType)		ifFalse:[^self ffiFail: FFIErrorCallType].	argTypes _ argTypeArray.	"Fetch return type and args"	argType _ interpreterProxy fetchPointer: 0 ofObject: argTypes.	argSpec _ interpreterProxy fetchPointer: 0 ofObject: argType.	argClass _ interpreterProxy fetchPointer: 1 ofObject: argType.	self ffiCheckReturn: argSpec With: argClass.	interpreterProxy failed ifTrue:[^0]. "cannot return"	ffiRetOop _ argType.	1 to: nArgs do:[:i|		argType _ interpreterProxy fetchPointer: i ofObject: argTypes.		argSpec _ interpreterProxy fetchPointer: 0 ofObject: argType.		argClass _ interpreterProxy fetchPointer: 1 ofObject: argType.		oop _ interpreterProxy fetchPointer: i-1 ofObject: argArray.		self ffiArgument: oop Spec: argSpec Class: argClass.		interpreterProxy failed ifTrue:[^0]. "coercion failed"	].	"Go out and call this guy"	^self ffiCalloutTo: address WithFlags: callType! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 1/26/2000 23:11'!ffiCalloutTo: address WithFlags: callType	"Go out, call this guy and create the return value"	| retVal |	self inline: false.	"Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent 'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct"	(ffiRetHeader anyMask: FFIFlagPointer) ifTrue:[		retVal _ self ffiCallAddressOf: address WithPointerReturn: callType.		^self ffiCreateReturnPointer: retVal.	].	(ffiRetHeader anyMask: FFIFlagStructure) ifTrue:[		self 			ffiCallAddressOf: address 			With: callType 			Struct: (self cCoerce: ffiRetSpec to:'int*')			Return: ffiRetSpecSize.		^self ffiCreateReturnStruct.	].	retVal _ self ffiCallAddressOf: address With: callType ReturnType: ffiRetHeader.	^self ffiCreateReturn: retVal.! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 12/2/1999 21:29'!ffiCheckReturn: retSpec With: retClass	"Make sure we can return an object of the given type"	self inline: true.	retClass == interpreterProxy nilObject ifFalse:[		(interpreterProxy includesBehavior: retClass 						ThatOf: interpreterProxy classExternalStructure)			ifFalse:[^self ffiFail: FFIErrorBadReturn]].	ffiRetClass _ retClass.	(interpreterProxy isIntegerObject: retSpec)		ifTrue:[self ffiFail: FFIErrorWrongType. ^nil].	(interpreterProxy isWords: retSpec)		ifFalse:[self ffiFail: FFIErrorWrongType. ^nil].	ffiRetSpecSize _ interpreterProxy slotSizeOf: retSpec.	ffiRetSpecSize = 0 ifTrue:[self ffiFail: FFIErrorWrongType. ^nil].	ffiRetSpec _ self cCoerce: (interpreterProxy firstIndexableField: retSpec) to: 'int'.	ffiRetHeader _ interpreterProxy longAt: ffiRetSpec.	(self isAtomicType: ffiRetHeader) ifFalse:[		(ffiRetClass == interpreterProxy nilObject)			ifTrue:[^self ffiFail: FFIErrorBadReturn]].	(self ffiCan: (self cCoerce: ffiRetSpec to:'int*') Return: ffiRetSpecSize)		ifFalse:[self ffiFail: FFIErrorBadReturn]. "cannot return this type"	^0! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 12/2/1999 21:35'!ffiContentsOfHandle: oop errCode: errCode	"Make sure that the given oop is a valid external handle"	self inline: true.	(interpreterProxy isIntegerObject: oop)		ifTrue:[^self ffiFail: errCode].	(interpreterProxy isBytes: oop)		ifFalse:[^self ffiFail: errCode].	((interpreterProxy byteSizeOf: oop) == 4)		ifFalse:[^self ffiFail: errCode].	^interpreterProxy fetchWord: 0 ofObject: oop! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 1/26/2000 19:43'!ffiCreateLongLongReturn: isSigned	"Create a longlong return value from a previous call out"	| lowWord highWord largeClass nBytes largeInt ptr |	self var: #ptr declareC:'unsigned char *ptr'.	lowWord _ self ffiLongLongResultLow.	highWord _ self ffiLongLongResultHigh.	isSigned ifTrue:["check for 32 bit signed"		(highWord = 0 and:[lowWord >= 0])			ifTrue:[^interpreterProxy signed32BitIntegerFor: lowWord].		(highWord = -1 and:[lowWord < 0])			ifTrue:[^interpreterProxy signed32BitIntegerFor: lowWord].		"negate value for negative longlong"		highWord < 0 			ifTrue:[	largeClass _ interpreterProxy classLargeNegativeInteger.					lowWord _ lowWord bitInvert32.					highWord _ highWord bitInvert32.					lowWord = -1 "e.g., overflow when adding one"						ifTrue:[highWord _ highWord + 1].					lowWord _ lowWord + 1]			ifFalse:[largeClass _ interpreterProxy classLargePositiveInteger].			"fall through"	] ifFalse:["check for 32 bit unsigned"		highWord = 0 ifTrue:[			^interpreterProxy positive32BitIntegerFor: lowWord].		largeClass _ interpreterProxy classLargePositiveInteger.		"fall through"	].	"Create LargeInteger result"	nBytes _ 8.	(highWord anyMask: 255 << 24) ifFalse:[		nBytes _ 7.		highWord < (1 << 16) ifTrue:[nBytes _ 6].		highWord < (1 << 8) ifTrue:[nBytes _ 5].		highWord = 0 ifTrue:[nBytes _ 4]].	"now we know how many bytes to create"	largeInt _ interpreterProxy instantiateClass: largeClass indexableSize: nBytes.	(interpreterProxy isBytes: largeInt) 		ifFalse:[^self ffiFail: FFIErrorBadReturn]. "Hossa!!"	ptr _ interpreterProxy firstIndexableField: largeInt.	4 to: nBytes-1 do:[:i|		ptr at: i put: (highWord >> (i-4*8) bitAnd: 255)].	ptr at: 3 put: (lowWord >> 24 bitAnd: 255).	ptr at: 2 put: (lowWord >> 16 bitAnd: 255).	ptr at: 1 put: (lowWord >> 8 bitAnd: 255).	ptr at: 0 put: (lowWord bitAnd: 255).	^largeInt! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 1/26/2000 19:47'!ffiCreateReturn: retVal	"Generic callout support. Create an atomic return value from an external function call"	| atomicType retOop oop |	self inline: true.	interpreterProxy failed ifTrue:[^nil].	atomicType _ self atomicTypeOf: ffiRetHeader.	"void returns self"	atomicType <= FFITypeVoid ifTrue:[		^interpreterProxy pop: interpreterProxy methodArgumentCount].	"everything else returns value"	interpreterProxy pop: 		interpreterProxy methodArgumentCount+1.	interpreterProxy pushRemappableOop: ffiRetClass.	retOop _ self ffiCreateReturnOop: retVal.	ffiRetClass _ interpreterProxy popRemappableOop.	ffiRetClass == interpreterProxy nilObject ifTrue:[		"Just return oop"		^interpreterProxy push: retOop].	"Otherwise create an instance of external structure and store the return oop"	interpreterProxy pushRemappableOop: retOop.	retOop _ interpreterProxy instantiateClass: ffiRetClass indexableSize: 0.	oop _ interpreterProxy popRemappableOop.	interpreterProxy storePointer: 0 ofObject: retOop withValue: oop.	^interpreterProxy push: retOop.! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 1/26/2000 19:41'!ffiCreateReturnOop: retVal	"Callout support. Return the appropriate oop for the given atomic value"	| atomicType shift value mask |	atomicType _ self atomicTypeOf: ffiRetHeader.	atomicType = FFITypeBool ifTrue:[		retVal ifTrue:[^interpreterProxy trueObject].		^interpreterProxy falseObject].	atomicType <= FFITypeSignedInt ifTrue:[		"these are all generall integer returns"		atomicType <= FFITypeSignedShort ifTrue:[			"byte/short. first extract partial word, then sign extend"			shift _ (atomicType >> 1) * 8. "# of significant bits"			value _ retVal bitAnd: (1 << shift - 1). 			(atomicType anyMask: 1) ifTrue:[				"make the guy signed"				mask _ 1 << (shift-1).				value _ (value bitAnd: mask-1) - (value bitAnd: mask)].			^interpreterProxy integerObjectOf: value].		"32bit integer return"		(atomicType anyMask: 1)			ifTrue:[^(interpreterProxy signed32BitIntegerFor: retVal)] "signed return"			ifFalse:[^(interpreterProxy positive32BitIntegerFor: retVal)]]. "unsigned return"	atomicType < FFITypeSingleFloat ifTrue:[		"longlong, char"		(atomicType >> 1) = (FFITypeSignedLongLong >> 1) 			ifTrue:[^self ffiCreateLongLongReturn: (atomicType anyMask: 1)]			ifFalse:[^(interpreterProxy 						fetchPointer: (retVal bitAnd: 255)						ofObject: interpreterProxy characterTable)]].	"float return"	^interpreterProxy floatObjectOf: (self ffiReturnFloatValue).! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 1/26/2000 23:15'!ffiCreateReturnPointer: retVal	"Generic callout support. Create a pointer return value from an external function call"	| atomicType retOop oop ptr classOop |	self var: #ptr declareC:'int *ptr'.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy pop: interpreterProxy methodArgumentCount+1.	(ffiRetClass == interpreterProxy nilObject) ifTrue:[		"Create ExternalData upon return"		atomicType _ self atomicTypeOf: ffiRetHeader.		(atomicType >> 1) = (FFITypeSignedChar >> 1) ifTrue:["String return"			^self ffiReturnCStringFrom: retVal].		"generate external data"		interpreterProxy pushRemappableOop: ffiRetOop.		oop _ interpreterProxy 				instantiateClass: interpreterProxy classExternalAddress 				indexableSize: 4.		ptr _ interpreterProxy firstIndexableField: oop.		ptr at: 0 put: retVal.		interpreterProxy pushRemappableOop: oop. "preserve for gc"		retOop _ interpreterProxy 				instantiateClass: interpreterProxy classExternalData 				indexableSize: 0.		oop _ interpreterProxy popRemappableOop. "external address"		interpreterProxy storePointer: 0 ofObject: retOop withValue: oop.		oop _ interpreterProxy popRemappableOop. "return type"		interpreterProxy storePointer: 1 ofObject: retOop withValue: oop.		^interpreterProxy push: retOop.	].	"non-atomic pointer return"	interpreterProxy pushRemappableOop: ffiRetClass. "preserve for gc"	(ffiRetHeader anyMask: FFIFlagStructure)		ifTrue:[classOop _ interpreterProxy classByteArray]		ifFalse:[classOop _ interpreterProxy classExternalAddress].	oop _ interpreterProxy 			instantiateClass: classOop			indexableSize: 4.	ptr _ interpreterProxy firstIndexableField: oop.	ptr at: 0 put: retVal.	ffiRetClass _ interpreterProxy popRemappableOop. "return class"	interpreterProxy pushRemappableOop: oop. "preserve for gc"	retOop _ interpreterProxy instantiateClass: ffiRetClass indexableSize: 0.	oop _ interpreterProxy popRemappableOop. "external address"	interpreterProxy storePointer: 0 ofObject: retOop withValue: oop.	^interpreterProxy push: retOop.! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 12/2/1999 21:33'!ffiCreateReturnStruct	"Generic callout support. Create a structure return value from an external function call"	| retOop structSize oop |	self inline: true.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy pop: interpreterProxy methodArgumentCount+1.	structSize _ ffiRetHeader bitAnd: FFIStructSizeMask.	interpreterProxy pushRemappableOop: ffiRetClass.	oop _ interpreterProxy 			instantiateClass: interpreterProxy classByteArray 			indexableSize: structSize.	self ffiStore: (self cCoerce: (interpreterProxy firstIndexableField: oop) to:'int') 		Structure: structSize.	ffiRetClass _ interpreterProxy popRemappableOop.	interpreterProxy pushRemappableOop: oop. "secure byte array"	retOop _ interpreterProxy instantiateClass: ffiRetClass indexableSize: 0.	oop _ interpreterProxy popRemappableOop.	interpreterProxy storePointer: 0 ofObject: retOop withValue: oop.	^interpreterProxy push: retOop.! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 11/29/1999 10:42'!ffiFail: reason	self inline: true.	self ffiSetLastError: reason.	^interpreterProxy primitiveFail! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 12/2/1999 21:36'!ffiFloatValueOf: oop	"Support for generic callout. Return a float value that is coerced as C would do."	| oopClass |	self returnTypeC:'double'.	oopClass _ interpreterProxy fetchClassOf: oop.	oopClass == interpreterProxy classFloat		ifTrue:[^interpreterProxy floatValueOf: oop].	"otherwise try the integer coercions and return its float value"	^(self ffiIntegerValueOf: oop) asFloat! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 11/28/1999 18:06'!ffiGetLastError	^ffiLastError! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 12/1/1999 18:55'!ffiIntegerValueOf: oop	"Support for generic callout. Return an integer value that is coerced as C would do."	| oopClass |	self inline: true.	(interpreterProxy isIntegerObject: oop) ifTrue:[^interpreterProxy integerValueOf: oop].	oop == interpreterProxy nilObject ifTrue:[^0]. "@@: should we really allow this????"	oop == interpreterProxy falseObject ifTrue:[^0].	oop == interpreterProxy trueObject ifTrue:[^1].	oopClass _ interpreterProxy fetchClassOf: oop.	oopClass == interpreterProxy classFloat		ifTrue:[^(interpreterProxy floatValueOf: oop) asInteger].	oopClass == interpreterProxy classCharacter		ifTrue:[^interpreterProxy fetchInteger: 0 ofObject: oop].	^interpreterProxy signed32BitValueOf: oop "<- will fail if not integer"! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 1/26/2000 23:08'!ffiPushPointerContentsOf: oop	"Push the contents of the given external structure"	| ptrValue ptrClass ptrAddress |	self inline: false.	ptrValue _ oop.	ptrClass _ interpreterProxy fetchClassOf: ptrValue.	ptrClass == interpreterProxy classExternalAddress ifTrue:[		ptrAddress _ interpreterProxy fetchWord: 0 ofObject: ptrValue.		"Don't you dare to pass pointers into object memory"		(interpreterProxy isInMemory: ptrAddress)			ifTrue:[^self ffiFail: FFIErrorInvalidPointer].		^self ffiPushPointer: ptrAddress].	ptrClass == interpreterProxy classByteArray ifTrue:[		ptrAddress _ self cCoerce: (interpreterProxy firstIndexableField: ptrValue) to: 'int'.		^self ffiPushPointer: ptrAddress].	^self ffiFail: FFIErrorBadArg! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 11/28/1999 18:21'!ffiPushSignedLongLongOop: oop	"Push a longlong type (e.g., a 64bit integer).	Note: Coercions from float are *not* supported."	| lowWord highWord length oopClass negative ptr |	self var: #ptr declareC:'unsigned char *ptr'.	oop == interpreterProxy nilObject 		ifTrue:[^self ffiPushSignedLong: 0 Long: 0.]. "@@: check this"	oop == interpreterProxy falseObject		ifTrue:[^self ffiPushSignedLong: 0 Long: 0].	oop == interpreterProxy trueObject		ifTrue:[^self ffiPushSignedLong: 0 Long: 1].	(interpreterProxy isIntegerObject: oop) ifTrue:[		lowWord _ interpreterProxy integerValueOf: oop.		lowWord < 0 			ifTrue:[highWord _ -1]			ifFalse:[highWord _ 0].	] ifFalse:[		oopClass _ interpreterProxy fetchClassOf: oop.		oopClass == interpreterProxy classLargePositiveInteger 			ifTrue:[negative _ false]			ifFalse:[oopClass == interpreterProxy classLargeNegativeInteger 				ifTrue:[negative _ true]				ifFalse:[^self ffiFail: FFIErrorCoercionFailed]].		(interpreterProxy isBytes: oop) ifFalse:[^self ffiFail: FFIErrorCoercionFailed].		length _ interpreterProxy byteSizeOf: oop.		length > 8 ifTrue:[^self ffiFail: FFIErrorCoercionFailed].		lowWord _ highWord _ 0.		ptr _ interpreterProxy firstIndexableField: oop.		0 to: (length min: 4)-1 do:[:i|			lowWord _ lowWord + ((ptr at: i) << (i*8))].		0 to: (length-5) do:[:i|			highWord _ highWord + ((ptr at: i+4) << (i*8))].		negative ifTrue:[			lowWord _ lowWord bitInvert32.			highWord _ highWord bitInvert32.			lowWord = -1 "e.g., will overflow when adding one"				ifTrue:[highWord _ highWord + 1].			lowWord _ lowWord + 1].	].	^self ffiPushSignedLong: lowWord Long: highWord.! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 1/27/2000 00:02'!ffiPushStructureContentsOf: oop	"Push the contents of the given external structure"	| ptrValue ptrClass ptrAddress |	self inline: true.	ptrValue _ oop.	ptrClass _ interpreterProxy fetchClassOf: ptrValue.	ptrClass == interpreterProxy classExternalAddress ifTrue:[		ptrAddress _ interpreterProxy fetchWord: 0 ofObject: ptrValue.		"There is no way we can make sure the structure is valid.		But we can at least check for attempts to pass pointers to ST memory."		(interpreterProxy isInMemory: ptrAddress)			ifTrue:[^self ffiFail: FFIErrorInvalidPointer].		^self ffiPush: ptrAddress 				Structure: (self cCoerce: ffiArgSpec to:'int*')				OfLength: ffiArgSpecSize].	ptrClass == interpreterProxy classByteArray ifTrue:[		"The following is a somewhat pessimistic test but I like being sure..."		(interpreterProxy byteSizeOf: ptrValue) = (ffiArgHeader bitAnd: FFIStructSizeMask)			ifFalse:[^self ffiFail: FFIErrorStructSize].		ptrAddress _ self cCoerce: (interpreterProxy firstIndexableField: ptrValue) to: 'int'.		(ffiArgHeader anyMask: FFIFlagPointer) ifFalse:[			^self ffiPush: ptrAddress 					Structure: (self cCoerce: ffiArgSpec to: 'int*')					OfLength: ffiArgSpecSize].		"If FFIFlagPointer + FFIFlagStructure is set use ffiPushPointer on the contents"		(ffiArgHeader bitAnd: FFIStructSizeMask) = 4			ifFalse:[^self ffiFail: FFIErrorStructSize].		ptrAddress _ interpreterProxy fetchWord: 0 ofObject: ptrValue.		(interpreterProxy isInMemory: ptrAddress)			ifTrue:[^self ffiFail: FFIErrorInvalidPointer].		^self ffiPushPointer: ptrAddress].	^self ffiFail: FFIErrorBadArg! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 11/28/1999 19:05'!ffiPushUnsignedLongLongOop: oop	"Push a longlong type (e.g., a 64bit integer).	Note: Coercions from float are *not* supported."	| lowWord highWord length ptr |	self var: #ptr declareC:'unsigned char *ptr'.	oop == interpreterProxy nilObject 		ifTrue:[^self ffiPushUnsignedLong: 0 Long: 0.]. "@@: check this"	oop == interpreterProxy falseObject 		ifTrue:[^self ffiPushUnsignedLong: 0 Long: 0].	oop == interpreterProxy trueObject 		ifTrue:[^self ffiPushUnsignedLong: 0 Long: 1].	(interpreterProxy isIntegerObject: oop) ifTrue:[		lowWord _ interpreterProxy integerValueOf: oop.		lowWord < 0 ifTrue:[^self ffiFail: FFIErrorCoercionFailed].		highWord _ 0.	] ifFalse:[		(interpreterProxy fetchClassOf: oop) = interpreterProxy classLargePositiveInteger			ifFalse:[^interpreterProxy primitiveFail].		(interpreterProxy isBytes: oop) ifFalse:[^self ffiFail: FFIErrorCoercionFailed].		length _ interpreterProxy byteSizeOf: oop.		length > 8 ifTrue:[^self ffiFail: FFIErrorCoercionFailed].		lowWord _ highWord _ 0.		ptr _ interpreterProxy firstIndexableField: oop.		0 to: (length min: 4)-1 do:[:i|			lowWord _ lowWord + ((ptr at: i) << (i*8))].		0 to: (length-5) do:[:i|			highWord _ highWord + ((ptr at: i+4) << (i*8))].	].	^self ffiPushUnsignedLong: lowWord Long: highWord.! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 11/28/1999 19:25'!ffiPushVoid: ignored	"This is a fallback in case somebody tries to pass a 'void' value.	We could simply ignore the argument but I think it's better to let	the caller know what he did"	^self ffiFail: FFIErrorAttemptToPassVoid.! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 11/28/1999 18:25'!ffiReturnCStringFrom: cPointer	"Create a Smalltalk string from a zero terminated C string"	| strLen strOop cString strPtr |	self var: #cString declareC:'char *cString'.	self var: #strPtr declareC:'char *strPtr'.	cPointer = nil ifTrue:[		^interpreterProxy push: interpreterProxy nilObject]. "nil always returs as nil"	cString _ self cCoerce: cPointer to:'char *'.	strLen _ 0.	[(cString at: strLen) = 0] whileFalse:[strLen _ strLen+1].	strOop _ interpreterProxy 				instantiateClass: interpreterProxy classString 				indexableSize: strLen.	strPtr _ interpreterProxy firstIndexableField: strOop.	0 to: strLen-1 do:[:i| strPtr at: i put: (cString at: i)].	^interpreterProxy push: strOop! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 11/28/1999 18:25'!ffiSetLastError: errCode	^ffiLastError _ errCode! !!FFIPlugin methodsFor: 'callout support' stamp: 'ar 12/2/1999 21:37'!ffiValidateExternalData: oop AtomicType: atomicType	"Validate if the given oop (an instance of ExternalData) can be passed as a pointer to the given atomic type."	| ptrType specOop spec specType |	self inline: true.	ptrType _ interpreterProxy fetchPointer: 1 ofObject: oop.	(interpreterProxy isIntegerObject: ptrType)		ifTrue:[^self ffiFail: FFIErrorWrongType].	(interpreterProxy isPointers: ptrType)		ifFalse:[^self ffiFail: FFIErrorWrongType].	(interpreterProxy slotSizeOf: ptrType) < 2		ifTrue:[^self ffiFail: FFIErrorWrongType].	specOop _ interpreterProxy fetchPointer: 0 ofObject: ptrType.	(interpreterProxy isIntegerObject: specOop)		ifTrue:[^self ffiFail: FFIErrorWrongType].	(interpreterProxy isWords: specOop)		ifFalse:[^self ffiFail: FFIErrorWrongType].	(interpreterProxy slotSizeOf: specOop) = 0		ifTrue:[^self ffiFail: FFIErrorWrongType].	spec _ interpreterProxy fetchWord: 0 ofObject: specOop.	(self isAtomicType: spec)		ifFalse:[^self ffiFail: FFIErrorWrongType].	specType _ self atomicTypeOf: spec.	specType ~= atomicType ifTrue:[		"allow for signed/unsigned conversion but nothing else"		(atomicType > FFITypeBool and:[atomicType < FFITypeSingleFloat])			ifFalse:[^self ffiFail: FFIErrorCoercionFailed].		((atomicType >> 1) = (specType >> 1))			ifFalse:[^self ffiFail: FFIErrorCoercionFailed]].	^0! !!FFIPlugin methodsFor: 'symbol loading' stamp: 'ar 11/28/1999 19:10'!ffiLoadCalloutAddress: lit	"Load the address of the foreign function from the given object"	| addressPtr address ptr |	self var: #ptr declareC:'int *ptr'.	"Lookup the address"	addressPtr _ interpreterProxy fetchPointer: 0 ofObject: lit.	"Make sure it's an external handle"	address _ self ffiContentsOfHandle: addressPtr errCode: FFIErrorBadAddress.	interpreterProxy failed ifTrue:[^0].	address = 0 ifTrue:["Go look it up in the module"		(interpreterProxy slotSizeOf: lit) < 5 ifTrue:[^self ffiFail: FFIErrorNoModule].		address _ self ffiLoadCalloutAddressFrom: lit.		interpreterProxy failed ifTrue:[^0].		"Store back the address"		ptr _ interpreterProxy firstIndexableField: addressPtr.		ptr at: 0 put: address].	^address! !!FFIPlugin methodsFor: 'symbol loading' stamp: 'ar 11/28/1999 20:09'!ffiLoadCalloutAddressFrom: oop	"Load the function address for a call out to an external function"	| module moduleHandle functionName functionLength address |	self inline: false.	"First find and load the module"	module _ interpreterProxy fetchPointer: 4 ofObject: oop.	moduleHandle _ self ffiLoadCalloutModule: module.	interpreterProxy failed ifTrue:[^0]. "failed"	"fetch the function name"	functionName _ interpreterProxy fetchPointer: 3 ofObject: oop.	(interpreterProxy isBytes: functionName) ifFalse:[^self ffiFail: FFIErrorBadExternalFunction].	functionLength _ interpreterProxy byteSizeOf: functionName.	address _ interpreterProxy ioLoadSymbol: 					(self cCoerce: (interpreterProxy firstIndexableField: functionName) to:'int')					OfLength: functionLength 					FromModule: moduleHandle.	(interpreterProxy failed or:[address = 0])		ifTrue:[^self ffiFail: FFIErrorAddressNotFound].	^address! !!FFIPlugin methodsFor: 'symbol loading' stamp: 'ar 11/28/1999 19:13'!ffiLoadCalloutModule: module	"Load the given module and return its handle"	| moduleHandlePtr moduleHandle moduleName moduleLength rcvr theClass ptr |	self var: #ptr declareC:'int *ptr'.	(interpreterProxy isBytes: module) ifTrue:[		"plain module name"		moduleName _ module.		moduleLength _ interpreterProxy byteSizeOf: moduleName.		moduleHandle _ interpreterProxy ioLoadModule: (self cCoerce: (interpreterProxy firstIndexableField: moduleName) to:'int') OfLength: moduleLength.		interpreterProxy failed ifTrue:[^self ffiFail: FFIErrorModuleNotFound]. "failed"		^moduleHandle].	"Check if the external method is defined in an external library"	rcvr _ interpreterProxy stackValue: interpreterProxy methodArgumentCount.	theClass _ interpreterProxy fetchClassOf: rcvr.	(interpreterProxy includesBehavior: theClass 			ThatOf: interpreterProxy classExternalLibrary) ifFalse:[^0].	"external library"	moduleHandlePtr _ interpreterProxy fetchPointer: 0 ofObject: rcvr.	moduleHandle _ self ffiContentsOfHandle: moduleHandlePtr errCode: FFIErrorBadExternalLibrary.	interpreterProxy failed ifTrue:[^0].	moduleHandle = 0 ifTrue:["need to reload module"		moduleName _ interpreterProxy fetchPointer: 1 ofObject: rcvr.		(interpreterProxy isBytes: moduleName) ifFalse:[^self ffiFail: FFIErrorBadExternalLibrary].		moduleLength _ interpreterProxy byteSizeOf: moduleName.		moduleHandle _ interpreterProxy ioLoadModule: (self cCoerce: (interpreterProxy firstIndexableField: moduleName) to:'int') OfLength: moduleLength.		interpreterProxy failed ifTrue:[^self ffiFail: FFIErrorModuleNotFound]. "failed"		"and store back"		ptr _ interpreterProxy firstIndexableField: moduleHandlePtr.		ptr at: 0 put: moduleHandle].	^moduleHandle! !!FFIPlugin methodsFor: 'primitive support' stamp: 'ar 11/28/1999 23:59'!addressOf: rcvr startingAt: byteOffset size: byteSize	| rcvrClass rcvrSize addr |	(interpreterProxy isBytes: rcvr) ifFalse:[^interpreterProxy primitiveFail].	(byteOffset > 0) ifFalse:[^interpreterProxy primitiveFail].	rcvrClass _ interpreterProxy fetchClassOf: rcvr.	rcvrSize _ interpreterProxy byteSizeOf: rcvr.	rcvrClass == interpreterProxy classExternalAddress ifTrue:[		(rcvrSize = 4) ifFalse:[^interpreterProxy primitiveFail].		addr _ interpreterProxy fetchWord: 0 ofObject: rcvr.		"don't you dare to read from object memory!!"		(addr == 0 or:[interpreterProxy isInMemory: addr])			ifTrue:[^interpreterProxy primitiveFail].	] ifFalse:[		(byteOffset+byteSize-1 <= rcvrSize)			ifFalse:[^interpreterProxy primitiveFail].		addr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'int'.	].	addr _ addr + byteOffset - 1.	^addr! !!FFIPlugin methodsFor: 'primitive support' stamp: 'ar 12/2/1999 21:02'!atomicTypeOf: value	^(value bitAnd: FFIAtomicTypeMask) >> FFIAtomicTypeShift! !!FFIPlugin methodsFor: 'primitive support' stamp: 'ar 12/2/1999 21:04'!isAtomicType: typeSpec	^typeSpec anyMask: FFIFlagAtomic! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FFIPlugin class	instanceVariableNames: ''!!FFIPlugin class methodsFor: 'accessing' stamp: 'ar 11/28/1999 18:55'!declareCVarsIn: aCCodeGen	aCCodeGen addHeaderFile: '"sqFFI.h"'! !!FFIPlugin class methodsFor: 'accessing' stamp: 'ar 12/2/1999 22:19'!moduleName "FFIPlugin translate"	"IMPORTANT: IF YOU CHANGE THE NAME OF THIS PLUGIN YOU MUST CHANGE		Interpreter>>primitiveCalloutToFFI	TO REFLECT THE CHANGE."	^'SqueakFFIPrims'! !!FFIPlugin class methodsFor: 'C support code' stamp: 'ar 1/26/2000 14:27'!sqFFIHeaderFile^'/*****************************************************************************   PROJECT: Squeak foreign function interface*   FILE:    sqFFI.h*   CONTENT: Declarations for the foreign function interface**   AUTHOR:  Andreas Raab (ar)*   ADDRESS: Walt Disney Imagineering, Glendale, CA*   EMAIL:   andreasr@wdi.disney.com*   RCSID:   $Id$**   NOTES:******************************************************************************/#ifndef SQ_FFI_H#define SQ_FFI_H/* Calling conventions */#define FFICallTypeCDecl 0#define FFICallTypeApi 1/* Atomic types */#define FFITypeVoid 0#define FFITypeBool 1#define FFITypeUnsignedByte 2#define FFITypeSignedByte 3#define FFITypeUnsignedShort 4#define FFITypeSignedShort 5#define FFITypeUnsignedInt 6#define FFITypeSignedInt 7#define FFITypeUnsignedLongLong 8#define FFITypeSignedLongLong 9#define FFITypeUnsignedChar 10#define FFITypeSignedChar 11#define FFITypeSingleFloat 12#define FFITypeDoubleFloat 13/* Shift and mask for atomic types */#define FFIAtomicTypeShift 24#define FFIAtomicTypeMask 251658240/* Type flags */#define FFIFlagPointer 131072#define FFIFlagStructure 65536#define FFIFlagAtomic 262144/* Size mask */#define FFIStructSizeMask 65535/* error constants */#define FFINoCalloutAvailable -1#define FFIErrorGenericError 0#define FFIErrorNotFunction 1#define FFIErrorBadArgs 2#define FFIErrorBadArg 3#define FFIErrorIntAsPointer 4#define FFIErrorBadAtomicType 5#define FFIErrorCoercionFailed 6#define FFIErrorWrongType 7#define FFIErrorStructSize 8#define FFIErrorCallType 9#define FFIErrorBadReturn 10#define FFIErrorBadAddress 11#define FFIErrorNoModule 12#define FFIErrorAddressNotFound 13#define FFIErrorAttemptToPassVoid 14#define FFIErrorModuleNotFound 15#define FFIErrorBadExternalLibrary 16#define FFIErrorBadExternalFunction 17#define FFIErrorInvalidPointer 18/* Announce a coming FFI call */int ffiInitialize(void);/* cleanup */int ffiCleanup(void);/* Allocate/free external memory */int ffiAlloc(int byteSize);int ffiFree(int ptr);/* general <=32bit integer loads */int ffiPushSignedByte(int value);int ffiPushUnsignedByte(int value);int ffiPushSignedShort(int value);int ffiPushUnsignedShort(int value);int ffiPushSignedInt(int value);int ffiPushUnsignedInt(int value);/* 64bit integer loads */int ffiPushSignedLongLong(int lowWord, int highWord);int ffiPushUnsignedLongLong(int lowWord, int highWord);/* 64bit integer returns */int ffiLongLongResultLow(void);int ffiLongLongResultHigh(void);/* special <=32bit loads */int ffiPushSignedChar(int value);int ffiPushUnsignedChar(int value);/* float loads */int ffiPushSingleFloat(double value);int ffiPushDoubleFloat(double value);/* structure loads */int ffiPushStructureOfLength(int pointer, int* structSpec, int specSize);/* pointer loads */int ffiPushPointer(int pointer);/* string loads */int ffiPushStringOfLength(int srcIndex, int length);/* return true if calling convention is supported */int ffiSupportsCallingConvention(int callType);/* return true if these types can be returned */int ffiCanReturn(int* structSpec, int specSize);/* call the appropriate function w/ the given return type */int ffiCallAddressOfWithPointerReturn(int fn, int callType);int ffiCallAddressOfWithStructReturn(int fn, int callType, 				     int* structSpec, int specSize);int ffiCallAddressOfWithReturnType(int fn, int callType, int typeSpec);/* store the structure result of a previous call */int ffiStoreStructure(int address, int structSize);/* return the float value from a previous call */double ffiReturnFloatValue(void);#endif /* SQ_FFI_H */'! !!FFIPlugin class methodsFor: 'C support code' stamp: 'ar 1/26/2000 14:28'!sqMacFFIPPCFile^'/*****************************************************************************   PROJECT: Squeak foreign function interface*   FILE:    sqMacFFIPPC.c*   CONTENT: Mac/PPC specific support for the foreign function interface**   AUTHOR:  Andreas Raab (ar)*   ADDRESS: Walt Disney Imagineering, Glendale, CA*   EMAIL:   Andreas.Raab@disney.com*   RCSID:   $Id$**   NOTES:******************************************************************************/#include "sq.h"#include "sqFFI.h"/* note: LONGLONG is usually declared by universal headers */#ifndef LONGLONG#define LONGLONG long long#endifextern struct VirtualMachine *interpreterProxy;#define primitiveFail() interpreterProxy->primitiveFail();#define GP_MAX_REGS 8#define FP_MAX_REGS 13/* Values passed in GPR3-GPR10 */static int GPRegs[8];/* Nr of GPRegs used so far */static int gpRegCount = 0;/* Values passed in FPR1-FPR13 */static double FPRegs[13];/* Nr of FPRegs used so far */static int fpRegCount = 0;/* Max stack size */#define FFI_MAX_STACK 512/* The stack used to assemble the arguments for a call */static int   ffiStack[FFI_MAX_STACK];/* The stack pointer while filling the stack */static int   ffiStackIndex = 0;/* The area for temporarily allocated strings */static char *ffiTempStrings[FFI_MAX_STACK];/* The number of temporarily allocated strings */static int   ffiTempStringCount = 0;/* The return values for calls */static int      intReturnValue;static LONGLONG longReturnValue;static double   floatReturnValue;static int *structReturnValue = NULL;/**************************************************************/#define ARG_CHECK() if(gpRegCount >= GP_MAX_REGS && ffiStackIndex >= FFI_MAX_STACK) return primitiveFail();#define ARG_PUSH(value) { \	ARG_CHECK(); \	if(gpRegCount < GP_MAX_REGS) GPRegs[gpRegCount++] = value; \	ffiStack[ffiStackIndex++] = value; \}/*****************************************************************************//*****************************************************************************//*  ffiInitialize:	Announce that the VM is about to do an external function call. */int ffiInitialize(void){	ffiStackIndex = 0;	gpRegCount = 0;	fpRegCount = 0;	floatReturnValue = 0.0;	return 1;}/*  ffiSupportsCallingConvention:	Return true if the support code supports the given calling convention. */int ffiSupportsCallingConvention(int callType){	if(callType == FFICallTypeCDecl) return 1;	if(callType == FFICallTypeApi) return 1;	return 0;}int ffiAlloc(int byteSize){	return (int) malloc(byteSize);}int ffiFree(int ptr){	if(ptr) free((void*)ptr);	return 1;}/*****************************************************************************//*****************************************************************************/int ffiPushSignedChar(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedChar(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedByte(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedByte(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedShort(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedShort(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedInt(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedInt(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedLongLong(int low, int high){	ARG_PUSH(high);	ARG_PUSH(low);	return 1;}int ffiPushUnsignedLongLong(int low, int high) { 	ARG_PUSH(high); 	ARG_PUSH(low); 	return 1; }int ffiPushSingleFloat(double value){	float floatValue = (float) value;	if(fpRegCount < FP_MAX_REGS) {		/* Still space in FPRegs - so we use the more accurate double value */		FPRegs[fpRegCount++] = value;	}	/* Note: Even for args that are passed in FPRegs 	   we pass the actual 32bit value in either GPRegs	   or stack frame for varargs calls. */	ARG_PUSH(*(int*)(&floatValue));	return 1;}int ffiPushDoubleFloat(double value){	if(fpRegCount < FP_MAX_REGS) {		/* Still space in FPRegs */		FPRegs[fpRegCount++] = value;	}	/* Note: Even for args that are passed in FPRegs 	   we pass the actual 64bit value in either GPRegs	   or stack frame for varargs calls. */	ARG_PUSH(((int*)(&value))[1]);	ARG_PUSH(((int*)(&value))[0]);	return 1;}int ffiPushStructureOfLength(int pointer, int *structSpec, int specSize){	int i, typeSpec;	int *data = (int*) pointer;	for(i = 0; i<specSize; i++) {		typeSpec = structSpec[i];		if(typeSpec & FFIFlagPointer) {			ARG_PUSH(*data);			data++;		} else if(typeSpec & FFIFlagStructure) {			/* embedded structure */		} else {			/* atomic type */			int atomicType = (typeSpec & FFIAtomicTypeMask) >> FFIAtomicTypeShift;			switch(atomicType) {				case FFITypeUnsignedChar:				case FFITypeUnsignedByte:					ffiPushUnsignedByte(*(unsigned char*)data);					break;				case FFITypeSignedChar:				case FFITypeSignedByte:					ffiPushSignedByte(*(signed char*)data);					break;				case FFITypeUnsignedShort:					ffiPushUnsignedShort(*(unsigned short*)data);					break;				case FFITypeSignedShort:					ffiPushSignedShort(*(signed short*)data);					break;				case FFITypeUnsignedInt:					ffiPushUnsignedInt(*(unsigned int*)data);					break;				case FFITypeSignedInt:					ffiPushSignedInt(*(signed int*)data);					break;				case FFITypeUnsignedLongLong:					ffiPushUnsignedLongLong( ((unsigned int*)data)[1], ((unsigned int*)data)[0]);					break;				case FFITypeSignedLongLong:					ffiPushSignedLongLong( ((signed int*)data)[1], ((signed int*)data)[0]);					break;				case FFITypeSingleFloat:					ffiPushSingleFloat( *(float*)data);					break;				case FFITypeDoubleFloat:					{ double fArg;					  ((int*)&fArg)[0] = ((int*)data)[0];					  ((int*)&fArg)[1] = ((int*)data)[1];					  ffiPushDoubleFloat(fArg);					}					break;				default:					return primitiveFail();			}			data = (int*) ((int)data + (typeSpec & FFIStructSizeMask));		}	}	return 1;}int ffiPushPointer(int pointer){	ARG_PUSH(pointer);	return 1;}int ffiPushStringOfLength(int srcIndex, int length){	char *ptr;	ARG_CHECK(); /* fail before allocating */	ptr = (char*) malloc(length+1);	if(!!ptr) return primitiveFail();	memcpy(ptr, (void*)srcIndex, length);	ptr[length] = 0;	ffiTempStrings[ffiTempStringCount++] = ptr;	ARG_PUSH((int)ptr);	return 1;}/*****************************************************************************//*****************************************************************************//*  ffiCanReturn:	Return true if the support code can return the given type. */int ffiCanReturn(int *structSpec, int specSize){	int header = *structSpec;	if(header & FFIFlagPointer) return 1;	if(header & FFIFlagStructure) {		/* structs are always returned as pointers to hidden structures */		int structSize = header & FFIStructSizeMask;		structReturnValue = malloc(structSize);		if(!!structReturnValue) return 0;		ARG_PUSH((int)structReturnValue);	}	return 1;}/*  ffiReturnFloatValue:	Return the value from a previous ffi call with float return type. */double ffiReturnFloatValue(void){	return floatReturnValue;}/*  ffiLongLongResultLow:	Return the low 32bit from the 64bit result of a call to an external function */int ffiLongLongResultLow(void){	return ((int*) &longReturnValue)[1];}/*  ffiLongLongResultHigh:	Return the high 32bit from the 64bit result of a call to an external function */int ffiLongLongResultHigh(void){	return ((int*) &longReturnValue)[0];}/*  ffiStoreStructure:	Store the structure result of a previous ffi call into the given address. */int ffiStoreStructure(int address, int structSize){	if(structReturnValue) {		memcpy((void*)address, (void*)structReturnValue, structSize);	} else {		memcpy((void*)address, (void*)&intReturnValue, structSize);  	}  	return 1;}/*  ffiCleanup:	Cleanup after a foreign function call has completed.	The generic support code only frees the temporarily	allocated strings. */int ffiCleanup(void){	int i;	for(i=0; i<ffiTempStringCount; i++)		free(ffiTempStrings[i]);	ffiTempStringCount = 0;	if(structReturnValue) {		free(structReturnValue);		structReturnValue = NULL;	}	return 1;}/*****************************************************************************//*****************************************************************************/asm int ffiCallAddressOf(int);asm int ffiCallAddressOf(int addr) {	/* Save link register */	mflr r0	stw r0, 8(SP)	/* get stack index and preserve it for copying stuff later */	lwz r4, ffiStackIndex(RTOC)	/* compute frame size */	rlwinm r5, r4, 2, 0, 29  /* ffiStackIndex words to bytes (e.g., "slwi r5, r4, 2") */	addi r5, r5, 24 /* linkage area */	neg  r5, r5     /* stack goes down */	/* adjust stack frame */	stwux SP, SP, r5	/* load the stack frame area */	/* note: r4 == ffiStackIndex */	addi r5, SP, 24         /* dst = SP + linkage area */	lwz r6, ffiStack(RTOC)  /* src = ffiStack */	li r7, 0                /* i = 0 */	b nextItemcopyItem:	rlwinm r8, r7, 2, 0, 29 /* r8 = i << 2 (e.g., "slwi r8, r7, 2") */	lwzx r0, r6, r8         /* r0 = ffiStack[r8] */	addi r7, r7, 1          /* i = i + 1 */	stwx r0, r5, r8         /* dst[r8] = r0 */nextItem:	cmpw r7, r4             /* i < ffiStackIndex ? */	blt copyItem	/* Keep addr in GPR0 so we can load all regs beforehand */	mr r0, r3	/* load all the floating point registers */	lwz r3, fpRegCount	lwz r12, FPRegs(RTOC)	cmpwi r3, 0     /* skip all fpregs if no FP values used */	blt _0_fpregs	cmpwi r3, 8	blt _7_fpregs   /* skip last N fpregs if unused */_all_fpregs:	lfd  fp8, 56(r12)	lfd  fp9, 64(r12)	lfd fp10, 72(r12)	lfd fp11, 80(r12)	lfd fp12, 88(r12)	lfd fp13, 96(r12)_7_fpregs:	lfd  fp1,  0(r12)	lfd  fp2,  8(r12)	lfd  fp3, 16(r12)	lfd  fp4, 24(r12)	lfd  fp5, 32(r12)	lfd  fp6, 40(r12)	lfd  fp7, 48(r12)_0_fpregs:	/* load all the general purpose registers */	lwz  r3, gpRegCount	lwz  r12, GPRegs(RTOC)	cmpwi r3, 4	blt _4_gpregs    /* skip last four gpregs if unused */_all_gpregs:	lwz  r7, 16(r12)	lwz  r8, 20(r12)	lwz  r9, 24(r12)	lwz r10, 28(r12)_4_gpregs:	lwz  r3,  0(r12)	lwz  r4,  4(r12)	lwz  r5,  8(r12)	lwz  r6, 12(r12)_0_gpregs:	/* go calling out */	mr r12, r0      /* tvector into GPR12 */	/* Note: The code below is nearly identical to to what''s described in		"MacOS Runtime Architectures"		Chapter 2, Listing 2-2, pp. 2-11	*/	lwz r0, 0(r12)  /* get entry point */	stw r2, 20(SP)  /* save GPR2 */	mtctr r0        /* move entry point into count register */	lwz r2, 4(r12)  /* new base pointer */	bctrl           /* jump through count register and link */	lwz r2, 20(SP)  /* restore GPR2 */	lwz SP, 0(SP)   /* restore frame */	/* store the result of the call */	stw r3, intReturnValue(RTOC)	lwz r12, longReturnValue(RTOC)	stw r3, 0(r12)	stw r4, 4(r12)	stfd fp1, floatReturnValue(RTOC)	/* and get out of here */	lwz r0, 8(SP)	mtlr r0	blr}int ffiCallAddressOfWithPointerReturn(int fn, int callType){	return ffiCallAddressOf(fn);}int ffiCallAddressOfWithStructReturn(int fn, int callType, int* structSpec, int specSize){	return ffiCallAddressOf(fn);}int ffiCallAddressOfWithReturnType(int fn, int callType, int typeSpec){	return ffiCallAddressOf(fn);}/*****************************************************************************//*****************************************************************************//*****************************************************************************//************ Test functions for the foreign function interface **************//*****************************************************************************//*****************************************************************************//*****************************************************************************/#ifndef NO_FFI_TESTtypedef struct ffiTestPoint2 {	int x;	int y;} ffiTestPoint2;typedef struct ffiTestPoint4 {	int x;	int y;	int z;	int w;} ffiTestPoint4;#pragma export onEXPORT(char) ffiTestChars(char c1, char c2, char c3, char c4);EXPORT(short) ffiTestShorts(short c1, short c2, short c3, short c4);EXPORT(int) ffiTestInts(int c1, int c2, int c3, int c4);EXPORT(float) ffiTestFloats(float f1, float f2);EXPORT(double) ffiTestDoubles(double d1, double d2);EXPORT(char *) ffiPrintString(char *string);EXPORT(ffiTestPoint2) ffiTestStruct64(ffiTestPoint2 pt1, ffiTestPoint2 pt2);EXPORT(ffiTestPoint4) ffiTestStructBig(ffiTestPoint4 pt1, ffiTestPoint4 pt2);EXPORT(ffiTestPoint4*) ffiTestPointers(ffiTestPoint4 *pt1, ffiTestPoint4 *pt2);EXPORT(LONGLONG) ffiTestLongLong(LONGLONG i1, LONGLONG i2);#pragma export off/* test passing characters */EXPORT(char) ffiTestChars(char c1, char c2, char c3, char c4) {	printf("4 characters came in as\nc1 = %c (%x)\nc2 = %c (%x)\nc3 = %c (%x)\nc4 = %c (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return ''C'';}/* test passing shorts */EXPORT(short) ffiTestShorts(short c1, short c2, short c3, short c4) {	printf("4 shorts came in as\ns1 = %d (%x)\ns2 = %d (%x)\ns3 = %d (%x)\ns4 = %d (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return -42;}/* test passing ints */EXPORT(int) ffiTestInts(int c1, int c2, int c3, int c4) {	printf("4 ints came in as\ni1 = %d (%x)\ni2 = %d (%x)\ni3 = %d (%x)\ni4 = %d (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return 42;}/* test passing and returning floats */EXPORT(float) ffiTestFloats(float f1, float f2) {	printf("The two floats are %f and %f\n", f1, f2);	return (float) (f1 + f2);}/* test passing and returning doubles */EXPORT(double) ffiTestDoubles(double d1, double d2) {	printf("The two floats are %f and %f\n", (float)d1, (float)d2);	return d1+d2;}/* test passing and returning strings */EXPORT(char*) ffiPrintString(char *string) {	printf("%s\n", string);	return string;}/* test passing and returning 64bit structures */EXPORT(ffiTestPoint2) ffiTestStruct64(ffiTestPoint2 pt1, ffiTestPoint2 pt2) {	ffiTestPoint2 result;	printf("pt1.x = %d\npt1.y = %d\npt2.x = %d\npt2.y = %d\n",			pt1.x, pt1.y, pt2.x, pt2.y);	result.x = pt1.x + pt2.x;	result.y = pt1.y + pt2.y;	return result;}/* test passing and returning large structures */EXPORT(ffiTestPoint4) ffiTestStructBig(ffiTestPoint4 pt1, ffiTestPoint4 pt2) {	ffiTestPoint4 result;	printf("pt1.x = %d\npt1.y = %d\npt1.z = %d\npt1.w = %d\n",			pt1.x, pt1.y, pt1.z, pt1.w);	printf("pt2.x = %d\npt2.y = %d\npt2.z = %d\npt2.w = %d\n",			pt2.x, pt2.y, pt2.z, pt2.w);	result.x = pt1.x + pt2.x;	result.y = pt1.y + pt2.y;	result.z = pt1.z + pt2.z;	result.w = pt1.w + pt2.w;	return result;}/* test passing and returning pointers */EXPORT(ffiTestPoint4*) ffiTestPointers(ffiTestPoint4 *pt1, ffiTestPoint4 *pt2) {	ffiTestPoint4 *result;	printf("pt1.x = %d\npt1.y = %d\npt1.z = %d\npt1.w = %d\n",			pt1->x, pt1->y, pt1->z, pt1->w);	printf("pt2.x = %d\npt2.y = %d\npt2.z = %d\npt2.w = %d\n",			pt2->x, pt2->y, pt2->z, pt2->w);	result = (ffiTestPoint4*) malloc(sizeof(ffiTestPoint4));	result->x = pt1->x + pt2->x;	result->y = pt1->y + pt2->y;	result->z = pt1->z + pt2->z;	result->w = pt1->w + pt2->w;	return result;}/* test passing and returning longlongs */EXPORT(LONGLONG) ffiTestLongLong(LONGLONG i1, LONGLONG i2) {	return i1 + i2;}#endif /* NO_FFI_TEST */'! !!FFIPlugin class methodsFor: 'C support code' stamp: 'ar 1/26/2000 14:29'!sqUnixFFIFile^'/*****************************************************************************   PROJECT: Squeak foreign function interface*   FILE:    sqUnixFFI.c*   CONTENT: Unix support for the foreign function interface**   AUTHOR:  Andreas Raab (ar)*   ADDRESS: Walt Disney Imagineering, Glendale, CA*   EMAIL:   andreasr@wdi.disney.com*   RCSID:   $Id$**   NOTES:  The Unix version of the FFI support code relies on libffi from*	    http://sourceware.cygnus.com/libffi/******************************************************************************/#include "sq.h"#include "sqFFI.h"#ifndef NO_FFI_SUPPORT#include <ffi.h>extern struct VirtualMachine *interpreterProxy;#define primitiveFail() interpreterProxy->primitiveFail()#if 1#define HAVE_LONGLONG#endif/* Check if HAVE_LONGLONG is defined (should be figured out by configure */#ifdef HAVE_LONGLONG#define HAS_LONGLONG 1#define LONGLONG long long#endif/* Error if LONGLONG is not defined */#if HAS_LONGLONG#ifndef LONGLONG#error "You must define LONGLONG if HAS_LONGLONG is defined"#endif#endif/* Max number of arguments in call */#define FFI_MAX_ARGS 32static ffi_type*  ffiTypes[FFI_MAX_ARGS];static void*      ffiArgs[FFI_MAX_ARGS];static char   ffiBytes[FFI_MAX_ARGS];static short  ffiShorts[FFI_MAX_ARGS];static int    ffiInts[FFI_MAX_ARGS];static float  ffiFloats[FFI_MAX_ARGS];static double ffiDoubles[FFI_MAX_ARGS];static int    ffiArgIndex = 0;static ffi_type*  ffiStructTypes[FFI_MAX_ARGS];static int ffiStructIndex = 0;/* helpers */#define CHECK_ARGS() if(ffiArgIndex >= FFI_MAX_ARGS) return primitiveFail();#define PUSH_TYPE(type) { CHECK_ARGS(); ffiTypes[ffiArgIndex] = &type; }#define PUSH(where, what, type) { \	PUSH_TYPE(type); where[ffiArgIndex] = what; \	ffiArgs[ffiArgIndex] = (void*) (where + ffiArgIndex); \	ffiArgIndex++;\}#define BARG_PUSH(value, type) PUSH(ffiBytes, value, type)#define SARG_PUSH(value, type) PUSH(ffiShorts, value, type)#define IARG_PUSH(value, type) PUSH(ffiInts, value, type)#define FARG_PUSH(value) PUSH(ffiFloats, value, ffi_type_float)#define DARG_PUSH(value) PUSH(ffiDoubles, value, ffi_type_double)#if HAS_LONGLONGstatic LONGLONG ffiLongLongs[FFI_MAX_ARGS];#define LARG_PUSH(value, type) PUSH(ffiLongLongs, value, type)#endif/* The 64bit return value storage area - aligned by the C compiler */static double   returnValue;/* Storage area for large structure returns */static ffi_type* structReturnType = NULL;static void *structReturnValue = NULL;/* The area for temporarily allocated strings */static char *ffiTempStrings[FFI_MAX_ARGS];/* The number of temporarily allocated strings */static int   ffiTempStringCount = 0;/*****************************************************************************//*****************************************************************************//*  ffiInitialize:    Announce that the VM is about to do an external function call. */int ffiInitialize(void){  ffiArgIndex = 0;  ffiTempStringCount = 0;  ffiStructIndex = 0;  structReturnType = NULL;  structReturnValue = NULL;  return 1;}/*  ffiSupportsCallingConvention:    Return true if the support code supports the given calling convention */int ffiSupportsCallingConvention(int callType){  if(callType == FFICallTypeCDecl) return 1;  return 0;}/*  ffiAlloc:    Allocate space from the external heap */int ffiAlloc(int byteSize){  return (int)malloc(byteSize);}/*  ffiFree:    Free space from the external heap */int ffiFree(int pointer){  if(pointer) free((void*)pointer);  return 1;}/*****************************************************************************//*****************************************************************************/int ffiPushSignedByte(int value){  BARG_PUSH((char)value, ffi_type_sint8);  return 1;}int ffiPushUnsignedByte(int value){  BARG_PUSH((char)value, ffi_type_uint8);  return 1;}int ffiPushSignedShort(int value){  SARG_PUSH((short)value, ffi_type_sint16);  return 1;}int ffiPushUnsignedShort(int value){  SARG_PUSH((short)value, ffi_type_uint16);  return 1;}int ffiPushSignedInt(int value){  IARG_PUSH(value, ffi_type_sint32);  return 1;}int ffiPushUnsignedInt(int value){  IARG_PUSH(value, ffi_type_uint32);  return 1;}int ffiPushSignedLongLong(int low, int high){#if HAS_LONGLONG  LONGLONG value = (((LONGLONG) high) << 32)  | ((LONGLONG) (unsigned) low);  LARG_PUSH(value, ffi_type_sint64);  return 1;#else  return primitiveFail();#endif}int ffiPushUnsignedLongLong(int low, int high){#if HAS_LONGLONG  LONGLONG value = (((LONGLONG) high) << 32)  | ((LONGLONG) (unsigned) low);  LARG_PUSH(value, ffi_type_uint64);  return 1;#else  return primitiveFail();#endif}int ffiPushSignedChar(int value){  BARG_PUSH(value, ffi_type_sint8);  return 1;}int ffiPushUnsignedChar(int value){  BARG_PUSH(value, ffi_type_uint8);  return 1;}int ffiPushBool(int value){  IARG_PUSH(value, ffi_type_uint8);  return 1;}int ffiPushSingleFloat(double value){  FARG_PUSH((float)value);  return 1;}int ffiPushDoubleFloat(double value){  DARG_PUSH(value);  return 1;}ffi_type* ffiCreateType(int *structSpec, int structSize){  ffi_type *structType, **newTypes;  int nTypes, i, typeSpec;  /* count the number of atomic types we need to create */  nTypes = 0;  for(i=0; i<structSize; i++) {    typeSpec = structSpec[i];    if(typeSpec & FFIFlagPointer) nTypes++;    else if(typeSpec & FFIFlagAtomic) nTypes++;  }  /* note: nTypes == 0 means an invalid structure */  if(nTypes == 0) {    printf("Warning: nTypes == 0 in ffiCreateTypes\n");    return NULL;  }  /* allocate the structure type */  structType = calloc(1, sizeof(ffi_type));  /* allocate the atomic type refs */  newTypes = calloc(nTypes+1, sizeof(ffi_type*));  /* number of elements in type */  structType->size = (*structSpec) & FFIStructSizeMask;  structType->alignment = 4;  structType->type = FFI_TYPE_STRUCT;  structType->elements = newTypes;  /* now go over the structure and fill in the fields */  nTypes = 0;  for(i=0; i<structSize; i++) {    typeSpec = structSpec[i];    if(typeSpec & FFIFlagPointer) {      newTypes[nTypes++] = &ffi_type_pointer;      continue;    }    if((typeSpec & FFIFlagAtomic) == 0) continue;    switch((typeSpec & FFIAtomicTypeMask) >> FFIAtomicTypeShift) {    case FFITypeBool:      newTypes[nTypes++] = &ffi_type_uint8; break;    case FFITypeUnsignedByte:      newTypes[nTypes++] = &ffi_type_uint8; break;    case FFITypeSignedByte:      newTypes[nTypes++] = &ffi_type_sint8; break;    case FFITypeUnsignedShort:      newTypes[nTypes++] = &ffi_type_uint16; break;    case FFITypeSignedShort:      newTypes[nTypes++] = &ffi_type_sint16; break;    case FFITypeUnsignedInt:      newTypes[nTypes++] = &ffi_type_uint32; break;    case FFITypeSignedInt:      newTypes[nTypes++] = &ffi_type_sint32; break;    case FFITypeUnsignedLongLong:      newTypes[nTypes++] = &ffi_type_uint64; break;    case FFITypeSignedLongLong:      newTypes[nTypes++] = &ffi_type_sint64; break;    case FFITypeUnsignedChar:      newTypes[nTypes++] = &ffi_type_uint8; break;    case FFITypeSignedChar:      newTypes[nTypes++] = &ffi_type_sint8; break;    case FFITypeSingleFloat:      newTypes[nTypes++] = &ffi_type_float; break;    case FFITypeDoubleFloat:      newTypes[nTypes++] = &ffi_type_double; break;    default:      printf("Warning: unknown atomic type (%x) in ffiCreateTypes\n", 	     typeSpec);      free(newTypes);      free(structType);      return NULL;    };  }  newTypes[nTypes++] = NULL;  return structType;}int ffiPushStructureOfLength(int pointer, int* structSpec, int structSize){  ffi_type *structType;  if(pointer == 0) return primitiveFail();  CHECK_ARGS(); /* fail early on */  structType = ffiCreateType(structSpec, structSize);  if(structType == NULL) return primitiveFail();  ffiStructTypes[ffiStructIndex++] = structType;  ffiTypes[ffiArgIndex] = structType;  ffiArgs[ffiArgIndex] = (void*) pointer;  ffiArgIndex++;  return 1;}int ffiPushPointer(int pointer){  IARG_PUSH(pointer, ffi_type_pointer);  return 1;}int ffiPushStringOfLength(int srcIndex, int length){  char *ptr;  ptr = (char*) malloc(length+1);  if(!!ptr) return primitiveFail();  memcpy(ptr, (void*)srcIndex, length);  ptr[length] = 0;  ffiTempStrings[ffiTempStringCount++] = ptr;  IARG_PUSH((int)ptr, ffi_type_pointer);  return 1;}/*****************************************************************************//*****************************************************************************//*  ffiCanReturn:	Return true if the support code can return the given type. */int ffiCanReturn(int *structSpec, int specSize){  int header = *structSpec;  if(header & FFIFlagPointer) return 1;  if(header & FFIFlagStructure) {    int structSize = header & FFIStructSizeMask;    structReturnType = ffiCreateType(structSpec, specSize);    if(!!structReturnType) return 0;    if(structSize > 8) {      structReturnValue = calloc(1,structSize);      if(!!structReturnValue) return 0;      return 1;    }  }  return 1;}/*  ffiReturnFloatValue:    Return the value from a previous ffi call with float return type. */double ffiReturnFloatValue(void){  return returnValue;}/*  ffiLongLongResultLow:    Return the low 32bit from the 64bit result of a call to an external function */int ffiLongLongResultLow(void){#if HAS_LONGLONG  return (int) ( (*(LONGLONG*)&returnValue) & (LONGLONG)0xFFFFFFFFU);#else  return 0;#endif}/*  ffiLongLongResultHigh:    Return the high 32bit from the 64bit result of a call to an external function */int ffiLongLongResultHigh(void){#if HAS_LONGLONG  return (int) ( (*(LONGLONG*)&returnValue) >> 32);#else  return 0;#endif}/*  ffiStoreStructure:    Store the structure result of a previous ffi call into the given address*/int ffiStoreStructure(int address, int structSize){  if(structReturnValue) {    memcpy((void*)address, (void*)structReturnValue, structSize);  } else {    memcpy((void*)address, (void*)&returnValue, structSize);  }  return 1;}/*  ffiCleanup:    Cleanup after a foreign function call has completed.    The generic support code only frees the temporarily    allocated strings. */int ffiCleanup(void){  int i;  for(i=0; i<ffiTempStringCount; i++)    free(ffiTempStrings[i]);  for(i=0; i<ffiStructIndex; i++) {    free(ffiStructTypes[i]->elements);    free(ffiStructTypes[i]);    ffiStructTypes[i]=NULL;  }  if(structReturnType) {    free(structReturnType->elements);    free(structReturnType);    structReturnType = NULL;  }  if(structReturnValue) {    free(structReturnValue);    structReturnValue = NULL;  }  ffiTempStringCount = 0;  ffiStructIndex = 0;  return 1;}/*****************************************************************************//*****************************************************************************/int ffiCallAddress(int fn, ffi_type *returnType, int atomicArgType){  ffi_cif cif;  ffi_status result;  int retVal;  result = ffi_prep_cif(&cif, FFI_DEFAULT_ABI, ffiArgIndex, 			returnType, ffiTypes);  if(result !!= FFI_OK) return primitiveFail();  if(structReturnValue) {    ffi_call(&cif, (void *)fn, (void *)structReturnValue, (void **)ffiArgs);    return (int) structReturnValue;  }  ffi_call(&cif, (void *)fn, (void *)&returnValue, (void **)ffiArgs);  retVal = *(int*)&returnValue;#ifdef FFI_MIPS_N32  /* Note: MIPS N32 ABI returns 64bit for integer/pointer whatever.     This seems to be a bug in the fficall implementation. */  retVal = ((int*)(&returnValue))[1];#endif  /* Promote certain return types to integral size */  switch(atomicArgType) {  case FFITypeUnsignedChar:  case FFITypeUnsignedByte: retVal = *(unsigned char*) &retVal; break;  case FFITypeSignedChar:  case FFITypeSignedByte: retVal = *(signed char*) &retVal; break;  case FFITypeUnsignedShort: retVal = *(unsigned short*) &retVal; break;  case FFITypeSignedShort: retVal = *(signed short*) &retVal; break;  case FFITypeSingleFloat: returnValue = *(float*)&returnValue; break;  }  return retVal;}int ffiCallAddressOfWithPointerReturn(int fn, int callType){  return ffiCallAddress(fn, &ffi_type_pointer,-1);}int ffiCallAddressOfWithStructReturn(int fn, int callType, 				     int *structSpec, int specSize){  if(!!structReturnType) return primitiveFail();  return ffiCallAddress(fn, structReturnType,-1);}int ffiCallAddressOfWithReturnType(int fn, int callType, int typeSpec){  ffi_type *returnType;  int atomicType;  atomicType = (typeSpec & FFIAtomicTypeMask) >> FFIAtomicTypeShift;  switch(atomicType) {  case FFITypeVoid:		returnType = &ffi_type_void; break;  case FFITypeBool:		returnType = &ffi_type_uint8; break;  case FFITypeUnsignedByte:	returnType = &ffi_type_uint8; break;  case FFITypeSignedByte:	returnType = &ffi_type_sint8; break;  case FFITypeUnsignedShort:	returnType = &ffi_type_uint16; break;  case FFITypeSignedShort:	returnType = &ffi_type_sint16; break;  case FFITypeUnsignedInt:	returnType = &ffi_type_uint32; break;  case FFITypeSignedInt:       	returnType = &ffi_type_sint32; break;  case FFITypeUnsignedLongLong: returnType = &ffi_type_uint64; break;  case FFITypeSignedLongLong:	returnType = &ffi_type_sint64; break;  case FFITypeUnsignedChar:	returnType = &ffi_type_uint8; break;  case FFITypeSignedChar:      	returnType = &ffi_type_sint8; break;  case FFITypeSingleFloat:	returnType = &ffi_type_float; break;  case FFITypeDoubleFloat:	returnType = &ffi_type_double; break;  default:    return primitiveFail();  }  return ffiCallAddress(fn, returnType, atomicType);}#endif /* NO_FFI_SUPPORT *//*****************************************************************************//*****************************************************************************//*****************************************************************************//************ Test functions for the foreign function interface **************//*****************************************************************************//*****************************************************************************//*****************************************************************************/#ifndef NO_FFI_TESTtypedef struct ffiTestPoint2 {	int x;	int y;} ffiTestPoint2;typedef struct ffiTestPoint4 {	int x;	int y;	int z;	int w;} ffiTestPoint4;typedef struct ffiTestPointMix {  int x;  double y;  int z;  double w;} ffiTestPointMix;#pragma export onEXPORT(char) ffiTestChars(char c1, char c2, char c3, char c4);EXPORT(short) ffiTestShorts(short c1, short c2, short c3, short c4);EXPORT(int) ffiTestInts(int c1, int c2, int c3, int c4);EXPORT(float) ffiTestFloats(float f1, float f2);EXPORT(double) ffiTestDoubles(double d1, double d2);EXPORT(char *) ffiPrintString(char *string);EXPORT(ffiTestPoint2) ffiTestStruct64(ffiTestPoint2 pt1, ffiTestPoint2 pt2);EXPORT(ffiTestPoint4) ffiTestStructBig(ffiTestPoint4 pt1, ffiTestPoint4 pt2);EXPORT(ffiTestPoint4*) ffiTestPointers(ffiTestPoint4 *pt1, ffiTestPoint4 *pt2);EXPORT(ffiTestPointMix) ffiTestStructMix(ffiTestPointMix pt1, 					 ffiTestPointMix pt2);EXPORT(LONGLONG) ffiTestLongLong(LONGLONG i1, LONGLONG i2);#pragma export off/* test passing characters */EXPORT(char) ffiTestChars(char c1, char c2, char c3, char c4) {	printf("4 characters came in as\nc1 = %c (%x)\nc2 = %c (%x)\nc3 = %c (%x)\nc4 = %c (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return ''C'';}/* test passing shorts */EXPORT(short) ffiTestShorts(short c1, short c2, short c3, short c4) {	printf("4 shorts came in as\ns1 = %d (%x)\ns2 = %d (%x)\ns3 = %d (%x)\ns4 = %d (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return -42;}/* test passing ints */EXPORT(int) ffiTestInts(int c1, int c2, int c3, int c4) {	printf("4 ints came in as\ni1 = %d (%x)\ni2 = %d (%x)\ni3 = %d (%x)\ni4 = %d (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return 42;}/* test passing and returning floats */EXPORT(float) ffiTestFloats(float f1, float f2) {	printf("The two floats are %f and %f\n", f1, f2);	return (float) (f1 + f2);}/* test passing and returning doubles */EXPORT(double) ffiTestDoubles(double d1, double d2) {	printf("The two floats are %f and %f\n", (float)d1, (float)d2);	return d1+d2;}/* test passing and returning strings */EXPORT(char*) ffiPrintString(char *string) {	printf("%s\n", string);	return string;}/* test passing and returning 64bit structures */EXPORT(ffiTestPoint2) ffiTestStruct64(ffiTestPoint2 pt1, ffiTestPoint2 pt2) {	ffiTestPoint2 result;	printf("pt1.x = %d\npt1.y = %d\npt2.x = %d\npt2.y = %d\n",			pt1.x, pt1.y, pt2.x, pt2.y);	result.x = pt1.x + pt2.x;	result.y = pt1.y + pt2.y;	return result;}/* test passing and returning large structures */EXPORT(ffiTestPoint4) ffiTestStructBig(ffiTestPoint4 pt1, ffiTestPoint4 pt2) {	ffiTestPoint4 result;	printf("pt1.x = %d\npt1.y = %d\npt1.z = %d\npt1.w = %d\n",			pt1.x, pt1.y, pt1.z, pt1.w);	printf("pt2.x = %d\npt2.y = %d\npt2.z = %d\npt2.w = %d\n",			pt2.x, pt2.y, pt2.z, pt2.w);	result.x = pt1.x + pt2.x;	result.y = pt1.y + pt2.y;	result.z = pt1.z + pt2.z;	result.w = pt1.w + pt2.w;	return result;}/* test passing and returning pointers */EXPORT(ffiTestPoint4*) ffiTestPointers(ffiTestPoint4 *pt1, ffiTestPoint4 *pt2) {	ffiTestPoint4 *result;	printf("pt1.x = %d\npt1.y = %d\npt1.z = %d\npt1.w = %d\n",			pt1->x, pt1->y, pt1->z, pt1->w);	printf("pt2.x = %d\npt2.y = %d\npt2.z = %d\npt2.w = %d\n",			pt2->x, pt2->y, pt2->z, pt2->w);	result = (ffiTestPoint4*) malloc(sizeof(ffiTestPoint4));	result->x = pt1->x + pt2->x;	result->y = pt1->y + pt2->y;	result->z = pt1->z + pt2->z;	result->w = pt1->w + pt2->w;	return result;}/* test passing and returning longlongs */EXPORT(LONGLONG) ffiTestLongLong(LONGLONG i1, LONGLONG i2) {	return i1 + i2;}#endif /* NO_FFI_TEST */'! !!FFIPlugin class methodsFor: 'C support code' stamp: 'ar 1/26/2000 14:33'!sqWin32FFIFile^'/*****************************************************************************   PROJECT: Squeak foreign function interface*   FILE:    sqWin32FFI.c*   CONTENT: Win32 support for the foreign function interface**   AUTHOR:  Andreas Raab (ar)*   ADDRESS: Walt Disney Imagineering, Glendale, CA*   EMAIL:   andreasr@wdi.disney.com*   RCSID:   $Id$**   NOTES:******************************************************************************/#include "sq.h"#include "sqFFI.h"extern struct VirtualMachine *interpreterProxy;#define primitiveFail() interpreterProxy->primitiveFail();#define LONGLONG __int64/* Max stack size */#define FFI_MAX_ARGS 128/* The stack used to assemble the arguments for a call */static int   ffiArgs[FFI_MAX_ARGS];/* The stack pointer while filling the stack */static int   ffiArgIndex = 0;/* The area for temporarily allocated strings */static char *ffiTempStrings[FFI_MAX_ARGS];/* The number of temporarily allocated strings */static int   ffiTempStringCount = 0;/* The return values for calls */static int      intReturnValue;static int      intReturnValue2;static double   floatReturnValue;static void*    structReturnValue;#define ARG_CHECK() if(ffiArgIndex >= FFI_MAX_ARGS) return primitiveFail();#define ARG_PUSH(value) { ARG_CHECK(); ffiArgs[ffiArgIndex++] = value; }/*****************************************************************************//*****************************************************************************//*  ffiInitialize:	Announce that the VM is about to do an external function call. */int ffiInitialize(void){	ffiArgIndex = 0;	ffiTempStringCount = 0;	return 1;}/*  ffiSupportsCallingConvention:	Return true if the support code supports the given calling convention. */int ffiSupportsCallingConvention(int callType){	if(callType == FFICallTypeCDecl) return 1;	if(callType == FFICallTypeApi) return 1;	return 0;}int ffiAlloc(int byteSize){	return (int) malloc(byteSize);}int ffiFree(int ptr){	if(ptr) free((void*)ptr);	return 1;}/*****************************************************************************//*****************************************************************************/int ffiPushSignedChar(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedChar(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedByte(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedByte(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedShort(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedShort(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedInt(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedInt(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedLongLong(int lowWord, int highWord) { 	ARG_PUSH(lowWord); 	ARG_PUSH(highWord); 	return 1; }int ffiPushUnsignedLongLong(int lowWord, int highWord) { 	ARG_PUSH(lowWord); 	ARG_PUSH(highWord); 	return 1; }int ffiPushSingleFloat(double value){	float floatValue;	floatValue = (float) value;	ARG_PUSH(*(int*)(&floatValue));	return 1;}int ffiPushDoubleFloat(double value){	ARG_PUSH(((int*)(&value))[0]);	ARG_PUSH(((int*)(&value))[1]);	return 1;}int ffiPushStructureOfLength(int pointer, int* structSpec, int structSize){	int nItems, i;	nItems = ((*structSpec & FFIStructSizeMask) + 3) / 4;	if(pointer == 0) 		return primitiveFail();	for(i=0; i < nItems;i++)		ARG_PUSH(((int*)pointer)[i]);	return 1;}int ffiPushPointer(int pointer){	ARG_PUSH(pointer);	return 1;}int ffiPushStringOfLength(int srcIndex, int length){	char *ptr;	ARG_CHECK(); /* fail before allocating */	ptr = (char*) malloc(length+1);	if(!!ptr) return primitiveFail();	memcpy(ptr, (void*)srcIndex, length);	ptr[length] = 0;	ffiTempStrings[ffiTempStringCount++] = ptr;	ARG_PUSH((int)ptr);	return 1;}/*****************************************************************************//*****************************************************************************//*  ffiCanReturn:	Return true if the support code can return the given type. */int ffiCanReturn(int *structSpec, int specSize){	int header = *structSpec;	if(header & FFIFlagPointer) return 1;	if(header & FFIFlagStructure) {		int structSize = header & FFIStructSizeMask;		if(structSize > 8) {			structReturnValue = malloc(structSize);			if(!!structReturnValue) return 0;			ARG_PUSH((int)structReturnValue);		}	}	return 1;}/*  ffiReturnFloatValue:	Return the value from a previous ffi call with float return type. */double ffiReturnFloatValue(void){	return floatReturnValue;}/*  ffiLongLongResultLow:	Return the low 32bit from the 64bit result of a call to an external function */int ffiLongLongResultLow(void){	return intReturnValue;}/*  ffiLongLongResultHigh:	Return the high 32bit from the 64bit result of a call to an external function */int ffiLongLongResultHigh(void){	return intReturnValue2;}/*  ffiStoreStructure:	Store the structure result of a previous ffi call into the given address.	Note: Since the ST allocator always allocates multiples of 32bit we can	use the atomic types for storing <= 64bit result structures. */int ffiStoreStructure(int address, int structSize){	if(structSize <= 4) {		*(int*)address = intReturnValue;		return 1;	}	if(structSize <= 8) {		*(int*)address = intReturnValue;		*(int*)(address+4) = intReturnValue2;		return 1;	}	/* assume pointer to hidden structure */	memcpy((void*)address, (void*) structReturnValue, structSize);	return 1;}/*  ffiCleanup:	Cleanup after a foreign function call has completed. */int ffiCleanup(void){	int i;	for(i=0; i<ffiTempStringCount; i++)		free(ffiTempStrings[i]);	ffiTempStringCount = 0;	if(structReturnValue) {		free(structReturnValue);		structReturnValue = NULL;	}	return 1;}/*****************************************************************************//*****************************************************************************//*  ffiCallAddress:	Perform the actual function call. */int ffiCallAddress(int fn, int callType){	__asm {		push ebx		push ecx		push edx		push edi		push esi		/* alloca() ffiStackIndex size bytes */		mov ecx, ffiArgIndex		shl ecx, 2		sub esp, ecx		/* copy stack */		mov edi, esp		lea esi, ffiArgs		shr ecx, 2		cld		rep movsd		/* go calling */		mov ebx, fn		call ebx		/* store the return values for ints, longlongs and floats */		mov intReturnValue, eax		mov intReturnValue2, edx		fstp floatReturnValue		/* clean up stack if required */		cmp callType, 0		jne noCleanup		mov ecx, ffiArgIndex		shl ecx, 2		add esp, ecxnoCleanup:		/* restore register values */		pop esi		pop edi		pop edx		pop ecx		pop ebx		/* done */	}	return intReturnValue;}int ffiCallAddressOfWithPointerReturn(int fn, int callType){	return ffiCallAddress(fn, callType);}int ffiCallAddressOfWithStructReturn(int fn, int callType, int* structSpec, int specSize){	return ffiCallAddress(fn, callType);}int ffiCallAddressOfWithReturnType(int fn, int callType, int typeSpec){	return ffiCallAddress(fn, callType);}/*****************************************************************************//*****************************************************************************//*****************************************************************************//************ Test functions for the foreign function interface **************//*****************************************************************************//*****************************************************************************//*****************************************************************************/#ifndef NO_FFI_TESTtypedef struct ffiTestPoint2 {	int x;	int y;} ffiTestPoint2;typedef struct ffiTestPoint4 {	int x;	int y;	int z;	int w;} ffiTestPoint4;#pragma export onEXPORT(char) ffiTestChars(char c1, char c2, char c3, char c4);EXPORT(short) ffiTestShorts(short c1, short c2, short c3, short c4);EXPORT(int) ffiTestInts(int c1, int c2, int c3, int c4);EXPORT(float) ffiTestFloats(float f1, float f2);EXPORT(double) ffiTestDoubles(double d1, double d2);EXPORT(char *) ffiPrintString(char *string);EXPORT(ffiTestPoint2) ffiTestStruct64(ffiTestPoint2 pt1, ffiTestPoint2 pt2);EXPORT(ffiTestPoint4) ffiTestStructBig(ffiTestPoint4 pt1, ffiTestPoint4 pt2);EXPORT(ffiTestPoint4*) ffiTestPointers(ffiTestPoint4 *pt1, ffiTestPoint4 *pt2);EXPORT(LONGLONG) ffiTestLongLong(LONGLONG i1, LONGLONG i2);#pragma export off/* test passing characters */EXPORT(char) ffiTestChars(char c1, char c2, char c3, char c4) {	printf("4 characters came in as\nc1 = %c (%x)\nc2 = %c (%x)\nc3 = %c (%x)\nc4 = %c (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return c1+c2;}/* test passing shorts */EXPORT(short) ffiTestShorts(short c1, short c2, short c3, short c4) {	printf("4 shorts came in as\ns1 = %d (%x)\ns2 = %d (%x)\ns3 = %d (%x)\ns4 = %d (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return c1+c2;}/* test passing ints */EXPORT(int) ffiTestInts(int c1, int c2, int c3, int c4) {	printf("4 ints came in as\ni1 = %d (%x)\ni2 = %d (%x)\ni3 = %d (%x)\ni4 = %d (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return c1+c2;}/* test passing and returning floats */EXPORT(float) ffiTestFloats(float f1, float f2) {	printf("The two floats are %f and %f\n", f1, f2);	return (float) (f1 + f2);}/* test passing and returning doubles */EXPORT(double) ffiTestDoubles(double d1, double d2) {	printf("The two floats are %f and %f\n", (float)d1, (float)d2);	return d1+d2;}/* test passing and returning strings */EXPORT(char*) ffiPrintString(char *string) {	printf("%s\n", string);	return string;}/* test passing and returning 64bit structures */EXPORT(ffiTestPoint2) ffiTestStruct64(ffiTestPoint2 pt1, ffiTestPoint2 pt2) {	ffiTestPoint2 result;	printf("pt1.x = %d\npt1.y = %d\npt2.x = %d\npt2.y = %d\n",			pt1.x, pt1.y, pt2.x, pt2.y);	result.x = pt1.x + pt2.x;	result.y = pt1.y + pt2.y;	return result;}/* test passing and returning large structures */EXPORT(ffiTestPoint4) ffiTestStructBig(ffiTestPoint4 pt1, ffiTestPoint4 pt2) {	ffiTestPoint4 result;	printf("pt1.x = %d\npt1.y = %d\npt1.z = %d\npt1.w = %d\n",			pt1.x, pt1.y, pt1.z, pt1.w);	printf("pt2.x = %d\npt2.y = %d\npt2.z = %d\npt2.w = %d\n",			pt2.x, pt2.y, pt2.z, pt2.w);	result.x = pt1.x + pt2.x;	result.y = pt1.y + pt2.y;	result.z = pt1.z + pt2.z;	result.w = pt1.w + pt2.w;	return result;}/* test passing and returning pointers */EXPORT(ffiTestPoint4*) ffiTestPointers(ffiTestPoint4 *pt1, ffiTestPoint4 *pt2) {	ffiTestPoint4 *result;	printf("pt1.x = %d\npt1.y = %d\npt1.z = %d\npt1.w = %d\n",			pt1->x, pt1->y, pt1->z, pt1->w);	printf("pt2.x = %d\npt2.y = %d\npt2.z = %d\npt2.w = %d\n",			pt2->x, pt2->y, pt2->z, pt2->w);	result = (ffiTestPoint4*) malloc(sizeof(ffiTestPoint4));	result->x = pt1->x + pt2->x;	result->y = pt1->y + pt2->y;	result->z = pt1->z + pt2->z;	result->w = pt1->w + pt2->w;	return result;}/* test passing and returning longlongs */EXPORT(LONGLONG) ffiTestLongLong(LONGLONG i1, LONGLONG i2) {	return i1 + i2;}#endif /* NO_FFI_TEST */'! !!FFIPlugin class methodsFor: 'C support code' stamp: 'ar 1/26/2000 15:12'!writeSupportFiles	"FFIPlugin writeSupportFiles"	InterpreterSupportCode		storeString: self sqFFIHeaderFile onFileNamed:'sqFFI.h';		storeString: self sqMacFFIPPCFile onFileNamed:'sqMacFFIPPC.c';		storeString: self sqUnixFFIFile onFileNamed:'sqUnixFFI.c';		storeString: self sqWin32FFIFile onFileNamed:'sqWin32FFI.c'.! !ExternalStructure subclass: #FFITestPoint2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Plugin'!!FFITestPoint2 methodsFor: 'accessing' stamp: 'ar 12/1/1999 16:42'!x	"This method was automatically generated"	^handle signedLongAt: 1! !!FFITestPoint2 methodsFor: 'accessing' stamp: 'ar 12/1/1999 16:42'!x: anObject	"This method was automatically generated"	handle signedLongAt: 1 put: anObject! !!FFITestPoint2 methodsFor: 'accessing' stamp: 'ar 12/1/1999 16:42'!y	"This method was automatically generated"	^handle signedLongAt: 5! !!FFITestPoint2 methodsFor: 'accessing' stamp: 'ar 12/1/1999 16:42'!y: anObject	"This method was automatically generated"	handle signedLongAt: 5 put: anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FFITestPoint2 class	instanceVariableNames: ''!!FFITestPoint2 class methodsFor: 'field definition' stamp: 'ar 12/1/1999 16:42'!fields	"FFITestPoint2 defineFields"	^#(		(x	'long')		(y	'long')	)! !ExternalStructure subclass: #FFITestPoint4	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Plugin'!!FFITestPoint4 methodsFor: 'accessing' stamp: 'ar 12/1/1999 16:41'!w	"This method was automatically generated"	^handle signedLongAt: 13! !!FFITestPoint4 methodsFor: 'accessing' stamp: 'ar 12/1/1999 16:41'!w: anObject	"This method was automatically generated"	handle signedLongAt: 13 put: anObject! !!FFITestPoint4 methodsFor: 'accessing' stamp: 'ar 12/1/1999 16:41'!x	"This method was automatically generated"	^handle signedLongAt: 1! !!FFITestPoint4 methodsFor: 'accessing' stamp: 'ar 12/1/1999 16:41'!x: anObject	"This method was automatically generated"	handle signedLongAt: 1 put: anObject! !!FFITestPoint4 methodsFor: 'accessing' stamp: 'ar 12/1/1999 16:41'!y	"This method was automatically generated"	^handle signedLongAt: 5! !!FFITestPoint4 methodsFor: 'accessing' stamp: 'ar 12/1/1999 16:41'!y: anObject	"This method was automatically generated"	handle signedLongAt: 5 put: anObject! !!FFITestPoint4 methodsFor: 'accessing' stamp: 'ar 12/1/1999 16:41'!z	"This method was automatically generated"	^handle signedLongAt: 9! !!FFITestPoint4 methodsFor: 'accessing' stamp: 'ar 12/1/1999 16:41'!z: anObject	"This method was automatically generated"	handle signedLongAt: 9 put: anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FFITestPoint4 class	instanceVariableNames: ''!!FFITestPoint4 class methodsFor: 'field definition' stamp: 'ar 12/1/1999 16:41'!fields	"FFITestPoint4 defineFields"	^#(		(x	'long')		(y	'long')		(z	'long')		(w	'long')	)! !ExternalLibrary subclass: #FFITester	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Plugin'!!FFITester methodsFor: 'primitives' stamp: 'ar 11/19/1999 20:37'!ffiPrintString: aString	"FFITester ffiPrintString: 'Hello'"	<cdecl: char* 'ffiPrintString' (char *)>	^self externalCallFailed! !!FFITester methodsFor: 'primitives' stamp: 'ar 11/20/1999 23:41'!ffiTestChar: c1 with: c2 with: c3 with: c4	"FFITester ffiTestChar: $A with: 65 with: 65.0 with: true"	<cdecl: char 'ffiTestChars' (char char char char)>	^self externalCallFailed! !!FFITester methodsFor: 'primitives' stamp: 'ar 11/19/1999 21:30'!ffiTestDoubles: f1 with: f2	"FFITester ffiTestDoubles: $A with: 65.0"	<cdecl: double 'ffiTestDoubles' (double double)>	^self externalCallFailed! !!FFITester methodsFor: 'primitives' stamp: 'ar 11/19/1999 20:31'!ffiTestFloats: f1 with: f2	"FFITester ffiTestFloats: $A with: 65.0"	<cdecl: float 'ffiTestFloats' (float float)>	^self externalCallFailed! !!FFITester methodsFor: 'primitives' stamp: 'ar 11/19/1999 20:31'!ffiTestInt: c1 with: c2 with: c3 with: c4	"FFITester ffiTestInt: $A with: 65 with: 65.0 with: $A"	<cdecl: long 'ffiTestInts' (long long long long)>	^self externalCallFailed! !!FFITester methodsFor: 'primitives' stamp: 'ar 11/19/1999 20:31'!ffiTestShort: c1 with: c2 with: c3 with: c4	"FFITester ffiTestShort: $A with: 65 with: 65.0 with: $A"	<cdecl: short 'ffiTestShorts' (short short short short)>	^self externalCallFailed! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FFITester class	instanceVariableNames: ''!!FFITester class methodsFor: 'public' stamp: 'ar 11/28/1999 20:13'!testAll	"FFITester testAll"	"Run all the tests"	"Pass 1: Run all the methods in the class and see if it works"	"Pass 2: Run all the methods in an instance (ExternalLibrary) and see if it works"	"Pass 3: Run all the methods directly invoked from an ExternalMethod"	| rcvr value meth module |	1 to: 2 do:[:i|		i = 1 ifTrue:[rcvr _ self] ifFalse:[rcvr _ self new].		"Test argument coercion and passing of arguments of different sizes"		rcvr ffiTestChar: $A with: 65 with: 65.0 with: true.		rcvr ffiTestShort: $A with: 65 with: 65.0 with: true.		rcvr ffiTestInt: $A with: 65 with: 65.0 with: true.		value _ rcvr ffiTestFloats: $A with: 65.0.		value rounded = 130 ifFalse:[self error:'single floats don''t work'].		value _ rcvr ffiTestDoubles: 41 with: true.		value = 42.0 ifFalse:[self error:'problem with doubles'].		value _ rcvr ffiPrintString:'Hello World!!'.		value = 'Hello World!!' ifFalse:[self error:'Problem with strings'].	].	module _ self moduleName.	meth _ ExternalLibraryFunction		name:'ffiTestChars' module: module callType: 0 returnType: ExternalType char		argumentTypes: ((1 to: 4) collect:[:i| ExternalType char]).	meth invokeWith: $A with: 65 with: 65.0 with: true.	meth _ ExternalLibraryFunction		name:'ffiTestShorts' module: module callType: 0 returnType: ExternalType short		argumentTypes: ((1 to: 4) collect:[:i| ExternalType short]).	meth invokeWithArguments: (Array with: $A with: 65 with: 65.0 with: true).	meth _ ExternalLibraryFunction		name:'ffiTestInts' module: module callType: 0 returnType: ExternalType long		argumentTypes: ((1 to: 4) collect:[:i| ExternalType long]).	meth invokeWith: $A with: 65 with: 65.0 with: true.	meth _ ExternalLibraryFunction		name:'ffiTestFloats' module: module callType: 0 returnType: ExternalType float		argumentTypes: ((1 to: 2) collect:[:i| ExternalType float]).	value _ meth invokeWith: $A with: 65.0.	value rounded = 130 ifFalse:[self error:'single floats don''t work'].	meth _ ExternalLibraryFunction		name:'ffiTestDoubles' module: module callType: 0 returnType: ExternalType double		argumentTypes: ((1 to: 2) collect:[:i| ExternalType double]).	value _ meth invokeWithArguments: (Array with: 41 with: true).	value = 42.0 ifFalse:[self error:'problem with doubles'].	meth _ ExternalLibraryFunction		name:'ffiPrintString' module: module callType: 0 returnType: ExternalType string		argumentTypes: ((1 to: 1) collect:[:i| ExternalType string]).	value _ meth invokeWith:'Hello World!!'.	value = 'Hello World!!' ifFalse:[self error:'Problem with strings'].! !!FFITester class methodsFor: 'public' stamp: 'ar 11/22/1999 05:02'!testLongLongs	"FFITester testLongLongs"	"Test passing and returning longlongs"	| long1 long2 long3 |	long1 _ 16r123456789012.	long2 _ (-1 << 31).	long3 _ self ffiTestLongLong: long1 with: long2.	long3 = (long1 + long2) ifFalse:[self error:'Problem passing/returning longlongs'].	^long3! !!FFITester class methodsFor: 'public' stamp: 'ar 11/22/1999 05:03'!testPoint2 "FFITester testPoint2"	"Test passing and returning up of structures >32bit and <= 64 bit"	| pt1 pt2 pt3 |	pt1 _ FFITestPoint2 new.	pt1 x: 1. pt1 y: 2.	pt2 _ FFITestPoint2 new.	pt2 x: 3. pt2 y: 4.	pt3 _ self ffiTestPoint2: pt1 with: pt2.	(pt3 x = 4 and:[ pt3 y = 6]) 		ifFalse:[self error:'Problem passing 64bit structures'].	^pt3! !!FFITester class methodsFor: 'public' stamp: 'ar 11/22/1999 05:03'!testPoint4 "FFITester testPoint4"	"Test passing and returning up of structures > 64 bit"	| pt1 pt2 pt3 |	pt1 _ FFITestPoint4 new.	pt1 x: 1. pt1 y: 2. pt1 z: 3. pt1 w: 4.	pt2 _ FFITestPoint4 new.	pt2 x: 5. pt2 y: 6. pt2 z: 7. pt2 w: 8.	pt3 _ self ffiTestPoint4: pt1 with: pt2.	(pt3 x = 6 and:[ pt3 y = 8 and:[pt3 z = 10 and:[pt3 w = 12]]]) 		ifFalse:[self error:'Problem passing large structures'].	^pt3! !!FFITester class methodsFor: 'public' stamp: 'ar 12/1/1999 16:39'!testPointers "FFITester testPointers"	"Test passing and returning of pointers to structs"	| pt1 pt2 pt3 |	pt1 _ FFITestPoint4 new.	pt1 x: 1. pt1 y: 2. pt1 z: 3. pt1 w: 4.	pt2 _ FFITestPoint4 new.	pt2 x: 5. pt2 y: 6. pt2 z: 7. pt2 w: 8.	pt3 _ self ffiTestPointers: pt1 with: pt2.	(pt3 x = 6 and:[ pt3 y = 8 and:[pt3 z = 10 and:[pt3 w = 12]]]) 		ifFalse:[self error:'Problem passing large structures'].	^pt3! !!FFITester class methodsFor: 'primitives' stamp: 'ar 1/27/2000 01:21'!ffiPrintString: aString	"FFITester ffiPrintString: 'Hello'"	<cdecl: char* 'ffiPrintString' (char *) module:'SqueakFFIPrims'>	^self externalCallFailed! !!FFITester class methodsFor: 'primitives' stamp: 'ar 11/28/1999 19:51'!ffiTestChar: c1 with: c2 with: c3 with: c4	"FFITester ffiTestChar: $A with: 65 with: 65.0 with: true"	<cdecl: char 'ffiTestChars' (char char char char) module:'SqueakFFIPrims'>	^self externalCallFailed! !!FFITester class methodsFor: 'primitives' stamp: 'ar 11/28/1999 19:51'!ffiTestDoubles: f1 with: f2	"FFITester ffiTestDoubles: $A with: 65.0"	<cdecl: double 'ffiTestDoubles' (double double) module:'SqueakFFIPrims'>	^self externalCallFailed! !!FFITester class methodsFor: 'primitives' stamp: 'ar 11/28/1999 19:51'!ffiTestFloats: f1 with: f2	"FFITester ffiTestFloats: $A with: 65.0"	<cdecl: float 'ffiTestFloats' (float float) module:'SqueakFFIPrims'>	^self externalCallFailed! !!FFITester class methodsFor: 'primitives' stamp: 'ar 11/29/1999 14:49'!ffiTestInt: c1 with: c2 with: c3 with: c4	"FFITester ffiTestInt: $A with: 65 with: 65.0 with: true"	<cdecl: long 'ffiTestInts' (long long long long) module:'SqueakFFIPrims'>	^self externalCallFailed! !!FFITester class methodsFor: 'primitives' stamp: 'ar 11/28/1999 19:51'!ffiTestLongLong: long1 with: long2	<cdecl: longlong 'ffiTestLongLong' (longlong longlong) module:'SqueakFFIPrims'>	^self externalCallFailed! !!FFITester class methodsFor: 'primitives' stamp: 'ar 11/28/1999 19:51'!ffiTestPoint2: pt1 with: pt2	<cdecl: FFITestPoint2 'ffiTestStruct64' (FFITestPoint2 FFITestPoint2) module:'SqueakFFIPrims'>	^self externalCallFailed! !!FFITester class methodsFor: 'primitives' stamp: 'ar 11/28/1999 19:51'!ffiTestPoint4: pt1 with: pt2	<cdecl: FFITestPoint4 'ffiTestStructBig' (FFITestPoint4 FFITestPoint4) module:'SqueakFFIPrims'>	^self externalCallFailed! !!FFITester class methodsFor: 'primitives' stamp: 'ar 12/1/1999 16:39'!ffiTestPointers: pt1 with: pt2	<cdecl: FFITestPoint4* 'ffiTestPointers' (FFITestPoint4* FFITestPoint4*) module:'SqueakFFIPrims'>	^self externalCallFailed! !!FFITester class methodsFor: 'primitives' stamp: 'ar 11/29/1999 14:16'!ffiTestShort: c1 with: c2 with: c3 with: c4	"FFITester ffiTestShort: $A with: 65 with: 65.0 with:1"	<cdecl: short 'ffiTestShorts' (short short short short) module:'SqueakFFIPrims'>	^self externalCallFailed! !!FFITester class methodsFor: 'accessing' stamp: 'ar 11/28/1999 19:51'!moduleName	"Use the fully qualified VM name so we ensure testing loading a library"	^'SqueakFFIPrims'! !FFITestPoint2 compileFields!FFITestPoint4 compileFields!