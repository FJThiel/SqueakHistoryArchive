'From Squeak 2.3 of January 14, 1999 on 26 January 1999 at 10:15:24 am'!!Morph methodsFor: 'debug and other' stamp: 'tk 1/26/1999 09:22'!allStringsAfter: aSubmorph	"return an OrderedCollection of strings of text in my submorphs.  If aSubmorph is non-nil, begin with that container."	| list string ok |	list _ OrderedCollection new.	ok _ aSubmorph == nil.	self allMorphsDo: [:sub | 		ok ifFalse: [ok _ sub == aSubmorph].		"and do this one too"		ok ifTrue: [			(string _ sub userString) ifNotNil: [				(string isKindOf: String) 					ifTrue: [list add: string]					ifFalse: [list addAll: string]]]].	^ list! !!BookMorph methodsFor: 'navigation' stamp: 'tk 1/23/1999 09:33'!goToPageMorph: newPage transitionSpec: transitionSpec	| pageIndex  aWorld oldPageIndex ascending tSpec |	pages isEmpty ifTrue: [^ self].	self setProperty: #searchContainer toValue: nil.	"forget previous search"	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	pageIndex _ pages identityIndexOf: newPage ifAbsent: [^ self "abort"].	oldPageIndex _ pages identityIndexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageIndex == nil) or: [newPage == currentPage])			ifTrue: [nil]			ifFalse: [oldPageIndex < pageIndex].	tSpec _ transitionSpec ifNil:  "If transition not specified by requestor..."		[newPage valueOfProperty: #transitionSpec  " ... then consult new page"			ifAbsent: [self transitionSpecFor: self  " ... otherwise this is the default"]].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	currentPage ifNotNil: [currentPage updateCachedThumbnail].	self currentPage ~~ nil		ifTrue:		[(((pages at: pageIndex) owner isKindOf: TransitionMorph)			and: [(pages at: pageIndex) isInWorld])			ifTrue: [^ self  "In the process of a prior pageTurn"].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		ascending ifNotNil:			["Show appropriate page transition and start new page when done"			currentPage stopStepping.			(pages at: pageIndex) position: currentPage position.			^ (TransitionMorph					effect: tSpec second					direction: tSpec third					inverse: (ascending or: [transitionSpec notNil]) not)				showTransitionFrom: currentPage				to: (pages at: pageIndex)				in: self				whenStart: [self playPageFlipSound: tSpec first]				whenDone:					[currentPage delete; fullReleaseCachedState.					self addMorphBack: (currentPage _ pages at: pageIndex).					self snapToEdgeIfAppropriate.					aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].					self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].					(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld]]].		"No transition, but at least decommission current page"		currentPage delete; fullReleaseCachedState].	self addMorphBack: (currentPage _ pages at: pageIndex).	self snapToEdgeIfAppropriate.	aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].	self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld].! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/26/1999 10:10'!findText: wants	"Turn to the next page that has all of the strings mentioned on it.  Highlight where it is found.  allText and allTextUrls have been set.  Case insensitive search.	Resuming a search.  If container's text is still in the list and secondary keys are still in the page, (1) search rest of that container.  (2) search rest of containers on that page (3) pages till end of book, (4) from page 1 to this page again."	"Later sort wants so longest key is first"	| allText good thisWord here fromHereOn startToHere oldContainer oldIndex otherKeys strings |	allText _ self valueOfProperty: #allText ifAbsent: [#()].	here _ pages identityIndexOf: currentPage ifAbsent: [1].	fromHereOn _ here+1 to: pages size.	startToHere _ 1 to: here.		"repeat this page"	(self valueOfProperty: #searchKey ifAbsent: [#()]) = wants ifTrue: [		"does page have all the other keys?  No highlight if found!!"		otherKeys _ wants allButFirst.		strings _ allText at: here.		good _ true.		otherKeys do: [:searchString | "each key"			good ifTrue: [thisWord _ false.				strings do: [:longString |					(longString findString: searchString startingAt: 1 						caseSensitive: false) > 0 ifTrue: [							thisWord _ true]].				good _ thisWord]].		good ifTrue: ["all are on this page.  Look in rest for string again."			oldContainer _ self valueOfProperty: #searchContainer.			oldIndex _ self valueOfProperty: #searchOffset.			(self findText: (OrderedCollection with: wants first) inStrings: strings					startAt: oldIndex+1 container: oldContainer 				pageNum: here) ifTrue: [					self setProperty: #searchKey toValue: wants.					^ true]]]		ifFalse: [fromHereOn _ here to: pages size].	"do search this page"	"other pages"	fromHereOn do: [:pageNum |		(self findText: wants inStrings: (allText at: pageNum) startAt: 1 container: nil 				pageNum: pageNum) 					ifTrue: [^ true]].	startToHere do: [:pageNum |		(self findText: wants inStrings: (allText at: pageNum) startAt: 1 container: nil 				pageNum: pageNum) 					ifTrue: [^ true]].	"if fail"	self setProperty: #searchContainer toValue: nil.	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	^ false! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/26/1999 10:06'!findText: keys inStrings: rawStrings	startAt: startIndex container: oldContainer pageNum: pageNum	"Call once to search a page of the book.  Return true if found and highlight the text.  oldContainer should be NIL.  	(oldContainer is only non-nil when (1) doing a 'search again' and (2) the page is in memory and (3) keys has just one element.  oldContainer is a TextMorph.)"	| good thisWord index insideOf place container start wasIn strings |	good _ true.	start _ startIndex.	strings _ oldContainer ifNil: [rawStrings]	"normal case"		ifNotNil: [(pages at: pageNum) isInMemory 					ifFalse: [rawStrings]					ifTrue: [(pages at: pageNum) allStringsAfter: oldContainer]].	keys do: [:searchString | "each key"		good ifTrue: [thisWord _ false.			strings do: [:longString |				(index _ longString findString: searchString startingAt: start 					caseSensitive: false) > 0 ifTrue: [						thisWord not & (searchString == (keys at: 1)) ifTrue: [							insideOf _ longString. place _ index].						thisWord _ true].				start _ 1].	"only first key on first container"			good _ thisWord]].	good ifTrue: ["all are on this page"		wasIn _ (pages at: pageNum) isInMemory.		self goToPage: pageNum.		wasIn ifFalse: ["search again, on the real current text.  Know page is in."			^ self findText: keys 				inStrings: ((pages at: pageNum) allStringsAfter: nil) "recompute"					startAt: startIndex container: oldContainer 				pageNum: pageNum]].	good ifTrue: ["have the exact string object"		(container _ oldContainer)			ifNil: [container _ self highlightText: (keys at: 1) at: place in: insideOf]			ifNotNil: [				container userString == insideOf 					ifFalse: [						container _ self highlightText: (keys at: 1) at: place 							in: insideOf]					ifTrue: [(container isKindOf: TextMorph) ifTrue: [						container editor selectFrom: index to: 								(keys at: 1) size - 1 + index.						container changed].						]].		self setProperty: #searchContainer toValue: container.		self setProperty: #searchOffset toValue: place.		self setProperty: #searchKey toValue: keys.		"override later"		^ true].	^ false! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/26/1999 09:26'!getAllText	"Collect the text for each page.  Just point at strings so don't have to recopy them.  Parallel array of urls for ID of pages.	allText = Array (pages size) of arrays (fields in it) of strings of text.	allTextUrls = Array (pages size) of urls or page numbers.	For any page that is out, text data came from .bo file on server.  	Is rewritten when one or all pages are stored."	| oldUrls oldStringLists allText allTextUrls aUrl which |	oldUrls _ self valueOfProperty: #allTextUrls ifAbsent: [#()].	oldStringLists _ self valueOfProperty: #allText ifAbsent: [#()].	allText _ pages collect: [:pg | OrderedCollection new].	allTextUrls _ Array new: pages size.	pages doWithIndex: [:aPage :ind | aUrl _ aPage url.  aPage isInMemory 		ifTrue: [(allText at: ind) addAll: (aPage allStringsAfter: nil).			aUrl ifNil: [aUrl _ ind].			allTextUrls at: ind put: aUrl]		ifFalse: ["Order of pages on server may be different.  (later keep up to date?)"			which _ oldUrls indexOf: aUrl.			allTextUrls at: ind put: aUrl.			which = 0 ifFalse: [allText at: ind put: (oldStringLists at: which)]]].	self setProperty: #allText toValue: allText.	self setProperty: #allTextUrls toValue: allTextUrls.	^ allText! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/19/1999 07:11'!highlightText: stringToHilite at: index in: insideOf	"Find the container with this text and highlight it.  May not be able to do it for stringMorphs."	"Find the container with that text"	| container |	self allMorphsDo: [:sub | 		insideOf == sub userString ifTrue: [container _ sub]].	container ifNil: [		self allMorphsDo: [:sub | 			insideOf = sub userString ifTrue: [container _ sub]]].	"any match"	container ifNil: [^ nil].	"Order it highlighted"	(container isKindOf: TextMorph) ifTrue: [		container editor selectFrom: index to: stringToHilite size - 1 + index].	container changed.	^ container! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/26/1999 09:26'!saveIndexOfOnly: aPage	"Modify the index of this book on a server.  Read the index, modify the entry for just this page, and write back.  See saveIndexOnURL."	| holder mine sf remoteFile strm remote pageURL num pre index after sp dict allText allTextUrls |	mine _ self valueOfProperty: #url.	mine ifNil: [^ self saveIndexOnURL].	Cursor wait showWhile: [strm _ (ServerFile new fullPath: mine) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	remote _ strm fileInObjectAndCode.	dict _ remote at: 1.	allText _ dict at: #allText ifAbsent: [nil].	"remote, not local"	allTextUrls _ dict at: #allTextUrls ifAbsent: [nil].	allText size + 1 ~= remote size ifTrue: [self error: '.bo size mismatch.  Please tell Ted what you just did to this book.'].	(pageURL _ aPage url) ifNil: [self error: 'just had one!!'].	2 to: remote size do: [:ii | 		((remote at: ii) url findString: pageURL startingAt: 1 						caseSensitive: false) > 0 ifTrue: [index _ ii].	"fast"		(remote at: ii) xxxReset].	index ifNil: ["new page, what existing page does it follow?"		num _ self pageNumberOf: aPage.		1 to: num-1 do: [:ii | (pages at: ii) url ifNotNil: [pre _ (pages at: ii) url]].		pre ifNil: [after _ remote size+1]			ifNotNil: ["look for it on disk, put me after"				2 to: remote size do: [:ii | 					((remote at: ii) url findString: pre startingAt: 1 								caseSensitive: false) > 0 ifTrue: [after _ ii+1]]].		remote _ remote copyReplaceFrom: after to: after-1 with: #(1).		allText ifNotNil: [			dict at: #allText put: (allText copyReplaceFrom: after-1 to: after-2 with: #(())).			dict at: #allTextUrls put: (allTextUrls copyReplaceFrom: after-1 to: after-2 with: #(()))].		index _ after].	sp _ aPage sqkPage copy.	"is there"	holder _ MorphObjectOut new xxxSetUrl: sp url page: sp.	sp contentsMorph: holder.	remote at: index put: holder.	(dict at: #modTime ifAbsent: [0]) < Time totalSeconds ifTrue:		[dict at: #modTime put: Time totalSeconds].	allText ifNotNil: [		(dict at: #allText) at: index-1 put: (aPage allStringsAfter: nil).		(dict at: #allTextUrls) at: index-1 put: pageURL].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: remote.		"remoteFile close"].! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/18/1999 09:57'!textSearch	"search the text on all pages of this book"	| wanted wants list str |	list _ self valueOfProperty: #searchKey ifAbsent: [#()].	str _ String streamContents: [:strm | 			list do: [:each | strm nextPutAll: each]].	wanted _ FillInTheBlank request: 'words to search for.  Order is not important.Beginnings of words are OK.'		initialAnswer: str.	wants _ wanted findTokens: Character separators.	wants size = 0 ifTrue: [^ self].	self getAllText.		"save in allText, allTextUrls"	^ self findText: wants	"goes to the page and highlights the text"! !Morph removeSelector: #allStrings!