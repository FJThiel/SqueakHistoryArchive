'From Squeak2.6 of 11 October 1999 [latest update: #1660] on 27 November 1999 at 9:49:49 pm'!"Change Set:		veryDeepCopy-hgDate:			24 November 1999Author:			Henrik Gedenryd with tweaks by Ted KaehlerWhen copying many small structures, the variable check's 'once-in-a-while'becomes way too often, so I changed this to use time intervals instead, since the need is related to the programmer changing the code.	Ted set the time interval to 10 minutes. The idea is to flag it while the programmer is still looking at it.Also, I've given each class a chance to set the initial size of the array, so that when an object of class X is called, if you know that as a rule of thumb it contains just a small object hierarchy or uses many shallow copies, you can set a smaller size. (It will always grow if needed.) This one alone gave a 400% speedup for a very small structure.Beside the speedups, I have also added copying of dependents to veryDeepCopy. (Only applies to MVC.  Morphic has its own dependents inst var.) This slows down the copying a bit, esp. checking for 'backward' dependencies, so that objects that have the source as a dependent also gets the copy as one (unless the source is copied too; then that copy gets it). The whole DependentsFields structure is scanned once per group of objects copied. 	Also fixed veryDeepCopy of a live Browser.	Also fixed Float.closeTo: for NaN and Infinity."!Object subclass: #DeepCopier	instanceVariableNames: 'references uniClasses '	classVariableNames: 'NextVariableCheckTime '	poolDictionaries: ''	category: 'System-Object Storage'!!Object methodsFor: 'copying' stamp: 'hg 11/23/1999 13:43'!initialDeepCopierSize	"default value is 4096; other classes may override this, esp. for smaller (=faster) sizes"	^4096! !!Object methodsFor: 'copying' stamp: 'tk 11/25/1999 14:22'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy."	| copier new refs newDep newModel |	copier _ DeepCopier new initialize: self initialDeepCopierSize.	new _ self veryDeepCopyWith: copier.	copier mapUniClasses.	copier references associationsDo: [:assoc | 		assoc value veryDeepFixupWith: copier].	"Fix dependents"	refs _ copier references.	DependentsFields associationsDo: [:pair |		pair value do: [:dep | 			(newDep _ refs at: dep ifAbsent: [nil]) ifNotNil: [				(newModel _ refs at: pair key ifAbsent: [nil]) 					ifNil: [pair key addDependent: newDep]					ifNotNil: [newModel addDependent: newDep]]]].	^ new! !!Browser methodsFor: 'class list' stamp: 'tk 11/27/1999 18:07'!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className |	classListIndex _ anInteger.	self setClassOrganizer.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self classCommentIndicated		ifTrue: []		ifFalse: [editSelection _ anInteger = 0					ifTrue: [metaClassIndicated | (systemCategoryListIndex == 0)						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass]].	contents _ nil.	self selectedClass isNil		ifFalse: [className _ self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #contents.! !!DeepCopier commentStamp: 'tk 11/25/1999 14:31' prior: 0!I do veryDeepCopy.  I hold the dictionary of objects seen, and the correspondance (uniClass -> new uniClass).  See Object|veryDeepCopy which calls (self veryDeepCopyWith: aDeepCopier).When a tree of Morphs points at a morph outside of it, that morph should not be copied.  Use our own kind of weak pointers for the potentially outside morphs.   Default is that any new class will have all of its newly defined fields deeply copied.  If a field needs to be weakly copied, define veryDeepInner: and veryDeepFixupWith:.(Object veryDeepCopyWith: notes which superclasses did not do veryDeepInner:, and very deep copies those vars).Key to seeing if you have to add the methods veryDeepFixupWith:   and   veryDeepInner:Does field X contain a morph?  If not, no action needed.Is the morph in field X a submorph of the object?  Is it down lower in the submorph tree?	If so, no action needed.Could the morph in field X every appear on the screen (be a submorph of some other morph)?	If not, no action needed.	If so, you must write the methods veryDeepFixupWith:   and   veryDeepInner:, and in them, refrain from sending veryDeepCopyWith: to the contents of field X.Rule:  If a morph stores a uniClass class (Player 57) as an object in a field, the new uniClass will not be stored there.   All uniClass instances do have a new class created for them.  (fix this by putting the old class in references and allow lookup?  Wrong if encounter it before seeing an instance?)Rule: If object A has object C in a field, and A says (^ C) for the copy, but object B has A in a normal field and it gets deepCopied, and A in encountered first, then there will be two copies of C.  (just be aware of it)Dependents are now fixed up.  Suppose a model has a dependent view.  In the DependentFields dictionary, model -> (view ...).  	If only the model is copied, no dependents are created (no one knows about the new model).  	If only the view is copied, it is inserted into DependentFields on the right side.  model -> (view  copiedView ...).  	If both are copied, the new model has the new view as its dependent.	If additional things depend on a model that is copied, the caller must add them to its dependents.!!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 11/24/1999 17:52'!checkVariables	"Check that no indexes of instance vars have changed in certain classes.  If you get an error in this method, an implementation of veryDeepCopyWith: needs to be updated.  The idea is to catch a change while it is still in the system of the programmer who made it.  	DeepCopier new checkVariables	"	| str str2 meth |	str _ '|veryDeepCopyWith: or veryDeepInner: is out of date.'.	Object instSize = 0 ifFalse: [self error: 'Many implementers of veryDeepCopyWith: are out of date'].	Morph superclass == Object ifFalse: [self error: 'Morph', str].	(Morph instVarNames copyFrom: 1 to: 6) = #('bounds' 'owner' 'submorphs' 			'fullBounds' 'color' 'extension') 		ifFalse: [self error: 'Morph', str].	"added ones are OK"	"Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  So check that the last one is mentioned in the copy method."	(Smalltalk allClassesImplementing: #veryDeepInner:) do: [:aClass | 		((aClass compiledMethodAt: #veryDeepInner:) writesField: aClass instSize) ifFalse: [			aClass instSize > 0 ifTrue: [				self warnIverNotCopiedIn: aClass sel: #veryDeepInner:]]].	(Smalltalk allClassesImplementing: #veryDeepCopyWith:) do: [:aClass | 		meth _ aClass compiledMethodAt: #veryDeepCopyWith:.		(meth size > 20) & (meth literals includes: #veryDeepCopyWith:) not ifTrue: [			(meth writesField: aClass instSize) ifFalse: [				self warnIverNotCopiedIn: aClass sel: #veryDeepCopyWith:]]].	str2 _ 'Player|copyUniClass and DeepCopier|mapUniClasses are out of date'.	Behavior instVarNames = #('superclass' 'methodDict' 'format' )		ifFalse: [self error: str2].	ClassDescription instVarNames = #('instanceVariables' 'organization' )		ifFalse: [self error: str2].	Class instVarNames = #('subclasses' 'name' 'classPool' 'sharedPools' )		ifFalse: [self error: str2].	Model superclass == Object ifFalse: [self error: str2].	Player superclass == Model ifFalse: [self error: str2].	Model class instVarNames = #() ifFalse: [self error: str2].	Player class instVarNames = #('scripts' 'slotInfo')		ifFalse: [self error: str2].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'hg 11/23/1999 13:36'!initialize	self initialize: 4096.! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'hg 11/23/1999 13:35'!initialize: size	references _ IdentityDictionary new: size.	uniClasses _ IdentityDictionary new.	"UniClass -> new UniClass"	self isItTimeToCheckVariables ifTrue: [self checkVariables].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 11/24/1999 17:53'!intervalForChecks	"set delay interval for checking for new instance variables to 10 minutes. hg 11/23/1999"	^600! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 11/25/1999 14:37'!isItTimeToCheckVariables	| now isIt |	NextVariableCheckTime ifNil: [		NextVariableCheckTime _ Time totalSeconds.		^ true].	now _ Time totalSeconds.	isIt _ NextVariableCheckTime < now.	isIt ifTrue: ["update time for next check"		NextVariableCheckTime _ now + self intervalForChecks].	^isIt! !!Float methodsFor: 'comparing' stamp: 'tk 11/27/1999 21:47'!closeTo: num	"are these two numbers close?"	| fuzz ans |	num isNumber ifFalse: [		[ans _ self = num] ifError: [:aString :aReceiver | ^ false].		^ ans].	self = 0.0 ifTrue: [^ num abs < 0.0001].	num = 0.0 ifTrue: [^ self abs < 0.0001].	self isNaN == num isNaN ifFalse: [^ false].	self isInfinite == num isInfinite ifFalse: [^ false].	fuzz := (self abs max: num abs) * 0.0001.	^ (self - num) abs <= fuzz! !Object removeSelector: #coldCopyHandleDependents:!Object removeSelector: #cloneDependents:!Browser removeSelector: #veryDeepFixupWith:!