'From Squeak 2.3 of January 14, 1999 on 30 April 1999 at 4:51:04 pm'!"Change Set:		selFinder-tkJRDate:			30 April 1999Author:			Ted Kaehler	Puts a bottom pane on the Selector Finder window.  In this pane, you can use examples to find a method in the system.  You supply inputs and answers and the system will find the method.  Each inner array is a list of inputs.  It contains the receiver and zero or more arguments.  Open a Selector Finder and try it!!	Fixed: In Syntax Error window during a fileIn, you can now choose the menu item 'open a debugger on the stack'.  In the menu of the upper pane.	Fixes many minor bugs in various classes."!Object subclass: #MethodFinder	instanceVariableNames: 'data answers selector argMap thisData mapStage mapList '	classVariableNames: 'AddAndRemove Approved Blocks Dangerous '	poolDictionaries: ''	category: 'Kernel-Methods'!!Object methodsFor: 'accessing' stamp: 'tk 4/17/1999 10:09'!in: aBlock	"Evaluate the given block with the receiver as its argument."	(aBlock isKindOf: BlockContext) ifFalse: [self error: 'expecting a block'].	^ aBlock value: self! !!Object methodsFor: 'comparing' stamp: 'tk 4/16/1999 18:26'!closeTo: anObject	"Answer whether the receiver and the argument represent the same	object. If = is redefined in any subclass, consider also redefining the	message hash."	| ans |	[ans _ self = anObject] ifError: [:aString :aReceiver | ^ false].	^ ans! !!Object methodsFor: 'copying' stamp: 'tk 4/20/1999 14:44'!copyTwoLevel	"one more level than a shallowCopy"	| newObject class index |	class _ self class.	newObject _ self clone.	newObject == self ifTrue: [^ self].	class isVariable		ifTrue: 			[index _ self basicSize.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index) shallowCopy.					index _ index - 1]].	index _ class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index) shallowCopy.			index _ index - 1].	^newObject! !!Behavior methodsFor: 'copying' stamp: 'tk 4/16/1999 17:30'!deepCopy	"Classes should only be shallowCopied or made anew."^ self shallowCopy! !!Behavior methodsFor: 'instance creation' stamp: 'tk 4/16/1999 20:24'!basicNew: anInteger 	"Primitive. Answer an instance of the receiver (which is a class) with the 	number of indexable variables specified by the argument, anInteger. Fail 	if the class is not indexable or if the argument is not a positive Integer. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>	self isVariable ifFalse: [		self error: self printString, ' cannot have variable sized instances'].	(anInteger isInteger and: [anInteger >= 0]) ifTrue: [		"arg okay; space must be low"		Smalltalk signalLowSpace.		^ self basicNew: anInteger  "retry if user proceeds"	].	self primitiveFailed! !!Behavior methodsFor: 'instance creation' stamp: 'tk 3/24/1999 08:29'!new: anInteger 	"Primitive. Answer an instance of the receiver (which is a class) with the 	number of indexable variables specified by the argument, anInteger. Fail 	if the class is not indexable or if the argument is not a positive Integer. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>	self isVariable ifFalse: [		self error: self printString, ' cannot have variable sized instances'].	(anInteger isInteger and: [anInteger >= 0]) ifTrue: [		"arg okay; space must be low"		Smalltalk signalLowSpace.		^ self basicNew: anInteger  "retry if user proceeds"	].	self primitiveFailed! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'tk 4/26/1999 07:28'!formalParametersAt: aSelector	"Return the names of the arguments used in this method."	| source parser message list params |	source _ self sourceCodeAt: aSelector ifAbsent: [^ #()].	"for now"	(parser _ self parserClass new) parseSelector: source.	message _ source copyFrom: 1 to: (parser endOfLastToken min: source size).	list _ message string findTokens: Character separators.	params _ OrderedCollection new.	list withIndexDo: [:token :ind | ind even ifTrue: [params addLast: token]].	^ params! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'tk 3/24/1999 07:44'!selectorsWithArgs: numberOfArgs	"Return all selectors defined in this class that take this number of arguments.  Could use String.keywords.  Could see how compiler does this."	| list num |	list _ OrderedCollection new.	self selectorsDo: [:aSel | 		num _ aSel count: [:char | char == $:].		num = 0 ifTrue: [aSel last isLetter ifFalse: [num _ 1]].		num = numberOfArgs ifTrue: [list add: aSel]].	^ list! !!Debugger methodsFor: 'initialize' stamp: 'tk 4/18/1999 06:59'!openFullNoSuspendLabel: aString	"Create and schedule a full debugger with the given label. Do not terminate the current active process."	| topView |	Smalltalk isMorphic ifNotNil: [self openFullMorphicLabel: aString.		^ Project current spawnNewProcess].	topView _ self buildMVCDebuggerViewLabel: aString minSize: 300@200.	topView controller openNoTerminate.	^ topView! !!Encoder methodsFor: 'encoding' stamp: 'tk 4/20/1999 15:41'!undeclared: name	| sym |	requestor interactive ifTrue: [		requestor requestor == #error: ifTrue: [requestor error: 'Undeclared'].		^ self notify: 'Undeclared'].	Transcript show: ' (' , name , ' is Undeclared) '.	sym _ name asSymbol.	Undeclared at: sym put: nil.	^self global: (Undeclared associationAt: sym) name: sym! !!MethodFinder commentStamp: 'tk 4/30/1999 14:40' prior: 0!Find a method in the system from a set of examples.  Done by brute force, trying every possible selector.  Errors are skipped over using ( [3 + 'xyz'] ifError: [^ false] ).Submit an array of the form ((data1 data2) answer  (data1 data2) answer).	MethodFinder methodFor: #( (4 3) 7  (0 5) 5  (5 5) 10).answer:  'data1 + data2'More generally, use the brace notation to construct live examples.The program tries data1 as the receiver, and	tries all other permutations of the data for the receiver and args, and	tries leaving out one argument, and	uses all selectors data understands, and	uses all selectors in all od data's superclasses.Floating point values must be precise to 0.01 percent, or (X * 0.0001).If you get an error, you have probably discovered a selector that needs to be removed from the Approved list.  See MethodFinder.initialize.  Please email the Squeak Team.Only considers 0, 1, 2, and 3 argument messages.  The argument data may have 1 to 5 entries, but only a max of 4 used at a time.  For now, we only test messages that use given number of args or one fewer.  For example, this data (100 true 0.6) would test the receiver plus two args, and the receiver plus one arg, but not any other patterns.Three sets of selectors:  Approved, AddAndRemove, and Blocks selectors.  When testing a selector in AddAndRemove, deepCopy the receiver.  We do not handle selectors that modify an argument (printOn: etc.).  Blocks is a set of (selector argNumber) where that argument must be a block.For perform, the selector is tested.  It must be in the Approved list.do: is not on the Approved list.  It does not produce a result that can be tested.  Type 'do' into the upper pane of the Selector Finder to find messages list that.[Later, allow the user to supply a block that tests the answer, not just the literal answer.]	MethodFinder methodFor: { { true. [3]. [4]}. 3}. Later allow this to work without the blocks around 3 and 4.!!MethodFinder reorganize!('initialize' initialize initialize2 load: noteDangerous organizationFiltered: test2: test3 testFromTuple: testRandom verify)('arg maps' argMap data makeAllMaps mapData permuteArgs thisData)('search' findMessage search simpleSearch testPerfect:)!!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/27/1999 17:52'!initialize	"The methods we are allowed to use.  (MethodFinder new initialize) "	Approved _ Set new.	AddAndRemove _ Set new.	Blocks _ Set new.	"These modify an argument: longPrintOn: printOn: storeOn: sentTo: storeOn:base: printOn:base: absPrintExactlyOn:base: absPrintOn:base: absPrintOn:base:digitCount: writeOn: writeScanOn: possibleVariablesFor:continuedFrom:""Object"  	#("in class, instance creation" categoryForUniclasses chooseUniqueClassName initialInstance isSystemDefined newFrom: officialClass readCarefullyFrom:"accessing" at: basicAt: basicSize bindWithTemp: in: size yourself "testing" basicType ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: isColor isFloat isFraction isInMemory isInteger isMorph isNil isNumber isPoint isPseudoContext isText isTransparent isWebBrowser knownName notNil pointsTo: wantsSteps "comparing" = == closeTo: hash hashMappedBy: identityHash identityHashMappedBy: identityHashPrintString ~= ~~ "copying" clone copy shallowCopy "dependents access" canDiscardEdits dependents hasUnacceptedEdits "updating" changed changed: okToChange update: windowIsClosing "printing" fullPrintString isLiteral longPrintString printString storeString stringForReadout stringRepresentation "class membership" class isKindOf: isKindOf:orOf: isMemberOf: respondsTo: xxxClass "error handling" "user interface" addModelMenuItemsTo:forMorph:hand: defaultBackgroundColor defaultLabelForInspector fullScreenSize initialExtent modelWakeUp mouseUpBalk: newTileMorphRepresentative windowActiveOnFirstClick windowReqNewLabel: "system primitives" asOop instVarAt: instVarNamed: "private" "associating" -> "converting" as: asOrderedCollection asString "casing" caseOf: caseOf:otherwise: "binding" bindingOf: "macpal" contentsChanged currentEvent currentHand currentWorld flash ifKindOf:thenDo: instanceVariableValues scriptPerformer "flagging" flag: "translation support" "objects from disk" "finalization" ) do: [:sel | Approved add: sel].	#(at:add: at:modify: at:put: basicAt:put: "NOT instVar:at:""message handling" perform: perform:orSendTo: perform:with: perform:with:with: perform:with:with:with: perform:withArguments: perform:withArguments:inSuperclass: ) do: [:sel | AddAndRemove add: sel]."Boolean, True, False, UndefinedObject"  	#("logical operations" & eqv: not xor: |"controlling" and: ifFalse: ifFalse:ifTrue: ifTrue: ifTrue:ifFalse: or:"copying" "testing" isEmptyOrNil) do: [:sel | Approved add: sel]."Behavior" 	#("initialize-release""accessing" compilerClass decompilerClass evaluatorClass format methodDict parserClass sourceCodeTemplate subclassDefinerClass"testing" instSize instSpec isBits isBytes isFixed isPointers isVariable isWeak isWords"copying""printing" defaultNameStemForInstances printHierarchy"creating class hierarchy""creating method dictionary""instance creation" basicNew basicNew: new new:"accessing class hierarchy" allSubclasses allSubclassesWithLevelDo:startingLevel: allSuperclasses subclasses superclass withAllSubclasses withAllSuperclasses"accessing method dictionary" allSelectors changeRecordsAt: compiledMethodAt: compiledMethodAt:ifAbsent: firstCommentAt: lookupSelector: selectors selectorsDo: selectorsWithArgs: "slow but useful ->" sourceCodeAt: sourceCodeAt:ifAbsent: sourceMethodAt: sourceMethodAt:ifAbsent:"accessing instances and variables" allClassVarNames allInstVarNames allSharedPools classVarNames instVarNames instanceCount sharedPools someInstance subclassInstVarNames"testing class hierarchy" inheritsFrom: kindOfSubclass"testing method dictionary" canUnderstand: classThatUnderstands: hasMethods includesSelector: scopeHas:ifTrue: whichClassIncludesSelector: whichSelectorsAccess: whichSelectorsReferTo: whichSelectorsReferTo:special:byte: whichSelectorsStoreInto:"enumerating""user interface""private" indexIfCompact) do: [:sel | Approved add: sel]."ClassDescription"	#("initialize-release" "accessing" classVersion isMeta name theNonMetaClass"copying" "printing" classVariablesString instanceVariablesString sharedPoolsString"instance variables" checkForInstVarsOK: "method dictionary" "organization" category organization whichCategoryIncludesSelector:"compiling" acceptsLoggingOfCompilation wantsChangeSetLogging"fileIn/Out" definition"private" ) do: [:sel | Approved add: sel]."Class"	#("initialize-release" "accessing" classPool"testing""copying" "class name" "instance variables" "class variables" classVarAt: classVariableAssociationAt:"pool variables" "compiling" "subclass creation" "fileIn/Out" ) do: [:sel | Approved add: sel]. "Metaclass"	#("initialize-release" "accessing" isSystemDefined soleInstance"copying" "instance creation" "instance variables"  "pool variables" "class hierarchy"  "compiling""fileIn/Out"  nonTrivial ) do: [:sel | Approved add: sel]."Context, BlockContext"	#(receiver client method receiver tempAt: "debugger access" mclass pc selector sender shortStack sourceCode tempNames tempsAndValues"controlling"  "printing" "system simulation" "initialize-release" "accessing" hasMethodReturn home numArgs"evaluating" value value:ifError: value:value: value:value:value: value:value:value:value: valueWithArguments:"controlling"  "scheduling"  "instruction decoding"  "printing" "private"  "system simulation" ) do: [:sel | Approved add: sel].	#(value: "<- Association has it as a store" ) do: [:sel | AddAndRemove add: sel]."Message"	#("inclass, instance creation" selector: selector:argument: selector:arguments:"accessing" argument argument: arguments sends:"printing" "sending" ) do: [:sel | Approved add: sel].	#("private" setSelector:arguments:) do: [:sel | AddAndRemove add: sel]."Magnitude"	#("comparing" < <= > >= between:and:"testing" max: min: min:max: ) do: [:sel | Approved add: sel]."Date, Time"	#("in class, instance creation" fromDays: fromSeconds: fromString: newDay:month:year: newDay:year: today	"in class, general inquiries" dateAndTimeNow dayOfWeek: daysInMonth:forYear: daysInYear: firstWeekdayOfMonth:year: indexOfMonth: leapYear: nameOfDay: nameOfMonth:"accessing" day leap monthIndex monthName weekday year"arithmetic" addDays: subtractDate: subtractDays:"comparing""inquiries" dayOfMonth daysInMonth daysInYear daysLeftInYear firstDayOfMonth previous:"converting" asSeconds"printing" mmddyy mmddyyyy printFormat: printOn:format:"private" firstDayOfMonthIndex: weekdayIndex 	"in class, instance creation" fromSeconds: now 	"in class, general inquiries" dateAndTimeFromSeconds: dateAndTimeNow millisecondClockValue millisecondsToRun: totalSeconds"accessing" hours minutes seconds"arithmetic" addTime: subtractTime:"comparing""printing" intervalString print24 "converting") do: [:sel | Approved add: sel].	#("private" hours: hours:minutes:seconds: day:year: 		 ) do: [:sel | AddAndRemove add: sel]."Number"	#("in class" readFrom:base: "arithmetic" * + - / // \\ abs negated quo: reciprocal rem:"mathematical functions" arcCos arcSin arcTan arcTan: cos exp floorLog: ln log log: raisedTo: raisedToInteger: sin sqrt squared tan"truncation and round off" ceiling detentBy:atMultiplesOf:snap: floor roundTo: roundUpTo: rounded truncateTo: truncated"comparing""testing" even isDivisibleBy: isInf isInfinite isNaN isZero negative odd positive sign strictlyPositive"converting" @ asInteger asNumber asPoint asSmallAngleDegrees degreesToRadians radiansToDegrees"intervals" to: to:by: "printing" printStringBase: storeStringBase: ) do: [:sel | Approved add: sel]."Integer"	#("in class" primesUpTo:"testing" isPowerOfTwo"arithmetic" alignedTo:"comparing""truncation and round off" atRandom normalize"enumerating" timesRepeat:"mathematical functions" degreeCos degreeSin factorial gcd: lcm: take:"bit manipulation" << >> allMask: anyMask: bitAnd: bitClear: bitInvert bitInvert32 bitOr: bitShift: bitXor: lowBit noMask:"converting" asCharacter asColorOfDepth: asFloat asFraction asHexDigit"printing" asStringWithCommas hex hex8 radix:"system primitives" lastDigit replaceFrom:to:with:startingAt:"private" "benchmarks" ) do: [:sel | Approved add: sel]."SmallInteger, LargeNegativeInteger, LargePositiveInteger"	#("arithmetic" "bit manipulation" highBit "testing" "comparing" "copying" "converting" "printing" "system primitives" digitAt: digitLength "private" fromString:radix: ) do: [:sel | Approved add: sel].	#(digitAt:put: ) do: [:sel | AddAndRemove add: sel]."Float"	#("arithmetic""mathematical functions" reciprocalFloorLog: reciprocalLogBase2 timesTwoPower:"comparing" "testing""truncation and round off" exponent fractionPart integerPart significand significandAsInteger"converting" asApproximateFraction asIEEE32BitWord asTrueFraction"copying") do: [:sel | Approved add: sel]."Fraction, Random"	#(denominator numerator reduced next nextValue) do: [:sel | Approved add: sel].	#(setNumerator:denominator:) do: [:sel | AddAndRemove add: sel]."Collection"	#("accessing" anyOne"testing" includes: includesAllOf: includesAnyOf: includesSubstringAnywhere: isEmpty isSequenceable occurrencesOf:"enumerating" collect: collect:thenSelect: contains: count: detect: detect:ifNone: detectMax: detectMin: detectSum: inject:into: reject: select: select:thenCollect:"converting" asBag asCharacterSet asSet asSortedArray asSortedCollection asSortedCollection:"printing""private" maxSize"arithmetic""math functions" average max median min range sum) do: [:sel | Approved add: sel].	#("adding" add: addAll: addIfNotPresent:"removing" remove: remove:ifAbsent: removeAll: removeAllFoundIn: removeAllSuchThat: remove:ifAbsent:) do: [:sel | AddAndRemove add: sel]."SequenceableCollection"	#("comparing" hasEqualElements:"accessing" allButFirst allButLast at:ifAbsent: atAll: atPin: atRandom: atWrap: fifth first fourth identityIndexOf: identityIndexOf:ifAbsent: indexOf: indexOf:ifAbsent: indexOf:startingAt:ifAbsent: indexOfSubCollection:startingAt: indexOfSubCollection:startingAt:ifAbsent: last second sixth third"removing""copying" , copyAfterLast: copyAt:put: copyFrom:to: copyReplaceAll:with: copyReplaceFrom:to:with: copyUpTo: copyUpToLast: copyWith: copyWithout: copyWithoutAll: forceTo:paddingWith: shuffled sortBy:"enumerating" collectWithIndex: findFirst: findLast: pairsCollect: with:collect: withIndexCollect: "converting" asArray asDictionary asFloatArray asIntegerArray asStringWithCr asWordArray reversed"private" copyReplaceAll:with:asTokens: ) do: [:sel | Approved add: sel].	#( swap:with:) do: [:sel | AddAndRemove add: sel]."ArrayedCollection, Bag"	#("private" defaultElement "sorting" isSorted"accessing" cumulativeCounts sortedCounts sortedElements "testing" "adding" add:withOccurrences: "removing" "enumerating" 	) do: [:sel | Approved add: sel].	#( mergeSortFrom:to:by: sort sort: fill:fromStack: add: add:withOccurrences:"private" setDictionary ) do: [:sel | AddAndRemove add: sel]."Other messages that modify the receiver"	#(atAll:put: atAll:putAll: atAllPut: atWrap:put: replaceAll:with: replaceFrom:to:with:  removeFirst removeLast) do: [:sel | AddAndRemove add: sel].	self initialize2."MethodFinder new initialize.MethodFinder new organizationFiltered: Set"! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/30/1999 16:23'!initialize2	"The methods we are allowed to use.  (MethodFinder new initialize) "| |"Set"	#("in class" sizeFor:"testing" "adding" "removing" "enumerating""private" array findElementOrNil: "accessing" someElement) do: [:sel | Approved add: sel]."Dictionary, IdentityDictionary, IdentitySet"	#("accessing" associationAt: associationAt:ifAbsent: at:ifPresent: keyAtIdentityValue: keyAtIdentityValue:ifAbsent: keyAtValue: keyAtValue:ifAbsent: keys"testing" includesKey: ) do: [:sel | Approved add: sel].	#(removeKey: removeKey:ifAbsent:) do: [:sel | AddAndRemove add: sel]."LinkedList, Interval, MappedCollection"	#("in class"  from:to: from:to:by:"accessing" contents) do: [:sel | Approved add: sel].	#("adding" addFirst: addLast:) do: [:sel | AddAndRemove add: sel]."OrderedCollection, SortedCollection"	#("accessing" after: before:"copying" copyEmpty"adding"  growSize"removing" "enumerating" "private" "accessing" sortBlock) do: [:sel | Approved add: sel].	#("adding" add:after: add:afterIndex: add:before: addAllFirst: addAllLast: addFirst: addLast:"removing" removeAt: removeFirst removeLast"accessing" sortBlock:) do: [:sel | AddAndRemove add: sel]."Character"	#("in class, instance creation" allCharacters digitValue: new separators	"accessing untypeable characters" backspace cr enter lf linefeed nbsp newPage space tab	"constants" alphabet characterTable"accessing" asciiValue digitValue"comparing""testing" isAlphaNumeric isDigit isLetter isLowercase isSafeForHTTP isSeparator isSpecial isUppercase isVowel tokenish"copying""converting" asIRCLowercase asLowercase asUppercase	) do: [:sel | Approved add: sel]."String"	#("in class, instance creation" crlf fromPacked:	"primitives" findFirstInString:inSet:startingAt: indexOfAscii:inString:startingAt: 	"internet" valueOfHtmlEntity:"accessing" byteAt: endsWithDigit findAnySubStr:startingAt: findBetweenSubStrs: findDelimiters:startingAt: findString:startingAt: findString:startingAt:caseSensitive: findTokens: findTokens:includes: findTokens:keep: includesSubString: includesSubstring:caseSensitive: indexOf:startingAt: indexOfAnyOf: indexOfAnyOf:ifAbsent: indexOfAnyOf:startingAt: indexOfAnyOf:startingAt:ifAbsent: lineCorrespondingToIndex: lineCount lineNumber: skipAnySubStr:startingAt: skipDelimiters:startingAt: startsWithDigit"comparing" alike: beginsWith: caseSensitiveLessOrEqual: charactersExactlyMatching: compare: crc16 endsWith: endsWithAnyOf: match: sameAs: startingAt:match:startingAt:"copying" copyReplaceTokens:with: padded:to:with:"converting" asByteArray asDate asDisplayText asFileName asHtml asLegalSelector asPacked asParagraph asText asTime asUnHtml asUrl asUrlRelativeTo: capitalized compressWithTable: contractTo: correctAgainst: encodeForHTTP initialInteger integerAtBeginning keywords quoted sansPeriodSuffix splitInteger stemAndNumericSuffix substrings surroundedBySingleQuotes translateToLowercase truncateWithElipsisTo: withBlanksTrimmed withFirstCharacterDownshifted withNoLineLongerThan: withSeparatorsCompacted withoutLeadingDigits withoutTrailingBlanks"displaying" "printing""system primitives" compare:with:collated: "Celeste" withCRs"internet" decodeMimeHeader decodeQuotedPrintable replaceHtmlCharRefs unescapePercents withInternetLineEndings withSqueakLineEndings withoutQuoting"testing" isAllSeparators lastSpacePosition"paragraph support" indentationIfBlank:"arithmetic" ) do: [:sel | Approved add: sel].	#(byteAt:put: ) do: [:sel | AddAndRemove add: sel]."Symbol"	#("in class, private" hasInterned:ifTrue:	"access" morePossibleSelectorsFor: possibleSelectorsFor: selectorsContaining: thatStarts:skipping:"accessing" "comparing" "copying" "converting" "printing" "system primitives" isInfix isKeyword isPvtSelector) do: [:sel | Approved add: sel]."Array"	#("comparing" "converting" evalStrings "printing" "private" hasLiteralSuchThat:) do: [:sel | Approved add: sel]."Array2D"	#("access" at:at: atCol: atCol:put: atRow: extent extent:fromArray: height width width:height:type:) do: [:sel | Approved add: sel].	#(at:at:add: at:at:put: atRow:put: ) do: [:sel | AddAndRemove add: sel]."ByteArray"	#("accessing" doubleWordAt: wordAt: "platform independent access" longAt:bigEndian: shortAt:bigEndian: unsignedLongAt:bigEndian: unsignedShortAt:bigEndian: "converting") do: [:sel | Approved add: sel].	#(doubleWordAt:put: wordAt:put: longAt:put:bigEndian: shortAt:put:bigEndian: unsignedLongAt:put:bigEndian: unsignedShortAt:put:bigEndian:	) do: [:sel | AddAndRemove add: sel]."FloatArray"		"Dont know what happens when prims not here"	false ifTrue: [#("accessing" "arithmetic" *= += -= /="comparing""primitives-plugin" primAddArray: primAddScalar: primDivArray: primDivScalar: primMulArray: primMulScalar: primSubArray: primSubScalar:"primitives-translated" primAddArray:withArray:from:to: primMulArray:withArray:from:to: primSubArray:withArray:from:to:"converting" "private" "user interface") do: [:sel | Approved add: sel].	]."IntegerArray, WordArray""RunArray"	#("in class, instance creation" runs:values: scanFrom:"accessing" runLengthAt: "adding" "copying""private" runs values) do: [:sel | Approved add: sel].	#(coalesce addLast:times: repeatLast:ifEmpty: repeatLastIfEmpty:		) do: [:sel | AddAndRemove add: sel]."Stream  -- many operations change its state"	#("testing" atEnd) do: [:sel | Approved add: sel].	#("accessing" next: nextMatchAll: nextMatchFor: upToEndnext:put: nextPut: nextPutAll: "printing" print: printHtml:	) do: [:sel | AddAndRemove add: sel]."PositionableStream"	#("accessing" contentsOfEntireFile originalContents peek peekFor: "testing""positioning" position ) do: [:sel | Approved add: sel].	#(nextDelimited: nextLine upTo: position: reset resetContents setToEnd skip: skipTo:		) do: [:sel | AddAndRemove add: sel].	"Because it is so difficult to test the result of an operation on a Stream (you have to supply another Stream in the same state), we don't support Streams beyond the basics.  We want to find the messages that convert Streams to other things.""ReadWriteStream"	#("file status" closed) do: [:sel | Approved add: sel].	#("accessing" next: on: ) do: [:sel | AddAndRemove add: sel]."WriteStream"	#("in class, instance creation" on:from:to: with: with:from:to:		) do: [:sel | Approved add: sel].	#("positioning" resetToStart"character writing" crtab crtab:) do: [:sel | AddAndRemove add: sel]."LookupKey, Association, Link"	#("accessing" key nextLink) do: [:sel | Approved add: sel].	#(key: key:value: nextLink:) do: [:sel | AddAndRemove add: sel]."Point"	#("in class, instance creation" r:degrees: x:y:"accessing" x y "comparing" "arithmetic" "truncation and round off""polar coordinates" degrees r theta"point functions" bearingToPoint: crossProduct: dist: dotProduct: eightNeighbors flipBy:centerAt: fourNeighbors grid: nearestPointAlongLineFrom:to: nearestPointOnLineFrom:to: normal normalized octantOf: onLineFrom:to: onLineFrom:to:within: quadrantOf: rotateBy:centerAt: transposed unitVector"converting" asFloatPoint asIntegerPoint corner: extent: rect:"transforming" adhereTo: rotateBy:about: scaleBy: scaleFrom:to: translateBy: "copying""interpolating" interpolateTo:at:) do: [:sel | Approved add: sel]."Rectangle"	#("in class, instance creation" center:extent: encompassing: left:right:top:bottom: 	merging: origin:corner: origin:extent: "accessing" area bottom bottomCenter bottomLeft bottomRight boundingBox center corner corners innerCorners left leftCenter origin right rightCenter top topCenter topLeft topRight"comparing""rectangle functions" adjustTo:along: amountToTranslateWithin: areasOutside: bordersOn:along: encompass: expandBy: extendBy: forPoint:closestSideDistLen: insetBy: insetOriginBy:cornerBy: intersect: merge: pointNearestTo: quickMerge: rectanglesAt:height: sideNearestTo: translatedToBeWithin: withBottom: withHeight: withLeft: withRight: withSide:setTo: withTop: withWidth:"testing" containsPoint: containsRect: hasPositiveExtent intersects: isTall isWide"truncation and round off""transforming" align:with: centeredBeneath: newRectFrom: squishedWithin: "copying"	) do: [:sel | Approved add: sel]."Color"	#("in class, instance creation" colorFrom: colorFromPixelValue:depth: fromRgbTriplet: gray: h:s:v: r:g:b: r:g:b:alpha: r:g:b:range:	"named colors" black blue brown cyan darkGray gray green lightBlue lightBrown lightCyan lightGray lightGreen lightMagenta lightOrange lightRed lightYellow magenta orange red transparent veryDarkGray veryLightGray veryVeryDarkGray veryVeryLightGray white yellow	"other" colorNames indexedColors pixelScreenForDepth: quickHighLight:"access" alpha blue brightness green hue luminance red saturation"equality""queries" isBitmapFill isBlack isGray isSolidFill isTranslucent isTranslucentColor"transformations" alpha: dansDarker darker lighter mixed:with: muchLighter slightlyDarker slightlyLighter veryMuchLighter"groups of shades" darkShades: lightShades: mix:shades: wheel:"printing" shortPrintString"other" colorForInsets rgbTriplet"conversions" asB3DColor asColor balancedPatternForDepth: bitPatternForDepth: closestPixelValue1 closestPixelValue2 closestPixelValue4 closestPixelValue8 dominantColor halfTonePattern1 halfTonePattern2 indexInMap: pixelValueForDepth: pixelWordFor:filledWith: pixelWordForDepth: scaledPixelValue32"private" privateAlpha privateBlue privateGreen privateRGB privateRed "copying"	) do: [:sel | Approved add: sel]."	For each selector that requires a block argument, add (selector argNum) 		to the set Blocks.""ourClasses _ #(Object Boolean True False UndefinedObject Behavior ClassDescription Class Metaclass MethodContext BlockContext Message Magnitude Date Time Number Integer SmallInteger LargeNegativeInteger LargePositiveInteger Float Fraction Random Collection SequenceableCollection ArrayedCollection Bag Set Dictionary IdentityDictionary IdentitySet LinkedList Interval MappedCollection OrderedCollection SortedCollection Character String Symbol Array Array2D ByteArray FloatArray IntegerArray WordArray RunArray Stream PositionableStream ReadWriteStream WriteStream LookupKey Association Link Point Rectangle Color).ourClasses do: [:clsName | cls _ Smalltalk at: clsName.	(cls selectors) do: [:aSel |		((Approved includes: aSel) or: [AddAndRemove includes: aSel]) ifTrue: [			(cls formalParametersAt: aSel) withIndexDo: [:tName :ind |				(tName endsWith: 'Block') ifTrue: [					Blocks add: (Array with: aSel with: ind)]]]]]."#((timesRepeat: 1 ) (indexOf:ifAbsent: 2 ) (pairsCollect: 1 ) (mergeSortFrom:to:by: 3 ) (ifNotNil:ifNil: 1 ) (ifNotNil:ifNil: 2 ) (ifNil: 1 ) (at:ifAbsent: 2 ) (ifNil:ifNotNil: 1 ) (ifNil:ifNotNil: 2 ) (ifNotNil: 1 ) (at:modify: 2 ) (identityIndexOf:ifAbsent: 2 ) (sort: 1 ) (sortBlock: 1 ) (detectMax: 1 ) (repeatLastIfEmpty: 1 ) (allSubclassesWithLevelDo:startingLevel: 1 ) (keyAtValue:ifAbsent: 2 ) (in: 1 ) (ifTrue: 1 ) (or: 1 ) (select: 1 ) (inject:into: 2 ) (ifKindOf:thenDo: 2 ) (forPoint:closestSideDistLen: 2 ) (value:ifError: 2 ) (selectorsDo: 1 ) (removeAllSuchThat: 1 ) (keyAtIdentityValue:ifAbsent: 2 ) (detectMin: 1 ) (detect:ifNone: 1 ) (ifTrue:ifFalse: 1 ) (ifTrue:ifFalse: 2 ) (detect:ifNone: 2 ) (hasLiteralSuchThat: 1 ) (indexOfAnyOf:ifAbsent: 2 ) (reject: 1 ) (newRectFrom: 1 ) (removeKey:ifAbsent: 2 ) (at:ifPresent: 2 ) (associationAt:ifAbsent: 2 ) (withIndexCollect: 1 ) (repeatLast:ifEmpty: 2 ) (findLast: 1 ) (indexOf:startingAt:ifAbsent: 3 ) (contains: 1 ) (remove:ifAbsent: 2 ) (ifFalse:ifTrue: 1 ) (ifFalse:ifTrue: 2 ) (caseOf:otherwise: 2 ) (count: 1 ) (collect: 1 ) (sortBy: 1 ) (and: 1 ) (asSortedCollection: 1 ) (with:collect: 2 ) (sourceCodeAt:ifAbsent: 2 ) (detect: 1 ) (scopeHas:ifTrue: 2 ) (collectWithIndex: 1 ) (compiledMethodAt:ifAbsent: 2 ) (bindWithTemp: 1 ) (detectSum: 1 ) (indexOfSubCollection:startingAt:ifAbsent: 3 ) (findFirst: 1 ) (sourceMethodAt:ifAbsent: 2 ) (collect:thenSelect: 1 ) (collect:thenSelect: 2 ) (select:thenCollect: 1 ) (select:thenCollect: 2 ) (ifFalse: 1 ) (indexOfAnyOf:startingAt:ifAbsent: 3 ) (indentationIfBlank: 1 ) ) do: [:anArray |	Blocks add: anArray]."MethodFinder new initialize.MethodFinder new organizationFiltered: TranslucentColor class ""Do not forget class messages for each of these classes"! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/30/1999 15:29'!load: dataWithAnswers	"Find a function that takes the data and gives the answers.  Odd list entries are data for it, even ones are the answers. ""  (MethodFinder new) load: #( (4 3) 7  (-10 5) -5  (-3 11) 8);		findMessage  "| fixed |data _ Array new: dataWithAnswers size // 2.1 to: data size do: [:ii | data at: ii put: (dataWithAnswers at: ii*2-1)].answers _ Array new: data size.1 to: answers size do: [:ii | answers at: ii put: (dataWithAnswers at: ii*2)].fixed _ false.data do: [:list | 	(list isKindOf: SequenceableCollection) ifFalse: [		^ self inform: 'first and third items are not Arrays'].	list withIndexDo: [:arg :ind | 			arg == #true ifTrue: [list at: ind put: true.  fixed _ true].			arg == #false ifTrue: [list at: ind put: false.  fixed _ true].			]].answers withIndexDo: [:arg :ind | 			arg == #true ifTrue: [answers at: ind put: true.  fixed _ true].			arg == #false ifTrue: [answers at: ind put: false.  fixed _ true].			].fixed ifTrue: [self inform: '#(true false) are Symbols, not Booleans.  Next time use { true. false }'].argMap _ (1 to: data first size) asArray.argMap size > 5 ifTrue: [self inform: 'No more than a receiver and four arguments allowed'].	"Really only test receiver and three args." thisData _ data copy.mapStage _ mapList _ nil.! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/15/1999 19:14'!noteDangerous	"Remember the methods with really bad side effects."	Dangerous _ Set new."Object accessing, testing, copying, dependent access, macpal, flagging"	#(addInstanceVarNamed:withValue: haltIfNil copyAddedStateFrom: veryDeepCopy veryDeepCopyWith: veryDeepFixupWith: veryDeepInner: addDependent: evaluate:wheneverChangeIn: codeStrippedOut: playSoundNamed: isThisEverCalled isThisEverCalled: logEntry logExecution logExit)		do: [:sel | Dangerous add: sel]."Object error handling"	#(cannotInterpret: caseError confirm: confirm:orCancel: doesNotUnderstand: error: halt halt: notify: notify:at: primitiveFailed shouldNotImplement subclassResponsibility tryToDefineVariableAccess:)		do: [:sel | Dangerous add: sel]."Object user interface"	#(basicInspect beep inform: inspect inspectWithLabel: notYetImplemented smartInspect )		do: [:sel | Dangerous add: sel]."Object system primitives"	#(become: becomeForward: instVarAt:put: instVarNamed:put: nextInstance nextObject rootStubInImageSegment: someObject tryPrimitive:withArgs:)		do: [:sel | Dangerous add: sel]."Object private"	#(errorImproperStore errorNonIntegerIndex errorNotIndexable errorSubscriptBounds: mustBeBoolean primitiveError: species storeAt:inTempFrame:)		do: [:sel | Dangerous add: sel]."Object, translation support"	#(cCode: cCode:inSmalltalk: cCoerce:to: export: inline: returnTypeC: sharedCodeNamed:inCase: var:declareC:)		do: [:sel | Dangerous add: sel]."Object, objects from disk, finalization.  And UndefinedObject"	#(comeFullyUpOnReload: objectForDataStream: readDataFrom:size: rehash saveOnFile storeDataOn: actAsExecutor executor finalize retryWithGC:until:   suspend)		do: [:sel | Dangerous add: sel]."No Restrictions:   Boolean, False, True, ""Morph"	#(fullCopy copyRecordingIn:)		do: [:sel | Dangerous add: sel]."Behavior"	#(obsolete confirmRemovalOf: copyOfMethodDictionary literalScannedAs:notifying: storeLiteral:on: addSubclass: removeSubclass: superclass: "creating method dictionary" addSelector:withMethod: compile: compile:notifying: compileAll compileAllFrom: compress decompile: defaultSelectorForMethod: methodDictionary: recompile:from: recompileChanges removeSelector: compressedSourceCodeAt: selectorAtMethod:setClass: allInstances allSubInstances inspectAllInstances inspectSubInstances thoroughWhichSelectorsReferTo:special:byte: "enumerating" allInstancesDo: allSubInstancesDo: allSubclassesDo: allSuperclassesDo: selectSubclasses: selectSuperclasses: subclassesDo: withAllSubclassesDo:"user interface" allCallsOn: browse browseAllAccessesTo: browseAllCallsOn: browseAllStoresInto: "too slow->" crossReference removeUninstantiatedSubclassesSilently "too slow->" unreferencedInstanceVariables"private" becomeCompact becomeUncompact flushCache format:variable:words:pointers: format:variable:words:pointers:weak: printSubclassesOn:level: removeSelectorSimply:)		do: [:sel | Dangerous add: sel]."Others "	#("no tangible result" do: associationsDo:  "private" adaptToCollection:andSend: adaptToNumber:andSend: adaptToPoint:andSend: adaptToString:andSend: instVarAt:put: asDigitsToPower:do: combinations:atATimeDo: doWithIndex: pairsDo: permutationsDo: reverseDo: reverseWith:do: with:do: withIndexDo: asDigitsAt:in:do: combinationsAt:in:after:do: errorOutOfBounds permutationsStartingAt:do: fromUser)		do: [:sel | Dangerous add: sel].	#(    fileOutPrototype addSpareFields makeFileOutFile )		do: [:sel | Dangerous add: sel].	#(recompile:from: recompileAllFrom: recompileChanges asPrototypeWithFields: asPrototype addInstanceVarNamed:withValue: addInstanceVariable addClassVarName: removeClassVarName: findOrAddClassVarName: tryToDefineVariableAccess: instanceVariableNames: )		do: [:sel | Dangerous add: sel]. ! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/14/1999 11:16'!organizationFiltered: aClass	"Return the organization of the class with all selectors defined in superclasses removed.  (except those in Object)"	| org str |	org _ aClass organization deepCopy.	Dangerous do: [:sel |			org removeElement: sel].	Approved do: [:sel |			org removeElement: sel].	AddAndRemove do: [:sel |			org removeElement: sel].	str _ org printString copyWithout: $(.	str _ '(', (str copyWithout: $) ).	str _ str replaceAll: $' with: $".	^ str! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/27/1999 17:24'!test2: anArray	"look for bad association"	anArray do: [:sub |		sub class == Association ifTrue: [			(#('true' '$a' '2' 'false') includes: sub value printString) ifFalse: [				self error: 'bad assn'].			(#('3' '5.6' 'x' '''abcd''') includes: sub key printString) ifFalse: [				self error: 'bad assn'].	"			sub value class == Association ifTrue: [					self error: 'bad assn'].				(sub value isKindOf: Class) ifTrue: [					self error: 'class in assn'].				sub value class == Symbol ifTrue: [sub value asciiValue = 204 '$Ì' ifTrue: [					self error: 'Write into char']].				sub value == $Ì ifTrue: [					self error: 'Write into char']	"].		sub class == Array ifTrue: [			sub do: [:element | 				element class == String ifTrue: [element first asciiValue < 32 ifTrue: [						self error: 'store into string in data']].				element class == Association ifTrue: [					element value class == Association ifTrue: [						self error: 'bad assn']]]].		sub class == Date ifTrue: [sub year isInteger ifFalse: [				self error: 'stored into input date!!!!']].		sub class == Dictionary ifTrue: [				sub size > 0 ifTrue: [					self error: 'store into dictionary']].		sub class == OrderedCollection ifTrue: [				sub size > 4 ifTrue: [					self error: 'store into OC']].		].! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/24/1999 19:34'!test3	"find the modification of the caracter table"	(#x at: 1) asciiValue = 120 ifFalse: [self error: 'Character table mod'].! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/27/1999 17:56'!testFromTuple: nth	"verify that the methods allowed don't crash the system.  Try N of each of the fundamental types.  up to 4 of each kind." | objects nonRepeating even other aa cnt |objects _ #((1 4 17 42) ($a $b $c $d) ('one' 'two' 'three' 'four')	(x + rect: new) ((a b 1 4) (c 1 5) ($a 3 d) ()) (4.5 0.0 3.2 100.3)	).objects _ objects, {{true. false. true. false}. {Point. SmallInteger. Association. Array}.	{Point class. SmallInteger class. Association class. Array class}.	"{ 4 blocks }."	{Date today. '1 Jan 1950' asDate. '25 Aug 1987' asDate. '1 Jan 2000' asDate}.	{'15:16' asTime. '1:56' asTime. '4:01' asTime. '6:23' asTime}.	{Dictionary new. Dictionary new. Dictionary new. Dictionary new}.	{#(a b 1 4) asOrderedCollection. #(c 1 5) asOrderedCollection. 		#($a 3 d) asOrderedCollection. #() asOrderedCollection}.	{3->true. 5.6->$a. #x->2. 'abcd'->false}.	{9@3 extent: 5@4. 0@0 extent: 45@9. -3@-7 extent: 2@2. 4@4 extent: 16@16}.	{Color red.  Color blue. Color black. Color gray}}.self test2: objects."rec+0, rec+1, rec+2, rec+3 need to be tested.  " cnt _ 0.nth to: 4 do: [:take |	nonRepeating _ OrderedCollection new.	objects do: [:each |		nonRepeating addAll: (each copyFrom: 1 to: take)].	"all combinations of take, from nonRepeating"	even _ true.	nonRepeating combinations: take atATimeDo: [:tuple |		even ifTrue: [other _ tuple clone]			ifFalse: [self load: (aa _ Array with: tuple with: 1 with: other with: 7).				(cnt _ cnt+1) \\ 50 = 0 ifTrue: [					Transcript cr; show: aa first printString].				self search.				self test2: aa.				self test2: nonRepeating.				"self test2: objects"].		even _ even not].	].! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/29/1999 13:34'!testRandom	"verify that the methods allowed don't crash the system.  Pick 3 or 4 from a mixed list of the fundamental types." | objects other aa cnt take tuple fName sss |objects _ #((1 4 17 42) ($a $b $c $d) ('one' 'two' 'three' 'four')	(x + rect: new) ((a b 1 4) (c 1 5) ($a 3 d) ()) (4.5 0.0 3.2 100.3)	).objects _ objects, {{true. false. true. false}. {Point. SmallInteger. Association. Array}.	{Point class. SmallInteger class. Association class. Array class}.	"{ 4 blocks }."	{Date today. '1 Jan 1950' asDate. '25 Aug 1987' asDate. '1 Jan 2000' asDate}.	{'15:16' asTime. '1:56' asTime. '4:01' asTime. '6:23' asTime}.	{Dictionary new. Dictionary new. Dictionary new. Dictionary new}.	{#(a b 1 4) asOrderedCollection. #(c 1 5) asOrderedCollection. 		#($a 3 d) asOrderedCollection. #() asOrderedCollection}.	{3->true. 5.6->$a. #x->2. 'abcd'->false}.	{9@3 extent: 5@4. 0@0 extent: 45@9. -3@-7 extent: 2@2. 4@4 extent: 16@16}.	{Color red.  Color blue. Color black. Color gray}}.self test2: objects."rec+0, rec+1, rec+2, rec+3 need to be tested.  " fName _ (FileDirectory default fileNamesMatching: '*.ran') first.sss _ fName splitInteger first.(Collection classPool at: #RandomForPicking) seed: sss.cnt _ 0.[take _ #(3 4) atRandom.	tuple _ (1 to: take) collect: [:ind | (objects atRandom) atRandom].	other _ (1 to: take) collect: [:ind | (objects atRandom) atRandom].	self load: (aa _ Array with: tuple with: 1 with: other with: 7).	((cnt _ cnt+1) \\ 10 = 0) " | (cnt > Skip)" ifTrue: [		Transcript cr; show: cnt printString; tab; tab; show: aa first printString].	cnt > StopHere ifTrue: [self halt].		"stop just before crash"	cnt > Skip ifTrue: ["skip this many at start"		self search.		self test2: aa first.  self test2: (aa at: 3).		"self test2: objects"		].	true] whileTrue.	! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/30/1999 15:50'!verify	"Test a bunch of examples"	"	MethodFinder new verify   "(MethodFinder methodFor: #( (0) 0  (30) 0.5  (45) 0.707106  (90) 1)	) = 'data1 degreeSin' ifFalse: [self error: 'should have found it'].(MethodFinder methodFor:  { { true. [3]. [4]}. 3}	) = 'data1 ifTrue: data2 ifFalse: data3' ifFalse: [self error: 'should have found it'].(MethodFinder methodFor: #((1) true (2) false (5) true (10) false)	) = 'data1 odd' ifFalse: [self error: 'should have found it'].		"will correct the date type of #true, and complain"(MethodFinder methodFor: #((4 2) '2r100'   (255 16) '16rFF'    (14 8) '8r16')	) = 'data1 radix: data2'  ifFalse: [self error: 'should have found it'].	(MethodFinder methodFor: {{Point x: 3 y: 4}. 4.  {Point x: 1 y: 5}. 5}	) = 'data1 y' ifFalse: [self error: 'should have found it'].	(MethodFinder methodFor: #(('abcd') $a  ('Ted') $T)	) = 'data1 first' ifFalse: [self error: 'should have found it'].	(MethodFinder methodFor: #(('abcd' 1) $a  ('Ted ' 3) $d )	) = 'data1 at: data2' ifFalse: [self error: 'should have found it'].	(MethodFinder methodFor: #(((12 4 8)) 24  ((1 3 6)) 10 )	) = 'data1 sum'   ifFalse: [self error: 'should have found it'].			"note extra () needed for an Array object as an argument"(MethodFinder methodFor: #((14 3) 11  (-10 5) -15  (4 -3) 7)	) = 'data1 - data2' ifFalse: [self error: 'should have found it'].(MethodFinder methodFor: #((4) 4  (-10) 10 (-3) 3 (2) 2 (-6) 6 (612) 612)	) = 'data1 abs' ifFalse: [self error: 'should have found it'].(MethodFinder methodFor: {#(4 -1). true.  #(-7 3). false.  #(5 1). true.  #(5 6). false}	) = 'data1 > data2' ifFalse: [self error: 'should have found it'].	(MethodFinder methodFor: #((5) 0.2   (2) 0.5)	) = 'data1 reciprocal' ifFalse: [self error: 'should have found it'].	(MethodFinder methodFor: #((12 4 8) 2  (1 3 6) 2  (5 2 16) 8)	) = 'data3 / data2'  ifFalse: [self error: 'should have found it'].	(MethodFinder methodFor: #((0.0) 0.0  (1.5) 0.997495  (0.75) 0.681639)	) = 'data1 sin'   ifFalse: [self error: 'should have found it'].	(MethodFinder methodFor: #((7 5) 2   (4 5) 4   (10 5) 0)	) = 'data1 \\ data2'   ifFalse: [self error: 'should have found it'].	! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 4/24/1999 19:29'!argMap	^ argMap ! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 4/24/1999 19:29'!data	^ data ! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 4/24/1999 19:29'!makeAllMaps 	"Make a giant list of all permutations of the args.  To find the function, we will try these permutations of the input data.  receiver, args.	permutations of original args.	fewer than original args.	using an arg twice or more"	| ii sz |	mapList _ Array new: (sz _ argMap size factorial) * 2.	ii _ 1.	argMap permutationsDo: [:perm |		mapList at: ii put: perm copy.		mapList at: ii+sz put: perm allButLast.	"one less arg"		ii _ ii + 1].	argMap size > 4 ifTrue: [mapList _ mapList copyFrom: sz+1 to: sz*2].		"Only use receiver and 3 args max"	mapStage _ 1.	"about to be bumped"! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 4/24/1999 19:29'!mapData 	"Force the data through the map (permutation) to create the data to test."	thisData _ data collect: [:realData |					argMap collect: [:ind | realData at: ind]].		! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 4/24/1999 19:29'!permuteArgs 	"Run through ALL the permutations.  First one was as presented."	argMap size = 0 ifTrue: [^ false].	"no other way"	argMap size = 1 ifTrue: [			argMap _ #(1 1).	"one double of arg 1"			mapList _ #((1 1)).			mapStage _ 1.			self mapData.			^ true].	mapList ifNil: [self makeAllMaps].	mapStage _ mapStage + 1.	mapStage > mapList size ifTrue: [^ false].	argMap _ mapList at: mapStage.	self mapData.	^ true	! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 4/24/1999 19:29'!thisData	^ thisData ! !!MethodFinder methodsFor: 'search' stamp: 'tk 4/30/1999 15:32'!findMessage	"Control the search."	data do: [:alist | 		(alist isKindOf: SequenceableCollection) ifFalse: [			^ 'first and third items are not Arrays']].	Approved ifNil: [self initialize].	"Sets of allowed selectors"	self search.	^ selector 		ifNil: ['no single method does that function']		ifNotNil: [String streamContents: [:strm |			strm nextPutAll: 'data', argMap first printString.			selector keywords doWithIndex: [:key :ind |				strm nextPutAll: ' ',key.				(key last == $:) | (key first isLetter not)					ifTrue: [strm nextPutAll: ' data', (argMap at: ind+1) printString]]]			]! !!MethodFinder methodsFor: 'search' stamp: 'tk 4/16/1999 18:47'!search	| old |	old _ Preferences autoAccessors.	Preferences disable: #autoAccessors.	self simpleSearch.	selector ifNotNil: [		old ifTrue: [Preferences enable: #autoAccessors].		^ selector].	[self permuteArgs] whileTrue: [		self simpleSearch.		selector ifNotNil: [			old ifTrue: [Preferences enable: #autoAccessors].			^ selector]].	old ifTrue: [Preferences enable: #autoAccessors].	^ nil! !!MethodFinder methodsFor: 'search' stamp: 'tk 4/27/1999 18:16'!simpleSearch	"Run through first arg's class' selectors, looking for one that works."| class supers selectorList |selector _ nil.class _ thisData first first class.supers _ class withAllSuperclasses.supers do: [:cls |	selectorList _ cls selectorsWithArgs: (argMap size) - 1.	selectorList do: [:aSel |		((Approved includes: aSel) or: [AddAndRemove includes: aSel]) ifTrue: [			(self testPerfect: aSel) ifTrue: [				^ selector _ aSel]]]].^ nil! !!MethodFinder methodsFor: 'search' stamp: 'tk 4/30/1999 14:22'!testPerfect: aSelector	"Try this selector!! Return true if it answers every example perfectly.  Take the args in the order they are.  Do not permute them.  Survive errors.  later cache arg lists."| sz argList val rec activeSel perform |	"Transcript cr; show: aSelector.		debug"perform _ aSelector beginsWith: 'perform:'.sz _ argMap size.1 to: thisData size do: [:ii | "each example set of args"	argList _ (thisData at: ii) copyFrom: 2 to: sz.	perform		ifFalse: [activeSel _ aSelector]		ifTrue: [activeSel _ argList first.	"what will be performed"			((Approved includes: activeSel) or: [AddAndRemove includes: activeSel])				ifFalse: [^ false].	"not approved"			aSelector == #perform:withArguments: 				ifTrue: [activeSel numArgs = (argList at: 2) basicSize "avoid error" 							ifFalse: [^ false]]				ifFalse: [activeSel numArgs = (aSelector numArgs - 1) 							ifFalse: [^ false]]].	1 to: sz do: [:num | 		(Blocks includes: (Array with: activeSel with: num)) ifTrue: [			(argList at: num) class == BlockContext ifFalse: [^ false]]].	rec _ (AddAndRemove includes: activeSel) 			ifTrue: [(thisData at: ii) first class == Symbol ifTrue: [^ false].						"vulnerable to modification"				(thisData at: ii) first copyTwoLevel] 	"protect from damage"			ifFalse: [(thisData at: ii) first].	val _ [rec perform: aSelector withArguments: argList] 				ifError: [:aString :aReceiver | 							"self test3."							"self test2: (thisData at: ii)."							^ false].	"self test3."	"self test2: (thisData at: ii)."	((answers at: ii) closeTo: val) ifFalse: [^ false].	].^ true! !!Morph methodsFor: 'copying' stamp: 'tk 4/30/1999 15:59'!deepCopy	self error: 'Please use veryDeepCopy or fullCopy'.	^ self shallowCopy! !!Number methodsFor: 'comparing' stamp: 'tk 4/16/1999 18:26'!closeTo: num	"are these two numbers close?"	| ans |	num isFloat ifTrue: [^ num closeTo: self asFloat].	[ans _ self = num] ifError: [:aString :aReceiver | ^ false].	^ ans! !!Float methodsFor: 'comparing' stamp: 'tk 4/16/1999 18:28'!closeTo: num	"are these two numbers close?"	| fuzz ans |	num isNumber ifFalse: [		[ans _ self = num] ifError: [:aString :aReceiver | ^ false].		^ ans].	self = 0.0 ifTrue: [^ num abs < 0.0001].	num = 0.0 ifTrue: [^ self abs < 0.0001].	fuzz := (self abs max: num abs) * 0.0001.	^ (self - num) abs <= fuzz! !!Integer methodsFor: 'system primitives' stamp: 'tk 3/24/1999 20:26'!lastDigit	"Answer the last digit of the integer base 256.  LargePositiveInteger uses bytes of base two number, and each is a 'digit'."	^self digitAt: self digitLength! !!LargePositiveInteger methodsFor: 'system primitives' stamp: 'tk 3/24/1999 20:28'!digitAt: index 	"Primitive. Answer the value of an indexable field in the receiver.   LargePositiveInteger uses bytes of base two number, and each is a 'digit' base 256.  Fail if the argument (the index) is not an Integer or is out of bounds. Essential.  See Object documentation whatIsAPrimitive."	<primitive: 60>	self digitLength < index		ifTrue: [^0]		ifFalse: [^super at: index]! !!Object class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 15:46'!readCarefullyFrom: textOrString	"Create an object based on the contents of textOrString.  Return an error instead of putting up a SyntaxError window."	| object ok |	ok _ (textOrString isKindOf: Stream) or: [textOrString isKindOf: String].	(ok or: [textOrString isKindOf: Text]) ifFalse: [^ self error: 'expected String or Text'].	object _ Compiler evaluate: textOrString for: nil 				notifying: #error: "signal we want errors" logged: false.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!Object class methodsFor: 'instance creation' stamp: 'tk 4/18/1999 07:05'!readFrom: aStream	"Create an object based on the contents of aStream."	| object ok |	ok _ (aStream isKindOf: Stream) or: [aStream isKindOf: String].	(ok or: [aStream isKindOf: Text]) ifFalse: [^ self error: 'expected String or Text'].	object _ Compiler evaluate: aStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!Integer class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 14:18'!basicNew	self == Integer ifTrue: [		^ self error: 'Integer is an abstract class.  Make a concrete subclass.'].	^ super basicNew! !!Integer class methodsFor: 'instance creation' stamp: 'tk 4/18/1999 22:01'!new	self == Integer ifTrue: [		^ self error: 'Integer is an abstract class.  Make a concrete subclass.'].	^ super new! !!MethodFinder class methodsFor: 'as yet unclassified' stamp: 'tk 3/28/1999 19:04'!methodFor: dataAndAnswers	"Return an expression that computes these answers."	^ (self new) load: dataAndAnswers; findMessage! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 4/30/1999 15:53'!byExample	^ 'Type a fragment of a selector in the top pane.  Accept it.Or, in this pane, use examples to find a method in the system.  You supply inputs and answers and the system will find the method.  Each inner array is a list of inputs.  It contains the receiver and zero or more arguments.  Select the line of code and choose "print it".  	MethodFinder methodFor: #( (4 3) 7  (0 5) 5  (5 5) 10).This will discover (data1 + data2)For Booleans and any computed arguments, use brace notation.	MethodFinder methodFor: { {1. 3}. true.  {20. 10}. false}.This will discover the expression (data1 < data2)	MethodFinder methodFor: { {''29 Apr 1999'' asDate}. ''Thursday''.  		{''30 Apr 1999'' asDate}. ''Friday'' }.Will discover the expression (data1 weekday)Receiver and arguments do not have to be in the right order.  See MethodFinder.verify for more examples.'! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 3/29/1999 22:12'!byExample: newText	"Don't save it"	^ true! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 4/30/1999 14:33'!morphicWindow	"Create a Browser that lets you type part of a selector, shows a list of selectors, shows the classes of the one you chose, and spawns a full browser on it.  Answer the window	SelectorBrowser new open "	| window typeInView selectorListView classListView |	window _ (SystemWindow labelled: 'later') model: self.	selectorIndex _ classListIndex _ 0.	typeInView _ PluggableTextMorph on: self 		text: #contents accept: #contents:notifying:		readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	typeInView acceptOnCR: true.	window addMorph: typeInView frame: (0@0 corner: 0.5@0.14).	selectorListView _ PluggableListMorph on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #selectorMenu:		keystroke: #messageListKey:from:.	selectorListView menuTitleSelector: #selectorMenuTitle.	window addMorph: selectorListView frame: (0@0.14 corner: 0.5@0.6).	classListView _ PluggableListMorph on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: nil		keystroke: #arrowKey:from:.	classListView menuTitleSelector: #classListSelectorTitle.	window addMorph: classListView frame: (0.5@0 corner: 1@0.6).	window addMorph: ((PluggableTextMorph on: self text: #byExample 				accept: #byExample:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)					askBeforeDiscardingEdits: false)		frame: (0@0.6 corner: 1@1).	window setLabel: 'Selector Finder'.	^ window! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 3/29/1999 22:47'!openAsMorph	"Create a Browser that lets you type part of a selector, shows a list of selectors, shows the classes of the one you chose, and spwns a full browser on it.	SelectorBrowser new open   "	^ self morphicWindow openInWorldExtent: 450@350! !!SmallInteger methodsFor: 'system primitives' stamp: 'tk 3/24/1999 20:28'!digitAt: n 	"Answer the value of an indexable field in the receiver.  LargePositiveInteger uses bytes of base two number, and each is a 'digit' base 256.  Fail if the argument (the index) is not an Integer or is out of bounds."	n>4 ifTrue: [^ 0].	self < 0		ifTrue: 			[self = SmallInteger minVal ifTrue:				["Can't negate minVal -- treat specially"				^ #(0 0 0 64) at: n].			^ ((0-self) bitShift: (1-n)*8) bitAnd: 16rFF]		ifFalse: [^ (self bitShift: (1-n)*8) bitAnd: 16rFF]! !!SmallInteger class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 14:17'!basicNew	self error: 'SmallIntegers can only be created by performing arithmetic'! !!SmallInteger class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 14:18'!new	self basicNew	"generates an error"! !!SortedCollection methodsFor: 'accessing' stamp: 'tk 3/28/1999 22:55'!median	"Return the middle element, or as close as we can get."	^ self at: self size + 1 // 2! !!String methodsFor: 'converting' stamp: 'tk 3/28/1999 22:44'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	| listOfLines currentLast currentStart resultString putativeLast putativeLine crPosition |	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	listOfLines _ OrderedCollection new.	currentLast _ 0.	[currentLast < self size] whileTrue:		[currentStart _ currentLast + 1.		putativeLast _ (currentStart + aNumber - 1) min: self size.		putativeLine _ self copyFrom: currentStart to: putativeLast.		(crPosition _ putativeLine indexOf: Character cr) > 0 ifTrue:			[putativeLast _ currentStart + crPosition - 1.			putativeLine _ self copyFrom: currentStart to: putativeLast].		currentLast _ putativeLast == self size			ifTrue:				[putativeLast]			ifFalse:				[currentStart + putativeLine lastSpacePosition - 1].		currentLast <= currentStart ifTrue:			["line has NO spaces; baleout!!"			currentLast _ putativeLast].		listOfLines add: (self copyFrom: currentStart to: currentLast) withBlanksTrimmed].	listOfLines size > 0 ifFalse: [^ ''].	resultString _ listOfLines first.	2 to: listOfLines size do:		[:i | resultString _ resultString, String cr, (listOfLines at: i)].	^ resultString"#(5 7 20) collect:	[:i | 'Fred the bear went down to the brook to read his book in silence' withNoLineLongerThan: i]"! !!SyntaxError methodsFor: 'initialization' stamp: 'tk 4/19/1999 08:02'!setClass: aClass code: aString debugger: aDebugger doitFlag: flag	| types printables badChar |	class _ aClass.	debugger _ aDebugger.	selector _ aClass parserClass new parseSelector: aString.	types _ Scanner classPool at: #TypeTable.	"dictionary"	printables _ '!!@#$%&*-_=+<>{}?/\,¥£¢¤¦»¼ÐÑÒÔÓÕÉò¾òøùÀÇÈ`~`' asSet.	badChar _ aString detect: [:aChar | (types at: aChar value) == #xBinary and: [			(printables includes: aChar) not]] ifNone: [nil].	contents _ badChar 		ifNil: [aString]		ifNotNil: ['<<<This string contains a character (ascii value ', 			badChar value printString,			') that is not normally used in code>>> ', aString].	category ifNil: [category _ aClass organization categoryOfElement: selector].	category ifNil: [category _ ClassOrganizer default].	doitFlag _ flag! !!SyntaxError methodsFor: 'message list' stamp: 'tk 4/19/1999 08:08'!list	"Answer an array of one element made up of the class name, message category, and message selector in which the syntax error was found. This is the single item in the message list of a view/browser on the receiver."	selector ifNil: [^ Array with: (class name, '  ', category, '  ', '<none>')].	^ Array with: (class name, '  ', category, '  ', selector)! !MethodFinder removeSelector: #organizationNotInSuper:!MethodFinder removeSelector: #test!