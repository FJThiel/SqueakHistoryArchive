'From Squeak2.8alpha of 26 January 2000 [latest update: #2174] on 26 May 2000 at 12:02:45 pm'!"Change Set:		macSupportFilesDate:			26 May 2000Author:			John MaloneyMacintosh (and some generic) support code files for new pluginized VM.Includes new support for building Squeak VM to run as a browser plugin.See the readme file for additional details."!!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 5/26/2000 10:40'!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Tosh:Desktop Folder:Squeak VM Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode macArchiveBinaryFile asByteArray		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'platform.exports') contentsOfEntireFile =	InterpreterSupportCode squeakPlatformExportsFile		ifFalse: [self inform: 'File platform.exports differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqPlatformSpecific.h') contentsOfEntireFile =	InterpreterSupportCode squeakPlatSpecFile		ifFalse: [self inform: 'File sqPlatformSpecific.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqADPCMPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakADPCMCodecPrimsFile		ifFalse: [self inform: 'File sqADPCMPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqGSMCodecPlugin.c') contentsOfEntireFile =	InterpreterSupportCode squeakGSMCodecPluginFile		ifFalse: [self inform: 'File sqGSMCodecPlugin.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacAsyncFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode macAsyncFilePrimsFile		ifFalse: [self inform: 'File sqMacAsyncFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNSPlugin.c') contentsOfEntireFile =	InterpreterSupportCode macBrowserPluginFile		ifFalse: [self inform: 'File sqMacNSPlugin.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystickAndTablet.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickAndTabletFile		ifFalse: [self inform: 'File sqMacJoystickAndTablet.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacMinimal.c') contentsOfEntireFile =	InterpreterSupportCode macMinimal		ifFalse: [self inform: 'File sqMacMinimal.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSerialAndMIDIPort.c') contentsOfEntireFile =	InterpreterSupportCode macSerialAndMIDIPortFile		ifFalse: [self inform: 'File sqMacSerialAndMIDIPort.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqNamedPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakNamedPrimsFile		ifFalse: [self inform: 'File sqNamedPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqOldSoundPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakOldSoundPrimsFile		ifFalse: [self inform: 'File sqOldSoundPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqVirtualMachine.h') contentsOfEntireFile =	InterpreterSupportCode squeakVirtualMachineHeaderFile		ifFalse: [self inform: 'File sqVirtualMachine.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqVirtualMachine.c') contentsOfEntireFile =	InterpreterSupportCode squeakVirtualMachineFile		ifFalse: [self inform: 'File sqVirtualMachine.c differs from the version stored in this image.'].	dir _ dir directoryNamed: 'MacTCP'.	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 5/26/2000 09:11'!storeStuffitArchive: archiveData onFileNamed: fileName	"Store the given binary data as a file with the type and creator of a Stuff archive file. You will need to use a StuffIt unpacking utility such as StuffIt Expander to unpack the file."	| f |	f _ (FileStream newFileNamed: fileName) binary.	archiveData do: [:byte | f nextPut: byte].	f close.	FileDirectory default setMacFileNamed: fileName type: 'SITD' creator: 'SIT!!'.! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 5/26/2000 09:35'!writeMacSourceFiles	"Store into this image's folder the C sources files required to support the interpreter on the Macintosh. It also generates the code for the sound synthesis primitives. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate the interpreter code, use the method 'translate:doInlining:' in Interpreter class."	"InterpreterSupportCode writeMacSourceFiles"	self writeSupportFiles.	self storeString: self macAsyncFilePrimsFile	onFileNamed: 'sqMacAsyncFilePrims.c'.	self storeString: self macBrowserPluginFile	onFileNamed: 'sqMacNSPlugin.c'.	self storeString: self macDirectoryFile	onFileNamed: 'sqMacDirectory.c'.	self storeString: self macJoystickAndTabletFile  onFileNamed: 'sqMacJoystickAndTablet.c'.	self storeString: self macMinimal		onFileNamed: 'sqMacMinimal.c'.	self storeString: self macNetworkFile		onFileNamed: 'sqMacNetwork.c'.	self storeString: self macSerialAndMIDIPortFile	onFileNamed: 'sqMacSerialAndMIDIPort.c'.	self storeString: self macSoundFile		onFileNamed: 'sqMacSound.c'.	self storeString: self macWindowFile		onFileNamed: 'sqMacWindow.c'.	self storeString: self macTCPFile			onFileNamed: 'MacTCP.h'.	self storeString: self macAddressXlationFile		onFileNamed: 'AddressXlation.h'.	self storeString: self macDNRFile					onFileNamed: 'dnr.c'.	self storeStuffitArchive: self	 macArchiveBinaryFile		onFileNamed: 'projectArchive.sit'.! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 5/26/2000 10:41'!writeSupportFiles	"Store into this image's folder the C sources files required to support the interpreter on all platforms. This method also generates the code for the sound synthesis and other primitives translated from Smalltalk to C. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate that code, use the method 'translate:doInlining:' in Interpreter class."	"InterpreterSupportCode writeSupportFiles"	self storeString: self readmeFile			onFileNamed: 'readme'.	self storeString: self squeakHeaderFile	onFileNamed: 'sq.h'.	self storeString: self squeakConfigFile	onFileNamed: 'sqConfig.h'.	self storeString: self squeakPlatformExportsFile	onFileNamed: 'platform.exports'.	self storeString: self squeakPlatSpecFile	onFileNamed: 'sqPlatformSpecific.h'.	self storeString: self squeakVirtualMachineHeaderFile	onFileNamed: 'sqVirtualMachine.h'.	self storeString: self squeakVirtualMachineFile	onFileNamed: 'sqVirtualMachine.c'.	self storeString: self squeakNamedPrimsFile onFileNamed:'sqNamedPrims.c'.	self storeString: self squeakADPCMCodecPrimsFile	 onFileNamed: 'sqADPCMPrims.c'.	self storeString: self squeakFilePrimsFile	onFileNamed:  'sqFilePrims.c'.	self storeString: self squeakGSMCodecPluginFile	onFileNamed: 'sqGSMCodecPlugin.c'.	Smalltalk at: #AbstractSound ifPresent: [:abstractSound |		self storeString: abstractSound cCodeForSoundPrimitives													onFileNamed: 'sqSoundPrims.c'].	self storeString: self cCodeForMiscPrimitives		onFileNamed: 'sqMiscPrims.c'.	self storeString: self squeakOldSoundPrimsFile	onFileNamed: 'sqOldSoundPrims.c'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/26/2000 11:41'!macArchiveBinaryFile	"Answer the binary contents of a StuffIt archive file containing the CodeWarrier project files for the virtual machine. You will need to use a StuffIt unpacking utility such as StuffIt Expander to unpack the file. The result will be a folder containing the project files."	"To create the text for this method evaulate:		| in out |		in _ (FileStream oldFileNamed: 'projectArchive.sit') binary.		out _ WriteStream on: (String new: 100000).		out nextPutAll: '#('.		[in atEnd] whileFalse: [out nextPutAll: in next printString; space].		out skip: -1.		out nextPutAll: ')'.		in close.		ParagraphEditor clipboardTextPut: out contents asText	  and then do paste into this method."	^ #(83 73 84 33 0 7 0 0 96 218 114 76 97 117 2 114 0 0 0 22 6 253 13 0 23 68 79 76 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 114 115 114 99 0 0 0 0 0 0 0 0 92 107 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 243 0 0 0 0 255 255 255 255 114 115 114 99 82 83 69 68 1 0 180 207 51 128 181 83 210 11 0 0 1 188 0 0 0 0 0 0 1 109 0 0 0 0 2 53 0 0 0 0 0 0 0 0 119 85 17 0 8 28 220 238 16 196 213 0 249 239 203 63 53 255 174 249 143 205 223 56 127 207 184 39 243 231 142 27 27 119 85 156 63 110 112 190 167 227 138 231 59 37 223 164 124 129 124 59 230 189 39 95 225 188 187 230 189 54 111 147 188 35 242 28 150 231 177 60 9 121 118 245 190 158 39 201 123 132 247 69 111 45 239 142 185 159 240 182 200 125 104 238 55 115 247 207 125 77 238 216 220 3 114 93 148 187 82 174 109 114 189 144 107 131 92 59 231 188 38 87 243 156 219 230 156 158 179 114 206 227 114 92 155 179 99 14 153 227 205 28 13 114 92 26 251 118 142 93 99 175 202 209 51 118 155 28 27 196 214 142 189 33 230 197 216 61 99 206 140 237 22 179 105 140 138 201 23 115 142 103 66 76 154 39 45 102 67 207 198 158 219 209 205 158 157 209 97 158 205 80 71 79 28 242 162 155 225 2 180 3 164 160 120 40 4 143 57 43 90 175 175 193 118 13 27 110 215 96 51 207 44 195 22 41 163 141 107 214 28 60 120 176 47 195 145 75 192 83 34 49 146 201 232 80 220 150 100 80 28 72 39 67 169 192 131 226 125 181 82 11 127 96 100 137 5 224 217 136 68 163 233 145 20 34 35 156 213 28 82 35 108 98 22 102 110 153 69 201 192 152 112 230 150 78 74 30 160 34 51 227 155 141 79 110 19 73 167 153 243 47 206 121 93 161 59 74 52 119 20 170 175 175 57 212 181 60 120 32 15 108 173 148 222 202 121 93 193 211 96 164 209 214 59 218 167 96 148 209 20 71 187 222 2 13 13 13 77 121 80 108 117 103 105 110 46 112 114 111 106 32 67 32 67 111 100 101 116 0 0 0 0 0 0 0 0 0 0 10 185 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 22 0 0 14 201 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 181 84 10 29 0 0 41 201 0 0 7 218 0 0 9 133 0 0 2 225 239 206 51 129 0 0 0 0 0 0 74 219 13 192 213 101 47 91 153 39 187 189 114 79 238 166 157 120 182 217 168 163 199 87 118 132 95 103 148 80 114 251 216 90 107 207 105 114 42 83 78 191 179 149 119 236 18 79 13 207 60 143 173 19 182 218 177 232 241 65 183 22 97 101 30 249 205 142 236 147 236 103 145 237 17 74 158 39 217 44 194 8 63 201 38 123 64 54 35 191 9 37 251 24 161 132 109 147 108 37 155 29 97 185 237 40 79 242 156 236 39 155 13 54 219 18 70 120 140 48 194 99 120 224 171 43 57 205 6 121 110 105 209 204 35 188 99 70 216 38 183 117 179 77 126 147 223 100 147 205 240 100 3 227 79 207 207 50 0 6 0 115 87 0 204 193 191 105 93 68 61 250 169 135 24 168 111 197 224 54 151 122 12 255 111 251 54 45 112 170 7 181 211 210 188 134 117 73 89 90 235 245 186 157 177 120 52 8 2 162 123 60 222 122 119 211 146 74 6 53 214 129 236 209 78 44 63 21 219 86 181 206 132 236 192 171 0 183 134 103 45 114 170 191 217 250 100 77 229 26 203 178 77 91 95 40 43 194 204 180 234 136 218 181 192 9 118 252 219 240 159 179 116 199 159 45 117 127 0 251 106 219 178 77 84 27 179 60 87 223 88 183 48 171 246 112 225 49 53 182 116 213 210 228 66 128 44 206 45 139 127 230 12 89 18 119 32 204 89 24 176 116 57 64 245 111 89 193 92 172 16 192 66 117 92 74 58 155 28 223 199 179 38 45 133 144 29 147 252 107 165 86 249 172 150 90 76 208 235 157 74 71 248 92 253 196 134 14 37 33 135 221 33 73 81 100 229 60 133 217 239 42 117 46 44 32 32 144 9 51 155 241 116 25 115 56 4 100 129 61 107 24 16 53 164 136 221 35 249 197 186 6 17 45 66 116 47 112 23 23 59 191 59 128 226 210 218 76 59 232 231 101 108 51 203 21 30 60 137 131 173 63 212 197 131 97 59 133 228 132 44 180 50 53 157 86 85 70 65 169 25 218 145 98 203 22 128 69 42 125 186 130 185 22 79 52 34 249 163 195 76 205 48 31 172 236 71 66 170 239 124 42 56 61 205 65 28 192 88 175 80 39 172 51 61 11 249 0 229 221 192 126 158 141 117 211 168 143 63 207 213 57 123 50 57 120 107 48 236 119 43 226 151 129 15 243 43 79 60 13 190 91 127 167 229 0 186 1 124 174 212 47 79 224 255 176 43 229 74 245 238 159 179 18 213 206 135 189 136 188 129 184 162 203 1 171 117 117 62 245 18 248 110 171 134 149 111 173 134 212 107 187 33 245 72 187 43 245 164 149 215 164 54 6 53 38 26 63 209 238 234 36 60 87 231 55 94 131 207 254 226 139 3 92 48 147 122 244 91 186 196 105 205 83 240 134 222 19 196 175 191 209 59 183 207 112 117 190 128 213 58 63 152 188 10 246 226 255 36 159 71 222 0 223 162 215 241 252 61 206 101 23 231 252 38 108 225 74 79 70 84 100 140 221 36 228 151 161 177 160 175 52 36 99 177 104 60 81 70 125 237 2 22 60 184 27 28 121 187 96 210 51 243 51 205 87 162 41 130 168 44 120 104 33 56 150 189 142 255 189 109 234 159 92 152 191 133 172 0 28 55 149 96 238 24 254 237 48 185 179 17 241 187 103 131 217 140 121 241 29 124 228 119 200 171 229 75 18 172 248 167 93 138 63 30 128 169 21 216 213 55 149 112 71 9 30 198 62 64 125 56 126 14 226 147 30 5 25 63 152 245 230 6 215 19 223 73 96 6 155 128 248 28 126 30 28 69 219 88 133 205 139 185 125 200 111 51 239 243 73 207 60 164 225 163 30 132 239 152 25 211 25 20 192 76 114 10 86 15 194 244 50 143 156 136 71 239 151 227 107 21 177 33 33 69 90 164 120 139 88 27 104 142 75 241 142 50 79 67 173 232 46 67 164 151 247 91 225 241 236 67 191 222 136 232 86 237 76 205 49 31 43 95 121 91 221 89 248 109 45 135 37 143 7 99 136 86 168 238 252 244 3 131 120 251 75 6 240 44 118 172 169 86 119 126 156 20 197 154 3 187 152 247 120 55 253 179 187 252 171 129 221 177 91 221 57 245 11 144 31 168 85 247 180 111 166 51 187 167 32 136 152 219 213 30 236 22 196 65 84 47 204 93 254 67 152 186 99 179 218 179 97 181 218 179 49 133 245 221 232 16 190 227 93 152 249 18 241 226 202 91 17 137 254 132 118 175 214 12 142 95 129 133 38 12 125 192 168 13 68 214 202 241 51 238 60 134 0 83 122 216 203 123 246 227 223 190 1 132 42 117 223 49 62 59 152 95 218 179 16 132 3 243 97 90 185 215 91 123 99 28 34 51 44 143 197 66 198 0 60 60 158 218 197 163 56 121 104 4 226 146 48 185 35 73 127 30 195 227 173 173 50 8 224 209 228 70 19 52 2 208 181 190 161 126 144 224 135 60 26 43 87 52 154 156 205 109 254 222 222 94 96 61 79 240 194 3 95 230 46 229 122 52 136 254 109 170 176 45 150 66 161 104 52 34 86 203 33 110 174 31 41 21 224 192 166 237 208 53 175 20 182 150 237 166 18 226 33 56 253 23 249 218 60 77 218 100 59 212 29 26 15 179 211 95 92 108 8 192 195 228 244 95 20 228 239 60 210 51 197 13 93 99 195 68 174 242 144 219 47 10 242 65 104 253 218 246 223 126 181 247 241 24 81 99 34 242 240 74 138 95 10 93 16 86 211 53 38 13 94 243 252 147 135 127 88 217 81 93 105 8 37 30 22 226 241 190 19 93 225 33 56 207 206 81 253 97 170 151 31 184 220 175 202 69 159 182 160 12 229 74 152 251 52 175 127 215 167 87 184 235 198 230 24 59 129 84 141 76 50 45 81 127 242 127 22 196 231 143 184 18 31 25 26 198 121 40 109 161 230 81 156 60 111 229 37 85 145 71 34 105 16 192 131 194 236 196 46 249 143 174 94 234 69 109 34 191 179 244 110 227 150 137 28 165 63 143 113 109 34 31 226 97 24 48 145 215 45 174 17 199 244 240 120 155 70 245 48 250 152 236 223 83 245 218 100 63 194 227 234 100 63 198 99 124 178 31 211 117 124 178 31 229 97 188 48 217 15 234 241 175 201 126 72 216 15 39 251 81 30 227 147 253 32 141 235 147 253 8 15 227 128 201 222 236 84 228 214 247 125 26 160 235 150 19 184 21 49 31 22 207 70 127 238 30 240 233 42 238 211 198 31 19 249 123 141 127 109 34 191 224 176 134 1 19 121 83 32 114 199 237 98 123 233 157 255 158 200 173 255 152 168 144 232 69 231 184 50 81 141 240 184 58 9 141 233 49 62 9 141 242 184 226 244 131 60 174 59 253 8 15 147 115 196 21 115 144 7 26 195 216 232 126 195 129 50 60 66 129 97 91 236 191 249 184 208 105 196 35 218 140 139 76 23 120 212 53 7 71 121 228 122 134 214 69 46 59 98 142 199 227 174 54 4 104 138 191 221 85 228 160 90 188 227 47 241 64 39 11 13 207 172 147 136 7 173 38 138 238 104 56 22 8 157 86 63 237 28 216 241 242 26 67 0 93 111 56 71 102 166 31 185 27 184 194 99 212 161 71 251 44 227 172 137 225 54 187 18 22 220 246 227 9 97 253 7 123 143 89 193 104 91 36 44 133 135 118 83 47 5 50 100 116 16 112 195 208 224 37 168 17 140 95 122 160 47 166 208 222 108 95 95 244 103 104 23 149 58 69 203 230 65 54 102 248 79 175 239 1 220 108 29 219 0 190 20 139 48 180 219 126 150 90 113 102 179 246 122 16 159 190 228 185 77 99 228 121 6 180 20 114 211 226 163 156 213 178 212 34 199 149 241 145 195 6 38 190 104 172 227 179 87 251 87 210 79 247 149 145 79 220 119 159 146 144 226 252 130 209 184 33 168 141 29 96 18 116 91 100 233 55 3 40 200 43 51 102 185 147 191 50 96 0 32 185 241 131 226 108 10 234 72 239 15 156 142 134 104 50 210 226 142 182 200 126 111 60 16 86 68 58 5 18 129 245 127 121 240 192 144 36 118 160 203 179 28 79 135 55 148 108 13 68 34 90 31 156 6 169 42 111 104 252 235 141 178 17 65 227 190 51 5 13 190 182 64 222 37 244 189 122 49 22 130 13 177 112 55 94 255 12 95 194 49 207 93 87 81 57 79 156 87 81 222 88 142 71 239 18 119 227 60 163 149 22 176 233 143 176 232 49 240 174 76 118 81 135 163 224 56 150 20 178 159 129 16 91 206 111 25 167 197 226 120 165 88 4 115 27 26 235 103 33 226 179 253 248 185 229 252 138 142 79 77 247 254 24 232 213 134 60 202 221 243 32 208 61 205 20 202 213 60 6 180 19 72 239 22 64 242 102 248 12 30 183 81 110 98 35 180 226 145 94 148 128 153 115 0 185 178 26 202 101 31 129 207 97 238 235 148 123 184 23 232 165 129 23 41 39 253 17 158 230 115 58 70 112 61 124 147 187 27 70 235 83 240 28 230 248 171 22 171 247 195 15 48 215 78 185 155 23 194 79 48 247 85 202 21 174 129 125 120 17 247 60 229 86 30 129 94 148 21 121 225 142 197 114 248 61 230 56 215 146 90 56 10 48 125 50 229 218 190 66 157 49 29 95 143 192 186 109 108 18 230 248 189 147 47 204 10 49 199 119 28 239 58 194 240 1 134 25 92 99 223 215 216 39 49 87 79 185 200 42 134 187 130 51 248 244 80 180 139 121 0 68 254 154 202 199 138 153 15 115 216 105 168 253 139 12 47 194 69 126 85 251 137 61 12 119 105 102 58 41 55 253 32 123 24 145 248 253 180 179 132 61 134 79 83 240 222 154 243 10 67 29 103 149 242 166 219 69 175 106 204 225 24 31 77 81 78 224 239 46 228 123 241 173 31 217 159 16 177 111 149 64 52 82 224 145 90 3 126 209 45 197 78 93 29 227 213 79 186 80 187 73 159 148 41 208 57 228 241 245 130 62 196 9 180 128 66 115 227 93 114 196 154 89 70 225 101 58 98 190 190 82 149 134 76 231 155 164 120 36 16 105 85 44 149 45 129 68 52 110 174 138 70 18 121 105 165 42 219 19 113 73 201 119 39 149 68 52 44 222 45 119 220 31 141 183 40 182 114 191 95 70 189 188 82 162 77 177 52 74 241 86 57 97 91 156 12 132 90 116 192 220 229 110 124 98 68 78 36 99 19 104 87 85 23 198 78 185 138 128 130 82 203 225 102 148 192 154 89 100 229 56 105 109 181 21 140 180 80 122 186 79 39 119 149 7 193 38 240 123 49 157 24 229 78 18 203 188 89 145 77 41 92 8 226 120 58 65 155 182 26 141 250 69 228 144 13 183 178 250 184 254 31 0 0 0 10 192 248 174 211 50 155 216 17 26 121 78 9 243 34 140 28 35 148 80 242 43 97 228 57 97 132 146 1 35 108 37 183 18 182 18 118 158 71 14 207 60 9 37 140 12 216 73 240 73 241 133 151 48 124 30 61 188 213 145 149 29 121 38 57 118 146 1 35 136 96 100 68 201 152 226 41 57 70 152 145 103 100 198 200 132 145 9 35 83 70 38 140 80 50 98 132 17 74 40 25 51 114 236 200 81 224 6 69 216 121 70 6 148 28 91 59 66 47 60 153 81 194 8 35 72 97 248 3 182 176 186 222 112 93 27 0 20 172 35 0 170 131 245 5 246 52 172 29 88 45 136 193 117 172 227 64 31 141 113 198 214 127 59 168 1 130 175 115 92 31 125 33 175 217 223 29 79 140 124 250 126 204 18 60 86 255 250 19 188 55 106 99 226 157 251 132 249 195 204 26 248 106 24 127 200 39 97 26 46 253 224 93 149 188 225 142 247 188 175 124 43 55 223 62 132 103 177 7 215 172 3 127 42 226 110 198 110 61 221 135 93 136 99 239 127 72 192 91 124 215 199 103 132 59 96 17 0 164 74 13 205 174 47 18 39 107 180 195 229 95 103 232 44 248 178 249 28 93 244 72 157 144 58 37 117 23 234 117 212 73 169 211 82 247 73 221 47 117 183 212 189 82 103 94 79 116 78 162 30 220 158 206 57 168 7 182 11 59 83 168 11 112 7 166 226 159 177 211 74 174 167 52 91 28 203 103 53 45 159 45 146 202 105 114 2 7 39 78 50 204 201 76 221 241 73 205 60 179 131 147 116 238 36 125 215 241 77 175 170 27 230 121 36 77 110 219 137 90 210 125 235 183 9 254 177 253 118 232 36 204 91 73 113 217 29 78 248 141 201 233 51 39 67 135 9 229 184 143 40 209 224 222 135 156 178 70 253 122 133 117 32 150 227 51 18 205 102 176 247 178 172 172 149 180 98 129 117 32 46 188 70 115 24 236 109 4 33 117 35 128 14 65 141 38 165 149 80 167 152 143 104 239 189 218 82 55 149 181 242 237 251 101 214 129 132 200 53 81 67 175 217 195 85 123 224 149 237 64 78 229 29 85 80 211 186 67 201 252 146 238 213 232 49 187 69 77 10 170 74 253 5 226 158 152 229 123 51 164 174 67 151 160 38 41 121 108 206 251 109 108 139 154 146 185 58 117 219 254 147 107 183 160 118 173 232 243 54 161 109 179 45 175 233 48 33 127 193 38 149 139 132 122 228 52 44 144 149 211 88 143 18 234 149 9 173 26 150 238 157 112 91 94 251 154 9 121 196 89 188 72 168 95 206 16 91 91 231 51 244 147 58 32 54 126 134 46 207 17 207 175 235 118 73 55 44 226 28 57 96 87 144 216 67 252 30 202 8 106 138 46 231 93 167 74 126 101 196 110 41 65 229 87 213 160 160 14 209 101 205 214 253 170 235 213 102 151 76 131 84 137 113 192 103 151 151 244 202 110 176 33 177 41 163 251 97 187 28 191 130 251 213 178 43 172 35 143 7 188 194 33 166 205 154 139 251 251 77 16 190 81 128 189 97 105 168 163 171 31 177 127 153 221 166 90 145 250 124 198 71 87 210 120 100 205 224 81 51 169 21 108 202 222 252 3 0 0 13 13 16 77 121 80 108 117 103 105 110 54 56 75 46 112 114 111 106 67 111 100 101 116 0 0 0 0 0 0 0 0 0 0 87 202 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 243 0 0 26 227 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 181 84 10 26 0 0 35 21 0 0 7 90 0 0 8 201 0 0 2 225 202 154 69 206 0 0 0 0 0 0 120 254 13 192 213 229 49 95 78 191 219 43 247 236 162 155 30 158 109 150 47 215 227 43 59 114 60 194 99 132 146 227 222 90 107 207 105 166 157 156 122 236 228 148 119 236 54 195 51 124 50 207 99 235 64 142 191 142 69 175 62 215 34 172 207 35 155 108 118 228 57 225 132 27 217 30 97 228 217 62 194 159 48 194 58 178 9 191 36 155 145 223 132 146 125 116 51 194 246 196 24 217 199 8 143 229 38 172 36 207 201 126 178 61 175 78 194 8 143 17 70 88 135 7 190 186 146 123 94 132 109 22 221 236 200 102 121 182 7 94 132 145 9 35 156 12 57 225 121 120 178 129 87 128 3 2 0 26 116 120 224 21 128 1 64 205 118 128 106 60 29 183 167 140 35 55 221 197 192 120 75 133 235 253 198 81 60 143 247 108 158 239 51 94 55 111 29 101 225 219 179 138 180 46 20 10 248 84 45 29 7 1 217 131 193 80 87 160 123 105 51 131 182 146 81 244 200 32 62 31 171 29 171 122 103 130 59 118 0 96 94 114 214 98 159 241 251 39 31 109 107 94 235 90 190 249 201 167 27 106 16 153 209 154 50 182 205 247 65 5 158 30 60 39 117 236 122 219 213 249 6 84 172 246 44 223 76 111 85 215 83 93 145 206 5 69 237 135 171 142 26 106 199 170 142 236 2 128 34 174 173 136 255 156 5 177 100 238 104 57 139 176 160 99 5 64 235 31 88 229 28 124 33 128 139 222 113 43 233 238 240 62 143 119 211 90 42 193 173 74 242 58 169 87 57 237 165 89 165 214 123 159 62 144 60 243 254 170 240 128 158 81 146 129 132 164 235 138 254 158 132 107 255 230 212 153 114 129 128 68 14 68 182 224 237 3 206 243 37 160 10 204 172 109 64 181 145 35 21 65 73 22 59 195 34 182 8 49 48 63 80 87 231 123 110 148 197 111 198 204 188 88 247 229 108 11 43 22 238 60 201 131 209 63 151 226 241 242 140 49 249 160 8 91 153 145 135 13 131 81 17 84 109 94 169 182 110 5 88 108 208 207 114 176 216 21 76 167 36 57 125 94 169 19 106 161 132 253 80 200 141 220 199 138 203 51 59 136 23 24 123 68 232 21 238 119 188 0 229 0 141 67 192 126 229 198 119 51 40 199 247 112 119 78 223 28 94 30 13 134 121 47 65 254 6 232 65 124 229 59 143 67 207 188 63 154 24 192 16 64 143 63 247 219 119 240 60 236 207 249 115 7 247 207 94 137 110 151 195 62 100 222 72 90 177 203 1 107 247 15 62 246 115 232 185 190 21 86 190 181 26 114 47 239 133 220 189 253 254 220 163 37 252 77 110 83 220 84 98 234 19 43 252 131 196 231 31 252 214 203 240 149 151 190 62 170 5 145 220 253 79 88 22 231 61 207 193 171 86 38 72 223 137 160 15 62 83 237 31 124 26 95 91 250 96 202 42 216 135 231 73 61 247 190 10 61 139 95 193 251 247 184 150 61 92 243 155 176 149 59 61 5 89 81 49 166 73 40 111 192 198 130 125 37 156 85 213 180 150 105 160 92 251 129 197 95 223 11 222 178 61 48 121 123 109 33 124 245 166 35 200 202 226 135 22 128 119 249 43 120 238 235 51 254 234 71 252 58 106 5 224 189 186 30 177 163 120 86 192 148 193 8 242 15 93 11 78 39 226 226 187 252 168 239 80 200 196 235 51 172 238 103 219 116 89 139 193 180 38 76 245 213 245 188 163 196 15 99 14 208 31 206 63 9 249 201 143 202 66 63 152 245 230 70 255 67 207 102 16 193 16 144 158 195 59 193 91 179 131 53 121 66 136 189 136 250 182 240 156 79 222 126 151 201 143 126 16 191 119 166 106 41 168 132 153 212 41 88 23 8 159 111 8 42 25 45 125 135 162 173 211 197 112 70 74 69 37 45 42 182 199 214 104 146 54 208 16 12 183 139 129 6 100 250 229 254 18 120 208 125 232 119 155 144 189 196 188 83 56 106 241 229 111 142 27 195 85 223 53 49 124 242 96 92 69 182 42 99 120 209 134 113 190 253 245 163 124 174 10 124 211 106 12 127 145 28 197 55 175 237 97 161 99 67 116 186 183 201 171 129 221 176 215 24 158 118 31 148 199 218 141 95 247 111 161 59 187 165 50 142 156 207 24 187 49 45 200 131 172 33 152 179 226 7 48 109 215 22 99 247 198 213 198 238 77 57 124 63 132 29 162 231 216 54 68 190 73 186 184 243 37 200 68 39 177 221 102 134 161 172 22 92 52 97 96 35 184 113 225 50 180 62 181 78 209 242 89 19 221 112 252 104 107 10 132 115 12 255 173 202 198 80 168 29 170 135 119 186 31 123 73 4 225 181 90 184 238 23 212 9 205 154 247 112 232 44 49 242 241 30 232 246 212 62 68 64 163 170 38 236 1 116 4 131 237 75 192 183 166 79 254 135 142 50 108 4 226 210 36 117 71 178 126 76 199 140 10 186 7 67 237 45 54 1 58 186 3 77 246 0 190 118 46 105 19 47 249 17 12 117 79 248 209 21 238 10 216 3 248 17 105 190 53 226 184 232 135 103 137 148 72 164 211 41 177 85 73 228 155 244 41 63 72 135 224 147 47 232 8 118 155 19 242 136 171 227 58 156 62 185 174 206 22 64 135 195 39 203 182 1 58 84 123 0 29 232 171 170 218 4 232 80 250 207 235 152 200 125 33 175 125 159 248 65 134 152 126 168 114 223 199 58 104 120 36 29 46 210 129 44 159 233 16 124 218 251 58 28 93 202 134 124 127 61 157 143 19 57 211 149 222 79 115 22 77 203 89 248 84 7 1 154 174 201 246 0 58 244 190 196 26 184 152 179 178 80 115 203 196 252 161 103 178 54 1 58 168 156 62 76 201 199 190 18 137 53 1 211 71 184 79 38 224 31 47 178 11 152 128 237 0 116 92 153 128 209 250 247 18 118 101 2 62 167 131 79 192 118 0 190 154 147 171 29 128 14 187 134 201 53 159 142 207 38 215 11 58 46 79 174 151 116 124 56 185 94 242 245 195 73 113 66 135 253 194 228 58 238 199 71 147 235 184 142 143 38 215 11 58 254 61 185 54 234 255 156 92 5 159 254 190 14 23 218 48 161 227 214 64 39 206 13 23 252 168 32 146 145 25 207 244 246 148 14 115 2 254 95 238 11 19 176 29 128 142 43 19 240 217 121 232 202 4 124 86 7 149 61 192 4 76 177 198 205 9 14 8 235 255 181 67 82 20 79 247 165 146 82 242 220 158 207 197 66 133 140 46 2 110 107 216 188 20 5 193 254 37 3 35 53 21 138 112 13 8 251 144 181 123 196 59 18 111 70 180 215 99 190 36 180 12 104 39 200 2 249 101 55 190 112 150 6 7 66 137 108 111 44 133 31 140 150 197 146 122 225 75 223 7 213 210 24 142 240 14 111 27 80 139 177 70 192 51 91 91 133 30 80 168 133 80 156 127 128 159 165 90 21 41 170 104 186 175 239 63 130 61 224 224 193 225 221 21 207 3 180 161 119 90 235 164 124 78 82 114 72 195 156 216 198 116 159 203 245 85 61 35 105 124 169 199 190 161 104 91 206 11 14 193 106 139 44 191 127 73 69 189 178 208 44 135 249 198 166 13 136 227 108 42 250 56 214 203 168 202 195 233 108 42 26 72 71 21 179 151 137 116 139 101 98 235 255 190 60 106 75 82 187 176 203 179 83 57 56 69 98 63 48 219 92 14 238 187 83 208 248 230 42 245 46 97 100 131 248 82 9 30 228 194 61 67 235 103 251 82 222 185 129 206 166 230 185 226 220 166 198 72 35 94 67 75 3 145 185 118 43 17 240 88 11 237 86 141 238 232 187 140 183 43 43 143 225 147 42 246 2 8 234 10 190 220 49 67 213 148 181 80 3 115 194 145 174 89 200 248 157 19 252 197 141 64 223 214 248 212 116 219 143 128 54 96 203 8 187 229 78 160 239 52 83 9 107 123 0 218 241 74 59 160 144 157 14 95 198 235 14 194 174 138 64 47 94 105 59 23 102 206 6 212 202 218 8 115 255 25 190 134 216 35 132 221 125 16 104 107 243 167 132 73 127 129 199 249 156 142 21 95 15 223 230 221 141 82 125 28 158 66 140 127 163 11 47 130 239 35 214 79 88 77 19 252 4 177 135 9 115 26 240 34 126 136 219 73 216 148 39 224 32 192 231 184 142 210 52 252 9 49 190 149 91 245 5 56 130 150 173 226 62 69 41 25 83 185 142 184 159 77 70 236 62 194 214 30 96 85 136 113 111 22 56 24 46 179 78 227 83 194 205 125 236 75 136 161 63 232 217 243 172 5 49 174 85 125 131 5 1 166 127 131 176 27 58 89 15 98 152 52 212 81 196 112 59 122 58 238 191 2 220 116 15 203 98 204 54 112 111 158 101 119 3 92 195 191 191 207 158 195 30 64 87 186 184 14 47 67 31 171 120 134 96 15 109 40 87 115 142 107 114 132 9 124 135 181 60 132 255 155 160 200 25 17 115 171 199 210 169 202 160 212 27 147 197 128 164 138 252 31 2 196 64 58 169 198 18 138 134 43 60 249 135 230 10 207 228 194 3 75 67 89 119 44 213 133 107 246 22 99 105 255 194 27 17 140 42 55 43 169 18 194 76 94 254 204 98 44 15 73 186 44 37 70 40 243 120 183 164 165 98 169 94 221 213 28 141 101 210 154 179 37 157 202 148 229 157 106 238 207 104 146 94 30 200 234 153 116 82 92 166 12 220 145 214 162 186 167 81 150 21 244 43 36 101 250 116 87 68 210 122 149 140 103 73 54 150 136 90 132 197 43 2 184 174 173 100 178 106 41 109 226 90 198 84 16 214 20 211 209 106 37 185 6 45 40 41 172 233 114 158 188 183 230 130 64 222 40 11 30 241 41 208 18 68 178 82 254 47 3 150 48 194 78 10 43 108 63 185 9 194 143 207 156 207 18 232 49 63 250 163 127 41 37 225 161 29 184 188 214 255 3 0 0 10 192 171 244 181 204 102 17 26 97 132 70 152 71 142 145 99 100 101 146 95 185 228 57 97 100 37 3 70 216 74 110 37 108 37 236 60 37 135 103 231 17 154 100 192 78 130 207 44 1 8 195 231 209 195 91 29 89 217 145 103 146 99 231 17 132 48 130 0 70 6 212 200 49 194 204 78 66 9 35 207 200 132 145 9 35 79 9 10 40 25 49 66 179 39 83 70 142 145 167 192 13 214 35 116 96 145 167 228 232 128 208 200 74 102 148 48 50 97 4 25 12 160 3 234 176 186 222 116 93 27 0 2 248 191 8 16 252 14 160 134 177 166 227 191 17 255 113 236 188 6 10 68 129 62 234 231 140 197 222 117 212 0 229 31 163 92 239 63 133 255 163 176 162 204 191 143 110 109 129 242 53 170 204 175 230 89 235 106 252 132 247 215 223 27 181 52 240 193 125 2 202 102 20 51 43 97 87 15 126 144 12 193 16 156 223 230 93 150 188 158 198 143 188 30 248 57 82 237 125 8 207 148 7 87 120 54 213 167 34 238 134 114 243 233 22 108 66 3 226 190 64 19 172 96 95 59 159 17 238 128 69 0 16 214 74 186 93 156 32 78 204 60 8 170 250 154 42 206 202 27 11 207 209 69 171 212 65 169 195 82 55 163 158 67 29 146 58 34 117 187 212 29 82 183 72 221 38 117 215 235 129 38 54 167 221 75 67 9 7 117 231 82 106 125 16 117 10 110 195 96 195 103 172 212 146 235 213 134 211 253 201 88 50 165 93 143 15 245 167 12 47 250 63 249 47 158 189 26 75 147 204 110 114 21 238 145 147 110 237 190 112 113 175 232 248 164 96 253 114 176 51 181 167 78 46 104 134 159 71 186 12 229 48 17 96 51 249 219 73 228 142 227 91 94 206 48 173 195 48 228 99 251 109 59 235 4 119 86 159 141 242 183 23 239 2 179 154 158 78 177 10 40 9 110 186 62 7 229 141 183 150 164 98 5 26 4 181 158 121 121 99 121 173 66 93 94 131 70 65 173 231 91 190 251 41 17 152 165 126 49 195 42 184 125 56 181 190 173 94 45 170 11 129 217 145 91 99 35 172 2 65 49 13 193 2 38 20 219 91 144 123 185 226 230 226 84 94 81 5 53 98 56 148 140 79 26 94 129 30 176 107 212 144 160 170 212 207 18 247 216 44 223 118 21 234 28 52 11 106 136 146 199 214 184 127 132 173 81 195 50 87 167 104 219 127 114 109 17 212 230 105 99 220 38 244 200 108 205 107 164 146 144 159 181 73 230 44 161 86 57 13 89 50 125 18 235 126 66 109 50 161 25 51 111 120 199 220 154 215 246 106 66 30 113 38 206 18 234 144 51 196 23 221 233 12 237 80 59 197 158 238 162 83 163 196 243 139 134 173 25 102 158 56 251 14 216 237 34 246 16 191 98 186 4 53 76 167 146 174 147 35 135 25 177 11 72 80 249 45 212 45 168 231 232 148 110 27 126 206 245 10 195 147 150 73 114 196 220 229 179 123 73 122 101 151 147 56 3 240 10 6 69 31 182 38 240 118 173 60 236 9 0 235 97 190 212 190 210 24 214 47 177 219 80 79 83 159 79 107 223 204 75 60 77 66 120 84 40 122 202 166 172 231 31 0 0 13 13 14 83 113 117 101 97 107 54 56 75 46 112 114 111 106 110 106 67 111 100 101 116 0 0 0 0 0 0 0 0 0 0 226 253 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 14 201 0 0 48 145 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 90 110 181 84 10 44 0 0 40 235 0 0 55 130 0 0 8 197 0 0 12 121 99 76 84 97 0 0 0 0 0 0 135 173 13 192 248 163 215 122 76 217 202 233 119 132 110 61 66 55 189 196 111 163 60 122 132 83 222 202 221 231 17 182 41 167 228 185 235 177 149 121 121 157 120 66 37 244 57 189 228 177 239 240 212 147 221 42 19 159 215 198 127 236 172 200 38 212 202 219 39 25 240 8 37 207 201 109 61 247 73 216 38 155 145 77 216 109 178 201 62 70 54 185 125 100 19 70 56 217 132 109 9 37 148 176 205 8 35 156 48 194 179 243 50 51 70 54 225 228 57 225 121 29 217 140 28 143 236 51 9 95 129 175 174 110 211 172 147 108 233 150 22 61 249 218 102 132 235 17 182 201 241 147 240 200 115 114 251 200 38 155 225 201 6 232 4 2 208 203 3 48 0 14 0 110 124 26 160 26 255 5 75 5 107 151 46 196 101 41 102 10 9 89 210 4 43 46 89 130 169 39 100 93 147 5 89 53 139 59 62 151 146 165 190 213 245 27 3 73 67 223 177 145 199 234 162 24 105 15 119 183 52 114 176 161 122 18 125 25 79 191 190 190 189 245 46 13 160 242 44 178 30 149 133 94 85 138 246 9 122 202 82 21 36 72 148 77 155 179 21 87 76 1 127 86 92 22 98 242 54 41 165 90 184 55 251 44 61 41 36 13 69 179 100 35 208 210 201 14 159 59 36 68 37 77 211 45 161 23 217 232 59 229 152 160 111 219 230 144 176 235 244 202 81 41 101 202 130 98 17 61 20 132 7 15 238 170 89 35 252 99 121 128 199 66 5 136 12 225 238 114 205 153 197 35 11 159 11 0 139 236 218 64 138 148 138 82 84 104 235 16 86 215 247 9 225 91 194 117 117 129 239 79 86 9 210 166 208 217 56 251 59 185 33 174 136 255 252 185 58 1 88 236 32 11 58 251 207 87 10 192 34 14 50 153 44 156 201 112 180 8 90 105 111 105 237 223 15 176 38 67 159 163 96 145 71 212 53 41 170 207 48 45 132 90 240 113 143 242 233 177 253 249 197 232 145 61 1 148 33 152 228 31 228 191 82 240 50 148 0 132 142 3 247 184 23 207 149 83 31 15 48 117 46 236 10 202 88 107 112 216 239 62 224 184 6 232 65 124 203 107 15 67 207 77 207 219 24 192 113 128 158 96 250 151 175 225 255 119 193 116 48 253 171 167 110 220 130 106 151 192 19 88 121 15 113 237 34 10 173 193 193 175 157 130 158 79 54 195 150 63 222 3 233 103 79 67 122 95 127 48 125 192 199 206 164 247 238 176 153 216 252 132 210 224 32 213 11 14 126 245 89 216 252 139 251 39 185 32 146 254 210 97 71 226 172 230 105 120 206 233 9 226 55 209 232 131 71 87 6 7 191 139 167 29 126 176 108 43 60 129 255 115 124 246 61 7 61 107 206 224 254 7 140 203 9 198 249 44 236 103 74 47 195 170 200 152 251 13 240 149 13 162 108 25 250 46 217 232 51 133 14 75 210 98 146 17 19 90 149 94 67 50 118 55 136 29 173 66 184 1 192 59 124 196 7 195 222 151 126 189 23 217 248 236 125 45 66 181 120 242 240 171 153 145 138 239 217 24 30 25 174 161 106 21 153 145 59 238 157 170 119 228 230 201 122 7 211 120 166 57 51 114 155 69 210 121 135 31 57 225 173 184 111 29 251 127 243 230 33 224 110 61 157 25 89 254 69 40 81 90 51 63 237 31 162 189 183 242 212 11 88 243 104 102 52 147 161 58 88 181 2 62 209 245 35 88 126 108 40 51 186 231 158 204 232 94 226 116 28 187 163 231 149 131 136 124 153 120 177 230 241 121 43 241 111 87 187 139 57 202 50 224 75 26 208 92 209 91 59 82 201 164 110 88 13 247 129 119 229 250 135 24 123 170 56 124 228 38 24 116 122 224 192 187 61 112 224 201 85 239 245 64 228 232 133 30 24 56 204 254 211 61 240 99 82 198 233 129 1 116 143 127 247 0 154 233 51 224 161 132 193 2 198 70 108 127 173 79 54 222 112 103 167 66 36 18 254 123 5 88 113 135 119 248 208 83 248 47 221 3 124 83 230 231 127 98 217 161 16 14 173 2 254 183 181 80 30 138 68 90 175 197 33 50 195 80 50 169 186 3 240 16 197 214 181 249 58 197 104 134 66 75 130 156 129 164 127 179 134 24 105 109 114 9 224 209 29 70 55 115 3 208 181 189 163 125 138 224 251 60 58 27 55 117 22 4 122 227 81 236 104 214 193 204 157 14 173 240 14 127 227 52 57 13 212 150 171 254 181 146 170 234 186 38 52 203 106 210 177 19 172 1 116 222 91 244 2 203 51 196 131 15 68 103 249 250 197 110 59 217 78 119 135 205 163 48 16 173 171 115 5 224 81 16 136 206 10 242 79 30 142 236 46 0 186 38 103 136 92 225 33 247 207 10 114 105 217 253 26 255 111 191 150 142 241 200 169 113 29 242 136 72 102 84 82 47 10 107 235 154 148 76 183 0 30 209 25 101 243 186 146 161 17 15 15 241 120 219 137 22 120 240 129 11 57 106 98 21 180 203 247 94 238 87 115 214 167 61 40 67 200 76 48 159 118 202 190 225 211 155 194 109 115 57 166 148 138 52 229 146 76 76 143 166 254 103 65 44 127 24 166 145 11 13 243 60 204 184 218 155 175 83 28 105 124 71 85 228 97 165 92 2 120 208 42 12 96 151 252 71 215 8 245 98 62 179 187 160 36 114 148 254 205 26 87 19 249 52 15 215 128 68 222 182 118 3 221 75 231 244 16 35 221 121 61 220 62 146 253 91 170 94 77 246 57 30 87 146 253 28 143 249 100 63 167 235 124 178 207 243 112 95 72 246 83 122 252 43 217 79 11 251 126 178 207 243 152 79 246 83 52 62 72 246 57 30 238 1 201 190 48 96 202 219 223 246 105 104 4 17 241 51 54 94 133 243 58 19 62 253 103 54 12 226 254 145 200 223 106 252 171 137 252 162 195 186 6 36 242 110 69 187 245 211 66 127 253 234 15 19 185 239 189 68 133 68 103 157 99 33 81 229 120 92 73 66 115 122 204 39 161 60 143 5 167 159 226 241 129 211 231 120 20 4 114 174 184 24 121 160 49 204 69 247 107 14 52 206 67 85 102 108 113 226 230 227 98 167 17 15 189 23 7 153 46 242 104 235 221 145 231 81 36 78 143 139 92 118 196 197 162 24 110 118 5 104 138 119 239 42 22 163 90 172 227 223 225 129 78 166 206 100 214 165 196 67 149 76 83 8 235 137 164 162 190 174 126 214 57 176 227 229 109 174 0 186 94 115 142 241 76 159 187 27 88 224 145 119 232 124 159 141 59 171 53 211 102 11 203 131 211 126 12 224 119 94 154 123 92 180 67 143 107 9 41 33 127 200 22 25 114 180 225 113 194 208 229 101 81 35 184 191 244 192 216 186 30 22 225 152 49 243 33 54 47 139 160 51 209 74 179 168 142 107 224 42 6 154 99 29 239 32 128 81 60 193 93 103 79 105 11 93 226 236 37 198 244 106 10 117 116 218 183 253 129 51 165 56 58 122 109 173 193 53 6 254 109 210 24 74 14 142 41 200 16 92 245 80 148 245 95 28 93 104 198 153 116 217 48 231 35 135 159 77 104 143 119 198 211 246 152 243 121 191 1 176 251 164 75 140 24 74 194 196 191 98 41 59 101 147 254 174 49 70 148 91 119 223 109 90 146 193 6 81 221 27 22 77 120 151 81 183 59 182 56 177 200 43 89 172 96 7 71 192 227 6 96 101 107 92 32 20 231 174 103 239 21 184 211 172 99 228 242 249 215 15 40 139 216 217 134 195 139 3 250 211 123 8 155 92 1 82 78 190 113 255 154 130 166 94 91 32 47 227 157 55 11 46 45 222 143 181 34 236 250 192 118 56 151 151 85 86 19 110 91 215 88 35 212 172 11 117 134 112 27 105 9 119 214 184 173 180 128 159 94 219 24 95 147 47 187 120 171 118 150 173 120 5 143 84 112 223 2 62 217 197 110 25 203 147 6 94 41 226 124 127 71 103 251 199 177 226 158 9 58 198 139 236 138 142 165 141 246 159 64 21 110 3 132 173 127 0 232 42 174 158 176 230 8 208 85 238 41 194 146 143 3 206 227 113 229 132 37 6 160 29 49 54 47 248 153 199 0 47 152 185 205 132 149 60 12 10 98 248 194 0 218 238 62 192 151 96 240 101 9 226 116 22 190 128 24 233 3 214 40 60 128 238 182 130 176 1 1 14 224 37 219 42 194 238 60 9 95 71 201 72 19 88 126 18 190 131 24 227 122 203 237 240 67 148 245 65 194 234 170 49 231 65 5 158 197 116 122 18 126 134 216 35 132 221 240 123 56 131 216 99 132 9 171 224 69 124 129 230 33 194 182 190 10 127 65 140 222 216 128 221 159 194 151 62 160 146 189 165 161 135 184 165 0 85 143 18 246 217 39 185 74 196 176 139 0 212 6 14 123 160 234 121 194 90 86 115 183 35 155 163 132 221 22 229 66 0 31 59 73 216 71 74 56 17 25 223 79 88 252 15 28 190 155 112 195 49 214 80 39 232 37 148 106 86 227 163 105 194 184 103 88 79 68 240 37 29 57 106 9 216 147 166 162 107 197 236 250 127 236 50 120 9 13 136 132 245 152 188 94 214 124 227 195 34 236 152 83 185 196 25 121 202 150 204 226 221 146 161 41 218 118 211 211 24 83 44 221 40 108 210 53 171 56 203 182 177 223 50 36 179 36 156 50 45 61 33 108 148 119 239 210 141 152 233 15 69 163 50 94 69 71 36 43 110 122 58 37 99 187 108 249 215 166 20 53 230 20 44 234 10 227 243 23 178 149 74 46 161 89 82 71 152 82 194 214 41 38 222 98 203 137 94 148 192 55 62 104 202 234 56 172 139 237 17 137 172 80 14 60 166 83 184 73 196 98 75 232 217 136 44 49 194 206 17 27 127 83 194 75 16 14 236 176 122 14 65 191 61 186 140 250 105 178 234 199 169 169 49 174 255 7 13 0 107 57 233 28 100 54 200 203 81 177 79 187 78 187 28 201 123 150 94 190 204 235 148 221 202 180 94 238 109 189 141 103 235 73 31 207 52 45 252 117 125 69 246 41 57 158 17 70 54 35 195 77 126 147 219 100 196 34 123 64 246 49 175 203 219 116 235 38 251 200 38 219 200 38 11 143 76 56 217 199 200 38 140 112 247 177 89 132 237 99 71 248 69 24 225 146 227 132 145 227 146 205 14 184 183 152 157 248 163 51 7 189 199 233 17 70 216 69 201 128 221 38 11 249 77 166 43 217 120 178 2 220 10 148 131 4 112 171 170 151 16 98 131 223 89 132 172 157 6 191 43 224 206 9 191 201 240 251 67 50 142 44 39 73 36 47 205 165 6 53 183 172 19 219 153 191 146 111 145 210 186 187 183 10 73 26 32 208 47 29 207 244 75 226 120 89 14 201 61 175 66 217 167 73 154 2 168 27 25 94 42 98 8 220 14 60 98 59 205 255 149 244 113 94 202 177 2 118 149 154 95 71 121 232 252 146 216 111 30 33 171 142 147 9 123 114 136 237 239 63 32 228 141 187 182 221 147 174 145 213 196 9 231 159 61 128 163 51 51 60 252 40 127 236 188 236 112 82 54 73 182 185 167 84 119 141 184 46 105 253 27 119 201 199 192 61 153 85 77 22 144 223 195 159 96 82 49 1 165 0 72 87 124 1 89 243 231 187 187 40 50 191 189 120 222 208 118 189 245 187 48 133 29 207 227 240 92 130 231 98 56 191 5 231 100 60 167 224 57 21 207 105 120 46 197 243 70 60 39 181 187 222 123 31 206 5 191 92 146 82 0 231 151 219 55 23 250 224 92 214 110 191 180 9 206 191 235 231 47 91 111 44 42 113 22 59 156 154 210 160 15 178 184 39 225 3 127 255 71 254 4 211 79 50 248 99 22 64 72 150 222 104 87 188 242 23 244 145 185 9 15 248 171 105 119 221 57 51 194 163 45 213 70 125 114 134 197 227 84 189 17 188 178 72 63 224 115 15 243 89 100 242 56 190 237 237 195 69 29 124 78 106 157 123 147 222 231 28 125 238 224 123 29 252 78 108 59 23 72 130 243 4 56 167 117 240 157 221 182 255 111 20 39 206 251 74 156 71 240 159 142 184 150 14 234 64 7 31 141 234 249 14 19 192 116 203 143 114 152 14 74 20 77 118 7 84 237 64 68 210 7 98 58 72 220 192 255 99 31 104 178 181 0 123 139 44 254 167 51 254 55 169 7 244 128 226 174 47 242 121 170 164 125 94 57 208 173 131 111 152 252 87 32 63 66 7 75 91 79 148 209 251 215 240 127 243 209 23 150 225 255 44 191 200 104 61 126 235 190 111 148 227 255 54 13 232 40 31 231 16 122 218 140 120 150 174 50 17 39 11 231 136 235 108 185 169 179 151 240 62 164 183 23 113 62 5 116 119 229 255 253 247 94 14 2 221 109 145 3 205 170 86 63 24 36 190 98 234 78 232 74 232 73 232 168 177 245 237 99 183 224 172 181 125 114 120 86 79 206 88 240 72 15 66 7 211 16 207 226 127 202 47 126 115 99 57 156 115 143 93 248 121 16 206 251 65 7 103 71 117 240 15 219 53 96 113 181 149 67 184 255 184 100 77 145 188 224 62 142 242 146 114 167 170 245 248 207 215 241 92 141 188 8 61 76 198 123 225 71 175 224 249 249 214 191 124 210 235 79 235 255 235 79 85 232 7 79 125 106 39 226 134 252 106 59 206 97 249 150 11 255 191 11 207 235 218 174 255 225 251 29 250 93 136 252 238 64 188 120 142 176 124 206 242 183 87 145 31 203 231 188 160 239 139 112 174 135 243 229 81 157 127 207 118 8 84 186 216 210 121 38 215 185 26 244 121 134 119 23 243 76 191 203 67 222 132 206 67 186 182 116 188 24 245 27 210 115 92 183 47 32 142 165 215 37 248 63 225 167 161 188 33 244 185 8 207 143 243 71 60 119 52 128 14 207 143 234 112 143 237 155 160 162 5 86 238 128 253 5 232 112 167 226 243 168 205 67 66 124 110 64 135 33 223 20 186 90 133 231 103 90 143 253 152 158 11 17 39 148 79 44 253 89 122 91 141 243 174 104 187 50 255 72 135 222 214 60 202 51 86 142 22 249 110 198 64 190 17 58 123 186 223 186 183 31 114 40 186 123 100 63 244 213 132 15 251 173 15 200 159 97 250 220 158 92 186 69 106 144 61 95 16 232 75 120 192 159 191 189 242 223 223 233 225 81 5 255 187 61 166 199 73 122 227 86 175 135 229 142 97 74 215 38 156 216 151 34 127 160 199 81 242 224 251 90 194 7 254 126 66 232 6 60 203 242 147 92 189 113 135 162 5 130 146 23 98 71 157 226 147 67 28 58 18 30 240 23 218 3 162 206 82 60 62 109 100 169 78 121 197 179 200 163 34 135 134 114 230 108 60 79 55 115 209 28 188 159 133 103 107 95 24 218 103 77 197 243 76 60 63 107 230 25 177 183 17 57 210 218 215 216 73 217 184 127 82 61 119 234 52 179 156 246 10 106 36 183 12 245 137 65 254 183 225 121 96 142 25 14 41 80 7 35 20 219 29 107 10 54 207 203 91 165 44 43 240 44 206 239 30 106 203 240 28 51 29 174 138 121 197 249 56 134 93 210 66 147 84 14 207 49 217 177 147 207 80 25 244 5 148 6 185 135 9 254 109 29 158 35 215 169 169 53 176 40 215 214 20 212 195 64 225 49 88 135 165 127 14 214 87 201 220 22 132 61 107 21 48 17 211 217 110 60 139 92 0 173 144 7 124 176 213 125 29 219 221 123 131 181 138 47 100 94 181 9 15 124 85 236 223 67 185 224 87 228 20 76 63 209 226 47 99 195 138 146 97 226 240 163 91 140 196 6 252 61 225 45 123 131 18 216 224 13 140 80 39 37 154 224 45 195 110 175 122 168 55 241 239 196 11 188 13 248 92 230 136 195 241 79 79 120 192 155 232 89 60 209 93 174 221 171 74 129 34 77 147 14 12 179 232 73 52 161 187 105 162 18 194 251 32 17 238 2 9 15 120 19 61 139 39 186 155 88 33 105 181 50 13 181 181 178 54 184 56 121 61 209 132 79 79 130 252 172 41 45 43 90 86 198 76 79 132 199 196 17 62 205 154 27 163 62 29 76 120 192 155 232 43 60 225 47 155 87 80 70 24 108 74 120 192 159 232 89 252 135 63 213 93 63 232 211 226 107 78 120 192 159 232 3 61 225 47 139 111 57 71 12 132 182 216 18 27 240 39 250 21 79 243 245 46 197 255 48 95 203 9 27 124 155 113 197 183 81 241 93 231 241 111 39 253 209 118 176 170 180 186 138 222 0 38 67 77 214 27 243 235 162 196 210 253 48 71 165 55 100 92 33 67 77 109 128 125 96 20 151 177 205 80 217 77 50 71 77 211 3 30 69 141 192 50 174 5 234 91 36 133 163 166 3 170 87 217 23 134 53 81 83 13 84 77 241 213 62 70 77 67 94 217 50 113 136 215 251 168 233 133 204 47 210 170 14 248 101 61 202 43 221 217 114 84 122 51 158 163 78 46 86 125 30 37 160 168 62 182 69 215 84 115 2 182 129 230 168 244 102 2 71 205 112 40 45 178 199 161 122 6 104 98 123 102 142 74 111 50 56 106 122 105 147 236 11 68 40 98 219 109 134 202 110 50 113 86 182 213 244 104 82 115 63 48 219 97 115 84 122 147 197 81 39 26 168 85 114 75 160 27 153 109 178 25 42 187 201 230 168 227 183 186 182 7 20 111 152 34 83 67 19 145 87 135 220 64 251 189 97 149 211 237 187 80 67 18 201 65 189 210 237 83 84 175 38 67 147 132 134 52 77 133 165 67 88 67 180 41 192 213 64 111 114 185 191 166 131 180 171 138 157 97 84 186 191 231 254 74 111 200 100 84 94 145 223 239 149 171 36 111 125 63 176 201 208 20 62 107 78 145 199 163 201 186 94 93 33 81 91 233 130 166 157 1 62 43 189 33 83 113 214 74 89 231 239 49 60 156 117 154 240 60 77 242 143 105 232 25 84 249 70 89 15 72 222 30 87 64 13 209 22 5 215 16 189 153 142 168 118 213 235 161 251 158 1 84 115 214 25 200 107 21 60 71 17 245 20 19 245 89 129 10 166 53 134 58 19 189 193 229 214 20 127 152 86 11 117 22 58 37 44 178 188 81 245 153 168 179 133 26 148 22 90 199 120 164 134 57 168 215 114 183 234 27 211 235 92 238 40 241 119 17 218 93 41 159 137 116 152 242 25 180 60 25 106 188 21 218 238 74 45 21 168 169 165 208 73 20 179 14 117 24 219 93 87 141 36 122 245 125 104 80 51 212 120 227 26 38 92 98 204 186 132 204 71 13 149 200 77 74 216 241 186 188 124 1 122 3 180 69 0 84 127 228 148 11 81 121 92 8 97 229 177 38 41 159 149 222 60 207 81 51 139 213 6 191 234 11 167 54 19 117 17 162 178 89 203 125 254 96 191 23 153 168 121 28 53 139 165 141 72 68 52 121 93 204 81 83 75 157 206 226 104 86 54 51 229 18 100 8 64 169 49 239 83 91 250 176 205 89 95 224 168 217 91 212 128 82 163 184 251 115 77 23 234 139 168 114 110 38 17 149 119 230 215 165 28 117 2 228 242 128 166 134 163 168 137 154 143 42 119 200 190 96 212 95 77 212 101 194 135 96 59 169 214 62 102 104 57 50 68 51 74 41 236 14 6 96 77 53 188 36 18 27 236 54 180 47 19 192 10 156 213 143 13 169 1 96 214 223 229 9 155 222 172 68 94 93 108 251 242 56 177 173 18 185 28 148 55 150 81 86 35 170 83 109 30 228 213 244 242 53 194 149 221 16 96 191 156 117 45 79 27 241 222 233 201 163 121 63 229 105 131 222 144 2 142 58 65 111 4 79 169 81 66 219 40 186 219 227 168 244 134 188 204 81 167 232 141 78 175 20 168 81 181 6 151 95 118 83 251 123 128 79 55 129 152 108 224 6 154 199 70 138 26 108 42 159 104 218 126 130 163 210 27 232 151 138 20 53 212 71 61 121 116 233 33 193 235 210 67 240 106 3 67 141 191 242 0 137 11 247 13 244 134 172 19 89 153 1 70 55 115 240 34 2 238 216 224 230 21 204 202 144 135 26 198 178 242 122 142 154 91 92 233 224 227 246 7 62 19 181 16 25 170 80 155 97 177 20 217 244 116 186 114 17 87 67 252 237 29 208 64 178 161 134 100 178 129 111 28 51 37 159 174 236 245 75 26 128 245 206 107 110 82 139 197 118 83 121 93 222 27 217 55 152 123 202 18 142 154 234 11 122 35 186 235 154 181 148 163 142 111 146 246 122 21 61 60 172 57 171 157 163 166 121 148 166 40 65 214 172 27 113 214 102 119 157 164 69 112 205 89 203 184 242 186 219 200 157 240 116 87 142 202 131 27 82 142 42 223 44 107 62 57 162 7 51 55 108 226 168 147 113 196 210 22 183 236 167 105 212 148 173 233 40 155 69 126 133 246 125 165 92 11 50 234 219 86 154 179 86 24 158 231 145 237 154 84 219 208 159 204 205 89 29 33 53 116 250 185 169 134 45 124 214 120 195 183 237 250 187 167 109 7 29 206 10 104 54 188 123 154 108 21 106 24 238 225 182 93 63 37 11 212 83 50 113 162 43 199 90 183 144 36 223 65 84 184 33 219 56 106 188 203 220 182 237 131 66 219 65 61 16 220 71 111 72 37 119 148 120 227 184 237 95 63 250 53 206 10 55 196 197 103 157 106 244 121 251 215 48 230 54 186 10 121 45 111 144 106 25 34 221 194 118 111 42 76 212 237 28 53 107 91 201 214 154 26 221 173 201 114 239 106 195 82 249 14 116 20 87 64 242 121 36 205 67 179 198 200 70 100 167 216 151 171 77 240 132 94 36 55 116 50 84 141 105 190 200 171 72 225 173 87 215 172 175 98 194 222 161 120 228 104 219 195 244 188 93 28 53 199 80 158 35 168 155 137 183 135 161 221 184 113 140 245 175 223 41 207 71 111 160 55 240 234 85 71 126 141 188 146 5 57 109 161 145 216 22 146 215 140 221 161 94 191 33 178 235 49 213 176 199 72 216 67 47 228 157 92 112 118 21 38 108 184 129 119 254 120 206 139 189 11 8 173 166 55 5 67 119 222 132 86 53 67 141 183 176 1 235 140 129 122 6 58 205 156 161 88 7 26 176 142 24 168 71 160 169 200 80 227 205 70 192 186 105 160 222 132 30 50 103 40 214 91 6 172 27 6 234 13 104 209 242 100 19 107 221 2 214 167 6 234 167 208 201 226 179 198 58 92 128 245 185 129 250 57 169 65 71 233 104 40 247 10 221 212 80 45 50 20 235 239 3 214 85 3 245 42 169 11 161 154 249 21 186 248 6 234 71 68 225 168 253 93 222 123 200 128 117 197 64 189 66 246 163 202 31 52 10 187 153 5 172 179 6 234 89 82 47 80 239 247 40 251 80 47 27 168 151 137 23 53 228 80 60 202 176 134 46 26 168 23 73 3 71 125 208 25 236 129 5 172 243 6 234 121 120 177 70 248 235 208 11 55 237 174 219 27 5 234 237 141 68 237 69 237 227 245 182 49 235 109 226 231 168 57 126 220 203 229 203 45 126 88 120 137 146 186 129 10 111 220 32 42 220 144 70 204 175 144 53 202 100 41 92 100 97 47 41 241 60 68 111 52 204 67 247 80 121 134 181 242 16 125 119 233 160 195 81 92 198 110 244 110 247 234 111 96 220 249 208 224 245 67 104 123 71 29 229 30 190 233 67 65 161 242 225 142 48 96 93 50 80 47 65 211 182 199 81 250 210 198 125 247 106 238 117 175 62 212 115 6 234 57 104 149 118 59 74 95 179 228 206 5 3 245 2 188 9 201 85 30 123 67 18 50 97 134 145 14 51 160 113 206 80 227 13 117 152 240 154 49 43 125 59 15 62 27 188 150 75 146 156 46 185 246 238 93 3 8 254 99 35 244 63 112 36 105 179 79 192 251 107 182 57 240 183 106 103 133 206 218 249 105 179 143 23 18 50 27 154 203 51 126 235 180 123 153 9 253 15 0 13 13 20 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 112 114 111 106 116 0 0 0 0 0 0 0 0 0 0 35 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 26 227 0 0 72 167 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 181 84 10 24 0 0 42 17 0 0 61 92 0 0 9 157 0 0 14 9 76 212 188 78 0 0 0 0 0 0 123 161 13 192 248 171 243 250 86 230 201 174 149 189 155 114 7 120 186 105 3 219 180 91 217 17 126 17 30 37 148 236 99 183 118 246 153 156 218 201 169 13 146 191 114 241 212 240 204 179 115 194 86 171 232 241 65 183 22 97 165 71 54 185 205 142 176 142 108 178 217 17 158 132 146 227 215 107 132 17 126 110 27 48 194 37 191 9 37 251 40 97 132 110 182 143 108 66 201 62 70 24 225 61 161 60 182 143 112 178 159 108 150 183 143 112 194 9 143 17 70 246 49 60 240 213 149 156 246 121 121 242 163 69 91 153 71 56 89 152 17 182 201 45 220 205 54 121 78 126 147 77 184 120 178 129 241 39 80 231 119 25 0 7 0 11 123 0 22 224 223 176 33 160 188 249 133 71 56 80 222 10 193 82 187 114 2 255 127 111 216 182 204 166 188 174 158 42 103 185 253 162 207 23 17 125 237 46 95 71 139 55 224 114 57 108 161 112 176 141 71 22 78 167 171 90 61 57 234 87 151 16 175 11 177 167 177 37 27 96 198 95 1 22 127 39 103 165 77 249 195 238 93 229 37 235 141 181 219 118 191 88 48 15 145 172 178 128 210 179 204 6 22 252 155 241 159 82 185 255 31 198 170 191 128 101 157 185 118 27 229 134 140 207 87 215 84 45 79 174 56 62 251 132 18 170 108 172 236 88 14 144 204 184 37 179 47 41 78 246 188 8 73 201 24 80 89 7 80 246 71 46 115 33 102 240 96 164 60 60 179 124 48 88 247 225 185 77 195 49 223 20 18 61 237 98 139 244 158 160 48 69 203 183 201 93 254 11 249 83 221 93 114 68 242 59 124 162 44 75 242 69 10 243 223 85 234 66 24 129 199 66 6 68 182 227 233 106 205 177 224 145 69 154 14 0 139 88 148 147 34 22 167 232 17 170 220 2 118 6 193 177 204 145 151 103 251 254 153 42 118 213 102 234 65 59 215 114 219 185 84 254 225 211 117 208 250 163 46 30 9 243 217 74 54 72 198 86 166 196 96 69 225 40 8 154 171 30 41 118 238 4 88 169 208 167 41 152 106 116 6 3 162 39 56 198 52 9 114 33 141 251 17 31 29 58 159 13 70 79 237 32 86 4 131 252 14 254 160 225 119 144 1 80 216 11 220 47 76 152 151 69 62 254 18 83 231 252 201 96 101 214 224 208 239 105 192 113 5 208 128 248 218 83 79 67 195 103 254 164 98 0 189 0 13 246 232 111 78 225 255 184 61 106 143 14 190 178 96 45 170 157 1 135 176 242 38 226 138 93 14 184 10 123 247 55 126 6 13 75 203 96 237 91 235 32 250 234 0 68 31 235 180 71 119 165 177 156 232 230 54 149 137 202 79 176 216 187 169 158 189 251 169 87 225 254 95 109 57 195 5 145 232 227 207 105 18 199 52 143 194 107 154 39 136 223 176 209 187 247 206 181 119 191 136 217 26 63 152 222 8 135 240 127 154 207 99 175 65 195 202 35 120 254 1 227 210 207 56 191 1 59 153 210 211 177 42 50 70 55 241 25 5 216 88 176 175 184 59 66 161 96 56 82 64 190 182 3 215 246 250 0 88 211 251 97 218 179 185 113 243 45 81 21 193 170 92 219 177 229 96 173 61 130 255 67 173 202 223 236 136 47 166 86 0 214 25 75 16 59 129 127 11 76 239 174 193 250 189 243 33 41 9 113 225 237 250 200 239 152 75 197 151 68 184 188 159 246 200 158 176 23 102 21 163 171 103 44 97 29 165 237 56 250 0 245 97 245 83 176 62 233 145 25 239 7 57 111 108 178 63 249 189 8 34 104 2 226 115 252 5 176 206 219 195 21 155 93 136 29 70 126 219 153 207 167 61 251 136 90 31 245 160 250 214 236 144 198 32 19 178 169 83 112 47 1 63 167 192 41 69 194 193 7 165 112 187 44 184 35 98 160 89 12 55 11 21 222 166 176 24 238 42 48 153 142 20 160 111 0 207 89 240 132 233 216 111 55 99 245 52 245 76 230 200 165 76 179 210 55 251 37 21 195 148 39 184 1 204 89 162 244 173 120 232 189 122 159 63 93 111 135 217 130 57 107 148 190 207 146 162 152 115 178 223 184 229 228 115 244 55 245 236 91 7 220 157 189 74 223 172 47 195 109 217 125 202 47 59 183 211 217 248 149 85 7 177 102 175 114 64 81 168 14 14 49 91 96 97 65 0 114 191 187 87 57 176 105 157 114 96 115 20 243 7 160 22 106 93 235 16 121 154 120 49 229 211 176 18 253 169 90 173 106 134 25 243 193 72 19 134 54 96 84 120 3 237 82 248 92 119 158 168 0 153 79 153 76 191 127 5 255 150 34 224 75 149 195 39 204 198 173 219 209 214 153 43 128 63 154 11 183 23 186 92 21 183 198 33 106 134 133 161 144 79 31 128 135 211 89 81 52 94 39 29 27 129 176 218 79 221 145 164 191 88 195 233 170 40 213 9 224 81 239 64 183 232 1 232 90 233 214 11 240 89 181 187 122 68 168 143 120 212 148 172 169 49 216 154 90 61 131 131 131 192 29 120 146 37 30 221 193 186 157 253 241 54 156 3 12 197 230 34 188 2 9 6 3 66 153 228 99 77 250 182 124 30 142 110 219 11 61 139 242 97 119 193 0 165 16 15 222 230 185 204 215 236 172 87 39 228 81 151 169 60 146 108 158 188 60 93 0 30 6 155 231 178 32 255 228 17 155 77 110 233 26 26 35 114 157 135 212 121 89 144 15 67 245 107 235 127 253 106 25 226 145 80 99 42 242 112 137 178 71 244 93 18 86 213 53 36 142 92 23 253 139 135 103 76 217 113 93 105 152 37 30 70 226 241 65 39 186 198 131 183 157 159 199 134 195 80 45 61 116 213 175 242 229 62 109 68 25 10 101 63 235 211 44 255 221 62 189 198 81 53 49 15 89 168 72 105 98 34 106 14 122 58 62 105 65 108 254 8 203 225 196 208 48 201 67 110 245 53 141 215 73 119 149 92 81 21 121 68 58 116 2 120 80 36 217 208 37 255 209 213 69 94 84 39 251 187 242 239 254 120 178 207 210 255 152 236 81 250 139 53 110 76 246 163 60 116 3 38 251 170 162 114 97 66 15 167 171 126 92 15 189 143 201 254 125 85 111 76 246 9 30 215 39 251 9 30 147 147 253 132 174 147 147 253 56 15 253 133 201 126 68 143 127 79 246 163 194 126 52 217 143 243 152 156 236 71 104 220 156 236 19 60 244 3 38 251 36 155 44 181 124 208 167 1 122 22 159 194 237 138 92 40 154 143 253 185 247 76 159 46 101 125 90 255 99 34 127 223 248 55 38 242 75 29 86 55 96 34 175 247 6 238 188 67 232 204 191 235 227 137 60 237 255 39 42 36 122 185 115 92 155 168 18 60 174 79 66 19 122 76 78 66 227 60 174 117 250 17 30 55 59 125 130 135 193 150 232 138 41 200 3 27 195 196 232 126 171 3 197 121 248 188 99 109 113 248 230 227 146 211 136 71 176 9 23 162 46 241 168 106 106 27 231 145 234 28 93 59 185 218 17 83 156 78 71 153 46 128 41 254 239 174 34 5 213 98 142 191 194 3 59 153 111 108 102 157 70 60 104 197 81 112 4 253 33 175 239 29 245 99 157 3 29 47 173 215 5 208 245 86 231 136 207 244 137 187 129 107 60 198 59 244 184 207 226 157 53 50 102 179 107 97 196 173 65 6 240 27 63 220 159 76 110 11 182 6 252 162 127 116 199 245 74 32 67 142 14 60 110 42 234 188 4 25 65 255 197 3 67 49 147 246 111 135 124 49 140 208 78 43 57 69 69 211 193 132 8 251 105 249 7 0 55 0 39 54 137 175 196 74 12 245 182 159 139 174 57 183 161 123 51 136 207 16 120 97 99 25 121 158 43 154 15 169 76 82 252 163 156 101 146 216 44 133 229 201 145 195 12 6 182 176 172 153 135 251 245 240 106 251 59 190 210 243 137 7 30 144 35 98 152 93 48 234 55 4 217 216 10 6 94 107 139 241 237 116 12 234 149 241 102 217 199 94 43 248 36 252 162 55 0 58 15 138 115 51 81 71 122 199 224 116 96 251 116 111 232 144 196 246 58 167 43 236 245 203 178 28 136 4 19 87 202 122 36 177 31 187 60 55 179 210 189 84 181 130 80 231 20 66 97 73 184 195 150 111 107 34 132 21 113 86 185 221 250 0 187 179 55 141 251 246 20 52 242 106 3 189 122 192 15 189 158 49 17 188 25 107 225 142 189 246 233 190 132 117 145 163 170 184 100 145 176 168 184 176 166 16 143 174 213 142 154 69 122 43 22 48 107 143 185 104 113 230 125 26 211 188 141 39 50 79 98 202 108 238 231 192 135 234 216 45 99 22 118 197 245 48 15 22 186 107 170 115 176 226 183 134 235 167 22 178 43 58 54 53 221 251 99 160 215 31 210 9 187 231 97 160 123 154 153 132 149 111 5 234 164 244 254 1 116 124 10 238 195 227 30 194 166 214 64 11 30 233 101 10 200 94 0 200 149 43 39 44 119 63 124 17 177 175 19 86 26 132 175 34 118 144 176 251 215 2 190 94 128 115 58 198 134 123 224 155 172 187 97 216 94 134 231 17 99 175 99 52 245 195 203 136 117 18 86 245 109 248 9 98 95 35 172 253 135 112 24 47 226 94 32 44 244 12 12 162 172 136 227 254 91 23 252 25 177 35 132 221 183 2 222 4 152 115 47 97 235 155 201 25 115 216 16 247 168 196 77 67 108 19 211 123 7 55 27 49 182 55 211 24 226 240 33 135 185 141 132 181 108 229 62 135 216 46 194 86 23 114 184 43 56 23 53 65 79 100 112 78 0 97 11 97 46 129 107 64 12 157 6 176 209 204 225 69 184 192 244 88 113 146 195 93 154 236 141 132 173 106 231 30 5 248 52 189 90 1 13 207 112 91 241 137 139 74 194 114 246 113 168 99 142 122 3 210 79 175 115 44 96 53 110 143 18 198 51 205 50 92 248 84 144 228 137 8 232 91 217 27 12 100 58 197 22 175 71 112 136 161 179 87 199 120 245 19 75 84 111 210 167 197 19 52 14 233 108 189 96 168 226 20 90 64 113 4 155 165 85 82 32 45 190 140 194 210 180 138 25 218 74 85 172 100 12 175 23 195 1 111 160 69 54 150 52 123 113 220 76 42 13 6 34 233 49 165 74 58 35 97 81 206 112 116 200 145 160 95 184 91 234 122 48 24 110 150 205 133 30 143 132 122 185 196 72 171 108 172 17 195 45 82 196 92 212 225 245 53 107 5 83 235 28 248 84 137 20 233 8 77 161 93 85 77 24 11 97 197 94 25 165 150 252 77 40 65 90 124 145 149 213 137 105 171 174 96 196 132 210 224 33 157 28 165 78 44 54 133 221 139 105 196 8 59 77 44 254 246 133 137 32 92 8 98 245 52 130 102 117 53 26 245 11 72 62 51 110 101 13 113 253 31 0 0 13 0 107 157 39 123 7 217 229 117 246 230 32 63 229 118 202 109 96 57 240 210 113 167 236 86 166 199 236 154 104 120 182 158 244 241 76 207 43 252 215 128 231 128 242 206 235 36 91 50 224 100 147 225 38 155 12 182 100 159 145 125 76 89 121 202 9 39 123 66 54 219 100 79 200 111 194 201 126 114 155 28 239 8 39 155 240 142 240 203 147 176 65 118 228 120 78 200 102 1 247 22 205 77 241 71 103 230 245 30 247 8 35 155 110 70 6 236 54 153 108 114 156 140 86 178 215 14 184 128 114 208 7 52 45 68 8 113 193 255 165 132 108 58 69 200 230 60 120 243 194 255 217 240 255 67 146 77 54 144 44 178 52 199 27 138 54 43 234 82 114 232 234 215 225 59 66 98 31 54 176 218 249 101 49 188 162 60 95 52 18 209 116 115 69 185 22 148 137 251 155 240 101 30 252 145 119 127 76 238 35 249 67 120 185 188 191 21 213 161 168 76 206 225 205 173 83 246 235 146 174 200 198 177 34 196 155 5 127 28 143 50 103 227 17 215 31 220 140 229 172 99 69 238 101 255 184 141 125 219 120 250 165 97 254 72 214 230 172 45 143 125 74 142 209 126 150 191 78 174 35 63 131 239 10 25 58 253 185 0 2 126 5 17 198 88 173 106 202 122 164 56 48 42 6 246 123 18 235 53 177 163 61 79 64 23 55 98 189 14 235 181 88 95 7 245 147 80 175 198 250 6 172 139 177 190 9 235 34 172 215 99 125 125 175 239 200 175 161 222 112 120 93 246 29 80 223 220 187 173 68 133 186 174 183 234 245 173 196 229 218 235 218 7 221 175 118 248 203 55 218 60 82 96 183 162 6 181 142 73 250 136 248 86 240 231 57 184 178 251 8 212 75 122 150 191 87 10 245 149 61 47 212 208 119 193 107 62 126 31 194 186 160 231 208 183 105 29 70 156 59 122 158 61 244 1 212 119 198 142 63 189 246 140 14 114 99 175 153 89 80 95 141 56 66 23 243 98 7 254 76 223 85 236 55 18 251 219 170 111 65 157 131 56 26 246 153 214 207 93 136 35 116 84 136 239 11 177 118 116 117 13 246 151 214 87 131 107 15 168 99 149 163 175 249 76 95 219 125 220 216 146 10 251 178 173 175 189 88 207 142 61 251 52 229 91 232 106 110 207 243 31 208 119 161 47 71 55 110 168 169 199 53 224 247 142 126 132 94 230 216 122 217 135 117 227 69 253 204 194 190 28 221 4 123 171 222 252 43 212 247 199 150 52 63 6 245 3 61 239 94 187 18 234 7 99 185 213 63 132 58 59 214 182 251 153 179 186 34 63 69 223 229 114 234 243 93 163 173 180 194 91 238 241 234 74 216 152 52 46 238 241 25 28 124 151 252 138 252 6 186 95 224 240 7 190 91 165 132 228 207 232 35 251 51 30 240 39 116 154 246 183 28 215 28 96 225 74 135 199 197 204 223 74 141 46 53 48 205 231 237 54 143 142 175 93 133 190 158 246 53 199 207 46 249 125 220 175 100 208 193 201 115 122 62 205 12 126 137 163 131 66 166 131 10 69 151 3 166 166 119 37 36 253 165 148 14 50 55 240 63 227 3 237 174 78 96 111 173 195 255 18 198 255 86 173 203 48 149 64 107 169 26 244 75 251 67 178 57 164 131 237 54 255 243 145 31 161 131 165 152 79 118 164 242 165 240 11 39 15 173 196 239 174 29 215 145 200 149 66 79 171 16 111 38 39 197 117 182 108 60 87 198 245 38 114 101 19 232 238 196 231 254 11 57 136 230 75 217 236 208 244 214 201 32 113 139 173 59 161 43 39 87 198 115 185 208 71 222 191 245 32 116 112 247 120 174 222 252 253 31 189 179 1 234 77 135 254 242 189 40 212 205 160 131 55 206 233 224 239 174 183 129 197 141 99 254 227 147 117 69 10 129 251 120 106 43 106 189 48 120 26 82 196 173 88 87 33 47 66 15 213 248 46 252 232 30 172 75 123 126 127 124 196 159 182 252 207 159 202 208 15 46 249 84 37 226 198 253 170 28 251 112 124 171 4 191 223 138 245 182 216 209 159 127 237 140 126 107 144 223 10 196 75 231 8 199 231 28 127 171 69 126 28 159 83 64 223 71 161 110 129 250 216 57 157 127 197 245 20 168 244 122 71 231 121 92 231 90 84 13 78 197 102 82 63 62 175 18 58 143 235 218 209 177 31 245 27 215 115 90 183 241 57 204 46 252 78 248 105 60 111 8 125 250 176 158 201 31 233 220 113 0 116 248 214 231 243 23 58 55 84 140 192 217 249 197 198 140 15 243 151 87 200 239 160 251 133 195 185 105 187 20 150 131 159 17 216 150 241 128 63 163 183 254 159 143 14 243 168 131 62 63 190 160 199 5 70 219 142 80 144 249 226 52 165 247 101 124 208 99 98 158 119 142 60 248 125 33 227 3 127 223 33 223 165 246 231 240 183 208 104 107 80 116 51 42 133 32 158 180 40 170 28 231 176 53 227 1 127 169 57 85 118 80 213 167 131 19 254 232 238 7 253 137 188 36 114 82 60 7 93 142 245 78 123 222 127 5 190 47 198 218 153 103 197 231 45 11 176 94 132 245 101 246 156 94 204 21 68 206 177 231 9 174 151 92 47 3 123 55 209 237 141 126 254 231 170 145 176 20 40 14 68 34 41 254 119 99 189 231 224 198 245 245 103 230 4 98 46 31 159 91 93 154 7 8 221 196 245 226 204 9 46 205 177 226 249 210 209 87 124 15 64 248 142 200 151 66 135 206 222 68 58 111 166 247 0 238 237 249 201 53 95 229 249 96 22 205 165 182 110 23 249 218 162 178 212 90 171 150 233 90 135 33 235 197 186 161 143 218 152 137 117 21 236 186 172 129 173 157 181 4 54 125 78 62 131 205 236 115 47 59 213 77 110 134 105 216 173 176 25 176 145 220 238 38 167 189 228 78 114 23 185 155 108 34 155 201 61 100 11 41 33 165 164 140 148 147 10 82 9 93 84 147 26 82 75 182 146 109 164 142 120 96 122 185 3 156 113 39 76 23 124 196 79 118 145 6 240 137 61 228 94 72 85 247 147 7 200 131 100 47 32 214 48 254 172 237 163 44 102 196 121 108 67 168 73 10 200 176 178 52 233 59 98 127 196 233 3 117 224 246 72 102 75 170 5 246 91 62 221 71 190 199 87 183 162 188 216 235 45 47 158 238 70 26 239 3 121 45 240 236 46 175 143 170 166 18 150 167 27 17 57 100 136 15 58 215 36 121 59 163 48 55 246 67 27 41 114 87 96 45 114 100 182 157 195 216 42 66 11 219 69 152 90 185 137 102 60 200 97 98 159 32 158 35 95 34 52 159 204 119 248 203 45 187 165 226 179 93 33 250 107 207 120 192 223 69 222 10 202 20 179 44 100 158 165 174 35 211 4 111 185 85 85 254 243 122 163 91 15 153 25 120 27 247 185 188 179 14 199 127 93 25 15 120 19 123 35 23 117 183 176 42 164 73 102 169 174 75 93 211 44 62 148 105 66 119 151 139 21 23 190 223 146 224 238 139 25 15 120 19 123 35 23 117 55 191 78 210 155 101 26 70 155 101 125 114 208 246 68 166 9 159 94 0 185 87 87 58 111 233 188 53 101 122 15 103 156 240 105 182 137 114 206 167 31 201 120 192 155 216 191 184 200 95 1 95 169 57 203 224 163 25 15 248 19 123 35 255 229 79 11 180 78 250 180 248 61 150 241 128 63 177 223 116 145 191 124 62 21 63 107 32 221 25 15 248 19 251 34 151 242 245 125 74 228 124 190 126 60 99 131 111 51 174 74 24 89 233 25 93 108 231 43 37 174 110 195 140 238 167 47 36 139 163 166 39 96 177 163 47 127 221 213 237 241 214 85 209 23 50 139 163 186 253 93 17 217 40 110 137 203 129 77 83 187 253 149 123 252 236 101 54 71 189 172 92 83 131 138 169 104 42 219 51 208 53 187 3 54 139 230 168 244 37 155 79 221 220 106 68 138 40 201 94 97 2 235 226 168 240 66 114 120 175 185 108 34 23 212 165 142 49 100 54 215 101 168 236 197 141 168 30 165 83 14 122 224 220 195 24 42 155 86 243 94 233 203 28 142 58 223 234 213 47 119 154 67 200 108 198 204 80 217 203 92 142 58 167 178 93 86 205 132 136 216 164 157 51 68 95 230 113 212 185 59 124 187 76 37 52 1 107 43 47 23 123 245 200 97 186 215 27 239 149 77 229 5 175 89 36 15 213 224 213 181 128 108 24 113 165 219 188 230 163 55 208 217 78 210 27 108 212 2 228 181 90 54 76 41 52 172 30 84 3 221 47 224 106 160 47 243 81 121 244 50 71 149 46 53 135 199 164 100 247 90 40 220 11 220 78 255 15 67 11 80 13 245 178 161 69 117 16 196 121 53 44 68 84 63 28 39 73 42 214 70 189 76 160 130 145 92 64 93 132 42 247 5 116 37 50 33 33 7 117 49 106 8 114 67 40 201 173 141 122 57 234 181 74 233 164 195 252 120 179 54 234 21 168 188 218 128 166 94 240 134 37 216 107 133 220 174 76 232 14 188 129 238 142 112 111 160 47 87 10 84 72 254 90 115 2 117 32 1 92 37 92 89 215 53 24 45 77 184 242 64 175 87 35 175 30 89 141 38 121 181 123 93 202 81 231 65 30 50 117 109 194 204 109 212 107 144 87 126 238 100 134 215 101 216 43 117 148 74 72 95 227 176 182 242 150 11 94 167 247 53 236 76 185 130 39 182 244 54 196 15 106 139 17 149 190 144 149 168 188 109 178 174 202 161 25 229 93 139 153 18 23 214 42 59 3 114 132 70 75 91 23 54 175 171 48 245 210 237 201 122 185 89 49 204 209 84 100 247 186 186 132 237 243 184 13 51 168 104 201 36 74 179 58 79 81 244 101 13 71 205 147 84 67 105 140 72 58 108 6 142 64 179 201 128 64 125 130 92 199 81 231 24 202 67 114 99 194 203 237 94 215 114 212 28 53 26 74 40 104 176 215 34 142 58 183 93 106 12 129 20 38 50 229 64 175 184 213 60 219 104 75 118 74 8 221 68 228 185 156 190 144 117 200 80 56 25 26 134 24 186 65 168 193 12 134 148 253 51 106 184 17 245 26 84 218 147 18 114 122 93 143 106 232 8 180 72 122 2 215 238 181 216 98 72 87 212 230 25 134 110 66 53 176 185 203 148 26 250 81 233 21 40 234 229 70 27 36 135 38 37 222 45 157 21 113 229 209 23 216 23 99 168 139 140 54 111 72 50 155 52 61 236 139 200 1 165 73 9 252 11 159 78 150 80 175 240 2 59 102 220 41 83 23 26 122 125 57 235 132 202 115 214 193 94 26 67 77 223 51 0 172 13 22 234 6 216 101 19 189 78 93 197 121 113 245 159 110 227 168 244 69 92 81 72 239 114 191 208 190 235 5 142 74 95 224 146 11 67 77 95 126 1 94 102 91 12 205 134 189 93 193 208 212 158 239 139 7 215 63 133 12 193 11 185 3 39 115 208 105 141 44 5 233 202 194 136 98 217 205 10 158 54 232 203 157 28 53 191 15 21 246 220 134 189 129 94 184 232 246 120 202 107 216 203 93 152 14 125 204 135 38 210 161 157 135 238 22 19 17 93 138 92 200 229 155 184 26 230 0 67 254 114 239 4 44 221 101 229 106 160 47 176 159 200 80 11 75 131 65 29 166 74 123 234 36 154 215 6 209 233 38 44 71 165 47 228 30 107 210 19 14 95 152 82 108 225 168 11 203 235 61 220 133 198 70 8 54 106 9 71 93 108 229 87 104 58 162 169 206 108 201 158 177 149 162 202 199 192 250 84 78 47 32 112 149 211 151 50 100 168 54 44 53 179 62 169 38 134 244 96 247 90 142 222 176 179 98 71 83 147 17 208 101 121 72 64 67 188 86 96 234 245 153 146 26 148 244 32 117 188 97 88 27 181 82 204 14 181 118 56 81 151 72 54 3 12 85 161 15 149 134 20 105 98 114 56 216 107 53 71 205 45 141 68 66 178 95 10 181 158 159 123 213 160 123 241 131 26 137 233 203 128 242 106 17 181 65 9 202 201 52 111 207 0 182 114 212 66 203 27 60 81 195 78 80 195 106 216 38 38 115 204 132 146 233 16 174 154 96 206 131 151 58 238 148 67 91 249 3 248 116 7 0 51 10 188 16 15 122 3 211 80 98 184 108 107 104 123 127 98 75 92 64 130 20 180 198 202 67 107 200 14 107 50 103 180 150 37 38 95 118 175 94 222 107 122 139 255 249 71 178 126 193 123 165 47 100 167 152 56 106 161 137 8 53 212 107 61 206 162 82 23 87 128 205 74 139 215 74 226 67 47 103 128 181 106 36 58 54 6 176 29 197 207 81 115 42 233 66 114 34 205 219 19 253 93 216 43 128 210 33 241 126 173 115 20 219 230 181 65 76 176 52 147 70 248 177 12 53 136 186 155 171 33 125 63 224 240 47 79 44 197 201 1 188 144 61 194 203 111 243 153 209 166 166 9 229 209 27 3 188 87 250 114 175 181 183 1 231 51 147 254 10 27 243 188 87 250 2 59 232 12 53 125 9 228 197 131 69 207 137 132 93 244 28 236 173 115 71 57 160 39 55 68 192 95 97 123 159 163 210 23 216 117 103 168 243 0 213 76 46 178 208 93 127 100 8 94 96 63 158 123 57 160 54 134 19 113 131 94 6 192 94 225 133 236 197 249 144 4 123 20 48 1 73 206 135 250 103 81 141 125 115 175 160 60 33 60 103 62 180 175 15 21 246 36 103 80 37 142 154 222 169 143 157 248 134 31 55 129 224 5 46 251 137 233 203 212 229 188 94 95 246 251 194 95 179 223 135 59 156 2 117 234 110 103 175 127 214 31 17 21 94 72 16 189 252 204 214 240 8 183 116 151 87 228 33 216 234 149 49 69 13 238 212 59 41 234 205 147 22 234 73 210 196 81 199 54 101 251 144 1 235 132 133 122 130 52 115 212 129 125 189 33 142 0 235 13 11 245 13 210 34 80 251 183 20 71 81 143 89 168 199 136 130 106 240 40 65 101 90 13 71 45 212 163 228 0 42 175 127 35 111 24 22 176 222 178 80 223 130 123 47 227 73 116 64 180 118 18 13 137 77 32 216 111 184 48 85 10 99 86 174 211 58 96 93 105 2 214 222 111 80 177 87 175 214 49 185 211 99 167 121 13 81 97 99 70 74 102 20 155 161 8 71 157 23 209 181 38 176 147 120 187 236 182 43 247 87 250 210 102 205 14 167 110 54 245 250 62 169 22 78 249 73 53 209 71 80 71 189 225 99 75 175 31 19 131 163 22 70 112 210 91 44 119 210 11 198 198 160 191 102 239 21 254 154 189 23 174 142 48 212 244 149 146 94 223 111 97 6 64 63 162 47 112 131 98 220 95 29 111 120 243 29 139 161 119 224 242 3 67 77 95 138 176 189 188 3 213 144 186 211 0 88 135 45 212 195 112 245 128 247 154 186 146 0 88 167 44 212 83 112 115 96 48 109 140 78 14 6 188 252 33 84 67 234 50 0 96 189 103 161 190 7 123 246 201 180 209 135 108 167 141 135 49 43 167 182 202 1 75 100 47 120 129 29 109 204 13 211 59 221 118 218 120 116 36 163 140 42 239 184 133 122 28 246 145 135 243 208 40 106 127 218 232 30 206 40 35 233 112 32 217 60 142 42 79 237 234 2 214 71 22 234 71 112 201 148 59 101 234 242 41 76 133 114 173 249 80 46 220 57 102 168 233 187 200 189 126 247 171 194 95 221 175 194 53 2 142 154 186 94 208 235 59 253 182 232 245 244 219 112 115 155 107 40 117 163 187 215 247 218 17 129 250 218 17 254 141 11 238 160 147 44 175 79 110 254 244 83 11 8 190 113 17 250 13 148 196 189 188 243 67 120 95 70 175 131 123 235 12 118 119 200 189 188 11 238 102 173 56 13 80 5 222 170 16 11 13 255 7 0 0 0 13 0 20 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 114 115 114 99 115 114 99 0 0 0 0 0 0 0 0 69 182 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 48 145 0 0 74 116 0 0 0 0 255 255 255 255 114 115 114 99 82 83 69 68 1 0 180 207 51 128 181 83 204 37 0 0 1 161 0 0 0 0 0 0 1 93 0 0 0 0 155 41 0 0 0 0 0 0 0 0 94 52 17 0 8 28 92 231 16 196 213 0 249 239 203 63 53 255 174 249 143 205 223 56 127 207 184 39 243 231 142 27 27 119 85 156 63 110 112 190 167 227 138 231 59 37 223 164 124 129 124 59 230 189 39 95 225 188 187 230 189 54 111 147 188 35 242 28 150 231 177 60 9 121 118 245 190 158 39 201 123 132 247 69 111 45 239 142 185 159 240 182 200 125 104 238 55 115 247 207 125 77 238 216 220 3 114 93 148 187 82 174 109 114 189 144 107 131 92 59 231 188 38 87 243 156 219 230 156 158 179 114 206 227 114 92 155 179 99 14 153 227 205 28 13 114 92 26 251 118 142 93 99 175 202 209 51 118 155 28 27 196 214 142 189 33 230 197 216 61 99 206 140 237 22 179 105 140 138 201 23 115 142 103 66 76 154 39 45 102 67 207 198 158 219 209 205 158 157 209 97 158 205 80 71 79 28 242 162 155 225 2 180 3 164 160 120 40 4 143 57 43 90 175 175 193 118 13 27 110 215 96 51 207 44 195 22 41 163 141 107 214 28 60 120 176 47 195 145 231 128 103 131 224 150 89 148 12 196 129 244 172 212 8 195 131 106 251 26 146 244 104 26 201 153 237 99 33 103 128 167 40 137 70 211 35 41 68 70 56 171 57 164 70 166 177 242 225 204 45 29 123 54 160 124 51 59 4 34 233 52 115 254 89 9 207 230 59 107 195 162 142 66 245 137 53 135 186 150 7 15 228 129 173 149 154 61 211 85 70 171 55 218 144 209 206 210 210 36 0 0 13 13 14 83 113 117 101 97 107 80 80 67 46 112 114 111 106 114 46 112 114 111 106 116 0 0 0 0 0 0 0 0 0 0 88 78 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 72 167 0 0 0 0 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 181 84 10 116 0 0 41 201 0 0 56 0 0 0 9 153 0 0 12 93 31 220 212 40 0 0 0 0 0 0 157 98 13 192 85 103 41 91 153 39 187 189 178 119 179 77 123 60 219 108 34 63 175 149 221 62 22 225 81 66 201 237 99 107 103 207 105 114 42 83 78 79 230 101 251 216 37 158 26 158 211 243 216 58 97 171 85 180 222 90 107 179 50 143 60 247 8 35 156 108 178 89 100 159 132 146 103 251 200 102 17 70 248 185 143 236 1 217 140 60 39 148 236 163 132 18 86 39 217 236 200 102 71 216 102 219 142 214 145 231 100 159 100 179 188 253 18 70 120 140 176 109 12 15 124 117 37 167 89 94 70 183 180 232 183 70 120 199 140 176 77 110 235 102 155 252 38 191 201 38 155 225 201 6 198 159 166 151 7 224 1 48 0 152 183 18 96 46 254 77 235 195 234 201 79 63 200 64 125 35 10 183 57 213 83 248 127 179 97 235 34 135 250 154 118 90 158 83 187 190 85 150 214 121 60 46 71 52 22 9 128 128 213 221 110 79 141 171 126 89 25 131 74 75 127 246 100 59 94 63 23 187 215 52 207 130 44 255 139 0 183 134 102 47 117 168 191 222 245 100 101 217 189 230 21 91 119 61 91 52 19 51 211 42 194 106 199 34 7 216 240 111 197 255 184 229 123 255 108 174 254 29 216 214 90 87 108 165 187 81 243 211 53 222 234 197 153 85 39 242 79 169 209 229 107 150 183 46 6 200 228 216 50 249 151 145 2 75 228 246 71 70 38 6 44 175 3 168 248 13 203 155 135 55 4 48 211 61 78 37 157 77 246 239 227 89 163 150 66 200 138 74 190 117 82 179 124 129 75 45 198 235 247 29 202 198 208 197 251 19 106 55 42 113 57 228 10 74 138 34 43 239 66 152 243 14 83 23 195 12 2 22 50 97 102 27 158 174 212 28 10 1 81 96 207 26 6 68 37 49 98 115 75 62 177 186 86 68 137 16 93 139 92 11 22 56 190 219 95 197 169 181 153 118 208 207 43 216 54 150 45 60 112 182 14 182 254 96 23 15 132 245 92 37 7 100 162 148 169 201 180 170 50 10 74 205 208 142 20 59 118 0 44 85 233 211 25 204 54 187 35 97 201 23 25 66 154 1 5 96 97 63 20 18 189 231 115 193 225 105 10 98 199 228 227 194 115 194 126 211 73 74 23 119 2 251 89 22 38 166 81 31 127 158 179 115 225 100 178 243 214 96 216 239 22 96 172 8 26 48 191 250 204 83 208 112 235 171 90 14 160 19 160 193 153 248 229 25 252 159 112 38 156 137 158 35 115 87 35 219 185 112 8 43 111 198 51 160 202 1 171 114 182 127 237 5 104 184 173 2 86 191 177 22 18 71 15 64 226 225 54 103 226 73 11 191 147 216 18 208 144 104 248 68 155 179 157 234 57 219 191 122 20 62 247 139 47 245 99 193 76 226 145 111 234 20 39 57 79 192 43 122 79 16 190 190 70 111 223 51 195 217 254 44 222 214 241 193 164 53 112 8 255 103 241 60 252 10 52 44 125 25 207 223 227 88 246 113 204 175 195 14 206 244 36 172 138 136 177 155 132 220 34 20 22 212 149 218 214 104 52 18 139 23 81 95 59 129 5 94 59 0 246 156 125 48 113 103 65 170 249 22 106 140 96 85 22 56 190 24 236 43 94 198 255 161 22 245 143 78 204 223 66 82 0 246 201 11 49 119 10 255 54 152 212 238 197 250 157 115 32 35 3 243 226 91 245 17 223 113 143 150 95 24 103 11 126 210 161 248 98 126 152 90 138 93 61 121 33 87 148 192 9 236 3 228 135 215 31 135 245 137 143 188 148 30 204 126 125 179 243 137 239 196 49 131 77 64 120 78 60 3 246 153 187 89 169 213 131 185 195 136 111 27 239 243 137 59 31 212 234 35 31 84 223 62 43 170 35 200 131 89 164 20 172 6 132 233 69 110 57 30 139 220 39 199 214 41 98 109 92 10 55 73 177 38 177 202 223 24 147 98 27 139 220 181 85 162 171 8 43 237 63 98 129 199 178 142 191 180 5 171 91 180 51 53 71 1 222 252 249 155 106 87 254 183 181 28 94 121 44 16 197 106 249 106 215 103 238 31 168 119 100 97 127 61 179 13 239 84 168 93 183 19 163 120 231 216 62 230 57 221 73 255 172 14 223 90 96 75 14 168 93 83 191 8 185 254 42 245 96 219 54 58 179 187 243 2 88 115 143 218 141 221 130 117 176 170 7 230 213 61 7 83 247 110 83 187 55 175 85 187 183 36 240 126 39 42 68 195 233 14 204 60 78 184 56 243 22 172 68 127 170 182 74 107 6 251 175 192 76 14 67 55 24 85 254 240 58 57 118 94 157 71 43 192 148 110 182 255 224 17 252 219 54 131 80 174 30 62 197 189 67 198 11 7 23 131 112 172 0 166 21 123 60 85 105 187 145 227 41 43 23 151 133 72 141 8 234 249 251 36 134 197 209 104 240 166 173 34 28 110 119 85 201 40 31 40 4 67 124 80 184 61 85 229 6 1 56 234 93 40 130 70 0 188 214 212 214 12 0 252 16 135 183 108 165 215 228 104 108 241 245 244 244 0 235 126 130 95 60 182 157 171 148 243 145 0 234 183 169 212 90 34 5 131 145 72 88 172 144 131 92 92 63 82 40 192 177 173 123 160 99 126 33 236 42 58 64 87 8 135 224 240 13 227 181 186 235 53 103 59 216 29 26 142 12 135 111 193 2 67 0 28 38 135 111 152 144 191 227 72 122 138 155 188 70 135 128 92 195 33 183 13 19 242 65 104 253 218 242 223 126 181 245 226 24 97 99 2 226 240 72 138 79 10 94 34 86 227 53 42 13 60 243 252 19 135 111 136 217 52 175 100 66 9 135 153 112 188 175 68 87 113 8 142 11 62 170 47 76 53 242 253 87 250 85 25 214 105 51 210 80 172 132 184 78 243 251 239 232 244 74 87 245 168 143 177 81 145 97 135 6 208 20 241 181 254 79 130 184 255 136 41 177 17 211 48 134 67 105 9 54 166 235 164 125 39 133 18 111 53 8 192 65 145 225 192 46 249 15 175 30 234 69 205 145 223 81 120 151 177 129 35 255 107 135 25 55 56 114 164 254 221 26 215 29 249 32 14 195 0 71 94 93 82 41 142 242 225 246 212 167 249 48 250 112 246 239 177 122 221 217 143 224 184 230 236 71 113 140 57 251 81 94 199 156 125 26 135 241 130 179 31 224 227 95 206 126 144 216 15 157 125 26 199 152 179 31 128 113 195 217 143 224 48 14 112 246 25 14 69 110 126 95 167 1 58 110 57 131 83 17 5 80 50 7 245 185 179 95 167 203 185 78 27 127 56 242 247 26 255 186 35 191 164 176 134 1 142 188 222 31 94 242 73 177 173 240 142 127 59 114 203 63 28 21 2 29 86 142 171 142 106 4 199 53 39 52 202 199 152 19 74 227 184 170 244 3 56 110 40 253 8 14 147 99 68 21 199 33 14 20 134 81 235 126 83 129 82 56 130 254 33 89 236 123 249 184 212 105 132 35 210 136 131 76 151 112 84 55 6 210 56 178 221 131 227 34 87 20 113 156 219 237 170 48 4 104 138 191 189 85 140 67 182 120 199 95 198 129 74 22 28 242 172 19 9 7 141 38 138 174 72 40 234 15 190 205 126 82 57 176 227 229 123 13 1 120 189 169 28 41 79 63 242 54 112 21 71 90 161 211 125 150 82 214 248 80 155 93 13 51 78 251 241 132 176 225 131 185 199 204 64 164 37 28 146 66 131 179 169 151 3 17 50 58 8 56 97 104 240 18 212 8 198 47 61 208 27 83 104 110 182 183 47 250 50 52 139 74 157 162 101 115 32 11 51 252 167 223 239 6 156 108 29 157 0 190 28 75 49 180 215 126 150 88 121 126 178 246 70 16 158 222 228 197 73 99 196 121 190 104 33 100 39 201 71 58 43 100 169 73 142 41 99 150 195 10 38 62 105 204 213 21 255 47 246 141 164 191 221 87 70 62 113 207 61 74 92 138 241 7 70 227 134 160 54 182 131 73 208 101 145 37 119 6 80 144 86 246 10 35 116 129 153 15 190 27 126 48 206 166 240 109 9 23 66 219 11 81 231 246 196 252 33 197 31 22 233 236 143 251 55 252 101 225 129 33 73 236 37 149 159 160 245 129 88 231 38 251 67 123 50 104 75 70 42 202 139 107 189 154 183 41 250 10 190 136 191 138 87 240 49 214 198 103 195 141 14 26 247 45 23 52 176 109 129 180 75 232 221 122 49 26 130 21 107 225 108 188 254 25 190 132 125 190 171 186 180 108 190 56 191 180 216 91 140 71 207 50 151 119 190 209 74 11 88 245 37 44 122 244 239 149 201 154 217 6 121 167 241 74 62 251 41 8 209 58 254 202 56 45 26 195 39 197 153 48 175 214 91 51 27 43 126 163 175 126 118 49 127 162 227 110 99 213 143 128 182 54 228 80 238 238 7 128 222 105 166 80 174 242 81 160 153 64 218 91 0 173 31 133 207 226 113 55 229 38 120 161 25 143 180 81 2 102 205 5 196 202 42 41 151 245 123 120 8 115 168 188 0 155 122 128 54 13 252 152 114 210 31 224 41 238 211 49 2 27 224 235 92 221 48 214 109 135 167 49 199 183 90 76 217 9 63 192 92 27 239 246 231 225 121 204 125 153 114 158 111 193 97 124 136 123 134 114 85 54 232 65 90 17 23 192 67 47 193 111 49 199 177 230 239 2 220 253 49 125 18 229 214 111 162 206 152 142 219 35 0 166 238 96 19 49 199 223 157 154 34 44 31 115 124 198 49 103 49 195 5 12 51 56 199 119 122 217 167 48 87 67 185 130 63 49 156 21 156 193 31 204 107 87 49 55 128 200 77 165 251 40 107 192 28 118 26 114 89 194 208 112 136 252 169 118 201 23 24 206 210 204 114 80 110 90 55 219 4 240 113 254 62 61 249 12 123 20 87 83 240 222 250 196 118 134 60 206 46 228 77 183 143 182 106 204 229 53 62 150 160 156 192 247 46 228 122 208 197 200 190 184 136 125 171 248 35 225 60 183 212 236 247 137 46 41 122 238 233 24 159 126 146 23 181 151 244 137 169 11 58 134 28 62 94 208 91 113 60 13 160 184 34 77 242 157 114 216 146 26 70 225 215 244 138 185 250 72 85 178 100 50 95 47 197 194 254 112 179 98 46 107 242 199 35 177 140 242 72 56 158 147 100 170 172 45 30 147 148 92 87 171 18 143 132 196 187 228 141 247 69 98 77 138 181 216 231 147 145 47 143 20 111 81 204 94 41 214 44 199 173 37 173 254 96 147 94 48 187 206 133 43 70 228 120 107 116 60 205 170 234 196 216 40 87 234 87 144 106 57 212 136 20 88 82 131 172 188 78 146 91 109 4 35 73 148 158 238 229 201 85 238 198 98 227 249 187 152 14 140 114 103 129 165 118 86 100 81 10 7 130 120 61 29 160 85 27 141 70 254 194 114 208 138 83 89 189 88 255 15 13 0 235 49 243 123 191 183 65 94 94 49 203 137 93 167 220 188 206 236 51 53 7 121 157 178 91 153 30 27 52 241 241 108 61 233 133 231 212 180 240 95 103 109 178 159 145 219 231 17 70 182 228 54 121 78 54 25 109 50 224 132 69 246 128 236 99 94 183 217 69 55 97 228 56 57 78 184 155 112 178 89 100 194 201 62 50 96 132 187 9 27 117 132 237 83 194 47 194 8 119 159 132 71 184 251 216 1 247 22 243 18 127 244 211 207 99 158 199 233 17 78 216 37 25 176 139 76 56 185 77 70 43 217 43 89 129 15 15 148 131 46 159 170 6 8 33 14 248 159 73 200 99 63 135 255 3 208 115 195 127 22 252 191 11 213 18 226 132 111 245 134 34 134 177 127 198 25 168 9 105 255 247 38 86 219 63 39 195 43 254 6 239 103 45 31 241 254 199 197 206 55 255 89 133 95 83 94 162 120 240 109 118 201 206 183 41 222 232 253 203 78 208 79 161 79 121 179 241 232 127 49 153 154 245 46 159 232 146 215 252 118 43 249 177 243 133 249 59 175 225 229 0 220 83 206 167 127 116 133 124 76 70 1 129 175 145 121 228 109 248 110 130 201 133 131 142 68 72 174 18 52 100 45 84 226 235 167 181 243 87 135 117 89 251 249 182 159 192 20 171 177 46 194 186 2 235 114 168 95 130 122 54 214 247 99 61 7 235 185 88 87 98 93 133 245 172 14 207 145 163 80 63 242 198 162 209 43 160 94 222 177 118 101 16 234 149 29 149 103 214 64 253 86 148 191 2 189 169 180 220 93 230 114 107 74 163 126 131 197 23 50 62 240 247 39 112 33 66 38 218 252 229 235 77 149 74 64 254 146 62 242 100 198 3 254 244 14 207 229 99 195 60 58 178 29 185 192 194 116 155 199 41 122 147 75 242 149 234 173 65 223 16 159 223 181 120 204 105 127 253 149 210 78 62 199 183 205 186 72 251 5 251 102 239 62 210 201 111 126 251 9 195 9 117 46 212 57 157 124 231 181 191 248 87 138 147 230 125 25 206 35 248 207 70 92 91 7 50 232 224 195 17 61 95 102 2 152 102 235 96 2 211 65 185 162 201 62 67 213 90 19 146 190 47 165 131 204 13 252 223 242 129 102 71 4 216 91 96 243 63 141 241 191 70 109 213 13 197 215 80 26 244 123 165 29 1 217 232 213 193 86 139 255 82 228 71 232 224 161 182 131 85 180 191 13 191 155 135 190 240 48 126 103 251 197 152 182 3 159 119 249 70 53 126 183 38 166 163 37 56 135 208 211 90 196 179 117 53 22 113 198 225 28 105 157 45 181 116 86 139 253 184 222 74 112 190 237 160 187 15 254 231 191 144 131 64 119 235 100 163 69 213 26 110 4 137 85 150 238 132 174 132 158 132 142 34 109 175 239 255 28 234 214 246 79 94 161 42 183 115 198 252 155 122 16 58 152 140 120 54 255 133 191 123 243 194 18 168 39 236 63 245 219 48 212 62 208 193 241 17 29 252 205 65 147 246 163 81 255 241 200 154 34 5 192 125 92 213 229 213 110 85 235 243 159 199 176 126 6 121 17 122 152 136 125 225 71 143 99 93 220 246 151 79 174 251 211 19 223 250 211 70 244 131 187 62 181 5 113 227 126 181 9 231 176 125 203 139 223 63 135 245 138 246 243 127 252 105 167 126 23 32 191 155 17 47 157 35 108 159 179 253 237 89 228 199 246 57 9 244 125 26 234 29 80 159 29 209 249 203 142 61 160 210 133 182 206 243 184 206 213 112 208 63 180 187 248 142 229 119 139 144 55 161 243 184 174 109 29 63 128 250 141 235 57 173 219 197 136 99 235 245 65 252 78 248 105 60 111 8 125 46 196 250 86 254 72 231 14 63 232 240 228 136 14 183 58 182 131 138 230 246 237 47 64 135 155 149 160 95 109 25 20 162 43 166 195 184 111 10 93 173 195 122 74 219 254 95 210 122 61 226 196 243 137 173 63 91 111 110 156 215 211 254 193 156 189 157 122 219 112 51 207 216 57 90 228 187 123 98 249 70 232 236 219 253 22 213 151 162 251 134 247 67 79 101 124 216 111 189 71 254 12 211 23 246 229 210 117 82 163 236 255 146 64 35 227 1 127 205 29 181 255 253 97 31 143 97 240 191 75 183 245 56 81 111 90 31 240 179 220 49 68 233 163 25 44 246 165 35 228 193 239 123 25 31 248 251 21 249 13 181 63 155 191 66 189 105 147 162 25 97 41 0 177 99 167 18 148 227 28 62 157 241 128 191 212 30 112 180 63 168 13 47 213 41 16 214 34 143 138 28 26 207 153 51 176 158 106 229 162 153 216 191 23 107 123 95 24 223 103 77 194 122 58 214 211 172 60 35 246 54 34 71 218 251 26 225 51 156 246 171 58 101 171 224 157 108 23 28 8 215 43 193 184 24 234 51 30 232 84 236 115 227 62 243 7 114 24 166 31 111 243 55 110 213 210 242 33 226 240 39 238 46 50 23 240 119 135 183 130 85 138 177 42 96 12 83 167 100 108 224 45 230 23 121 195 78 193 127 187 50 30 240 38 246 223 119 253 162 178 210 251 149 95 188 152 105 194 47 10 43 3 170 100 148 106 154 212 58 68 159 150 105 194 47 166 138 19 3 126 95 144 224 78 205 120 192 155 216 219 223 209 221 248 26 73 171 151 171 225 248 170 94 214 110 4 241 239 103 154 240 139 137 46 201 208 148 200 210 200 178 148 219 133 50 78 228 11 118 9 48 98 208 77 25 15 120 19 251 239 59 252 21 240 147 134 97 6 233 29 100 102 3 254 196 222 254 27 254 84 95 195 13 159 22 191 134 140 7 252 137 251 146 59 252 229 243 173 217 176 129 52 102 60 224 79 236 235 239 230 211 103 149 208 87 249 52 152 177 193 183 43 73 213 168 191 67 13 215 170 252 231 100 27 181 60 26 145 180 58 201 39 215 40 59 110 240 38 246 111 177 57 114 32 183 236 76 141 192 225 98 115 56 248 28 249 46 79 77 81 89 137 219 93 86 50 52 77 205 16 31 5 174 205 101 181 225 160 161 52 202 67 131 8 220 216 28 227 67 154 90 7 171 19 141 50 18 72 14 66 239 160 163 188 142 97 58 219 16 166 97 26 232 72 137 228 121 107 14 49 151 99 44 250 100 83 88 150 26 138 54 185 138 150 175 88 155 156 163 165 75 187 43 153 234 210 90 111 223 240 222 74 199 110 221 8 239 160 29 226 228 168 105 101 91 168 163 56 106 90 127 237 231 15 191 234 216 237 114 215 128 127 29 126 149 100 113 212 180 218 224 166 228 13 68 133 14 236 118 25 106 122 23 124 224 7 206 119 28 187 189 21 91 188 180 67 178 145 87 111 107 72 214 75 186 239 186 187 102 165 251 88 134 202 58 57 28 117 82 153 26 244 43 134 162 6 217 134 92 83 173 9 216 118 153 163 210 78 46 71 29 231 82 34 178 223 165 250 229 232 188 108 135 204 81 105 103 12 71 205 173 104 150 131 70 130 34 182 185 102 168 172 51 22 103 101 78 227 215 164 150 40 48 219 79 115 84 218 25 135 202 51 81 189 114 196 232 69 102 91 106 134 202 58 121 28 117 204 122 207 70 67 9 12 80 100 105 40 31 121 117 201 141 244 118 55 206 43 219 172 11 53 56 73 1 234 149 110 48 147 122 181 24 26 47 52 164 105 42 44 128 6 52 68 175 0 184 26 104 7 115 105 46 72 219 91 230 30 64 165 187 121 238 40 180 67 38 162 242 74 67 161 128 236 149 2 13 81 96 139 161 66 62 235 132 82 191 95 147 117 125 75 141 68 109 165 7 154 222 3 240 89 105 135 76 194 89 107 101 93 13 107 190 184 34 172 89 39 11 207 211 164 208 109 13 77 65 149 175 150 117 67 10 244 185 2 106 136 94 72 112 13 209 206 84 68 173 84 3 126 186 123 139 161 90 179 222 131 188 122 225 169 137 164 167 88 168 211 4 42 152 214 109 212 233 232 13 30 159 166 132 6 104 181 81 239 69 167 132 20 21 72 170 207 66 157 33 212 160 68 104 144 186 169 134 153 168 215 106 159 26 188 173 215 251 208 81 82 55 242 29 158 236 113 220 81 104 7 46 56 121 58 76 93 124 2 86 133 137 90 65 102 113 212 44 189 41 65 15 67 61 114 84 160 194 61 82 209 74 150 139 179 27 147 82 160 9 128 238 64 120 2 160 157 217 28 53 71 55 252 138 154 76 108 116 3 34 80 95 34 247 115 212 92 64 133 40 153 72 27 221 168 115 76 84 77 9 214 223 66 157 139 188 178 188 59 200 107 23 234 60 244 134 114 185 89 25 112 242 158 140 50 31 61 207 173 169 0 170 223 76 0 11 208 81 184 192 7 40 98 215 175 124 86 218 41 230 168 121 101 106 99 72 13 14 164 81 11 117 33 162 178 89 171 131 161 112 212 99 45 212 69 28 53 159 165 168 68 244 181 120 125 128 163 102 87 208 149 65 66 121 86 86 126 16 25 2 80 26 56 118 168 145 126 108 107 214 197 28 181 96 157 106 40 117 138 47 154 215 122 80 75 80 229 252 136 55 161 242 238 92 254 16 71 29 11 251 6 67 83 7 34 182 133 186 68 236 108 228 96 56 153 27 44 212 135 133 15 193 6 92 173 191 197 208 82 100 136 102 175 10 216 137 196 96 45 53 44 195 89 61 204 95 111 165 195 71 120 218 24 171 55 129 30 234 148 184 47 211 221 39 79 27 180 3 55 162 12 53 125 83 122 104 95 241 175 57 42 237 144 229 28 117 178 222 228 14 72 70 157 170 53 122 66 178 143 10 254 218 212 116 191 138 201 6 58 240 222 1 67 77 191 143 0 217 9 211 60 237 144 21 34 137 50 192 100 218 128 183 4 48 55 64 231 113 76 162 224 202 141 183 147 232 19 28 181 176 172 214 197 199 141 198 14 11 245 73 206 107 250 29 157 14 207 232 207 4 175 163 63 131 87 104 24 106 250 213 26 208 64 150 169 134 44 184 177 22 179 14 222 100 31 108 222 120 144 163 210 14 92 210 114 87 78 93 222 30 218 183 120 143 80 249 226 61 112 191 202 213 144 186 119 165 219 115 100 8 58 4 182 162 81 212 110 13 89 168 165 166 94 253 114 165 38 213 55 70 179 141 165 188 85 38 175 131 47 143 128 114 22 153 26 90 68 202 120 18 205 147 130 186 178 45 36 105 160 133 235 174 98 37 236 114 145 122 149 93 242 182 196 70 196 202 175 21 152 122 131 225 64 194 187 122 102 173 228 168 99 154 165 109 1 69 31 24 214 154 117 53 71 205 241 43 205 73 130 236 89 171 112 214 22 223 78 73 75 224 90 179 86 163 43 175 149 181 160 156 96 214 202 229 107 56 234 36 180 132 138 136 79 14 209 132 104 9 208 82 249 90 145 41 225 138 191 86 174 7 65 244 111 70 173 89 107 56 175 233 107 137 246 127 252 194 139 251 114 232 192 27 17 166 191 222 120 83 162 195 115 206 220 217 156 59 74 214 137 253 43 36 209 219 187 168 245 168 161 26 181 5 214 189 9 13 117 103 74 55 206 234 86 91 100 45 153 95 187 213 176 1 81 97 159 39 133 190 102 168 22 81 233 81 70 114 86 11 213 131 169 87 92 42 196 128 217 235 23 220 81 104 199 203 81 167 152 87 32 209 133 138 181 47 223 136 137 173 186 81 170 103 136 116 79 220 187 115 176 80 55 113 212 252 13 229 235 235 234 116 159 38 203 215 151 20 54 175 155 209 135 60 134 20 244 75 154 159 230 181 225 221 198 22 177 209 87 155 149 228 114 222 98 232 25 142 58 166 52 160 72 3 251 171 158 89 159 69 189 110 82 252 114 114 11 104 121 195 115 28 117 130 169 60 87 88 183 146 124 31 67 207 227 78 52 117 181 243 251 234 18 188 125 161 29 120 3 79 36 182 193 55 243 14 205 61 254 8 38 81 232 192 75 93 157 155 131 196 203 94 144 238 230 153 57 111 30 217 102 238 14 245 134 85 137 93 143 165 161 237 124 214 232 117 239 213 17 232 205 173 152 21 174 111 37 84 67 231 141 231 245 113 1 235 180 137 122 154 236 64 53 92 187 172 236 197 5 172 179 38 234 89 226 19 168 93 247 140 253 168 199 77 212 227 196 143 201 166 235 138 176 143 34 192 58 105 162 158 36 50 166 249 158 183 20 172 52 15 47 28 152 168 31 194 75 141 220 243 82 47 59 118 120 157 255 66 84 232 192 59 12 177 89 173 125 131 231 242 57 115 214 115 240 250 1 67 77 191 150 0 88 199 76 212 99 240 246 0 215 80 234 173 2 192 218 107 162 238 133 203 121 62 107 234 210 30 176 46 152 168 23 224 158 180 79 175 253 179 158 48 81 79 192 21 109 159 55 244 163 118 249 80 99 159 202 251 243 235 229 83 38 234 41 184 184 228 188 166 46 52 1 235 11 19 245 11 184 107 79 58 229 213 1 44 111 8 113 212 244 21 55 96 93 52 81 47 194 77 116 143 191 70 47 48 46 159 49 81 207 192 139 1 220 81 82 47 12 0 214 167 38 234 167 68 199 89 7 220 174 223 81 12 51 217 12 190 54 212 225 185 180 90 160 94 90 77 194 215 81 251 189 252 146 57 235 37 210 204 81 39 132 112 251 90 34 71 66 176 66 213 109 84 120 111 8 81 161 3 247 142 232 13 67 247 145 224 197 47 59 118 151 186 221 53 180 67 34 120 7 0 201 171 74 150 6 206 149 216 91 88 60 83 210 78 43 38 236 171 168 176 129 233 69 101 47 103 237 118 185 202 170 88 103 87 175 242 98 42 127 223 84 195 251 240 62 1 67 77 191 103 0 88 31 153 168 252 141 92 226 128 183 122 137 211 237 145 235 175 92 49 129 224 27 120 164 11 190 129 146 228 204 106 121 7 250 240 134 219 204 215 220 53 58 123 35 42 103 86 228 63 240 124 230 91 240 8 226 69 119 101 128 201 238 255 0 0)! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/25/2000 18:30'!macAsyncFilePrimsFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "AsynchFilePlugin.h"/* initialize/shutdown */int asyncFileInit() { return true; }int asyncFileShutdown() {}/* End of adjustments for pluginized VM *//*  Experimental support for asynchronous file reading and writing.  When a read or write operation is initiated, control is returned to Squeak  immediately. A semaphore is signaled when the operation completes, at which  time the client can find out how many bytes were actually read or written  and copy the results of the read operation from the file buffer into a Squeak  buffer. Only one operation may be in progress on a given file at a given time,  but operations on different files may be done in parallel.  The semaphore is signalled once for each transfer operation that is successfully  started, even if that operation later fails. Write operations always write  their entire buffer if they succeed, but read operations may transfer less than  their buffer size if they are started less than a buffer''s size from the end  of the file.    The state of a file is kept in the following structure, which is stored directly  in a Squeak ByteArray object:    typedef struct {	  int				sessionID;	  AsyncFileState	*state;    } AsyncFile;  The session ID is used to detect stale files--files that were open  when the image was saved. The state pointer of such files is meaningless.  Async file handles use the same session ID as ordinary file handles.  Note: These primitives are experimental!! They need not be implemented on  every platform, and they may be withdrawn or replaced in a future release.*/#include <Errors.h>#include <Files.h>#include <Strings.h>/* Async file handle (defined in header file):*/typedef struct {	ParamBlockRec pb;  /* must be first */	long	refNum;	int		writable;	int		semaIndex;	int		status;	int		bytesTransferred;	int		bufferSize;	char 	*bufferPtr;} AsyncFileState;/*** Status Values ***/#define IDLE			0#define LAST_OP_FAILED	1#define BUSY			2/*** Imported Variables ***/extern int successFlag;extern int thisSession;/*** Local Vaiables ***/IOCompletionUPP asyncFileCompletionProc = nil;/*** Exported Functions ***/int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** Local Functions ***/int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount);int asyncFileCompletionRoutine(AsyncFileState *state);int asyncFileInitPB(AsyncFileState *state, int fPosition);int asyncFileValid(AsyncFile *f);int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount) {  /* Allocate a new buffer of the given size if necessary. If the current buffer	 is already allocated and of the desired size, do nothing. */	if ((state->bufferPtr !!= nil) && (state->bufferSize == byteCount)) {		return;  /* buffer is already allocated and of the desired size */	}	/* free old buffer, if any */	if (state->bufferPtr !!= nil) {		DisposePtr(state->bufferPtr);		state->bufferSize = 0;		state->bufferPtr = nil;	}	/* allocate new buffer */	state->bufferPtr = NewPtr(byteCount);	if (state->bufferPtr == nil) {		state->bufferSize = 0;		return success(false);  /* could not allocate a buffer of size count */	}	state->bufferSize = byteCount;}int asyncFileCompletionRoutine(AsyncFileState *state) {  /* Called when an I/O request completes. Decides what to do based on the given state.	 Note that the first part of the state record is the I/O parameter block. */	OSErr err;	err = state->pb.ioParam.ioResult;	if ((err !!= noErr) && (err !!= eofErr)) {		/* Note: eofErr indicates that fewer than the count bytes were transfered when		   reading because the end-of-file was encountered first; it isn''t a real error. */		state->status = LAST_OP_FAILED;		state->bytesTransferred = 0;		signalSemaphoreWithIndex(state->semaIndex);		return;	}	state->bytesTransferred = state->pb.ioParam.ioActCount;	state->status = IDLE;	signalSemaphoreWithIndex(state->semaIndex);}int asyncFileInitPB(AsyncFileState *state, int fPosition) {	memset(&state->pb, 0, sizeof(ParamBlockRec));	state->pb.ioParam.ioCompletion = asyncFileCompletionProc;	state->pb.ioParam.ioRefNum = state->refNum;	state->pb.ioParam.ioBuffer = state->bufferPtr;	state->pb.ioParam.ioReqCount = state->bufferSize;	state->pb.ioParam.ioPosMode = fsFromStart;	state->pb.ioParam.ioPosOffset = (fPosition < 0) ? 0 : fPosition;	state->status = BUSY;	state->bytesTransferred = 0;}int asyncFileValid(AsyncFile *f) {	return (		(f !!= NULL) &&		(f->sessionID == thisSession) &&		(f->state !!= NULL) &&		(((AsyncFileState *) f->state)->refNum !!= 0));}/*** Exported Functions ***/int asyncFileClose(AsyncFile *f) {  /* Close the given asynchronous file. */	AsyncFileState *state;	short int volRefNum;	OSErr err;	if (!!asyncFileValid(f)) return;  /* already closed */	state = f->state;	err = GetVRefNum(state->refNum, &volRefNum);	success(err == noErr);	err = FSClose(state->refNum);	success(err == noErr);	if (successFlag) err = FlushVol(NULL, volRefNum);	success(err == noErr);	if (state->bufferPtr !!= nil) DisposePtr(state->bufferPtr);	DisposePtr((void *) f->state);	f->state = nil;	f->sessionID = 0;}int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex) {  /* Opens the given file using the supplied AsyncFile structure to record	 its state. Fails with no side effects if f is already open. Files are	 always opened in binary mode. */	int i;	char cFileName[256];	unsigned char *pFileName;	short int fileRefNum;	ParamBlockRec pb;	AsyncFileState *state;	OSErr err;	/* don''t open an already open file */	if (asyncFileValid(f)) return success(false);	/* build complete routine descriptor, if necessary */	if (asyncFileCompletionProc == nil) {		asyncFileCompletionProc = NewIOCompletionProc(asyncFileCompletionRoutine);	}	/* copy the file name into a null-terminated C string */	if (fileNameSize > 255) return success(false);	for (i = 0; i < fileNameSize; i++) {		cFileName[i] = *((char *) (fileNamePtr + i));	}	cFileName[fileNameSize] = 0;	pFileName = c2pstr(cFileName);	f->sessionID = 0;	if (writeFlag) {		/* first try to open an existing file read/write: */		err = FSOpen(pFileName, 0, &fileRefNum);		if (err !!= noErr) {			/* file does not exist; must create it. */			err = Create(pFileName, 0, ''TEXT'', ''R*ch'');			if (err !!= noErr) return success(false);			err = FSOpen(pFileName, 0, &fileRefNum);			if (err !!= noErr) return success(false);		}	} else {		/* open the file read-only (use parameter block call to specify read-only): */		memset(&pb, 0, sizeof(ParamBlockRec));		pb.ioParam.ioNamePtr = pFileName;		pb.ioParam.ioPermssn = fsRdPerm;		err = PBOpenSync(&pb);		if (err !!= noErr) return success(false);		fileRefNum = pb.ioParam.ioRefNum;	}	f->state = (AsyncFileState *) NewPtr(sizeof(AsyncFileState));	/* allocate state record */	if (f->state == nil) {		FSClose(fileRefNum);		return success(false);	}	f->sessionID = thisSession;	state = (AsyncFileState *) f->state;	state->refNum = fileRefNum;	state->writable = writeFlag;	state->semaIndex = semaIndex;	state->status = IDLE;	state->bytesTransferred = 0;	state->bufferSize = 0;	state->bufferPtr = nil;}int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize) {  /* Copy up to bufferSize bytes from the buffer of the last read operation	 into the given Squeak buffer, and return the number of bytes copied.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed	Note that a read operation may read fewer bytes than requested if, for	example, there are fewer than the requested number of bytes between the	starting file position of the read operation and the end-of-file. */	AsyncFileState *state;	int bytesRead;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	/* copy the file buffer into the squeak buffer */	bytesRead = (bufferSize < state->bytesTransferred) ? bufferSize : state->bytesTransferred;	memcpy((char *) bufferPtr, state->bufferPtr, bytesRead);	return bytesRead;}int asyncFileReadStart(AsyncFile *f, int fPosition, int count) {  /* Start an asynchronous operation to read count bytes from the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileReadResult() to	 find out if the operation succeeded and to get the data that was read. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, count);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	asyncFileInitPB(state, fPosition);	err = PBReadAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}int asyncFileRecordSize() {	return sizeof(AsyncFile);}int asyncFileWriteResult(AsyncFile *f) {  /* Return the number of bytes copied by the last write operation.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed */	AsyncFileState *state;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	return state->bytesTransferred;}int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize) {  /* Start an asynchronous operation to write bufferSize bytes to the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileWriteResult() to	 find out if the operation succeeded and how many bytes were actually written. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	if (!!state->writable) return success(false);	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, bufferSize);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	/* copy the squeak buffer into the file buffer */	memcpy(state->bufferPtr, (char *) bufferPtr, bufferSize);	asyncFileInitPB(state, fPosition);	err = PBWriteAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/26/2000 10:53'!macBrowserPluginFile	^ '/********** Notes on Browser Plugin VM ************How it Works:The browser plugin VM allows Squeak to be run as a plug-in underversion 4.0 and later of either Netscape Navigator or Internet Explorer.To use it, you must translate a version of interp.c with the browser pluginhooks. These hooks work by causing the VM to save the state of the currentSqueak process and return control from the interpret() after a shortperiod of time (e.g., 1/15th second). This allows the browser to processevents and perform other tasks. Eventually, the browser calls NPP_HandleEvent()with a NULL event, thus re-entering the Squeak interpret loop. The key toefficiency is to not return control to the browser too often, since thebrowser is quite slow to send the next null event. The VM does thisby polling for events itself; if there are no events in the OS queue,then it return control to the browser much less often.Relationship of this file to sqMacWindow.c:One can think of this file as specializing and extending sqMacWindow.cfor running within a browser. Certain methods in  sqMacWindow.c arereplaced by functions defined here. The originals are removed fromsqMacWindow.c by defining the PLUGIN flag in that file when compiling.Here is a list of the functions overridden:	ioExit()	ioScreenSize()	ioSetFullScreen()	sqAllocateMemory()    plugInAllowAccessToFilePath()In addition, ioProcessEvents() becomes a noop and main() is completelyomitted when sqMacWindow.c is compiled for use in the browser plugin VM.**********/#include "sq.h"#include "FilePlugin.h"#include "npapi.h"#include <Events.h>#include <Files.h>#include <Notification.h>#include <Strings.h>/********** Compilation Options:**	DISNEY*	  Define this to build the Disney Online browser plugin. In this*	  case the image file and Squeak file sandbox are located in the*	  Disney Online folder, and the image name is "dolsqueak.image".**	ENABLE_URL_FETCH*	  Define this to compile primitives to fetch URL''s via the browser.**	  Warning: Fetching file URL''s through the URL fetch mechanism allows*	  potentially untrusted code to read files outside of the Squeak*	  file system "sandbox", a serious breach of privacy. Outside*	  of Disney, there are few uses for use for the browser URL fetch*	  mechanism, since you can always fetch URL''s from remote servers*	  using Squeak''s own HTTPSocket.***********///#define DISNEY#ifdef DISNEY# define IMAGE_NAME "dolsqueak.image"# define ENABLE_URL_FETCH#else# define IMAGE_NAME "squeak.image"#endif/*** Exported Primitives ***/#ifdef ENABLE_URL_FETCH#pragma export onint primitivePluginBrowserReady(void);int primitivePluginDestroyRequest(void);int primitivePluginRequestFileHandle(void);int primitivePluginRequestState(void);int primitivePluginRequestURL(void);int primitivePluginRequestURLStream(void);#pragma export off#endif/* Constants */#define MAX_STRING_LENGTH 255#define STATUS_BAD_HANDLE -1#define STATUS_IDLE 0#define STATUS_IN_PROGRESS 1#define STATUS_FAILED 2#define STATUS_SUCCEEDED 3/*** Imported Variables ***/extern int interruptKeycode;extern unsigned char *memory;extern WindowPtr stWindow;extern char documentName[];  /* full path to document file */extern char imageName[];  /* full path to image file */extern char shortImageName[];  /* just the image file name */extern char vmPath[];  /* full path to interpreter''s directory */extern struct VirtualMachine *interpreterProxy;extern int thisSession;  /* from sqFilePrims.c: *//*** Local Variables ***/int			exitRequested	= false;CGrafPort	gSavePort;CGrafPtr	gOldPort		= nil;int			interpStartTime	= 0;int			needsUpdate		= false;NPWindow* 	netscapeWindow	= nil;Str255		notificationMsg = "";NMRec		notifyRec;int			pluginArgCount	= 0;char		*pluginArgName[100];char		*pluginArgValue[100];int			squeakHeapMBytes = 15;  /* default heap size, override via the "memory" EMBED tag */char		squeakPluginImageName[] = IMAGE_NAME;NPP			thisInstance	= nil;#define URL_REQUEST_COUNT 100typedef struct {	int id;  /* used to associate a request with its outcome */	int status;	int semaIndex;	char fileName[MAX_STRING_LENGTH + 1];} URLRequestRecord;URLRequestRecord urlRequests[URL_REQUEST_COUNT];int nextRequestID = 1;/*** Functions Imported from sqMacWindow ***/int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Local Functions ***/int CaseInsensitiveMatch(char *s1, char *s2);void EndDraw(void);void ExitCleanup(void);int FindIdleURLRequest(void);int InitFilePaths(void);void InitURLRequestTable(void);int IsPrefixedBy(char *s, char *prefix);void OpenFileReadOnly(SQFile *f, char *fileName);void ReadSqueakImage(void);void StartDraw(void);int StringToInteger(char *s);void URLRequestCompleted(int notifyData, const char* fileName);int URLRequestCreate(char *url, char *target, int semaIndex);void URLRequestDestroy(int requestHandle);void URLRequestFailed(int notifyData, int reason);char * URLRequestFileName(int requestHandle);int URLRequestStatus(int requestHandle);/*** Initialize/Shutdown ***/NPError NPP_Initialize(void) {	exitRequested = false;	needsUpdate = false;	netscapeWindow = nil;	pluginArgCount = 0;	squeakHeapMBytes = 20;	thisInstance = nil;	InitURLRequestTable();	return NPERR_NO_ERROR;}void NPP_Shutdown(void) {	ExitCleanup();}/*** Instance Create/Destroy ***/NPError NPP_New(NPMIMEType pluginType, NPP instance, uint16 mode,  int16 argc, char* argn[], char* argv[], NPSavedData* saved) {	int i;	/* only Squeak instance can be active at a time */	if (thisInstance !!= nil) return NPERR_GENERIC_ERROR;	for (i = 0; i < 100; i++) {		pluginArgName[i] = pluginArgValue[i] = "";	}	/* record plugin arguments */	pluginArgCount = argc;	for (i = 0; (i < argc) && (i < 100); i++) {		pluginArgName[i] = (char *) NPN_MemAlloc(strlen(argn[i]) + 1);		strcpy(pluginArgName[i], argn[i]);		pluginArgValue[i] = (char *) NPN_MemAlloc(strlen(argv[i]) + 1);		strcpy(pluginArgValue[i], argv[i]);		if (CaseInsensitiveMatch(pluginArgName[i], "memory")) {			squeakHeapMBytes = StringToInteger(pluginArgValue[i]);		}	}	memory = nil;	ReadSqueakImage();	if (!!memory) return NPERR_GENERIC_ERROR;	thisInstance = instance;	return NPERR_NO_ERROR;}NPError NPP_Destroy(NPP instance, NPSavedData** save) {	ExitCleanup();	return NPERR_NO_ERROR;}NPError NPP_SetWindow(NPP instance, NPWindow* window) {	NP_Port* port;	netscapeWindow = window;	port = (NP_Port *) netscapeWindow->window;	stWindow = (WindowPtr) port->port;	needsUpdate	= true;	return NPERR_NO_ERROR;}/*** Streaming ***/NPError NPP_NewStream(  NPP instance, NPMIMEType type,  NPStream *stream, NPBool seekable, uint16 *stype) {  /* Call to load the initial URL and to handle explicit URL fetch requests. */	*stype = NP_ASFILEONLY;  /* ask Netscape to cache file and call NPP_StreamAsFile */	return NPERR_NO_ERROR;}NPError NPP_DestroyStream(NPP instance, NPStream *stream, NPError reason) {	return NPERR_NO_ERROR;}void NPP_StreamAsFile(NPP instance, NPStream *stream, const char* fname) {	if (fname !!= null) {		URLRequestCompleted((int) stream->notifyData, fname);	} else {		URLRequestFailed((int) stream->notifyData, 1);	}}void NPP_URLNotify(NPP instance, const char* url, NPReason reason, void* notifyData) {	if (reason !!= NPRES_DONE) {		URLRequestFailed((int) notifyData, reason);	}}int32 NPP_WriteReady(NPP instance, NPStream *stream) {  /* not used, because we use ASFILEONLY mode */	return 100000;}int32 NPP_Write(NPP instance, NPStream *stream, int32 offset, int32 len, void *buffer) {  /* not used, because we use ASFILEONLY mode */	return len;}/*** Printing ***/void NPP_Print(NPP instance, NPPrint* printInfo) {	/* printing is not supported */}/*** Event Handling ***/int16 NPP_HandleEvent(NPP instance, void *rawEvent) {	EventRecord *eventPtr = (EventRecord*) rawEvent;	if (exitRequested) {		ExitCleanup();		return false;	}	if ((thisInstance == nil) || (eventPtr == NULL)) {		/* no instance or no event; do nothing */		return false;	}	recordModifierButtons(eventPtr);	switch (eventPtr->what) {		case mouseDown:			recordMouseDown(eventPtr);		break;		case keyDown:		case autoKey:			recordKeystroke(eventPtr);		break;		case updateEvt:			needsUpdate = true;		break;		case nullEvent:			/* interpret some bytecodes on every event */			if (memory) {  /* but only if the VM has memory!! */				StartDraw();				interpret();				EndDraw();			}		break;	}	if (needsUpdate && (netscapeWindow !!= nil) && (memory)) {		StartDraw();		fullDisplayUpdate();  /* ask VM to call ioShowDisplay */		EndDraw();		needsUpdate = false;	}	return true;}/*** Drawing ***/void EndDraw(void) {	SetOrigin(gSavePort.portRect.left, gSavePort.portRect.top);	SetClip(gSavePort.clipRgn);	SetPort((GrafPtr) gOldPort);}void StartDraw(void) {	NP_Port* port;	Rect clipRect;	port = (NP_Port *) netscapeWindow->window;	/* save old graphics port and switch to ours */	GetPort((GrafPtr *) &gOldPort);	SetPort((GrafPtr) port->port);	stWindow = (WindowPtr) port->port;	/* save old drawing environment */	gSavePort.portRect = port->port->portRect;	GetClip(gSavePort.clipRgn);	/* setup our drawing environment */	SetOrigin(port->portx, port->porty);	clipRect.top    = netscapeWindow->clipRect.top    + port->porty;	clipRect.left   = netscapeWindow->clipRect.left   + port->portx;	clipRect.bottom = netscapeWindow->clipRect.bottom + port->porty;	clipRect.right  = netscapeWindow->clipRect.right  + port->portx;	ClipRect(&clipRect);	BackColor(whiteColor);  /* needed to avoid funny colors */}/*** Image File Reading ***/void ReadSqueakImage(void) {	sqImageFile f;	char msg[500];	plugInInit(squeakPluginImageName);	InitFilePaths();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		strcpy(msg, "Could not open Squeak image file \"");		strcat(msg, imageName);		strcat(msg, "\"");		plugInNotifyUser(msg);		return;	}	readImageFromFileHeapSizeStartingAt(f, squeakHeapMBytes * 1000000, 0);	sqImageFileClose(f);	interruptKeycode = 515;  /* ctrl-C, since Netscape blocks cmd-. */}/*** URL Requests ***/int URLRequestCreate(char *url, char *target, int semaIndex) {  /* Start a URL request and return its index. Return -1 if there were     no idle request handles. */	int handle, notifyData;	long junk;	handle = FindIdleURLRequest();	if (handle < 0) return handle;	urlRequests[handle].id = nextRequestID++;	urlRequests[handle].status = STATUS_IN_PROGRESS;	urlRequests[handle].semaIndex = semaIndex;	/* temporarily return the grafPort to Netscape so it can display feedback: */	EndDraw();	notifyData = (urlRequests[handle].id << 8) + handle;	NPN_GetURLNotify(thisInstance, url, target, (void *) notifyData);	Delay(120, &junk);  /* workaround for a bug in Mac Netscape 4.7--						  back-to-back requests to a server sometimes fail						  when the server was heavily loaded */	StartDraw();	return handle;}void URLRequestDestroy(int requestHandle) {  /* Clear the url request with the given handle. */	if ((requestHandle < 0) || (requestHandle >= URL_REQUEST_COUNT)) {		return;	}	urlRequests[requestHandle].id = 0;	urlRequests[requestHandle].status = STATUS_IDLE;	urlRequests[requestHandle].semaIndex = 0;	urlRequests[requestHandle].fileName[0] = 0;}char * URLRequestFileName(int requestHandle) {  /* Return the filename associated with the url request with the given     handle. Return null if the request status is not STATUS_SUCCEEDED. */	if ((requestHandle < 0) ||		(requestHandle >= URL_REQUEST_COUNT) ||		(urlRequests[requestHandle].status !!= STATUS_SUCCEEDED)) {			return null;	}	return urlRequests[requestHandle].fileName;}int URLRequestStatus(int requestHandle) {  /* Return the status of the url request with the given handle. */	if ((requestHandle < 0) ||		(requestHandle >= URL_REQUEST_COUNT) ||		(urlRequests[requestHandle].status < STATUS_IN_PROGRESS)) {			return STATUS_BAD_HANDLE;	}	return urlRequests[requestHandle].status;}int FindIdleURLRequest(void) {  /* Return the index of an idle request or -1 if there are none. */	int i;	for (i = 0; i < URL_REQUEST_COUNT; i++) {		if (urlRequests[i].status == STATUS_IDLE) {			return i;		}	}	return -1;}void URLRequestCompleted(int notifyData, const char* fileName) {  /* Record that the given request has completed, caching the result in     the given file name. */	int handle = notifyData & 0xFF;	if ((handle < 0) || (handle >= URL_REQUEST_COUNT)) {		return;	}	if (urlRequests[handle].id == (notifyData >> 8)) {		strncpy(urlRequests[handle].fileName, fileName, MAX_STRING_LENGTH);		urlRequests[handle].status = STATUS_SUCCEEDED;		signalSemaphoreWithIndex(urlRequests[handle].semaIndex);	}}void URLRequestFailed(int notifyData, int reason) {  /* Record that the given URL request failed. */	int handle = notifyData & 0xFF;	if ((handle < 0) || (handle >= URL_REQUEST_COUNT)) {		return;	}	if (urlRequests[handle].id == (notifyData >> 8)) {		/* Note: For local files, we''re informed that there was a network		   error (but only after NPP_StreamAsFile has reported success).		   We could allow local files to be read through the URL request		   mechanism but NOT failing here if the status has already been		   set to success. But we don''t want to allow the URL mechanism		   to be used as a loophole to read files outside the sandbox, so		   we let this fail. */		if (urlRequests[handle].status !!= STATUS_SUCCEEDED) {			urlRequests[handle].status = STATUS_FAILED;			signalSemaphoreWithIndex(urlRequests[handle].semaIndex);		}	}}void InitURLRequestTable(void) {  /* Initialize the table of URL requests. */	int i;	for (i = 0; i < URL_REQUEST_COUNT; i++) {		URLRequestDestroy(i);	}	nextRequestID = 1;}/*** Squeak I/O Support and Memory Allocation ***/int ioExit(void) {  /* Request that we stop running plugin. */	plugInForceTimeToReturn();	thisInstance = nil;	exitRequested = true;}int ioScreenSize(void) {	int w = 10, h = 10;	if (netscapeWindow !!= nil) {		w = netscapeWindow->clipRect.right - netscapeWindow->clipRect.left;		h = netscapeWindow->clipRect.bottom - netscapeWindow->clipRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSetFullScreen(int fullScreen) {	/* noop */}void * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {  /* Allocate the Squeak object heap memory from the system heap. */	MaxBlockSys();	return NewPtrSys(desiredHeapSize);}/*** File and Access Paths ***/int InitFilePaths(void) {	short vRefNum;	long ignore;	Str255 volumeName;	/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	/* get the default volume */	GetVInfo(0, volumeName, &vRefNum, &ignore);	/* set the vmPath */	strcpy(vmPath, p2cstr(volumeName));	strcat(vmPath, ":Disney:Disney Online:Squeak");	/* set the short and full image names */	strcpy(shortImageName, squeakPluginImageName);	strcpy(imageName, vmPath);	strcat(imageName, ":Files:");	strcat(imageName, shortImageName);}int IsPrefixedBy(char *s, char *prefix) {  /* Return true if the given string begins with or equals the given prefix. */	int i;	for (i = 0; prefix[i] !!= 0; i++) {		if (s[i] !!= prefix[i]) return false;	}	return true;}int plugInAllowAccessToFilePath(char *pathString, int pathStringLength) {  /* Return true if access to the given file is allowed. */	int i;	char path[2000];	/* copy path into C string */	if (pathStringLength >= 2000) return false;  /* path too long */	for (i = 0; i < pathStringLength; i++) {		path[i] = pathString[i];	}	path[pathStringLength] = 0;	/* disallow relative path names that might access a parent folder */	for (i = 0; i < pathStringLength; i++) {		if ((path[i] == '':'') && (path[i+1] == '':'')) {			return false;		}	}	return IsPrefixedBy(path, vmPath);}/*** Optional URL Fetch Primitives ***/#ifdef ENABLE_URL_FETCHint primitivePluginBrowserReady(void) {	/* Args: none.	   Always return true on Macintosh. */	interpreterProxy->pop(1);	interpreterProxy->pushBool(1);}int primitivePluginDestroyRequest(void) {	/* Args: handle.	   Destroy the given request. */	int handle;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	URLRequestDestroy(handle);	interpreterProxy->pop(1);}int primitivePluginRequestFileHandle(void) {	/* Args: handle.	   Return a file handle for the completed request. Fail if	   the request handle is not valid or hasn''t successfully completed. */	int handle, fileObj;	char *fileName;	SQFile *filePtr;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	fileName = URLRequestFileName(handle);	if (fileName == null) {		interpreterProxy->success(false);		return null;	}	fileObj = interpreterProxy->instantiateClassindexableSize(		interpreterProxy->classByteArray(), sizeof(SQFile));	filePtr = (SQFile *) (fileObj + 4);	/* Note: OpenFileReadOnly() allows any file on the disk to be read via a file URL.	   However, we are using it for now because we are not sure where the Netscape cache	   folder will be--it''s folder might even be user-name dependent. sqFileOpen() will	   only allow opening files within the sandbox, which would be better. Here''s the	   sandbox-safe alternative:		  sqFileOpen(filePtr, (int) fileName, strlen(fileName), false);	*/	OpenFileReadOnly(filePtr, fileName);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(2);	interpreterProxy->push(fileObj);}int primitivePluginRequestState(void) {	/* Args: handle.	   Return true if the request succeeded, false if it failed, and nil if	   it is still in progress. Fail if the request handle is not valid. */	int handle;	int status;	int resultObj;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	status = URLRequestStatus(handle);	if (status == STATUS_BAD_HANDLE) {		interpreterProxy->success(false);		return null;	}	/* default return object: (nil means "in progress") */	resultObj = interpreterProxy->nilObject();	if (status == STATUS_FAILED) {		resultObj = interpreterProxy->falseObject();	}	if (status == STATUS_SUCCEEDED) {		resultObj = interpreterProxy->trueObject();	}	interpreterProxy->pop(2);	interpreterProxy->push(resultObj);}int primitivePluginRequestURL(void) {	/* Args: url, target, semaphoreIndex.	   Start a URL request to fetch the given URL to the given target.	   (See the Netscape Plugin programmer''s manual for possible targets.)	   Return a handle that can be used to identify this request. Fail if	   there are already too many outstanding requests. */	char *urlPtr;	char *targetPtr;	int semaIndex;	int urlObj, urlSize;	int targetObj, targetSize;	char url[MAX_STRING_LENGTH + 1];	char target[MAX_STRING_LENGTH + 1];	int i;	int handle;	semaIndex = interpreterProxy->stackIntegerValue(0);	targetObj = interpreterProxy->stackObjectValue(1);	urlObj = interpreterProxy->stackObjectValue(2);	interpreterProxy->success(interpreterProxy->isBytes(targetObj));	interpreterProxy->success(interpreterProxy->isBytes(urlObj));	if (interpreterProxy->failed()) {		return null;	}	urlSize = interpreterProxy->stSizeOf(urlObj);	urlPtr = interpreterProxy->firstIndexableField(urlObj);	targetSize = interpreterProxy->stSizeOf(targetObj);	targetPtr = interpreterProxy->firstIndexableField(targetObj);	/* copy url into a C string */	if (urlSize > MAX_STRING_LENGTH) urlSize = MAX_STRING_LENGTH;	for (i = 0; i < urlSize; i++) {		url[i] = urlPtr[i];	}	url[urlSize] = 0;	/* copy target into a C string */	if (targetSize > MAX_STRING_LENGTH) targetSize = MAX_STRING_LENGTH;	for (i = 0; i < targetSize; i++) {		target[i] = targetPtr[i];	}	target[targetSize] = 0;	handle = URLRequestCreate(url, target, semaIndex);	interpreterProxy->success(handle >= 0);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(4);	interpreterProxy->pushInteger(handle);}int primitivePluginRequestURLStream(void) {	/* Args: url, semaphoreIndex.	   Start a URL request to fetch the given URL. Return a handle that	   can be used to identify this request. Fail if there are already	   too many outstanding requests. */	int urlObj, urlSize, semaIndex;	char *urlPtr;	char url[MAX_STRING_LENGTH + 1];	int handle, i;	semaIndex = interpreterProxy->stackIntegerValue(0);	urlObj = interpreterProxy->stackObjectValue(1);	interpreterProxy->success(interpreterProxy->isBytes(urlObj));	if (interpreterProxy->failed()) {		return null;	}	urlSize = interpreterProxy->stSizeOf(urlObj);	urlPtr = interpreterProxy->firstIndexableField(urlObj);	/* copy url into a C string */	if (urlSize > MAX_STRING_LENGTH) urlSize = MAX_STRING_LENGTH;	for (i = 0; i < urlSize; i++) {		url[i] = urlPtr[i];	}	url[urlSize] = 0;	handle = URLRequestCreate(url, null, semaIndex);	interpreterProxy->success(handle >= 0);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(3);	interpreterProxy->pushInteger(handle);}void OpenFileReadOnly(SQFile *f, char *fileName) {	/* Opens the given file for reading using the supplied sqFile	   structure. This is a simplified version of sqFileOpen() that	   avoids the "sandbox" access check, since the browser''s	   cache folder is outside the Squeak sandbox. That is why	   we only allow reading of this file. Sets the primitive	   failure flag if not successful. */	f->file = fopen(fileName, "rb");	f->writable = false;	if (f->file == NULL) {		f->sessionID = 0;		f->fileSize = 0;		interpreterProxy->success(false);		return;	} else {		f->sessionID = thisSession;		/* compute and cache file size */		fseek(f->file, 0, SEEK_END);		f->fileSize = ftell(f->file);		fseek(f->file, 0, SEEK_SET);	}	f->lastOp = 0;}#endif/*** Other ***/int CaseInsensitiveMatch(char *s1, char *s2) {  /* Return true if the two strings are the same, not considering case. */	int len, i, c1, c2;	len = strlen(s1);	if (strlen(s2) !!= len) return false;	for (i = 0; i < len; i++) {		c1 = s1[i];		c2 = s2[i];		if ((c1 >= ''a'') && (c1 <= ''z'')) {			c1 = c1 - (''a'' - ''A'');		}		if ((c2 >= ''a'') && (c2 <= ''z'')) {			c2 = c2 - (''a'' - ''A'');		}		if (c1 !!= c2) return false;	}	return true;}void ExitCleanup(void) {  /* Clean up and stop running plugin. */	thisInstance = nil;	plugInShutdown();	NPP_Initialize();  /* reset local variables */	MaxBlockSys();}int StringToInteger(char *s) {  /* Answer the integer resulting from converting the given     string, assumed to be decimal integer. */	int sign, n, i, ch;	sign = 1;	n = 0;	i = 0;	while ((ch = s[i++]) !!= 0) {		if ((ch == ''-'') && (i == 1)) {			sign = -1;		} else {			if ((ch >= ''0'') && (ch <= ''9'')) {				n = (10 * n) + (ch - ''0'');			} else {				return sign * n;			}		}	}	return sign * n;}/*** Interpreter Hooks ***/void plugInForceTimeToReturn(void) {  /* Ensure that the next call to pluginTimeToReturn() will return true. */	interpStartTime = clock() - 1000;}int plugInNotifyUser(char *msg) {  /* Notify the user that there was a problem starting Squeak. */	strcpy((char *) notificationMsg, msg);  /* copy message, since notification is asynchronous */	c2pstr((char *) notificationMsg);	notifyRec.qType = nmType;	notifyRec.nmMark = false;			/* no mark in applications menu */	notifyRec.nmIcon = nil;				/* no menu bar icon */	notifyRec.nmSound = (Handle) -1;	/* -1 means system beep */	notifyRec.nmStr = notificationMsg;	notifyRec.nmResp = (NMUPP) -1;		/* -1 means remove notification when user confirms */	/* add to notification queue */	NMInstall(&notifyRec);}void plugInSetStartTime(void) {  /* Set that time at which interpret() was started. */	interpStartTime = clock();}int plugInTimeToReturn(void) {  /* Return true if it is time to return from interpret(). */	EventRecord evt;	int delta = clock() - interpStartTime;	if ((delta < 0) || (delta >= 20)) {		/* let Netscape have control every so often whether or		   not there are pending events */		return true;	}	if ((delta & 0x3) == 0x3) {		/* check every 4 ticks; if pending events, return to the browser */		if (OSEventAvail(everyEvent, &evt)) return true;	}	return false;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/25/2000 18:31'!macDirectoryFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "FilePlugin.h"/* End of adjustments for pluginized VM */#include <Files.h>#include <Strings.h>/***	The interface to the directory primitive is path based.	That is, the client supplies a Squeak string describing	the path to the directory on every call. To avoid traversing	this path on every call, a cache is maintained of the last	path seen, along with the Mac volume and folder reference	numbers corresponding to that path.***//*** Constants ***/#define ENTRY_FOUND     0#define NO_MORE_ENTRIES 1#define BAD_PATH        2#define DELIMITOR '':''#define MAX_PATH 2000/*** Variables ***/char lastPath[MAX_PATH + 1];int  lastPathValid = false;int  lastRefNum = 0;int  lastVolNum = 0;/*** Functions ***/int convertToSqueakTime(int macTime);int equalsLastPath(char *pathString, int pathStringLength);int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr);int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr);int lookupVolume(char *volName, int *refNumPtr);int recordPath(char *pathString, int pathStringLength, int refNum, int volNum);int convertToSqueakTime(int macTime) {	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than Mac one */	return macTime + (3 * 365 * 24 * 60 * 60);}int dir_Create(char *pathString, int pathStringLength) {	/* Create a new directory with the given path. By default, this	   directory is created in the current directory. Use	   a full path name such as "MyDisk:Working:New Folder" to	   create folders elsewhere. */	Str255 name;	HParamBlockRec pb;	int i;	if (!!plugInAllowAccessToFilePath(pathString, pathStringLength)) {		return false;	}	for (i = 0; i < pathStringLength; i++) {		name[i] = pathString[i];	}	name[i] = 0; /* string terminator */	c2pstr((char *) name);	pb.fileParam.ioNamePtr = name;	pb.fileParam.ioVRefNum = 0;	pb.fileParam.ioDirID = 0;	return PBDirCreateSync(&pb) == noErr;}int dir_Delete(char *pathString, int pathStringLength) {	/* Delete the existing directory with the given path. */	int okay, refNum, volNum, i;	HParamBlockRec pb;	Str255 name;	if (!!plugInAllowAccessToFilePath(pathString, pathStringLength)) {		return false;	}	for (i = 0; i < pathStringLength; i++) {		name[i] = pathString[i];	}	name[i] = 0; /* string terminator */	okay = lookupPath(pathString, pathStringLength, &refNum, &volNum);	if (!!okay) {		return false;	}	c2pstr((char *) name);	pb.fileParam.ioNamePtr = name;	pb.fileParam.ioVRefNum = volNum;	pb.fileParam.ioDirID = refNum;	return PBHDeleteSync(&pb) == noErr;}int dir_Delimitor(void) {	return DELIMITOR;}int dir_Lookup(char *pathString, int pathStringLength, int index,  /* outputs: */  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile) {	/* Lookup the index-th entry of the directory with the given path, starting	   at the root of the file system. Set the name, name length, creation date,	   creation time, directory flag, and file size (if the entry is a file).	   Return:	0 	if a entry is found at the given index	   			1	if the directory has fewer than index entries	   			2	if the given path has bad syntax or does not reach a directory	*/	int okay, newRefNum, newVolNum;	HVolumeParam volumeParams;	CInfoPBRec dirParams;	/* default return values */	*name             = 0;	*nameLength       = 0;	*creationDate     = 0;	*modificationDate = 0;	*isDirectory      = false;	*sizeIfFile       = 0;	if (!!plugInAllowAccessToFilePath(pathString, pathStringLength)) {		return NO_MORE_ENTRIES;	}	if ((pathStringLength == 0)) {		/* get volume info */		volumeParams.ioNamePtr = (unsigned char *) name;		volumeParams.ioVRefNum = 0;		volumeParams.ioVolIndex = index;		okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;		if (okay) {			p2cstr((unsigned char *) name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(volumeParams.ioVCrDate);			*modificationDate = convertToSqueakTime(volumeParams.ioVLsMod);			*isDirectory      = true;			*sizeIfFile       = 0;			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	} else {		/* get file or directory info */		if (!!equalsLastPath(pathString, pathStringLength)) {			/* lookup and cache the refNum for this path */			okay = lookupPath(pathString, pathStringLength, &newRefNum, &newVolNum);			if (okay) {				recordPath(pathString, pathStringLength, newRefNum, newVolNum);			} else {				return BAD_PATH;			}		}		dirParams.hFileInfo.ioNamePtr = (unsigned char *) name;		dirParams.hFileInfo.ioFVersNum = 0;		dirParams.hFileInfo.ioFDirIndex = index;		if (lastRefNum < 0) {			dirParams.hFileInfo.ioVRefNum = lastRefNum;			dirParams.hFileInfo.ioDirID = 0;		} else {			dirParams.hFileInfo.ioVRefNum = lastVolNum;			dirParams.hFileInfo.ioDirID = lastRefNum;		}		okay = PBGetCatInfoSync(&dirParams) == noErr;		if (okay) {			p2cstr((unsigned char *) name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(dirParams.hFileInfo.ioFlCrDat);			*modificationDate = convertToSqueakTime(dirParams.hFileInfo.ioFlMdDat);			if ((dirParams.hFileInfo.ioFlAttrib & 16) !!= 0) {				*isDirectory  = true;				*sizeIfFile   = 0;			} else {				*isDirectory  = false;				*sizeIfFile   = dirParams.hFileInfo.ioFlLgLen;			}			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	}}dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Set the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */	Str255 name;	FInfo finderInfo;	int i;	/* copy file name into a Pascal string */	if (filenameSize > 255) return false;	name[0] = filenameSize;	for (i = 1; i <= filenameSize; i++) {		name[i] = filename[i - 1];	}	if (GetFInfo(name, 0, &finderInfo) !!= noErr) return false;	finderInfo.fdType = *((int *) fType);	finderInfo.fdCreator = *((int *) fCreator);	if (SetFInfo(name, 0, &finderInfo) !!= noErr) return false;	return true;}int equalsLastPath(char *pathString, int pathStringLength) {	/* Return true if the lastPath cache is valid and the	   given Squeak string equals it. */	int i, ch;	if (!!lastPathValid ||		(pathStringLength > MAX_PATH)) {			return false;	}	for (i = 0; i < pathStringLength; i++) {		ch = lastPath[i];		if ((ch == 0) || (ch !!= pathString[i])) return false;	}	return lastPath[i] == 0;}int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr) {	/* Look up the next directory in a path starting from the folder and volume	   with the given reference numbers and setting *refNumPtr to the reference	   number of the resulting folder. Return true if this succeeds. */	CInfoPBRec pb;	c2pstr((char *) name);	pb.hFileInfo.ioNamePtr = (unsigned char *) name;	pb.hFileInfo.ioFVersNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioVRefNum = volRefNum;	pb.hFileInfo.ioDirID = folderRefNum;	if (PBGetCatInfoSync(&pb) == noErr) {		p2cstr((unsigned char *) name);		*refNumPtr = pb.hFileInfo.ioDirID;		return true;	}	p2cstr((unsigned char *) name);	return false;}int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr) {	/* Resolve the given path and return the resulting folder or volume	   reference number in *refNumPtr. Return false if the path is bad. */	char chunk[100];	int stIndex, chunkIndex, ch;	int okay, thisVolNum = 0, thisRefNum = 0;	int firstChunk = true, hasLeadingDelimitors = false;	stIndex = 0;	while (stIndex < pathStringLength) {		chunkIndex = 0;		while ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {			/* copy any leading delimitors */			chunk[chunkIndex++] = pathString[stIndex++];			hasLeadingDelimitors = true;		}		while ((stIndex < pathStringLength) && (pathString[stIndex] !!= DELIMITOR)) {			/* copy up to the next delimitor */			ch = chunk[chunkIndex++] = pathString[stIndex++];		}		if (firstChunk && (chunk[chunkIndex] !!= DELIMITOR)) {			/* Add a trailing delimiter to the first chunk of the			   path to indicate that it is a volume name. If the			   path starts with an initial delimitor, it will be			   interpreted as a path relative to the current working			   directory even with a trailing delimitor, which is			   exactly the behavior we want. */			chunk[chunkIndex++] = DELIMITOR;			if ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {				stIndex++;			}			firstChunk = false;		}		chunk[chunkIndex] = 0;  /* terminate this chunk */		if ((thisVolNum == 0) && !!hasLeadingDelimitors) {			okay = lookupVolume(chunk, &thisVolNum);			thisRefNum = 0;		} else {			okay = lookupDirectory(thisVolNum, thisRefNum, chunk, &thisRefNum);		}		if (!!okay) {			*refNumPtr = 0;			*volNumPtr = 0;			return false;		}	}	*refNumPtr = thisRefNum;	*volNumPtr = thisVolNum;	return true;}int lookupVolume(char *volName, int *refNumPtr) {	/* Look up the volume with the given name and set *refNumPtr	   to the reference number of the resulting volume.	   Return true if this succeeds. */	int okay;	HVolumeParam volumeParams;	volumeParams.ioNamePtr = c2pstr(volName);	volumeParams.ioVRefNum = 0;	volumeParams.ioVolIndex = -1;	okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;	p2cstr((unsigned char *) volName);	if (okay) {		*refNumPtr = volumeParams.ioVRefNum;		return true;	}	return false;}int recordPath(char *pathString, int pathStringLength, int refNum, int volNum) {	/* Copy the given Squeak string into the lastPath cache. */	int i;	if (pathStringLength > MAX_PATH) {		lastPath[0] = 0; /* set to empty string */		lastPathValid = false;		lastRefNum = 0;		lastVolNum = 0;		return;	}	for (i = 0; i < pathStringLength; i++) {		lastPath[i] = pathString[i];	}	lastPath[i] = 0; /* string terminator */	lastPathValid = true;	lastRefNum = refNum;	lastVolNum = volNum;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/25/2000 18:32'!macJoystickAndTabletFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "JoystickTabletPlugin.h"/* initialize/shutdown */int joystickShutdown() {}/* End of adjustments for pluginized VM */#include <DeskBus.h>#include <Devices.h>#include <Timer.h>/* Joystick Record */#define MOUSESTICK_SIGNATURE 0x4A656666#define MAX_STICKS 4typedef struct {	short			rawX;				/* absolute stick position */	short			rawY;	unsigned char	buttons;	char			private1;	short			cursorX;			/* cursor position */	short			cursorY;	char			oldStickType;	char			private2;	char			stickOn;			/* true if stick is connected */	char			private3;	char			stickControlsCursor;	char			applicationAware;	/* settings change with application changes */	char			private4[152];} MouseStickRec;typedef struct {	long			signature;	char			private1[18];	short			stickCount;	char			private2[22];	MouseStickRec	stick[MAX_STICKS];} MouseStickSetRec, *MouseStickSetPtr;/* Tablet Record (see  Apple Tech. Note 266, version 2) */#define MAX_TRANSDUCERS 4typedef struct {    char	DOFTrans;			/* degrees of freedom and transducer type */    char	orientFlag;			/* type of orientation information */    short	pressLevels;		/* pressure support and number of levels */    unsigned short xScale;		/* x scale factor for screen mapping */    short	xTrans;				/* x translation factor for screen */    unsigned short yScale;		/* y scale factor for screen mapping */    short	yTrans;				/* y translation factor for screen */    unsigned char flags;		/* proximity, update flag, and # buttons */    unsigned char pressThresh;	/* pressure threshold - normally unused */    short	buttonMask;			/* button mask of driver-reserved buttons */    short	errorFlag;			/* error code generated */    short	buttons;			/* buttons pressed */    short	tangPress;			/* tangential pressure level */    short	pressure;			/* normal pressure level */    long	timeStamp;			/* ticks at latest update */    long	xCoord;				/* x coordinate in resolution units */    long	yCoord;				/* y coordinate in resolution units */    long	zCoord;				/* z coordinate in resolution units */    short	xTilt;				/* x tilt */    short	yTilt;				/* y tilt */    short	unused[8];			/* remainder of unused attitude matrix */} TransducerRec, *TransducerRecPtr;typedef struct {    char	version;			/* version of this data format */    char	semaphore;			/* for future use -- tells if drvr is enabled */    char	cursors;			/* number of cursors with tablet */    char	updateFlags;		/* flags used when updating structure */    short	angleRes;			/* metric bit & angular resolution */    short	spaceRes;			/* spatial resolution of the tablet */    long	xDimension;			/* x dimension in resolution units */    long	yDimension;			/* y dimension in resolution units */    long	zDimension;			/* z dimension in resolution units */    long	xDisplace;			/* x displacement - minimum x value */    long	yDisplace;			/* y displacement - minimum y value */    long	zDisplace;			/* z displacement - minimum z value */    long	reserved;			/* reserved */    long	tabletID;			/* contains ''TBLT'' identifying the device */	TransducerRec transducer[MAX_TRANSDUCERS];} TabletRec, *TabletRecPtr;/*** Variables ***/MouseStickSetPtr joySticks = nil;	/* pointer to a joystick set or nil */TabletRecPtr tablet = nil;  		/* pointer to a tablet record or nil */int joystickInit(void) {	/* If a joystick is plugged in and its control panel is installed,	   initialize the global pointer ''joySticks'' to the joystick set	   data structure. Otherwise, set it to nil.	*/	ADBDataBlock adbGetInfo;	MouseStickSetPtr sticks;	int count, i;	joySticks = nil;  /* set to nil in case we don''t find any joysticks */	count = CountADBs();	for (i = 1; i <= count; i++) {		GetADBInfo(&adbGetInfo, GetIndADB(&adbGetInfo, i));		sticks = (MouseStickSetPtr) adbGetInfo.dbDataAreaAddr;		if ((sticks !!= nil) && (sticks->signature == MOUSESTICK_SIGNATURE)) {			joySticks = sticks;			return true;		}	}	return true;}int joystickRead(int stickIndex) {	/* Return input word for the joystick with the given index (in range [1..2]	   on the Macintosh; other platforms may vary). This word is encoded as follows:		<onFlag (1 bit)><buttonFlags (5 bits)><x-value (11 bits)><y-value (11 bits)>	   The highest four bits of the input word are zero. If the onFlag bit is zero,	   there is no joystick at the given index. This may be because no joystick	   is connected or the joystick control panel is not installed. In such,	   cases, the entire word will be zero. A maximum of two joysticks are supported	   by Gravis''s current version of the control panel. The x and y values are	   11-bit signed values in the range [-1024..1023] representing the raw (unencoded)	   joystick position. The MouseStick II only uses the approximate range [-650..650].	   The range and center values of poorly adjusted joysticks may vary; the client	   software should provide a way to adjust the center and scaling to correct.	*/	MouseStickRec stickData;	int buttons, xBits, yBits;	if ((joySticks == nil) || (stickIndex < 1) || (stickIndex > 2) ||		(stickIndex > joySticks->stickCount)) {			return 0;  /* no joystick at the given index */	}	stickData = joySticks->stick[stickIndex - 1];  /* 1-based index */	buttons = ~stickData.buttons & 0x1F;	xBits = (0x400 + stickData.rawX) & 0x7FF;	yBits = (0x400 + stickData.rawY) & 0x7FF;	return (1 << 27) | (buttons << 22) | (yBits << 11) | xBits;}int tabletInit(void);int tabletInit(void) {	/* Open the tablet driver and initialize the global pointer to its status	   record. Return true if a tablet exists, false otherwise. */	CntrlParam	pb;	short		driverRefNum;	if (OpenDriver("\p.Wacom", &driverRefNum) !!= noErr) {		return false;	}	pb.ioCRefNum = driverRefNum;	pb.csCode = 20;  /* requests the address of the current tablet record */	if (PBStatusSync((ParmBlkPtr) (&pb)) !!= noErr) {		return false;	}	tablet = *((TabletRecPtr *) &pb.csParam);	return tablet->tabletID == 0x54424c54;  /* verify that id is ''TBLT'' */}int tabletGetParameters(int cursorIndex, int result[]) {	/* Fill in the integer array ''result'' with tablet parameter information.	   For cursor-specific parameters, such as the number of pressure levels,	   return the information for the cursor with the given index, an integer	   between 1 and tablet->cursors. */	TransducerRecPtr cursorPtr;	int cursor;	/* open tablet if necessary; return false if no tablet */	if (tablet == nil) {		if (!!tabletInit()) return false;	}	cursor = cursorIndex - 1;	if ((cursor < 0)  || (cursor >= tablet->cursors)) {		return false;	}	cursorPtr = &tablet->transducer[cursor];	result[0] = tablet->xDimension;	result[1] = tablet->yDimension;	result[2] = tablet->spaceRes;	result[3] = tablet->cursors;  /* number of cursors */	result[4] = cursor + 1;	result[5] = cursorPtr->xScale;	result[6] = cursorPtr->xTrans;	result[7] = cursorPtr->yScale;	result[8] = cursorPtr->yTrans;	result[9] = cursorPtr->pressLevels;	result[10] = cursorPtr->pressThresh;	if (tablet->angleRes == 0) {		result[11] = 0;  /* no pen tilt support */	} else {		result[11] = tablet->angleRes >> 1;  /* number of pen tilt levels */	}	return true;}int tabletRead(int cursorIndex, int result[]) {	/* Fill in the integer array ''result'' with the current data	   the cursor with the given index, an integer between 1 and	   tablet->cursors. Note that the timestamp changes only	   when some new data has arrived from the tablet. */	TransducerRecPtr cursorPtr;	int cursor;	/* open tablet if necessary; return false if no tablet */	if (tablet == nil) {		if (!!tabletInit()) return false;	}	cursor = cursorIndex - 1;	if ((cursor < 0)  || (cursor >= tablet->cursors)) {		return false;	}	cursorPtr = &tablet->transducer[cursor];	result[0] = cursor + 1;	result[1] = cursorPtr->timeStamp;	result[2] = cursorPtr->xCoord;	result[3] = cursorPtr->yCoord;	result[4] = cursorPtr->zCoord;	result[5] = cursorPtr->xTilt;	result[6] = cursorPtr->yTilt;	result[7] = (cursorPtr->DOFTrans & 0x30) >> 4;  /* cursor type; 1-pen, 2-puck, 3-eraser */	result[8] = cursorPtr->buttons;	result[9] = cursorPtr->pressure;	result[10] = cursorPtr->tangPress;	result[11] = cursorPtr->flags;	return true;}int tabletResultSize(void) {	/* Return the size of the integer array required to hold the results of	   either a tabletGetParameters() or tabletRead() call. The VM allocates	   an array of this length and passes it as a parameter to be filled in. */	return 12;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/25/2000 18:33'!macMinimal	^ '/* sqMacMinimal.c	This file includes the minimal support code to build a Squeak virtual machine for	the Mac. Most primitives are "stubbed-out", meaning that if they are invoked from	the image they will return a "primitive failed" error. Among the stubbed out	primitives are those that support sound input and output, serial and MIDI ports,	networking, ,file directory operations, etc. The basic file read/write operations	are NOT stubbed out, although they could be as long as the image loading mechanism	still works.	The purpose of this file is to provide an implementation roadmap when bootstrapping	Squeak on a new platform. Once all the non-stubbed-out functions in this file have	been ported, you will have a working, usable Squeak virtual machine!!*** Implementation Notes ***  I/O Functions	The following are essential for display and user interaction:		ioScreenSize()		ioShowDisplay()		ioGetButtonState()		ioGetKeystroke()		ioMousePoint()		ioPeekKeystroke()	The following can be made no-ops:		ioProcessEvents() 	-- poll for input events on some platforms		ioSetCursor()		-- install a 16x16 black and white hardware cursor		ioSetCursorWithMask() -- install a masked black and white hardware cursor		ioBeep()			-- sound a short beep through the speaker		ioExit()			-- exit the VM: quit the application, reboot, power down, or							-- similar behavior appropriate to this platform (if this							-- is a noop you simply won''t be able to quit from Squeak)  File Naming	The virtual machine keeps track of the full path name of the Squeak image	file and the path to the directory containing the virtual machine. In this	minimal implementation, the VM path is the empty string and the image name is	hardwired to "squeak.image". It is assumed that the image file, the changes	file, the Squeak application, and the system sources file are all in the	the same directory, and that this directory is the default working directory	for any file operations.  Time Functions		ioMSecs(), ioMicroMSecs()							-- both return a millisecond clock value, but historically							-- ioMicroMSecs() used a higher resolution timer; the							-- ideal implementation is an inexpensive clock with 1							-- millisecond accuracy, but both functions can use a							-- clock with much coarser accuracy (e.g., 50-100 mSecs)							-- if necessary		ioSeconds()			-- returns the number of seconds since Jan 1, 1901.	   						-- optional: may be implemented to always return 0, but then	   						-- the current date and time will be wrong*** Linking ***	To build a Macintosh VM using this file, link together:		interp.c		-- automatically generated interpreter file		sqMiscPrims.c	-- automatically generated primitives		sqMacMinimal.c	-- this file	plus the appropriate C libraries (e.g. math, strings, standard I/O).		The interpreter code depends on the following functions from libraries:	    math: exp(), log(), atan(), sin(), sqrt(), ldexp(), frexp(), modf()	    standard i/o: getchar(), putchar(), printf()	    other: memcpy(), strlen(), clock()	The standard i/o functions could be stubbed out; they are only used to report	fatal VM errors.*/#include <Devices.h>#include <Fonts.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include "sq.h"#include "FilePlugin.h"/*** Mac Toolbox Function that is Missing from Standard Header Files ***/void ExitToShell(void);/*** Stub Definitions ***/#define STUBBED_OUT { success(false); }#define DO_NOTHING { }/*** Enumerations ***/enum { appleID = 1, fileID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by RecordKeystroke if interrupt key is pressed *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);int RecordKeystroke(EventRecord *theEvent);int RecordModifierButtons(EventRecord *theEvent);int RecordMouseDown(EventRecord *theEvent);void SetColorEntry(int index, int red, int green, int blue);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);/*** Mac-specific Functions (these would be replaced on another platform) ***/int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				RecordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				RecordModifierButtons(&theEvent);				RecordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				InvalRect(&stWindow->portRect);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	if ((HiWord(mSelect) == fileID) &&		(LoWord(mSelect) == quitItem)) {		ioExit();	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				RecordMouseDown(theEvent);			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();	SetUpMenus();	SetUpWindow();	SetUpPixmap();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 460, 640};	stWindow = NewCWindow(		0L, &windowBounds, "\p Squeak!! ",		true, documentProc, (WindowPtr) -1L, true, 0);}/*** Event Recording Functions ***/int RecordKeystroke(EventRecord *theEvent) {	/* record a keystroke in the keyboard buffer. */	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int RecordMouseDown(EventRecord *theEvent) {	/* record that the mouse button has been pressed. */	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int RecordModifierButtons(EventRecord *theEvent) {	/* record the state of the mouse buttons and modifier keys. */	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	/* optional; could be noop. play a beep through the speaker. */	SysBeep(1000);}int ioExit(void) {	/* optional; could be noop. exit from the Squeak application. */	ExitToShell();}int ioForceDisplayUpdate(void) {	/* does nothing on a Mac */}int ioGetButtonState(void) {	/* return the state of the mouse and modifier buttons */	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	/* return the next keystroke from the buffer or -1 if the buffer is empty */	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	/* return the mouse point two 16-bit positive integers packed into a 32-bit integer */	Point p;	ioProcessEvents();  /* process all pending events */	GetMouse(&p);	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	/* return the next keystroke from the buffer or -1 if the buffer is empty; leave	   the keystrok in the buffer. */	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* process Macintosh events, checking for the interrupt key. Return	   true if the interrupt key was pressed. This might simply do nothing	   on some other platform.*/	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}	return interruptPending;}int ioScreenSize(void) {	/* return the screen size as two positive 16-bit integers packed into a 32-bit integer */	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	/* return the time in seconds since midnight of Jan 1, 1901.  */	/* optional: could simply return 0.  */	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* old version; just call the new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Optional primitive; this could be defined to do nothing. */	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioShowDisplay(	/* copy the given rectangular display region to the hardware display buffer. */	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** VM Home Directory Path ***/int vmPathSize(void) {	/* return the length of the path string for the directory containing the VM. */	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	/* copy the path string for the directory containing the VM into the given Squeak string. */	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Image File Name ***/int imageNameSize(void) {	/* return the length of the Squeak image name. */	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	/* copy the Squeak image name into the given Squeak string. */	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	/* copy from the given Squeak string into the imageName variable. */	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	return count;}/*** Clipboard Support ***/int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	/* return number of bytes read from clipboard; stubbed out. */	return 0;}int clipboardSize(void) {	/* return the number of bytes of data the clipboard; stubbed out. */	return 0;}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	/* write count bytes to the clipboard; stubbed out. */	return 0;}/*** System Attributes ***/char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return "";	/* the following attributes describe the underlying platform: */	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 680xx";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	/* return the length of the given attribute string. */	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	/* copy the attribute with the given id into a Squeak string. */	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Read/Write ***/void * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {	/* allocate memory for Squeak object heap. */	MaxBlock();	return NewPtr(desiredHeapSize);}void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}/*** I/O Stubs ***/int ioFormPrint(int bitsAddr, int width, int height,	int depth, double hScale, double vScale, int landscapeFlag)				STUBBED_OUTint ioHasDisplayDepth(int depth) 											STUBBED_OUTint ioRelinquishProcessorForMicroseconds(int microSeconds)					DO_NOTHINGint ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag)	DO_NOTHINGint ioSetFullScreen(int fullScreen) 										DO_NOTHING/*** File I/0 Stubs ***/int sqFileAtEnd(SQFile *f)													STUBBED_OUTint sqFileClose(SQFile *f)													STUBBED_OUTint sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize)			STUBBED_OUTint sqFileGetPosition(SQFile *f)											STUBBED_OUTint sqFileInit(void)														{ return true; }int sqFileOpen(  SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag)		STUBBED_OUTint sqFileReadIntoAt(  SQFile *f, int count, int byteArrayIndex, int startIndex)					STUBBED_OUTint sqFileRenameOldSizeNewSize(  int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize)		STUBBED_OUTint sqFileSetPosition(SQFile *f, int position)								STUBBED_OUTint sqFileSize(SQFile *f) { return 0; }int sqFileShutdown(void)													{ return 0; }int sqFileValid(SQFile *f)													STUBBED_OUTint sqFileWriteFromAt(  SQFile *f, int count, int byteArrayIndex, int startIndex)					STUBBED_OUT/*** Directory Stubs ***/int dir_Create(char *pathString, int pathStringLength)						STUBBED_OUTint dir_Delimitor(void)														{ return '':''; }int dir_Lookup(char *pathString, int pathStringLength, int index,  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile)										STUBBED_OUTdir_SetMacFileTypeAndCreator(char *filename, int filenameSize,  char *fType, char *fCreator)												DO_NOTHINGint dir_Delete(char *pathString, int pathStringLength)						STUBBED_OUT/*** Profiling Stubs ***/int clearProfile(void)														STUBBED_OUTint dumpProfile(void)														STUBBED_OUTint startProfiling(void)													STUBBED_OUTint stopProfiling(void)														STUBBED_OUT/*** External Primitive Support (No-ops) ***/int ioLoadModule(char *pluginName) { return 0; }int ioFindExternalFunctionIn(char *lookupName, int moduleHandle) { return 0; }int ioFreeModule(int moduleHandle) { return 0; }/*** Main ***/void main(void) {	sqImageFile f;	int availableMemory;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	InitMacintosh();	sqFileInit();	imageName[0] = shortImageName[0] = vmPath[0] = 0;	strcpy(imageName, "squeak.image");	strcpy(shortImageName, "squeak.image");	/* compute the desired memory allocation */	availableMemory = MaxBlock() - 50000;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in that partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.		(We reserve 50K for Mac toolbox calls, the error console window, etc.	******/	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("In this minimal VM, the image file must be named ''squeak.image''\n");		printf("and must be in the same directory as the Squeak application.\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	/* run Squeak */	interpret();}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/25/2000 18:34'!macNetworkFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include <MacHeaders.h>  /* needed only for ExitToShell() */#include "sq.h"#include "SocketPlugin.h"/* initialize/shutdown */int socketInit() { return true; }int socketShutdown() { sqNetworkShutdown(); }/* End of adjustments for pluginized VM */#include <Events.h>#include <Devices.h>#include <Processes.h>#include <Traps.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "MacTCP.h"#include "AddressXLation.h"/*** Socket Type Constants ***/#define TCPSocketType 		0#define UDPSocketType 		1#define ListenerQueueType	2/*** Resolver Status Constants ***/#define RESOLVER_UNINITIALIZED	0#define RESOLVER_SUCCESS		1#define RESOLVER_BUSY			2#define RESOLVER_ERROR			3/* Resolver State */typedef struct {	int				semaIndex;	int				status;	int				error;	int				localAddress;	int				remoteAddress;	struct hostInfo	hostInfo;} ResolverStatusRec, *ResolverStatusPtr;/*** TCP Socket Status Constants ***/#define Unconnected				0#define WaitingForConnection	1#define Connected				2#define OtherEndClosed			3#define ThisEndClosed			4/*** TCP Socket State ***/#define SendBufferSize	(8 * 1024)#define RecvBufferSize	(8 * 1024)typedef struct {	TCPiopb		tcpPB;				/* TCP parameter block for open/send (must be first) */	TCPiopb		closePB;			/* TCP parameter block for close */	StreamPtr	tcpStream;			/* TCP stream */	void *		next;				/* next socket in a linked list of open sockets */	int			semaIndex;	int			connectStatus;	void *		nextInListenerQueue; /* next socket in a ListenderQueue waiting socket list */	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;//xxx	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} TCPSockRec, *TCPSockPtr;typedef struct {	TCPiopb		tcpPB;	TCPSockPtr	mySocket;	struct wdsEntry wds[2];	char		data[SendBufferSize];} TCPSendBuf, *TCPSendBufPtr;#define SendBufCount 8TCPSendBuf sendBufPool[SendBufCount];int nextSendBuf = 0;typedef struct {	int			localAddress;	int			localPort;	int			closed;				/* set true by close or abort */	int			semaIndex;			/* semaphore of the server socket */	int			desiredQueueLength;	TCPSockPtr	waitingSockets;} ListenerQueueRec, *ListenerQueuePtr;/*** UDP Socket Status Constants ***/#define UnknowRemoteAddrAndPort	0#define Ready					1/*** UDP Socket State ***/typedef struct {	void *		next;				/* next socket in a linked list of open sockets */	int			remoteAddress;	int			remotePort;	int			semaIndex;	int			connectStatus;	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} UDPSockRec, *UDPSockPtr;/*** Variables ***/short				macTCPRefNum = 0;int					mtuSize = 1024;TCPSockPtr 			openTCPSockets = nil;UDPSockPtr			openUDPSockets = nil;ResolverStatusRec 	resolver = {0, 0, 0, 0, 0, 0, 0};UniversalProcPtr	myExitHandlerProc = nil;UniversalProcPtr	oldExitHandlerProc = nil;ResultUPP			resolverDoneProc = nil;TCPIOCompletionUPP	tcpCloseDoneProc = nil;TCPIOCompletionUPP	tcpConnectDoneProc = nil;TCPNotifyUPP		tcpNotifyProc = nil;TCPIOCompletionUPP	tcpSendDoneProc = nil;UDPNotifyUPP		udpNotifyProc = nil;UDPIOCompletionUPP	udpSendDoneProc = nil;int					thisNetSession = 0;/*** Private TCP Socket Functions ***/void *		TCPSockCreate(void);void		TCPSockDestroy(TCPSockPtr s);void		TCPSockRemoveFromOpenList(TCPSockPtr s);int			TCPSockLocalAddress(TCPSockPtr s);int			TCPSockLocalPort(TCPSockPtr s);int			TCPSockRemoteAddress(TCPSockPtr s);int			TCPSockRemotePort(TCPSockPtr s);void		TCPSockConnectTo(TCPSockPtr s, int addr, int port);void		TCPSockListenOn(TCPSockPtr s, int port);void		TCPSockAbortConnection(TCPSockPtr s);void		TCPSockCloseConnection(TCPSockPtr s);int			TCPSockDataAvailable(TCPSockPtr s);int			TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize);int			TCPSockSendData(TCPSockPtr s, char *buf, int bufSize);/*** Private ListenerQueue Socket Functions ***/void		FillListenerQueue(ListenerQueuePtr listener);TCPSockPtr	FindConnectedSocket(ListenerQueuePtr listener);TCPSockPtr	FindZombieSocket(ListenerQueuePtr listener);void		RemoveSocketFromListenerQueue(TCPSockPtr sockToRemove, ListenerQueuePtr listener);ListenerQueuePtr ListenerQueueCreate(TCPSockPtr tcpSocket, int port, int backlogSize);void		ListenerQueueDestroy(ListenerQueuePtr listener);int			ListenerQueueStatus(ListenerQueuePtr listener);/*** Private UDP Socket Functions ***/void *		UDPSockCreate(void);void		UDPSockDestroy(UDPSockPtr s);void		UDPSockRemoveFromOpenList(UDPSockPtr s);int			UDPSockLocalAddress(UDPSockPtr s);int			UDPSockLocalPort(UDPSockPtr s);int			UDPSockRemoteAddress(UDPSockPtr s);int			UDPSockRemotePort(UDPSockPtr s);void		UDPSockConnectTo(UDPSockPtr s, int addr, int port);void		UDPSockListenOn(UDPSockPtr s, int port);int			UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize);int			UDPSockSendData(UDPSockPtr s, char *buf, int bufSize);/*** Other Private Functions ***/void		DestroyAllOpenSockets(void);void		InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr);void		InstallExitHandler(void);void		MyExitHandler(void);int			PortNumberValid(int port);pascal void	ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr);int			ResolverInitialize(int resolverSemaIndex);void		ResolverTerminate(void);int			SocketValid(SocketPtr s);void		TCPCloseCompletionRoutine(struct TCPiopb *s);void		TCPConnectCompletionRoutine(struct TCPiopb *s);pascal void	TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg);void		TCPSendCompletionRoutine(struct TCPiopb *s);/*** Network Functions ***/int sqNetworkInit(int resolverSemaIndex) {	/* initialize the network and return 0 if successful */	int localAddr;	UDPiopb paramBlock;	OSErr err = noErr;	if (thisNetSession !!= 0) return 0;  /* noop if network is already initialized */	/* open network driver */	macTCPRefNum = 0;	err = OpenDriver("\p.IPP", &macTCPRefNum);	if (err !!= noErr) {		return -1;	}	/* open resolver */	err = ResolverInitialize(resolverSemaIndex);	if (err !!= noErr) {		ResolverTerminate();		return -1;	}	/* get local address */	localAddr = sqResolverLocalAddress();	if (sqResolverError() !!= noErr) {		ResolverTerminate();		return -1;	}	/* compute MTU (maximum transfer unit) size */	memset(&paramBlock, 0, sizeof(paramBlock));	paramBlock.csCode = UDPMaxMTUSize;	paramBlock.csParam.mtu.remoteHost = localAddr;	paramBlock.ioCRefNum = macTCPRefNum;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err == noErr) {		mtuSize = paramBlock.csParam.mtu.mtuSize;	} else {		mtuSize = 1024;  /* guess */		ResolverTerminate();		return -1;	}	resolverDoneProc	= NewResultProc(ResolverCompletionRoutine);	tcpCloseDoneProc 	= NewTCPIOCompletionProc(TCPCloseCompletionRoutine);	tcpConnectDoneProc	= NewTCPIOCompletionProc(TCPConnectCompletionRoutine);	tcpNotifyProc		= NewTCPNotifyProc(TCPNotificationRoutine);	tcpSendDoneProc		= NewTCPIOCompletionProc(TCPSendCompletionRoutine);	InstallExitHandler();	/* Success!! Create a session ID that is unlikely to be	   repeated. Zero is never used for a valid session number.	*/	thisNetSession = clock() + time(NULL);	if (thisNetSession == 0) thisNetSession = 1;  /* don''t use 0 */	return 0;}void sqNetworkShutdown(void) {	/* shut down the network */	if (thisNetSession == 0) return;  /* noop if network is already shut down */	SetToolTrapAddress(oldExitHandlerProc, _ExitToShell);	ResolverTerminate();	DestroyAllOpenSockets();	thisNetSession = 0;}/*** Squeak Generic Socket Functions ***/void sqSocketAbortConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockAbortConnection((TCPSockPtr) s->privateSocketPtr);		return;	}	if (s->socketType == ListenerQueueType) {		((ListenerQueuePtr) s->privateSocketPtr)->closed = true; /* set closed flag */		return;	}	success(false);}void sqSocketCloseConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockCloseConnection((TCPSockPtr) s->privateSocketPtr);		return;	}	if (s->socketType == ListenerQueueType) {		((ListenerQueuePtr) s->privateSocketPtr)->closed = true; /* set closed flag */		return;	}	success(false);}int sqSocketConnectionStatus(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->connectStatus;	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->connectStatus;	}	if (s->socketType == ListenerQueueType) {		return ListenerQueueStatus((ListenerQueuePtr) s->privateSocketPtr);	}	success(false);}void sqSocketConnectToPort(SocketPtr s, int addr, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockConnectTo((TCPSockPtr) s->privateSocketPtr, addr, port);		return;	}	if (s->socketType == UDPSocketType) {		UDPSockConnectTo((UDPSockPtr) s->privateSocketPtr, addr, port);		return;	}	success(false);}void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex) {	TCPSockPtr tcpSock = nil;	UDPSockPtr udpSock = nil;	/* reference args to suppress compiler warnings about unused variables */	s; netType; recvBufSize; sendBufSize;	s->sessionID = 0;	if (socketType == TCPSocketType) {		tcpSock = TCPSockCreate();		if (tcpSock == nil) {			success(false);		} else {			tcpSock->semaIndex = semaIndex;			tcpSock->next = openTCPSockets;			openTCPSockets = tcpSock;			s->sessionID = thisNetSession;			s->socketType = TCPSocketType;			s->privateSocketPtr = tcpSock;		}		return;	}	if (s->socketType == UDPSocketType) {		udpSock = UDPSockCreate();		if (udpSock == nil) {			success(false);		} else {			udpSock->semaIndex = semaIndex;			udpSock->next = openUDPSockets;			openUDPSockets = udpSock;			s->sessionID = thisNetSession;			s->socketType = UDPSocketType;			s->privateSocketPtr = udpSock;		}		return;	}	success(false);}void sqSocketDestroy(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockDestroy((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		UDPSockDestroy((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		ListenerQueueDestroy((ListenerQueuePtr) s->privateSocketPtr);	}	s->sessionID = 0;	s->socketType = -1;	s->privateSocketPtr = nil;}int sqSocketError(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->lastError;	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->lastError;	}	if (s->socketType == ListenerQueueType) {		return 0;  /* ListenerQueue''s themselves never get an error */	}}void sqSocketListenOnPort(SocketPtr s, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockListenOn((TCPSockPtr) s->privateSocketPtr, port);		return;	}	if (s->socketType == UDPSocketType) {		UDPSockListenOn((UDPSockPtr) s->privateSocketPtr, port);		return;	}	success(false);}int sqSocketLocalAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalAddress((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockLocalAddress((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		return ((ListenerQueuePtr) s->privateSocketPtr)->localAddress;	}	success(false);}int sqSocketLocalPort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalPort((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockLocalPort((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		return ((ListenerQueuePtr) s->privateSocketPtr)->localPort;	}	success(false);}int sqSocketReceiveDataAvailable(SocketPtr s) {	if (!!SocketValid(s)) return 0;	if (s->socketType == TCPSocketType) {		return TCPSockDataAvailable((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->dataAvailable;	}	success(false);}int sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRecvData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	if (s->socketType == UDPSocketType) {		return UDPSockRecvData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	success(false);}int sqSocketRemoteAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemoteAddress((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockRemoteAddress((UDPSockPtr) s->privateSocketPtr);	}	success(false);}int sqSocketRemotePort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemotePort((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockRemotePort((UDPSockPtr) s->privateSocketPtr);	}	success(false);}int sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockSendData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	if (s->socketType == UDPSocketType) {		return UDPSockSendData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	success(false);}int sqSocketSendDone(SocketPtr s) {	if (!!SocketValid(s)) return 1;	if (s->socketType == TCPSocketType) {		return !!((TCPSockPtr) s->privateSocketPtr)->sendInProgress;	}	if (s->socketType == UDPSocketType) {		return !!((UDPSockPtr) s->privateSocketPtr)->sendInProgress;	}	success(false);}/*** Resolver Functions ***/void sqResolverAbort(void) {	int semaIndex;	/* abort the current request */	if (resolver.status == RESOLVER_BUSY) {		semaIndex = resolver.semaIndex;		ResolverTerminate();		ResolverInitialize(semaIndex);	}}void sqResolverAddrLookupResult(char *nameForAddress, int nameSize) {	/* copy the name found by the last address lookup into the given string */	memcpy(nameForAddress, resolver.hostInfo.cname, nameSize);}int sqResolverAddrLookupResultSize(void) {	return strlen(resolver.hostInfo.cname);}int sqResolverError(void) {	return resolver.error;}int sqResolverLocalAddress(void) {	struct GetAddrParamBlock paramBlock;	if (resolver.localAddress == 0) {		resolver.remoteAddress = 0;		memset(&paramBlock, 0, sizeof(struct GetAddrParamBlock));		paramBlock.ioResult = 1;		paramBlock.csCode = ipctlGetAddr;		paramBlock.ioCRefNum = macTCPRefNum;		PBControlSync((ParmBlkPtr) &paramBlock);		if (paramBlock.ioResult == noErr) {			resolver.status = RESOLVER_SUCCESS;			resolver.localAddress = paramBlock.ourAddress;			resolver.error = noErr;		} else {			resolver.status = RESOLVER_ERROR;			resolver.error = paramBlock.ioResult;		}	} else {		resolver.status = RESOLVER_SUCCESS;		resolver.error = noErr;	}	return resolver.localAddress;}int sqResolverNameLookupResult(void) {	/* return the result of the last successful lookup */	return resolver.remoteAddress;}void sqResolverStartAddrLookup(int address) {	OSErr err;	if (resolver.status == RESOLVER_BUSY) return;	resolver.status = RESOLVER_BUSY;	resolver.error = noErr;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = AddrToName(address, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;	} else {		if (err !!= cacheFault) {			/* real error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}void sqResolverStartNameLookup(char *hostName, int nameSize) {	char name[501];	int len; 	OSErr err;	if (resolver.status == RESOLVER_BUSY) return;	len = ((nameSize <= 500) ? nameSize : 500);	memcpy(name, hostName, len);	name[len] = ''\0'';	resolver.status = RESOLVER_BUSY;	resolver.error = noErr;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = StrToAddr(name, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;		resolver.remoteAddress = resolver.hostInfo.addr[0];	} else {		if (err !!= cacheFault) {			/* real error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}int sqResolverStatus(void) {	return resolver.status;}/*** Private Resolver Functions ***/int ResolverInitialize(int resolverSemaIndex) {	if (resolver.status !!= RESOLVER_UNINITIALIZED) {		ResolverTerminate();	}	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;	resolver.error = OpenResolver(nil);	if (resolver.error !!= noErr) {		resolver.status = RESOLVER_ERROR;		return resolver.error;	}	resolver.semaIndex = resolverSemaIndex;	resolver.status = RESOLVER_SUCCESS;	return noErr;}static pascal void ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr) {	ResolverStatusPtr r = (ResolverStatusPtr) userDataPtr;	if ((r == null) || (r->status !!= RESOLVER_BUSY)) return;	/* completion routine */	if (r->hostInfo.rtnCode == noErr) {		r->status = RESOLVER_SUCCESS;		r->remoteAddress = hostInfoPtr->addr[0];	} else {		r->status = RESOLVER_ERROR;		r->error = hostInfoPtr->rtnCode;	}	signalSemaphoreWithIndex(r->semaIndex);}void ResolverTerminate(void) {	CloseResolver();	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;}/*** Squeak TCP Socket Listen/Accept Functions ***/ListenerQueuePtr ListenerQueueCreate(TCPSockPtr tcpSocket, int port, int backlogSize) {	ListenerQueuePtr listener;	/* allocate a new ListenerQueue */	listener = (ListenerQueuePtr) malloc(sizeof(ListenerQueueRec));	if (listener == nil) return nil;	/* initialize it */	listener->localAddress = TCPSockLocalAddress(tcpSocket);	listener->localPort = port;	listener->closed = false;	listener->semaIndex = tcpSocket->semaIndex;	listener->desiredQueueLength = (backlogSize < 1) ? 1 : backlogSize;	listener->waitingSockets = nil;	/* add the given socket to the new ListenerQueue */	tcpSocket->nextInListenerQueue = listener->waitingSockets;	listener->waitingSockets = tcpSocket;	TCPSockListenOn(tcpSocket, listener->localPort);	/* create additional waiting sockets in necessary to fill the ListenerQueue */	FillListenerQueue(listener);	return listener;}void ListenerQueueDestroy(ListenerQueuePtr listener) {	TCPSockPtr thisSock, nextSock;	/* destroy all sockets in this ListenerQueue''s waiting socket list */	thisSock = listener->waitingSockets;	while (thisSock !!= nil) {		nextSock = thisSock->nextInListenerQueue;		TCPSockDestroy(thisSock);		thisSock = nextSock;	}	/* clear a few fields, just in case of a dangling reference */	listener->closed = true;	listener->semaIndex = 0;	listener->waitingSockets = nil;	/* free the ListenerQueue */	free(listener);}int ListenerQueueStatus(ListenerQueuePtr listener) {	TCPSockPtr sock;	if (listener == nil) {		success(false);		return Unconnected;	}	if (listener->closed) return Unconnected;	/* check for zombie sockets; if there is one, clean up the queue */	if (FindZombieSocket(listener) !!= nil) {		FillListenerQueue(listener);  /* removes zombies and refills queue */	}	/* scan queue for a connected socket */	sock = FindConnectedSocket(listener);	return (sock == nil) ? WaitingForConnection : Connected;}void FillListenerQueue(ListenerQueuePtr listener) {	TCPSockPtr sock, newSock;	int count, socksToAdd;	/* remove from the queue and destroy any zombie sockets */	while ((sock = FindZombieSocket(listener)) !!= nil) {		RemoveSocketFromListenerQueue(sock, listener);		TCPSockDestroy(sock);	}	/* count the number of remaining sockets */	count = 0;	sock = listener->waitingSockets;	while (sock !!= nil) {		count++;		sock = sock->nextInListenerQueue;	}	/* create enough new sockets up to fill ListenerQueue to desired size */	socksToAdd = listener->desiredQueueLength - count;	while (socksToAdd > 0) {		newSock = TCPSockCreate();		if (newSock!!= nil) {			/* set semaphore of the new socket*/			newSock->semaIndex = listener->semaIndex;			/* record new socket in openTCPSockets */			newSock->next = openTCPSockets;			openTCPSockets = newSock;			/* add new socket to the listener queue and start it listening */			newSock->nextInListenerQueue = listener->waitingSockets;			listener->waitingSockets = newSock;			TCPSockListenOn(newSock, listener->localPort);		}		socksToAdd--;	}}TCPSockPtr FindConnectedSocket(ListenerQueuePtr listener) {  /* Return the first connected socket in the given ListenerQueue,     or nil if there isn''t one. */	TCPSockPtr sock;	sock = listener->waitingSockets;	while (sock !!= nil) {		if (sock->connectStatus == Connected) return sock;		sock = sock->nextInListenerQueue;	}	return nil;}TCPSockPtr FindZombieSocket(ListenerQueuePtr listener) {  /* Return the first socket in the given ListenerQueue that is not connected or     waiting for a connection (we call this a zombie), or nil if there isn''t one.     Zombies are created when a connection is made but broken again before an     accept has been done. Since a zombie are no longer waiting for a connection,     it takes the place of listening socket. If the queue became filled with zombies     no connections could get through. Thus, zombies must be eliminated. As the     saying goes: "the only good zombie is a dead zombie." */	TCPSockPtr sock;	sock = listener->waitingSockets;	while (sock !!= nil) {		if ((sock->connectStatus !!= WaitingForConnection) &&			(sock->connectStatus !!= Connected)) return sock;		sock = sock->nextInListenerQueue;	}	return nil;}void sqSocketAcceptFromRecvBytesSendBytesSemaID(  SocketPtr s, SocketPtr serverSocket,  int recvBufSize, int sendBufSize, int semaIndex) {  /* Accept a connection for the given server socket. The server socket must     have been turned into a listener queue via sqSocketListenOnPortBacklogSize().     If successful, s is initialized to newly connected socket using the     given paramenters, and a new listening socket will be created and added     to the ListenerQueue to maintain the desired queue length. Note that MacTCP     allows multiple sockets to be listening on the same port number and, indeed,     this is the only way to support the Unix socket notion of a socket backlog. */	ListenerQueuePtr listener;	TCPSockPtr connectedSock;	/* server socket must be a valid ListenerQueue */	if ((serverSocket == nil) ||		(serverSocket->sessionID !!= thisNetSession) ||		(serverSocket->socketType !!= ListenerQueueType) ||		(serverSocket->privateSocketPtr == nil)) {			success(false);			return;	}	/* result socket must be a new, unintialized socket */	if ((s == nil) ||		(s->sessionID !!= 0) ||		(s->socketType !!= 0) ||		(s->privateSocketPtr !!= nil)) {			success(false);			return;	}	/* look for a connected socket */	listener = (ListenerQueuePtr) serverSocket->privateSocketPtr;	connectedSock = FindConnectedSocket(listener);	if (connectedSock == nil) {		success(false);	} else {		/* remove connected socket from the listener queue */		RemoveSocketFromListenerQueue(connectedSock, listener);		/* fill in the result socket handle */		connectedSock->semaIndex = semaIndex;		s->sessionID = thisNetSession;		s->socketType = TCPSocketType;		s->privateSocketPtr = connectedSock;	}	/* ensure that the queue has the desired number of listenening sockets */	FillListenerQueue(listener);}void RemoveSocketFromListenerQueue(TCPSockPtr sockToRemove, ListenerQueuePtr listener) {	TCPSockPtr lastSock, thisSock;	if (sockToRemove == nil) return;	if (listener->waitingSockets == sockToRemove) {		listener->waitingSockets = sockToRemove->nextInListenerQueue;		sockToRemove->nextInListenerQueue = nil;		return;	}	lastSock = listener->waitingSockets;	thisSock = lastSock->nextInListenerQueue;	while (thisSock !!= nil) {		if (thisSock == sockToRemove) {			lastSock->nextInListenerQueue = sockToRemove->nextInListenerQueue;			sockToRemove->nextInListenerQueue = nil;			return;		}		lastSock = thisSock;		thisSock = lastSock->nextInListenerQueue;	}}void sqSocketListenOnPortBacklogSize(SocketPtr s, int port, int backlogSize) {	TCPSockPtr tcpSocket;	ListenerQueuePtr listener;	/* s must be an TCP socket that is initialized but unconnected */	if ((!!SocketValid(s)) || (s->socketType !!= TCPSocketType)) {		success(false);		return;	}	tcpSocket = (TCPSockPtr) s->privateSocketPtr;	if (tcpSocket->connectStatus !!= Unconnected) {		success(false);		return;	}	/* make sure the port number is in range */	if (!!PortNumberValid(port)) {;		success(false);		return;	}	/* create a new listener on the given with the given backlog size */	listener = ListenerQueueCreate((TCPSockPtr) s->privateSocketPtr, port, backlogSize);	if (listener == nil) {		success(false);		return;	}	/* mutate s into a listener socket: replace the original TCP socket in s with	   the new listener, and change the type of s to ListenerQueueType */	s->socketType = ListenerQueueType;	s->privateSocketPtr = listener;}/*** Private TCP Socket Functions ***/void * TCPSockCreate(void) {	TCPiopb paramBlock;	TCPSockPtr s = nil;	int minRcvBufSize, rcvBufSize;	OSErr err = noErr;	rcvBufSize = RecvBufferSize;	minRcvBufSize = (4 * mtuSize) + 1024;	if (rcvBufSize < minRcvBufSize) rcvBufSize = minRcvBufSize;	s = (TCPSockPtr) malloc(sizeof(TCPSockRec) + rcvBufSize);	if (s == nil) return nil;  /* allocation failed */	memset(s, 0, sizeof(TCPSockRec) + rcvBufSize);	InitTCPCmd(TCPCreate, nil, &paramBlock);	paramBlock.csParam.create.rcvBuff = s->rcvBuf;	paramBlock.csParam.create.rcvBuffLen = rcvBufSize;	paramBlock.csParam.create.notifyProc = tcpNotifyProc;	paramBlock.csParam.create.userDataPtr = (Ptr) s;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		free(s);		return nil;	}	s->tcpStream = paramBlock.tcpStream;	return s;}int TCPSockDataAvailable(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return false;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.amtUnreadData > 0;}void TCPSockDestroy(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return;  /* already destroyed */	}	InitTCPCmd(TCPRelease, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	TCPSockRemoveFromOpenList(s);	s->tcpStream = nil;	free(s);}int TCPSockLocalAddress(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localHost;}int TCPSockLocalPort(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localPort;}int TCPSockRemoteAddress(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remoteHost;}int TCPSockRemotePort(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remotePort;}void TCPSockRemoveFromOpenList(TCPSockPtr s) {	TCPSockPtr thisSock, nextSock, previousSock;	previousSock = nil;	for (thisSock = openTCPSockets; thisSock !!= nil; thisSock = nextSock) {		nextSock = thisSock->next;		if (thisSock == s) {			if (previousSock == nil) {				openTCPSockets = nextSock;			} else {				previousSock->next = nextSock;			}			break;		}		previousSock = thisSock;	}}void TCPSockConnectTo(TCPSockPtr s, int addr, int port) {	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPActiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.remoteHost = addr;	s->tcpPB.csParam.open.remotePort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->connectStatus = Unconnected;	}}void TCPSockListenOn(TCPSockPtr s, int port) {	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPPassiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.localPort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->connectStatus = Unconnected;	}}void TCPSockCloseConnection(TCPSockPtr s) {	/* Note: This operation uses a dedicated parameter block so that it	   can be invoked even in the previous send is not yet complete.	   It will eventually use a completion routine to delete the	   socket automatically. For now, this is the client''s responsibility.	*/	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPClose, s->tcpStream, &s->closePB);//	s->closePB.ioCompletion = tcpCloseDoneProc;	s->connectStatus = ThisEndClosed; // xxx remove when making this async	s->lastError = PBControlSync((ParmBlkPtr) &s->closePB);}void TCPSockAbortConnection(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPAbort, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	s->connectStatus = Unconnected;}int TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize) {	TCPiopb paramBlock;  /* use local parameter block since send may be using one in socket */	OSErr err = noErr;	int bytesRead;	if ((s->connectStatus == Unconnected) || (s->connectStatus == WaitingForConnection)) {		success(false);		return 0;  /* fail if not connected */	}	if (!!TCPSockDataAvailable(s)) return 0;  /* no data available */	InitTCPCmd(TCPRcv, s->tcpStream, &paramBlock);	paramBlock.csParam.receive.commandTimeoutValue = 1; /* finish in one second, data or not */	paramBlock.csParam.receive.rcvBuff = buf;	paramBlock.csParam.receive.rcvBuffLen = bufSize;	s->lastError = noErr;	err = PBControlSync((ParmBlkPtr) &paramBlock);  /* synchronous */	if (err == noErr) {		bytesRead = paramBlock.csParam.receive.rcvBuffLen;	} else {		/* if err == commandTimeout, no data was available */		bytesRead = 0;		if (!!((err == commandTimeout) || (err == connectionClosing))) {			s->lastError = err;		}	}	s->dataAvailable = (bytesRead !!= 0);  /* if we got data, there may be more */	return bytesRead;}int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize);int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	int sendCount;	struct wdsEntry wds[2];	buf;  /* xxx avoid compiler complaint about unreferenced vars */	/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;//xxx	memcpy(s->sendBuf, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	wds[0].length = sendCount;//xxx		wds[0].ptr = s->sendBuf;	wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.send.wdsPtr = (Ptr) &wds;	s->tcpPB.csParam.send.pushFlag = true;	s->sendInProgress = true;	s->tcpPB.ioCompletion = tcpSendDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->sendInProgress = false;		return 0;	}	return sendCount;}int TCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	TCPSendBufPtr sendBuf;	int sendCount;	if ((s->connectStatus == Unconnected) || (s->connectStatus == WaitingForConnection)) {		success(false);		return 0;  /* fail if not connected */	}	sendBuf = &sendBufPool[nextSendBuf++];	if (nextSendBuf >= SendBufCount) nextSendBuf = 0;	sendBuf->mySocket = s;	/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;	memcpy(sendBuf->data, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	sendBuf->wds[0].length = sendCount;	sendBuf->wds[0].ptr = sendBuf->data;	sendBuf->wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &sendBuf->tcpPB);	sendBuf->tcpPB.csParam.send.wdsPtr = (Ptr) &sendBuf->wds;	sendBuf->tcpPB.csParam.send.pushFlag = true;	sendBuf->tcpPB.ioCompletion = tcpSendDoneProc;	s->sendInProgress = true;	s->lastError = PBControlAsync((ParmBlkPtr) &sendBuf->tcpPB);	if (s->lastError !!= noErr) {		s->sendInProgress = false;		return 0;	}	return sendCount;}/*** Private General Utilities ***/void DestroyAllOpenSockets(void) {	while (openTCPSockets !!= nil) {		TCPSockDestroy(openTCPSockets);  /* removes socket from the list */	}	while (openUDPSockets !!= nil) {		UDPSockDestroy(openUDPSockets);  /* removes socket from the list */	}}void InstallExitHandler(void) {	/* Install a handler to release all open sockets when terminating this	   application. The handler will be called even if you type ''es'' to	   MacsBug or use Command-Option-Escape for force the program to exit.	   The handler is only installed the first time the network is initialized.	*/	if (oldExitHandlerProc == nil) {		oldExitHandlerProc = GetToolTrapAddress(_ExitToShell);		myExitHandlerProc = 			NewRoutineDescriptor((ProcPtr) MyExitHandler, kPascalStackBased, GetCurrentISA());		SetToolTrapAddress(myExitHandlerProc, _ExitToShell);	}}void MyExitHandler(void) {	SetCurrentA5();	SetToolTrapAddress(oldExitHandlerProc, _ExitToShell);	ResolverTerminate();	DestroyAllOpenSockets();	ExitToShell();}int PortNumberValid(int port) {	if (port < 0xFFFF) {		return true;	}	success(false);	return false;}int SocketValid(SocketPtr s) {	if ((s !!= NULL) &&		(s->privateSocketPtr !!= NULL) &&		(s->sessionID == thisNetSession)) {			if (s->socketType == TCPSocketType) {				if (((TCPSockPtr) s->privateSocketPtr)->tcpStream !!= nil) {					return true;				}			}			return true;	}	success(false);	return false;}/*** Private TCP Utilities ***/void InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr) {	memset(paramBlkPtr, 0, sizeof(TCPiopb));	paramBlkPtr->csCode = cmd;	paramBlkPtr->tcpStream = tcpStream;	paramBlkPtr->ioCRefNum = macTCPRefNum;	paramBlkPtr->ioResult = 1;}void TCPCloseCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		if (s->connectStatus == OtherEndClosed) {			s->connectStatus = Unconnected;		} else {			s->connectStatus = ThisEndClosed;		}	}	signalSemaphoreWithIndex(s->semaIndex);}void TCPConnectCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		s->connectStatus = Connected;	} else {		s->connectStatus = Unconnected;	}	signalSemaphoreWithIndex(s->semaIndex);}pascal void TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg) {	/* called when data arrives or stream status changes */	/* reference args to suppress compiler warnings about unused variables */	s; terminReason; icmpMsg;	if (eventCode == TCPDataArrival) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->dataAvailable = true;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPClosing) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		if (tcpSock->connectStatus == ThisEndClosed) {			tcpSock->connectStatus = Unconnected;		} else {			tcpSock->connectStatus = OtherEndClosed;		}		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPTerminate) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->connectStatus = Unconnected;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}}void TCPSendCompletionRoutine(struct TCPiopb *pbPtr) {//xxx	TCPSockPtr s = (TCPSockPtr) pbPtr;TCPSockPtr s = ((TCPSendBufPtr) pbPtr)->mySocket;	s->lastError = s->tcpPB.ioResult;	s->sendInProgress = false;	signalSemaphoreWithIndex(s->semaIndex);}/*** Private UDP Socket Functions (not yet implemented) ***/void * UDPSockCreate(void) {	return nil;}void UDPSockDestroy(UDPSockPtr s) {	s;}int UDPSockLocalAddress(UDPSockPtr s) {	s;}int UDPSockLocalPort(UDPSockPtr s) {	s;}int UDPSockRemoteAddress(UDPSockPtr s) {	s;}int UDPSockRemotePort(UDPSockPtr s) {	s;}void UDPSockConnectTo(UDPSockPtr s, int addr, int port) {	s; addr; port;}void UDPSockListenOn(UDPSockPtr s, int port) {	s; port;}int UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize) {	s; buf; bufSize;}int UDPSockSendData(UDPSockPtr s, char *buf, int bufSize) {	s; buf; bufSize;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/25/2000 18:35'!macSerialAndMIDIPortFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "SerialPlugin.h"#include "MidiPlugin.h"/* initialize/shutdown */int midiInit() { return true; }int midiShutdown() {}int serialPortInit() { return true; }int serialPortShutdown() {	serialPortClose(0);	serialPortClose(1);}/* helper function for MIDI module */int sqMIDIParameter(int whichParameter, int modify, int newValue);int sqMIDIParameterSet(int whichParameter, int newValue) {	sqMIDIParameter(whichParameter, true, newValue);}int sqMIDIParameterGet(int whichParameter) {	sqMIDIParameter(whichParameter, false, 0);}/* End of adjustments for pluginized VM */#include <CommResources.h>#include <CRMSerialDevices.h>#include <Devices.h>#include <QuickTimeComponents.h>#include <QuickTimeMusic.h>#include <Serial.h>#include <Strings.h>/*** Constants ***/#define INPUT_BUF_SIZE 1000#define FIRST_DRUM_KIT 16385/*** Imported Variables ***/extern int successFlag;/*** Serial Ports ***/#define MAX_PORTS 4short inRefNum[MAX_PORTS] = {0, 0, 0, 0};short outRefNum[MAX_PORTS] = {0, 0, 0, 0};char inputBuffer[MAX_PORTS][INPUT_BUF_SIZE];/* Quicktime MIDI note allocator and channels */NoteAllocator na = nil;NoteChannel channel[16] = {	nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil};/* Initial instruments: drums on channel 10, piano on all other channels */int channelInstrument[16] = {	1, 1, 1, 1, 1, 1, 1, 1, 1, FIRST_DRUM_KIT, 1, 1, 1, 1, 1, 1};/* Quicktime MIDI parser state */enum {idle, want1of2, want2of2, want1of1, sysExclusive};int state = idle;int argByte1 = 0;int argByte2 = 0;int lastCmdByte = nil;/* number of argument bytes for each MIDI command */char argumentBytes[128] = {	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	3, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};/*** Private Functions ***/int portIsOpen(int portNum);int portNames(int portNum, char *portName, char *inName, char *outName);int serialPortCount(void);int setHandshakeOptions(int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int setMidiClockRate(int portNum, int interfaceClockRate);/*** Quicktime MIDI Support Functions ***/void closeQuicktimeMIDIPort(void);void openQuicktimeMIDIPort(void);void performMIDICmd(int cmdByte, int arg1, int arg2);void processMIDIByte(int aByte);void startMIDICommand(int cmdByte);int serialPortCount(void) {  /* Return the number of serial ports available on this machine */ 	CRMRec		commRec; 	CRMRecPtr	thisRecPtr; 	int			count = 0; 	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    }    if (count > MAX_PORTS) count = MAX_PORTS; 	return count; }int portIsOpen(int portNum) {	if ((portNum < 0) || (portNum > 1)) return false;	return outRefNum[portNum] !!= 0;}int portNames(int portNum, char *portName, char *inName, char *outName) {/* Fill in the user name and input and output port names for the given   port number. Note that ports are numbered starting with zero. */ 	CRMRec			commRec; 	CRMRecPtr		thisRecPtr; 	CRMSerialPtr	serialPtr; 	int				count = 0;  	portName[0] = inName[0] = outName[0] = 0;	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		if (count == portNum) {			serialPtr = (CRMSerialPtr) thisRecPtr->crmAttributes;			strcpy(portName, p2cstr(*(serialPtr->name)));			strcpy(inName, p2cstr(*(serialPtr->inputDriverName)));			strcpy(outName, p2cstr(*(serialPtr->outputDriverName)));			c2pstr((void *) *(serialPtr->name));			c2pstr((void *) *(serialPtr->inputDriverName));			c2pstr((void *) *(serialPtr->outputDriverName)); 		} 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    } }int setHandshakeOptions(  int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Set the given port''s handshaking parameters. */	SerShk handshakeOptions;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	handshakeOptions.fInX = false;	handshakeOptions.fDTR = false;	if (inFlowCtrl == 1) handshakeOptions.fInX = true;  /* XOn/XOff handshaking */	if (inFlowCtrl == 2) handshakeOptions.fDTR = true;  /* hardware handshaking */	handshakeOptions.fXOn = false;	handshakeOptions.fCTS = false;	if (outFlowCtrl == 1) handshakeOptions.fXOn = true;  /* XOn/XOff handshaking */	if (outFlowCtrl == 2) handshakeOptions.fCTS = true;  /* hardware handshaking */	handshakeOptions.xOn  = xOnChar;	/* XOn character */	handshakeOptions.xOff = xOffChar;	/* XOff character */	handshakeOptions.errs = 0;			/* clear errors mask bits */	handshakeOptions.evts = 0;			/* clear event enable mask bits */	osErr = Control(outRefNum[portNum], 14, &handshakeOptions);	if (osErr !!= noErr) {		success(false);	}}int setMidiClockRate(int portNum, int interfaceClockRate) {/* Put the given port into MIDI mode, which uses a clock supplied   by an external MIDI interface adaptor to determine the baud rate.   Possible external clock rates: 31.25 KHz, 0.5 MHz, 1 MHz, or 2 MHz. */	char midiParam = 15;  /* dummy value */	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	if (interfaceClockRate ==   31250) midiParam = 0x00;	if (interfaceClockRate ==  500000) midiParam = 0x40;	if (interfaceClockRate == 1000000) midiParam = 0x80;	if (interfaceClockRate == 2000000) midiParam = 0xC0;	if (midiParam == 15) {		return success(false);  /* bad interfaceClockRate */	}	osErr = Control(outRefNum[portNum], 15, &midiParam);	if (osErr !!= noErr) {		return success(false);	}}/*** Serial Port Functions ***/int serialPortClose(int portNum) {	int osErr;	if ((portNum < 0) || (portNum > 1)) {		return success(false); /* bad port number */	}	if (!!portIsOpen(portNum)) {		return;  /* already closed */	}	osErr = KillIO(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(inRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	inRefNum[portNum] = 0;	outRefNum[portNum] = 0;}int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Open the given serial port using the given settings. The baud rate can be   any number between about 224 and 57600; the driver will pick a clock   divisor that will generate the closest available baud rate. */	short int options, baudRateParam;	char userName[256], inName[256], outName[256];	int osErr;	if ((portNum < 0) || (portNum > 1) || portIsOpen(portNum)) {		return success(false); /* bad port number or port already open */	}	options = baud9600;	switch (stopBitsType) {	case 0:		options += stop15;		break;	case 1:		options += stop10;		break;	case 2:		options += stop20;		break;	default:		return success(false);	}	switch (parityType) {	case 0:		options += noParity;		break;	case 1:		options += oddParity;		break;	case 2:		options += evenParity;		break;	default:		return success(false);	}	switch (dataBits) {	case 5:		options += data5;		break;	case 6:		options += data6;		break;	case 7:		options += data7;		break;	case 8:		options += data8;		break;	default:		return success(false);	}	portNames(portNum, userName, inName, outName);	osErr = OpenDriver(c2pstr(outName), &outRefNum[portNum]);	if (osErr !!= noErr) {		return success(false);	}	osErr = OpenDriver(c2pstr(inName), &inRefNum[portNum]);	if (osErr !!= noErr) {		CloseDriver(outRefNum[portNum]);		return success(false);	}	/* set the handshaking options */	setHandshakeOptions(portNum, inFlowCtrl, outFlowCtrl, xOnChar, xOffChar);	/* install a larger input buffer */	osErr = SerSetBuf(inRefNum[portNum], &inputBuffer[portNum][0], INPUT_BUF_SIZE);	if (osErr !!= noErr) {		success(false);	}	/* set data bits, parity type, and stop bits */	osErr = SerReset(outRefNum[portNum], options);	if (osErr !!= noErr) {		success(false);	}	/* set the baud rate (e.g., the value 9600 gives 9600 baud) */	baudRateParam = baudRate;	osErr = Control(outRefNum[portNum], 13, &baudRateParam);	if (osErr !!= noErr) {		success(false);	}	if (!!successFlag) {		CloseDriver(inRefNum[portNum]);		CloseDriver(outRefNum[portNum]);		inRefNum[portNum] = 0;		outRefNum[portNum] = 0;	}}int serialPortReadInto(int portNum, int count, int bufferPtr) {/* Read up to count bytes from the given serial port into the given byte array.   Read only up to the number of bytes in the port''s input buffer; if fewer bytes   than count have been received, do not wait for additional data to arrive.   Return zero if no data is available. */	long int byteCount;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = SerGetBuf(inRefNum[portNum], &byteCount);  /* bytes available */	if (osErr !!= noErr) {		return success(false);	}	if (byteCount > count) byteCount = count;  /* read at most count bytes */	osErr = FSRead(inRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;}int serialPortWriteFrom(int portNum, int count, int bufferPtr) {/* Write count bytes from the given byte array to the given serial port''s   output buffer. Return the number of bytes written. This implementation is   synchronous: it doesn''t return until the data has been sent. However, other   implementations may return before transmission is complete. */	long int byteCount = count;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = FSWrite(outRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;}/*** MIDI Parameters (used with sqMIDIParameter function) ***/#define sqMIDIInstalled				1/* Read-only. Return 1 if a MIDI driver is installed, 0 if not.   On OMS-based MIDI drivers, this returns 1 only if the OMS   system is properly installed and configured. */#define sqMIDIVersion				2/* Read-only. Return the integer version number of this MIDI driver.   The version numbering sequence is relative to a particular driver.   That is, version 3 of the Macintosh MIDI driver is not necessarily   related to version 3 of the Win95 MIDI driver. */#define sqMIDIHasBuffer				3/* Read-only. Return 1 if this MIDI driver has a time-stamped output   buffer, 0 otherwise. Such a buffer allows the client to schedule   MIDI output packets to be sent later. This can allow more precise   timing, since the driver uses timer interrupts to send the data   at the right time even if the processor is in the midst of a   long-running Squeak primitive or is running some other application   or system task. */#define sqMIDIHasDurs				4/* Read-only. Return 1 if this MIDI driver supports an extended   primitive for note-playing that includes the note duration and   schedules both the note-on and the note-off messages in the   driver. Otherwise, return 0. */#define sqMIDICanSetClock			5/* Read-only. Return 1 if this MIDI drivers clock can be set   via an extended primitive, 0 if not. */#define sqMIDICanUseSemaphore		6/* Read-only. Return 1 if this MIDI driver can signal a semaphore   when MIDI input arrives. Otherwise, return 0. If this driver   supports controller caching and it is enabled, then incoming   controller messages will not signal the semaphore. */#define sqMIDIEchoOn				7/* Read-write. If this flag is set to a non-zero value, and if   the driver supports echoing, then incoming MIDI events will   be echoed immediately. If this driver does not support echoing,   then queries of this parameter will always return 0 and   attempts to change its value will do nothing. */#define sqMIDIUseControllerCache	8/* Read-write. If this flag is set to a non-zero value, and if   the driver supports a controller cache, then the driver will   maintain a cache of the latest value seen for each MIDI controller,   and control update messages will be filtered out of the incoming   MIDI stream. An extended MIDI primitive allows the client to   poll the driver for the current value of each controller. If   this driver does not support a controller cache, then queries   of this parameter will always return 0 and attempts to change   its value will do nothing. */#define sqMIDIEventsAvailable		9/* Read-only. Return the number of MIDI packets in the input queue. */#define sqMIDIFlushDriver			10/* Write-only. Setting this parameter to any value forces the driver   to flush its I/0 buffer, discarding all unprocessed data. Reading   this parameter returns 0. Setting this parameter will do nothing   if the driver does not support buffer flushing. */#define sqMIDIClockTicksPerSec		11/* Read-only. Return the MIDI clock rate in ticks per second. */#define sqMIDIHasInputClock			12/* Read-only. Return 1 if this MIDI driver timestamps incoming   MIDI data with the current value of the MIDI clock, 0 otherwise.   If the driver does not support such timestamping, then the   client must read input data frequently and provide its own   timestamping. *//*** MIDI Functions ***/int sqMIDIClosePort(int portNum) {/* Close the given MIDI port. Do nothing if the port is not open.   Fail if there is no port of the given number.*/	int serialPorts;		serialPorts = serialPortCount();	if (portNum == serialPorts) {		closeQuicktimeMIDIPort();		return;	} else {		return serialPortClose(portNum);	}}int sqMIDIGetClock(void) {/* Return the current value of the clock used to schedule MIDI events.   The MIDI clock is assumed to wrap at or before half the maximum   positive SmallInteger value. This allows events to be scheduled   into the future without overflowing into LargePositiveIntegers.    This implementation does not support event scheduling, so it   just returns the value of the Squeak millisecond clock. */	return ioMicroMSecs();}int sqMIDIGetPortCount(void) {/* Return the number of available MIDI interfaces, including both   hardware ports and software entities that act like ports. Ports   are numbered from 0 to N-1, where N is the number returned by this   primitive. */	return serialPortCount() + 1;  /* serial ports + QuickTime Synth */}int sqMIDIGetPortDirectionality(int portNum) {/* Return an integer indicating the directionality of the given   port where: 1 = input, 2 = output, 3 = bidirectional. Fail if   there is no port of the given number. */		int serialPorts;		serialPorts = serialPortCount();	if (portNum > serialPorts) return success(false);	if (portNum == serialPorts) {		return 2;	} else {		return 3;	}}int sqMIDIGetPortName(int portNum, int namePtr, int length) {/* Copy the name of the given MIDI port into the string at the given   address. Copy at most length characters, and return the number of   characters copied. Fail if there is no port of the given number.*/	char userName[256], inName[256], outName[256];	int serialPorts, count;		serialPorts = serialPortCount();	if (portNum > serialPorts) return success(false);	if (portNum == serialPorts) {		strcpy(userName, "QuickTime MIDI");	} else {		portNames(portNum, userName, inName, outName);	}	count = strlen(userName);	if (count > length) count = length;	memcpy((void *) namePtr, userName, count);	return count;}int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate) {/* Open the given port, if possible. If non-zero, readSemaphoreIndex   specifies the index in the external objects array of a semaphore   to be signalled when incoming MIDI data is available. Note that   not all implementations support read semaphores (this one does   not); see sqMIDICanUseSemaphore. The interfaceClockRate parameter   specifies the clock speed for an external MIDI interface   adaptor on platforms that use such adaptors (e.g., Macintosh).   Fail if there is no port of the given number.*/	int serialPorts;		serialPorts = serialPortCount();	if (portNum > serialPorts) return success(false);	if (portNum == serialPorts) {		openQuicktimeMIDIPort();		return;	}	serialPortOpen(portNum, 9600, 1, 0, 8, 0, 0, 0, 0);	if (successFlag) {		setMidiClockRate(portNum, interfaceClockRate);		if (!!successFlag) {			serialPortClose(portNum);		}	}}int sqMIDIParameter(int whichParameter, int modify, int newValue) {/* Read or write the given MIDI driver parameter. If modify is 0,   then newValue is ignored and the current value of the specified   parameter is returned. If modify is non-zero, then the specified   parameter is set to newValue. Note that many MIDI driver parameters   are read-only; attempting to set one of these parameters fails.   For boolean parameters, true = 1, false = 0. */	if (modify == 0) {		switch(whichParameter) {		case sqMIDIInstalled:			return 1;			break;		case sqMIDIVersion:			return 100;			break;		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:		case sqMIDIEchoOn:		case sqMIDIUseControllerCache:			return 0;			break;		case sqMIDIEventsAvailable:			return 1;  /* pretend that events are always available */			break;		case sqMIDIFlushDriver:			return 0;			break;		case sqMIDIClockTicksPerSec:			return 1000;			break;		case sqMIDIHasInputClock:			return 0;			break;		default:			return success(false);		}	} else {		switch(whichParameter) {		case sqMIDIInstalled:		case sqMIDIVersion:		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:			return success(false);			break;		case sqMIDIEchoOn:			/* noop; echoing not supported */			break;		case sqMIDIUseControllerCache:			/* noop; controller cache not supported */			break;		case sqMIDIEventsAvailable:			return success(false);			break;		case sqMIDIFlushDriver:			/* noop; buffer flushing not supported */			break;		case sqMIDIClockTicksPerSec:			return success(false);			break;		default:			return success(false);		}	}}int sqMIDIPortReadInto(int portNum, int count, int bufferPtr) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Copy up to (length - 4) bytes   of incoming MIDI data into that buffer, preceded by a 4-byte   timestamp in the units of the MIDI clock, most significant byte   first. Implementations that do not support timestamping of   incoming data as it arrives (see sqMIDIHasInputClock) simply   set the timestamp to the value of the MIDI clock when this   function is called. Return the total number of bytes read,   including the timestamp bytes. Return zero if no data is   available. Fail if the buffer is shorter than five bytes,   since there must be enough room for the timestamp plus at   least one data byte. */	int bytesRead;	if (count < 5) return success(false);	bytesRead = serialPortReadInto(portNum, count - 4, bufferPtr + 4);	if (bytesRead == 0) return 0;	*((int *) bufferPtr) = sqMIDIGetClock();  /* set timestamp */	return bytesRead + 4;}int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Send its contents to the given   port when the MIDI clock reaches the given time. If time equals   zero, then send the data immediately. Implementations that do   not support a timestamped output queue, such as this one, always   send the data immediately; see sqMIDIHasBuffer. */	int serialPorts, i;	unsigned char *bytePtr;		serialPorts = serialPortCount();	if (portNum > serialPorts) return success(false);	if (portNum == serialPorts) {		if (!!na) return success(false);  /* QuickTime port not open */		bytePtr = (unsigned char *) bufferPtr;		for (i = 0; i < count; i++) {			processMIDIByte(*bytePtr++);		}		return count;	}	return serialPortWriteFrom(portNum, count, bufferPtr);}/*** Quicktime MIDI Support Functions ***/void closeQuicktimeMIDIPort(void) {	int i;	if (!!na) return;	for (i = 0; i < 16; i++) {		/* dispose of note channels */		if (channel[i]) NADisposeNoteChannel(na, channel[i]);		channel[i] = nil;	}	CloseComponent(na);  /* close note allocator */}void openQuicktimeMIDIPort(void) {	ComponentResult err;	NoteRequest nr;	NoteChannel nc;	int i;	closeQuicktimeMIDIPort();	na = OpenDefaultComponent(''nota'', 0);	if (!!na) return;	for (i = 0; i < 16; i++) {		nr.info.polyphony = 11;					/* max simultaneous tones */		nr.info.typicalPolyphony = 0x00010000;	/* typical simultaneous tones */		NAStuffToneDescription(na, 1, &nr.tone);		err = NANewNoteChannel(na, &nr, &nc);		if (err || !!nc) {			closeQuicktimeMIDIPort();			return;		}		NAResetNoteChannel(na, nc);		NASetInstrumentNumber(na, nc, channelInstrument[i]);		channel[i] = nc;	}	state = idle;	argByte1 = 0;	argByte2 = 0;	lastCmdByte = nil;	return;}void performMIDICmd(int cmdByte, int arg1, int arg2) {	/* Perform the given MIDI command with the given arguments. */	int ch, cmd, val, instrument, bend;	ch = cmdByte & 0x0F;	cmd = cmdByte & 0xF0;	if (cmd == 128) {  /* note off */		NAPlayNote(na, channel[ch], arg1, 0);	}	if (cmd == 144) {  /* note on */		NAPlayNote(na, channel[ch], arg1, arg2);	}	if (cmd == 176) {  /* control change */		if ((arg1 >= 32) && (arg1 <= 63)) {			val = arg2 << 1;  /* LSB of controllers 0-31 */		} else {			val = arg2 << 8;  /* scale MSB to QT controller range */		}		NASetController(na, channel[ch], arg1, val);	}	if (cmd == 192) {  /* program change */		if (ch == 9) {			instrument = FIRST_DRUM_KIT + arg1;  /* if channel 10, select a drum set */		} else {			instrument = arg1 + 1;		}		NASetInstrumentNumber(na, channel[ch], instrument);		channelInstrument[ch] = instrument;	}	if (cmd == 224) {  /* pitch bend */		bend = ((arg2 << 7) + arg1) - (64 << 7);		bend = bend / 32;  /* default sensitivity = +/- 2 semitones */		NASetController(na, channel[ch], kControllerPitchBend, bend);	}}void processMIDIByte(int aByte) {	/* Process the given incoming MIDI byte and perform any completed commands. */	if (aByte > 247) return;  /* skip all real-time messages */	switch (state) {	case idle:		if (aByte >= 128) {			/* start a new command using the action table */			startMIDICommand(aByte);		} else {			/* data byte arrived in idle state: use running status if possible */			if (lastCmdByte == nil) {				return;  /* last command byte is not defined; just skip this byte */			} else {				/* process this data as if it had the last command byte in front of it */				startMIDICommand(lastCmdByte);				/* the previous line put us into a new state; we now do a recursive			   	   call to process the data byte in this new state. */				processMIDIByte(aByte);				return;			}		}		break;	case want1of2:		argByte1 = aByte;		state = want2of2;		break;	case want2of2:		argByte2 = aByte;		performMIDICmd(lastCmdByte, argByte1, argByte2);		state = idle;		break;	case want1of1:		argByte1 = aByte;		performMIDICmd(lastCmdByte, argByte1, 0);		state = idle;		break;	case sysExclusive:		if (aByte < 128) {			/* skip a system exclusive data byte */		} else {			if (aByte < 248) {				/* a system exclusive message can be terminated by any non-real-time command byte */				state = idle;				if (aByte !!= 247) {					processMIDIByte(aByte);	/* if not endSysExclusive, byte is the start the next command */				}			}		}		break;	}}void startMIDICommand(int cmdByte) {	/* Start processing a MIDI message beginning with the given command byte. */	int argCount;	argCount = argumentBytes[cmdByte - 128];	switch (argCount) {	case 0:						/* start a zero argument command (e.g., a real-time message) */		/* Stay in the current state and don''t change active status.		   Real-time messages may arrive between data bytes without disruption. */		performMIDICmd(cmdByte, 0, 0);		break;	case 1:						/* start a one argument command */		lastCmdByte = cmdByte;		state = want1of1;		break;	case 2:						/* start a two argument command */		lastCmdByte = cmdByte;		state = want1of2;		break;	case 3:						/* start a variable length ''system exclusive'' command */		/* a system exclusive command clears running status */		lastCmdByte = nil;		state = sysExclusive;		break;	}}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/25/2000 18:37'!macSoundFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "SoundPlugin.h"/* initialize/shutdown */int soundInit() { return true; }int soundShutdown() { snd_Stop(); }/* End of adjustments for pluginized VM */#include <Sound.h>#include <SoundInput.h>/******  Mac Sound Output Notes:	The Squeak sound code produces 16-bit, stereo sound buffers. The was	arrived at after experimentation on a PPC 601 at 110 MHz on which I	found that:	  a. using 16-bit sound only slightly increased the background CPU burden and	  b. 16-bit sound yielded vastly superior sound quality.	My understanding is that SoundManager 3.0 or later supports the 16-bit	sound interface an all Macs, even if the hardware only supports 8-bits.	If this is not true, however, change BYTES_PER_SAMPLE to 1. Then, either	the Squeak code will need to be changed to use 8-bit sound buffers,	or (preferrably) snd_PlaySamplesFromAtLength will need to do the conversion	from 16 to 8 bits. I plan to cross that bridge if and when we need to.	The code as currently written was to support Squeak code that generated	8-bit sound buffers.	In earlier versions, I experimented with other sound buffer formats. Here	are all the sound buffer formats that were used at one point or another:		1. mono,    8-bits -- packed array of bytes (not currently used)		2. stereo,  8-bits -- as above, with L and R channels in alternate bytes (not currently used)		3. stereo, 16-bits -- array of 32-bit words; with L and R channels in high and low half-words	Note:  8-bit samples are encoded with 0x80 as the center (zero) value	Note: 16-bit samples are encoded as standard, signed integers (i.e., 2''s-complement)	Note: When the sound drive is operating in "mono", the two stereo channels are mixed	      together. This feature was added in January, 1998.	-- John Maloney, July 28, 1996	-- edited: John Maloney, January 5, 1998  Mac Sound Input Notes:	Squeak sound input is currently defined to provide a single (mono) stream	of signed 16-bit samples for all platforms. Platforms that only support	8-bit sound input should convert samples to signed 16 bit values, leaving	the low order bits zero. Since the available sampling rates differ from	platform to platform, the client may not get the requested sampling rate;	however, the call snd_GetRecordingSampleRate returns the sampling rate.	On many platforms, simultaneous record and playback is permitted only if	the input and output sampling rates are the same.	-- John Maloney, Aug 22, 1997******/#define BYTES_PER_SAMPLE 2/*** double-buffer state record ***/typedef struct {	int open;	int stereo;	int frameCount;	int sampleRate;	int lastFlipTime;	int playSemaIndex;	int bufSizeInBytes;	int bufState0;	int bufState1;	int done;} PlayStateRec;/*** possible buffer states ***/#define BUF_EMPTY	0#define BUF_FULL	1#define BUF_PLAYING	2/*** record buffer state record ***//* Note: RECORD_BUFFER_SIZE should be a multiple of 4096 bytes to avoid clicking.   (The clicking was observed on a Mac 8100; the behavior of other Macs could differ.)   Note: G3 Series Powerbook requires minimum of 4 * 4096 buffer size for stereo.*/#define RECORD_BUFFER_SIZE (4096 * 2)typedef struct {	SPB paramBlock;	int stereo;	int bytesPerSample;	int recordSemaIndex;	int readIndex;  /* index of the next sample to read */	char samples[RECORD_BUFFER_SIZE];} RecordBufferRec, *RecordBuffer;/*** sound output variables ***/SndChannelPtr chan;PlayStateRec bufState = {false, false, 0, 0, 0, 0, 0, 0, 0, true};SndDoubleBufferHeader dblBufHeader;/*** sound input variables ***/RecordBufferRec recordBuffer1, recordBuffer2;int recordingInProgress;long soundInputRefNum;/*** local functions ***/pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf);int FillBufferWithSilence(SndDoubleBufferPtr buf);pascal void FlipRecordBuffers(SPBPtr pb);int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex);pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf) {  /* Switch buffers (at interrupt time). The given buffer just finished playing. */	PlayStateRec *state;	chan;  /* reference argument to avoid compiler warnings */	state = (PlayStateRec *) buf->dbUserInfo[0];	if (buf->dbUserInfo[1] == 0) {		state->bufState0 = BUF_EMPTY;		state->bufState1 = BUF_PLAYING;	} else {		state->bufState0 = BUF_PLAYING;		state->bufState1 = BUF_EMPTY;	}	buf->dbNumFrames = state->frameCount;	buf->dbFlags = buf->dbFlags | dbBufferReady;	if (state->done) {		buf->dbFlags = buf->dbFlags | dbLastBuffer;	} else {		signalSemaphoreWithIndex(state->playSemaIndex);	}	state->lastFlipTime = ioMicroMSecs();	FillBufferWithSilence(buf);  /* avoids ugly stutter if not filled in time */}int FillBufferWithSilence(SndDoubleBufferPtr buf) {	unsigned int *sample, *lastSample;	sample		= (unsigned int *) &buf->dbSoundData[0];	lastSample	= (unsigned int *) &buf->dbSoundData[bufState.bufSizeInBytes];	/* word-fill buffer with silence */	if (BYTES_PER_SAMPLE == 1) {		while (sample < lastSample) {			*sample++ = 0x80808080;  /* Note: 0x80 is zero value for 8-bit samples */		}	} else {		while (sample < lastSample) {			*sample++ = 0;		}	}}pascal void FlipRecordBuffers(SPBPtr pb) {	/* called at interrupt time to exchange the active and inactive record buffers */	RecordBuffer thisBuffer = (RecordBuffer) pb;	RecordBuffer nextBuffer = (RecordBuffer) pb->userLong;	if (pb->error == 0) {		/* restart recording using the other buffer */		SPBRecord(&nextBuffer->paramBlock, true);		/* reset the read pointer for the buffer that has just been filled */		thisBuffer->readIndex = 0;		signalSemaphoreWithIndex(nextBuffer->recordSemaIndex);	}}/*** exported sound output functions ***/int snd_AvailableSpace(void) {	if (!!bufState.open) return -1;	if ((bufState.bufState0 == BUF_EMPTY) ||		(bufState.bufState1 == BUF_EMPTY)) {			return bufState.bufSizeInBytes;	}	return 0;}int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex) {	SndDoubleBufferPtr buf;	int framesWritten;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		buf = dblBufHeader.dbhBufferPtr[0];		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			buf = dblBufHeader.dbhBufferPtr[1];			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	if (bufState.frameCount < frameCount) {		framesWritten = bufState.frameCount;	} else {		framesWritten = frameCount;	}	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) (arrayIndex + startIndex);		end = (unsigned char *) src + (framesWritten * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) &buf->dbSoundData[0];		while (src < end) {			*dst++ = *src++;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (arrayIndex + (startIndex * 4));		end = (short int *) (arrayIndex + ((startIndex + framesWritten) * 4));		dst = (short int *) &buf->dbSoundData[0];		if (bufState.stereo) {  /* stereo */			while (src < end) {				*dst++ = *src++;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			while (src < end) {				*dst++ = (*src++ + *src++) / 2;			}		}	}	return framesWritten;}int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex) {	int sample;	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) srcBufPtr + srcStartIndex;		end = (unsigned char *) srcBufPtr + (count * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) dstBufPtr + dstStartIndex;		while (src < end) {			sample = *dst + (*src++ - 128);			if (sample > 255) sample = 255;			if (sample < 0) sample = 0;			*dst++ = sample;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (srcBufPtr + (srcStartIndex * 4));		end = (short int *) (srcBufPtr + ((srcStartIndex + count) * 4));		if (bufState.stereo) {  /* stereo */			dst = (short int *) (dstBufPtr + (dstStartIndex * 4));			while (src < end) {				sample = *dst + *src++;				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			dst = (short int *) (dstBufPtr + (dstStartIndex * 2));			while (src < end) {				sample = *dst + ((*src++ + *src++) / 2);				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		}	}}int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime) {	SndDoubleBufferPtr bufPlaying, otherBuf;	int samplesInserted, startSample, count;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_PLAYING) {		bufPlaying = dblBufHeader.dbhBufferPtr[0];		otherBuf = dblBufHeader.dbhBufferPtr[1];	} else {		bufPlaying = dblBufHeader.dbhBufferPtr[1];		otherBuf = dblBufHeader.dbhBufferPtr[0];	}	samplesInserted = 0;	/* mix as many samples as can fit into the remainder of the currently playing buffer */	startSample =		((bufState.sampleRate * (ioMicroMSecs() - bufState.lastFlipTime)) / 1000) + samplesOfLeadTime;	if (startSample < bufState.frameCount) {		count = bufState.frameCount - startSample;		if (count > frameCount) count = frameCount;		MixInSamples(count, (char *) srcBufPtr, 0, (char *) &bufPlaying->dbSoundData[0], startSample);		samplesInserted = count;	}	/* mix remaining samples into the inactive buffer */	count = bufState.frameCount;	if (count > (frameCount - samplesInserted)) {		count = frameCount - samplesInserted;	}	MixInSamples(count, (char *) srcBufPtr, samplesInserted, (char *) &otherBuf->dbSoundData[0], 0);	return samplesInserted + count;}int snd_PlaySilence(void) {	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		FillBufferWithSilence(dblBufHeader.dbhBufferPtr[0]);		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			FillBufferWithSilence(dblBufHeader.dbhBufferPtr[1]);			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	return bufState.bufSizeInBytes;}int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex) {	OSErr				err;	SndDoubleBufferPtr	buffer;	int					bytesPerFrame, bufferBytes, i;	bytesPerFrame			= stereo ? 2 * BYTES_PER_SAMPLE : BYTES_PER_SAMPLE;	bufferBytes				= ((frameCount * bytesPerFrame) / 8) * 8;		/* Note: Must round bufferBytes down to an 8-byte boundary to avoid clicking!!!!!! */	if (bufState.open) {		/* still open from last time; clean up before continuing */		snd_Stop();	}	bufState.open			= false;  /* set to true if successful */	bufState.stereo			= stereo;	bufState.frameCount		= bufferBytes / bytesPerFrame;	bufState.sampleRate		= samplesPerSec;	bufState.lastFlipTime	= ioMicroMSecs();	bufState.playSemaIndex	= semaIndex;	bufState.bufSizeInBytes	= bufferBytes;	bufState.bufState0		= BUF_EMPTY;	bufState.bufState1		= BUF_EMPTY;	bufState.done			= false;	dblBufHeader.dbhNumChannels		= stereo ? 2 : 1;	dblBufHeader.dbhSampleSize		= BYTES_PER_SAMPLE * 8;	dblBufHeader.dbhCompressionID	= 0;	dblBufHeader.dbhPacketSize		= 0;	dblBufHeader.dbhSampleRate		= samplesPerSec << 16; /* convert to fixed point */	dblBufHeader.dbhDoubleBack		= NewSndDoubleBackProc(DoubleBack);	chan = NULL;	err = SndNewChannel(&chan, sampledSynth, 0, NULL);	if (err !!= noErr) return false; /* could not open sound channel */	for (i = 0; i < 2; i++) {		buffer = (SndDoubleBufferPtr) NewPtrClear(sizeof(SndDoubleBuffer) + bufState.bufSizeInBytes);		if (buffer == NULL) {   /* could not allocate memory for a buffer; clean up and abort */			SndDisposeChannel(chan, true);			DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);			if (i == 1) {  /* free the first buffer */				DisposePtr((char *) dblBufHeader.dbhBufferPtr[1]);				dblBufHeader.dbhBufferPtr[1] = NULL;			}			return false;		}		buffer->dbNumFrames		= bufState.frameCount;		buffer->dbFlags			= dbBufferReady;		buffer->dbUserInfo[0]	= (long) &bufState;		buffer->dbUserInfo[1]	= i;		FillBufferWithSilence(buffer);		dblBufHeader.dbhBufferPtr[i] = buffer;	}	err = SndPlayDoubleBuffer(chan, &dblBufHeader);	if (err !!= noErr) return false; /* could not play double buffer */	bufState.open = true;	return true;}int snd_Stop(void) {	OSErr				err;	SndDoubleBufferPtr	buffer;	SCStatus			status;	long				i, junk;	if (!!bufState.open) return;	bufState.open = false;	bufState.done = true;	while (true) {		err = SndChannelStatus(chan, sizeof(status), &status);		if (err !!= noErr) break; /* could not get channel status */		if (!!status.scChannelBusy) break;		Delay(1, &junk);	}	SndDisposeChannel(chan, true);	DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);	for (i = 0; i < 2; i++) {		buffer = dblBufHeader.dbhBufferPtr[i];		if (buffer !!= NULL) {			DisposePtr((char *) buffer);		}		dblBufHeader.dbhBufferPtr[i] = NULL;	}	bufState.open = false;}/*** exported sound input functions ***/int snd_SetRecordLevel(int level) {	/* set the recording level to a value between 0 (minimum gain) and 1000. */	Fixed inputGainArg;	int err;	if (!!recordingInProgress || (level < 0) || (level > 1000)) {		success(false);		return;  /* noop if not recording */	}	inputGainArg = ((500 + level) << 16) / 1000;  /* gain is Fixed between 0.5 and 1.5 */	err = SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	/* don''t fail on error; hardware may not support setting the gain */}int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex) {	/* turn on sound recording, trying to use a sampling rate close to	   the one specified. semaIndex is the index in the exportedObject	   array of a semaphore to be signalled when input data is available. */	Str255 deviceName = "";	short automaticGainControlArg;	Fixed inputGainArg;	long  compressionTypeArg;	short continuousArg;	short sampleSizeArg;	short channelCountArg;	UnsignedFixed sampleRateArg;	int err;	err = SPBOpenDevice(deviceName, siWritePermission, &soundInputRefNum);	if (err !!= noErr) {		success(false);		return;	}	/* try to initialize some optional parameters, but don''t fail if we can''t */	automaticGainControlArg = false;	SPBSetDeviceInfo(soundInputRefNum, siAGCOnOff, &automaticGainControlArg);	inputGainArg = 1 << 16;  /* 1.0 in Fixed */	SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	compressionTypeArg = ''NONE'';	SPBSetDeviceInfo(soundInputRefNum, siCompressionType, &compressionTypeArg);	continuousArg = true;	err = SPBSetDeviceInfo(soundInputRefNum, siContinuous, &continuousArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	sampleSizeArg = 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);	if (err !!= noErr) {		/* use 8-bit samples */		sampleSizeArg = 8;		err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);		if (err !!= noErr) {			success(false);			SPBCloseDevice(soundInputRefNum);			return;		}	}	channelCountArg = stereo ? 2 : 1;	err = SPBSetDeviceInfo(soundInputRefNum, siNumberChannels, &channelCountArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	/* try to set the client''s desired sample rate */	sampleRateArg = desiredSamplesPerSec << 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		/* if client''s rate fails, try the nearest common sampling rates in {11025, 22050, 44100} */		if (desiredSamplesPerSec <= 16538) {			sampleRateArg = 11025 << 16;		} else {			if (desiredSamplesPerSec <= 33075) {				sampleRateArg = 22050 << 16;			} else {				sampleRateArg = 44100 << 16;			}		}		/* even if following fails, recording can go on at the default sample rate */		SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	}	recordBuffer1.paramBlock.inRefNum = soundInputRefNum;	recordBuffer1.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.milliseconds = 0;	recordBuffer1.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.bufferPtr = recordBuffer1.samples;	recordBuffer1.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer1.paramBlock.interruptRoutine = nil;	recordBuffer1.paramBlock.userLong = (long) &recordBuffer2;  /* pointer to other buffer */	recordBuffer1.paramBlock.error = noErr;	recordBuffer1.paramBlock.unused1 = 0;	recordBuffer1.stereo = stereo;	recordBuffer1.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer1.recordSemaIndex = semaIndex;	recordBuffer1.readIndex = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.inRefNum = soundInputRefNum;	recordBuffer2.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.milliseconds = 0;	recordBuffer2.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.bufferPtr = recordBuffer2.samples;	recordBuffer2.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer2.paramBlock.interruptRoutine = nil;	recordBuffer2.paramBlock.userLong = (long) &recordBuffer1;  /* pointer to other buffer */	recordBuffer2.paramBlock.error = noErr;	recordBuffer2.paramBlock.unused1 = 0;	recordBuffer2.stereo = stereo;	recordBuffer2.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer2.recordSemaIndex = semaIndex;	recordBuffer2.readIndex = RECORD_BUFFER_SIZE;	err = SPBRecord(&recordBuffer1.paramBlock, true);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	recordingInProgress = true;}int snd_StopRecording(void) {	/* turn off sound recording */	int err;	if (!!recordingInProgress) return;  /* noop if not recording */	err = SPBStopRecording(soundInputRefNum);	if (err !!= noErr) success(false);	SPBCloseDevice(soundInputRefNum);	DisposeRoutineDescriptor(recordBuffer1.paramBlock.completionRoutine);	recordBuffer1.paramBlock.completionRoutine = nil;	DisposeRoutineDescriptor(recordBuffer2.paramBlock.completionRoutine);	recordBuffer2.paramBlock.completionRoutine = nil;	recordBuffer1.recordSemaIndex = 0;	recordBuffer2.recordSemaIndex = 0;	recordingInProgress = false;}double snd_GetRecordingSampleRate(void) {	/* return the actual recording rate; fail if not currently recording */	UnsignedFixed sampleRateArg;	int err;	if (!!recordingInProgress) {		success(false);		return 0.0;	}	err = SPBGetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		success(false);		return 0.0;	}	return  (double) ((sampleRateArg >> 16) & 0xFFFF) +			((double) (sampleRateArg & 0xFFFF) / 65536.0);}int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes) {	/* if data is available, copy as many sample slices as possible into the	   given buffer starting at the given slice index. do not write past the	   end of the buffer, which is buf + bufferSizeInBytes. return the number	   of slices (not bytes) copied. a slice is one 16-bit sample in mono	   or two 16-bit samples in stereo. */	int bytesPerSlice = (recordBuffer1.stereo ? 4 : 2);	char *nextBuf = (char *) buf + (startSliceIndex * bytesPerSlice);	char *bufEnd = (char *) buf + bufferSizeInBytes;	char *src, *srcEnd;	RecordBuffer recBuf = nil;	int bytesCopied;	if (!!recordingInProgress) {		success(false);		return 0;	}	/* select the buffer with unread samples, if any */	recBuf = nil;	if (recordBuffer1.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer1;	if (recordBuffer2.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer2;	if (recBuf == nil) return 0;  /* no samples available */	/* copy samples into the client''s buffer */	src = &recBuf->samples[0] + recBuf->readIndex;	srcEnd = &recBuf->samples[RECORD_BUFFER_SIZE];	if (recBuf->bytesPerSample == 1) {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			/* convert 8-bit sample to 16-bit sample */			*nextBuf++ = (*src++) - 128;  /* convert from [0-255] to [-128-127] */			*nextBuf++ = 0;  /* low-order byte is zero */		}	} else {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			*nextBuf++ = *src++;		}	}	recBuf->readIndex = src - &recBuf->samples[0];  /* update read index */	/* return the number of slices copied */	bytesCopied = (int) nextBuf - (buf + (startSliceIndex * bytesPerSlice));	return bytesCopied / bytesPerSlice;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/26/2000 08:27'!macWindowFile	^ '#include <MacHeaders.h>  /* needed only for ExitToShell() */#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape or IE Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/* The following prototype is missing from the CW11 header files: */pascal void ExitToShell(void);/*** Variables -- Imported from Browser Plugin Module ***/#ifdef PLUGINextern int pluginArgCount;extern char *pluginArgName[100];extern char *pluginArgValue[100];#endif/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image file */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document file */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;Handle			clipboardBuffer = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */int cachedButtonState = 0;	/* buffered mouse button and modifier state for							   last mouse click even if button has since gone up;							   this cache is kept until the next time ioGetButtonState()							   is called to avoid missing short clicks */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath);void MenuBarHide(void);void MenuBarRestore(void);int PathToWorkingDir(char *pathName, int pathNameMax);int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "squeak.image");	return noErr;}pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) goto done;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;	if (numFiles !!= 1) {		error("You may only open one Squeak image or document file at a time.");	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;	strcpy(shortImageName, p2cstr(fileSpec.name));	if (!!IsImageName(shortImageName)) {		/* record the document name, but run the default image in VM directory */		StoreFullPathForLocalNameInto(shortImageName, documentName, DOCUMENT_NAME_SIZE);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */ 	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	LMSetMBarHeight(menuBarHeight);	DisposeRgn(menuBarRegion);	menuBarRegion = nil;	DrawMenuBar();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int asciiChar, modifierBits, keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & 0xFF;	modifierBits = modifierMap[(theEvent->modifiers >> 8) & 0x1F];	if ((modifierBits & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	keystate = (modifierBits << 8) | asciiChar;	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);	cachedButtonState = cachedButtonState | buttonState;}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** Mac Specific External Primitive Support ***//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName) {	char pluginDirPath[1000];	CFragConnectionID libHandle;	/* first, look in the "<Squeak VM directory>:Plugins" directory for the library */	strcpy(pluginDirPath, vmPath);	strcat(pluginDirPath, ":Plugins");	libHandle = LoadLibViaPath(pluginName, pluginDirPath);	if (libHandle !!= nil) return libHandle;	/* second, look directly in Squeak VM directory for the library */	libHandle = LoadLibViaPath(pluginName, vmPath);	if (libHandle !!= nil) return libHandle;	return nil;}/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle) {	CFragSymbolClass ignored;	Ptr functionPtr = 0;	OSErr err;	if (!!moduleHandle) return 0;	/* get the address of the desired primitive function */	c2pstr(lookupName);  /* convert to Pascal string */	err = FindSymbol(		(CFragConnectionID) moduleHandle, (unsigned char *) lookupName,		&functionPtr, &ignored);	p2cstr((unsigned char *) lookupName);  /* convert back to C string */	if (err) return 0;	return (int) functionPtr;}/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle) {	CFragConnectionID libHandle;	OSErr err;	if (!!moduleHandle) return 0;	libHandle = (CFragConnectionID) moduleHandle;	err = CloseConnection(&libHandle);	return 0;}CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath) {	short 				vRefNum;	long				ignore;	CInfoPBRec 			pb;	FSSpec				fileSpec;	Str255				problemLibName;	Ptr					junk;	CFragConnectionID	libHandle = 0;	OSErr				err = noErr;	/* get the default volume */	GetVInfo(0, nil, &vRefNum, &ignore);	/* get the directory ID for the given path */	pb.hFileInfo.ioNamePtr = c2pstr(pluginDirPath);	pb.hFileInfo.ioVRefNum = 0;  /* use the default volume */	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	err = PBGetCatInfoSync(&pb);	p2cstr((unsigned char *) pluginDirPath);	if (err) return nil; /* bad plugin directory path */	/* make a file spec for the given file name in the plugin directory */	fileSpec.vRefNum = vRefNum;	fileSpec.parID = pb.hFileInfo.ioDirID;	strcpy((char *) fileSpec.name, libName);	c2pstr((char *) fileSpec.name);	err = GetDiskFragment(		&fileSpec, 0, kWholeFork, nil, kLoadCFrag, &libHandle, &junk, problemLibName);	if (err) return nil;	return libHandle;}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}#ifndef PLUGINint ioExit(void) {	ioShutdownAllModules();	MenuBarRestore();	ExitToShell();}#endifint ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	if ((cachedButtonState & 0x7) !!= 0) {		int result = cachedButtonState;		cachedButtonState = 0;  /* clear cached button state */		return result;	}	cachedButtonState = 0;  /* clear cached button state */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioHasDisplayDepth(int depth) {	/* Return true if this platform supports the given color display depth. */	switch (depth) {	case 1:	case 2:	case 4:	case 8:	case 16:	case 32:		return true;	}	return false;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * ioProcessEvents(), which gives other applications a chance to run.	 */	ioProcessEvents();  /* process all pending events */}#ifndef PLUGINint ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}#endifint ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag) {	/* Set the window to the given width, height, and color depth. Put the window	   into the full screen mode specified by fullscreenFlag. */	/* Note: Changing display depth is not yet, and may never be, implemented	   on the Macintosh, where (a) it is considered inappropriate and (b) it may	   not even be a well-defined operation if the Squeak window spans several	   displays (which display''s depth should be changed?). */	ioSetFullScreen(fullscreenFlag);	if (!!fullscreenFlag) {		SizeWindow(stWindow, width, height, true);	}}#ifndef PLUGINint ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		MenuBarHide();		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}#endifint ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length) {	int offset, sz, i;	offset = PathToWorkingDir(fullName, length);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Initializing the path to Working Dir ***/int PathToWorkingDir(char *pathName, int pathNameMax) {	/* Fill in the given string with the full path from a root volume to	   to current working directory. (At startup time, the working directory	   is set to the application''s directory. Fails if the given string is not	   long enough to hold the entire path. (Use at least 1000 characters to	   be safe.)	*/	char thisName[256];	CInfoPBRec pb;	int nextDirRefNum, pathLen;	/* initialize string copying state */	pathName[0] = 0;	pathLen = 0;	/* get refNum of working directory */	strcpy(thisName, ":");	pb.hFileInfo.ioNamePtr = c2pstr(thisName);	pb.hFileInfo.ioVRefNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	if (PBGetCatInfoSync(&pb) !!= noErr) {		nextDirRefNum = 0;	}	nextDirRefNum = pb.hFileInfo.ioDirID;	while (true) {		thisName[0] = 0;		pb.hFileInfo.ioFDirIndex = -1; /* map ioDirID -> name */		pb.hFileInfo.ioVRefNum = 0;		pb.hFileInfo.ioDirID = nextDirRefNum;		if (PBGetCatInfoSync(&pb) !!= noErr) {			break;  /* we''ve reached the root */		}		p2cstr((unsigned char *) thisName);		pathLen = PrefixPathWith(pathName, pathLen, pathNameMax, thisName);		nextDirRefNum = pb.dirInfo.ioDrParID;	}	return pathLen;}int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {	/* Insert the given prefix C string plus a delimitor character at the	   beginning of the given C string. Return the new pathName size. Fails	   if pathName is does not have sufficient space for the result.	   Assume: pathName is null terminated.	*/	int offset, i;	offset = strlen(prefix) + 1;	if ((pathNameSize + offset) > pathNameMax) {		return pathNameSize;	}	for (i = pathNameSize; i >= 0; i--) {		/* make room in pathName for prefix (moving string terminator, too) */		pathName[i + offset] = pathName[i];	}	for (i = 0; i < offset; i++) {		/* make room in pathName for prefix */		pathName[i] = prefix[i];	}	pathName[offset - 1] = '':'';  /* insert delimitor */	return pathNameSize + offset;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	short junk;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	/* open MacTCP driver early to avoid leaving a high sandbar in System Heap */	OpenDriver("\p.IPP", &junk);	SetUpClipboard();	SetUpPixmap();}int plugInShutdown(void) {	ioShutdownAllModules();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}#ifndef PLUGINint plugInAllowAccessToFilePath(char *pathString, int pathStringLength) {  /* Grant permission to all files. */	return true;}#endif/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	/* Note: 1.3x images will try to read the image as a document because they	   expect attribute #1 to be the document name. A 1.3x image can be patched	   using a VM of 2.6 or earlier. */	if (id == 1) return imageName;	if (id == 2) return documentName;#ifdef PLUGIN	/* When running in browser, return the EMBED tag info */	if ((id > 2) && (id <= (2 + (2 * pluginArgCount)))) {		int i = id - 3;		if ((i & 1) == 0) {  /* i is even */			return pluginArgName[i/2];		} else {			return pluginArgValue[i/2];		}	}#endif	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}#ifndef PLUGINvoid * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {	/* Application allocates Squeak object heap memory from its own heap. */	MaxBlock();	return NewPtr(desiredHeapSize);}#endif/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 150000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 50K to that.)	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSizeStartingAt(f, availableMemory, 0);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/26/2000 11:46'!readmeFile	^ 'Building the Squeak Virtual MachineThe Macintosh virtual machine is built using the following source files:	sq.h				-- shared definitions included in all .c files	sqConfig.h			-- platform configuration settings	sqMachDep.h		-- machine dependent macros to support threaded code	sqPlatformSpecific.h -- platform specific macros and definitions	sqVirtualMachine.h	-- support for dynamic primitives	sqADPCMPrims.c		-- ADCPM sound compression primitives	sqFilePrims.c		-- file primitives	sqMacAsyncFilePrims.c -- Mac asynchronous file I/O	sqMacDirectory.c	-- Mac directory enumerations	sqMacJoystickAndTablet.c -- Mac support for Wacom tablets and Gravis MouseStickII joystick	sqMacNetwork.c		-- Mac networking primitives	sqMacSerialAndMIDIPort.c -- Mac serial and MIDI port primitives	sqMacSound.c		-- Mac audio output primitives	sqMacWindow.c		-- Mac window and event handling; main program	sqMiscPrims.c		-- miscellaneous automatically generated primitives	sqNamedPrims.c		-- support for named primitives	sqSoundPrims.c		-- automatically generated sound synthesis primitives	sqOldSoundPrims.c	-- old versions of sound primitives for backward compatibility	sqVirtualMachine.c	-- support for dynamic primitives	interp.c				-- automatically generated code for the virtual machineIn addition to these files, a number of .h and .c files are generated when Squeak generates a new interpreter. The exact set of files depends on which sets of primitives are included. In general, all the files created by this process should be visible to the CW project and all the generated .c files should be added to the CW project. Don''t worry--the linker will tell you if you forget something.The platform specific files are sqMacXXX.c, totaling about 2000 lines of code when this document was originally written. All other code is written to standard ANSI libraries and should port easily to other C environments.The file sqMacMinimal.c can be used a porting guide. This ~1100 line file stubs out all non-essential support functions and, together with sqFilePrims.c, allows one to build a functioning virtual machine that only lacks non-essential I/O functions (including support for file directory enumeration, which is not really essential!!). The small size of this file demonstrates how little code is really needed to get Squeak running on a new platform.Thanks to Ian Piumarta, the C header files are identical across all the major Squeak platforms.The code assumes that C ints and pointers are 4 bytes and double floats are 8 bytes; these assumptions are checked at start up time. Float objects in the image are stored in the IEEE standard byte ordering for double-precision floats on all platforms; macros in sq.h can be defined to swap bytes into and out of the platform native float format if necessary. (To ensure proper word alignment, one typically has to copy a Squeak Float object into a C "double" variable before operating on it; byte swapping can be done while doing this copy for little or no additional cost.)The files interp.c, sqSoundPrims.c, and sqMiscPrims.c are generated automatically, so changes to these files will be lost when they are next generated. It is fine to make ephemeral changes to these file for the purpose of debugging or statistics gathering. To generate the interpreter, see the "translation" category in Interpreter class. To generate sqSoundPrims.c, see the class method "cCodeForSoundPrimitives" in AbstractSound.The current VM was compiled with Metrowerks CodeWarrior 11. Earlier, I used Semantec Think C 6.0, but discovered a few bugs in their libraries having to do with 8-byte versus 4-byte integers. These bugs have probably been fixed by now.This code has also been compiled under the MPW "Mr. C" Macintosh compiler by Hans-Martin Mosner (hmm@heeg.de) with only one minor change: you will need to create an empty "MacHeaders.h" file. You may get some harmless compiler warnings and, for peak performance, the method that patches the dispatch loop must also be changed. Hans-Martin says: "The whole VM seems to be marginally slower than the delivered VM, but it is significantly smaller."The virtual machine uses the following libraries:	Libraries for 68K Project:		dnr.c		InterfaceLib		MathLibCFM68K (4i/8d).Lib		MSL C.CFM68K Far(4i/8d).Lib		MWCFM68KRuntime.Lib		Profiler68kCFM.lib	Libraries for PowerPC Project:		dnr.c		InterfaceLib		MathLib		MSL C.PPC.Lib		MWCRuntime.Lib		profilerPPC.libThe Mac networking code also requires three files from Apple''s MacTCP developer''s kit:	MacTCP.h	AddressXlation.h	dnr.cFor convenience, these files are included.To build a fat binary, build the 68K version first, and make sure that the file "Squeak VM 68K" is included in the PowerPC project. Then build the PowerPC version. CodeWarrior will include the 68K interpreter in the resource fork of the output file, resulting in an interpreter that runs on either 68K or PowerPC Macs.To get an additional speedup, the object code for the bytecode dispatch loop of the PPC version can be patched using the method "patchInterp:" in Interpreter class.Note: In order to support dynamically loaded primitives, we have switched to using Code Fragement Manager model for the 68K VM. This has several ramifications:  1. You now need to use the CFM versions of the library files. The 68K project file has been updated accordingly.  2. You cannot run the 68K VM under the emulator on the PowerPC (Apple doesn''t support CFM apps under the 68K emulator).  3. You need to be sure that version 4.0 or later of "CFM-68K Runtime Enabler" is in the Extensions folder of the system folder on your 68K Mac. *** Warning: Older versions of "CFM-68K Runtime Enabler" had bugs that will probably prevent Squeak from even starting!! ***.Building Named Primitive PluginsI''ve included a pair of sample projects for building Squeak primitive plugins. As usual, you must build the 68K version first, then the FAT one. If you don''t need a FAT version, you can remove the 68K project from the PPC one.Pluginized VMSqueak 2.8 introduces the "pluginized VM". In the interest of getting a Mac version of the 2.8 out as quickly and with as little chance of introducing bugs as possible, I''ve made the bare minimal changes to the Mac support files. For this reason, all the Mac primitives that were previously linked into the VM must still be built into the VM as "internal" primitives. That is because many of them still access a few VM functions and variables directly, rather than calling through the interpreter proxy, which they must in order to run in an external plugin. One can still override these builtin primitives with an external plugin and, of course, newly built plugins can be created as external or internal plugins. When the dust settles, it will be easy to make the final few changes required.Building Squeak as a Browser PluginI''ve included an archive containing a CW project file and various supporting files for building the Squeak VM as plugin for Netscape or Internet Explorer on the Mac. The plugin works with versions 4.0 or later of either browser. However, the primitives that can be used to ask the browser to fetch a URL do not work in versions of IE earlier than 5.0. There are also two resource files the contain the strings needed to tell the browser about the plugin--its name, version, and the mime and file extensions it recognizes.To build this, you will need a copy of the Netscape Plugin SDK, available for free at their web site. The required support files are:	jri.h	jritypes.h	jri_md.h	npapi.h	npmac.cpp	npupp.hThe installation and use of Squeak as a browser plugin is somewhat beyond the scope of this readme file. The basic idea is that the Squeak image started by the browser lives in a pre-defined directory ("Disney:Disney Online:Squeak:Files" by default) with predefined name (e.g., "squeak.image" or "DOLSqueak.image"). The browser plugin can only read and write files within the image directory and directories contained within it. This is called Squeak file system "sand box". The browser captures most of the command key combination, so you have to use the menus rather than your favorite Squeak command key shortcuts. The browser also captures cmd-., so the interrupt key when running under the browser is control-C. The most flexible way to invoke Squeak is through the HTML "EMBED" command. This allows arbitrary arguments to be made available to Squeak. The "memory" EMBED tag can be used to tell Squeak how much memory is required by a given Squeaklet.To build a browser plugin VM, requires several steps:  1. translate a browser plugin version of the interpreter (see the translate category in Interpreter class).  2. edit the file sqMacWindow.c, and #define the symbol "PLUGIN"  3. build the plugin using the supplied browser plugin projectIf you build your own project file, note that IE requires that the main entry point be "main" rather than CW''s usual "__start". (Netscape doesn''t care, so it took me a long time to figure out why it wasn''t working under IE!!) The supplied project produces a PPC-only plugin.	-- John Maloney, May 25, 2000'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/25/2000 18:39'!squeakFilePrimsFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "FilePlugin.h"/* End of adjustments for pluginized VM *//***	The state of a file is kept in the following structure,	which is stored directly in a Squeak bytes object.	NOTE: The Squeak side is responsible for creating an	object with enough room to store sizeof(SQFile) bytes.	The session ID is used to detect stale file objects--	files that were still open when an image was written.	The file pointer of such files is meaningless.	Files are always opened in binary mode; Smalltalk code	does (or someday will do) line-end conversion if needed.	Writeable files are opened read/write. The stdio spec	requires that a positioning operation be done when	switching between reading and writing of a read/write	filestream. The lastOp field records whether the last	operation was a read or write operation, allowing this	positioning operation to be done automatically if needed.	typedef struct {		File	*file;		int		sessionID;		int		writable;		int		fileSize;		int		lastOp;  // 0 = uncommitted, 1 = read, 2 = write //	} SQFile;***//*** Constants ***/#define UNCOMMITTED	0#define READ_OP		1#define WRITE_OP	2#ifndef SEEK_SET#define SEEK_SET	0#define SEEK_CUR	1#define SEEK_END	2#endif/*** Variables ***/int thisSession = 0;int sqFileAtEnd(SQFile *f) {	/* Return true if the file''s read/write head is at the end of the file. */	if (!!sqFileValid(f)) return success(false);	return ftell(f->file) == f->fileSize;}int sqFileClose(SQFile *f) {	/* Close the given file. */	if (!!sqFileValid(f)) return success(false);	fclose(f->file);	f->file = NULL;	f->sessionID = 0;	f->writable = false;	f->fileSize = 0;	f->lastOp = UNCOMMITTED;}int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize) {	char cFileName[1000];	int i, err;	if (sqFileNameSize >= 1000) {		return success(false);	}	/* copy the file name into a null-terminated C string */	for (i = 0; i < sqFileNameSize; i++) {		cFileName[i] = *((char *) (sqFileNameIndex + i));	}	cFileName[sqFileNameSize] = 0;	if (!!plugInAllowAccessToFilePath(cFileName, sqFileNameSize)) {		return success(false);	}	err = remove(cFileName);	if (err) {		return success(false);	}}int sqFileGetPosition(SQFile *f) {	/* Return the current position of the file''s read/write head. */	int position;	if (!!sqFileValid(f)) return success(false);	position = ftell(f->file);	if (position < 0) return success(false);	return position;}int sqFileInit(void) {	/* Create a session ID that is unlikely to be repeated.	   Zero is never used for a valid session number.	   Should be called once at startup time.	*/	thisSession = clock() + time(NULL);	if (thisSession == 0) thisSession = 1;	/* don''t use 0 */}int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag) {	/* Opens the given file using the supplied sqFile structure	   to record its state. Fails with no side effects if f is	   already open. Files are always opened in binary mode;	   Squeak must take care of any line-end character mapping.	*/	char cFileName[1001];	int i;	/* don''t open an already open file */	if (sqFileValid(f)) return success(false);	/* copy the file name into a null-terminated C string */	if (sqFileNameSize > 1000) {		return success(false);	}	for (i = 0; i < sqFileNameSize; i++) {		cFileName[i] = *((char *) (sqFileNameIndex + i));	}	cFileName[sqFileNameSize] = 0;	if (!!plugInAllowAccessToFilePath(cFileName, sqFileNameSize)) {		return success(false);	}	if (writeFlag) {		/* First try to open an existing file read/write: */		f->file = fopen(cFileName, "r+b");		if (f->file == NULL) {			/* Previous call fails if file does not exist. In that case,			   try opening it in write mode to create a new, empty file.			*/			f->file = fopen(cFileName, "w+b");			if (f->file !!= NULL) {				/* set the type and creator of newly created Mac files */				dir_SetMacFileTypeAndCreator(cFileName, strlen(cFileName), "TEXT", "R*ch");				}		}		f->writable = true;	} else {		f->file = fopen(cFileName, "rb");		f->writable = false;	}	if (f->file == NULL) {		f->sessionID = 0;		f->fileSize = 0;		return success(false);	} else {		f->sessionID = thisSession;		/* compute and cache file size */		fseek(f->file, 0, SEEK_END);		f->fileSize = ftell(f->file);		fseek(f->file, 0, SEEK_SET);	}	f->lastOp = UNCOMMITTED;}int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Read count bytes from the given file into byteArray starting at	   startIndex. byteArray is the address of the first byte of a	   Squeak bytes object (e.g. String or ByteArray). startIndex	   is a zero-based index; that is a startIndex of 0 starts writing	   at the first byte of byteArray.	*/	char *dst;	int bytesRead;	if (!!sqFileValid(f)) return success(false);	if (f->writable && (f->lastOp == WRITE_OP)) fseek(f->file, 0, SEEK_CUR);  /* seek between writing and reading */	dst = (char *) (byteArrayIndex + startIndex);	bytesRead = fread(dst, 1, count, f->file);	f->lastOp = READ_OP;	return bytesRead;}int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize) {	char cOldName[1000], cNewName[1000];	int i, err;	if ((oldNameSize >= 1000) || (newNameSize >= 1000)) {		return success(false);	}	/* copy the file names into null-terminated C strings */	for (i = 0; i < oldNameSize; i++) {		cOldName[i] = *((char *) (oldNameIndex + i));	}	cOldName[oldNameSize] = 0;	for (i = 0; i < newNameSize; i++) {		cNewName[i] = *((char *) (newNameIndex + i));	}	cNewName[newNameSize] = 0;	if (!!plugInAllowAccessToFilePath(cOldName, oldNameSize) ||		!!plugInAllowAccessToFilePath(cNewName, newNameSize)) {		return success(false);	}	err = rename(cOldName, cNewName);	if (err) {		return success(false);	}}int sqFileSetPosition(SQFile *f, int position) {	/* Set the file''s read/write head to the given position. */	if (!!sqFileValid(f)) return success(false);	fseek(f->file, position, SEEK_SET);	f->lastOp = UNCOMMITTED;}int sqFileShutdown() {	/* Prepare to shutdown Squeak. */ 	thisSession = 0;}int sqFileSize(SQFile *f) {	/* Return the length of the given file. */	if (!!sqFileValid(f)) return success(false);	return f->fileSize;}int sqFileValid(SQFile *f) {	return (		(f !!= NULL) &&		(f->file !!= NULL) &&		(f->sessionID == thisSession));}int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Write count bytes to the given writable file starting at startIndex	   in the given byteArray. (See comment in sqFileReadIntoAt for interpretation	   of byteArray and startIndex).	*/	char *src;	int bytesWritten, position;	if (!!(sqFileValid(f) && f->writable)) return success(false);	if (f->lastOp == READ_OP) fseek(f->file, 0, SEEK_CUR);  /* seek between reading and writing */	src = (char *) (byteArrayIndex + startIndex);	bytesWritten = fwrite(src, 1, count, f->file);	position = ftell(f->file);	if (position > f->fileSize) {		f->fileSize = position;  /* update file size */	}	if (bytesWritten !!= count) {		success(false);	}	f->lastOp = WRITE_OP;	return bytesWritten;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/26/2000 08:26'!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#include "sqVirtualMachine.h"#define true 1#define false 0#define null 0  /* using "null" because nil is predefined in Think C *//* pluggable primitives macros *//* Note: All pluggable primitives are defined as	EXPORT(int) somePrimitive(void)   If the platform requires special declaration modifiers   the EXPORT macro can be redefined*/#define EXPORT(returnType) returnType/* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* platform-dependent memory size adjustment macro *//* Note: This macro can be redefined to allows platforms with a   fixed application memory partition (notably, the Macintosh)   to reserve extra C heap memory for special applications that need   it (e.g., for a 3D graphics library). Since most platforms can   extend their application memory partition at run time if needed,   this macro is defined as a noop here and redefined if necessary   in sqPlatformSpecific.h.*/#define reserveExtraCHeapBytes(origHeapSize, bytesToReserve) origHeapSize/* platform-dependent millisecond clock macros *//* Note: The Squeak VM uses three different clocks functions for   timing. The primary one, ioMSecs(), is used to implement Delay   and Time millisecondClockValue. The resolution of this clock   determines the resolution of these basic timing functions. For   doing real-time control of music and MIDI, a clock with resolution   down to one millisecond is preferred, but a coarser clock (say,   1/60th second) can be used in a pinch. The VM calls a different   clock function, ioLowResMSecs(), in order to detect long-running   primitives. This function must be inexpensive to call because when   a Delay is active it is polled twice per primitive call. On several   platforms (Mac, Win32), the high-resolution system clock used in   ioMSecs() would incur enough overhead in this case to slow down the   the VM significantly. Thus, a cheaper clock with low resolution is   used to implement ioLowResMSecs() on these platforms. Finally, the   function ioMicroMSecs() is used only to collect timing statistics   for the garbage collector and other VM facilities. (The function   name is meant to suggest that the function is based on a clock   with microsecond accuracy, even though the times it returns are   in units of milliseconds.) This clock must have enough precision to   provide accurate timings, and normally isn''t called frequently   enough to slow down the VM. Thus, it can use a more expensive clock   that ioMSecs(). By default, all three clock functions are defined   here as macros based on the standard C library function clock().   Any of these macros can be overridden in sqPlatformSpecific.h.*/int ioMSecs(void);int ioLowResMSecs(void);int ioMicroMSecs(void);#define ioMSecs()		((1000 * clock()) / CLOCKS_PER_SEC)#define ioLowResMSecs()	((1000 * clock()) / CLOCKS_PER_SEC)#define ioMicroMSecs()	((1000 * clock()) / CLOCKS_PER_SEC)/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);int ioHasDisplayDepth(int depth);int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag);/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFromFileHeapSizeStartingAt(sqImageFile f, int desiredHeapSize, int imageOffset);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* browser plug-in support */int plugInAllowAccessToFilePath(char *pathString, int pathStringLength);void plugInForceTimeToReturn(void);int plugInInit(char *imageName);int plugInNotifyUser(char *msg);void plugInSetStartTime(void);int plugInShutdown(void);int plugInTimeToReturn(void);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/* ar 5/13/2000:	The following set of miscellaneous and sound primitives should	at some point go into named primitives. Right now there are a few	problems with that (related to how the distinct set of methods can	be defined as residing in one plugin).*//* miscellaneous primitives */int primBitmapcompresstoByteArray(void);int primBitmapdecompressfromByteArrayat(void);int primSampledSoundconvert8bitSignedFromto16Bit(void);int primStringcomparewithcollated(void);int primStringfindFirstInStringinSetstartingAt(void);int primStringfindSubstringinstartingAtmatchTable(void);int primStringindexOfAsciiinStringstartingAt(void);int primStringtranslatefromtotable(void);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);int oldprimSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primReverbSoundapplyReverbTostartingAtcount(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/*** sound compression primitives ***/int primADPCMCodecprivateDecodeMono(void);int primADPCMCodecprivateDecodeStereo(void);int primADPCMCodecprivateEncodeMono(void);int primADPCMCodecprivateEncodeStereo(void);/*** pluggable primitive support ***//* NOTE: The following functions are those implemented by sqNamedPrims.c */int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength,  int moduleNameIndex, int moduleNameLength);int ioUnloadModuleOfLength(int moduleNameIndex, int moduleNameLength);int ioLoadFunctionFrom(char *functionName, char *pluginName);int ioShutdownAllModules(void);int ioUnloadModule(char *);int ioUnloadModuleOfLength(int moduleNameIndex, int moduleNameLength);char *ioListBuiltinModule(int moduleIndex);/* The next two are FFI entries!! (implemented in sqNamedPrims.c as well) */int ioLoadModuleOfLength(int moduleNameIndex, int moduleNameLength);int ioLoadSymbolOfLengthFromModule(int functionNameIndex, int functionNameLength, int moduleHandle);/* The next three functions must be implemented by sqXYZExternalPrims.c *//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName);/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle);/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle);/* The Squeak version this interpreter was generated from */extern const char *interpreterVersion;'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/26/2000 10:39'!squeakPlatformExportsFile	^ '/* This file is for extra (platform) specific declarations of exported functions.   The general format is a list of XFN(name), referring to the extra exports that   should be listed in the internal primitive table. As an example, two extra   definitions required by the Unix VM would look like:   XFN(SetSocketPollingFunction)   XFN(SetSoundPollingFunction)*/#ifdef macintosh//#define PLUGIN#ifdef PLUGIN/* Plugin support primitives   We should make these primitives a proper plugin   but right now we just need the exports. */XFN(primitivePluginBrowserReady)XFN(primitivePluginRequestURLStream)XFN(primitivePluginRequestURL)XFN(primitivePluginRequestFileHandle)XFN(primitivePluginDestroyRequest)XFN(primitivePluginRequestState)#endif#endif /* macintosh */'! !InterpreterSupportCode class removeSelector: #archiveBinaryFileBytes!InterpreterSupportCode class removeSelector: #macExternalPrimsFile!InterpreterSupportCode class removeSelector: #storeProjectArchiveOnFileNamed:!