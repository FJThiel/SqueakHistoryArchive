'From Squeak 2.5 of August 6, 1999 [latest update: #1517] on 5 October 1999 at 9:16:01 pm'!"Change Set:		browserOptions-swDate:			5 October 1999Author:			Scott WallaceSummary: primarily serves to extend the availability of annotation panes and 'optional morphic buttons' to various tools from which they had been absent, and to make 'diffs' optionally available in most code tools.Allows system browsers to show both annotation panes and optional morphic buttons if the appropriate preferences are set.  (NB: at present, only the full system browser is affected; class category, class, method-category, hierarchy, and protocol browsers don't yet show the optional panes.)Makes optional morphic buttons available in message-list browsers and in versions browsers as well.Makes annotation panes available in debuggers.These changes for the moment are only made to the morphic development environment.  mvc browsers are not affected.Makes the 'browse method' command in the various tools now bring up a message-list browser on the given method, rather than an oddball system browser.Cmd-key equivalent for the browse-this-method command added:  cmd-O (that's an upper-case letter o).Makes cmd-I in an inspector open up an ObjectExplorer.Adds the ability to show diffs from prior version in any message-list browser, system browser, changelist browser, versions browser; the control for this (if you're in morphic and in a message-list browser or a changelist browser or a versions browser) will be found in the 'optional morphic buttons', but can also be reached, less elegantly, from either mvc or morphic, via the menu item 'toggle diffing' on the shifted side of the selector menu.Also, adds a new item to the choices can be shown in annotation panes, namely the count of prior versions.   Use with discretion!!Inserts CodeHolder as a layer of hierarchy between StringHolder and any of the code-holding models (Browser, ChangeSorter, ChangeList, Debugger)Reworks menus for versions browsers -- most of the items in their selector menus had been at best irrelevant, at worst prone to drop you into a debugger."!StringHolder subclass: #CodeHolder	instanceVariableNames: 'showDiffs '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Support'!CodeHolder subclass: #Browser	instanceVariableNames: 'systemOrganizer classOrganizer metaClassOrganizer systemCategoryListIndex classListIndex messageCategoryListIndex messageListIndex editSelection metaClassIndicated '	classVariableNames: 'RecentClasses '	poolDictionaries: ''	category: 'Interface-Browser'!CodeHolder subclass: #ChangeList	instanceVariableNames: 'changeList list listIndex listSelections file lostMethodPointer showsVersions '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Changes'!CodeHolder subclass: #ChangeSorter	instanceVariableNames: 'parent myChangeSet currentClassName currentSelector priorChangeSetList '	classVariableNames: 'AllChangeSets '	poolDictionaries: ''	category: 'Interface-Changes'!CodeHolder subclass: #Debugger	instanceVariableNames: 'interruptedProcess interruptedController contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC sourceMap tempNames '	classVariableNames: 'ContextStackKeystrokes ErrorRecursion '	poolDictionaries: ''	category: 'Interface-Debugger'!!Preferences class methodsFor: 'parameters' stamp: 'sw 9/25/1999 00:12'!annotationInfo 	^ #(		(timeStamp			'The time stamp of the last submission of the method.')		(messageCategory	'Which method category the method lies in')		(sendersCount		'A report of how many senders there of the message.')		(implementorsCount	'A report of how many implementors there are of the message.')		(recentChangeSet	'The most recent change set bearing the method.')		(allChangeSets		'A list of all change sets bearing the method.')		(priorVersionsCount	'A report of how many previous versions there are of the method' ))! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 10/5/1999 21:13'!noteThatFlag: prefSymbol justChangedTo: aBoolean	"Provides a hook so that a user's toggling of a preference might precipitate some immediate action"	| keep |	prefSymbol == #useGlobalFlaps ifTrue:		[aBoolean			ifFalse:		"Turning off use of flaps"				[keep _ self confirm:'Do you want to preserve the existingglobal flaps for future use?'.				Utilities globalFlapTabsIfAny do:					[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: keep.					aFlapTab isInWorld ifTrue: [self error: 'Flap problem']].				keep ifFalse: [Utilities clobberFlapTabList]]			ifTrue:		"Turning on use of flaps"				[Smalltalk isMorphic ifTrue:					[self currentWorld addGlobalFlaps]]].	prefSymbol == #roundedWindowCorners ifTrue:		[World ifNotNil: [World fullRepaintNeeded]].	prefSymbol == #optionalMorphicButtons ifTrue:		[Utilities replacePartSatisfying: [:el |  (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented model isKindOf: FileList]]]inGlobalFlapSatisfying: [:f1 | f1 wording = 'Tools'] with:  FileList openAsMorph applyModelExtent].	(prefSymbol == #optionalMorphicButtons  or: [prefSymbol == #useAnnotationPanes]) ifTrue:		[Utilities replaceBrowserInToolsFlap]! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sw 9/30/1999 11:12'!confirm: queryString trueChoice: trueChoice falseChoice: falseChoice	"Put up a yes/no menu with caption queryString.  The actual wording for the two choices will be as provided in the trueChoice and falseChoice parameters.  Answer true if the response is the true-choice, false if it's the false-choice.  This is a modal question -- the user must respond one way or the other."	"SelectionMenu confirm: 'Are you hungry?' trueChoice: 'yes, I''m famished' falseChoice: 'no, I just ate'"	| menu choice |	menu _ self selections: (Array with: trueChoice with: falseChoice).	[true] whileTrue: [		choice _ menu startUpWithCaption: queryString.		choice = trueChoice ifTrue: [^ true].		choice = falseChoice ifTrue: [^ false]]! !!StringHolder methodsFor: 'accessing' stamp: 'sw 9/27/1999 14:16'!contentsChanged	self changed: #contents! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 9/21/1999 11:52'!messageListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."	| sel class |	(class _ self selectedClassOrMetaClass) ifNil: [^ self arrowKey: aChar from: view].	sel _ self selectedMessageName.	aChar == $b ifTrue: [^ Browser fullOnClass: class selector: sel].	aChar == $N ifTrue: [^ self browseClassRefs].	sel ifNil: [^ self arrowKey: aChar from: view].	aChar == $m ifTrue: [^ Smalltalk browseAllImplementorsOf: sel].	aChar == $n ifTrue: [^ Smalltalk browseAllCallsOn: sel].	aChar == $v ifTrue: [^ self browseVersions].	aChar == $O ifTrue: [^ self openSingleMessageBrowser].	^ self arrowKey: aChar from: view! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 9/21/1999 11:35'!openSingleMessageBrowser	| msgName title |	"Create and schedule a message list browser populated only by the currently selected message"	(msgName _ self selectedMessageName) ifNil: [^ self].	Smalltalk browseMessageList: (Array with: (title _ self selectedClassOrMetaClass name, ' ', msgName))		name: title autoSelect: nil! !!StringHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 14:10'!showDiffs	"For backward compatibility during transition only, lest browsers be unusable for a spell"	^ false! !!CodeHolder commentStamp: 'sw 10/5/1999 21:16' prior: 0!An ancestor class for all models which can show code.  Eventually, much of the code that currently resides in StringHolder which only applies to code-holding StringHolders might get moved down here.!!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/30/1999 11:18'!annotation	"Provide a line of annotation material for a middle pane."	| stamp aMessage sendersCount implementorsCount toShow aCategory separator aString aList versionsCount |	(aMessage _ self selectedMessageName)		ifNil: [^ '------'].	toShow _ ReadWriteStream on: ''.	separator _ ' ¥ '.	self annotationRequests do:		[:aRequest |		(aRequest == #timeStamp) ifTrue:			[stamp _ self timeStamp.			toShow nextPutAll: (stamp size > 0				ifTrue: [stamp, separator]				ifFalse: ['no timeStamp', separator])].		(aRequest == #messageCategory) ifTrue:			[aCategory _ self selectedClassOrMetaClass organization categoryOfElement: self selectedMessageName.			aCategory ifNotNil: "woud be nil for a method no longer present, e.g. in a recent-submissions browser"				[toShow nextPutAll: aCategory, separator]].		(aRequest == #sendersCount) ifTrue:			[sendersCount _ (Smalltalk allCallsOn: aMessage) size.			sendersCount _ sendersCount == 1				ifTrue:					['1 sender']				ifFalse:					[sendersCount printString, ' senders'].			toShow nextPutAll: sendersCount, separator].		(aRequest == #implementorsCount) ifTrue:			[implementorsCount _ (Smalltalk allImplementorsOf: aMessage) size.			implementorsCount _ implementorsCount == 1				ifTrue:					['1 implementor']				ifFalse:					[implementorsCount printString, ' implementors'].			toShow nextPutAll: implementorsCount,  separator].		(aRequest == #priorVersionsCount) ifTrue:			[versionsCount _ ChangeList versionCountForSelector: self selectedMessageName class: self selectedClassOrMetaClass.			toShow nextPutAll: 				((versionsCount > 1					ifTrue:						[versionsCount == 2 ifTrue:							['1 prior version']							ifFalse:								[versionsCount printString, ' prior versions']]					ifFalse:						['no prior versions']), separator)].		(aRequest == #recentChangeSet) ifTrue:			[aString _ ChangeSorter mostRecentChangeSetWithChangeForClass: self selectedClassOrMetaClass selector: self selectedMessageName.			aString size > 0 ifTrue: [toShow nextPutAll: aString, separator]].		(aRequest == #allChangeSets) ifTrue:			[aList _ ChangeSorter allChangeSetsWithClass: self selectedClassOrMetaClass selector: self selectedMessageName.			aList size > 0				ifTrue:					[aList size = 1						ifTrue:							[toShow nextPutAll: 'only in change set ']						ifFalse:							[toShow nextPutAll: 'in change sets: '].					aList do:						[:aChangeSet | toShow nextPutAll: aChangeSet name, ' ']]				ifFalse:					[toShow nextPutAll: 'in no change set'].			toShow nextPutAll: separator]].			^ toShow contents! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 14:13'!annotationRequests	^ Preferences defaultAnnotationRequests! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 14:14'!changeCategory	"Present a menu of the categories of messages for the current class, and let the user choose a new category for the current message"	| aClass aSelector |	(aClass _ self selectedClassOrMetaClass) ifNotNil:		[(aSelector _ self selectedMessageName) ifNotNil:			[(aClass organization letUserReclassify: aSelector) ifTrue:				["Smalltalk changes reorganizeClass: aClass."				"Decided on further review that the above, when present, could cause more                    unexpected harm than good"				self methodCategoryChanged]]]! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 14:11'!contentsChanged	self changed: #contents.	self changed: #annotation! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/5/1999 21:15'!diffButton	|  outerButton aButton aForm |	"Return a checkbox that lets the user decide whether diffs should be shown or not"	outerButton _ AlignmentMorph newRow height: 24.	outerButton color:  Color transparent.	outerButton hResizing: #shrinkToFit; vResizing: #shrinkToFit.	outerButton addMorph: (aButton _ UpdatingThreePhaseButtonMorph new).	aButton onImage: (aForm _ ScriptingSystem formAtKey: #ButtonOn);		pressedImage:	aForm;		offImage: (ScriptingSystem formAtKey: #ButtonOff);		actionSelector: #toggleDiff;		extent: 18 @ 16;		target: self;		getSelector: #showDiffs.	outerButton addMorphBack: (StringMorph contents: 'diffs') lock.	outerButton setBalloonText: 'If checked, then code differences from the previous version, if any, will be shown.'.	^ outerButton	! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 14:04'!diffFromPriorSourceFor: sourceCode	| prior |	"If there is a prior version of source for the selected method, return a diff, else just return the source code"	^ (prior _ self priorSourceOrNil)		ifNil:			[sourceCode]		ifNotNil:			[TextDiffBuilder buildDisplayPatchFrom: prior to: sourceCode]! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 14:11'!methodCategoryChanged	self changed: #annotation! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/30/1999 12:08'!okayToAccept	self showDiffs ifFalse:		[^ true]. 	^ (SelectionMenu confirm: 'Caution!!  You are "showing diffs" here, so there is a danger that some of the text in thecode pane is contaminated by the "diff" display'	trueChoice: 'accept anyway -- I''ll take my chances' falseChoice: 'um, let me reconsider')! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 14:09'!priorSourceOrNil	"If the currently-selected method has a previous version, return its source, else return nil"	| aClass aSelector  changeRecords |	(aClass _ self selectedClassOrMetaClass) ifNil: [^ nil].	(aSelector _ self selectedMessageName) ifNil: [^ nil].	changeRecords _ aClass changeRecordsAt: aSelector.	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [^ nil].	^ (changeRecords at: 2) string ! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 13:56'!showDiffs	^ showDiffs == true! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 13:56'!showDiffs: aBoolean	showDiffs _ aBoolean! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 16:08'!toggleDiff	self okToChange ifTrue:		[self showDiffs: self showDiffs not.		contents _ nil.		self changed: #contents]! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 16:33'!toggleDiffing	| showing |	showing _ self showDiffs.	self toggleDiff.	showing = self showDiffs ifTrue: ["cancelled out" ^ self].	self inform: (showDiffs		ifTrue:			['Okay, diffs will be shown']		ifFalse:			['Okay, diffs will no longer be shown'])! !!Browser methodsFor: 'initialize-release' stamp: 'sw 9/22/1999 17:13'!methodCategoryChanged	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #annotation.	self messageListIndex: 0! !!Browser methodsFor: 'initialize-release' stamp: 'sw 9/27/1999 14:23'!openAsMorphEditing: editString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window switches codePane aListMorph baseline aTextMorph |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #systemCategoryList			selected: #systemCategoryListIndex changeSelected: #systemCategoryListIndex:			menu: #systemCategoryMenu: keystroke: #systemCatListKey:from:)		frame: (0@0 extent: 0.25@0.4).	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu: keystroke: #classListKey:from:)		frame: (0.25@0 extent: 0.25@0.3).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0.25@0.3 extent: 0.25@0.1).	switches borderWidth: 0.	window addMorph: (PluggableListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu:)		frame: (0.5@0 extent: 0.25@0.4).	aListMorph _ PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0.75@0 extent: 0.25@0.4).	Preferences useAnnotationPanes		ifFalse:			[baseline _ 0.4]		ifTrue:			[aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.4 corner: 1@0.45).			baseline _ 0.45].	Preferences optionalMorphicButtons		ifTrue:			[window addMorph: self optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0 @ baseline corner: 1 @ 1).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'sw 9/27/1999 22:57'!optionalButtonRow	| aRow aButton |	aRow _ AlignmentMorph newRow.	aButton _ SimpleButtonMorph new target: self.	aButton color: Color transparent; borderWidth: 1; borderColor: Color black.	aRow addTransparentSpacerOfSize: (5@0).	#(('senders' 		browseSendersOfMessages)	('implementors'		browseMessages)	('versions'			browseVersions)	('inheritance'		methodHierarchy)	('hierarchy'		classHierarchy)	('inst vars'			browseInstVarRefs)	('class vars'			browseClassVarRefs)) do:			[:pair |				aButton _ aButton fullCopy.				aButton actionSelector: pair second.				aButton label: pair first.				aRow addMorphBack: aButton.				aRow addTransparentSpacerOfSize: (3 @ 0)].	^ aRow! !!Browser methodsFor: 'accessing' stamp: 'sw 9/30/1999 13:19'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be	 updated. The information can be a variety of things, depending on	 the list selections (such as templates for class or message definition,	 methods) or the user menu commands (such as definition, comment,	 hierarchy).  Answer the result of updating the source."	| aString aText theClass |	self changed: #annotation.	aString _ input asString.	aText _ input asText.	editSelection == #editSystemCategories ifTrue: [^ self changeSystemCategories: aString].	editSelection == #editClass | (editSelection == #newClass) ifTrue: [^ self defineClass: aString notifying: aController].	editSelection == #editComment		ifTrue: 			[theClass _ self selectedClass.			theClass				ifNil: 					[PopUpMenu notify: 'You must select a classbefore giving it a comment.'.					^ false].			theClass comment: aText stamp: Utilities changeStamp.			^ true].	editSelection == #hierarchy ifTrue: [^ true].	editSelection == #editMessageCategories ifTrue: [^ self changeMessageCategories: aString].	editSelection == #editMessage | (editSelection == #newMessage)		ifTrue:			[^ self okayToAccept				ifFalse:					[false]				ifTrue:					[self compileMessage: aText notifying: aController]].	editSelection == #none		ifTrue: 			[PopUpMenu notify: 'This text cannot be acceptedin this part of the browser.'.			^ false].	self error: 'unacceptable accept'! !!Browser methodsFor: 'message list' stamp: 'sw 9/22/1999 17:17'!messageListIndex: anInteger 	"Set the selected message selector to be the one indexed by anInteger."	messageListIndex _ anInteger.	editSelection _ 		anInteger = 0			ifTrue: [#newMessage]			ifFalse: [#editMessage].	contents _ nil.	self changed: #messageListIndex.	"update my selection"	self contentsChanged! !!Browser methodsFor: 'message list' stamp: 'sw 9/25/1999 00:31'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector method tempNames |	contents == nil ifFalse: [^ contents copy].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector.	(Sensor controlKeyPressed		or: [method fileIndex > 0 and: [(SourceFiles at: method fileIndex) == nil]])		ifTrue:		["Emergency or no source file -- decompile without temp names"		contents _ (class decompilerClass new decompile: selector in: class method: method)			decompileString.		^ contents copy].	Sensor leftShiftDown ifTrue:		["Special request to decompile -- get temps from source file"		tempNames _ (class compilerClass new						parse: method getSourceFromFile asString in: class notifying: nil)						tempNames.		contents _ ((class decompilerClass new withTempNames: tempNames)				decompile: selector in: class method: method) decompileString.		contents _ contents asText makeSelectorBoldIn: class.		^ contents copy].	contents _ class sourceCodeAt: selector.	Preferences browseWithPrettyPrint ifTrue:		[contents _ class compilerClass new			format: contents in: class notifying: nil].	self showDiffs ifTrue:		[contents _ self diffFromPriorSourceFor: contents].	contents _ contents asText makeSelectorBoldIn: class.	^ contents copy! !!Browser methodsFor: 'message functions' stamp: 'sw 9/30/1999 11:18'!defineMessageFrom: aString notifying: aController	"Compile the expressions in aString. Notify aController if a syntax error occurs. Install the compiled method in the selected class classified under  the currently selected message category name. Answer the selector obtained if compilation succeeds, nil otherwise."	| selectedMessageName selector category oldMessageList |	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	contents _ nil.	selector _ self selectedClassOrMetaClass				compile: aString				classified: (category _ self selectedMessageCategoryName)				notifying: aController.	selector == nil ifTrue: [^ nil].	contents _ aString copy.	selector ~~ selectedMessageName		ifTrue: 			[category = ClassOrganizer nullCategory				ifTrue: [self changed: #classSelectionChanged.						self changed: #classList.						self messageCategoryListIndex: 1].			self setClassOrganizer.  "In case organization not cached"			(oldMessageList includes: selector)				ifFalse: [self changed: #messageList].			self messageListIndex: (self messageList indexOf: selector)]		ifFalse:			[self changed: #annotation].	^ selector! !!Browser methodsFor: 'message functions' stamp: 'sw 9/25/1999 00:04'!messageListMenu: aMenu shifted: shifted	^ shifted ifFalse: [aMenu labels:'browse full (b)fileOutprintOutsenders of... (n)implementors of... (m)method inheritanceversions (v)inst var refs...inst var defs...class var refs...class variablesclass refs (N)removemore...'	lines: #(3 7 12)	selections:		#(browseMethodFull fileOutMessage printOutMessage		browseSendersOfMessages browseMessages methodHierarchy browseVersions		browseInstVarRefs browseInstVarDefs browseClassVarRefs 			browseClassVariables browseClassRefs		removeMessage shiftedYellowButtonActivity )]	ifTrue: [aMenu labels: 'browse class hierarchybrowse classbrowse method (O)toggle diffingimplementors of sent messageschange sets with this methodinspect instancesinspect subinstancesremove from this browserchange category...revert to previous versionremove from current change setrevert and forgetfetch documentationmore...' 	lines:  #(6 8 10 13)	selections: #(classHierarchy browseClass 		openSingleMessageBrowser toggleDiffing browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		removeMessageFromBrowser 		changeCategory		revertToPreviousVersion 		removeFromCurrentChanges revertAndForget 		fetchDocPane		unshiftedYellowButtonActivity)]! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 9/27/1999 15:59'!buttonRowForChangeList	| aRow aButton |	aRow _ AlignmentMorph newRow.	aButton _ SimpleButtonMorph new target: self.	aButton color: Color lightBlue; borderWidth: 1; borderColor: Color blue darker.	aRow addTransparentSpacerOfSize: (5@0).	#(('select all' 		selectAll)	('deselect all'		deselectAll)	('select conflicts'	selectConflicts)	('file in selections' 	fileInSelections)) do:			[:pair |				aButton _ aButton fullCopy.				aButton actionSelector: pair second.				aButton label: pair first.				aRow addMorphBack: aButton.				aRow addTransparentSpacerOfSize: (3 @ 0)].	aRow addMorphBack: self diffButton.		^ aRow! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 10/5/1999 20:41'!buttonRowForVersions	| aRow aButton |	aRow _ AlignmentMorph newRow.	aButton _ SimpleButtonMorph new target: self.	aButton color: Color lightBlue; borderWidth: 1; borderColor: Color blue darker.	aRow addTransparentSpacerOfSize: (5@0).	#(	('compare to current' 	compareToCurrentVersion			'opens a separate window which shows the text differences between the selected version and the current version')) do:			[:triplet |				aButton _ aButton fullCopy.				aButton actionSelector: triplet second.				aButton label: triplet first.				aButton setBalloonText: triplet third.				aRow addMorphBack: aButton.				aRow addTransparentSpacerOfSize: (3 @ 0)].	aRow addMorphBack: self diffButton.		^ aRow! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 9/27/1999 16:02'!initialize	showsVersions _ false.	showDiffs _ Preferences showDiffsInChangeList.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	super initialize! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 9/27/1999 16:21'!optionalMorphicButtons	^ self showsVersions		ifFalse:			[self buttonRowForChangeList]		ifTrue:			[self buttonRowForVersions]! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 9/27/1999 16:06'!changeListMenu: aMenu^ aMenu labels:'fileIn selectionsfileOut selections...compare to currenttoggle diffingselect conflictsselect conflicts withselect unchanged methodsselect methods for this classselect alldeselect allremove doItsremove older versionsremove selections'	lines: #(2 4 10)	selections: #(fileInSelections fileOutSelectionscompareToCurrentVersion toggleDiffing selectConflicts selectConflictsWith selectUnchangedMethods selectMethodsForThisClass selectAll deselectAllremoveDoIts removeOlderMethodVersions removeSelections)! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 9/27/1999 16:26'!versionsMenu: aMenu	^ aMenu labels:'compare to currenttoggle diffing'	lines: #()	selections: #(compareToCurrentVersion toggleDiffing )! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 9/27/1999 16:01'!contents	^ self showDiffs		ifFalse:			[self undiffedContents]		ifTrue:			[self showsVersions				ifTrue:					[self diffedVersionContents]				ifFalse:					[self contentsDiffedFromCurrent]]! !!ChangeList class methodsFor: 'instance creation' stamp: 'sw 9/27/1999 16:27'!open: aChangeList name: aString multiSelect: multiSelect	"Create a standard system view for the messageSet, whose label is aString.	The listView may be either single or multiple selection type"	| topView aBrowserCodeView aListView |	World ifNotNil: [^ self openAsMorph: aChangeList name: aString multiSelect: multiSelect].	topView _ (StandardSystemView new) model: aChangeList.	topView label: aString.	topView minimumSize: 180 @ 120.	topView borderWidth: 1.	aListView _ (multiSelect ifTrue: [PluggableListViewOfMany]							ifFalse: [PluggableListView])		on: aChangeList list: #list		selected: #listIndex changeSelected: #toggleListIndex:		menu: (aChangeList showsVersions ifTrue: [#versionsMenu:] ifFalse: [#changeListMenu:])		keystroke: #messageListKey:from:.	aListView window: (0 @ 0 extent: 180 @ 100).	topView addSubView: aListView.	aBrowserCodeView _ PluggableTextView on: aChangeList 			text: #contents accept: #contents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aBrowserCodeView controller: ReadOnlyTextController new.	aBrowserCodeView window: (0 @ 0 extent: 180 @ 300).	topView addSubView: aBrowserCodeView below: aListView.	topView controller open! !!ChangeList class methodsFor: 'instance creation' stamp: 'sw 9/29/1999 18:40'!openAsMorph: aChangeList name: labelString multiSelect: multiSelect	"Open a morphic view for the messageSet, whose label is labelString.	The listView may be either single or multiple selection type"	| window boundary |	window _ (SystemWindow labelled: labelString) model: aChangeList.	Preferences optionalMorphicButtons		ifFalse:			[boundary _ 0]		ifTrue:			[boundary _ 0.08.			window addMorph: aChangeList optionalMorphicButtons frame: (0 @ 0 corner: 1 @ boundary)].	window addMorph: ((multiSelect ifTrue: [PluggableListMorphOfMany]									ifFalse: [PluggableListMorph])		on: aChangeList list: #list		selected: #listIndex changeSelected: #toggleListIndex:		menu: (aChangeList showsVersions ifTrue: [#versionsMenu:] ifFalse: [#changeListMenu:])			keystroke: nil)		frame: (0@boundary corner: 1@0.4).	window addMorph: (AcceptableCleanTextMorph on: aChangeList 			text: #contents accept: #contents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.4 corner: 1@1).	^ window openInWorld! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 9/21/1999 11:53'!shiftedMessageMenu: aMenu	^ aMenu labels: 'browse class hierarchybrowse classbrowse method (O)implementors of sent messageschange sets with this methodinspect instancesinspect subinstanceschange category...revert to previous versionrevert and forgetmore...' 	lines: #(5 7 8 10)	selections: #(classHierarchy browseClass 		openSingleMessageBrowser browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		changeCategory		revertToPreviousVersion revertAndForget		unshiftedYellowButtonActivity)! !!Debugger methodsFor: 'initialize' stamp: 'sw 9/27/1999 14:25'!openFullMorphicLabel: labelString	| window aListMorph codeTop aTextMorph |	self expandStack.	window _ (SystemWindow labelled: labelString) model: self.	aListMorph _ PluggableListMorph on: self list: #contextStackList			selected: #contextStackIndex changeSelected: #toggleContextStackIndex:			menu: #contextStackMenu:shifted: keystroke: #contextStackKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0@0 corner: 1@0.3).	Preferences useAnnotationPanes		ifFalse:			[codeTop _ 0.3]		ifTrue:			[aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.3 corner: 1@0.35).			codeTop _ 0.35].	Preferences optionalMorphicButtons ifTrue:		[window addMorph: self optionalButtonRow frame: ((0@codeTop corner: 1 @ (codeTop + 0.1))).		codeTop _ codeTop + 0.1].	window addMorph: (PluggableTextMorph on: self			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0 @ codeTop corner: 1 @ 0.7).	window addMorph: (PluggableListMorph on: self receiverInspector list: #fieldList			selected: #selectionIndex changeSelected: #toggleIndex:			menu: #fieldListMenu: keystroke: #inspectorKey:from:)		frame: (0@0.7 corner: 0.2@1).	window addMorph: (PluggableTextMorph on: self receiverInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.2@0.7 corner: 0.5@1).	window addMorph: (PluggableListMorph on: self contextVariablesInspector list: #fieldList			selected: #selectionIndex changeSelected: #toggleIndex:			menu: #fieldListMenu: keystroke: #inspectorKey:from:)		frame: (0.5@0.7 corner: 0.7@1).	window addMorph: (PluggableTextMorph on: self contextVariablesInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.7@0.7 corner: 1@1).	^ window openInWorld! !!Debugger methodsFor: 'initialize' stamp: 'sw 9/27/1999 14:24'!optionalButtonRow	| aRow aButton |	aRow _ AlignmentMorph newRow.	aButton _ SimpleButtonMorph new target: self.	aButton color: Color lightRed; borderWidth: 1; borderColor: Color red darker.	aRow addTransparentSpacerOfSize: (5@0).	#(('Proceed' proceed)	('Restart'	restart)	('Send'		send)	('Step'		doStep)	('Full Stack'	fullStack)	('Where'	where)	('Browse full'	browseMethodFull)) do:			[:pair |				aButton _ aButton fullCopy.				aButton actionSelector: pair second.				aButton label: pair first.				aRow addMorphBack: aButton.				aRow addTransparentSpacerOfSize: (3 @ 0)].	^ aRow! !!Debugger methodsFor: 'context stack menu' stamp: 'sw 9/21/1999 11:53'!contextStackMenu: aMenu shifted: shifted	^ shifted ifFalse: [aMenu labels: 'fullStack (f)restart (r)proceed (p)step (t)send (e)where (w)peel to first like thissenders of... (n)implementors of... (m)method inheritanceversions (v)inst var refs...inst var defs...class var refs...class variablesclass refs (N)browse full (b)file out more...'	lines: #(7 11 13 16 18)	selections: #(fullStack restart proceed doStep send where peelToFirstbrowseSendersOfMessages browseMessages methodHierarchy browseVersionsbrowseInstVarRefs browseInstVarDefsbrowseClassVarRefs browseClassVariables browseClassRefsbrowseMethodFull fileOutMessageshiftedYellowButtonActivity)]	ifTrue: [aMenu labels: 'browse class hierarchybrowse classbrowse method (O)implementors of sent messageschange sets with this methodinspect instancesinspect subinstancesrevert to previous versionremove from current change setrevert and forgetmore...' 	lines: #(5 7 10)	selections: #(classHierarchy browseClass 		openSingleMessageBrowser browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		revertToPreviousVersion 		removeFromCurrentChanges revertAndForget		unshiftedYellowButtonActivity)]! !!Debugger methodsFor: 'private' stamp: 'sw 9/23/1999 15:58'!contextStackIndex: anInteger oldContextWas: oldContext	| newMethod |	contextStackIndex _ anInteger.	anInteger = 0		ifTrue:			[tempNames _ sourceMap _ contents _ nil.			self changed: #contextStackIndex.			self contentsChanged.			contextVariablesInspector object: nil.			receiverInspector object: self receiver.			^self].	(newMethod _ oldContext == nil or:		[oldContext method ~~ self selectedContext method])		ifTrue:			[tempNames _ sourceMap _ nil.			contents _ self selectedMessage.			self contentsChanged.			self pcRange "will compute tempNamesunless noFrills"].	self changed: #contextStackIndex.	tempNames == nil		ifTrue: [tempNames _ 					self selectedClassOrMetaClass parserClass new parseArgsAndTemps: contents notifying: nil].	contextVariablesInspector object: self selectedContext.	receiverInspector object: self receiver.	newMethod ifFalse: [self changed: #contentsSelection]! !!FileList methodsFor: 'initialization' stamp: 'sw 9/27/1999 14:25'!optionalButtonRow	| aRow aButton |	aRow _ AlignmentMorph newRow.	aButton _ SimpleButtonMorph new target: self.	aButton color: Color lightMagenta; borderWidth: 1; borderColor: Color brown.	aRow addTransparentSpacerOfSize: (5@0).	#(	('Name' 		sortByName)		('Date'			sortByDate)		('Size'			sortBySize)		('Changes'		browseChanges)		('File-in'		fileInSelection)		('File-in to New'	fileIntoNewChangeSet)) do:			[:pair |				aButton actionSelector: pair second.				aButton label: pair first.				aRow addMorphBack: aButton.				aRow addTransparentSpacerOfSize: (3 @ 0).				aButton _ aButton fullCopy.				(pair second == #sortBySize)					ifTrue:						[aRow addTransparentSpacerOfSize: (4@0).						aButton borderColor: Color magenta darker]].	^ aRow! !!FileList class methodsFor: 'instance creation' stamp: 'sw 9/27/1999 14:25'!openAsMorph     "FileList openAsMorph openInMVC"	"Open a morphic view of a FileList on the default directory."	| dir aFileList window fileListTop |	dir _ FileDirectory default.	aFileList _ self new directory: dir.	window _ (SystemWindow labelled: dir pathName) model: aFileList.	window addMorph: ((PluggableListMorph on: aFileList list: #volumeList selected: #volumeListIndex				changeSelected: #volumeListIndex: menu: #volumeMenu:) autoDeselect: false)		frame: (0@0 corner: 0.3@0.2).	window addMorph: (PluggableTextMorph on: aFileList text: #pattern accept: #pattern:)		frame: (0@0.2 corner: 0.3@0.3).	Preferences optionalMorphicButtons		ifTrue:			[window addMorph: aFileList optionalButtonRow frame: (0.3 @ 0 corner: 1 @ 0.08).			fileListTop _ 0.08]		ifFalse:			[fileListTop _ 0].	window addMorph: (PluggableListMorph on: aFileList list: #fileList selected: #fileListIndex				changeSelected: #fileListIndex: menu: #fileListMenu:)		frame: (0.3 @ fileListTop corner: 1@0.3).	window addMorph: (PluggableTextMorph on: aFileList text: #contents accept: #put:			readSelection: #contentsSelection menu: #fileContentsMenu:shifted:)		frame: (0@0.3 corner: 1@1).	^ window! !!Inspector methodsFor: 'menu commands' stamp: 'sw 9/21/1999 12:16'!exploreSelection	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	^ self selection explore! !!Inspector methodsFor: 'menu commands' stamp: 'sw 9/21/1999 12:10'!fieldListMenu: aMenu	^ aMenu labels: 'inspect (i)explore (I)method refs to this inst varobjects pointing to this valuecopy namebrowse full (b)browse classinst var refs...inst var defs...class var refs...class variablesclass refsbasic inspect'	lines: #(2 4 5 7 9 12)	selections: #(inspectSelection exploreSelection referencesToSelection objectReferencesToSelection copyName  browseMethodFull browseClass browseInstVarRefs browseInstVarDefs classVarRefs browseClassVariables browseClassRefs inspectBasic).! !!Inspector methodsFor: 'menu commands' stamp: 'sw 9/21/1999 12:13'!inspectorKey: aChar from: view	"respond to a Command key.  Got here from a list of fields being inspected"	aChar == $i ifTrue: [self selection inspect].	aChar == $I ifTrue: [self selection explore].	aChar == $b ifTrue:	[self browseMethodFull].	aChar == $c ifTrue: [self copyName].	^ self arrowKey: aChar from: view! !!MessageSet methodsFor: 'message list' stamp: 'sw 9/27/1999 22:57'!optionalButtonRow	| aRow |	aRow _ super optionalButtonRow.	aRow addMorphBack: self diffButton.	^ aRow! !!MessageSet methodsFor: 'message list' stamp: 'sw 9/24/1999 23:49'!selectedMessage	"Answer the source method for the currently selected message."	| source |	self setClassAndSelectorIn: [:class :selector | 		source _ class sourceMethodAt: selector ifAbsent: [^ 'Missing'].		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil].		self showDiffs ifTrue:			[source _ self diffFromPriorSourceFor: source].		^ source asText makeSelectorBoldIn: class]! !!MessageSet methodsFor: 'message functions' stamp: 'sw 9/27/1999 15:30'!toggleDiff	self okToChange ifTrue:		[self showDiffs: self showDiffs not.		self changed: #contents]! !!MessageSet methodsFor: 'contents' stamp: 'sw 9/30/1999 11:07'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector |	messageListIndex = 0 ifTrue: [^ false].	self okayToAccept ifFalse: [^ false].	self setClassAndSelectorIn: [:class :oldSelector].	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^false].	selector == oldSelector ifFalse: [self messageListIndex: 0].	contents _ aString copy.	self changed: #annotation.	^ true! !!ChangedMessageSet methodsFor: 'everything' stamp: 'sw 9/30/1999 12:15'!contents: aString notifying: aController	| selectedMessageName selector oldMessageList cls |	self okayToAccept ifFalse: [^ false].	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	contents _ nil.	selector _ self selectedClassOrMetaClass				compile: aString				classified:  self selectedMessageCategoryName				notifying: aController.	selector == nil ifTrue: [^ false].	cls _ self selectedClassOrMetaClass.	contents _ aString copy.	selector ~~ selectedMessageName ifTrue: 			[(oldMessageList includes: selector) ifFalse: [					self initializeMessageList: changeSet changedMessageListAugmented.					self changed: #messageList].			self messageListIndex: (self messageList indexOf: (cls name, ' ', selector))].	^ true! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 9/27/1999 14:23'!openAsMorph: aMessageSet name: labelString inWorld: aWorld	"Create a SystemWindow aMessageSet, with the label labelString."	| window aListMorph aTextMorph baseline |	window _ (SystemWindow labelled: labelString) model: aMessageSet.	aListMorph _ PluggableListMorph on: aMessageSet list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0@0 extent: 1@0.2).	Preferences useAnnotationPanes		ifFalse:			[baseline  _ 0.2]		ifTrue:			[aTextMorph _ PluggableTextMorph on: aMessageSet					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.2 corner: 1@0.25).			baseline _ 0.25].	Preferences optionalMorphicButtons		ifTrue:			[window addMorph: aMessageSet optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	window addMorph: (PluggableTextMorph on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@baseline corner: 1@1).	window openInWorld: aWorld! !!SystemDictionary methodsFor: 'browsing' stamp: 'sw 9/21/1999 11:38'!browseMessageList: messageList name: labelString autoSelect: autoSelectString	| title aSize |	"Create and schedule a MessageSet browser on the message list."	messageList size = 0 ifTrue: 		[^ (PopUpMenu labels: ' OK ')				startUpWithCaption: 'There are no' , labelString].	title _ (aSize _ messageList size) > 1		ifFalse:	[labelString]		ifTrue:	[ labelString, ' [', aSize printString, ']'].	MessageSet openMessageList: messageList name: title autoSelect: autoSelectString! !!Utilities class methodsFor: 'support windows' stamp: 'sw 9/21/1999 12:22'!commandKeyMappings	^ self class firstCommentAt: #commandKeyMappings"Lower-case command keysa	Select allb	Browse it (selection is a class name)c	Copyd	Do it (selection is a valid expression)e	Exchangef	Findg	Find againh	Set Search Stringi	Inspect it (selection is a valid expression)j	Again oncek	Set fontl	Cancelm	Implementors of it (selection is a message selector)n	Senders of it (selection is a message selector)o	Spawnp	Print it (selection is a valid expression)q	Query symbolr	Recognizers	Save (i.e. accept)u	Alignv	Pastew	Delete preceding wordx	Cuty	Swap charactersz	UndoNote: for Do it, Senders of it, etc., a null selection will be expanded to a word or to the current line in an attempt to do what you want.  Also note that Senders/Implementors of it will find the outermost keyword selector in a large selection, as when you have selected a bracketed expression or an entire line.  Finally note that the same cmd-m and cmd-n (and cmd-v for versions) work in the message pane of most browsers.Upper-case command keys (Hold down Cmd & Shift, or Ctrl key)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateE	Method strings containing itF	Insert 'ifFalse:'I	Inspect via Object ExplorerJ	Again manyK	Set styleL	Outdent (move selection one tab-stop left)N	References to itO	Open single-message browser (in selector lists)R	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'U	Convert linefeeds to carriage returns in selectionV	Paste author's initialsW	Selectors containing itX	Force selection to lowercaseY	Force selection to uppercaseZ	Capitalize all words in selection<return>		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)esc			Select current type-inshift-delete	Forward delete characterEnclose the selection in a kind of bracket.  Each is a toggle.Control-(	Enclose within ( and ), or remove enclosing ( and )[	Enclose within [ and ], or remove enclosing [ and ]{	Enclose within { and }, or remove enclosing { and }<	Enclose within < and >, or remove enclosing < and >'	Enclose within ' and ', or remove enclosing ' and '""	Enclose within "" and "", or remove enclosing "" and ""Note also that you can double-click just inside any of the above delimiters (or at the beginning or end of a line) to select the text enclosed.Text Emphasis...1	10 point font2	12 point font3	18 point font4	24 point font5	36 point font6	color, action-on-click, link to class comment, link to method, url	Brings up a menu.  To remove these properties, select	more than the active part and then use command-0.7	bold8	italic9	narrow (same as negative kern)0	plain text (resets all emphasis)-	underlined (toggles it)=	struck out (toggles it)Cmd-shift_ (aka shift -)	negative kern (letters 1 pixel closer)+		positive kern (letters 1 pixel larger spread)"! !!Utilities class methodsFor: 'flaps' stamp: 'sw 10/5/1999 21:12'!replaceBrowserInToolsFlap	self replacePartSatisfying: [:el |  (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented model isKindOf: Browser]]]inGlobalFlapSatisfying: [:f1 | f1 wording = 'Tools'] with:  ((Browser new openAsMorphEditing: nil) applyModelExtent setLabel: 'System Browser').! !StringHolder removeSelector: #changeCategory!StringHolder removeSelector: #noteContentsChanged!StringHolder removeSelector: #annotationRequests!StringHolder removeSelector: #methodCategoryChanged!StringHolder removeSelector: #showDiffs:!StringHolder removeSelector: #annotation!CodeHolder removeSelector: #contents:!Browser removeSelector: #buttonRowForBrowser!Debugger removeSelector: #buttonRowForDebugger!FileList removeSelector: #buttonRowForFileBrowser!"Postscript:"StringHolder organization removeEmptyCategories.Utilities replaceBrowserInToolsFlap.!