'From Squeak2.9alpha of 17 July 2000 [latest update: #3138] on 7 December 2000 at 1:46:56 pm'!"Change Set:		moreScoreStuffDate:			7 December 2000Author:			Bob ArningMaking the PianoRollScoreMorph usable for recorded sounds as well.- added 'Morph' button to RecordingControlsMorph that provides a SoundEventMorph which can be dropped on the PRSM."!RectangleMorph subclass: #AbstractMediaEventMorph	instanceVariableNames: 'startTimeInScore endTimeInScore '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!AbstractMediaEventMorph commentStamp: '<historical>' prior: 0!An abstract representation of media events to be placed in a PianoRollScoreMorph (or others as they are developed)!AbstractMediaEventMorph subclass: #SoundEventMorph	instanceVariableNames: 'sound '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!SoundMorph commentStamp: '<historical>' prior: 0!Note: as of December 2000, this does not work. SoundMorph>>buildImage requires the sound to implement #volumeEnvelopeScaledTo: and as yet, no one does.!AbstractMediaEventMorph subclass: #ZASMCameraMarkMorph	instanceVariableNames: 'startTimeInPianoRoll '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!AbstractMediaEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 11:01'!addMorphsTo: morphList pianoRoll: pianoRoll eventTime: t betweenTime: leftTime and: rightTime	"subclasses should decide if they should be visible on the score given the current time values"! !!AbstractMediaEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 11:02'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	"subclasses should recognize that their time has come"! !!AbstractMediaEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 12:58'!endTime	^endTimeInScore ifNil: [startTimeInScore + 100]! !!AbstractMediaEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 11:37'!initialize	super initialize.	color _ Color paleYellow.	self borderColor: Color black.	self borderWidth: 1.	self layoutPolicy: TableLayout new.	self listDirection: #leftToRight.	self wrapCentering: #topLeft.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self layoutInset: 2.	self rubberBandCells: true. "default"! !!AbstractMediaEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 12:57'!justDroppedInto: newOwner event: anEvent	(newOwner isKindOf: PianoRollScoreMorph) ifTrue: [		self justDroppedIntoPianoRoll: newOwner event: anEvent	].	super justDroppedInto: newOwner event: anEvent! !!AbstractMediaEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 11:51'!justDroppedIntoPianoRoll: newOwner event: evt		startTimeInScore _ newOwner timeForX: self left.	"self endTime > newOwner scorePlayer durationInTicks ifTrue:		[newOwner scorePlayer updateDuration]"! !!AbstractMediaEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 11:02'!pauseFrom: scorePlayer	"subclasses should take five"! !!AbstractMediaEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 11:03'!resetFrom: scorePlayer	"subclasses should revert to their initial state"! !!AbstractMediaEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 11:03'!resumeFrom: scorePlayer	"subclasses should continue from their current position"! !!RecordingControlsMorph methodsFor: 'initialization' stamp: 'RAA 12/7/2000 11:30'!addButtonRows	| r |	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Morph' action: #makeSoundMorph).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Tile' action: #makeTile).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Trim' action: #trim).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Show' action: #show).	self addMorphBack: r.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Record' action: #record).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Stop' action: #stop).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Play' action: #playback).	r addMorphBack: self makeStatusLight.	self addMorphBack: r.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'RAA 12/7/2000 11:37'!makeSoundMorph	| m |	recorder pause.	m _ SoundEventMorph new sound: recorder recordedSound.	self world firstHand attachMorph: m.! !!SoundEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 12:36'!addMorphsTo: morphList pianoRoll: pianoRoll eventTime: t betweenTime: leftTime and: rightTime	| startX lengthInTicks endX |	startTimeInScore > rightTime ifTrue: [^ self].  	lengthInTicks _ pianoRoll scorePlayer ticksForMSecs: sound duration * 1000.0.	startTimeInScore + lengthInTicks < leftTime ifTrue: [^ self].	startX _ pianoRoll xForTime: startTimeInScore.	endX _ pianoRoll xForTime: startTimeInScore + lengthInTicks.	morphList add: 		(self left: startX; width: endX - startX).! !!SoundEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 12:29'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	"hack... since we are called from within the SoundPlayer loop, the Semaphore will	block attempts to play directly from here"	WorldState addDeferredUIMessage: [sound play].! !!SoundEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 12:59'!initialize	super initialize.	self height: 10.	color _ Color lightGreen.! !!SoundEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 12:41'!justDroppedIntoPianoRoll: newOwner event: evt		| startX lengthInTicks endX |	startTimeInScore _ newOwner timeForX: self left.	lengthInTicks _ newOwner scorePlayer ticksForMSecs: sound duration * 1000.0.	endTimeInScore _ startTimeInScore + lengthInTicks.	endTimeInScore > newOwner scorePlayer durationInTicks ifTrue:		[newOwner scorePlayer updateDuration].	startX _ newOwner xForTime: startTimeInScore.	endX _ newOwner xForTime: endTimeInScore.	self width: endX - startX.! !!SoundEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 13:01'!sound: aSound	sound _ aSound.	self setBalloonText: 'a sound of duration ',(sound duration roundTo: 0.1) printString,' seconds'.! !!ZASMCameraMarkMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 11:47'!addMorphsTo: morphList pianoRoll: pianoRoll eventTime: t betweenTime: leftTime and: rightTime	| startX |	startTimeInScore > rightTime ifTrue: [^ self].  	startTimeInScore < leftTime ifTrue: [^ self].	startX _ pianoRoll xForTime: startTimeInScore.	morphList add: 		(self align: self bottomLeft			with: startX @ self bottom).! !!ZASMCameraMarkMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 11:37'!initialize	super initialize.! !ZASMCameraMarkMorph removeSelector: #justDroppedIntoPianoRoll:event:!AbstractMediaEventMorph subclass: #ZASMCameraMarkMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!