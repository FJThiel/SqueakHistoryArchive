'From Squeak2.7alpha of 24 December 1999 [latest update: #1726] on 26 December 1999 at 12:31:30 am'!"Change Set:		RecentSlangChangesDate:			26 December 1999Author:			Andrew C. GreenbergThis change file synthesizes a number recent changes made to the Slang code generators.  This gathers together the results of changesets previously posted on Squeak-L: 		TestInterpreterPlugin3.1.cs	TestInterpreterPlugin4.1.cs	TestInterpreterPlugin5.1.cs	CCodeGenerator.1.cs	CCodeGenerator2.4.cs	TestCodeGenerator.1.csSummary of Changes to CCodeGenerator:*	improves CCodeGenerator error handling when generator is unable to open output code fileImproves compilation of #whileTrue, #whileFalse, #whileTrue: and #whileFalse: builtins.  *	CCodeGenerator (and hence, the named primitive compilers) now correctly generate loops of the following forms, as appropriate:	SMALLTALK	EXEMPLAR				GENERATED CODE	[cond] whileTrue: [stmtList].			while(cond) do {stmtList}	[cond] whileFalse: [stmtList].			while(!!!!(cond)) do {stmtList}	[stmtList. cond] whileTrue.			do {stmtList} while(cond)	[stmtList. cond] whileTrue: []	[stmtList. cond] whileFalse.			do {stmtList} while(!!!!(cond))	[stmtList. cond] whileFalse: []	[stmtListA. cond]					while(1) {stmtListA; if(!!!!(cond)) break; stmtListB}		 whileTrue: [stmtListB]	[stmtListA. cond]					while(1) {stmtListA; if(cond) break; stmtListB}		 whileFalse: [stmtListB]Summary of Changes to the Specification Slang Compiler (TestCCodeGenerator and TestInterpreterPlugin)*	implemented a new feature: 	foo: a and: b with: c		self	primitive: #foo			parameters: #(Array Oop SmallInteger)			receiver: #Oop.		self suppressFailureGuards: true.		. . .used as a pragma for specification primitives now suppresses automatic generation of checks for and returns on primitive failure that will otherwise be generated automatically: (i) after the specification prolog and (ii) before return postlogs.  This is not to be used lightly, since misuse can lead to crashing code on primitive failure.*	Fixes a bug where primitives without specifications ended with an uncompilable 'return self'*	reorganizes, recomments and refactors TestCodeGenerator and TestInterpreterPlugin somewhat to improve clarity, reusability and performance.*	started building testbed for named specifications with type coercion specifications*	fixed crashing bugs executing code generated by tranlation of '^ expr' when expr failed*	eliminated some spurious Transcript messages during code generation*	changed demonstration code to reflect current specification API, and fixed crashing bug in one example.*	Corrects a bug where the code generator generated uncompilable characters and incorrect code for the expression	'value asOop: Boolean'"!TestInterpreterPlugin subclass: #TIPTestPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-TestPlugins'!TMethod subclass: #TestTMethod	instanceVariableNames: 'isPrimitive suppressingFailureGuards fullSelector fullArgs parmSpecs rcvrSpec '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-TestPlugins'!!Object methodsFor: 'translation support' stamp: 'acg 12/18/1999 11:31'!suppressFailureGuards: failureGuardFlag	"For translation only; noop when running in Smalltalk."! !!CCodeGenerator methodsFor: 'public' stamp: 'acg 12/18/1999 09:32'!storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: assertionFlag	"Store C code for this code base on the given file."	| stream |	stream _ CrLfFileStream newFileNamed: fileName.	stream ifNil: [Error signal: 'Could not open C code file: ', fileName].	self emitCCodeOn: stream doInlining: inlineFlag doAssertions: assertionFlag.	stream close! !!CCodeGenerator methodsFor: 'C translation' stamp: 'acg 12/22/1999 01:40'!generateDoWhileFalse: msgNode on: aStream indent: level	"Generate do {stmtList} while(!!(cond))"	| stmts testStmt |	stmts _ msgNode receiver statements asOrderedCollection.	testStmt _ stmts removeLast.	msgNode receiver setStatements: stmts.	aStream nextPutAll: 'do {'; cr.	msgNode receiver emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} while(!!('.	testStmt emitCCodeOn: aStream level: 0 generator: self.	aStream nextPutAll: '))'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'acg 12/22/1999 01:39'!generateDoWhileTrue: msgNode on: aStream indent: level	"Generate do {stmtList} while(cond)"	| stmts testStmt |	stmts _ msgNode receiver statements asOrderedCollection.	testStmt _ stmts removeLast.	msgNode receiver setStatements: stmts.	aStream nextPutAll: 'do {'; cr.	msgNode receiver emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} while('.	testStmt emitCCodeOn: aStream level: 0 generator: self.	aStream nextPutAll: ')'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'acg 12/22/1999 01:41'!generateWhileFalse: msgNode on: aStream indent: level	"Generate C code for a loop in one of the following formats, as appropriate:		while(!!(cond)) { stmtList }		do {stmtList} while(!!(cond))		while(1) {stmtListA; if (cond) break; stmtListB}"	msgNode receiver statements size <= 1		ifTrue: [^self generateWhileFalseLoop: msgNode on: aStream indent: level].	msgNode args first isNilStmtListNode		ifTrue: [^self generateDoWhileFalse: msgNode on: aStream indent: level].	^self generateWhileForeverBreakTrueLoop: msgNode on: aStream indent: level! !!CCodeGenerator methodsFor: 'C translation' stamp: 'acg 12/22/1999 01:41'!generateWhileFalseLoop: msgNode on: aStream indent: level	"Generate while(!!(cond)) {stmtList}."	aStream nextPutAll: 'while (!!('.	self emitCTestBlock: msgNode receiver on: aStream.	aStream nextPutAll: ')) {'; cr.	msgNode args first isNilStmtListNode ifFalse:		[msgNode args first emitCCodeOn: aStream level: level + 1 generator: self].	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'acg 12/22/1999 01:40'!generateWhileForeverBreakFalseLoop: msgNode on: aStream indent: level	"Generate while(1) {stmtListA; if(!!(cond)) break; stmtListB}."	| stmts testStmt |	stmts _ msgNode receiver statements asOrderedCollection.	testStmt _ stmts removeLast.	msgNode receiver setStatements: stmts.	level - 1 timesRepeat: [ aStream tab ].	aStream nextPutAll: 'while (1) {'; cr.	msgNode receiver emitCCodeOn: aStream level: level + 1 generator: self.	(level + 1) timesRepeat: [ aStream tab ].	aStream nextPutAll: 'if (!!('.	testStmt emitCCodeOn: aStream level: 0 generator: self.	aStream nextPutAll: ')) break;'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'acg 12/22/1999 01:38'!generateWhileForeverBreakTrueLoop: msgNode on: aStream indent: level	"Generate while(1) {stmtListA; if(cond) break; stmtListB}."	| stmts testStmt |	stmts _ msgNode receiver statements asOrderedCollection.	testStmt _ stmts removeLast.	msgNode receiver setStatements: stmts.	level - 1 timesRepeat: [ aStream tab ].	aStream nextPutAll: 'while (1) {'; cr.	msgNode receiver emitCCodeOn: aStream level: level + 1 generator: self.	(level + 1) timesRepeat: [ aStream tab ].	aStream nextPutAll: 'if ('.	testStmt emitCCodeOn: aStream level: 0 generator: self.	aStream nextPutAll: ') break;'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'acg 12/22/1999 01:41'!generateWhileTrue: msgNode on: aStream indent: level	"Generate C code for a loop in one of the following formats, as appropriate:		while(cond) { stmtList }		do {stmtList} while(cond)		while(1) {stmtListA; if (!!(cond)) break; stmtListB}"	msgNode receiver statements size <= 1		ifTrue: [^self generateWhileTrueLoop: msgNode on: aStream indent: level].	msgNode args first isNilStmtListNode		ifTrue: [^self generateDoWhileTrue: msgNode on: aStream indent: level].	^self generateWhileForeverBreakFalseLoop: msgNode on: aStream indent: level! !!CCodeGenerator methodsFor: 'C translation' stamp: 'acg 12/22/1999 01:38'!generateWhileTrueLoop: msgNode on: aStream indent: level	"Generate while(cond) {stmtList}."	aStream nextPutAll: 'while ('.	self emitCTestBlock: msgNode receiver on: aStream.	aStream nextPutAll: ') {'; cr.	msgNode args first isNilStmtListNode ifFalse:		[msgNode args first emitCCodeOn: aStream level: level + 1 generator: self].	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!FlippyArray2 commentStamp: '<historical>' prior: 0!Demonstrator class using FlippyArrayPlugin2!!Foo2 commentStamp: '<historical>' prior: 0!Demonstrator class using FooPlugin2!!Oop commentStamp: '<historical>' prior: 0!Cooercion specification for Identity coercions:	x asOop: Oop == x	y asValue: Oop == y!!TParseNode methodsFor: 'as yet unclassified' stamp: 'acg 12/17/1999 07:21'!nameOrValue	self error: 'object is neither variable nor constant'! !!TConstantNode methodsFor: 'as yet unclassified' stamp: 'acg 12/17/1999 07:19'!nameOrValue	^value! !!TStmtListNode methodsFor: 'as yet unclassified' stamp: 'acg 12/21/1999 02:25'!isNilStmtListNode	|stmt|	statements size = 1 ifFalse: [^false].	stmt _ statements at: 1.	^ stmt isVariable and: [stmt name = 'nil']! !!TVariableNode methodsFor: 'as yet unclassified' stamp: 'acg 12/17/1999 07:18'!nameOrValue	^name! !!TestCodeGenerator commentStamp: '<historical>' prior: 0!Subclass of CCodeGenerator, used in connection with TestInterpreterPlugin to generate named primitives with type coercion specifications!!TestCodeGenerator reorganize!('building/generating' addClass: codeStringForPrimitives:)('transforming' var:as:)('linking' emitLoad:asBooleanValueFrom:on: emitLoad:asCharPtrFrom:on: emitLoad:asFloatPtrFrom:on: emitLoad:asFloatValueFrom:on: emitLoad:asIntPtrFrom:on: emitLoad:asIntegerValueFrom:on: emitLoad:asKindOf:from:on: emitLoad:asMemberOf:from:on: emitLoad:asNakedOopFrom:on: emitLoad:asNonIntegerValueFrom:on: emitLoad:asUnsignedValueFrom:on:)('coercing' ccgLoad:expr:asBooleanValueFrom: ccgLoad:expr:asCharPtrFrom: ccgLoad:expr:asCharPtrFrom:andThen: ccgLoad:expr:asFloatValueFrom: ccgLoad:expr:asIntPtrFrom: ccgLoad:expr:asIntPtrFrom:andThen: ccgLoad:expr:asIntegerValueFrom: ccgLoad:expr:asKindOf:from: ccgLoad:expr:asMemberOf:from: ccgLoad:expr:asNamedPtr:from: ccgLoad:expr:asNamedPtr:from:andThen: ccgLoad:expr:asNonIntegerValueFrom: ccgLoad:expr:asRawOopFrom: ccgLoad:expr:asUnsignedPtrFrom:andThen: ccgLoad:expr:asUnsignedValueFrom: ccgLoad:expr:asWBCharPtrFrom: ccgLoad:expr:asWBFloatPtrFrom: ccgLoad:expr:asWBIntPtrFrom: ccgSetBlock: ccgTVarBlock: ccgValBlock:)('asOop:/asValue:' generateCoerceToBooleanObjectFrom:on: generateCoerceToBooleanValueFrom:on: generateCoerceToFloatObjectFrom:on: generateCoerceToFloatValueFrom:on: generateCoerceToObjectFromPtr:on: generateCoerceToPtr:fromObject:on: generateCoerceToSmallIntegerObjectFrom:on: generateCoerceToSmallIntegerValueFrom:on: generateCoerceToUnsignedObjectFrom:on: generateCoerceToUnsignedValueFrom:on:)('translating builtins' generateAsBooleanObj:on:indent: generateAsCBoolean:on:indent: generateAsCDouble:on:indent: generateAsCInt:on:indent: generateAsCUnsigned:on:indent: generateAsCharPtr:on:indent: generateAsFloatObj:on:indent: generateAsIfVar:on:indent: generateAsIfVarAsValue:on:indent: generateAsIfVarPut:on:indent: generateAsIntPtr:on:indent: generateAsOop:on:indent: generateAsPositiveIntegerObj:on:indent: generateAsSmallIntegerObj:on:indent: generateAsValue:on:indent: generateCPtrAsOop:on:indent: generateClass:on:indent: generateField:on:indent: generateFieldPut:on:indent: generateFromStack:on:indent: generateIsBytes:on:indent: generateIsFloat:on:indent: generateIsIndexable:on:indent: generateIsInteger:on:indent: generateIsIntegerOop:on:indent: generateIsIntegerValue:on:indent: generateIsKindOf:on:indent: generateIsMemberOf:on:indent: generateIsPointers:on:indent: generateIsWords:on:indent: generateIsWordsOrBytes:on:indent: generateNext:on:indent: generateStAt:on:indent: generateStAtPut:on:indent: generateStSize:on:indent: initializeCTranslationDictionary)('as yet unclassified')!!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:32'!ccgLoad: aBlock expr: aString asBooleanValueFrom: anInteger	"Answer codestring for boolean coercion (with validating side-effect) of object, as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy booleanValueOf:';		crtab: 2;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	')'])! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:29'!ccgLoad: aBlock expr: aString asCharPtrFrom: anInteger	"Answer codestring for character pointer to first indexable field of object (without validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''char *'''])! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:29'!ccgLoad: aBlock expr: aString asCharPtrFrom: anInteger andThen: valBlock	"Answer codestring for character pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to ccgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''char *''']))	 ! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:29'!ccgLoad: aBlock expr: aString asFloatValueFrom: anInteger	"Answer codestring for double precision coercion (with validating side-effect) of oop, as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy stackFloatValue: ';		nextPutAll: anInteger asString])! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:29'!ccgLoad: aBlock expr: aString asIntPtrFrom: anInteger	"Answer codestring for integer pointer to first indexable field of object (without validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''int *'''])! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:29'!ccgLoad: aBlock expr: aString asIntPtrFrom: anInteger andThen: valBlock	"Answer codestring for integer pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to ccgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''int *''']))! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:29'!ccgLoad: aBlock expr: aString asIntegerValueFrom: anInteger	"Answer codestring for integer coercion (with validating side-effect) of oop, as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy stackIntegerValue: ';		nextPutAll: anInteger asString])! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:29'!ccgLoad: aBlock expr: exprString asNamedPtr: recordString from: anInteger	"Answer codestring for integer pointer to first indexable field of object (without validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''';		nextPutAll: recordString;		nextPutAll: ' *'''])! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:29'!ccgLoad: aBlock expr: exprString asNamedPtr: recordString from: anInteger andThen: valBlock	"Answer codestring for integer pointer to first indexable field of object (without validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''';		nextPutAll: recordString;		nextPutAll: ' *''']))! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:29'!ccgLoad: aBlock expr: aString asNonIntegerValueFrom: anInteger	"Answer codestring for oop (with validating side effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy stackObjectValue: ';		nextPutAll: anInteger asString])! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:32'!ccgLoad: aBlock expr: aString asRawOopFrom: anInteger	"Answer a string for a Slang expression that will load an oop (without validation) from stack index anInteger.  Apply aBlock, a BlockContext instance that when passed an expression, will return a string assigning the expression to the desired identifier, to the string before answering.  aString is a Slang expression that refers to the stack value, once it has been loaded."	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy stackValue: ';		nextPutAll: anInteger asString])! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:31'!ccgLoad: aBlock expr: aString asUnsignedPtrFrom: anInteger andThen: valBlock	"Answer a codestring for integer pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to ccgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''unsigned *''']))! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:31'!ccgLoad: aBlock expr: aString asUnsignedValueFrom: anInteger	"Answer a codestring for positive integer coercion (with validating side-effect) of oop, as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy positive32BitValueOf:';		crtab: 2;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	')'])! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:31'!ccgLoad: aBlock expr: aString asWBCharPtrFrom: anInteger	"Answer codestring for char pointer to first indexable field of object (with validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''char *'''])! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:31'!ccgLoad: aBlock expr: aString asWBFloatPtrFrom: anInteger	"Answer codestring for single-precision float pointer to first indexable field of object (with validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''float *'''])! !!TestCodeGenerator methodsFor: 'coercing' stamp: 'acg 12/17/1999 07:31'!ccgLoad: aBlock expr: aString asWBIntPtrFrom: anInteger	"Answer codestring for integer pointer to first indexable field of object (with validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''int *'''])! !!TestCodeGenerator methodsFor: 'asOop:/asValue:' stamp: 'acg 12/25/1999 10:00'!generateCoerceToBooleanObjectFrom: aNode on: aStream	aStream nextPutAll: '('.	self emitCExpression: aNode on: aStream.	aStream nextPutAll: '? interpreterProxy->trueObject(): interpreterProxy->falseObject())'! !!TestCodeGenerator methodsFor: 'translating builtins' stamp: 'acg 12/17/1999 07:23'!generateAsIfVarAsValue: aNode on: aStream indent: anInteger	| cName fName class index fetchNode |	cName _ String streamContents: 		[:scStr | self emitCExpression: aNode args first on: scStr].	class _ Smalltalk 		at: (cName asSymbol) 		ifAbsent: [nil].	(class isNil not and: [class isBehavior]) ifFalse: 		[^self error: 'first arg must identify class'].	fName _ aNode args second value.	index _ class instVarNames		indexOf: fName		ifAbsent: [^self error: 'second arg must be instVar'].	fetchNode _ TSendNode new		setSelector: #fetchPointer:ofObject:		receiver: (TVariableNode new setName: 'interpreterProxy')		arguments: (Array			with: (TConstantNode new setValue: index - 1)			with: aNode receiver).	cName _ aNode args third nameOrValue.	class _ Smalltalk 		at: (cName asSymbol) 		ifAbsent: [nil].	(class isNil not and: [class isBehavior]) ifFalse: 		[^self error: 'third arg must identify class'].	class ccg: self generateCoerceToValueFrom: fetchNode on: aStream! !!TestCodeGenerator methodsFor: 'translating builtins' stamp: 'acg 12/17/1999 07:23'!generateAsOop: aNode on: aStream indent: anInteger	| cName class |	cName _ aNode args first nameOrValue.	class _ Smalltalk 		at: (cName asSymbol) 		ifAbsent: [nil].	(class isNil not and: [class isBehavior]) ifFalse: 		[^self error: 'first arg must identify class'].	class ccg: self generateCoerceToOopFrom: aNode receiver on: aStream! !!TestCodeGenerator methodsFor: 'translating builtins' stamp: 'acg 12/17/1999 07:22'!generateAsValue: aNode on: aStream indent: anInteger	| cName class |	cName _ aNode args first nameOrValue.	class _ Smalltalk 		at: (cName asSymbol) 		ifAbsent: [nil].	(class isNil not and: [class isBehavior]) ifFalse: 		[^self error: 'first arg must identify class'].	class ccg: self generateCoerceToValueFrom: aNode receiver on: aStream! !!TestInterpreterPlugin commentStamp: '<historical>' prior: 0!Subclass of InterpreterPlugin, used in connection with TestCodeGenerator for named primitives with type coercion specifications!!FlippyArrayPlugin2 commentStamp: '<historical>' prior: 0!"TestInterpreterPlugin Example: primitives for reversing an array"FlippyArrayPlugin2 translateSmalltalk garbageCollect!!FooPlugin2 commentStamp: '<historical>' prior: 0!"TestInterpreter Example: Squeak Swiki named primitive documentation primitives"FooPlugin2 translate!!FooPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 12/18/1999 09:59'!primFooIntegerIdentity: x	self 		primitive: 	'primFooIntegerIdentity'		parameters: #(SmallInteger)		receiver: 	#Oop.	^ x asOop: SmallInteger! !!FooPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 12/18/1999 10:00'!primFooIntegerSeventeen	self primitive: 'primFooIntegerSeventeen'		parameters: #()		receiver: #Oop.	^ 17 asOop: SmallInteger! !!FooPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 12/18/1999 10:00'!primFooIntegerSumAnd: x with: y	self 		primitive: 	'primFooIntegerSumAnd'		parameters: #(SmallInteger SmallInteger)		receiver: 	#Oop.	^ (x + y) asOop: SmallInteger! !!FooPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 12/18/1999 10:00'!primFooIntegerSumWith: x	|rcvr myInteger|	rcvr _ self 		primitive: 	'primFooIntegerSumWith'		parameters: #(SmallInteger)		receiver: 	#Foo2.	myInteger _ (rcvr asIf: Foo2 var: 'myInteger') asValue: SmallInteger.	^ (x + myInteger) asOop: SmallInteger! !!FooPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 12/18/1999 11:28'!primNGFooIntegerIdentity: x	self 		primitive: 	'primNGFooIntegerIdentity'		parameters: #(SmallInteger)		receiver: 	#Oop.	self suppressFailureGuards: true.	^ x asOop: SmallInteger! !!FooPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 12/18/1999 11:28'!primNGFooIntegerSeventeen	self primitive: 'primNGFooIntegerSeventeen'		parameters: #()		receiver: #Oop.	self suppressFailureGuards: true.	^ 17 asOop: SmallInteger! !!FooPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 12/18/1999 11:28'!primNGFooIntegerSumAnd: x with: y	self 		primitive: 	'primNGFooIntegerSumAnd'		parameters: #(SmallInteger SmallInteger)		receiver: 	#Oop.	self suppressFailureGuards: true.	^ (x + y) asOop: SmallInteger! !!FooPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 12/18/1999 11:28'!primNGFooIntegerSumWith: x	|rcvr myInteger|	rcvr _ self 		primitive: 	'primNGFooIntegerSumWith'		parameters: #(SmallInteger)		receiver: 	#Foo2.	self suppressFailureGuards: true.	myInteger _ (rcvr asIf: Foo2 var: 'myInteger') asValue: SmallInteger.	^ (x + myInteger) asOop: SmallInteger! !!TIPTestPlugin commentStamp: '<historical>' prior: 0!"Testbed for TestInterpreterPlugin, TestCodeGenerator and TestTMethod"TIPTestPlugin translate!!TIPTestPlugin reorganize!('testing returns' primNilReturn primTestConstantReturn primTestExpressionReturn primTestFailureReturn primTestNonSpecificationReturns primTestReturnsWithGuards primTestReturnsWithoutGuards primTestSelfReturn primTestVariableReturn)('testing nonprimitives' collateralProcedure)('testing nonspecifications' primTestNonSpecificationCalls)!!TIPTestPlugin methodsFor: 'testing returns' stamp: 'acg 12/15/1999 07:27'!primNilReturn	self primitive: 'primNilReturn'		parameters: #()		receiver: #Oop.	interpreterProxy failed ifTrue: [^nil].	^ nil! !!TIPTestPlugin methodsFor: 'testing returns' stamp: 'acg 12/15/1999 07:17'!primTestConstantReturn	self primitive: 'primTestConstantReturn'		parameters: #()		receiver: #Oop.	1 == 1 ifTrue: [^ 1]. "Smalltalk Oop for zero"	^1 "Smalltalk Oop for zero"! !!TIPTestPlugin methodsFor: 'testing returns' stamp: 'acg 12/18/1999 11:08'!primTestExpressionReturn	self primitive: 'primTestExpressionReturn'		parameters: #()		receiver: #Oop.	1 == 1 ifTrue: [^17 asOop: SmallInteger].	^ 17 asOop: SmallInteger! !!TIPTestPlugin methodsFor: 'testing returns' stamp: 'acg 12/18/1999 11:08'!primTestFailureReturn	self primitive: 'primTestFailureReturn'		parameters: #()		receiver: #Oop.	1 == 1 ifTrue: [^interpreterProxy primitiveFail].	^ 17 asOop: SmallInteger! !!TIPTestPlugin methodsFor: 'testing returns' stamp: 'acg 12/15/1999 07:21'!primTestNonSpecificationReturns	| x y |	self export: true.	x _ interpreterProxy stackIntegerValue: 0.	y _ interpreterProxy stackIntegerValue: 1.	interpreterProxy pop: 3 thenPush:		(interpreterProxy integerObjectOf: (x + y)).! !!TIPTestPlugin methodsFor: 'testing returns' stamp: 'acg 12/18/1999 11:12'!primTestReturnsWithGuards	| x |	self primitive: 'primTestReturnsWithGuards'		parameters: #()		receiver: #Oop.		1 == 1 ifTrue: [^nil].	2 == 2 ifTrue: [^123].	3 == 3 ifTrue: [^123 asOop: SmallInteger].	4 == 4 ifTrue: [^self].	x _ 123 asOop: SmallInteger.	5 == 5 ifTrue: [^x].	^ x! !!TIPTestPlugin methodsFor: 'testing returns' stamp: 'acg 12/18/1999 11:12'!primTestReturnsWithoutGuards	| x |	self primitive: 'primTestReturnsWithoutGuards'		parameters: #()		receiver: #Oop.	self suppressFailureGuards: true.		1 == 1 ifTrue: [^nil].	2 == 2 ifTrue: [^123].	3 == 3 ifTrue: [^123 asOop: SmallInteger].	4 == 4 ifTrue: [^self].	x _ 123 asOop: SmallInteger.	5 == 5 ifTrue: [^x].	^ x! !!TIPTestPlugin methodsFor: 'testing returns' stamp: 'acg 12/15/1999 07:22'!primTestSelfReturn	self primitive: 'primTestSelfReturn'		parameters: #()		receiver: #Oop.	1 == 1 ifTrue: [^self].	^ self! !!TIPTestPlugin methodsFor: 'testing returns' stamp: 'acg 12/18/1999 11:08'!primTestVariableReturn	| x |	self primitive: 'primTestVariableReturn'		parameters: #()		receiver: #Oop.	x _ 17 asOop: SmallInteger.	1 == 1 ifTrue: [^x].	^ x! !!TIPTestPlugin methodsFor: 'testing nonprimitives' stamp: 'acg 12/15/1999 08:08'!collateralProcedure	1.	2.	3.	^4! !!TIPTestPlugin methodsFor: 'testing nonspecifications' stamp: 'acg 12/15/1999 08:09'!primTestNonSpecificationCalls	self primitive: 'primTestNonSpecificationCalls'		parameters: #()		receiver: #Oop.	^(self collateralProcedure) asOop: #SmallInteger! !!TestInterpreterPlugin class reorganize!('translation' translate:all:doInlining: translate:doInlining:)('instance creation' doPrimitive:withArguments:)('private' generateVMProxyOn:)!!TestTMethod commentStamp: '<historical>' prior: 0!Variation of TMethod node of the Smalltalk C Code Generator, used in conjunction with TestCodeGenerator and TestInterpreterPlugin to generate named primitives with type coercion specifications.!!TestTMethod reorganize!('initializing' fromContext:primitive:parameters:receiver: setSelector:args:locals:block:primitive:)('accessing' args: parmSpecs rcvrSpec)('transforming' extractSuppressFailureGuardDirective fixUpReturnOneStmt:on: fixUpReturns recordDeclarations removeFinalSelfReturn replaceSizeMessages)('generating C code' emitCHeaderOn:generator:)('specifying primitives' extractPrimitiveDirectives handlePrimitiveDirective:on: isPrimitiveDirectiveSend: namedPrimitiveProlog primitive:parameters:receiver: primitiveDirectiveWasHandled:on: simulatePrologInContext:)('private' assign:expression: checkSuccessExpr generateFailureGuardOn: nullReturnExpr oldReplaceSizeMessages oopVariable: pop:thenReturnExpr: popExpr: statementsFor:varName:)('named primitives')!!TestTMethod methodsFor: 'initializing' stamp: 'acg 12/18/1999 10:40'!setSelector: sel args: argList locals: localList block: aBlockNode primitive: aNumber	"Initialize this method using the given information."	selector _ sel.	returnType _ 'int'. 	 "assume return type is int for now"	args _ argList asOrderedCollection collect: [:arg | arg key].	locals _ localList asOrderedCollection collect: [:arg | arg key].	declarations _ Dictionary new.	primitive _ aNumber.	parseTree _ aBlockNode asTranslatorNode.	labels _ OrderedCollection new.	complete _ false.  "set to true when all possible inlining has been done"	isPrimitive _ false.  "set to true only if you find a primtive direction."	export _ self extractExportDirective.	suppressingFailureGuards _ self extractSuppressFailureGuardDirective.	self recordDeclarations.	self extractPrimitiveDirectives.! !!TestTMethod methodsFor: 'transforming' stamp: 'acg 12/18/1999 10:39'!extractSuppressFailureGuardDirective	"Scan the top-level statements for a pragma directive of the form:		self suppressFailureGuards: <boolean>	 and remove the directive from the method body. Answer the argument of the directive or false if there is no #supressFailureGuards: directive."	| result newStatements |	result _ false.	newStatements _ OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		(stmt isSend and: [stmt selector = #suppressFailureGuards:]) ifTrue: [			result _ stmt args first name = 'true'.		] ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.	^ result! !!TestTMethod methodsFor: 'transforming' stamp: 'acg 12/18/1999 11:17'!fixUpReturnOneStmt: stmt on: sStream	stmt isReturn ifFalse: [^sStream nextPut: stmt].	(stmt expression isSend and: ['primitiveFail' = stmt expression selector]) ifTrue: 		["failure return"		 sStream nextPut: stmt expression.		 sStream nextPut: self nullReturnExpr.		 ^nil].	(stmt expression isVariable and: ['nil' = stmt expression name]) ifTrue: 		["^ nil -- this is never right unless automatically generated"		 sStream nextPut: stmt.		 ^nil].	(stmt expression isVariable and: ['self' = stmt expression name]) ifTrue: 		["^ self"		 self generateFailureGuardOn: sStream.		 sStream nextPut: (self popExpr: fullArgs size).		 sStream nextPut: self nullReturnExpr.		 ^nil].	(stmt expression isVariable | stmt expression isConstant | suppressingFailureGuards) ifTrue:		["^ variable or ^ constant or ^ expr without guardchecking"		 self generateFailureGuardOn: sStream.		 sStream nextPut: (self pop: fullArgs size + 1 thenReturnExpr: stmt expression).		 sStream nextPut: self nullReturnExpr.		 ^nil].	"^ expr with guardchecking"	sStream nextPut: (self assign: (self oopVariable: '_return_value') expression: stmt expression).	self generateFailureGuardOn: sStream.	sStream nextPut: (self pop: fullArgs size + 1 thenReturnExpr: (self oopVariable: '_return_value')).	sStream nextPut: self nullReturnExpr! !!TestTMethod methodsFor: 'specifying primitives' stamp: 'acg 12/15/1999 06:13'!extractPrimitiveDirectives	"Save selector in fullSelector and args in fullArgs.  Scan top-level statements for a directive of the form:		self				primitive: 	<string>or		self			primitive:	<string>			parameters: <list of class names>or		self			primitive:	<string>			parameters: <list of class names>			receiver: <class name>or an assignment of that expression to a local, and manipulate the state and parse tree accordingly."	parseTree setStatements: (Array streamContents:		[:sStream |			parseTree statements do:				[:stmt |				 (self primitiveDirectiveWasHandled: stmt on: sStream)					ifFalse: [sStream nextPut: stmt]]]).	isPrimitive 		ifTrue:			[export _ true.			 parseTree 				setStatements: self namedPrimitiveProlog, 								parseTree statements.			 self fixUpReturns.			 self replaceSizeMessages.			 ^true]		ifFalse: [self removeFinalSelfReturn].	^false! !!TestTMethod methodsFor: 'specifying primitives' stamp: 'acg 12/18/1999 11:21'!handlePrimitiveDirective: aStmt on: sStream	isPrimitive _ true.	fullArgs _ args.	locals addAll: args.	args _ OrderedCollection new.	fullArgs with: parmSpecs do:		[:argName :spec |			declarations				at: argName				put: (spec ccgDeclareCForVar: argName)].	aStmt isAssignment ifTrue:		[declarations			at: aStmt variable name			put: (rcvrSpec ccgDeclareCForVar: aStmt variable name).		 sStream nextPutAll: (self			statementsFor:				(rcvrSpec					ccg:		TestCodeGenerator new					prolog:  [:expr | aStmt variable name, ' _ ', expr]					expr: 	aStmt variable name					index: 	(fullArgs size))			varName: '')].	self generateFailureGuardOn: sStream.	^true.! !!TestTMethod methodsFor: 'specifying primitives' stamp: 'acg 12/15/1999 06:13'!namedPrimitiveProlog	| cg |	cg _ TestCodeGenerator new.	^Array streamContents: [:sStream |		1 to: fullArgs size do:			[:i |			 sStream nextPutAll: 				(self 					statementsFor: 						((parmSpecs at: i) 							ccg: 	cg							prolog:  [:expr | (fullArgs at: i), ' _ ', expr]							expr: (fullArgs at: i)							index: (fullArgs size - i))					varName: '')]]! !!TestTMethod methodsFor: 'private' stamp: 'acg 12/15/1999 06:31'!assign: variable expression: expression	^TAssignmentNode new		setVariable: variable		expression: expression! !!TestTMethod methodsFor: 'private' stamp: 'acg 12/18/1999 10:47'!generateFailureGuardOn: sStream	suppressingFailureGuards ifTrue: [^nil].	sStream nextPutAll: self checkSuccessExpr! !!TestTMethod methodsFor: 'private' stamp: 'acg 12/15/1999 05:50'!nullReturnExpr	^ TReturnNode new		setExpression: (TVariableNode new setName: 'null')! !!TestTMethod methodsFor: 'private' stamp: 'acg 12/15/1999 06:30'!oopVariable: aString	(locals includes: aString) ifFalse:		[locals add: aString.		 declarations			at: aString 			put: 'int ', aString].	^TVariableNode new setName: aString! !!TestTMethod methodsFor: 'private' stamp: 'acg 12/15/1999 05:55'!pop: anInteger thenReturnExpr: anExpression	^TSendNode new		setSelector: #pop:thenPush:		receiver: (TVariableNode new setName: 'interpreterProxy')		arguments: (Array 			with: (TConstantNode new 				setValue: anInteger)			with: anExpression)! !!TestTMethod methodsFor: 'private' stamp: 'acg 12/15/1999 05:45'!popExpr: anInteger	^ TSendNode new			 setSelector: #pop:			 receiver: (TVariableNode new setName: 'interpreterProxy')			 arguments: (Array 				with: (TConstantNode new 					setValue: anInteger))! !!TestTMethod methodsFor: 'private' stamp: 'acg 12/18/1999 09:56'!statementsFor: sourceText varName: varName	"Return the parse tree for the given expression. The result is the statements list of the method parsed from the given source text."	"Details: Various variables are declared as locals to avoid Undeclared warnings from the parser."	| s |	s _ WriteStream on: ''.	s nextPutAll: 'temp'; cr; cr; tab.	s nextPutAll: '| '.	(#('rcvr' 'stackPointer' 'successFlag' 'interpreterProxy') reject: [:each | locals includes: each]) do:		[:each | s nextPutAll: each; space ].	(locals reject: [:each | each first = $_]) do: [:each | s nextPutAll: each; space].	s nextPutAll: varName.	s nextPutAll: '|'; cr.	s nextPutAll: sourceText.	^ ((Compiler new parse: s contents in: Object notifying: nil)			asTestTMethodFromClass: Object) statements! !!Unsigned commentStamp: '<historical>' prior: 0!Coercion specification for 32-bit unsigned numbers.Note: "x asOop: Unsigned" can cause garbage collection when x is outside SmallInteger range.!CCodeGenerator removeSelector: #generateLoopFalse:on:indent:!CCodeGenerator removeSelector: #generateLoopTrue:on:indent:!TestCodeGenerator removeSelector: #nameOrValue:!TestTMethod removeSelector: #buildNamedPrimitiveProlog!