'From Squeak 2.3 of January 14, 1999 on 28 March 1999 at 9:14:14 pm'!"Change Set:		WithoutWithoutDate:			28 March 1999Author:			Dan IngallsThis changeset adds a check for compatible version number and correct byte order to the image segment save/load mechanism.This also renames the keyword, 'withOutPointers:', which can be read as 'withoutPointers:' to be 'outPointers:'.  Requested by Ted Kaehler."!!ImageSegment methodsFor: 'initialization' stamp: 'di 3/28/1999 13:49'!copyFromRoots: aRootArray 	| segmentWordArray outPointerArray segSize |	aRootArray ifNil: [self errorWrongState].	arrayOfRoots _ aRootArray.	segSize _ 50000.		["Guess a reasonable segment size"	segmentWordArray _ WordArray new: segSize.	outPointerArray _ Array new: segSize // 20.	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray _ outPointerArray _ nil.			segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.	state _ #activeCopy.! !!ImageSegment methodsFor: 'changing state' stamp: 'di 3/28/1999 13:47'!extractThenInstall	"For testing only"	| newRoots |	state = #activeCopy ifFalse: [self errorWrongState].	arrayOfRoots elementsForwardIdentityTo:		(arrayOfRoots collect: [:r | r rootStubInImageSegment: self]).	state _ #active.	newRoots _ self loadSegmentFrom: segment outPointers: outPointers.	state _ #inactive.	arrayOfRoots elementsForwardIdentityTo: newRoots.! !!ImageSegment methodsFor: 'changing state' stamp: 'di 3/28/1999 13:48'!install	"This operation retrieves the segment if necessary from file storage, installs it in memory, and replaces (using become:) all the root stubs with the reconstructed roots of the segment."	| newRoots |	state = #onFile ifTrue: [self readFromFile].	state = #onFileWithSymbols ifTrue: [self readFromFileWithSymbols].	state = #active ifFalse: [self errorWrongState].	newRoots _ self loadSegmentFrom: segment outPointers: outPointers.	state _ #inactive.	arrayOfRoots elementsForwardIdentityTo: newRoots.! !!ImageSegment methodsFor: 'changing state' stamp: 'di 3/28/1999 13:48'!segmentCopy	"This operation will install a copy of the segment in memory, and return a copy of the array of roots.  The effect is to perform a deep copy of the original structure.  Note that installation destroys the segment, so it must be copied before doing the operation."	state = #activeCopy ifFalse: [self errorWrongState].	^ self loadSegmentFrom: segment copy outPointers: outPointers! !!ImageSegment methodsFor: 'primitives' stamp: 'di 3/28/1999 13:47'!loadSegmentFrom: segmentWordArray outPointers: outPointerArray	"This primitive will install a binary image segment and return as its value the array of roots of the tree of objects represented.  Upon successful completion, the wordArray will have been transmuted into an object of zero length.  If this primitive should fail, it will have destroyed the contents of the segment wordArray."	<primitive: 99>	"successful completion returns the array of roots"	^ nil			"failure returns nil"! !!ImageSegment methodsFor: 'primitives' stamp: 'di 3/28/1999 13:49'!storeSegmentFor: rootsArray into: segmentWordArray outPointers: outPointerArray	"This primitive will store a binary image segment (in the same format as the Squeak image file) of the receiver and every object in its proper tree of subParts (ie, that is not refered to from anywhere else outside the tree).  Note: all elements of the reciever are treated as roots indetermining the extent of the tree.  All pointers from within the tree to objects outside the tree will be copied into the array of outpointers.  In their place in the image segment will be an oop equal to the offset in the outpointer array (the first would be 4). but with the high bit set."	"The primitive expects the array and wordArray to be more than adequately long.  In this case it returns normally, and truncates the two arrays to exactly the right size.  If either array is too small, the primitive will fail, but in no other case."	<primitive: 98>	"successful completion returns self"	^ nil			"failure returns nil"! !!ImageSegment methodsFor: 'testing' stamp: 'di 3/28/1999 21:06'!deepCopyTest: aRootArray	"ImageSegment new deepCopyTest: Morph withAllSubclasses asArray"	"Project allInstances do:		[:p | p == Project current ifFalse:			[Transcript cr; cr; nextPutAll: p name.			ImageSegment new deepCopyTest: (Array with: p)]]."	| t1 t2 copy |	t1 _ Time millisecondsToRun: [self copyFromRoots: aRootArray].	t2 _ Time millisecondsToRun: [copy _ self segmentCopy].	Transcript cr; print: segment size * 4; nextPutAll: ' bytes stored with ';		print: outPointers size; show: ' outpointers in '; print: t1; show: 'ms.'.	Transcript cr; nextPutAll: 'Reconstructed in '; print: t2; show: 'ms.'.	^ copy"Smalltalk allClasses do:	[:m | ImageSegment new deepCopyTest: (Array with: m with: m class)]"! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'di 3/28/1999 14:28'!startField	"Examine and possibly trace the next field of the object being traced. See comment in markAndTrace for explanation of tracer state variables."	| typeBits childType |	self inline: true.	child _ self longAt: field.	typeBits _ child bitAnd: TypeMask.	(typeBits bitAnd: 1) = 1 ifTrue: [		"field contains a SmallInteger; skip it"		field _ field - 4.		^ StartField	].	typeBits = 0 ifTrue: [		"normal oop, go down"		self longAt: field put: parentField.		parentField _ field.		^ StartObj	].	typeBits = 2 ifTrue: [		"reached the header; do we need to process the class word?"		(child bitAnd: CompactClassMask) ~= 0 ifTrue: [			"object's class is compact; we're done"			"restore the header type bits"			child _ child bitAnd: AllButTypeMask.			childType _ self rightType: child.			self longAt: field put: (child bitOr: childType).			^ Upward		] ifFalse: [			"object has a full class word; process that class"			child _ self longAt: (field - 4).  "class word"			child _ child bitAnd: AllButTypeMask.  "clear type bits"			self longAt: (field - 4) put: parentField.			parentField _ (field - 4) bitOr: 1.  "point at class word; mark as working on the class."			^ StartObj		].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'di 3/28/1999 14:27'!startObj	"Start tracing the object 'child' and answer the next action. The object may be anywhere in the middle of being swept itself. See comment in markAndTrace for explanation of tracer state variables."	| oop header lastFieldOffset |	self inline: true.	oop _ child.	oop < youngStart ifTrue: [		"old object; skip it"		 field _ oop.		^ Upward	].	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [		"unmarked; mark and trace"		"<-- Finalization support: Do not trace the object's indexed fields if it's a weak class -->"		(self isWeak: oop) ifTrue:[			"Set lastFieldOffset before the weak fields in the receiver"			lastFieldOffset := (self nonWeakFieldsOf: oop) << 2.		] ifFalse:[			"Do it the usual way"			lastFieldOffset _ self lastPointerOf: oop.		].		header _ header bitAnd: AllButTypeMask.		header _ (header bitOr: MarkBit) bitOr: HeaderTypeGC.		self longAt: oop put: header.		field _ oop + lastFieldOffset.		^ StartField	"trace its fields and class"	] ifFalse: [		"already marked; skip it"		field _ oop.		^ Upward	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'di 3/28/1999 14:28'!upward	"Return from marking an object below. Incoming:		field = oop we just worked on, needs to be put away		parentField = where to put it in our object	NOTE: Type field of object below has already been restored!!!!!!"	| type header |	self inline: true.	(parentField bitAnd: 1) = 1 ifTrue: [		parentField = GCTopMarker ifTrue: [			"top of the chain"			header _ (self longAt: field) bitAnd: AllButTypeMask.			type _ self rightType: header.			self longAt: field put: header + type.  "install type on class oop"			^ Done		] ifFalse: [			"was working on the extended class word"			child _ field.	"oop of class"			field _ parentField - 1.  "class word, ** clear the low bit **"			parentField _ self longAt: field.			header _ self longAt: field+4.  "base header word"			type _ self rightType: header.			self longAt: field put: child + type.  "install type on class oop"			field _ field + 4.  "point at header"			"restore type bits"			header _ header bitAnd: AllButTypeMask.			self longAt: field put: (header + type).			^ Upward		].	] ifFalse: [		"normal"		child _ field.  "who we worked on below"		field _ parentField.  "where to put it"		parentField _ self longAt: field.		self longAt: field put: child.		field _ field - 4.  "point at header"		^ StartField	].! !!Interpreter methodsFor: 'image segment in/out' stamp: 'di 3/28/1999 20:49'!primitiveLoadImageSegment	"This primitive is called from Squeak as...		<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray.""This primitive will load a binary image segment created by primitiveStoreImageSegment.  It expects the outPointer array to be of the proper size, and the wordArray to be well formed.  It will return as its value the original array of roots, and the erstwhile segmentWordArray will have been truncated to a size of zero.  If this primitive should fail, the segmentWordArray will, sadly, have been reduced to an unrecognizable and unusable jumble.  But what more could you have done with it anyway?"	| outPointerArray segmentWordArray endSeg segOop fieldPtr fieldOop doingClass lastPtr extraSize mapOop lastOut outPtr hdrTypeBits header |	outPointerArray _ self stackValue: 0.	lastOut _ outPointerArray + (self lastPointerOf: outPointerArray).	segmentWordArray _ self stackValue: 1.	endSeg _ segmentWordArray + (self sizeBitsOf: segmentWordArray) - BaseHeaderSize.	"Essential type checks"	((self formatOf: outPointerArray) = 2				"Must be indexable pointers"		and: [(self formatOf: segmentWordArray) = 6])	"Must be indexable words"		ifFalse: [^ self primitiveFail].	"Version and byte order check"	(self readableFormat: (self longAt: segmentWordArray + BaseHeaderSize))		ifFalse:		["Not readable -- try again with reversed bytes..."		self reverseBytesFrom: segmentWordArray + BaseHeaderSize to: endSeg + 4.		(self readableFormat: (self longAt: segmentWordArray + BaseHeaderSize))			ifFalse:			["Still NG -- put things back and fail"			self reverseBytesFrom: segmentWordArray + BaseHeaderSize to: endSeg + 4.			^ self primitiveFail]].	"Proceed through the segment, remapping pointers..."	segOop _ self oopFromChunk: segmentWordArray + BaseHeaderSize + 4.	[segOop <= endSeg] whileTrue:		[((self baseHeader: segOop) bitAnd: CompactClassMask) = 0			ifTrue: ["This object has a class field -- start with that."					fieldPtr _ segOop - 4.  doingClass _ true]			ifFalse: ["No class field -- start with first data field"					fieldPtr _ segOop + BaseHeaderSize.  doingClass _ false].		lastPtr _ segOop + (self lastPointerOf: segOop).	"last field"		lastPtr > endSeg ifTrue: [^ self primitiveFail "out of bounds"].		"Go through all oops, remapping them..."		[fieldPtr > lastPtr] whileFalse:			["Examine each pointer field"			fieldOop _ self longAt: fieldPtr.			doingClass ifTrue:				[hdrTypeBits _ self headerType: fieldPtr.				fieldOop _ fieldOop - hdrTypeBits].			(self isIntegerObject: fieldOop)				ifTrue:					["Integer -- nothing to do"					fieldPtr _ fieldPtr + 4]				ifFalse:					[(fieldOop bitAnd: 3) = 0 ifFalse: [^ self primitiveFail "bad oop"].					(fieldOop bitAnd: 16r80000000) = 0						ifTrue: ["Internal pointer -- add segment offset"								mapOop _ fieldOop + segmentWordArray]						ifFalse: ["External pointer -- look it up in outPointers"								outPtr _ outPointerArray + (fieldOop bitAnd: 16r7FFFFFFF).								outPtr > lastOut ifTrue: [^ self primitiveFail "out of bounds"].								mapOop _ self longAt: outPtr].					doingClass						ifTrue: [self longAt: fieldPtr put: mapOop + hdrTypeBits.								fieldPtr _ fieldPtr + 8.								doingClass _ false]						ifFalse: [self longAt: fieldPtr put: mapOop.								fieldPtr _ fieldPtr + 4]]].		segOop _ self objectAfter: segOop].	"Again, proceed through the segment checking consistency..."	segOop _ self oopFromChunk: segmentWordArray + BaseHeaderSize + 4.	[segOop <= endSeg] whileTrue:		[(self oopHasOKclass: segOop) ifFalse: [^ self primitiveFail "inconsistency"].		fieldPtr _ segOop + BaseHeaderSize.		"first field"		lastPtr _ segOop + (self lastPointerOf: segOop).	"last field"		"Go through all oops, remapping them..."		[fieldPtr > lastPtr] whileFalse:			["Examine each pointer field"			fieldOop _ self longAt: fieldPtr.			(self oopHasOKclass: fieldOop) ifFalse: [^ self primitiveFail "inconsistency"].			fieldPtr _ fieldPtr + 4].		segOop _ self objectAfter: segOop].	"Truncate the segment word array to size = 4 (vers stamp only)"	extraSize _ self extraHeaderBytes: segmentWordArray.	hdrTypeBits _ self headerType: segmentWordArray.	extraSize = 8		ifTrue: [self longAt: segmentWordArray-extraSize put: BaseHeaderSize + 4 + hdrTypeBits]		ifFalse: [header _ self longAt: segmentWordArray.				self longAt: segmentWordArray					put: header - (header bitAnd: SizeMask) + BaseHeaderSize + 4].	.		"and return the roots array which was first in the segment"	self pop: 3 thenPush: (self oopFromChunk: segmentWordArray + BaseHeaderSize + 4)! !!Interpreter methodsFor: 'image segment in/out' stamp: 'di 3/28/1999 20:37'!primitiveStoreImageSegment	"This primitive is called from Squeak as...		<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers: anArray.""This primitive will store a binary image segment (in the same format as the Squeak image file) of the receiver and every object in its proper tree of subParts (ie, that is not refered to from anywhere else outside the tree).  All pointers from within the tree to objects outside the tree will be copied into the array of outpointers.  In their place in the image segment will be an oop equal to the offset in the outPointer array (the first would be 4). but with the high bit set.""The primitive expects the array and wordArray to be more than adequately long.  In this case it returns normally, and truncates the two arrays to exactly the right size.  To simplify truncation, both incoming arrays are required to be 256 bytes or more long (ie with 3-word headers).  If either array is too small, the primitive will fail, but in no other case.During operation of the primitive, it is necessary to convert from both internal and external oops to their mapped values.  To make this fast, the headers of the original objects in question are replaced by the mapped values (and this is noted by adding the forbidden XX header type).  Tables are kept of both kinds of oops, as well as of the original headers for restoration.To be specific, there are two similar two-part tables, the outpointer array, and one in the upper fifth of the segmentWordArray.  Each grows oops from the bottom up, and preserved headers from halfway up.In case of either success or failure, the headers must be restored.  In the event of primitive failure, the table of outpointers must also be nilled out (since the garbage in the high half will not have been discarded."	| outPointerArray segmentWordArray savedYoungStart lastOut lastIn firstIn lastSeg endSeg segOop fieldPtr fieldOop mapOop doingClass lastPtr extraSize hdrTypeBits arrayOfRoots hdrBaseIn hdrBaseOut header firstOut versionOffset |	outPointerArray _ self stackValue: 0.	segmentWordArray _ self stackValue: 1.	arrayOfRoots _ self stackValue: 2.	"Essential type checks"	((self formatOf: arrayOfRoots) = 2				"Must be indexable pointers"		and: [(self formatOf: outPointerArray) = 2				"Must be indexable pointers"		and: [(self formatOf: segmentWordArray) = 6]])	"Must be indexable words"		ifFalse: [^ self primitiveFail].	((self headerType: outPointerArray) = HeaderTypeSizeAndClass	"Must be 3-word header"		and: [(self headerType: segmentWordArray) = HeaderTypeSizeAndClass])	"Must be 3-word header"		ifFalse: [^ self primitiveFail].	"Use the top half of outPointers for saved headers."	firstOut _ outPointerArray + BaseHeaderSize.	lastOut _ firstOut - 4.	hdrBaseOut _ outPointerArray + ((self lastPointerOf: outPointerArray) // 8 * 4). "top half"	lastSeg _ segmentWordArray.	endSeg _ segmentWordArray + (self sizeBitsOf: segmentWordArray) - 4.	"Write a version number for byte order and version check"	versionOffset _ 4.	lastSeg _ lastSeg + versionOffset.	lastSeg > endSeg ifTrue: [^ self primitiveFail].	self longAt: lastSeg put: self imageFormatVersion.	"Allocate top 1/8 of segment for table of internal oops and saved headers"	firstIn _ endSeg - ((self sizeBitsOf: segmentWordArray) // 32 * 4).  "Take 1/8 of seg"	lastIn _ firstIn - 4.	hdrBaseIn _ firstIn + ((self sizeBitsOf: segmentWordArray) // 64 * 4). "top half"	"First mark the rootArray and all root objects."	self longAt: arrayOfRoots put: ((self longAt: arrayOfRoots) bitOr: MarkBit).	lastPtr _ arrayOfRoots + (self lastPointerOf: arrayOfRoots).	fieldPtr _ arrayOfRoots + BaseHeaderSize.	[fieldPtr <= lastPtr] whileTrue:		[fieldOop _ self longAt: fieldPtr.		(self isIntegerObject: fieldOop) ifFalse:			[self longAt: fieldOop put: ((self longAt: fieldOop) bitOr: MarkBit)].		fieldPtr _ fieldPtr + 4].	"Then do a mark pass over all objects.  This will stop at our marked roots,	thus leaving our segment unmarked in their shadow."	savedYoungStart _ youngStart.	youngStart _ self startOfMemory.  "process all of memory"	self markPhase.	youngStart _ savedYoungStart.		"Finally unmark the rootArray and all root objects."	self longAt: arrayOfRoots put: ((self longAt: arrayOfRoots) bitAnd: AllButMarkBit).	fieldPtr _ arrayOfRoots + BaseHeaderSize.	[fieldPtr <= lastPtr] whileTrue:		[fieldOop _ self longAt: fieldPtr.		(self isIntegerObject: fieldOop) ifFalse:			[self longAt: fieldOop put: ((self longAt: fieldOop) bitAnd: AllButMarkBit)].		fieldPtr _ fieldPtr + 4].	"All external objects, and only they, are now marked.	Copy the array of roots into the segment, and forward its oop."	lastIn _ lastIn + 4.	lastIn >= hdrBaseIn ifTrue: [lastIn _ lastIn - 4.  successFlag _ false].	lastSeg _ self copyObj: arrayOfRoots toSegment: segmentWordArray addr: lastSeg stopAt: firstIn saveOopAt: lastIn headerAt: hdrBaseIn + (lastIn - firstIn).	successFlag ifFalse:		[self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.		^ self primitiveFailAfterCleanup: outPointerArray].	"Now run through the segment fixing up all the pointers.	Note that more objects will be added to the segment as we make our way along."	segOop _ self oopFromChunk: segmentWordArray + versionOffset + BaseHeaderSize.	[segOop <= lastSeg] whileTrue:		[((self baseHeader: segOop) bitAnd: CompactClassMask) = 0			ifTrue: ["This object has a class field -- start with that."					fieldPtr _ segOop - 4.  doingClass _ true]			ifFalse: ["No class field -- start with first data field"					fieldPtr _ segOop + BaseHeaderSize.  doingClass _ false].		lastPtr _ segOop + (self lastPointerOf: segOop).	"last field"		"Go through all oops, remapping them..."		[fieldPtr > lastPtr] whileFalse:			["Examine each pointer field"			fieldOop _ self longAt: fieldPtr.			doingClass ifTrue:				[hdrTypeBits _ fieldOop bitAnd: TypeMask.				fieldOop _ fieldOop - hdrTypeBits].			(self isIntegerObject: fieldOop)				ifTrue: ["Just an integer -- nothing to do"						fieldPtr _ fieldPtr + 4]				ifFalse:				[header _ self longAt: fieldOop.				(header bitAnd: TypeMask) = HeaderTypeFree					ifTrue: ["Has already been forwarded -- this is the link"							mapOop _ header bitAnd: AllButTypeMask]					ifFalse:					[((self longAt: fieldOop) bitAnd: MarkBit) = 0						ifTrue:							["Points to an unmarked obj -- an internal pointer.							Copy the object into the segment, and forward its oop."							lastIn _ lastIn + 4.							lastIn >= hdrBaseIn ifTrue: [lastIn _ lastIn - 4.  successFlag _ false].							lastSeg _ self copyObj: fieldOop toSegment: segmentWordArray addr: lastSeg stopAt: firstIn saveOopAt: lastIn headerAt: hdrBaseIn + (lastIn - firstIn).							successFlag ifFalse:								["Out of space in segment"								self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.								^ self primitiveFailAfterCleanup: outPointerArray].							mapOop _ (self longAt: fieldOop) bitAnd: AllButTypeMask]						ifFalse:							["Points to a marked obj -- an external pointer.							Map it as a tagged index in outPointers, and forward its oop."							lastOut _ lastOut + 4.							lastOut >= hdrBaseOut ifTrue:								["Out of space in outPointerArray"								lastOut _ lastOut - 4.								self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.								^ self primitiveFailAfterCleanup: outPointerArray]..							mapOop _ lastOut - outPointerArray bitOr: 16r80000000.							self forward: fieldOop to: mapOop								savingOopAt: lastOut andHeaderAt: hdrBaseOut + (lastOut - firstOut)]].					"Replace the oop by its mapped value"					doingClass						ifTrue: [self longAt: fieldPtr put: mapOop + hdrTypeBits.								fieldPtr _ fieldPtr + 8.								doingClass _ false]						ifFalse: [self longAt: fieldPtr put: mapOop.								fieldPtr _ fieldPtr + 4].]].		segOop _ self objectAfter: segOop].	self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.	"Truncate the outPointerArray..."	((outPointerArray + (self lastPointerOf: outPointerArray) - lastOut) < 12		or: [(endSeg - lastSeg) < 12]) ifTrue:			["Not enough room to insert simple 3-word headers"			^ self primitiveFailAfterCleanup: outPointerArray].	extraSize _ self extraHeaderBytes: segmentWordArray.	hdrTypeBits _ self headerType: segmentWordArray.	"Copy the 3-word wordArray header to establish a free chunk."	self transfer: 3		from: segmentWordArray - extraSize		to: lastOut+4.	"Adjust the size of the original as well as the free chunk."	self longAt: lastOut+4		put: outPointerArray + (self lastPointerOf: outPointerArray) - lastOut - extraSize + hdrTypeBits.	self longAt: outPointerArray-extraSize		put: lastOut - firstOut + 8 + hdrTypeBits.	"Note that pointers have been stored into roots table"	self beRootIfOld: outPointerArray.	"Truncate the image segment..."	"Copy the 3-word wordArray header to establish a free chunk."	self transfer: 3		from: segmentWordArray - extraSize		to: lastSeg+4.	"Adjust the size of the original as well as the free chunk."	self longAt: segmentWordArray-extraSize		put: lastSeg - segmentWordArray + BaseHeaderSize + hdrTypeBits.	self longAt: lastSeg+4		put: endSeg - lastSeg - extraSize + hdrTypeBits.	self pop: 3  "...leaving the reciever on the stack as return value"! !!Interpreter methodsFor: 'image save/restore' stamp: 'di 3/28/1999 17:55'!readableFormat: imageVersion	"Anwer true if images of the given format are readable by this interpreter. Allows a virtual machine to accept selected older image formats."	^ imageVersion = self imageFormatVersion"	Example of multiple formats:	^ (imageVersion = self imageFormatVersion) or: [imageVersion = 6504]"! !!Interpreter methodsFor: 'image save/restore' stamp: 'di 3/28/1999 17:42'!reverseBytesFrom: startAddr to: stopAddr	"Byte-swap the given range of memory (not inclusive of stopAddr!!)."	| addr |	addr _ startAddr.	[addr < stopAddr] whileTrue:		[self longAt: addr put: (self byteSwapped: (self longAt: addr)).		addr _ addr + 4].! !ImageSegment removeSelector: #storeSegmentFor:into:withOutPointers:!ImageSegment removeSelector: #loadSegmentFrom:withOutPointers:!