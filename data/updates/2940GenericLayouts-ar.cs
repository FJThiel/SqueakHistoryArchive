'From Squeak2.9alpha of 13 June 2000 [latest update: #2987] on 9 November 2000 at 6:31:55 pm'!"Change Set:		GenericLayouts-arDate:			9 November 2000Author:			Andreas RaabThe first round of the layout changes. What it does:* Establish the new layout policies* Convert everything from old to new layouts* Make most of the stuff accessible from the UI.What it does NOT:* No classes are being reshaped yet.* Speed issues are not touched yet (e.g., it DOES slow down things)* Fix up classes still relying on the old mechanisms."!Object subclass: #LayoutCell	instanceVariableNames: 'target cellSize extraSpace flags nextCell '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Layouts'!!LayoutCell commentStamp: '<historical>' prior: 0!I am used in table layouts to hold temporary values while the layout is being computed.Instance variables:	target 		<Morph>		The morph contained in this cell	cellSize 		<Point>		The size of the cell	extraSpace 	<nil | Point>	Additional space to add after this cell	nextCell 	<nil | LayoutCell>	The next cell in the arrangement.Implementation note:Both, cellSize and extraSpace contains points where	x - represents the primary table direction	y - represents the secondary table direction!Object subclass: #LayoutFrame	instanceVariableNames: 'leftFraction leftOffset topFraction topOffset rightFraction rightOffset bottomFraction bottomOffset '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Layouts'!!LayoutFrame commentStamp: '<historical>' prior: 0!I define a frame for positioning some morph in a proportional layout.Instance variables:	leftFraction 	topFraction 	rightFraction 	bottomFraction 	<Float>		The fractional distance (between 0 and 1) to place the morph in its owner's bounds	leftOffset 	topOffset 	rightOffset 	bottomOffset 	<Integer>	Fixed pixel offset to apply after fractional positioning (e.g., "10 pixel right of the center of the owner")!Object subclass: #LayoutPolicy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Layouts'!!LayoutPolicy commentStamp: '<historical>' prior: 0!A LayoutPolicy defines how submorphs of some morph should be arranged. Subclasses of the receiver define concrete layout policies.!LayoutPolicy subclass: #ProportionalLayout	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Layouts'!!ProportionalLayout commentStamp: '<historical>' prior: 0!I represent a layout that places all children of some morph in their given LayoutFrame.!LayoutPolicy subclass: #TableLayout	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Layouts'!!TableLayout commentStamp: '<historical>' prior: 0!The layout process:For computing the new layout for the children of any morph, we start with an initial rectangle which is provided as a reference.Step 1: The first step of layout computation is to compute the minimum extent each of our children can have. The minimum extent is mapped through both the local layout frame of the morph (for relative positioning) and the global layout frame (for insets, such as cursor indication) to obtain the minimal size required for each cell.Step 2: Based on the cell sizes, the number of cells we can put into each row and column is computed. For equal spacing, the maximum size of the cells is taken into account here.Step 3: Based on the row/column sizes, we compute the extra space which should be added to each row/column. For 	#leftFlush/#topFlush - we add all extra space add the end	#rightFlush/#bottomFlush - we add all extra space at the start	#centering - we add 1/2 of the extra space at start and end	#justified - we distribute the space evenly between the morphs[NOTE: If any #spaceFill morphs are encountered during this step, #justified is implied and the space is exclusively and equally distributed between those #spaceFill morphs. This is for backward compatibility and should *never* be necessary in the new regime].Step 4: The morphs are placed in the computed cells and the extra space is distributed as necessary. Placing the submorphs is done by mapping through the global and the local layout frame as requested.Start point:=> bounds: new rectangle for the morph.Compute basic arrangement of morphs:=> For each submorph compute minExtent	- if global layout frame inset in global layout frame	- if local layout frame inset in local layout frame=> Compute number of morphs per, width and height of row/column	- if equal spacing based on max size=> Compute extra space per row/column	- if centering = #justified; distribute space equally	- if centering #leftFlush/#topFlush (-1) add start extra	- if centering #rightFlush/#bottomFlush (1) add end extra	- if centering #centered add 1/2 extra to start/end	<extra space must be float and rounded accordingly!!>=> Place morphs in appropriate cells	- if global layout frame inset in global layout frame	- if local layout frame inset in local layout frame	<will likely cause #layoutChanged by submorphs>Distribute morphs in row/column:=> Compute the max length of each row/column!!Browser methodsFor: 'initialize-release' stamp: 'ar 11/8/2000 22:47'!optionalButtonRow	| aRow aButton |	aRow _ AlignmentMorph newRow.	aRow beSticky.	aRow hResizing: #spaceFill.	aRow centering: #center.	aRow clipSubmorphs: true.	aRow addTransparentSpacerOfSize: (5@0).	self optionalButtonPairs  do:			[:pair |				aButton _ PluggableButtonMorph					on: self					getState: nil					action: pair second.				aButton useRoundedCorners;					label: pair first asString;					onColor: Color transparent offColor: Color transparent.				aRow addMorphBack: aButton.				aRow addTransparentSpacerOfSize: (3 @ 0)].	aRow addMorphBack: self diffButton.	^ aRow! !!ChangeList methodsFor: 'menu actions' stamp: 'ar 11/8/2000 22:47'!buttonRowForChangeList	| aRow aButton |	aRow _ AlignmentMorph newRow.	aRow clipSubmorphs: true.	aRow addTransparentSpacerOfSize: (5@0).	aRow centering: #center.	self changeListButtonSpecs do:		[:triplet |			aButton _ PluggableButtonMorph				on: self				getState: nil				action: triplet second.			aButton useRoundedCorners;				label: triplet first asString;				askBeforeChanging: true;				onColor: Color transparent offColor: Color transparent.			aRow addMorphBack: aButton.			aRow addTransparentSpacerOfSize: (3 @ 0).			aButton setBalloonText: triplet third.			aRow addMorphBack: aButton.			aRow addTransparentSpacerOfSize: (3 @ 0).			aButton setBalloonText: triplet third.			aRow addTransparentSpacerOfSize: (3 @ 0)].	aRow addMorphBack: self diffButton.		^ aRow! !!Debugger methodsFor: 'initialize' stamp: 'ar 11/9/2000 18:25'!buildMorphicNotifierLabelled: label message: messageString	| notifyPane window contentTop extentToUse |	window _ (PreDebugWindow labelled: label) model: self.	contentTop _ 0.27.	extentToUse _ 450 @ 156. "nice and wide to show plenty of the error msg"	window addMorph: (self buttonRowForPreDebugWindow: window)				frame: (0@0 corner: 1 @ contentTop).		notifyPane _ PluggableTextMorph on: self text: nil accept: nil		readSelection: nil menu: #debugProceedMenu:.	notifyPane editString: (self preDebugNotifierContentsFrom: messageString);		askBeforeDiscardingEdits: false.	window addMorph: notifyPane frame: (0@contentTop corner: 1@1).	"window deleteCloseBox.		chickened out by commenting the above line out, sw 8/14/2000 12:54"	window setBalloonTextForCloseBox.	^ window openInWorldExtent: extentToUse! !!Debugger methodsFor: 'initialize' stamp: 'ar 11/8/2000 22:48'!optionalButtonRow	| aRow aButton |	aRow _ AlignmentMorph newRow beSticky.	aRow clipSubmorphs: true.	aButton _ SimpleButtonMorph new target: self.	aButton color: Color lightRed; borderWidth: 1; borderColor: Color red darker.	aRow addTransparentSpacerOfSize: (5@0).	self optionalButtonPairs do:		[:pair |				aButton _ PluggableButtonMorph					on: self					getState: nil					action: pair second.				aButton useRoundedCorners;					label: pair first asString;					askBeforeChanging: true;					onColor: Color transparent offColor: Color transparent.				aRow addMorphBack: aButton.				aRow addTransparentSpacerOfSize: (3 @ 0)].	^ aRow! !!FileList methodsFor: 'initialization' stamp: 'ar 11/8/2000 22:48'!optionalButtonRow	| aRow aButton |	aRow _ AlignmentMorph newRow beSticky.	aRow clipSubmorphs: true.	aRow addTransparentSpacerOfSize: (5@0).	self optionalButtonSpecs do:			[:spec |				aButton _ PluggableButtonMorph					on: self					getState: nil					action: spec second.				aButton useRoundedCorners;					label: spec first asString;					askBeforeChanging: true;					onColor: Color transparent offColor: Color transparent.				aRow addMorphBack: aButton.				aRow addTransparentSpacerOfSize: (3 @ 0).				aButton setBalloonText: spec fourth.				aRow addTransparentSpacerOfSize: (3 @ 0).				(spec second == #sortBySize)					ifTrue:						[aRow addTransparentSpacerOfSize: (4@0)]].	^ aRow! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 11/2/2000 17:15'!addExtraSpace: aPoint	extraSpace 		ifNil:[extraSpace _ aPoint]		ifNotNil:[extraSpace _ extraSpace + aPoint]! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/28/2000 18:12'!cellSize	^cellSize! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/28/2000 18:12'!cellSize: aPoint	cellSize _ aPoint! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/28/2000 21:29'!extraSpace	^extraSpace! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/28/2000 21:30'!extraSpace: aPoint	extraSpace _ aPoint! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/31/2000 21:24'!hSpaceFill	^flags anyMask: 1! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/31/2000 23:23'!hSpaceFill: aBool	flags ifNil:[flags _ 0].	flags _ aBool ifTrue:[flags bitOr: 1] ifFalse:[flags bitClear: 1].! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/28/2000 18:12'!nextCell	^nextCell! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/28/2000 18:12'!nextCell: aCell	nextCell _ aCell! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/28/2000 18:11'!target	^target! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/28/2000 18:12'!target: newTarget	target _ newTarget! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/31/2000 21:24'!vSpaceFill	^flags anyMask: 2! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/31/2000 23:23'!vSpaceFill: aBool	flags ifNil:[flags _ 0].	flags _ aBool ifTrue:[flags bitOr: 2] ifFalse:[flags bitClear: 2].! !!LayoutCell methodsFor: 'collection' stamp: 'ar 10/28/2000 18:58'!do: aBlock	aBlock value: self.	nextCell ifNotNil:[nextCell do: aBlock].! !!LayoutCell methodsFor: 'collection' stamp: 'ar 10/28/2000 21:27'!inject: thisValue into: binaryBlock 	"Accumulate a running value associated with evaluating the argument, 	binaryBlock, with the current value of the argument, thisValue, and the 	receiver as block arguments. For instance, to sum the numeric elements 	of a collection, aCollection inject: 0 into: [:subTotal :next | subTotal + 	next]."	| nextValue |	nextValue _ thisValue.	self do: [:each | nextValue _ binaryBlock value: nextValue value: each].	^nextValue! !!LayoutCell methodsFor: 'collection' stamp: 'ar 10/28/2000 21:41'!size	| n cell |	n _ 0.	cell _ self.	[cell == nil] whileFalse:[		n _ n + 1.		cell _ cell nextCell].	^n! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!bottomFraction	^bottomFraction! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!bottomFraction: aNumber	bottomFraction _ aNumber! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!bottomFraction: aNumber offset: anInteger	bottomFraction _ aNumber.	bottomOffset _ anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!bottomOffset	^bottomOffset! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!bottomOffset: anInteger	bottomOffset _ anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!leftFraction	^leftFraction! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!leftFraction: aNumber	leftFraction _ aNumber! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!leftFraction: aNumber offset: anInteger	leftFraction _ aNumber.	leftOffset _ anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!leftOffset	^leftOffset! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!leftOffset: anInteger	leftOffset _ anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!rightFraction	^rightFraction! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!rightFraction: aNumber	rightFraction _ aNumber! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!rightFraction: aNumber offset: anInteger	rightFraction _ aNumber.	rightOffset _ anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!rightOffset	^rightOffset! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!rightOffset: anInteger	rightOffset _ anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!topFraction	^topFraction! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!topFraction: aNumber	topFraction _ aNumber! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:37'!topFraction: aNumber offset: anInteger	topFraction _ aNumber.	topOffset _ anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:37'!topOffset	^topOffset! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:37'!topOffset: anInteger	topOffset _ anInteger! !!LayoutFrame methodsFor: 'layout' stamp: 'ar 11/4/2000 22:51'!layout: oldBounds in: newBounds	"Return the proportional rectangle insetting the given bounds"	| left right top bottom |	leftFraction ifNotNil:[		left _ newBounds left + (newBounds width * leftFraction).		leftOffset ifNotNil:[left _ left + leftOffset]].	rightFraction ifNotNil:[		right _ newBounds right - (newBounds width * (1.0 - rightFraction)).		rightOffset ifNotNil:[right _ right - rightOffset]].	topFraction ifNotNil:[		top _ newBounds top + (newBounds height * topFraction).		topOffset ifNotNil:[top _ top + topOffset]].	bottomFraction ifNotNil:[		bottom _ newBounds bottom - (newBounds height * (1.0 - bottomFraction)).		bottomOffset ifNotNil:[bottom _ bottom - bottomOffset]].	left ifNil:[ right 			ifNil:[left _ oldBounds left. right _ oldBounds right]			ifNotNil:[left _ right - oldBounds width]].	right ifNil:[right _ left + oldBounds width].	top ifNil:[ bottom 			ifNil:[top _ oldBounds top. bottom _ oldBounds bottom]			ifNotNil:[top _ bottom - oldBounds height]].	bottom ifNil:[bottom _ top + oldBounds height].	^(left asInteger @ top asInteger) corner: (right asInteger @ bottom asInteger)! !!LayoutPolicy methodsFor: 'testing' stamp: 'ar 10/29/2000 01:28'!isProportionalLayout	^false! !!LayoutPolicy methodsFor: 'testing' stamp: 'ar 10/29/2000 01:28'!isTableLayout	^false! !!LayoutPolicy methodsFor: 'layout' stamp: 'ar 10/28/2000 19:12'!layout: aMorph in: newBounds	"Compute the layout for the given morph based on the new bounds"! !!LayoutPolicy methodsFor: 'layout' stamp: 'ar 10/31/2000 19:59'!minExtentOf: aMorph in: newBounds	"Return the minimal size aMorph's children would require given the new bounds"	^0@0! !!LayoutPolicy methodsFor: 'utilities' stamp: 'ar 10/29/2000 17:31'!indexForInserting: aMorph at: aPoint in: someMorph	"Return the insertion index based on the layout strategy defined for some morph. Used for drop insertion."	^1 "front-most"! !!Morph methodsFor: 'accessing' stamp: 'ar 11/9/2000 01:36'!borderWidth	^ 0! !!Morph methodsFor: 'accessing' stamp: 'ar 11/9/2000 01:36'!borderWidth: aNumber! !!Morph methodsFor: 'drawing' stamp: 'ar 11/4/2000 23:39'!changeClipSubmorphs	self clipSubmorphs: self clipSubmorphs not.! !!Morph methodsFor: 'drawing' stamp: 'ar 10/29/2000 19:21'!clipLayoutCells	"Drawing/layout specific. If this property is set, clip the submorphs of the receiver by its cell bounds."	extension == nil ifTrue:[^false].	^self valueOfProperty: #clipLayoutCells ifAbsent:[false].! !!Morph methodsFor: 'drawing' stamp: 'ar 10/29/2000 19:22'!clipLayoutCells: aBool	"Drawing/layout specific. If this property is set, clip the submorphs of the receiver by its cell bounds."	aBool == false		ifTrue:[self removeProperty: #clipLayoutCells]		ifFalse:[self setProperty: #clipLayoutCells toValue: aBool].	self changed.! !!Morph methodsFor: 'drawing' stamp: 'ar 10/29/2000 19:17'!clipSubmorphs	"Drawing specific. If this property is set, clip the receiver's submorphs to the receiver's clipping bounds."	extension == nil ifTrue:[^false]. "get out quickly"	^self valueOfProperty: #clipSubmorphs ifAbsent:[false].! !!Morph methodsFor: 'drawing' stamp: 'ar 10/29/2000 19:18'!clipSubmorphs: aBool	"Drawing specific. If this property is set, clip the receiver's submorphs to the receiver's clipping bounds."	aBool == false		ifTrue:[self removeProperty: #clipSubmorphs]		ifFalse:[self setProperty: #clipSubmorphs toValue: aBool].	self invalidRect: self fullBounds.! !!Morph methodsFor: 'drawing' stamp: 'ar 10/29/2000 19:16'!clippingBounds	"Return the bounds to which any submorphs should be clipped if the property is set"	^self innerBounds! !!Morph methodsFor: 'drawing' stamp: 'ar 11/1/2000 15:38'!drawSubmorphsOn: aCanvas	"Display submorphs back to front"	| drawBlock |	submorphs size = 0 ifTrue:[^self].	drawBlock _ [:canvas| submorphs reverseDo:[:m| canvas fullDrawMorph: m]].	self clipSubmorphs ifTrue:[		aCanvas clipBy: self clippingBounds during: drawBlock.	] ifFalse:[		drawBlock value: aCanvas.	].! !!Morph methodsFor: 'drawing' stamp: 'ar 11/8/2000 19:29'!expandFullBoundsForDropShadow: aRectangle	"Return an expanded rectangle for an eventual drop shadow"	| delta box |	delta _ self shadowOffset.	delta x >= 0 		ifTrue:[box _ aRectangle right: aRectangle right + delta x]		ifFalse:[box _ aRectangle left: aRectangle left + delta x].	delta y >= 0		ifTrue:[box _ aRectangle bottom: aRectangle bottom + delta y]		ifFalse:[box _ aRectangle top: aRectangle top + delta y].	^box! !!Morph methodsFor: 'drawing' stamp: 'ar 11/8/2000 19:29'!expandFullBoundsForRolloverBorder: aRectangle	| delta |	delta _ self valueOfProperty: #rolloverWidth ifAbsent: [10@10].	^aRectangle expandBy: delta.! !!Morph methodsFor: 'drawing' stamp: 'ar 11/8/2000 19:21'!fullDrawOn: aCanvas	"Draw the full Morphic structure on the given Canvas"	self visible ifFalse: [^ self].	(self hasProperty: #errorOnDraw) ifTrue:[^self drawErrorOn: aCanvas].	"Note: At some point we should generalize this into some sort of 	multi-canvas so that we can cross-optimize some drawing operations."	"Pass 1: Draw eventual drop-shadow"	self hasDropShadow ifTrue: [self drawDropShadowOn: aCanvas].	self hasRolloverBorder ifTrue: [self drawRolloverBorderOn: aCanvas].	"Pass 2: Draw receiver itself"	aCanvas roundCornersOf: self during:[		aCanvas drawMorph: self.		self drawSubmorphsOn:aCanvas.		self drawDropHighlightOn: aCanvas.		self drawMouseDownHighlightOn: aCanvas].! !!Morph methodsFor: 'drawing' stamp: 'ar 10/29/2000 19:31'!hasClipSubmorphsString	^self clipSubmorphs		ifTrue:['<on>clip submorphs']		ifFalse:['<off>clip submorphs']! !!Morph methodsFor: 'menus' stamp: 'ar 11/4/2000 23:39'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	self maybeAddCollapseItemTo: aMenu.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer:.	aMenu addLine.	aMenu add: 'copy Postscript' action: #clipPostscript.	aMenu add: 'print PS to file...' target: self selector: #printPSToFile.	self player ifNotNil:		[aMenu addLine.		aMenu add: 'make a sibling instance' target: self action: #makeNewPlayerInstance:.		aMenu balloonTextForLastItem: 'Makes another morph whose player is of the same class as this one.  Both siblings will share the same scripts'].	aMenu addLine.	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addDropShadowMenuItems: aMenu hand: aHandMorph.	self addLayoutMenuItems: aMenu hand: aHandMorph.	aMenu addUpdating: #hasClipSubmorphsString target: self selector: #changeClipSubmorphs argumentList: #().	aMenu addLine.	self potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' target: self action: #embedInto:].	aMenu defaultTarget: self.	aMenu addUpdating: #lockedString action: #lockUnlockMorph.	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu		defaultTarget: self;		add: 'add mouse up action' action: #addMouseUpAction;		add: 'remove mouse up action' action: #removeMouseUpAction.	aMenu addLine.	owner isStackBackground ifTrue:		[self isShared			ifFalse:				[aMenu add: 'put onto Background' target: self action: #putOnBackground]			ifTrue:				[aMenu add: 'remove from Background' target: self action: #putOnForeground.				self couldHoldSeparateDataForEachInstance ifTrue:					[self holdsSeparateDataForEachInstance						ifFalse:							[aMenu add: 'start holding separate data for each instance' target: self action: #makeHoldSeparateDataForEachInstance]						ifTrue:							[aMenu add: 'stop holding separate data for each instance' target: self action: #stopHoldingSeparateDataForEachInstance].							aMenu add: 'be default value on new card' target: self action: #setAsDefaultValueForNewCard.							(self hasProperty: #thumbnailImage)								ifTrue:									[aMenu add: 'stop using for reference thumbnail' target: self action: #stopUsingForReferenceThumbnail]								ifFalse:									[aMenu add: 'start using for reference thumbnail' target: self action: #startUsingForReferenceThumbnail]]].				aMenu addLine].	aMenu defaultTarget: self topRendererOrSelf.	aMenu add: 'draw new path' action: #definePath.	(self hasProperty: #pathPoints) ifTrue:		[aMenu add: 'follow path' action: #followPath.		aMenu add: 'delete path' action: #deletePath].	(owner == nil) ifFalse:		[aMenu add: 'send to back' action: #goBehind.		aMenu add: 'bring to front' action: #comeToFront].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'menus' stamp: 'ar 11/2/2000 15:04'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| realOwner realMorph |	"Add morph-specific items to the given menu which was invoked by the given hand.  Note the special-casing of Worlds, for which some of the the otherwise generic items are excluded."	aCustomMenu addUpdating: #hasDragAndDropEnabledString action: #changeDragAndDrop.	self isWorldMorph		ifFalse:			[(self isKindOf: SystemWindow)				ifFalse: [aCustomMenu add: 'put in a window' action: #embedInWindow].			aCustomMenu addUpdating: #stickinessString target: self action: #toggleStickiness.			aCustomMenu add: 'adhere to edge...' action: #adhereToEdge]		ifTrue:			[aCustomMenu add: 'desktop menu...' target: self action: #putUpDesktopMenu:.			aCustomMenu addLine].	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aCustomMenu hand: aHandMorph].	realOwner _ (realMorph _ self topRendererOrSelf) owner.	(realOwner isKindOf: TextPlusPasteUpMorph) ifTrue:		[aCustomMenu add: 'GeeMail stuff...' subMenu: (realOwner textPlusMenuFor: realMorph)]! !!Morph methodsFor: 'menus' stamp: 'ar 11/2/2000 15:04'!changeDragAndDrop	^self enableDragNDrop: self dragNDropEnabled not! !!Morph methodsFor: 'menus' stamp: 'ar 11/2/2000 15:03'!hasDragAndDropEnabledString	^self dragNDropEnabled ifTrue:['<on>drag and drop'] ifFalse:['<off>drag and drop']! !!Morph methodsFor: 'private' stamp: 'ar 11/1/2000 15:38'!privateMoveBy: delta	"Private!! Use 'position:' instead."	| fill |	extension ifNotNil:[		extension player ifNotNil:[			"Most cases eliminated fast by above test"			self getPenDown ifTrue:[				"If this is a costume for a player with its pen down, draw a line."				self moveWithPenDownBy: delta]]].	fullBounds == bounds		ifTrue: ["optimization: avoids recomputing fullBounds"				fullBounds _ bounds _ bounds translateBy: delta]		ifFalse: [bounds _ bounds translateBy: delta.				fullBounds ifNotNil:[fullBounds _ fullBounds translateBy: delta]].	fill _ self fillStyle.	fill isOrientedFill ifTrue:[fill origin: fill origin + delta].! !!Morph methodsFor: 'meta-actions' stamp: 'ar 11/4/2000 23:39'!buildMetaMenu: evt	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph:.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer:.	self maybeAddCollapseItemTo: menu.	menu add: 'delete' action: #dismissMorph:.	menu addLine.	menu add: 'copy Postscript' action: #clipPostscript.	menu add: 'print PS to file...' action: #printPSToFile.	menu addLine.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo:.	menu add: 'duplicate' action: #maybeDuplicateMorph:.	self potentialEmbeddingTargets size > 1 ifTrue:		[menu add: 'embed...' action: #embedInto:].	menu add: 'resize' action: #resizeMorph:.	"Give the argument control over what should be done about fill styles"	self addFillStyleMenuItems: menu hand: evt hand.	self addDropShadowMenuItems: menu hand: evt hand.	self addLayoutMenuItems: menu hand: evt hand.	menu addUpdating: #hasClipSubmorphsString target: self selector: #changeClipSubmorphs argumentList: #().	menu addLine.	(self morphsAt: evt position) size > 1 ifTrue:		[menu add: 'submorphs...'			target: self			selector: #invokeMetaMenuAt:event:			argument: evt position].	menu addLine.	menu add: 'inspect' selector: #inspectAt:event: argument: evt position.	menu add: 'explore' action: #explore.	menu add: 'browse hierarchy' action: #browseHierarchy.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'set variable name...' action: #choosePartName.	(self isMorphicModel) ifTrue:		[menu add: 'save morph as prototype' action: #saveAsPrototype.		(self ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	(self hasProperty: #resourceFilePath)		ifTrue: [((self valueOfProperty: #resourceFilePath) endsWith: '.morph')				ifTrue: [menu add: 'save as resource' action: #saveAsResource].				menu add: 'update from resource' action: #updateFromResource]		ifFalse: [menu add: 'attach to resource' action: #attachToResource].	menu add: 'show actions' action: #showActions.	menu addLine.	self addCustomMenuItems: menu hand: evt hand.	^ menu! !!Morph methodsFor: 'meta-actions' stamp: 'ar 11/8/2000 22:51'!resizeMorph: evt	| handle |	handle _ HandleMorph new forEachPointDo: [:newPoint | 		self extent: (self griddedPoint: newPoint) - self bounds topLeft].	evt hand attachMorph: handle.	handle startStepping.! !!Morph methodsFor: 'layout' stamp: 'ar 10/29/2000 17:31'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto a morph that has agreed to accept the dropped morph by responding 'true' to the wantsDroppedMorph:Event: message. This default implementation just adds the given morph to the receiver."	| layout |	layout _ self layoutPolicy.	layout ifNil:[^self addMorph: aMorph].	self privateAddMorph: aMorph atIndex: (layout indexForInserting: aMorph at: evt position in: self).	self changed.	self layoutChanged! !!Morph methodsFor: 'layout' stamp: 'ar 11/9/2000 14:46'!adjustBounds	"Adjust the receivers bounds depending on the resizing strategy imposed"	| hFit vFit box myExtent extent |	hFit _ self hResizing.	vFit _ self vResizing.	(hFit == #shrinkWrap or:[vFit == #shrinkWrap]) ifFalse:[^self]. "not needed"	box _ self layoutBounds.	myExtent _ box extent.	extent _ self submorphBounds corner - box origin.	hFit == #shrinkWrap ifTrue:[myExtent _ extent x @ myExtent y].	vFit == #shrinkWrap ifTrue:[myExtent _ myExtent x @ extent y].	"Make sure we don't get smaller than minWidth/minHeight"	myExtent x < self xMinWidth ifTrue:[		myExtent _ (myExtent x max: 			(self xMinWidth - self bounds width + self layoutBounds width)) @ myExtent y].	myExtent y < self xMinHeight ifTrue:[		myExtent _ myExtent x @ (myExtent y max:			(self xMinHeight - self bounds height + self layoutBounds height))].	self layoutBounds: (box origin extent: myExtent).! !!Morph methodsFor: 'layout' stamp: 'ar 11/8/2000 17:18'!convertAlignment	"Temporary - for converting old alignments only"! !!Morph methodsFor: 'layout' stamp: 'ar 11/9/2000 14:45'!fullBounds	"Return the bounding box of the receiver and all its children. Recompute the layout if necessary."	| layout box |	fullBounds ifNotNil:[^fullBounds].	"Send #ownerChanged to our children"	submorphs size > 0 ifTrue:[		submorphs do:[:m| m ownerChanged]].	layout _ self layoutPolicy.	layout ifNotNil:[layout layout: self in: self layoutBounds].	self adjustBounds.	fullBounds _ self privateFullBounds.	layout ifNotNil:[		box _ self priorFullBounds.		box == nil			ifTrue:[self invalidRect: fullBounds]			ifFalse:[box = fullBounds				ifFalse:[self invalidRect: (box quickMerge: fullBounds)]]].	^fullBounds! !!Morph methodsFor: 'layout' stamp: 'ar 10/30/2000 15:42'!layoutBounds	"Return the bounds for laying out children of the receiver"	| inset box |	inset _ self layoutInset.	box _ self innerBounds.	^box insetBy: inset.! !!Morph methodsFor: 'layout' stamp: 'ar 10/31/2000 21:09'!layoutBounds: aRectangle	"Set the bounds for laying out children of the receiver.	Note: written so that #layoutBounds can be changed without touching this method"	| outer inner |	outer _ self bounds.	inner _ self layoutBounds.	bounds _ aRectangle origin + (outer origin - inner origin) corner:				aRectangle corner + (outer corner - inner corner).! !!Morph methodsFor: 'layout' stamp: 'ar 11/1/2000 19:39'!layoutChanged	| layout |	fullBounds ifNil:[^self]. "layout will be recomputed so don't bother"	layout _ self layoutPolicy.	layout ifNotNil:[self changed]. "submorphs may move"	"Check if we really need to upcast #layoutChanged to our owner.	Three variants are possible, depending on the h/vResizing settings:		#rigid  - if the future fullBounds match the current fullBounds		#shrinkWrap - if the future fullBounds match the current fullBounds		#spaceFill - if my minExtent fits the current bounds."	"Note: fullBounds are reset regardless on sending #layoutChanged to our owner	since we *do* need to recompute the layout later on."	fullBounds _ nil.	owner ifNotNil: [owner layoutChanged].	"note: does not send #ownerChanged here - we'll do this when computing the new layout"! !!Morph methodsFor: 'layout' stamp: 'ar 11/6/2000 01:10'!layoutInBounds: cellBounds	"Layout specific. Apply the given bounds to the receiver after being layed out in its owner."	| box aSymbol |	cellBounds = bounds ifTrue:[^self]. "already up to date"	cellBounds extent = bounds extent "nice fit"		ifTrue:[self position: cellBounds origin].	self layoutPolicy ifNotNil:[fullBounds _ nil]. self flag: #arNote. "force a nonsense relayout"	box _ bounds.	"match #spaceFill constraints"	self hResizing == #spaceFill 		ifTrue:[box _ box origin extent: cellBounds width @ box height].	self vResizing == #spaceFill		ifTrue:[box _ box origin extent: box width @ cellBounds height].	"align accordingly"	aSymbol _ (owner ifNil:[self]) cellPositioning.	box _ box align: (box perform: aSymbol) with: (cellBounds perform: aSymbol).	"and install new bounds"	self bounds: box.! !!Morph methodsFor: 'layout' stamp: 'ar 11/6/2000 01:09'!layoutProportionallyIn: newBounds	"Layout specific. Apply the given bounds to the receiver."	| box frame |	frame _ self layoutFrame ifNil:[^self].	"compute the cell size the receiver has given its layout frame"	box _ frame layout: self bounds in: newBounds.	box = self bounds ifTrue:[^self]. "no change"	^self layoutInBounds: box.! !!Morph methodsFor: 'layout' stamp: 'ar 11/9/2000 14:36'!minExtent	"Layout specific. Return the minimum size the receiver can be represented in.	Implementation note: When this message is sent from an owner trying to lay out its children it will traverse down the morph tree and recompute the minimal arrangement of the morphs based on which the minimal extent is returned. When a morph with some layout strategy is encountered, the morph will ask its strategy to compute the new arrangement. However, since the final size given to the receiver is unknown at the point of the query, the assumption is made that the current bounds of the receiver are the base on which the layout should be computed. This scheme prevents strange layout changes when for instance, a table is contained in another table. Unless the inner table has been resized manually (which means its bounds are already enlarged) the arrangement of the inner table will not change here. Thus the entire layout computation is basically an iterative process which may have different results depending on the incremental changes applied."	| layout minExtent extra |self flag: #arNote. "take a clipping receiver into account..."	"optimize for #rigid receiver (doesn't require layout computation)"	(self hResizing == #rigid and:[self vResizing == #rigid]) 		ifTrue:[^self fullBounds extent].	layout _ self layoutPolicy.	layout == nil		ifTrue:[minExtent _ self hasSubmorphs 					ifTrue:[self submorphBounds corner - bounds origin]					ifFalse:[0@0]]		ifFalse:[minExtent _ layout minExtentOf: self in: self layoutBounds].	minExtent _ minExtent max: (self xMinWidth@self xMinHeight).	self hResizing == #rigid		ifTrue:[	minExtent _ self fullBounds extent x @ minExtent y]		ifFalse:[	extra _ self bounds width - self layoutBounds width.				minExtent _ (minExtent x + extra) @ minExtent y].	self vResizing == #rigid		ifTrue:[minExtent _ minExtent x @ self fullBounds extent y]		ifFalse:[extra _ self bounds height - self layoutBounds height.				minExtent _ minExtent x @ (minExtent y + extra)].	^minExtent! !!Morph methodsFor: 'layout' stamp: 'ar 11/8/2000 19:30'!privateFullBounds	"Private. Compute the actual full bounds of the receiver"	| box |	box _ self bounds copy.	self hasDropShadow ifTrue:[box _ self expandFullBoundsForDropShadow: box].	self hasRolloverBorder ifTrue:[box _ self expandFullBoundsForRolloverBorder: box].	submorphs size > 0 ifTrue: [box _ box quickMerge: self submorphBounds].	^ box origin asIntegerPoint corner: box corner asIntegerPoint! !!Morph methodsFor: 'layout' stamp: 'ar 11/2/2000 17:42'!submorphBounds	"Private. Compute the actual full bounds of the receiver"	| box subBox |	submorphs do: [:m | 		(m visible) ifTrue: [			subBox _ m fullBounds.			box 				ifNil:[box _ subBox copy]				ifNotNil:[box _ box quickMerge: subBox]]].	box ifNil:[^self bounds]. "e.g., having submorphs but not visible"	^ box origin asIntegerPoint corner: box corner asIntegerPoint! !!Morph methodsFor: 'layout' stamp: 'ar 10/31/2000 20:23'!xMinHeight	^self valueOfProperty: #minHeight ifAbsent:[2]! !!Morph methodsFor: 'layout' stamp: 'ar 10/31/2000 20:24'!xMinHeight: aNumber	aNumber == nil		ifTrue:[self removeProperty: #minHeight]		ifFalse:[self setProperty: #minHeight toValue: aNumber].	self layoutChanged.! !!Morph methodsFor: 'layout' stamp: 'ar 10/31/2000 20:23'!xMinWidth	^self valueOfProperty: #minWidth ifAbsent:[2]! !!Morph methodsFor: 'layout' stamp: 'ar 10/31/2000 20:24'!xMinWidth: aNumber	aNumber == nil		ifTrue:[self removeProperty: #minWidth]		ifFalse:[self setProperty: #minWidth toValue: aNumber].	self layoutChanged.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/2/2000 14:56'!addCellLayoutMenuItems: aMenu hand: aHand	"Cell (e.g., child) related items"	| menu sub |	menu _ MenuMorph new defaultTarget: self.		menu addUpdating: #hasDisableTableLayoutString action: #changeDisableTableLayout.		menu addLine.		sub _ MenuMorph new defaultTarget: self.		#(rigid shrinkWrap spaceFill) do:[:sym|			sub addUpdating: #hResizingString: target: self selector: #hResizing: argumentList: (Array with: sym)].		menu add:'horizontal resizing' subMenu: sub.		sub _ MenuMorph new defaultTarget: self.		#(rigid shrinkWrap spaceFill) do:[:sym|			sub addUpdating: #vResizingString: target: self selector: #vResizing: argumentList: (Array with: sym)].		menu add:'vertical resizing' subMenu: sub.	aMenu ifNotNil:[aMenu add: 'child layout' subMenu: menu].	^menu! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/2/2000 14:59'!addLayoutMenuItems: topMenu hand: aHand	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addUpdating: #hasNoLayoutString action: #changeNoLayout.	aMenu addUpdating: #hasProportionalLayoutString action: #changeProportionalLayout.	aMenu addUpdating: #hasTableLayoutString action: #changeTableLayout.	aMenu addLine.	aMenu add: 'change layout inset...' action: #changeLayoutInset:.	aMenu addLine.	self addCellLayoutMenuItems: aMenu hand: aHand.	self addTableLayoutMenuItems: aMenu hand: aHand.	topMenu ifNotNil:[topMenu add: 'layout' subMenu: aMenu].	^aMenu! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/2/2000 22:39'!addTableLayoutMenuItems: aMenu hand: aHand	| menu sub |	menu _ MenuMorph new defaultTarget: self.	menu addUpdating: #hasReverseCellsString action: #changeReverseCells.	menu addUpdating: #hasClipLayoutCellsString action: #changeClipLayoutCells.	menu addUpdating: #hasRubberBandCellsString action: #changeRubberBandCells.	menu addLine.	menu add: 'change cell inset...' action: #changeCellInset:.	menu add: 'change min cell size...' action: #changeMinCellSize:.	menu add: 'change max cell size...' action: #changeMaxCellSize:.	menu addLine.	sub _ MenuMorph new defaultTarget: self.	#(leftToRight rightToLeft topToBottom bottomToTop) do:[:sym|		sub addUpdating: #listDirectionString: target: self selector: #changeListDirection: argumentList: (Array with: sym)].	menu add: 'list direction' subMenu: sub.	sub _ MenuMorph new defaultTarget: self.	#(none leftToRight rightToLeft topToBottom bottomToTop) do:[:sym|		sub addUpdating: #wrapDirectionString: target: self selector: #wrapDirection: argumentList: (Array with: sym)].	menu add: 'wrap direction' subMenu: sub.	sub _ MenuMorph new defaultTarget: self.	#(center topLeft topRight bottomLeft bottomRight topCenter leftCenter rightCenter bottomCenter) do:[:sym|		sub addUpdating: #cellPositioningString: target: self selector: #cellPositioning: argumentList: (Array with: sym)].	menu add: 'cell positioning' subMenu: sub.	sub _ MenuMorph new defaultTarget: self.	#(topLeft bottomRight center justified) do:[:sym|		sub addUpdating: #listCenteringString: target: self selector: #listCentering: argumentList: (Array with: sym)].	menu add: 'list centering' subMenu: sub.	sub _ MenuMorph new defaultTarget: self.	#(topLeft bottomRight center justified) do:[:sym|		sub addUpdating: #wrapCenteringString: target: self selector: #wrapCentering: argumentList: (Array with: sym)].	menu add: 'wrap centering' subMenu: sub.	sub _ MenuMorph new defaultTarget: self.	#(none equal) do:[:sym|		sub addUpdating: #listSpacingString: target: self selector: #listSpacing: argumentList: (Array with: sym)].	menu add: 'list spacing' subMenu: sub.	sub _ MenuMorph new defaultTarget: self.	#(none localRect localSquare globalRect globalSquare) do:[:sym|		sub addUpdating: #cellSpacingString: target: self selector: #cellSpacing: argumentList: (Array with: sym)].	menu add: 'cell spacing' subMenu: sub.	aMenu ifNotNil:[aMenu add: 'table layout' subMenu: menu].	^menu! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/1/2000 16:48'!changeCellInset: evt	| handle |	handle _ HandleMorph new forEachPointDo:[:newPoint |		self cellInset: (newPoint - evt cursorPoint) asIntegerPoint // 5].	evt hand attachMorph: handle.	handle startStepping.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:18'!changeClipLayoutCells	self clipLayoutCells: self clipLayoutCells not.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:19'!changeDisableTableLayout	self disableTableLayout: self disableTableLayout not.	self layoutChanged.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/2/2000 14:59'!changeLayoutInset: evt	| handle |	handle _ HandleMorph new forEachPointDo:[:newPoint |		self layoutInset: (newPoint - evt cursorPoint) asIntegerPoint // 5].	evt hand attachMorph: handle.	handle startStepping.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/2/2000 17:40'!changeListDirection: aSymbol	| listDir wrapDir |	self listDirection: aSymbol.	(self wrapDirection == #none) ifTrue:[^self].	"otherwise automatically keep a valid table layout"	listDir _ self listDirection.	wrapDir _ self wrapDirection.	(listDir == #leftToRight or:[listDir == #rightToLeft]) ifTrue:[		wrapDir == #leftToRight ifTrue:[^self wrapDirection: #topToBottom].		wrapDir == #rightToLeft ifTrue:[^self wrapDirection: #bottomToTop].	] ifFalse:[		wrapDir == #topToBottom ifTrue:[^self wrapDirection: #leftToRight].		wrapDir == #bottomToTop ifTrue:[^self wrapDirection: #rightToLeft].	].! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/2/2000 18:29'!changeMaxCellSize: evt	| handle |	handle _ HandleMorph new forEachPointDo:[:newPoint |		self maxCellSize: (newPoint - evt cursorPoint) asIntegerPoint].	evt hand attachMorph: handle.	handle startStepping.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/2/2000 18:29'!changeMinCellSize: evt	| handle |	handle _ HandleMorph new forEachPointDo:[:newPoint |		self minCellSize: (newPoint - evt cursorPoint) asIntegerPoint].	evt hand attachMorph: handle.	handle startStepping.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:19'!changeNoLayout	self layoutPolicy ifNil:[^self]. "already no layout"	self layoutPolicy: nil.	self layoutChanged.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:19'!changeProportionalLayout	| layout |	((layout _ self layoutPolicy) notNil and:[layout isProportionalLayout])		ifTrue:[^self]. "already proportional layout"	self layoutPolicy: ProportionalLayout new.	self layoutChanged.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:19'!changeReverseCells	self reverseTableCells: self reverseTableCells not.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/2/2000 22:39'!changeRubberBandCells	self rubberBandCells: self rubberBandCells not.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:20'!changeTableLayout	| layout |	((layout _ self layoutPolicy) notNil and:[layout isTableLayout])		ifTrue:[^self]. "already table layout"	self layoutPolicy: TableLayout new.	self layoutChanged.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:15'!hasClipLayoutCellsString	self clipLayoutCells		ifTrue:[^'<on>clip to cell size']		ifFalse:[^'<off>clip to cell size']! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:16'!hasDisableTableLayoutString	self disableTableLayout		ifTrue:[^'<on>disable layout in tables']		ifFalse:[^'<off>disable layout in tables']! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:16'!hasNoLayoutString	^self layoutPolicy == nil		ifTrue:['<on>no layout']		ifFalse:['<off>no layout'].! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:16'!hasProportionalLayoutString	| layout |	^((layout _ self layoutPolicy) notNil and:[layout isProportionalLayout])		ifTrue:['<on>proportional layout']		ifFalse:['<off>proportional layout'].! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:16'!hasReverseCellsString	self reverseTableCells		ifTrue:[^'<on>reverse table cells']		ifFalse:[^'<off>reverse table cells']! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/2/2000 22:39'!hasRubberBandCellsString	^self rubberBandCells ifTrue:['<on>rubber band cells'] ifFalse:['<off>rubber band cells']! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:16'!hasTableLayoutString	| layout |	^((layout _ self layoutPolicy) notNil and:[layout isTableLayout])		ifTrue:['<on>table layout']		ifFalse:['<off>table layout'].! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:17'!layoutMenuPropertyString: aSymbol from: currentSetting	| index |	^String streamContents:[:s|		s nextPutAll: (aSymbol == currentSetting ifTrue:['<on>'] ifFalse:['<off>']).		index _ 1.		aSymbol keysAndValuesDo:[:idx :ch|			ch isUppercase ifTrue:[				s nextPutAll: (aSymbol copyFrom: index to: idx-1) asLowercase.				s nextPutAll:' '.				index _ idx]].		index < aSymbol size ifTrue:[s nextPutAll: (aSymbol copyFrom: index to: aSymbol size) asLowercase]].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 18:44'!cellInset	"Layout specific. This property specifies an extra inset for each cell in the layout."	^self valueOfProperty: #cellInset ifAbsent:[0]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 18:45'!cellInset: aNumber	"Layout specific. This property specifies an extra inset for each cell in the layout."	(aNumber isNil or:[aNumber isNumber and:[aNumber = 0]])		ifTrue:[self removeProperty: #cellInset]		ifFalse:[self setProperty: #cellInset toValue: aNumber].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/2/2000 14:57'!cellPositioning	"Layout specific. This property describes how the receiver should be layed out in its owner when the bounds of the cell assigned to the receiver do not exactly match its bounds. Possible values are:		#topLeft, #topRight, #bottomLeft, #bottomRight, #topCenter, #leftCenter, #rightCenter, #bottomCenter, #center 	which align the receiver's bounds with the cell at the given point."	^self valueOfProperty: #cellPositioning ifAbsent:[#center].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/2/2000 14:57'!cellPositioning: aSymbol	"Layout specific. This property describes how the receiver should be layed out in its owner when the bounds of the cell assigned to the receiver do not exactly match its bounds. Possible values are:		#topLeft, #topRight, #bottomLeft, #bottomRight, #topCenter, #leftCenter, #rightCenter, #bottomCenter, #center 	which align the receiver's bounds with the cell at the given point."	aSymbol == #center		ifTrue:[self removeProperty: #cellPositioning]		ifFalse:[self setProperty: #cellPositioning toValue: aSymbol].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 02:48'!cellPositioningString: aSymbol	^self layoutMenuPropertyString: aSymbol from: self cellPositioning! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:31'!cellSpacing	"Layout specific. This property describes how the cell size for each element in a list should be computed.		#globalRect - globally equal rectangular cells		#globalSquare - globally equal square cells		#localRect - locally (e.g., per row/column) equal rectangular cells		#localSquare - locally (e.g., per row/column) equal square cells		#none - cells are sized based on available row/column constraints	"	^self valueOfProperty: #cellSpacing ifAbsent:[#none]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:14'!cellSpacing: aSymbol	"Layout specific. This property describes how the cell size for each element in a list should be computed.		#globalRect - globally equal rectangular cells		#globalSquare - globally equal square cells		#localRect - locally (e.g., per row/column) equal rectangular cells		#localSquare - locally (e.g., per row/column) equal square cells		#none - cells are sized based on available row/column constraints	"	aSymbol == #none		ifTrue:[self removeProperty: #cellSpacing]		ifFalse:[self setProperty: #cellSpacing toValue: aSymbol].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 02:47'!cellSpacingString: aSymbol	^self layoutMenuPropertyString: aSymbol from: self cellSpacing! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 17:28'!disableTableLayout	"Layout specific. Disable laying out the receiver in table layout"	^self valueOfProperty: #disableTableLayout ifAbsent:[false]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 17:28'!disableTableLayout: aBool	"Layout specific. Disable laying out the receiver in table layout"	aBool == false		ifTrue:[self removeProperty: #disableTableLayout]		ifFalse:[self setProperty: #disableTableLayout toValue: aBool].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/31/2000 20:52'!hResizing	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	^self valueOfProperty: #hResizing ifAbsent:[#rigid]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/31/2000 20:52'!hResizing: aSymbol	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	aSymbol == #rigid		ifTrue:[self removeProperty: #hResizing]		ifFalse:[self setProperty: #hResizing toValue: aSymbol].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/31/2000 20:45'!hResizingString: aSymbol	^self layoutMenuPropertyString: aSymbol from: self hResizing! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:32'!layoutFrame	"Layout specific. Return the layout frame describing where the receiver should appear in a proportional layout"	^self valueOfProperty: #layoutFrame ifAbsent:[nil]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:16'!layoutFrame: aLayoutFrame	"Layout specific. Return the layout frame describing where the receiver should appear in a proportional layout"	aLayoutFrame == nil		ifTrue:[self removeProperty: #layoutFrame]		ifFalse:[self setProperty: #layoutFrame toValue: aLayoutFrame].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/30/2000 15:43'!layoutInset	"Return the extra inset for layouts"	^self valueOfProperty: #layoutInset ifAbsent:[0]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/30/2000 15:43'!layoutInset: aNumber	"Return the extra inset for layouts"	(aNumber notNil and:[aNumber isZero])		ifTrue:[self removeProperty: #layoutInset]		ifFalse:[self setProperty: #layoutInset toValue: aNumber].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:33'!layoutPolicy	"Layout specific. Return the layout policy describing how children of the receiver should appear."	extension == nil ifTrue:[^nil]. "shortcut for speed"	^self valueOfProperty: #layoutPolicy ifAbsent:[nil]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:18'!layoutPolicy: aLayoutPolicy	"Layout specific. Return the layout policy describing how children of the receiver should appear."	aLayoutPolicy == nil		ifTrue:[self removeProperty: #layoutPolicy]		ifFalse:[self setProperty: #layoutPolicy toValue: aLayoutPolicy].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:33'!listCentering	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of primary direction		#bottomRight - center at end of primary direction		#center - center in the middle of primary direction		#justified - insert extra space inbetween rows/columns	"	^self valueOfProperty: #listCentering ifAbsent:[#topLeft]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:19'!listCentering: aSymbol	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of primary direction		#bottomRight - center at end of primary direction		#center - center in the middle of primary direction		#justified - insert extra space inbetween rows/columns	"	aSymbol == #topLeft		ifTrue:[self removeProperty: #listCentering]		ifFalse:[self setProperty: #listCentering toValue: aSymbol].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 02:47'!listCenteringString: aSymbol	^self layoutMenuPropertyString: aSymbol from: self listCentering! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:33'!listDirection	"Layout specific. This property describes the direction in which a list-like layout should be applied. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop	indicating the direction in which any layout should take place"	^self valueOfProperty: #listDirection ifAbsent:[#topToBottom].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:21'!listDirection: aSymbol	"Layout specific. This property describes the direction in which a list-like layout should be applied. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop	indicating the direction in which any layout should take place"	aSymbol == #topToBottom		ifTrue:[self removeProperty: #listDirection]		ifFalse:[self setProperty: #listDirection toValue: aSymbol].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 02:47'!listDirectionString: aSymbol	^self layoutMenuPropertyString: aSymbol from: self listDirection! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:22'!listSpacing	"Layout specific. This property describes how the heights for different rows in a table layout should be handled.		#equal - all rows have the same height		#none - all rows may have different heights	"	^self valueOfProperty: #listSpacing ifAbsent:[#none]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:22'!listSpacing: aSymbol	"Layout specific. This property describes how the heights for different rows in a table layout should be handled.		#equal - all rows have the same height		#none - all rows may have different heights	"	aSymbol == #none		ifTrue:[self removeProperty: #listSpacing]		ifFalse:[self setProperty: #listSpacing toValue: aSymbol].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 02:47'!listSpacingString: aSymbol	^self layoutMenuPropertyString: aSymbol from: self listSpacing! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/2/2000 18:28'!maxCellSize	"Layout specific. This property specifies the maximum size of a table cell."	^self valueOfProperty: #maxCellSize ifAbsent:[SmallInteger maxVal asPoint]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/2/2000 18:28'!maxCellSize: aPoint	"Layout specific. This property specifies the maximum size of a table cell."	(aPoint == nil or:[aPoint y > SmallInteger maxVal asPoint])		ifTrue:[self removeProperty: #maxCellSize]		ifFalse:[self setProperty: #maxCellSize toValue: aPoint].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/2/2000 18:26'!minCellSize	"Layout specific. This property specifies the minimal size of a table cell."	^self valueOfProperty: #minCellSize ifAbsent:[0]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/2/2000 18:25'!minCellSize: aPoint	"Layout specific. This property specifies the minimal size of a table cell."	(aPoint == nil or:[aPoint isZero])		ifTrue:[self removeProperty: #minCellSize]		ifFalse:[self setProperty: #minCellSize toValue: aPoint].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/1/2000 23:28'!priorFullBounds	^self valueOfProperty: #priorFullBounds! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/1/2000 23:28'!priorFullBounds: aRect	^self setProperty: #priorFullBounds toValue: aRect! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:24'!reverseTableCells	"Layout specific. This property describes if the cells should be treated in reverse order of submorphs."	^self valueOfProperty: #reverseTableCells ifAbsent:[false]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:25'!reverseTableCells: aBool	"Layout specific. This property describes if the cells should be treated in reverse order of submorphs."	aBool == false		ifTrue:[self removeProperty: #reverseTableCells]		ifFalse:[self setProperty: #reverseTableCells toValue: aBool].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/2/2000 22:36'!rubberBandCells	"Layout specific. This property describes if a parent that is #shrinkWrapped around its children should ignore any #spaceFill children. E.g., when #rubberBandCells is true, the compound layout will always stay at the smallest available size, even though some child may be able to grow."	^self valueOfProperty: #rubberBandCells ifAbsent:[false]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/2/2000 22:37'!rubberBandCells: aBool	"Layout specific. This property describes if a parent that is #shrinkWrapped around its children should ignore any #spaceFill children. E.g., when #rubberBandCells is true, the compound layout will always stay at the smallest available size, even though some child may be able to grow."	aBool == false		ifTrue:[self removeProperty: #rubberBandCells]		ifFalse:[self setProperty: #rubberBandCells toValue: aBool].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/31/2000 20:53'!vResizing	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	^self valueOfProperty: #vResizing ifAbsent:[#rigid]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/31/2000 20:53'!vResizing: aSymbol	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	aSymbol == #rigid		ifTrue:[self removeProperty: #vResizing]		ifFalse:[self setProperty: #vResizing toValue: aSymbol].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/31/2000 20:45'!vResizingString: aSymbol	^self layoutMenuPropertyString: aSymbol from: self vResizing! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:27'!wrapCentering	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of secondary direction		#bottomRight - center at end of secondary direction		#center - center in the middle of secondary direction		#justified - insert extra space inbetween rows/columns	"	^self valueOfProperty: #wrapCentering ifAbsent:[#topLeft]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:28'!wrapCentering: aSymbol	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of secondary direction		#bottomRight - center at end of secondary direction		#center - center in the middle of secondary direction		#justified - insert extra space inbetween rows/columns	"	aSymbol == #topLeft		ifTrue:[self removeProperty: #wrapCentering]		ifFalse:[self setProperty: #wrapCentering toValue: aSymbol].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 03:00'!wrapCenteringString: aSymbol	^self layoutMenuPropertyString: aSymbol from: self wrapCentering! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:29'!wrapDirection	"Layout specific. This property describes the direction along which a list-like layout should be wrapped. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop		#none	indicating in which direction wrapping should occur. This direction must be orthogonal to the list direction, that is if listDirection is #leftToRight or #rightToLeft then wrapDirection must be #topToBottom or #bottomToTop and vice versa."	^self valueOfProperty: #wrapDirection ifAbsent:[#none]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 14:29'!wrapDirection: aSymbol	"Layout specific. This property describes the direction along which a list-like layout should be wrapped. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop		#none	indicating in which direction wrapping should occur. This direction must be orthogonal to the list direction, that is if listDirection is #leftToRight or #rightToLeft then wrapDirection must be #topToBottom or #bottomToTop and vice versa."	aSymbol == #none		ifTrue:[self removeProperty: #wrapDirection]		ifFalse:[self setProperty: #wrapDirection toValue: aSymbol].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 10/29/2000 03:00'!wrapDirectionString: aSymbol	^self layoutMenuPropertyString: aSymbol from: self wrapDirection ! !!AlignmentMorph methodsFor: 'initialization' stamp: 'ar 11/8/2000 23:50'!initialize	super initialize.	borderWidth _ 0.	self orientation: #horizontal.	"#horizontal or #vertical  or #free"	self centering: #topLeft.		"#topLeft, #center, or #bottomRight"	self hResizing: #spaceFill.		"#spaceFill, #shrinkWrap, or #rigid"	self vResizing: #spaceFill.		"#spaceFill, #shrinkWrap, or #rigid"	self inset: 2.					"pixels inset within owner's bounds"	self minCellSize: 0.				"minimum space between morphs; useful for tables"	layoutNeeded _ true.	color _ Color r: 0.8 g: 1.0 b: 0.8.	self rubberBandCells: true. "default"! !!AlignmentMorph methodsFor: 'accessing' stamp: 'ar 11/8/2000 23:32'!centering: aSymbol	"Set the minor dimension alignment to #topLeft, #center, or #bottomRight."	centering _ aSymbol.	self cellPositioning: #topLeft. "default"	aSymbol == #topLeft 		ifTrue:[self wrapCentering: #topLeft].	aSymbol == #bottomRight 		ifTrue:[self wrapCentering: #bottomRight].	aSymbol == #center 		ifTrue:[self wrapCentering: #center.				self orientation == #horizontal					ifTrue:[self cellPositioning: #leftCenter]					ifFalse:[self cellPositioning: #topCenter]].! !!AlignmentMorph methodsFor: 'accessing' stamp: 'ar 11/8/2000 23:35'!hResizing: aSymbol	"Set the horizontal resizing style to #spaceFill, #shrinkWrap, or #rigid."	hResizing _ aSymbol.	(aSymbol == #spaceFill and:[owner isNil or:[owner isAlignmentMorph not and:[(owner isKindOf: SystemWindow) not]]])		ifTrue:[super hResizing: #shrinkWrap]		ifFalse:[super hResizing: aSymbol].! !!AlignmentMorph methodsFor: 'accessing' stamp: 'ar 11/8/2000 23:33'!inset: anInteger	"Set the amount of padding within my bounds to the given amount."	inset _ anInteger.	(inset isNumber or:[inset isPoint]) 		ifTrue:[self layoutInset: inset].! !!AlignmentMorph methodsFor: 'accessing' stamp: 'ar 11/8/2000 23:33'!minCellSize: anInteger	"Set the minium space per submorph to the given size. Useful for making tables."	minCellSize _ anInteger.	(minCellSize isNumber or:[minCellSize isPoint]) 		ifTrue:[super minCellSize: minCellSize].! !!AlignmentMorph methodsFor: 'accessing' stamp: 'ar 11/8/2000 23:35'!orientation: aSymbol	"Set the major layout dimension to #horizontal or #vertical or #free"	orientation _ aSymbol.	(aSymbol == #horizontal or:[aSymbol == #vertical])		ifTrue:[self layoutPolicy: TableLayout new]		ifFalse:[self layoutPolicy: nil].	aSymbol == #horizontal 		ifTrue:[self listDirection: #leftToRight].	aSymbol == #vertical 		ifTrue:[self listDirection: #topToBottom].! !!AlignmentMorph methodsFor: 'accessing' stamp: 'ar 11/8/2000 23:35'!vResizing: aSymbol	"Set the vertical resizing style to #spaceFill, #shrinkWrap, or #rigid."	vResizing _ aSymbol.	(aSymbol == #spaceFill and:[owner isNil or:[owner isAlignmentMorph not and:[(owner isKindOf: SystemWindow) not]]])		ifTrue:[super vResizing: #shrinkWrap]		ifFalse:[super vResizing: aSymbol].! !!AlignmentMorph methodsFor: 'menu' stamp: 'ar 11/8/2000 22:45'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: (self dragNDropEnabled ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #toggleDragNDrop.! !!AlignmentMorph methodsFor: 'private' stamp: 'ar 11/8/2000 23:42'!ownerChanged	super ownerChanged.	"Make the #shrinkWrap/#spaceFill thing work"	self hResizing == hResizing ifFalse:[self hResizing: hResizing].	self vResizing == vResizing ifFalse:[self vResizing: vResizing].! !!AlignmentMorph methodsFor: 'converting' stamp: 'ar 11/9/2000 14:35'!convertAlignment	(orientation == #horizontal or:[orientation == #vertical])		ifTrue:[self layoutPolicy: TableLayout new].	self cellPositioning: #topLeft. "default"	self rubberBandCells: true. "default"	orientation == #horizontal 		ifTrue:[self listDirection: #leftToRight].	orientation == #vertical 		ifTrue:[self listDirection: #topToBottom].	centering == #topLeft 		ifTrue:[self wrapCentering: #topLeft].	centering == #bottomRight 		ifTrue:[self wrapCentering: #bottomRight].	centering == #center 		ifTrue:[self wrapCentering: #center.				orientation == #horizontal					ifTrue:[self cellPositioning: #leftCenter]					ifFalse:[self cellPositioning: #topCenter]].	(hResizing == #spaceFill and:[owner isNil or:[owner isAlignmentMorph not and:[(owner isKindOf: SystemWindow) not]]])		ifTrue:[super hResizing: #shrinkWrap]		ifFalse:[super hResizing: hResizing].	(vResizing == #spaceFill and:[owner isNil or:[owner isAlignmentMorph not and:[(owner isKindOf: SystemWindow) not]]])		ifTrue:[super vResizing: #shrinkWrap]		ifFalse:[super vResizing: vResizing].	(inset isNumber or:[inset isPoint]) 		ifTrue:[self layoutInset: inset].	(minCellSize isNumber or:[minCellSize isPoint]) 		ifTrue:[super minCellSize: minCellSize].	(self hasProperty: #clipToOwnerWidth)		ifTrue:[self clipSubmorphs: true].! !!AlignmentMorph class methodsFor: 'instance creation' stamp: 'ar 11/1/2000 17:35'!newColumn	^ self new		orientation: #vertical;		hResizing: #spaceFill;		extent: 1@1;		vResizing: #spaceFill! !!AlignmentMorph class methodsFor: 'instance creation' stamp: 'ar 11/1/2000 17:35'!newRow	^ self new		orientation: #horizontal;		hResizing: #spaceFill;		vResizing: #spaceFill;		extent: 1@1;		borderWidth: 0! !!AlignmentMorph class methodsFor: 'instance creation' stamp: 'ar 11/1/2000 17:34'!newSpacer: aColor	"Answer a space-filling instance of me of the given color."	^ self new		hResizing: #spaceFill;		vResizing: #spaceFill;		inset: 0;		borderWidth: 0;		extent: 1@1;		color: aColor.! !!AlignmentMorph class methodsFor: 'instance creation' stamp: 'ar 11/1/2000 17:34'!newVariableTransparentSpacer	"Answer a space-filling instance of me of the given color."	^ self new		hResizing: #spaceFill;		vResizing: #spaceFill;		inset: 0;		borderWidth: 0;		extent: 1@1;		color: Color transparent! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/8/2000 22:49'!book: aBookMorph morphsToSort: morphList	| innerBounds |	book _ aBookMorph.	pageHolder removeAllMorphs.	pageHolder addAllMorphs: morphList.	pageHolder extent: pageHolder width@pageHolder fullBounds height.	innerBounds _ Rectangle merging: (morphList collect: [:m | m bounds]).	pageHolder extent: innerBounds extent + pageHolder borderWidth + 6.! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/8/2000 22:42'!xxxfixLayout	| trans |	trans _ self myTransformation.	trans ifNil:[^super fixLayout].	trans bounds: self innerBounds.! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'ar 11/4/2000 23:21'!setPasswordQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight acceptOnCR: acceptBoolean	| pane |	self setQuery: queryString 		initialAnswer: initialAnswer 		answerHeight: answerHeight 		acceptOnCR: acceptBoolean.	pane _ self submorphNamed: 'textPane'.	pane font: (StrikeFont passwordFontSize: 12).! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'ar 11/6/2000 01:13'!setQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight acceptOnCR: acceptBoolean	| query frame topOffset accept cancel bottomOffset |	response _ initialAnswer.	done _ false.	self removeAllMorphs.	self layoutPolicy: ProportionalLayout new.	query _ TextMorph new contents: queryString.	query setNameTo: 'query'.	query lock.		frame _ LayoutFrame new.		frame topFraction: 0.0; topOffset: 2.		frame leftFraction: 0.5; leftOffset: (query width // 2) negated.	query layoutFrame: frame.	self addMorph: query.	topOffset _ query height + 4.	accept _ SimpleButtonMorph new target: self; color: Color veryLightGray.	accept label: 'Accept(s)'; actionSelector: #accept.	accept setNameTo: 'accept'.		frame _ LayoutFrame new.		frame rightFraction: 0.5; rightOffset: 10; bottomFraction: 1.0; bottomOffset: 2.	accept layoutFrame: frame.	self addMorph: accept.	cancel _ SimpleButtonMorph new target: self; color: Color veryLightGray.	cancel label: 'Cancel(l)'; actionSelector: #cancel.	cancel setNameTo: 'cancel'.		frame _ LayoutFrame new.		frame leftFraction: 0.5; leftOffset: 10; bottomFraction: 1.0; bottomOffset: 2.	cancel layoutFrame: frame.	self addMorph: cancel.	bottomOffset _ (accept height max: cancel height) + 4.	textPane _ PluggableTextMorph on: self		text: #response		accept: #response:		readSelection: #selectionInterval		menu: #codePaneMenu:shifted:.	textPane hResizing: #spaceFill; vResizing: #spaceFill.	textPane borderWidth: 2.	textPane hasUnacceptedEdits: true.	textPane acceptOnCR: acceptBoolean.	textPane setNameTo: 'textPane'.		frame _ LayoutFrame new.		frame leftFraction: 0.0; rightFraction: 1.0; topFraction: 0.0; topOffset: topOffset; bottomFraction: 1.0; bottomOffset: bottomOffset.	textPane layoutFrame: frame.	self addMorph: textPane.	self extent: (200 max: query width) + 4 @ (topOffset + answerHeight + 4 + bottomOffset).! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/31/2000 19:14'!doGrow: evt with: growHandle	"Called while the mouse is down in the grow handle"	| newExtent extentToUse |	evt hand obtainHalo: self.	newExtent _ (target pointFromWorld: (target griddedPoint: evt cursorPoint - positionOffset))								- target topLeft.	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].	target renderedMorph extent: (extentToUse _ newExtent).	growHandle position: evt cursorPoint - (growHandle extent // 2).	self layoutChanged.	(self valueOfProperty: #commandInProgress) doIfNotNil:  		[:cmd | "Update the final extent"		cmd redoTarget: target selector: #extent: argument: extentToUse]! !!MenuLineMorph methodsFor: 'layout' stamp: 'ar 11/8/2000 23:09'!convertAlignment	self hResizing: #spaceFill; vResizing: #spaceFill.! !!MenuLineMorph methodsFor: 'layout' stamp: 'ar 11/1/2000 00:55'!xMinHeight	^ 2! !!MenuLineMorph methodsFor: 'layout' stamp: 'ar 10/31/2000 20:25'!xMinWidth	^ 10! !!MenuLineMorph methodsFor: 'initialize' stamp: 'ar 11/8/2000 23:09'!initialize	super initialize.	self hResizing: #spaceFill; vResizing: #spaceFill.! !!PasteUpMorph methodsFor: 'initialization' stamp: 'ar 11/9/2000 15:09'!initialize	owner _ nil.	submorphs _ EmptyArray.	borderWidth _ 1.	borderColor _ Color r: 0.861 g: 1.0 b: 0.722.	color _ Color r: 0.8 g: 1.0 b: 0.6.	bounds _ 0@0 corner: 50@40.	cursor _ 1.	padding _ 3.	self enableDragNDrop.	self isWorldMorph ifTrue: [self setProperty: #automaticPhraseExpansion toValue: true].	self clipSubmorphs: true.! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 11/9/2000 13:48'!acceptDroppingMorph: dropped event: evt	"The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"	| mm tfm aMorph |	aMorph _ self morphToDropFrom: dropped.	self isWorldMorph		ifTrue:["Add the given morph to this world and start stepping it if it wants to be."				self addMorphFront: aMorph.				(aMorph fullBounds intersects: self viewBox) ifFalse:					[self beep.  aMorph position: self bounds center]]		ifFalse:[super acceptDroppingMorph: dropped event: evt].	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	aMorph allMorphsDo:  "Establish any penDown morphs in new world"		[:m | m player ifNotNil:			[m player getPenDown ifTrue:				[((mm _ m player costume) notNil and: [(tfm _ mm owner transformFrom: self) notNil])					ifTrue: [self noteNewLocation: (tfm localPointToGlobal: mm referencePosition)									forPlayer: m player]]]].	self isPartsBin		ifTrue:			[aMorph isPartsDonor: true.			aMorph stopSteppingSelfAndSubmorphs.			aMorph suspendEventHandler]		ifFalse:			[self world startSteppingSubmorphsOf: aMorph].	self presenter morph: aMorph droppedIntoPasteUpMorph: self.	self showingListView ifTrue:		[self sortSubmorphsBy: (self valueOfProperty: #sortOrder).		self currentWorld abandonAllHalos]! !!PasteUpMorph methodsFor: 'layout' stamp: 'ar 11/9/2000 18:21'!convertAlignment	self clipSubmorphs: true.	(autoLineLayout == true) ifTrue:[		self layoutPolicy: TableLayout new.		self layoutInset: 8; cellInset: 4.		self listDirection: #leftToRight; wrapDirection: #topToBottom.		self xMinHeight: self height.	] ifFalse:[		self layoutPolicy: nil.		self layoutInset: 0; cellInset: 0.	].	(resizeToFit == true) ifTrue:[		self vResizing: #shrinkWrap.	] ifFalse:[		self vResizing: #rigid.	].! !!PasteUpMorph methodsFor: 'layout' stamp: 'ar 11/9/2000 13:43'!layoutChanged	"The receiver's layout changed; inform above and below"	super layoutChanged.	(self valueOfProperty: #SqueakPage) ifNotNil: [		self setProperty: #pageDirty toValue: true].		"I am the morph of a SqueakPage, I have changed and 		need to be written out again"! !!PasteUpMorph methodsFor: 'options' stamp: 'ar 11/9/2000 12:48'!autoLineLayout	| layout |	layout _ self layoutPolicy ifNil:[^false].	layout isTableLayout ifFalse:[^false].	self listDirection == #leftToRight ifFalse:[^false].	self wrapDirection == #topToBottom ifFalse:[^false].	^true! !!PasteUpMorph methodsFor: 'options' stamp: 'ar 11/9/2000 15:07'!autoLineLayout: aBoolean	"Make the receiver be viewed with auto-line-layout, which means that its submorphs will be laid out left-to-right and then top-to-bottom in the manner of a word processor, or (if aBoolean is false,) cease applying auto-line-layout"	aBoolean ifTrue:		[self viewingNormally ifTrue: [self saveBoundsOfSubmorphs]].	aBoolean ifTrue:[		self layoutPolicy: TableLayout new.		self layoutInset: 8; cellInset: 4.		self listDirection: #leftToRight; wrapDirection: #topToBottom.	] ifFalse:[		self layoutPolicy: nil.		self layoutInset: 0; cellInset: 0.	].! !!PasteUpMorph methodsFor: 'options' stamp: 'ar 11/8/2000 22:36'!behaveLikeHolder 	self resizeToFit: true; autoLineLayout: true; indicateCursor: true! !!PasteUpMorph methodsFor: 'options' stamp: 'ar 11/8/2000 22:36'!behaveLikeHolder: aBoolean 	"Change the receiver's viewing properties such that they conform to what we commonly call a Holder, viz: resize-to-fit, do auto-line-layout, and indicate the 'cursor'"	self resizeToFit: aBoolean; autoLineLayout: aBoolean; indicateCursor: aBoolean	! !!PasteUpMorph methodsFor: 'options' stamp: 'ar 11/9/2000 12:49'!resizeToFit	^self vResizing == #shrinkWrap! !!PasteUpMorph methodsFor: 'options' stamp: 'ar 11/9/2000 12:49'!resizeToFit: aBoolean	aBoolean ifTrue:[		self vResizing: #shrinkWrap.	] ifFalse:[		self vResizing: #rigid.	].! !!PasteUpMorph methodsFor: 'options' stamp: 'ar 11/8/2000 22:37'!toggleAutoLineLayout	"Toggle the auto-line-layout setting"	self autoLineLayout: self autoLineLayout not.	self autoLineLayout ifFalse: [self restoreBoundsOfSubmorphs].! !!PasteUpMorph methodsFor: 'options' stamp: 'ar 11/8/2000 22:37'!toggleIndicateCursor	indicateCursor _ self indicateCursor not.	self changed.! !!PasteUpMorph methodsFor: 'viewing' stamp: 'ar 11/9/2000 13:49'!imposeListViewSortingBy: sortOrderSymbol retrieving: fieldListSelectors	"Establish a list view of the receiver's contents, sorting the contents by the criterion represented by sortOrderSymbol, and displaying readouts as indicated by the list of field selectors."	| rep |	self setProperty: #sortOrder toValue: sortOrderSymbol.	self setProperty: #fieldListSelectors toValue: fieldListSelectors.	self showingListView ifFalse:		[self autoLineLayout ifFalse: [self saveBoundsOfSubmorphs].		self setProperty: #showingListView toValue: true.		self layoutPolicy: TableLayout new.		self layoutInset: 2; cellInset: 2.		self listDirection: #topToBottom.		self wrapDirection: #none].	self submorphs "important that it be a copy" do:		[:aMorph | 			rep _ aMorph listViewLineForFieldList: fieldListSelectors.			rep hResizing: #spaceFill.			self replaceSubmorph: aMorph by: rep].	self sortSubmorphsBy: (self valueOfProperty: #sortOrder).! !!PasteUpMorph methodsFor: 'viewing' stamp: 'ar 11/9/2000 13:46'!sortSubmorphsBy: sortOrderSymbol	"Sort the receiver's submorphs by the criterion indicated in the provided symbol"	submorphs _ submorphs sortBy:[:a :b | (a perform: sortOrderSymbol) <= (b perform: sortOrderSymbol)].	self layoutChanged.! !!PasteUpMorph methodsFor: 'viewing' stamp: 'ar 11/9/2000 13:50'!viewByIcon	"The receiver has been being viewed in some constrained layout view; now restore it to its normal x-y-layout view"	|  oldSubs |	self showingListView		ifTrue:			[oldSubs _ submorphs.			self removeAllMorphs.			self layoutPolicy: nil.			oldSubs do:				[:aSubmorph |					self addMorphBack:  aSubmorph objectRepresented].			self restoreBoundsOfSubmorphs.			self removeProperty: #showingListView]		ifFalse:			[self autoLineLayout == true ifTrue: [self toggleAutoLineLayout]]! !!PasteUpMorph methodsFor: 'viewing' stamp: 'ar 11/8/2000 22:37'!viewNonOverlapping	"Make the receiver show its contents as full-size morphs laid out left-to-right and top-to-bottom to be non-overlapping."	self viewingNormally ifTrue:		[self saveBoundsOfSubmorphs].	self showingListView ifTrue:		[self viewByIcon.		self removeProperty: #showingListView].	self autoLineLayout: true.! !!PianoRollScoreMorph methodsFor: 'initialization' stamp: 'ar 11/9/2000 15:10'!convertAlignment	self clipSubmorphs: true.! !!PianoRollScoreMorph methodsFor: 'initialization' stamp: 'ar 11/9/2000 15:10'!initialize	super initialize.	borderWidth _ 1.	color _ Color white.	self extent: 400@300.	showMeasureLines _ true.	showBeatLines _ false.	self timeSignature: 4 over: 4.	self clipSubmorphs: true.! !!PlayingCardDeck methodsFor: 'layout' stamp: 'ar 11/8/2000 22:42'!xxxfixLayout	layout = #stagger 	ifTrue: [^self fixLayoutStagger].	layout= #pile		ifTrue: [^self fixLayoutPile].	^super fixLayout.! !!PlayingCardDeck methodsFor: 'layout' stamp: 'ar 11/8/2000 22:52'!xxxminHeight	"Return the minimum height for this morph."	| spaceNeeded |	self vResizing = #shrinkWrap ifFalse: [^super minHeight].	submorphs isEmpty ifTrue: [^ self minHeightWhenEmpty].	self orientation == #horizontal ifTrue: [^super minHeight].	self orientation == #vertical ifTrue:		[spaceNeeded _ 2 * (self inset + borderWidth).		spaceNeeded _ spaceNeeded + (PlayingCardMorph height).		layout = #stagger ifTrue: [spaceNeeded _ spaceNeeded + 									((self submorphCount - 1) * self staggerOffset)]].	^ spaceNeeded! !!Point methodsFor: 'testing' stamp: 'ar 10/29/2000 19:02'!isZero	^x isZero and:[y isZero]! !!Presenter methodsFor: 'palette & parts bin' stamp: 'ar 11/8/2000 22:37'!customPagesForPartsBin	| aPage aWindow  pu pageList aClass |	pageList _ OrderedCollection new.	pageList add: (aPage _ self newPageForStandardPartsBin).	aPage addMorphBack: (PasteUpMorph authoringPrototype color: (Color r: 0.96 g: 0.96 b: 0.96)).	aPage addMorphBack: TabbedPalette authoringPrototype.	aPage addMorphBack: BookMorph authoringPrototype.	aPage addMorphBack: ScriptingSystem prototypicalHolder.	aPage addMorphBack: Morph new previousPageButton markAsPartsDonor.	aPage addMorphBack: Morph new nextPageButton markAsPartsDonor.	#(DatumMorph) do:		[:aName | (aClass _ Smalltalk at: aName ifAbsent: [nil]) ifNotNil:			[aPage addMorphBack: aClass authoringPrototype]].	pageList add: (aPage _ self newPageForStandardPartsBin).	aWindow _ Browser new openAsMorphEditing: nil.	aWindow setLabel: 'System Browser'.	aPage addMorphBack: aWindow applyModelExtent.	aWindow _ PackageBrowser new openAsMorphEditing: nil.	aWindow setLabel: 'Package Browser'.	aPage addMorphBack: aWindow applyModelExtent.	aWindow _ Workspace new embeddedInMorphicWindowLabeled: 'Workspace'.	aPage addMorphBack: aWindow applyModelExtent.	aPage addMorphBack: FileList openAsMorph applyModelExtent.	aPage addMorphBack: DualChangeSorter new morphicWindow applyModelExtent.	aPage addMorphBack: ChangeSorter new morphicWindow applyModelExtent.	aWindow _ SelectorBrowser new morphicWindow.	aWindow setLabel: 'Selector Browser'.	aPage addMorphBack: aWindow.	pageList add: (aPage _ self newPageForStandardPartsBin).	aPage addMorphBack: ScriptingSystem newScriptingSpace.	aPage addMorphBack: ScriptingSystem scriptControlButtons.	aPage addMorphBack: TrashCanMorph new.	aPage addMorphBack: PasteUpMorph authoringPrototype.	aPage addMorphBack: ((pu _ PasteUpMorph newSticky) embeddedInMorphicWindowLabeled: 'assembly').	pu color: (Color r: 0.839 g: 1.0 b: 0.935).	pageList do:[:page | page  replaceTallSubmorphsByThumbnails].	^ pageList! !!Presenter methodsFor: 'palette & parts bin' stamp: 'ar 11/8/2000 22:37'!newStandardPartsBinTitled: aTitle includeControls: includeControls	| aBook aPage aSize |	aSize _ 360 @ 190.	aBook _ BookMorph new color: Color blue veryMuchLighter.	aBook borderWidth: 0.	aBook removeEverything.	aBook disableDragNDrop.	includeControls ifTrue:		[aBook addMorphBack: (aBook makeMinimalControlsWithColor: Color transparent title: aTitle)].	self classNamesForStandardPartsBin do:		[:aList |			aPage _ self newPageForStandardPartsBin.			aList do:				[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].			aPage replaceTallSubmorphsByThumbnails.			aBook insertPage: aPage pageSize: aSize].	self customPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	self tilesPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	aBook goToPage: 1.	aBook currentPage addMorphBack: RectangleMorph roundRectPrototype.	^ aBook! !!Presenter methodsFor: 'palette & parts bin' stamp: 'ar 11/8/2000 22:37'!pageOfSampleWindowsOfExtent: aPoint	| aPage aWindow pu |	aPage _ self newPageForStandardPartsBin.	aPage extent: aPoint.	aWindow _ Browser new openAsMorphEditing: nil.	aWindow setLabel: 'System Browser'.	aPage addMorphBack: aWindow.	aWindow _ Workspace new embeddedInMorphicWindowLabeled: 'Workspace'.	aPage addMorphBack: aWindow.	aPage addMorphBack: FileList openAsMorph.	aWindow _ SelectorBrowser new morphicWindow.	aWindow setLabel: 'Selector Browser'.	aPage addMorphBack: aWindow.	aPage addMorphBack: ((pu _ PasteUpMorph newSticky borderInset) embeddedInMorphicWindowLabeled: 'assembly').	pu color: (Color r: 0.839 g: 1.0 b: 0.935).	aPage  replaceTallSubmorphsByThumbnails.	^ aPage! !!Presenter methodsFor: 'palette & parts bin' stamp: 'ar 11/8/2000 22:37'!tilesPagesForPartsBin	| aPage bools aTile aPhrase |	aPage _ self newPageForStandardPartsBin padding: 30.	bools _ self booleanTiles.	aPage addMorphBack: bools first markAsPartsDonor.	aPage addMorphBack: bools last markAsPartsDonor.	aPage addMorphBack: self arithmeticTiles first markAsPartsDonor.	aPage addMorphBack: RandomNumberTile new markAsPartsDonor.	#(('(Sensor anyButtonPressed)' 'button down?')	('(Sensor noButtonPressed)' 'button up?')	"('(Sensor keyboardPressed)' 'key hit?')   sucker doesn't work for some reason") do:		[:pair |			aPhrase _ SystemQueryPhrase new.			aTile _ BooleanTile new.			aTile setExpression: pair first label: pair second.			aPhrase addMorph: aTile.			aPage addMorphBack: aPhrase].	aPage enforceTileColorPolicy.	aPage replaceTallSubmorphsByThumbnails.	^ OrderedCollection with: aPage  "room to grow"! !!ProportionalLayout methodsFor: 'testing' stamp: 'ar 10/29/2000 01:29'!isProportionalLayout	^true! !!ProportionalLayout methodsFor: 'layout' stamp: 'ar 10/29/2000 01:24'!layout: aMorph in: newBounds	"Compute the layout for the given morph based on the new bounds"	aMorph submorphsDo:[:m| m layoutProportionallyIn: newBounds].! !!ProportionalLayout methodsFor: 'layout' stamp: 'ar 11/4/2000 22:47'!minExtentOf: aMorph in: newBounds	"Return the minimal size aMorph's children would require given the new bounds"	| min extent frame |	min _ 0@0.	aMorph submorphsDo:[:m|		"Map the minimal size of the child through the layout frame.		Note: This is done here and not in the child because its specific		for proportional layouts. Perhaps we'll generalize this for table		layouts but I'm not sure how and when."		extent _ m minExtent.		frame _ m layoutFrame.		frame ifNotNil:[extent _ (frame layout: (0@0 extent: extent) in: newBounds) extent].		min _ min max: extent].	^min! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ar 10/29/2000 02:41'!outsetBy: delta 	"Answer a Rectangle that is outset from the receiver by delta. delta is a 	Rectangle, Point, or scalar."	(delta isKindOf: Rectangle)		ifTrue: [^Rectangle 					origin: origin - delta origin 					corner: corner + delta corner]		ifFalse: [^Rectangle 					origin: origin - delta 					corner: corner + delta]! !!Rectangle methodsFor: 'testing' stamp: 'ar 10/29/2000 19:03'!isZero	^origin isZero and:[corner isZero]! !!SameGameBoard methodsFor: 'initialization' stamp: 'ar 11/8/2000 22:37'!initialize	super initialize.	target _ nil.	actionSelector _ #selection.	arguments _ #().	self hResizing: #rigid.	self vResizing: #rigid.	borderWidth _ 2.	borderColor _ Color black.	rows _ self preferredRows.	columns _ self preferredColumns.	color _ Color gray.	palette _ (Color wheel: self preferredTileTypes + 1) asOrderedCollection.	flashColor _ palette removeLast.	flash _ false.	self extent: self protoTile extent * (columns @ rows).	self resetBoard.! !!SameGameBoard methodsFor: 'private' stamp: 'ar 11/8/2000 22:42'!xxxfixLayout	"add or remove new protoTile submorphs to fill out my new bounds"	| newSubmorphs requiredSubmorphs count r c |	columns _ self width // protoTile width.	rows _ self height // protoTile height.	requiredSubmorphs _ rows * columns.	newSubmorphs _ OrderedCollection new.	r _ 0.	c _ 0.	self submorphCount > requiredSubmorphs		ifTrue: "resized smaller -- delete rows or columns"			[count _ 0.			submorphs do:				[:m | 				count < requiredSubmorphs					ifTrue:						[m position: self position + (protoTile extent * (c @ r)).						m arguments: (Array with: c @ r).						newSubmorphs add: m]					ifFalse: [m privateOwner: nil].				count _ count + 1.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]]		ifFalse: "resized larger -- add rows or columns"			[submorphs do:				[:m |				m position: self position + (self protoTile extent * (c @ r)).				m arguments: (Array with: c @ r).				newSubmorphs add: m.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]].			1 to: (requiredSubmorphs - self submorphCount) do:				[:m |				newSubmorphs add:					(protoTile copy						position: self position + (self protoTile extent * (c @ r));						actionSelector: #tileClickedAt:newSelection:;						arguments: (Array with: c @ r);						target: self;						privateOwner: self).				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]].	submorphs _ newSubmorphs asArray.! !!Scamper methodsFor: 'window definition' stamp: 'ar 11/8/2000 22:48'!buttonRowPane	"Create and return a pane of navigation buttons."	| buttonRow |	buttonRow _ AlignmentMorph new		borderWidth: 0;		inset: 0;		hResizing: #spaceFill;		centering: #center;		clipSubmorphs: true;		addTransparentSpacerOfSize: (5@0).		buttonRow 		addMorphBack: (self simpleButtonNamed: 'Back' action: #back text: self backButtonText); 		addTransparentSpacerOfSize: (5@0);		addMorphBack: (self simpleButtonNamed: 'Forward' action: #forward text: self forwardButtonText); 		addTransparentSpacerOfSize: (5@0);		addMorphBack: (self simpleButtonNamed: 'History' action: #displayHistory text: self historyButtonText); 		addTransparentSpacerOfSize: (5@0);		addMorphBack: (self simpleButtonNamed: 'Reload' action: #reload text: self reloadButtonText); 		addTransparentSpacerOfSize: (5@0);		addMorphBack: (self simpleButtonNamed: 'Home' action: #visitStartPage text: self homeButtonText); 		addTransparentSpacerOfSize: (5@0);		addMorphBack: (self simpleButtonNamed: 'Stop!!' action: #stopEverything text: self stopButtonText); 		addTransparentSpacerOfSize: (5@0).	^buttonRow! !!ScriptEditorMorph methodsFor: 'other' stamp: 'ar 10/31/2000 20:25'!xMinWidth	^160! !!ScriptEditorMorph methodsFor: 'other' stamp: 'ar 11/8/2000 22:52'!xxxminHeight	| extra |	extra _ 2 * (self inset + borderWidth).	^ (super minHeight - extra max: TileMorph defaultH) + extra! !!ScrollPane methodsFor: 'geometry' stamp: 'ar 11/8/2000 21:11'!minExtent	| extent |	extent _ super minExtent.	self flag: #arNote. "quick hack for excluding the retractable scrollbar area"	self isRetractableScrollbarShowing ifTrue:[		extent _ extent x - scrollBar fullBounds extent x @ extent y.	].	^extent! !!ScrollPane methodsFor: 'scrolling' stamp: 'ar 11/8/2000 21:11'!isRetractableScrollbarShowing	"Return true if a retractable scroll bar is currently showing"	retractableScrollBar ifFalse:[^false].	^submorphs includes: scrollBar! !!StringMorph methodsFor: 'layout' stamp: 'ar 11/1/2000 00:35'!xMinHeight	^self fontToUse height! !!MenuItemMorph methodsFor: 'initialization' stamp: 'ar 11/8/2000 23:08'!initialize	super initialize.	bounds _ 0@0 extent: 10@10.	color _ Color black.	contents _ ''.	hasFocus _ false.	isEnabled _ true.	subMenu _ nil.	isSelected _ false.	target _ nil.	selector _ nil.	arguments _ nil.	font _ Preferences standardMenuFont.	self hResizing: #spaceFill; vResizing: #shrinkWrap.! !!MenuItemMorph methodsFor: 'layout' stamp: 'ar 11/8/2000 23:08'!convertAlignment	self hResizing: #spaceFill; vResizing: #shrinkWrap.! !!MenuItemMorph methodsFor: 'layout' stamp: 'ar 11/1/2000 02:00'!xMinHeight	^ self fontToUse height! !!MenuItemMorph methodsFor: 'layout' stamp: 'ar 10/31/2000 20:26'!xMinWidth	| scanner |	scanner _ DisplayScanner quickPrintOn: Display box: Display boundingBox font: self fontToUse.	^ (scanner stringWidth: contents) + (subMenu == nil ifTrue: [0] ifFalse: [10])! !!SystemWindow methodsFor: 'initialization' stamp: 'ar 11/9/2000 01:05'!addCloseBox	| frame |	closeBox _ SimpleButtonMorph new borderWidth: 0;			label: 'X' font: Preferences standardButtonFont; color: Color transparent;			actionSelector: #closeBoxHit; target: self; extent: 14@14.	frame _ LayoutFrame new.	frame leftFraction: 0; leftOffset: 4; topFraction: 0; topOffset: 1.	closeBox layoutFrame: frame.	self addMorph: closeBox.! !!SystemWindow methodsFor: 'initialization' stamp: 'ar 11/9/2000 01:05'!addMenuControl"NB: for the moment, we always supply balloon help for this control, until people get used to it; eventually, we mays switch to showing this balloon help only in novice mode, as we do for the other standard window controls."	| frame |	menuBox _ IconicButton new borderWidth: 0;			labelGraphic: (ScriptingSystem formAtKey: 'TinyMenu'); color: Color transparent; 			actWhen: #buttonDown;			actionSelector: #offerWindowMenu; target: self;			setBalloonText: 'window menu'.	frame _ LayoutFrame new.	frame leftFraction: 0; leftOffset: 19; topFraction: 0; topOffset: 1.	menuBox layoutFrame: frame.	self addMorph: menuBox.! !!SystemWindow methodsFor: 'initialization' stamp: 'ar 11/9/2000 01:36'!initialize	| aFont frame |	super initialize.	allowReframeHandles := true.	labelString ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	borderColor _ #raised.	borderWidth _ 1.	color _ Color black.	self layoutPolicy: ProportionalLayout new.	label _ StringMorph new contents: labelString;			font: Preferences windowTitleFont emphasis: 1.	frame _ LayoutFrame new.	frame leftFraction: 0.5; topFraction: 0; leftOffset: label width negated // 2.	label layoutFrame: frame.	"Add collapse box so #labelHeight will work"	aFont _ Preferences standardButtonFont.	collapseBox _ SimpleButtonMorph new borderWidth: 0;			label: 'O' font: aFont; color: Color transparent;			actionSelector: #collapseOrExpand; target: self; extent: 14@14.	frame _ LayoutFrame new.	frame rightFraction: 1; topFraction: 0; rightOffset: 1; topOffset: 1.	collapseBox layoutFrame: frame.	stripes _ Array with: (RectangleMorph newBounds: bounds)  "see extent:"				with: (RectangleMorph newBounds: bounds).	frame _ LayoutFrame new.	frame leftFraction: 0; topFraction: 0; rightFraction: 1;			leftOffset: 1; topOffset: 1; rightOffset: 1.	stripes first layoutFrame: frame.	stripes first height: self labelHeight - 2.	stripes first hResizing: #spaceFill.	frame _ LayoutFrame new.	frame leftFraction: 0; topFraction: 0; rightFraction: 1;			leftOffset: 3; topOffset: 3; rightOffset: 3.	stripes last layoutFrame: frame.	stripes last height: self labelHeight - 6.	stripes last hResizing: #spaceFill.	self addMorph: (stripes first borderWidth: 1).	self addMorph: (stripes second borderWidth: 2).	self setLabelWidgetAllowance.	self addCloseBox.	self addMenuControl.	self addMorph: label.	self addMorph: collapseBox.	Preferences noviceMode ifTrue:		[closeBox ifNotNil: [closeBox setBalloonText: 'close window'].		menuBox ifNotNil: [menuBox setBalloonText: 'window menu'].		collapseBox ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].	self on: #mouseEnter send: #spawnReframeHandle: to: self.	self on: #mouseLeave send: #spawnReframeHandle: to: self.	label on: #mouseDown send: #relabelEvent: to: self.	self extent: 300@200.	mustNotClose _ false.	updatablePanes _ Array new.! !!SystemWindow methodsFor: 'geometry' stamp: 'ar 11/9/2000 01:24'!extent: newExtent 	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	self setStripeColorsFrom: self paneColorToUse.	label fitContents; setWidth: (label width min: bounds width - self labelWidgetAllowance).	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds]! !!SystemWindow methodsFor: 'geometry' stamp: 'ar 11/9/2000 01:35'!setPaneRectsFromBounds	"Reset proportional specs from actual bounds, eg, after reframing panes"	self flag: #arNote. "Doesn't work yet - the computation is more complex than this"	"| panelRect |	panelRect _ self panelRect.	paneRects _ paneMorphs collect:		[:m | 		(m bounds translateBy: panelRect topLeft negated)			scaleBy: (1.0 asPoint / panelRect extent)]"! !!SystemWindow methodsFor: 'label' stamp: 'sw 9/28/1999 13:39'!labelHeight	^ label height + 1 max: collapseBox height! !!SystemWindow methodsFor: 'label' stamp: 'ar 11/9/2000 01:10'!setLabel: aString	| frame |	labelString _ aString.	label ifNil: [^ self].	label contents: aString.	frame _ LayoutFrame new.	frame leftFraction: 0.5; topFraction: 0; leftOffset: label width negated // 2.	label layoutFrame: frame.	self labelWidgetAllowance.  "Sets it if not already"	self isCollapsed		ifTrue: [self extent: (label width + labelWidgetAllowance) @ (self labelHeight + 2)]		ifFalse: [label fitContents; setWidth: (label width min: bounds width - labelWidgetAllowance).				label align: label bounds topCenter with: bounds topCenter + (0@borderWidth).				collapsedFrame ifNotNil:					[collapsedFrame _ collapsedFrame withWidth: label width + labelWidgetAllowance]]! !!SystemWindow methodsFor: 'panes' stamp: 'ar 11/9/2000 18:24'!addMorph: aMorph frame: relFrame	| frame |	frame _ LayoutFrame new.	frame 		leftFraction: relFrame left; 		rightFraction: relFrame right; 		topFraction: relFrame top; 		bottomFraction: relFrame bottom.	frame topFraction isZero ifTrue:[frame topOffset: self labelHeight].	aMorph layoutFrame: frame.	aMorph hResizing: #spaceFill; vResizing: #spaceFill.	self addMorph: aMorph.	paneMorphs _ paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	aMorph borderWidth: 1.	aMorph color: self paneColor.! !!SystemWindow methodsFor: 'layout' stamp: 'ar 11/9/2000 01:37'!convertAlignment	| frame |	self layoutPolicy: ProportionalLayout new.	(paneMorphs == nil or:[paneRects == nil or:[paneMorphs size ~= paneRects size]]) ifFalse:[		paneMorphs with: paneRects do:[:m :r|			frame _ LayoutFrame new.			frame leftFraction: r left; rightFraction: r right; topFraction: r top; bottomFraction: r bottom.			frame topFraction isZero ifTrue:[frame topOffset: self labelHeight].			m layoutFrame: frame.			m hResizing: #spaceFill; vResizing: #spaceFill.		].	].	label ifNotNil:[		frame _ LayoutFrame new.		frame leftFraction: 0.5; topFraction: 0; leftOffset: label width negated // 2.		label layoutFrame: frame].	collapseBox ifNotNil:[		frame _ LayoutFrame new.		frame rightFraction: 1; topFraction: 0; rightOffset: 1; topOffset: 1.		collapseBox layoutFrame: frame].	stripes ifNotNil:[		frame _ LayoutFrame new.		frame leftFraction: 0; topFraction: 0; rightFraction: 1;				leftOffset: 1; topOffset: 1; rightOffset: 1.		stripes first layoutFrame: frame.		stripes first height: self labelHeight - 2.		stripes first hResizing: #spaceFill.		frame _ LayoutFrame new.		frame leftFraction: 0; topFraction: 0; rightFraction: 1;				leftOffset: 3; topOffset: 3; rightOffset: 3.		stripes last layoutFrame: frame.		stripes last height: self labelHeight - 6.		stripes last hResizing: #spaceFill].	menuBox ifNotNil:[		frame _ LayoutFrame new.		frame leftFraction: 0; leftOffset: 19; topFraction: 0; topOffset: 1.		menuBox layoutFrame: frame].	closeBox ifNotNil:[		frame _ LayoutFrame new.		frame leftFraction: 0; leftOffset: 4; topFraction: 0; topOffset: 1.		closeBox layoutFrame: frame].! !!FlashPlayerWindow methodsFor: 'as yet unclassified' stamp: 'ar 11/9/2000 01:31'!addMorph: aMorph frame: relFrame	"Do not change the color"	| cc |	cc _ aMorph color.	super addMorph: aMorph frame: relFrame.	aMorph color: cc.! !!NewWorldWindow methodsFor: 'as yet unclassified' stamp: 'ar 11/9/2000 01:31'!addMorph: aMorph frame: relFrame	| cc |	cc _ aMorph color.	super addMorph: aMorph frame: relFrame.	aMorph color: cc.! !!TabSorterMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/8/2000 22:38'!initialize	super initialize.	self removeAllMorphs.	self extent: 300@100.	pageHolder _ PasteUpMorph new.	pageHolder resizeToFit: true; autoLineLayout: true.	pageHolder extent: self extent - borderWidth.	pageHolder padding: 8.	pageHolder cursor: 0.	self addControls.	self addMorphBack: pageHolder! !!TabbedPalette methodsFor: 'parts & controls tabs' stamp: 'ar 11/8/2000 22:38'!addPartsTab	| partsBook aPage |	partsBook _ BookMorph new pageSize: pageSize; setNameTo: 'supplies'.	partsBook removeEverything.	aPage _ self presenter newPageForStandardPartsBin.	aPage extent: pageSize.	#(PaintInvokingMorph RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph JoystickMorph SimpleSliderMorph) do:		[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].	aPage addMorphBack: RectangleMorph roundRectPrototype.	aPage addMorphBack: ScriptingSystem prototypicalHolder.	aPage replaceTallSubmorphsByThumbnails.	aPage setPartsBinStatusTo: true.	partsBook insertPage: aPage pageSize: pageSize.	self addTabForBook: partsBook withBalloonText: 'parts bin'! !!TableLayout methodsFor: 'testing' stamp: 'ar 10/29/2000 01:29'!isTableLayout	^true! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/2/2000 17:15'!computeCellArrangement: cellHolder in: newBounds horizontal: aBool target: aMorph	"Compute number of cells we can put in each row/column. The returned array contains a list of all the cells we can put into the row/column at each level.	Note: The arrangement is so that the 'x' value of each cell advances along the list direction and the 'y' value along the wrap direction. The returned arrangement has an extra cell at the start describing the width and height of the row."	| cells wrap spacing output maxExtent n sum index max cell first last w cellMax maxCell hFill vFill inset |	maxCell _ cellHolder key.	cells _ cellHolder value.	aMorph wrapDirection == #none 		ifTrue:[wrap _ SmallInteger maxVal]		ifFalse:[wrap _ aBool ifTrue:[newBounds width] ifFalse:[newBounds height].				wrap < maxCell x ifTrue:[wrap _ maxCell x]].	spacing _ aMorph cellSpacing.	(spacing == #globalRect or:[spacing = #globalSquare]) ifTrue:[		"Globally equal spacing is a very special case here, so get out fast and easy"		^self computeGlobalCellArrangement: cells 			in: newBounds horizontal: aBool 			wrap: wrap spacing: spacing].	output _ (WriteStream on: Array new).	inset _ aMorph cellInset asPoint.	aBool ifFalse:[inset _ inset transposed].	first _ last _ nil.	maxExtent _ 0@0.	sum _ 0.	index _ 1.	n _ 0.	hFill _ vFill _ false.	[index <= cells size] whileTrue:[		w _ sum.		cell _ cells at: index.		cellMax _ maxExtent max: cell cellSize. "e.g., minSize"		(spacing == #localRect or:[spacing == #localSquare]) ifTrue:[			"Recompute entire size of current row"			spacing == #localSquare 				ifTrue:[max _ cellMax x max: cellMax y]				ifFalse:[max _ cellMax x].			sum _ (n + 1) * max.		] ifFalse:[			sum _ sum + (cell cellSize x).		].		((sum + (n * inset x)) > wrap and:[first notNil]) ifTrue:[			"It doesn't fit and we're not starting a new line"			(spacing == #localSquare or:[spacing == #localRect]) ifTrue:[				spacing == #localSquare 					ifTrue:[maxExtent _ (maxExtent x max: maxExtent y) asPoint].				first do:[:c| c cellSize: maxExtent]].			w _ w + ((n - 1) * inset x).			"redistribute extra space"			first nextCell ifNotNil:[first nextCell do:[:c| c addExtraSpace: inset x@0]].			last _ LayoutCell new.			last cellSize: w @ (maxExtent y).			last hSpaceFill: hFill.			last vSpaceFill: vFill.			last nextCell: first.			output position = 0 ifFalse:[last addExtraSpace: 0@inset y].			output nextPut: last.			first _ nil.			maxExtent _ 0@0.			sum _ 0.			n _ 0.			hFill _ vFill _ false.		] ifFalse:[			"It did fit; use next item from input"			first ifNil:[first _ last _ cell] ifNotNil:[last nextCell: cell. last _ cell].			index _ index+1.			n _ n + 1.			maxExtent _ cellMax.			hFill _ hFill or:[cell hSpaceFill].			vFill _ vFill or:[cell vSpaceFill].		].	].	first ifNotNil:[		last _ LayoutCell new.		sum _ sum + ((n - 1) * inset x).		first nextCell ifNotNil:[first nextCell do:[:c| c addExtraSpace: inset x@0]].		last cellSize: sum @ maxExtent y.		last hSpaceFill: hFill.		last vSpaceFill: vFill.		last nextCell: first.		output position = 0 ifFalse:[last addExtraSpace: 0@inset y].		output nextPut: last].	output _ output contents.	aMorph listSpacing == #equal ifTrue:[		"Make all the heights equal"		max _ output inject: 0 into:[:size :c| size max: c cellSize y].		output do:[:c| c cellSize: c cellSize x @ max].	].	^output! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/2/2000 18:28'!computeCellSizes: aMorph in: newBounds horizontal: aBool	"Step 1: Compute the minimum extent for all the children of aMorph"	| cells cell size block maxCell minSize maxSize |	cells _ WriteStream on: (Array new: aMorph submorphCount).	minSize _ aMorph minCellSize asPoint.	maxSize _ aMorph maxCellSize asPoint.	aBool ifTrue:[		minSize _ minSize transposed.		maxSize _ maxSize transposed].	maxCell _ 0@0.	block _ [:m|		m disableTableLayout ifFalse:[			size _ m minExtent.			cell _ LayoutCell new target: m.			aBool ifTrue:[				cell hSpaceFill: m hResizing == #spaceFill.				cell vSpaceFill: m vResizing == #spaceFill.			] ifFalse:[				cell hSpaceFill: m vResizing == #spaceFill.				cell vSpaceFill: m hResizing == #spaceFill.				size _ size transposed.			].			size _ (size min: maxSize) max: minSize.			cell cellSize: size.			maxCell _ maxCell max: size.			cells nextPut: cell]].	aMorph reverseTableCells		ifTrue:[aMorph submorphsReverseDo: block]		ifFalse:[aMorph submorphsDo: block].	^maxCell -> cells contents! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/2/2000 22:51'!computeExtraSpacing: arrangement in: newBounds horizontal: aBool target: aMorph	"Compute the required extra spacing for laying out the cells"	| extent extra centering n extraPerCell cell last hFill vFill max amount allow |	"match newBounds extent with arrangement's orientation"	extent _ newBounds extent.	aBool ifFalse:[extent _ extent transposed].	"figure out if we have any horizontal or vertical space fillers"	hFill _ vFill _ false.	max _ 0@0.	arrangement do:[:c|		max _ (max x max: c cellSize x) @ (max y + c cellSize y).		max _ max max: c cellSize.		hFill _ hFill or:[c hSpaceFill].		vFill _ vFill or:[c vSpaceFill]].	"Take client's shrink wrap constraints into account.	Note: these are only honored when there are no #spaceFill children,	or when #rubberBandCells is set."	allow _ aMorph rubberBandCells not.	aMorph hResizing == #shrinkWrap ifTrue:[		aBool 			ifTrue:[allow & hFill ifFalse:[extent _ max x @ (max y max: extent y)]]			ifFalse:[allow & vFill ifFalse:[extent _ (max x max: extent x) @ max y]]].	aMorph vResizing == #shrinkWrap ifTrue:[		aBool 			ifFalse:[allow & hFill ifFalse:[extent _ max x @ (max y max: extent y)]]			ifTrue:[allow & vFill ifFalse:[extent _ (max x max: extent x) @ max y]]].	"Now compute the extra v space"	extra _ extent y - (arrangement inject: 0 into:[:sum :c| sum + c cellSize y]).	extra > 0 ifTrue:[		"Check if we have any #spaceFillers"		vFill ifTrue:[ "use only #spaceFillers"			n _ arrangement inject: 0 into:[:sum :c| c vSpaceFill ifTrue:[sum+1] ifFalse:[sum]].			extraPerCell _ extra asFloat / n asFloat.			extra _ last _ 0.			arrangement do:[:c|				c vSpaceFill ifTrue:[					extra _ (last _ extra) + extraPerCell.					amount _ 0 @ (extra truncated - last truncated).					c do:[:cc| cc cellSize: cc cellSize + amount]]].		] ifFalse:[ "no #spaceFillers; distribute regularly"			centering _ aMorph wrapCentering.			"centering == #topLeft ifTrue:[]." "add all extra space to the last cell; e.g., do nothing"			centering == #bottomRight "add all extra space to the first cell"				ifTrue:[arrangement first addExtraSpace: 0@extra].			centering == #center "add 1/2 extra space to the first and last cell"				ifTrue:[arrangement first addExtraSpace: 0@ (extra // 2)].			centering == #justified "add extra space equally distributed to each cell"				ifTrue:[	n _ (arrangement size - 1) max: 1.						extraPerCell _ extra asFloat / n asFloat.						extra _ last _ 0.						arrangement do:[:c|							c addExtraSpace: 0@(extra truncated - last truncated).							extra _ (last _ extra) + extraPerCell]].		].	].	"Now compute the extra space for the primary direction"	centering _ aMorph listCentering.	1 to: arrangement size do:[:i|		cell _ (arrangement at: i).		extra _ extent x - cell cellSize x.		extra > 0 ifTrue:[			"Check if we have any #spaceFillers"			cell hSpaceFill ifTrue:[ "use only #spaceFillers"				cell _ cell nextCell.				n _ cell inject: 0 into:[:sum :c| c hSpaceFill ifTrue:[sum+1] ifFalse:[sum]].				extraPerCell _ extra asFloat / n asFloat.				extra _ last _ 0.				cell do:[:c|					c hSpaceFill ifTrue:[						extra _ (last _ extra) + extraPerCell.						amount _ extra truncated - last truncated.						c cellSize: c cellSize + (amount@0)]].			] ifFalse:[ "no #spaceFiller; distribute regularly"				cell _ cell nextCell.				"centering == #topLeft ifTrue:[]" "add all extra space to the last cell; e.g., do nothing"				centering == #bottomRight "add all extra space to the first cell"					ifTrue:[cell addExtraSpace: extra @ 0].				centering == #center "add 1/2 extra space to the first and last cell"					ifTrue:[cell addExtraSpace: (extra // 2) @ 0].				centering == #justified "add extra space equally distributed to each cell"					ifTrue:[	n _ (cell size - 1) max: 1.							extraPerCell _ extra asFloat / n asFloat.							extra _ last _ 0.							cell do:[:c|								c addExtraSpace: (extra truncated - last truncated) @ 0.								extra _ (last _ extra) + extraPerCell]].			].		].	].! !!TableLayout methodsFor: 'layout' stamp: 'ar 10/31/2000 22:50'!computeGlobalCellArrangement: cells in: newBounds horizontal: aBool wrap: wrap spacing: spacing	"Compute number of cells we can put in each row/column. The returned array contains a list of all the cells we can put into the row/column at each level.	Note: The arrangement is so that the 'x' value of each cell advances along the list direction and the 'y' value along the wrap direction. The returned arrangement has an extra cell at the start describing the width and height of the row."	| output maxExtent n cell first last hFill vFill |	output _ (WriteStream on: Array new).	first _ last _ nil.	maxExtent _ cells inject: 0@0 into:[:size :c| size max: c cellSize "e.g., minSize"].	spacing == #globalSquare ifTrue:[maxExtent _ (maxExtent x max: maxExtent y) asPoint].	n _ (wrap // maxExtent x) max: 1.	hFill _ vFill _ false.	1 to: cells size do:[:i|		cell _ cells at: i.		hFill _ hFill or:[cell hSpaceFill].		vFill _ vFill or:[cell vSpaceFill].		cell cellSize: maxExtent.		first ifNil:[first _ last _ cell] ifNotNil:[last nextCell: cell. last _ cell].		(i \\ n) = 0 ifTrue:[			last _ LayoutCell new.			last cellSize: (maxExtent x * n) @ (maxExtent y).			last hSpaceFill: hFill.			last vSpaceFill: vFill.			hFill _ vFill _ false.			last nextCell: first.			output nextPut: last.			first _ nil]].	first ifNotNil:[		last _ LayoutCell new.		last cellSize: (maxExtent x * n) @ (maxExtent y). self flag: #arNote."@@@: n is not correct!!"		last nextCell: first.		output nextPut: last].	^output contents! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/1/2000 16:08'!layout: aMorph in: box	"Compute the layout for the given morph based on the new bounds"	| cells arrangement horizontal newBounds |	aMorph hasSubmorphs ifFalse:[^self].	newBounds _ box origin asIntegerPoint corner: (box corner asIntegerPoint).	(aMorph listDirection == #topToBottom or:[aMorph listDirection == #bottomToTop])		ifTrue:[	horizontal _ false]		ifFalse:[	horizontal _ true].	"Step 1: Compute the minimum extent for all the children of aMorph"	cells _ self computeCellSizes: aMorph 				in: (0@0 corner: newBounds extent) 				horizontal: horizontal.	"Step 2: Compute the arrangement of the cells for each row and column"	arrangement _ self computeCellArrangement: cells 						in: newBounds 						horizontal: horizontal 						target: aMorph.	"Step 3: Compute the extra spacing for each cell"	self computeExtraSpacing: arrangement 		in: newBounds 		horizontal: horizontal 		target: aMorph.	"Step 4: Place the children within the cells accordingly"	self placeCells: arrangement 		in: newBounds 		horizontal: horizontal 		target: aMorph.! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/1/2000 16:09'!minExtentOf: aMorph in: box	"Return the minimal size aMorph's children would require given the new bounds"	| cells arrangement horizontal newBounds minX minY minExtent |	aMorph hasSubmorphs ifFalse:[^0@0].	newBounds _ box origin asIntegerPoint corner: (box corner asIntegerPoint).	(aMorph listDirection == #topToBottom or:[aMorph listDirection == #bottomToTop])		ifTrue:[	horizontal _ false]		ifFalse:[	horizontal _ true].	"Step 1: Compute the minimum extent for all the children of aMorph"	cells _ self computeCellSizes: aMorph 				in: (0@0 corner: newBounds extent) 				horizontal: horizontal.	"Step 2: Compute the arrangement of the cells for each row and column"	arrangement _ self computeCellArrangement: cells 						in: newBounds 						horizontal: horizontal						target: aMorph.	"Step 3: Extract the minimum size out of the arrangement"	minX _ minY _ 0.	arrangement do:[:cell|		minX _ minX max: cell cellSize x.		minY _ minY + cell cellSize y].	horizontal 		ifTrue:[minExtent _ minX@minY]		ifFalse:[minExtent _ minY@minX].	^minExtent! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/6/2000 01:09'!placeCells: arrangement in: newBounds horizontal: aBool target: aMorph	"Place the morphs within the cells accordingly"	| xDir yDir anchor yDist place cell xDist cellRect corner inset |	inset _ aMorph cellInset.	(inset isNumber and:[inset isZero]) ifTrue:[inset _ nil].	aBool ifTrue:["horizontal layout"		aMorph listDirection == #rightToLeft ifTrue:[			xDir _ -1@0.			aMorph wrapDirection == #bottomToTop 				ifTrue:[yDir _ 0@-1. anchor _ newBounds bottomRight]				ifFalse:[yDir _ 0@1. anchor _ newBounds topRight].		] ifFalse:[			xDir _ 1@0.			aMorph wrapDirection == #bottomToTop				ifTrue:[yDir _ 0@-1. anchor _ newBounds bottomLeft]				ifFalse:[yDir _ 0@1. anchor _ newBounds topLeft]].	] ifFalse:["vertical layout"		aMorph listDirection == #bottomToTop ifTrue:[			xDir _ 0@-1.			aMorph wrapDirection == #rightToLeft				ifTrue:[yDir _ -1@0. anchor _ newBounds bottomRight]				ifFalse:[yDir _ 1@0. anchor _ newBounds bottomLeft]		] ifFalse:[			xDir _ 0@1.			aMorph wrapDirection == #rightToLeft				ifTrue:[yDir _ -1@0. anchor _ newBounds topRight]				ifFalse:[yDir _ 1@0. anchor _ newBounds topLeft]].	].	1 to: arrangement size do:[:i|		cell _ arrangement at: i.		cell extraSpace ifNotNil:[anchor _ anchor + (cell extraSpace y * yDir)].		yDist _ cell cellSize y * yDir. "secondary advance direction"		place _ anchor.		cell _ cell nextCell.		[cell == nil] whileFalse:[			cell extraSpace ifNotNil:[place _ place + (cell extraSpace x * xDir)].			xDist _ cell cellSize x * xDir. "primary advance direction"			corner _ place + xDist + yDist.			cellRect _ Rectangle origin: (place min: corner) corner: (place max: corner).			inset ifNotNil:[cellRect _ cellRect insetBy: inset].			cell target layoutInBounds: cellRect.			place _ place + xDist.			cell _ cell nextCell].		anchor _ anchor + yDist.	].! !!TableLayout methodsFor: 'utilities' stamp: 'ar 11/1/2000 16:10'!indexForInserting: aMorph at: aPoint in: owner	"Return the insertion index based on the layout strategy defined for some morph. Used for drop insertion."	| horizontal morphList index |	owner hasSubmorphs ifFalse:[^1].	aMorph disableTableLayout ifTrue:[^1].	(owner listDirection == #topToBottom or:[owner listDirection == #bottomToTop])		ifTrue:[	horizontal _ false]		ifFalse:[	horizontal _ true].	morphList _ owner submorphs.	owner reverseTableCells ifTrue:[morphList _ morphList reversed].	index _ self indexForInserting: aPoint inList: morphList horizontal: horizontal target: owner.	owner reverseTableCells ifTrue:[index _ morphList size - index + 2].	^index ifNil:[1].			! !!TableLayout methodsFor: 'utilities' stamp: 'ar 11/1/2000 16:09'!indexForInserting: aPoint inList: morphList horizontal: aBool target: aMorph	| box cmp1 cmp2 cmp3 noWrap |	noWrap _ aMorph wrapDirection == #none.	aBool ifTrue:["horizontal"		aMorph listDirection == #rightToLeft			ifTrue:[cmp1 _ [:rect| aPoint x > rect left]]			ifFalse:[cmp1 _ [:rect| aPoint x < rect right]].		aMorph wrapDirection == #bottomToTop 			ifTrue:[cmp2 _ [:rect| aPoint y > rect top].					cmp3 _ [:rect| aPoint y > rect bottom]]			ifFalse:[cmp2 _ [:rect| aPoint y < rect bottom].					cmp3 _ [:rect| aPoint y < rect top]].	] ifFalse:["vertical"		aMorph listDirection == #bottomToTop 			ifTrue:[cmp1 _ [:rect| aPoint y > rect top]]			ifFalse:[cmp1 _ [:rect| aPoint y < rect bottom]].		aMorph wrapDirection == #rightToLeft			ifTrue:[cmp2 _ [:rect| aPoint x > rect left].					cmp3 _ [:rect| aPoint x > rect right]]			ifFalse:[cmp2 _ [:rect| aPoint x < rect right].					cmp3 _ [:rect| aPoint x < rect left]].	].	morphList keysAndValuesDo:[:index :m|		self flag: #arNote. "it is not quite clear if we can really use #fullBounds here..."		box _ m fullBounds.		noWrap ifTrue:[			"Only in one direction"			(cmp1 value: box) ifTrue:[^index]		] ifFalse:[			"Check for inserting before current row"			(cmp3 value: box) ifTrue:[^index].			"Check for inserting before current cell"			((cmp1 value: box) and:[cmp2 value: box]) ifTrue:[^index]]].	^morphList size + 1! !!TileMorph methodsFor: 'initialization' stamp: 'ar 11/8/2000 23:45'!initialize	super initialize.	self extent: 1@1.	self typeColor: (Color r: 0.8 g: 1.0 b: 0.6).	self borderWidth: 1.	type _ #literal.  "#literal, #slotRef, #objRef, #operator, #expression"	slotName _ ''.	literal _ 1.	self layoutPolicy: TableLayout new.	self cellInset: 2@0.	self layoutInset: 1@0.	self listDirection: #leftToRight.	self wrapCentering: #center.	self hResizing: #shrinkWrap.	self vResizing: #spaceFill.! !!TileMorph methodsFor: 'arrows' stamp: 'ar 11/2/2000 22:29'!addArrows	| frame |	downArrow _ ImageMorph new image: DownPicture.	upArrow _ ImageMorph new image: UpPicture.	frame _ Morph new color: Color transparent.	frame 		layoutPolicy: TableLayout new;		listDirection: #topToBottom;		hResizing: #shrinkWrap; 		vResizing: #shrinkWrap;		cellInset: 0@1;		layoutInset: 0@1.	frame addMorphBack: upArrow; addMorphBack: downArrow.	self addMorphFront: frame.! !!TileMorph methodsFor: 'arrows' stamp: 'ar 11/2/2000 22:30'!addSuffixArrow	suffixArrow _ ImageMorph new image: SuffixPicture.	self addMorphBack: suffixArrow.! !!TileMorph methodsFor: 'private' stamp: 'ar 11/2/2000 19:21'!convertAlignment	"Convert the receiver's alignment rules"	| where frame |	owner ifNotNil:[		owner class == TilePadMorph ifTrue:[			owner layoutPolicy: TableLayout new.			owner hResizing: #shrinkWrap.			owner vResizing: #spaceFill.		].	].	self layoutPolicy: TableLayout new.	self cellInset: 2@0.	self layoutInset: 1@0.	self listDirection: #leftToRight.	self wrapCentering: #center.	self hResizing: #shrinkWrap.	self vResizing: #spaceFill.	"Now convert up and down arrow"	(upArrow notNil and:[upArrow owner == self "e.g., not converted"		and:[downArrow notNil and:[downArrow owner == self]]]) ifTrue:[			"where to insert the frame"			where _ (submorphs indexOf: upArrow) min: (submorphs indexOf: downArrow).			frame _ Morph new color: Color transparent.			frame 				layoutPolicy: TableLayout new;				listDirection: #topToBottom;				hResizing: #shrinkWrap; 				vResizing: #shrinkWrap;				cellInset: 0@1;				layoutInset: 0@1.			self privateAddMorph: frame atIndex: where.			frame addMorphBack: upArrow; addMorphBack: downArrow.		].! !!TileMorph methodsFor: 'private' stamp: 'ar 11/8/2000 23:46'!ownerChanged	super ownerChanged.	(owner class == TilePadMorph and:[owner layoutPolicy isNil]) ifTrue:[		owner layoutPolicy: TableLayout new.		owner hResizing: #shrinkWrap.		owner vResizing: #spaceFill.	].! !!UpdatingMenuItemMorph methodsFor: 'stepping' stamp: 'ar 10/29/2000 02:41'!updateContents	| newString enablement nArgs |	wordingProvider ifNil:[^self].	wordingSelector ifNotNil:[		newString _ contents.		nArgs _ wordingSelector numArgs.		nArgs == 0 ifTrue:[newString _ wordingProvider perform: wordingSelector].		nArgs == arguments size ifTrue:[			newString _ wordingProvider perform: wordingSelector withArguments: arguments].		newString = contents ifFalse: [self contents: newString]].	enablementSelector ifNotNil:[		(enablement _ self enablement) == isEnabled 			ifFalse:[self isEnabled: enablement]]! !!Utilities class methodsFor: 'flaps' stamp: 'ar 11/8/2000 22:38'!addStackToolsFlap	"Add a flap with stack tools in it"	| aFlap aFlapTab aTextMorph aSketch  aMorph |	"Utilities reinstateDefaultFlaps. Utilities addStackToolsFlap"	(ScriptingSystem formAtKey: #CedarPic) ifNil:		[^ self notYetImplemented].	aFlap _ self newPartsFlapPage beSticky.	aFlap setProperty: #maximumThumbnailWidth toValue: 80.	aFlap setProperty: #flap toValue: true.	aFlap color: (Color green muchLighter lighter alpha: 0.3).	aFlapTab _ FlapTab new referent: aFlap.	aFlapTab assumeString: 'Stack Tools' font: Preferences standardFlapFont orientation: #horizontal color: Color brown lighter lighter.	aFlapTab edgeToAdhereTo: #bottom; inboard: false.	aFlapTab setToPopOutOnDragOver: false.	aFlapTab setToPopOutOnMouseOver: false.	aFlap addMorphBack: StackMorph authoringPrototype.	aTextMorph _ TextMorph authoringPrototype.	aTextMorph contents: 'backgroundlabel' asText.  	aTextMorph beAllFont: (StrikeFont familyName: #NewYork size: 18).	aTextMorph color: Color brown.	aTextMorph setProperty: #shared toValue: true.	aFlap addMorphBack: aTextMorph.	"Ted's fields, maybe good point of departure...	aTextMorph _ TextFieldMorph authoringPrototype.	aTextMorph setProperty: #shared toValue: true.	aFlap addMorphBack: aTextMorph."	aFlap addMorphBack: ScriptableButton authoringPrototype markAsPartsDonor beSticky.	"NB: Here is where we will put the prototype(s) for background/foreground fields; for the moment, vanilla TextMorphs are used, with the scrolling PTMWM temporarily commented out pending some more work.  A successor to Ted's TextFieldMorph, or some new kind of carefully-thought-through morph that will generally serve the community as the archetypal 'Field', is ultimately needed"	#(TextMorph "PluggableTextMorphWithModel") do:		[:sym |			aMorph _ (Smalltalk at: sym) authoringPrototype.			aMorph contents: 'background field' asText allBold.			aMorph setProperty: #shared toValue: true.			aMorph setNameTo: (sym == #TextMorph ifTrue: ['field1'] ifFalse: ['scrollingField1']).			aMorph setProperty: #holdsSeparateDataForEachInstance toValue: true.			aFlap addMorphBack: aMorph].	"aFlap addMorphBack: ScriptableListMorph authoringPrototype beSticky -- SOON!!"		#(CedarPic) do:		[:sym | 			aSketch _ SketchMorph newSticky form: ((ScriptingSystem formAtKey: sym) ifNil: [ScriptingSystem formAtKey: #squeakyMouse]).			aSketch setProperty: #shared toValue: true.			aSketch setProperty: #holdsSeparateDataForEachInstance toValue: true.			aFlap addMorphBack: aSketch].	"aCardReference _ CardReference authoringProtoype beSticky.	aCardReference card: Card new.  "	aFlap addMorphBack: StackMorph previousCardButton markAsPartsDonor.	aFlap addMorphBack: StackMorph nextCardButton markAsPartsDonor.	#( PaintInvokingMorph "ImageMorph  RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph SimpleSliderMorph") do:		[:sym | aFlap addMorphBack: (Smalltalk at: sym) authoringPrototype].	aFlap addMorphBack: TrashCanMorph new markAsPartsDonor.	aFlap addMorphBack: ScriptingSystem scriptControlButtons markAsPartsDonor.	aFlap replaceTallSubmorphsByThumbnails.	aFlapTab position: ((2 * (self currentWorld width // 3)) @ (self currentWorld height - aFlapTab height)).	aFlap setProperty: #flap toValue: true.	aFlap color: (Color red muchLighter "alpha: 0.2").	aFlap extent: self currentWorld width @ 100.		self currentWorld addMorphFront: aFlapTab.  	"a local flap, but we could as easily make it global by:		self addGlobalFlap: aFlapTab.  self currentWorld addGlobalFlaps"! !!Utilities class methodsFor: 'flaps' stamp: 'ar 11/8/2000 22:38'!standardBottomFlap	"Answer a fully-instantiated flap named 'Supplies' to be placed at the bottom of the screen"	|  aFlapTab aPage |	aPage _ self newPartsFlapPage.	aPage setProperty: #maximumThumbnailWidth toValue: 80.	aFlapTab _ FlapTab new referent: aPage beSticky.	aFlapTab color: Color red lighter.	aFlapTab setToPopOutOnDragOver: true.	aFlapTab setToPopOutOnMouseOver: true.	aFlapTab assumeString: 'Supplies' font: Preferences standardFlapFont orientation: #horizontal color: Color red lighter.	aFlapTab edgeToAdhereTo: #bottom; inboard: false.	aPage extent: self currentWorld width @ 100.	aPage addMorphBack: Command undoRedoButtons markAsPartsDonor.	aPage addMorphBack: TrashCanMorph new markAsPartsDonor.	aPage addMorphBack: ScriptingSystem scriptControlButtons markAsPartsDonor.	#(PaintInvokingMorph RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ) do:		[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].	aPage addMorphBack: ScriptingSystem prototypicalHolder.	aPage addMorphBack: RectangleMorph roundRectPrototype.	#(ImageMorph ScriptableButton SimpleSliderMorph		PasteUpMorph   BookMorph TabbedPalette 		JoystickMorph  ) do:		[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].	aPage addMorphBack: Morph new previousPageButton markAsPartsDonor.	aPage addMorphBack: Morph new nextPageButton markAsPartsDonor.	aPage addMorphBack: ScriptingSystem holderWithAlphabet markAsPartsDonor.	aPage addMorphBack: (ClockMorph authoringPrototype showSeconds: false) step.	aPage replaceTallSubmorphsByThumbnails.	aFlapTab position: ((Display width - aFlapTab width) // 2 @ (self currentWorld height - aFlapTab height)).	aPage beFlap: true.	aPage color: (Color red muchLighter "alpha: 0.2").	aPage extent: self currentWorld width @ 100.		^ aFlapTab! !!Utilities class methodsFor: 'flaps' stamp: 'ar 11/8/2000 22:38'!standardRightFlap	|  aFlapTab aPage |	aPage _ self newPartsFlapPage.	aFlapTab _ FlapTab new referent: aPage beSticky.	aFlapTab color: Color red lighter.	aFlapTab assumeString: 'Tools' font: Preferences standardFlapFont orientation: #vertical color: Color orange lighter.	aFlapTab edgeToAdhereTo: #right; inboard: false.	aFlapTab setToPopOutOnDragOver: true.	aFlapTab setToPopOutOnMouseOver: true.	aPage extent: (90 @ self currentWorld height).	self addSampleWindowsTo: aPage.	aPage addMorphBack: ScriptingSystem newScriptingSpace.	aPage addMorphBack: RecordingControlsMorph authoringPrototype.	aPage replaceTallSubmorphsByThumbnails.	aFlapTab position: (self currentWorld width - aFlapTab width) @ ((Display height - aFlapTab height) // 2).	aPage beFlap: true.	aPage color: (Color brown muchLighter alpha: 0.5).	aPage extent: (90 @ self currentWorld height).		^ aFlapTab! !TileMorph removeSelector: #fullBounds!!TableLayout reorganize!('testing' isTableLayout)('layout' computeCellArrangement:in:horizontal:target: computeCellSizes:in:horizontal: computeExtraSpacing:in:horizontal:target: computeGlobalCellArrangement:in:horizontal:wrap:spacing: layout:in: minExtentOf:in: placeCells:in:horizontal:target:)('utilities' indexForInserting:at:in: indexForInserting:inList:horizontal:target:)!PartsWindow removeSelector: #setBoundsOfPaneMorphs!SystemWindow removeSelector: #setBoundsOfPaneMorphs!MenuItemMorph removeSelector: #hResizing!MenuItemMorph removeSelector: #isAlignmentMorph!MenuItemMorph removeSelector: #layoutInWidth:height:!MenuItemMorph removeSelector: #minHeight!MenuItemMorph removeSelector: #minWidth!MenuItemMorph removeSelector: #vResizing!ScriptEditorMorph removeSelector: #minHeight!ScriptEditorMorph removeSelector: #minWidth!SameGameBoard removeSelector: #fixLayout!PlayingCardDeck removeSelector: #fixLayout!PlayingCardDeck removeSelector: #minHeight!PlayingCardDeck removeSelector: #minHeightWhenEmpty!PlayingCardDeck removeSelector: #minWidthWhenEmpty!PianoRollScoreMorph removeSelector: #drawSubmorphsOn:!PasteUpMorph removeSelector: #drawSubmorphsOn:!PasteUpMorph removeSelector: #fixLayout!PasteUpMorph removeSelector: #fullBounds!PasteUpMorph removeSelector: #horizontallyAlignSubmorphSubparts!PasteUpMorph removeSelector: #insertionIndexFor:!PasteUpMorph removeSelector: #layoutRow:lastRowBase:!PasteUpMorph removeSelector: #replaceSubmorph:by:!PasteUpMorph removeSelector: #rowBaseFor:lastRowBase:!PasteUpMorph removeSelector: #rowMorphsStartingAt:!PasteUpMorph removeSelector: #sortAndPositionSubmorphs!MoviePlayerMorph removeSelector: #minExtent!MonthMorph removeSelector: #minExtent!MenuMorph removeSelector: #minHeightWhenEmpty!MenuMorph removeSelector: #minWidthWhenEmpty!MenuLineMorph removeSelector: #hResizing!MenuLineMorph removeSelector: #isAlignmentMorph!MenuLineMorph removeSelector: #layoutInWidth:height:!MenuLineMorph removeSelector: #minHeight!MenuLineMorph removeSelector: #minWidth!MenuLineMorph removeSelector: #vResizing!FillInTheBlankMorph removeSelector: #addButtonRow!FillInTheBlankMorph removeSelector: #addLine!FillInTheBlankMorph removeSelector: #addQuery:!EmbeddedWorldBorderMorph removeSelector: #fixLayout!EmbeddedWorldBorderMorph removeSelector: #minHeight!EmbeddedWorldBorderMorph removeSelector: #minWidth!EToyGateKeeperMorph removeSelector: #minHeightWhenEmpty!EToyGateKeeperMorph removeSelector: #minWidthWhenEmpty!EToyFridgeMorph removeSelector: #minHeight!CategoryViewer removeSelector: #replaceSubmorph:by:!AlignmentMorphBob1 removeSelector: #fixLayout!AlignmentMorphBob1 removeSelector: #minHeight!AlignmentMorphBob1 removeSelector: #minWidth!AlignmentMorph removeSelector: #acceptDroppingMorph:event:!AlignmentMorph removeSelector: #centering!AlignmentMorph removeSelector: #chooseOrientation!AlignmentMorph removeSelector: #drawSubmorphsOn:!AlignmentMorph removeSelector: #extraSpacePerMorph!AlignmentMorph removeSelector: #fixLayout!AlignmentMorph removeSelector: #fullBounds!AlignmentMorph removeSelector: #hResizing!AlignmentMorph removeSelector: #insertionIndexFor:!AlignmentMorph removeSelector: #layoutChanged!AlignmentMorph removeSelector: #layoutInWidth:height:!AlignmentMorph removeSelector: #maxWidth!AlignmentMorph removeSelector: #minCellSize!AlignmentMorph removeSelector: #minExtent!AlignmentMorph removeSelector: #minHeight!AlignmentMorph removeSelector: #minHeightWhenEmpty!AlignmentMorph removeSelector: #minWidth!AlignmentMorph removeSelector: #minWidthWhenEmpty!AlignmentMorph removeSelector: #placeAndSize:at:padding:!AlignmentMorph removeSelector: #resizeIfNeeded!AlignmentMorph removeSelector: #vResizing!Morph removeSelector: #basicFullDrawOn:!Morph removeSelector: #expandFullBoundsForDropShadow!Morph removeSelector: #expandFullBoundsForRolloverBorder!Morph removeSelector: #minHeight!Morph removeSelector: #minWidth!Morph removeSelector: #removeEmptyLayoutMorphs!!LayoutCell reorganize!('accessing' addExtraSpace: cellSize cellSize: extraSpace extraSpace: hSpaceFill hSpaceFill: nextCell nextCell: target target: vSpaceFill vSpaceFill:)('collection' do: inject:into: size)!"Postscript:Convert all existing alignment related morphs into the new regime."Smalltalk allObjectsDo:[:o| o isMorph ifTrue:[o convertAlignment]].!