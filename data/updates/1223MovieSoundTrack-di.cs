'From Squeak 2.4c of May 10, 1999 on 1 June 1999 at 10:13:54 am'!"Change Set:		MovieSoundTrackDate:			31 May 1999Author:			Dan IngallsAdds the ability for a moviePlayerMorph to add a sound track from a .wav or .aif file.  Also modifies the step code to skip frames as appropriate when falling behind the real-time requirements of a sound track."!BookMorph subclass: #MoviePlayerMorph	instanceVariableNames: 'movieFileName movieFile frameSize frameDepth frameNumber frameCount playDirection msSinceStart msAtStart msAtLastSync frameAtLastSync msPerFrame scorePlayer '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!AbstractSound methodsFor: 'playing' stamp: 'di 5/30/1999 12:46'!millisecondsSinceStart	^ mSecsSinceStart! !!MovieFrameSyncMorph methodsFor: 'as yet unclassified' stamp: 'di 6/1/1999 08:51'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	"Set frame number and milliseconds since start in case of drift"	| next |	moviePlayerMorph frameNumber: frameNumber		msSinceStart: scorePlayer millisecondsSinceStart.	"If there is a later sync point, set the appropriate frame rate until then."	(next _ self nextSyncEventAfter: index inTrack: track) == nil ifFalse:		[moviePlayerMorph msPerFrame: (next time - ticks) * secsPerTick * 1000.0						/ (next morph frameNumber - self frameNumber)].! !!MoviePlayerMorph commentStamp: '<historical>' prior: 0!MoviePlayerMorph plays images from a file using async io.  The file format is simple but non-standard (see below).The heart of the play logic is in the step method.  Note that play is driven by a simulated time since start.  For a movie with a sound score, this is the millisecondsSinceStart of the score player, whereas a movie by itself gets this from the millisecondClock minus msAtStart.The following code was used to convert 27 files into a movie.  They were named	'BalloonDrop10fps003.bmp' through 'BalloonDrop10fps081.bmp'incrementing by 003.  Each was known to be a 320x240 image in 32-bit BMP format.Note the 27 in the 5th line is the number of frames, = (3 to: 81 by: 3) size.	| ps zps f32 out ff |	out _ FileStream newFileNamed: 'BalloonDrop10fps.movie'.	out binary.	ff _ Form extent: 320@240 depth: 16.	#(22 320 240 16 27 100000) , (7 to: 32)		do: [:i | out nextInt32Put: i].			3 to: 81 by: 3 do:		[:i | ps _ i printString. zps _ ps padded: #left to: 3 with: $0.		f32 _ Form fromFileNamed:			'BalloonDrop10fps' , zps , '.bmp'.		f32 displayOn: ff at: 0@0.  "Convert down to 16 bits"		ff display; writeOnMovie: out].	out close.!!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 5/30/1999 17:31'!fullyReleaseCachedSate	scorePlayer _ nil! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 6/1/1999 08:07'!openFileNamed: fName	| f w h d n m |	movieFileName _ fName.	"Read movie file parameters from 128-byte header...		(records follow as {N=int32, N words}*)"	f _ (FileStream oldFileNamed: movieFileName) binary.		f nextInt32.		w _ f nextInt32.		h _ f nextInt32.		d _ f nextInt32.		n _ f nextInt32.		m _ f nextInt32.		f close.	pageSize _ frameSize _ w@h.	frameDepth _ d.	frameCount _ n.	frameNumber _ 1.	playDirection _ 0.	msAtLastSync _ 0.	msPerFrame _ m/1000.0.	self makeMyPage.	self goToPage: 1! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 6/1/1999 09:34'!stopSoundTrackIfAny	scorePlayer == nil ifTrue:[^ self].	(scorePlayer isKindOf: SampledSound)		ifTrue: [scorePlayer pause]		ifFalse: [scorePlayer _ nil]! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 6/1/1999 09:13'!frameNumber: n msSinceStart: ms	"Set the current frame number, and save the scorePlayer's simulated time for synchronization."	frameAtLastSync _ n.	msAtLastSync _ ms.! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 6/1/1999 08:55'!msPerFrame: n	"Set a new frame rate, base on, eg, score synchronization info."	msPerFrame _ n.! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 5/31/1999 16:33'!stopPlay	playDirection _ 0.	self stopSoundTrackIfAny! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 5/31/1999 16:27'!pauseFrom: player	playDirection _ 0.! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 5/26/1999 19:58'!fileByteCountPerFrame		^ currentPage image bits size * 4! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 5/27/1999 22:40'!filePosForFrameNo: frameNo		^ 128 + ((frameNo-1)*(4+self fileByteCountPerFrame)) + 4! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 6/1/1999 10:11'!startRunning	| ms |	movieFile _ AsyncFile new open: movieFileName forWrite: false.	movieFile primReadStart: movieFile fileHandle			fPosition: (self filePosForFrameNo: frameNumber)			count: self fileByteCountPerFrame.	scorePlayer == nil		ifTrue: [ms _ Time millisecondClockValue.				msAtStart _ ms - ((frameNumber-1) * msPerFrame).				msAtLastSync _ ms - msAtStart.				frameAtLastSync _ frameNumber]		ifFalse: [(playDirection > 0 and: [scorePlayer isKindOf: SampledSound]) ifTrue:					[frameNumber <= 1						ifTrue: [scorePlayer play]						ifFalse: [scorePlayer reset;									playSilentlyUntil: frameNumber - 1 * msPerFrame / 1000.0;									resumePlaying]].				msAtLastSync _ scorePlayer millisecondsSinceStart.				frameAtLastSync _ frameNumber]! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 6/1/1999 09:50'!step	"NOTE:  The movie player has two modes of play, depending on whether scorePlayer is nil or not.  If scorePlayer is nil, then play runs according to the millisecond clock.  If scorePlayer is not nil, then the scorePlayer is consulted for synchronization.  If the movie is running ahead, then some calls on step will skip their  action until the right time.  If the movie is running behind, then the frame may advance by more than one to maintain synchronization."	"ALSO: This player operates with overlapped disk i/o.  This means that while one frame is being displayed, the next frame in sequence is being read into a disk buffer.  The value of frameNumber corresponds to the frame currently visible."	"This code may not work right for playing backwards right now.	Single-step and backwards (dir <= 0) should just run open-loop."	|  byteCount simTime ms nextFrameNumber |	movieFile == nil ifTrue: [^ self].	scorePlayer == nil		ifTrue: [(ms _ Time millisecondClockValue) < msAtStart ifTrue:  "clock rollover"					[msAtStart _ ms - (frameNumber * msPerFrame)].				simTime _ ms - msAtStart]		ifFalse: [simTime _ scorePlayer millisecondsSinceStart].	playDirection > 0		ifTrue: [nextFrameNumber _ frameAtLastSync + ((simTime - msAtLastSync)//msPerFrame).				nextFrameNumber = frameNumber ifTrue:					[((scorePlayer isKindOf: AbstractSound) and: [scorePlayer isPlaying not])						ifTrue: [^ self stopRunning].					^ self]]		ifFalse: [playDirection < 0 ifTrue: [nextFrameNumber _ frameNumber - 1]								ifFalse: [nextFrameNumber _ frameNumber]].	byteCount _ self fileByteCountPerFrame.	movieFile waitForCompletion.	movieFile primReadResult: movieFile fileHandle			intoBuffer: currentPage image bits			at: 1 count: byteCount//4.	currentPage changed.	frameNumber _ nextFrameNumber.		(playDirection = 0		or: [(playDirection > 0 and: [frameNumber >= frameCount])		or: [playDirection < 0 and: [frameNumber <= 1]]])		ifTrue: [^ self stopRunning].	"Start the read operation for the next frame..."	movieFile primReadStart: movieFile fileHandle			fPosition: (self filePosForFrameNo: frameNumber)			count: byteCount.! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 5/31/1999 16:41'!stopRunning	"Must only be called with no outstanding file read requests..."	movieFile ifNotNil: [movieFile close.  movieFile _ nil].	playDirection _ 0.	self stopSoundTrackIfAny! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 5/31/1999 16:57'!addSoundTrack	| fileName |	fileName _ Utilities chooseFileWithSuffixFromList: #('.aif' '.wav')					withCaption: 'Choose a sound track file'.	fileName == nil ifTrue: [^ self].	('*aif' match: fileName) ifTrue:		[scorePlayer _ SampledSound fromAIFFfileNamed: fileName].	('*wav' match: fileName) ifTrue:		[scorePlayer _ SampledSound fromWaveFileNamed: fileName].! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 5/30/1999 12:37'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu sel |	aMenu _ MVCMenuMorph new.	aMenu addList:	#(			('make thumbnail'		thumbnailForThisPage)			('open movie file'		openMovieFile)			('add sound track'		addSoundTrack)		).	(sel _ aMenu invokeAt: self primaryHand position in: self world)		ifNotNil: [self perform: sel].! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 5/30/1999 12:40'!openMovieFile	| fileName |	fileName _ Utilities chooseFileWithSuffixFromList: #('.movie')					withCaption: 'Choose a movie file to open'.	fileName ifNotNil: [self openFileNamed: fileName]! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 5/30/1999 12:40'!thumbnailForThisPage	"Overridden to make a MovieFrameSyncMorph"	| image |	image _ currentPage image.	self activeHand attachMorph:		(MovieFrameSyncMorph new			image: (image magnifyBy: 50 asFloat / (image width max: image height))			player: self frameNumber: frameNumber)! !!ScorePlayer methodsFor: 'accessing' stamp: 'di 5/30/1999 12:46'!millisecondsSinceStart	"Answer the approximate number of milliseconds of real time since the beginning of the score. Since this calculation uses the current tempo, which can change throughout the piece, it is safer to use ticksSinceStart for synchronization."	^ (secsPerTick * ticksSinceStart * 1000) asInteger! !MoviePlayerMorph removeSelector: #openSoundTrackIfAny!MoviePlayerMorph removeSelector: #openSoundTrack!MoviePlayerMorph removeSelector: #frameNumber:!MoviePlayerMorph removeSelector: #msSinceStart:!ScorePlayer removeSelector: #msecsSinceStart!