'From Squeak2.9alpha of 16 June 2000 [latest update: #3218] on 3 January 2001 at 1:44:16 pm'!"Change Set:		ProjStore9-tkDate:			3 January 2001Author:			Ted KaehlerNew tiles refer to self and to other Players by using names in Scott's References dictionary.  This makes veryDeepCopy (green handle) give the copy a new name and enter it in References.  Fixes up all viewers, script methods, and tiles.Speeds up renaming and grabbing an object by restrincting use of externalName, and using knownName instead.  It does not try to name the object."!!DeepCopier commentStamp: 'tk 1/2/2001 11:32' prior: 0!I do veryDeepCopy.  I hold the dictionary of objects seen, and the correspondance (uniClass -> new uniClass).  See Object|veryDeepCopy which calls (self veryDeepCopyWith: aDeepCopier).When a tree of Morphs points at a morph outside of it, that morph should not be copied.  Use our own kind of weak pointers for the potentially outside morphs.   Default is that any new class will have all of its newly defined fields deeply copied.  If a field needs to be weakly copied, define veryDeepInner: and veryDeepFixupWith:.     veryDeepInner: has the loop that actually copies the fields.  If a class defines its own copy of veryDeepInner: (to leave some fields out), then veryDeepFixupWith: will be called on that object at the end.  veryDeepInner: can find an alternate object to put in a field.(Object veryDeepCopyWith: notes which superclasses did not do veryDeepInner:, and very deep copies those vars).Key to seeing if you have to add the methods veryDeepFixupWith:   and   veryDeepInner:Does field X contain a morph?  If not, no action needed.Is the morph in field X a submorph of the object?  Is it down lower in the submorph tree?	If so, no action needed.Could the morph in field X every appear on the screen (be a submorph of some other morph)?	If not, no action needed.	If so, you must write the methods veryDeepFixupWith:   and   veryDeepInner:, and in them, refrain from sending veryDeepCopyWith: to the contents of field X.Rule:  If a morph stores a uniClass class (Player 57) as an object in a field, the new uniClass will not be stored there.   Each uniClass instance does have a new class created for it.  (fix this by putting the old class in references and allow lookup?  Wrong if encounter it before seeing an instance?)Rule: If object A has object C in a field, and A says (^ C) for the copy, but object B has A in a normal field and it gets deepCopied, and A in encountered first, then there will be two copies of C.  (just be aware of it)Dependents are now fixed up.  Suppose a model has a dependent view.  In the DependentFields dictionary, model -> (view ...).  	If only the model is copied, no dependents are created (no one knows about the new model).  	If only the view is copied, it is inserted into DependentFields on the right side.  model -> (view  copiedView ...).  	If both are copied, the new model has the new view as its dependent.	If additional things depend on a model that is copied, the caller must add them to its dependents.!!Object methodsFor: 'copying' stamp: 'tk 1/2/2001 10:53'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  All references to the object in the copy of the tree will point to the new copy."	| copier new refs newDep newModel |	copier _ DeepCopier new initialize: self initialDeepCopierSize.	new _ self veryDeepCopyWith: copier.	copier mapUniClasses.	copier references associationsDo: [:assoc | 		assoc value veryDeepFixupWith: copier].	"Fix dependents"	refs _ copier references.	DependentsFields associationsDo: [:pair |		pair value do: [:dep | 			(newDep _ refs at: dep ifAbsent: [nil]) ifNotNil: [				newModel _ refs at: pair key ifAbsent: [pair key].				newModel addDependent: newDep]]].	^ new! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 1/3/2001 07:25'!mapUniClasses	"For new Uniclasses, map their class vars to the new objects.  And their additional class instance vars.  (scripts slotInfo) and cross references like (player321)."	"Players also refer to each other using associations in the References dictionary.  Search the methods of our Players for those.  Make new entries in References and point to them."| pp oldPlayer newKey newAssoc oldSelList newSelList |"Uniclasses use class vars to hold onto siblings who are referred to in code"pp _ Object class instSize + 1.uniClasses do: [:playersClass | "values = new ones"	playersClass classPool associationsDo: [:assoc |		assoc value: (assoc value veryDeepCopyWith: self)].	playersClass scripts: (playersClass privateScripts veryDeepCopyWith: self).	"pp+0"	"(pp+1) slotInfo was deepCopied in copyUniClass and that's all it needs"	pp+2 to: playersClass class instSize do: [:ii | 		playersClass instVarAt: ii put: 			((playersClass instVarAt: ii) veryDeepCopyWith: self)].	]."Make new entries in References and point to them."References keys "copy" do: [:playerName |	oldPlayer _ References at: playerName.	(references includesKey: oldPlayer) ifTrue: [		newKey _ (references at: oldPlayer) "new player" uniqueNameForReference.		"now installed in References"		(references at: oldPlayer) renameTo: newKey]].uniClasses "values" do: [:newClass |	oldSelList _ OrderedCollection new.   newSelList _ OrderedCollection new.	newClass selectorsDo: [:sel | 		(newClass compiledMethodAt: sel)	 literals do: [:assoc |			assoc class == Association ifTrue: [				(References associationAt: assoc key) == assoc ifTrue: [					newKey _ (references at: assoc value ifAbsent: [assoc value]) 									externalName asSymbol.					(assoc key ~= newKey) & (References includesKey: newKey) ifTrue: [						newAssoc _ References associationAt: newKey.						newClass methodDictionary at: sel put: 							(newClass compiledMethodAt: sel) clone.	"were sharing it"						ii _ (newClass compiledMethodAt: sel) literals indexOf: assoc.						(newClass compiledMethodAt: sel) literalAt: ii put: newAssoc.						(oldSelList includes: assoc key) ifFalse: [							oldSelList add: assoc key.  newSelList add: newKey]]]]]].	oldSelList with: newSelList do: [:old :new |			newClass replaceSilently: old to: new]].	"This is text replacement and can be wrong"! !!FreeTranslation class methodsFor: 'as yet unclassified' stamp: 'tk 1/3/2001 08:58'!translatePanel: buttonPlayer fromTo: normalDirection	| ow fromTM toTM fromLang toLang tt doc answer width |	"Gather up all the info I need from the morphs in the button's owner and do the translation.  Insert the results in a TextMorph.  Use www.freeTranslation.com Refresh the banner ad.	TextMorph with 'from' in the title is starting text.	PopUpChoiceMorph  with 'from' in the title is the starting language.	TextMorph with 'from' in the title is place to put the answer.	PopUpChoiceMorph  with 'from' in the title is the target language.		If normalDirection is false, translate the other direction."	ow _ buttonPlayer costume ownerThatIsA: PasteUpMorph.	ow allMorphs do: [:mm |		(mm isKindOf: TextMorph) ifTrue: [ 			(mm knownName asString includesSubString: 'from') ifTrue: [				 fromTM _ mm].			(mm knownName asString includesSubString: 'to') ifTrue: [				 toTM _ mm]].		(mm isKindOf: PopUpChoiceMorph) ifTrue: [ 			(mm knownName asString includesSubString: 'from') ifTrue: [				 fromLang _ mm contents asString].			(mm owner knownName asString includesSubString: 'from') ifTrue: [				 fromLang _ mm contents asString].			(mm knownName asString includesSubString: 'to') ifTrue: [				 toLang _ mm contents asString].			(mm owner knownName asString includesSubString: 'to') ifTrue: [				 toLang _ mm contents asString]]].	normalDirection ifFalse: ["switch"		tt _ fromTM.  fromTM _ toTM.  toTM _ tt.		tt _ fromLang.  fromLang _ toLang.  toLang _ tt].	Cursor wait showWhile: [		doc _ self translate: fromTM contents asString from: fromLang to: toLang.		answer _ self extract: doc].	"pull out the translated text"		width _ toTM width.	toTM contents: answer wrappedTo: width.	toTM changed.! !!MessageSend methodsFor: 'tiles' stamp: 'tk 1/2/2001 14:27'!stringFor: anObject	| generic aName |	"Return a string suitable for compiling.  Literal or reference from global ref dictionary.  self is always named via the ref dictionary."	anObject isLiteral ifTrue: [^ anObject printString].	anObject class == Color ifTrue: [^ anObject printString].	anObject class superclass == Boolean ifTrue: [^ anObject printString].	anObject class == BlockContext ifTrue: [^ '[''do nothing'']'].	"default block"		"Real blocks need to construct tiles in a different way"	generic _ anObject knownName.	"may be nil or 'Ellipse' "	aName _ anObject uniqueNameForReference.	generic = aName ifFalse: [anObject renameTo: aName].	^ aName! !!Morph methodsFor: 'dropping/grabbing' stamp: 'tk 1/3/2001 12:46'!undoGrabCommand	"Return the undo command for grabbing the receiver"	| cmd |	owner ifNil:[^nil]. "no owner - no undo"	^(cmd _ Command new)		cmdWording: 'move ', (String streamContents: [:s | self printOn: s] limitedTo: 18);		undoTarget: self		selector: #undoMove:redo:owner:bounds:predecessor:		arguments: {cmd. false. owner. self bounds. (owner morphPreceding: self)}! !!Morph methodsFor: 'naming' stamp: 'tk 1/3/2001 13:26'!renameTo: aName	"Set Player name in costume.  Update Viewers.  Fix all tiles (old style).  fix References.  New tiles: recompile, and recreate open scripts.  If coming in from disk, and have name conflict, References will already have new name."	| aPresenter putInViewer aPasteUp renderer oldKey assoc classes oldName |	oldName _ self knownName.	(renderer _ self topRendererOrSelf) setNameTo: aName.	putInViewer _ false.	(aPresenter _ self presenter) ifNotNil:		[putInViewer _ aPresenter currentlyViewing: renderer player.		putInViewer ifTrue: [			renderer player viewerFlapTab hibernate]].  "empty it temporarily"	(aPasteUp _ self topPasteUp) ifNotNil:		[aPasteUp allTileScriptingElements do: [:m | m bringUpToDate]].	"Fix References dictionary.  See restoreReferences to know why oldKey is 		already aName, but oldName is the old name."	oldKey _ References keyAtIdentityValue: renderer player ifAbsent: [nil].	oldKey ifNotNil: [		assoc _ References associationAt: oldKey.		oldKey = aName ifFalse: ["normal rename"			assoc key: aName asSymbol.			References rehash]].	putInViewer ifTrue: [aPresenter viewMorph: self].	"recreate my viewer"	oldKey ifNil: [^ aName].	"Force strings in tiles to be remade with new name.  New tiles only."	(aPasteUp valueOfProperty: #universalTiles ifAbsent: [false]) ifFalse: [^ aName].	classes _ (Smalltalk allCallsOn: assoc) collect: [:classAndMethod | 		(classAndMethod findTokens: Character separators) first asSymbol].	(classes asSet) do: [:clsName |		(Smalltalk at: clsName) replaceSilently: oldName to: aName].		"replace in text body of all methods.  Can be wrong!!"	"Redo the tiles that are showing"	aPasteUp allTileScriptingElements do: [:mm | "just ScriptEditorMorphs"		(mm isKindOf: ScriptEditorMorph) ifTrue: [			((mm playerScripted class compiledMethodAt: mm scriptName) hasLiteral: assoc)				ifTrue: [mm hibernate; unhibernate]]].	^ aName! !!BookMorph methodsFor: 'accessing' stamp: 'tk 1/3/2001 08:54'!pageNamed: aName	^ pages detect: [:p | p knownName = aName] ifNone: [nil]! !!Player methodsFor: 'misc' stamp: 'tk 1/3/2001 09:37'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ self knownName ifNil: ['An unaffiliated Player'] ifNotNil: [self knownName]! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'tk 1/3/2001 10:22'!bringUpToDate	"Make certain that the script name and the names of actors within are up to date"	| currentName titleMorph newName |	playerScripted ifNil: ["likely a naked test/yes/no fragment!!" ^ self].	currentName _ playerScripted externalName.	submorphs size = 0 ifTrue: [^ self].	self firstSubmorph "align" submorphsDo: [:m | "try quick way"				m knownName = 'title' ifTrue: [titleMorph _ m]].	titleMorph ifNil: [		titleMorph _ self firstSubmorph findDeepSubmorphThat: [:m | m knownName = 'title'] 								ifAbsent: [nil]].	titleMorph ifNotNil:		[newName _ self isAnonymous			ifTrue:				['script']			ifFalse:				[self scriptName].		titleMorph label: currentName, ' ', newName font: ScriptingSystem fontForTiles]! !