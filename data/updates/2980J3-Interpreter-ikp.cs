'From Squeak2.8 of 13 June 2000 [latest update: #2359] on 27 October 2000 at 4:30:12 pm'!ObjectMemory subclass: #Interpreter	instanceVariableNames: 'activeContext theHomeContext method receiver instructionPointer stackPointer localIP localSP localHomeContext messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache atCache lkupClass reclaimableContextCount nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignalA semaphoresUseBufferA semaphoresToSignalCountA semaphoresToSignalB semaphoresToSignalCountB savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals compilerInitialized compilerHooks extraVMMemory newNativeMethod methodClass receiverClass interpreterVersion obsoleteIndexedPrimitiveTable obsoleteNamedPrimitiveTable interpreterProxy showSurfaceFn interruptCheckCounterFeedBackReset interruptChecksEveryNms '	classVariableNames: 'ActiveProcessIndex AtCacheEntries AtCacheFixedFields AtCacheFmt AtCacheMask AtCacheOop AtCacheSize AtCacheTotalSize AtPutBase BlockArgumentCountIndex BytecodeTable CacheProbeMax CallerIndex CharacterValueIndex CompilerHooksSize CrossedX DirBadPath DirEntryFound DirNoMoreEntries EndOfRun ExcessSignalsIndex FirstLinkIndex GenerateBrowserPlugin HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex JitterTable LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageLookupClassIndex MessageSelectorIndex MethodArrayIndex MethodCacheClass MethodCacheEntries MethodCacheEntrySize MethodCacheMask MethodCacheMethod MethodCacheNative MethodCachePrim MethodCacheSelector MethodCacheSize MethodIndex MillisecondClockMask MyListIndex NextLinkIndex PrimitiveExternalCallIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'VMConstruction-Interpreter'!!Interpreter methodsFor: 'initialization' stamp: 'ikp 10/16/2000 15:16'!initializeInterpreter: bytesToShift	"Initialize Interpreter state before starting execution of a new image."	interpreterProxy _ self sqGetInterpreterProxy.	self initializeObjectMemory: bytesToShift.	self initCompilerHooks.	self flushExternalPrimitives.	activeContext	_ nilObj.	theHomeContext	_ nilObj.	method			_ nilObj.	receiver		_ nilObj.	messageSelector	_ nilObj.	newMethod		_ nilObj.	methodClass		_ nilObj.	lkupClass		_ nilObj.	receiverClass	_ nilObj.	self flushMethodCache.	self loadInitialContext.	interruptCheckCounter _ 0.	interruptCheckCounterFeedBackReset _ 1000.	interruptChecksEveryNms _ 5.	nextPollTick _ 0.	nextWakeupTick _ 0.	lastTick _ 0.	interruptKeycode _ 2094.  "cmd-."	interruptPending _ false.	semaphoresUseBufferA _ true.	semaphoresToSignalCountA _ 0.	semaphoresToSignalCountB _ 0.	deferDisplayUpdates _ false.	pendingFinalizationSignals _ 0.! !!Interpreter methodsFor: 'object memory support' stamp: 'ikp 10/26/2000 17:46'!mapInterpreterOops	"Map all oops in the interpreter's state to their new values during garbage collection or a become: operation."	"Assume: All traced variables contain valid oops."	| oop |	nilObj				_ self remap: nilObj.	falseObj				_ self remap: falseObj.	trueObj				_ self remap: trueObj.	specialObjectsOop	_ self remap: specialObjectsOop.	compilerInitialized ifFalse: [		stackPointer 		_ stackPointer - activeContext.	"*rel to active"		activeContext		_ self remap: activeContext.		stackPointer 		_ stackPointer + activeContext.	"*rel to active"		theHomeContext		_ self remap: theHomeContext.	].	instructionPointer 	_ instructionPointer - method.	"*rel to method"	method				_ self remap: method.	instructionPointer 	_ instructionPointer + method.	"*rel to method"	receiver			_ self remap: receiver.	messageSelector		_ self remap: messageSelector.	newMethod			_ self remap: newMethod.	methodClass			_ self remap: methodClass.	lkupClass			_ self remap: lkupClass.	receiverClass		_ self remap: receiverClass.	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			remapBuffer at: i put: (self remap: oop).		].	].	"The method cache uses oops as hashes -- toss the whole thing."	self flushMethodCache.! !!Interpreter methodsFor: 'object memory support' stamp: 'ikp 11/22/1999 12:13'!markAndTraceInterpreterOops	"Mark and trace all oops in the interpreter's state."	"Assume: All traced variables contain valid oops."	| oop |	self compilerMarkHook.	self markAndTrace: specialObjectsOop.		"also covers nilObj, trueObj, falseObj, and compact classes"	compilerInitialized		ifTrue:			[self markAndTrace: receiver.			 self markAndTrace: method]		ifFalse:			[self markAndTrace: activeContext.  "traces entire stack"				"also covers theHomeContext, receiver, method"].	self markAndTrace: messageSelector.	self markAndTrace: newMethod.	self markAndTrace: methodClass.	self markAndTrace: lkupClass.	self markAndTrace: receiverClass.	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			self markAndTrace: oop.		].	].! !!Interpreter methodsFor: 'object memory support' stamp: 'ikp 11/22/1999 12:09'!postGCAction	"Mark the active and home contexts as roots if old. This allows the interpreter to use storePointerUnchecked to store into them."	compilerInitialized		ifTrue:			[self compilerPostGC]		ifFalse:			[(activeContext    < youngStart) ifTrue: [ self beRootIfOld: activeContext ].			 (theHomeContext < youngStart) ifTrue: [ self beRootIfOld: theHomeContext ]]! !!Interpreter methodsFor: 'object memory support' stamp: 'ikp 11/22/1999 12:10'!preGCAction: fullGCFlag	compilerInitialized		ifTrue:			[self compilerPreGC: fullGCFlag]		ifFalse:			[self storeContextRegisters: activeContext].! !!Interpreter methodsFor: 'contexts' stamp: 'ikp 11/14/1999 23:44'!isContextHeader: aHeader	| ccIndex |	self inline: true.	ccIndex _ (aHeader >> 12) bitAnd: 16r1F.	^ ccIndex = 13			"MethodContext"		or: [ccIndex = 14		"BlockContext"		or: [ccIndex = 4]]	"PseudoContext"! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 10/26/2000 15:57'!activateNewMethod	| newContext methodHeader initialIP tempCount nilOop |	methodHeader _ self headerOf: newMethod.	newContext _ self allocateOrRecycleContext: (methodHeader bitAnd: LargeContextBit).	initialIP _ ((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1.	tempCount _ (methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf: initialIP).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	0 to: argumentCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self stackValue: argumentCount-i)].	"clear remaining temps to nil in case it has been recycled"	nilOop _ nilObj.	argumentCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: nilOop].	self pop: argumentCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self newActiveContext: newContext.! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 11/20/1999 05:05'!createActualMessageTo: aClass	"Bundle up the selector, arguments and lookupClass into a Message object.	In the process it pops the arguments off the stack, and pushes the message object.	This can then be presented as the argument of e.g. #doesNotUnderstand:.	ikp 11/20/1999 03:59 -- added hook for external runtime compilers."	| argumentArray message lookupClass |	"remap lookupClass in case GC happens during allocation"	self pushRemappableOop: aClass.	argumentArray _ self instantiateClass: (self splObj: ClassArray)							indexableSize: argumentCount.	"remap argumentArray in case GC happens during allocation"	self pushRemappableOop: argumentArray.	message _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	argumentArray _ self popRemappableOop.	lookupClass _ self popRemappableOop.	self beRootIfOld: argumentArray.	compilerInitialized		ifTrue:			[self compilerCreateActualMessage: message storingArgs: argumentArray]		ifFalse:			[self transfer: argumentCount				from: stackPointer - ((argumentCount - 1) * 4)				to: argumentArray + BaseHeaderSize.			 self pop: argumentCount thenPush: message].	argumentCount _ 1.	self storePointer: MessageSelectorIndex ofObject: message		withValue: messageSelector.	self storePointer: MessageArgumentsIndex ofObject: message		withValue: argumentArray.	(self lastPointerOf: message) >= (MessageLookupClassIndex*4 +BaseHeaderSize) ifTrue:	["Only store lookupClass if message has 3 fields (old images don't)"	self storePointer: MessageLookupClassIndex ofObject: message		withValue: lookupClass].! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 10/27/2000 14:11'!findNewMethodInClass: class	"Find the compiled method to be run when the current messageSelector is sent to the given class, setting the values of 'newMethod' and 'primitiveIndex'."	| ok |	self inline: false.	ok _ self lookupInMethodCacheSel: messageSelector class: class.	ok ifFalse: [		"entry was not found in the cache; look it up the hard way"		self lookupMethodInClass: class.		lkupClass _ class.		self addNewMethodToCache.	].! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 10/26/2000 15:58'!internalActivateNewMethod	| methodHeader newContext tempCount argCount needsLarge |	self inline: true.	methodHeader _ self headerOf: newMethod.	needsLarge _ methodHeader bitAnd: LargeContextBit.	(needsLarge = 0 and: [freeContexts ~= NilContext])		ifTrue: [newContext _ freeContexts.				freeContexts _ self fetchPointer: 0 ofObject: newContext]		ifFalse: ["Slower call for large contexts or empty free list"				self externalizeIPandSP.				newContext _ self allocateOrRecycleContext: needsLarge.				self internalizeIPandSP].	tempCount _ (methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf:			(((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1)).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	argCount _ argumentCount.	0 to: argCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self internalStackValue: argCount-i)].	"clear remaining temps to nil in case it has been recycled"	methodHeader _ nilObj.  "methodHeader here used just as faster (register?) temp"	argCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: methodHeader].	self internalPop: argCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self internalNewActiveContext: newContext.! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 10/27/2000 14:11'!internalFindNewMethod	"Find the compiled method to be run when the current messageSelector is sent to the class 'lkupClass', setting the values of 'newMethod' and 'primitiveIndex'."	| ok | 	self inline: true.	self sharedCodeNamed: 'commonLookup' inCase: 131.	ok _ self lookupInMethodCacheSel: messageSelector class: lkupClass.	ok ifFalse: [		"entry was not found in the cache; look it up the hard way"		self externalizeIPandSP.		self lookupMethodInClass: lkupClass.		self internalizeIPandSP.		self addNewMethodToCache].! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 10/24/1999 03:58'!lookupMethodInClass: class	| currentClass dictionary found rclass |	self inline: false.	currentClass _ class.	[currentClass ~= nilObj]		whileTrue:		[dictionary _ self fetchPointer: MessageDictionaryIndex ofObject: currentClass.		dictionary = nilObj ifTrue:			["MethodDict pointer is nil (hopefully due a swapped out stub)				-- raise exception #cannotInterpret:."			self pushRemappableOop: currentClass.  "may cause GC!!"			self createActualMessageTo: class.			currentClass _ self popRemappableOop.			messageSelector _ self splObj: SelectorCannotInterpret.			^ self lookupMethodInClass: (self superclassOf: currentClass)].		found _ self lookupMethodInDictionary: dictionary.		found ifTrue: [^ methodClass _ currentClass].		currentClass _ self superclassOf: currentClass].	"Could not find #doesNotUnderstand: -- unrecoverable error."	messageSelector = (self splObj: SelectorDoesNotUnderstand) ifTrue:		[self error: 'Recursive not understood error encountered'].	"Cound not find a normal message -- raise exception #doesNotUnderstand:"	self pushRemappableOop: class.  "may cause GC!!"	self createActualMessageTo: class.	rclass _ self popRemappableOop.	messageSelector _ self splObj: SelectorDoesNotUnderstand.	^ self lookupMethodInClass: rclass! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 11/14/1999 23:52'!normalSend	"Send a message, starting lookup with the receiver's class."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| rcvr |	self inline: true.	self sharedCodeNamed: 'commonSend' inCase: 131.	rcvr _ self internalStackValue: argumentCount.	receiverClass _ lkupClass _ self fetchClassOf: rcvr.	self internalFindNewMethod.	self internalExecuteNewMethod.	self fetchNextBytecode.! !!Interpreter methodsFor: 'message sending' stamp: 'ikp 11/14/1999 23:55'!superclassSend	"Send a message to self, starting lookup with the superclass of the class containing the currently executing method."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| rcvr |	self inline: true.	self sharedCodeNamed: 'commonSupersend' inCase: 133.	lkupClass _ self superclassOf: (self methodClassOf: method).	rcvr _ self internalStackValue: argumentCount.	receiverClass _ self fetchClassOf: rcvr.	self internalFindNewMethod.	self internalExecuteNewMethod.	self fetchNextBytecode.! !!Interpreter methodsFor: 'method lookup cache' stamp: 'ikp 10/24/1999 04:17'!addNewMethodToCache	"Add the given entry to the method cache.	The policy is as follows:		Look for an empty entry anywhere in the reprobe chain.		If found, install the new entry there.		If not found, then install the new entry at the first probe position			and delete the entries in the rest of the reprobe chain.		This has two useful purposes:			If there is active contention over the first slot, the second				or third will likely be free for reentry after ejection.			Also, flushing is good when reprobe chains are getting full."	| probe hash |	self inline: false.	self compilerTranslateMethodHook.	"newMethod x lkupClass -> newNativeMethod (may cause GC !!)"	hash _ messageSelector bitXor: lkupClass.  "drop low-order zeros from addresses"	0 to: CacheProbeMax-1 do:		[:p | probe _ (hash >> p) bitAnd: MethodCacheMask.		(methodCache at: probe + MethodCacheSelector) = 0 ifTrue:				["Found an empty entry -- use it"				methodCache at: probe + MethodCacheSelector put: messageSelector.				methodCache at: probe + MethodCacheClass put: lkupClass.				methodCache at: probe + MethodCacheMethod put: newMethod.				methodCache at: probe + MethodCachePrim put: primitiveIndex.				methodCache at: probe + MethodCacheNative put: newNativeMethod.				^ nil]].	"OK, we failed to find an entry -- install at the first slot..."	probe _ hash bitAnd: MethodCacheMask.  "first probe"	methodCache at: probe + MethodCacheSelector put: messageSelector.	methodCache at: probe + MethodCacheClass put: lkupClass.	methodCache at: probe + MethodCacheMethod put: newMethod.	methodCache at: probe + MethodCachePrim put: primitiveIndex.	methodCache at: probe + MethodCacheNative put: newNativeMethod.	"...and zap the following entries"	1 to: CacheProbeMax-1 do:		[:p | probe _ (hash >> p) bitAnd: MethodCacheMask.		methodCache at: probe + MethodCacheSelector put: 0].! !!Interpreter methodsFor: 'method lookup cache' stamp: 'ikp 10/24/1999 03:20'!lookupInMethodCacheSel: selector class: class	"This method implements a simple method lookup cache. If an entry for the given selector and class is found in the cache, set the values of 'newMethod' and 'primitiveIndex' and return true. Otherwise, return false."	"About the re-probe scheme: The hash is the low bits of the XOR of two large addresses, minus their useless lowest two bits. If a probe doesn't get a hit, the hash is shifted right one bit to compute the next probe, introducing a new randomish bit. The cache is probed CacheProbeMax times before giving up."	"WARNING: Since the hash computation is based on the object addresses of the class and selector, we must rehash or flush when compacting storage. We've chosen to flush, since that also saves the trouble of updating the addresses of the objects in the cache."	| hash probe |	self inline: true.	hash _ selector bitXor: class.  "shift drops two low-order zeros from addresses"	probe _ hash bitAnd: MethodCacheMask.  "first probe"	(((methodCache at: probe + MethodCacheSelector) = selector) and:		 [(methodCache at: probe + MethodCacheClass) = class]) ifTrue:			[newMethod _ methodCache at: probe + MethodCacheMethod.			primitiveIndex _ methodCache at: probe + MethodCachePrim.			newNativeMethod _ methodCache at: probe + MethodCacheNative.			^ true	"found entry in cache; done"].	probe _ (hash >> 1) bitAnd: MethodCacheMask.  "second probe"	(((methodCache at: probe + MethodCacheSelector) = selector) and:		 [(methodCache at: probe + MethodCacheClass) = class]) ifTrue:			[newMethod _ methodCache at: probe + MethodCacheMethod.			primitiveIndex _ methodCache at: probe + MethodCachePrim.			newNativeMethod _ methodCache at: probe + MethodCacheNative.			^ true	"found entry in cache; done"].	probe _ (hash >> 2) bitAnd: MethodCacheMask.	(((methodCache at: probe + MethodCacheSelector) = selector) and:		 [(methodCache at: probe + MethodCacheClass) = class]) ifTrue:			[newMethod _ methodCache at: probe + MethodCacheMethod.			primitiveIndex _ methodCache at: probe + MethodCachePrim.			newNativeMethod _ methodCache at: probe + MethodCacheNative.			^ true	"found entry in cache; done"].	^ false! !!Interpreter methodsFor: 'processes' stamp: 'ikp 9/14/2000 01:26'!transferTo: aProc	"Record a process to be awoken on the next interpreter cycle.	ikp 11/24/1999 06:07 -- added hook for external runtime compiler"	| sched oldProc newProc |	newProc _ aProc.	sched _ self schedulerPointer.	oldProc _ self fetchPointer: ActiveProcessIndex ofObject: sched.	self storePointer: ActiveProcessIndex ofObject: sched withValue: newProc.	compilerInitialized ifTrue: [		self compilerProcessChange: oldProc to: newProc.	] ifFalse: [		self storePointer: SuspendedContextIndex ofObject: oldProc withValue: activeContext.		self newActiveContext: (self fetchPointer: SuspendedContextIndex ofObject: newProc)	].	reclaimableContextCount _ 0.! !!Interpreter methodsFor: 'other primitives' stamp: 'ikp 12/8/1999 11:04'!primitiveSnapshot	| activeProc dataSize rcvr |	"update state of active context"	compilerInitialized		ifTrue: [self compilerPreSnapshot]		ifFalse: [self storeContextRegisters: activeContext].	"update state of active process"	activeProc _ self		fetchPointer: ActiveProcessIndex		ofObject: self schedulerPointer.	self	storePointer: SuspendedContextIndex		ofObject: activeProc		withValue: activeContext.	"compact memory and compute the size of the memory actually in use"	self cleanUpContexts.	self incrementalGC.  "maximimize space for forwarding table"	self fullGC.	dataSize _ freeBlock - (self startOfMemory).	"Assume: all objects are below the start of the free block"	successFlag ifTrue: [		rcvr _ self popStack.  "pop rcvr"		self push: trueObj.		self writeImageFile: dataSize.		self pop: 1.  "pop true"	].	successFlag		ifTrue: [ self push: falseObj ]		ifFalse: [ self push: rcvr ].	compilerInitialized		ifTrue: [self compilerPostSnapshot].! !!Interpreter methodsFor: 'debug support' stamp: 'ikp 10/24/1999 03:57'!printCallStack	| ctxt home methClass methodSel |	ctxt _ activeContext.	[ctxt = nilObj] whileFalse: [		(self fetchClassOf: ctxt) = (self splObj: ClassBlockContext)			ifTrue: [ home _ self fetchPointer: HomeIndex ofObject: ctxt ]			ifFalse: [ home _ ctxt ].		methClass _			self findClassOfMethod: (self fetchPointer: MethodIndex ofObject: home)					   forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		methodSel _			self findSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)						 forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		self printNum: ctxt.		self print: ' '.		ctxt = home ifFalse: [ self print: '[] in ' ].		self printNameOfClass: methClass count: 5.		self print: '>'.		self printStringOf: methodSel.		self cr.		ctxt _ (self fetchPointer: SenderIndex ofObject: ctxt).	].! !!Interpreter methodsFor: 'plugin support' stamp: 'ikp 10/11/2000 17:29'!flushExternalPrimitiveOf: methodPtr	"methodPtr is a CompiledMethod containing an external primitive. Flush the function address and session ID of the CM"	| lit |	(self literalCountOf: methodPtr) > 0 ifFalse:[^nil]. "Something's broken"	lit _ self literal: 0 ofMethod: methodPtr.	((self fetchClassOf: lit) = (self splObj: ClassArray) and:[(self lengthOf: lit) = 4])		ifFalse:[^nil]. "Something's broken"	self storeInteger: 2 ofObject: lit withValue: 0.	self storeInteger: 3 ofObject: lit withValue: 0.! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 11/20/1999 05:05'!compilerCreateActualMessage: aMessage storingArgs: argArray	^self cCode: 'compilerHooks[14](aMessage, argArray)'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 11/24/1999 07:09'!compilerProcessChange: oldProc to: newProc	^self cCode: 'compilerHooks[6](oldProc, newProc)'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 10/22/1999 17:01'!compilerTranslateMethod	^self cCode: 'compilerHooks[1]()'! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 10/22/1999 17:01'!compilerTranslateMethodHook	self inline: true.	^compilerInitialized and: [self compilerTranslateMethod]! !!Interpreter methodsFor: 'compiler support' stamp: 'ikp 11/20/1999 04:53'!initCompilerHooks	"Initialize hooks for the 'null compiler'"	self cCode: 'compilerHooks[1]= nullCompilerHook'.	self cCode: 'compilerHooks[2]= nullCompilerHook'.	self cCode: 'compilerHooks[3]= nullCompilerHook'.	self cCode: 'compilerHooks[4]= nullCompilerHook'.	self cCode: 'compilerHooks[5]= nullCompilerHook'.	self cCode: 'compilerHooks[6]= nullCompilerHook'.	self cCode: 'compilerHooks[7]= nullCompilerHook'.	self cCode: 'compilerHooks[8]= nullCompilerHook'.	self cCode: 'compilerHooks[9]= nullCompilerHook'.	self cCode: 'compilerHooks[10]= nullCompilerHook'.	self cCode: 'compilerHooks[11]= nullCompilerHook'.	self cCode: 'compilerHooks[12]= nullCompilerHook'.	self cCode: 'compilerHooks[13]= nullCompilerHook'.	self cCode: 'compilerHooks[14]= nullCompilerHook'.	compilerInitialized _ false! !!Interpreter class methodsFor: 'initialization' stamp: 'ikp 10/26/2000 18:02'!initializeCaches	| atCacheEntrySize |	MethodCacheEntries _ 512. 	MethodCacheSelector _ 1.	MethodCacheClass _ 2.	MethodCacheMethod _ 3.	MethodCachePrim _ 4.	MethodCacheNative _ 5.	MethodCacheEntrySize _ 8.  "Must be power of two for masking scheme."	MethodCacheMask _ (MethodCacheEntries - 1) * MethodCacheEntrySize.	MethodCacheSize _ MethodCacheEntries * MethodCacheEntrySize.	CacheProbeMax _ 3.	AtCacheEntries _ 8.  "Must be power of two"	AtCacheOop _ 1.	AtCacheSize _ 2.	AtCacheFmt _ 3.	AtCacheFixedFields _ 4.	atCacheEntrySize _ 4.  "Must be power of two for masking scheme."	AtCacheMask _ (AtCacheEntries-1) * atCacheEntrySize.	AtPutBase _ AtCacheEntries * atCacheEntrySize.	AtCacheTotalSize _ AtCacheEntries * atCacheEntrySize * 2.! !!Interpreter class methodsFor: 'initialization' stamp: 'ikp 10/27/2000 14:47'!initializeCompilerHooks	"Interpreter initializeCompilerHooks"	"compilerHooks[] indices:	1	void compilerTranslateMethodHook(void)	2	void compilerFlushCacheHook(CompiledMethod *oldMethod)	3	void compilerPreGCHook(int fullGCFlag)	4	void compilerMapHook(int memStart, int memEnd)	5	void compilerPostGCHook(void)	6	void compilerProcessChangeHook(void)	7	void compilerPreSnapshotHook(void)	8	void compilerPostSnapshotHook(void)	9	void compilerMarkHook(void)	10	void compilerActivateMethodHook(void)	11	void compilerNewActiveContextHook(int sendFlag)	12	void compilerGetInstructionPointerHook(void)	13	void compilerSetInstructionPointerHook(void)	14	void compilerCreateActualMessageHook(void)"	CompilerHooksSize _ 15.! !Interpreter removeSelector: #addToMethodCacheSel:class:method:primIndex:!Interpreter removeSelector: #bytecodeActivateNewMethod!Interpreter removeSelector: #bytecodeExecuteNewMethod!Interpreter removeSelector: #compilerActivateMethod!Interpreter removeSelector: #compilerActivateMethodHook!Interpreter removeSelector: #internalBytecodeActivateNewMethod!