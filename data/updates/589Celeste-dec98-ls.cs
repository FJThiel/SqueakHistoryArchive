'From Squeak 2.3 beta of Nov 25, 1998 on 3 January 1999 at 3:52:31 pm'!"Change Set:		Celeste-dec98Date:			29 December 1998Author:			Lex SpoonNumerous small updates to Celeste:	1. Initial MIME support is added: MailMessage>>body returns a MIMEDocument instead of a raw string.  As an example, text/html email is automatically formatted as in Scamper.	2. Some small changes are made which make saving the index file faster.  It's still very slow....	3. [custom] button is a menu, not a toggle.  To turn off the custom filter, you have to specifically select (none).	4. menu item added to save individual messages to a file.	5. 'move again' menu item specifies which folder will be moved into.	6. small bug fix for email address parser.	7. CelesteComposition is added for message compositions; without it, blocks end up in the dependents dictionary.	8. when a message is sent, its lines are folded at 72 characters"!!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 10/27/1998 13:38'!formattedText	"Answer a version of my text with a cleaned up header"	^self cleanedHeader, self bodyText! !Model subclass: #CelesteComposition	instanceVariableNames: 'celeste messageText textEditor morphicWindow mvcWindow '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Mail Reader'!Object subclass: #MailMessage	instanceVariableNames: 'time from to cc subject text body '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Mail Reader'!!Celeste methodsFor: 'table of contents pane' stamp: 'ls 12/14/1998 12:14'!saveMessage	"save the currently seleactead meassage to  file" 	| fileName file |	currentMsgID ifNil: [ ^self ].	fileName _ FillInTheBlank request: 'file to save in'.	fileName isEmpty ifTrue: [ ^self ].  	file _ FileStream fileNamed: fileName.	file nextPutAll: (mailDB getMessage: currentMsgID) text.	file close.! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 12/14/1998 12:17'!tocMenu: aMenu	"Answer the menu for the table of contents pane."	| labels lineSeparations selections lines |	currentCategory ifNil: [^ nil].	currentMsgID		ifNil: [			^ aMenu				labels: 'compose\file all\move all\remove all\delete all\search' withCRs				lines: #(1 5)				selections: #(compose fileAll moveAll removeAll deleteAll search)]		ifNotNil: [			labels _ 'delete\compose\reply\forward\'.			lineSeparations _ #(1 3).			selections _ #(deleteMessage compose reply forward).			lastCategory isEmpty ifFalse: [				labels _ labels, 'file -> ', lastCategory, '\move -> ', lastCategory, '\'.				lineSeparations _ lineSeparations, #(2).				selections _ selections, #( fileAgain moveAgain) ].			labels _ labels, 'file\move\remove\file all\move all\remove all\delete all\other categories\search\'.			lineSeparations _ lineSeparations, #(3 4 2).			selections _ selections, #(fileMessage moveMessage removeMessage fileAll moveAll removeAll deleteAll otherCategories search).			labels_ labels, 'save message\'.			lineSeparations _ lineSeparations , #(). 			selections _ selections , #(saveMessage). 			"convert lineSeperations into absolute line positions"			lines _ lineSeparations copy.			(2 to: lines size) do: [ :i |			lines at: i put: ((lines at: i) + (lines at: i-1)) ].			^aMenu labels: labels withCRs lines: lines  selections: selections		].! !!Celeste methodsFor: 'filtering' stamp: 'ls 10/17/1998 16:20'!customFilterOff	"Cancel custom filtering."	customFilterBlock ifNil: [		"it's already turned off"		^self ].	customFilterBlock _ nil.	self updateTOC.	self changed: #isCustomFilterOn.! !!Celeste methodsFor: 'filtering' stamp: 'ls 10/17/1998 16:20'!customFilterOn	"Select or define and activate a custom filter."	| filterList filterName filterExpr |	filterList _ CustomFilters keys asSortedCollection asOrderedCollection.	filterList addFirst: '(none)'.	filterList addLast: '<define new filter...>'.	filterList addLast: '<edit exising filter...>'.	filterList addLast: '<delete a filter...>'.	filterName _ (CustomMenu selections: filterList)			startUpWithCaption: 'Select a filter:'.	filterName ifNil: [ ^self ].	filterName = '(none)' ifTrue: [^self customFilterOff ].	filterName = '<delete a filter...>' ifTrue: [ ^self deleteFilter].	filterName = '<edit exising filter...>'		ifTrue: [filterExpr _ self editFilter]		ifFalse: [			filterName = '<define new filter...>'				ifTrue: [filterExpr _ self defineFilter]				ifFalse: [filterExpr _ CustomFilters at: filterName]].	filterExpr isEmpty ifTrue: [^self].	customFilterBlock _ Compiler evaluate: '[ :m | ', filterExpr, ']'.	self updateTOC.	self changed: #isCustomFilterOn.! !!Celeste methodsFor: 'filtering' stamp: 'ls 10/15/1998 14:57'!isCustomFilterOn	"whether there is a custom filter in effect"	^customFilterBlock ~~ nil! !!Celeste methodsFor: 'message text pane' stamp: 'ls 10/27/1998 13:55'!formatedMessageText	"Answer a string that is my formatted mail message."	| message header body bodyText |	currentMsgID isNil ifTrue: [^ ''].	message _ mailDB getMessage: currentMsgID.	header _ message cleanedHeader.	body _ message body.	body contentType = 'text/html'		ifTrue: [			bodyText _ (HtmlParser parse: body content readStream) formattedText. ]		ifFalse: [			bodyText _ body content ].	^header asText, String cr, bodyText! !!Celeste methodsFor: 'sending mail' stamp: 'ls 10/16/1998 09:09'!openSender: initialText	CelesteComposition openForCeleste: self  initialText: initialText.! !!Celeste methodsFor: 'sending mail' stamp: 'ls 10/15/1998 14:51'!replyTextFor: msgID	"Answer the template for a reply to the message with the given ID."	| msg s anyCCs |	msg _ mailDB getMessage: msgID.	s _ WriteStream on: (String new: 500).	"add From:"	s nextPutAll: 'From: ', Celeste userName; cr.	"add To:"	s nextPutAll: 'To: ', msg from; cr.	"add CC:s from the message and from the user's CC list"	s nextPutAll: 'CC: '.	anyCCs _ false.	(msg to isEmpty) ifFalse: [		anyCCs ifTrue:[ s nextPutAll: ', '] ifFalse: [ anyCCs _ true ].		s nextPutAll: msg to ].	(msg cc isEmpty) ifFalse: [		anyCCs ifTrue: [ s nextPutAll: ', ' ] ifFalse: [ anyCCs _ true ].		s nextPutAll: msg cc ].	(Celeste ccList isEmpty) ifFalse: [		anyCCs ifTrue: [ s nextPutAll: ', ' ] ifFalse: [ anyCCs _ true ].			s nextPutAll: Celeste ccList ].	s cr.	"add Subject:"	((msg subject asLowercase indexOfSubCollection: 're:' startingAt: 1) ~= 0)		ifTrue: [s nextPutAll: 'Subject: ', msg subject]		ifFalse: [s nextPutAll: 'Subject: Re: ', msg subject].	s cr.	"add contents of previous message"	s cr.	s nextPutAll: msg from; nextPutAll: ' wrote:'; cr.	msg bodyText linesDo: [ :line |		s nextPutAll: '> '.		s nextPutAll: line.		s cr ].	s cr.	^s contents! !!Celeste methodsFor: 'abc' stamp: 'ls 10/15/1998 14:51'!forwardTextFor: msgID	"Answer the template for forwarding the message with the given ID."	^self composeText, '---------- Forwarded ----------',	(mailDB getMessage: msgID) bodyText, '-------------------------------'! !!Celeste class methodsFor: 'instance creation' stamp: 'ls 10/28/1998 14:28'!buildButtonsFor: model 	"Answer a collection of handy buttons for the Celeste user interface."	| buttonViewClass buttons b |	Smalltalk isMorphic		ifTrue: [buttonViewClass _ PluggableButtonMorph]		ifFalse: [buttonViewClass _ PluggableButtonView].	buttons _ OrderedCollection new.	b _ buttonViewClass on: (Switch new onAction: [model subjectFilterOn];				 offAction: [model subjectFilterOff]).	b label: 'Subj. F.' asParagraph centered;	 borderWidth: 1.	buttons add: b.	b _ buttonViewClass on: (Switch new onAction: [model fromFilterOn];				 offAction: [model fromFilterOff]).	b label: 'From F.' asParagraph centered;	 borderWidth: 1.	buttons add: b.	b _ buttonViewClass				on: model				getState: #isCustomFilterOn				action: #customFilterOn.	b label: 'Custom F.' asParagraph centered;	 borderWidth: 1.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model compose]);			 action: #turnOn;			 label: 'New' asParagraph centered;			 borderWidth: 1.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model reply]);			 action: #turnOn;			 label: 'Reply' asParagraph centered;			 borderWidth: 1.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model forward]);			 action: #turnOn;			 label: 'Forward' asParagraph centered;			 borderWidth: 1.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model moveAgain]);			 action: #turnOn;			 label: 'Move Again' asParagraph centered;			 borderWidth: 1.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model deleteMessage]);			 action: #turnOn;			 label: 'Delete' asParagraph centered;			 borderWidth: 1.	buttons add: b.	^ buttons! !!CelesteComposition commentStamp: '<historical>' prior: 0!a message being composed.  When finished, it will be submitted via a Celeste.!!CelesteComposition methodsFor: 'private' stamp: 'ls 1/3/1999 15:51'!breakLines: aString  atWidth: width	"break lines in the given string into shorter lines"	| result start end |true ifTrue: [ ^aString ].	result _ WriteStream on: (String new: (aString size * 50 // 49)).	aString asString linesDo: [ :line | 		start _ 1.		"output one shorter line each time through this loop"		[ start + width <= line size ] whileTrue: [			"find the end of the line"			end _ start + width - 1.			[end >= start and: [ (line at: (end+1)) isSeparator not ]] whileTrue: [				end _ end - 1 ].			end < start ifTrue: [				"a word spans the entire width!!"				end _ start + width - 1 ].			"copy the line to the output"			result nextPutAll: (line copyFrom: start to: end).			result cr.			"get ready for next iteration"			start _ end+1.			(line at: start) isSeparator ifTrue: [ start _ start + 1 ].		].		"write out the final part of the line"		result nextPutAll: (line copyFrom: start to: line size).		result cr.	].	^result contents! !!CelesteComposition methodsFor: 'access' stamp: 'ls 10/15/1998 21:52'!messageText	"return the current text"	^messageText! !!CelesteComposition methodsFor: 'access' stamp: 'ls 10/16/1998 09:16'!messageText: aText	"change the current text"	messageText _ aText.	self changed: #messageText.	^true! !!CelesteComposition methodsFor: 'access' stamp: 'ls 1/3/1999 15:04'!submit	"submit the message"	textEditor ifNotNil: [		self hasUnacceptedEdits ifTrue: [ textEditor accept ] ].	celeste queueMessageWithText: (self breakLines: messageText atWidth: 72).	morphicWindow ifNotNil: [ morphicWindow delete ].	mvcWindow ifNotNil: [ mvcWindow controller close ].! !!CelesteComposition methodsFor: 'initialization' stamp: 'ls 10/15/1998 21:51'!celeste: aCeleste  initialText: aText	celeste _ aCeleste.	messageText _ aText.! !!CelesteComposition methodsFor: 'interface' stamp: 'ls 10/16/1998 09:11'!open	"open an interface"	Smalltalk isMorphic		ifTrue: [ self openInMorphic ]		ifFalse: [ self openInMVC ]! !!CelesteComposition methodsFor: 'interface' stamp: 'ls 10/16/1998 09:17'!openInMVC	| textView sendButton  |	mvcWindow _ StandardSystemView new		label: 'Mister Postman';		minimumSize: 400@250;		model: self.	textView _ PluggableTextView		on: self		text: #messageText		accept: #messageText:.	textEditor _ textView controller.	sendButton _ PluggableButtonView 		on: self		getState: nil		action: #submit.	sendButton label: 'Send'.	sendButton borderWidth: 1.	sendButton window: (1@1 extent: 398@38).	mvcWindow addSubView: sendButton.	textView window: (0@40 corner: 400@250).	mvcWindow addSubView: textView below: sendButton.	mvcWindow controller open.		! !!CelesteComposition methodsFor: 'interface' stamp: 'ls 10/16/1998 09:17'!openInMorphic	"open an interface for sending a mail message with the given initial text"	| textMorph buttonsList sendButton |	morphicWindow _ SystemWindow labelled: 'Mister Postman'.	morphicWindow model: self.		textEditor _ textMorph _ PluggableTextMorph 		on: self 		text: #messageText  		accept: #messageText:.	morphicWindow addMorph: textMorph  frame: (0@0.1 corner: 1@1).	buttonsList _ AlignmentMorph newRow.	sendButton _ PluggableButtonMorph on: self getState: nil	 action: #submit.	sendButton label: 'send mesage'.	sendButton onColor: Color white  offColor: Color white.	buttonsList addMorphBack: sendButton.		morphicWindow addMorph: buttonsList  frame: (0@0 extent: 1@0.1).	morphicWindow openInMVC.! !!CelesteComposition class methodsFor: 'instance creation' stamp: 'ls 10/16/1998 09:08'!celeste: aCeleste  initialText: initialText	"create an instance for the given mail reader, editting the given text"	^self new celeste: aCeleste  initialText: initialText! !!CelesteComposition class methodsFor: 'instance creation' stamp: 'ls 10/16/1998 09:08'!openForCeleste: aCeleste  initialText: initialText	"open a composition window for the given mail reader, editting the given text"	(self celeste: aCeleste  initialText: initialText) open! !!IndexFile methodsFor: 'file operations' stamp: 'ls 11/9/1998 16:07'!openOn: aFileName messageFile: messageFile	"Initialize myself from the file with the given name."	| fileStream |	filename _ aFileName.	fileStream _ FileStream fileNamed: aFileName.	self readFrom: (ReadStream on: fileStream contentsOfEntireFile) messageFile: messageFile.		"close and release the file stream"	fileStream _ nil.! !!IndexFileEntry methodsFor: 'read-write' stamp: 'ls 10/6/1998 13:22'!writeOn: aStream	"Write a human-readable representation of myself on the given text stream."	aStream		nextPutAll: location printString; cr;		nextPutAll: textLength printString; cr;		nextPutAll: time printString; cr;		nextPutAll: from; cr;		nextPutAll: to; cr;		nextPutAll: cc; cr;		nextPutAll: subject; cr.! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 10/23/1998 13:39'!grabBasicAddress	"grad an address of the form a.b@c.d.e"	self startNewAddress.	"grab either the domain if specified, or the domain if not"	self addToAddress.	[tokens isEmpty not and: [ tokens last type = $.] ] 		whileTrue: 			["add name-dot pairs of tokens"			self addToAddress.			(#(Atom QuotedString ) includes: tokens last type)				ifFalse: [self error: 'bad token in address: ' , tokens last text].			self addToAddress].	(tokens isEmpty or: [tokens last type ~= $@])		ifTrue: ["no domain specified"			self finishAddress]		ifFalse: 			["that was the domain.  check that no QuotedString's slipped in"			curAddrTokens do: [:tok | tok type = #QuotedString ifTrue: [self error: 'quote marks are not allowed within a domain name (' , tok text , ')']].			"add the @ sign"			self addToAddress.			"add the local part"			(#(Atom QuotedString ) includes: tokens last type)				ifFalse: [self error: 'invalid local part for address: ' , tokens last text].			self addToAddress.			"add word-dot pairs if there are any"			[tokens isEmpty not and: [tokens last type = $.]]				whileTrue: 					[self addToAddress.					(tokens isEmpty not and: [#(Atom QuotedString ) includes: tokens last type])						ifTrue: [self addToAddress]].			self finishAddress]! !!MailMessage methodsFor: 'initialize-release' stamp: 'ls 10/27/1998 23:28'!from: aString 	"Parse the given string to initialize myself. The given string will become 	my text."	| parseStream isMime contentType bodyText contentTransferEncoding |	time _ 0.	from _ to _ cc _ subject _ ''.	text _ self removeTrailingSeparators: aString.	parseStream _ ReadStream on: text.	isMime _ false.	contentType _ 'text/plain'.	contentTransferEncoding _ nil.	self fieldsFrom: parseStream do: 		[:fName :fValue | 		fName = 'date' ifTrue: [time _ self timeFrom: fValue].		fName = 'from' ifTrue: [from _ fValue].		fName = 'to'			ifTrue: [to isEmpty					ifTrue: [to _ fValue]					ifFalse: [to _ to , ', ' , fValue]].		fName = 'cc'			ifTrue: [cc isEmpty					ifTrue: [cc _ fValue]					ifFalse: [cc _ cc , ', ' , fValue]].		fName = 'subject' ifTrue: [subject _ fValue].		fName = 'mime-version' ifTrue: [isMime _ true].		fName = 'content-type' ifTrue: [contentType _ fValue].		fName = 'content-transfer-encoding' ifTrue: [contentTransferEncoding _ fValue asLowercase]].	bodyText _ parseStream upToEnd.	contentTransferEncoding = 'base64'		ifTrue: 			[bodyText _ Base64MimeConverter mimeDecodeToChars: (ReadStream on: bodyText).			bodyText _ bodyText contents].	contentTransferEncoding = 'quoted-printable' ifTrue: [ bodyText _ bodyText decodeQuotedPrintable ].	isMime		ifTrue: [body _ MIMEDocument contentType: contentType content: bodyText]		ifFalse: [body _ MIMEDocument contentType: 'text/plain' content: bodyText]! !!MailMessage methodsFor: 'access' stamp: 'ls 1/3/1999 15:48'!body	"return just the body of the message"	^body! !!MailMessage methodsFor: 'access' stamp: 'ls 1/3/1999 15:52'!bodyText	"return the text of the body of the message"	^body content! !!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 1/3/1999 15:46'!cleanedHeader		| old new |	old _ ReadStream on: text.	new _ WriteStream on: (String new: text size).	self fieldsFrom: old do:		[: fName : fValue |		 (#('received'			'return-path'			'newsgroups'			'message-id'			'path'			'reply-to'			'in-reply-to'			'sender'			'x-sender'			'fonts'			'x-mailer'			'mime-version'			'x-uidl'			'status'			'content-type'			'content-transfer-encoding'			'errors-to'			'keywords'			'references'			'x-vms-to'			'x-delivery-notice'			'x-reply-of'			'x-newsreader'			'x-icon'			'x-mailing-list'			'x-loop'			'x-priority'			'x-msmail-priority'			'x-mimeole'			'x-organization'			'x-originating-ip'			'x-sun-charset'			'x-url'			'x-nextstep-mailer'			'x-authentication-warning'			'x-lotus-fromdomain'			'x-blackmail'			'x-authenticated-timestamp'			'nntp-posting-host'			'lines'			'return-receipt-to'			'precedence'			'originator'			'distribution'			'content-disposition'			'importance'			'resent-to'			'resent-cc'			'resent-message-id'			'resent-date'			'resent-sender'			'resent-from') includes: fName) ifFalse:				[new nextPutAll: fName capitalized.				 new nextPutAll: ': '.				 new nextPutAll: fValue; cr]].	new cr.	^new contents! !!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 10/27/1998 13:38'!formattedText	"Answer a version of my text with a cleaned up header"	^self cleanedHeader, self bodyText! !