'From Squeak 2.2 of Sept 23, 1998 on 6 October 1998 at 1:15:21 pm'!!DataStream methodsFor: 'all' stamp: 'tk 10/6/1998 13:14'!close	"Close the stream."	| bytes |	byteStream closed 		ifFalse: [			bytes _ byteStream position.			byteStream padToEndWith: $ .			byteStream close]		ifTrue: [bytes _ 'unknown'].	^ bytes! !!LessHTMLformatter methodsFor: 'translating' stamp: 'mjg 9/30/1998 13:39'!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacter asString) 				startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start 						to: start+1 with: specialCharacter asString.					start_start + 1.]			ifFalse: [				(end _ aLine indexOfSubCollection: (specialCharacter asString)  					startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom: start to: end						with: (aBlock value: (aLine copyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>' ; cr.]			ifFalse: [				(aLine beginsWith: '-')				ifTrue: [targetStream nextPutAll: '<li>',aLine allButFirst; cr.]				ifFalse: [				(aLine beginsWith: '====')				ifTrue: [targetStream nextPutAll: '<h4>',					(aLine copyFrom: 5 to: aLine size),'</h4>';cr.]				ifFalse: [				(aLine beginsWith: '===')				ifTrue: [targetStream nextPutAll: '<h3>',					(aLine copyFrom: 4 to: aLine size),'</h3>';cr.]				ifFalse: [				(aLine beginsWith: '==')				ifTrue: [targetStream nextPutAll: '<h2>',					(aLine copyFrom: 3 to: aLine size),'</h2>';cr.]				ifFalse: [				(aLine beginsWith: '=')				ifTrue: [targetStream nextPutAll: '<h1>',					aLine allButFirst,'</h1>';cr.]				ifFalse: [				(aLine beginsWith: '!!')				ifTrue: [targetStream nextPutAll: '<b>',aLine allButFirst,'</b>';cr.]				ifFalse: [				((aLine beginsWith: '|') and: [(aLine count: [:c | c= $|]) > 2])							"Then treat it as a table"				ifTrue: [targetStream nextPutAll: '<tr><td>',					(aLine allButFirst allButLast copyReplaceAll: '|' with:						'</td><td>'),'</td></tr>'.]				ifFalse: [targetStream nextPutAll: aLine].]]]]]]].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in a separator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue: [ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStream nextPutAll: '<p>'; cr.]				ifFalse: [targetStream cr.].]			ifTrue: [targetStream cr.].].	^targetStream contents.! !!ServerAction methodsFor: 'URL processing' stamp: 'mjg 10/5/1998 16:49'!process: request MIMEtype: imageGif	"See if there is a .gif file on my disk of this name, and send it out."	| fName |	fName _ ServerAction serverDirectory, (request message at: 1),		(ServerAction pathSeparator), (request message at: 2).	3 to: request message size do: [:part |		fName _ fName, '.', (request message at: part)].	Transcript show: fName; cr.	(FileDirectory default fileExists: fName)		ifTrue: ["maybe send out content-length?"			request reply: (PWS success),(PWS content: imageGif), PWS crlf.			request reply: (FileStream oldFileNamed: fName) contentsOfEntireFile]		ifFalse: [			request reply: ( 'HTTP/1.0 400 Bad Request', PWS crlfcrlf, 'file not found')].! !!EmbeddedServerAction methodsFor: 'URL processing' stamp: 'mjg 10/5/199816:44'!replyTo: pieces from: request	| theLast |	(StandardFileStream isAFileNamed: pieces)		ifTrue:			[theLast _ request message last asLowercase.			theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].			theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].			theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].			theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].			request reply: PWS success;			 reply: PWS contentHTML , PWS crlf.			request reply: (HTMLformatter evalEmbedded: 				(FileStream fileNamed: pieces) contentsOfEntireFile with: request)]		ifFalse: [request error: PWS notFound]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'tk 10/6/1998 13:13'!padToEndWith: aChar	"On the Mac, files do not truncate.  One can delete the old file and write a new one, but sometime deletion fails (file still open? file stale?).  This is a sad compromise.  Just let the file be the same length but pad it with a harmless character."	| pad |	self atEnd ifTrue: [^ self].	pad _ self isBinary & (aChar class == Character) 		ifTrue: [aChar asciiValue] ifFalse: [aChar].	self nextPutAll: (String new: ((self size - self position) min: 20000) 							withAll: pad).! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 10/5/1998 16:22'!textVersion: steps	"One step back gets the original"	| theFile theText real bb gotTo count |	theFile _ FileStream oldFileNamed: file.	theFile setToEnd.	bb _ 1. count _ steps.	[count > 0 and: [bb > 0]] whileTrue: [		bb _ self backupAChunk: theFile. count := count - 1.].	bb = 0 ifTrue: ["Went back beyond beginning"		theFile close.		^'<Too Far Back>'.].	bb _ bb - 7.		"before the back:"	"Be careful about occurances of 'text:' in the name or other field"	[theFile match: 'text:'.	gotTo _ theFile position.	theFile upTo: $'; skip: -1.	theText _ theFile nextDelimited: $'.	real _ (ReadStream on: theText) nextDelimited: $!!.	"Remove double !!"	theFile skipSeparators.	theFile position >= bb] whileFalse: [theFile position: gotTo].	theFile close.	^ real! !