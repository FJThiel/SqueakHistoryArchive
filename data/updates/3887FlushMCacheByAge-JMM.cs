'From Squeak3.1alpha of 6 February 2001 [latest update: #3740] on 5 March 2001 at 11:35:53 pm'!"Change Set:		FlushMCacheLessOftenJMMDate:			5 March 2001Author:			John M McIntoshI noticed the method cache gets flushed on every incremental compaction. This change set changes the logic to consider information about the range of memory that has been GCed and only flush entries that are affected. A full flush still occurs on a full GC, or on a become that affects OldSpace. This change set reduces overagressive flushing and may improve performance by reducing the number of times entries need to be readded to the cache. Also I removed duplicate flushs in the become primitives"!!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'JMM 3/5/2001 22:33'!mapPointersInObjectsFrom: memStart to: memEnd	"Use the forwarding table to update the pointers of all non-free objects in the given range of memory. Also remap pointers in root objects which may contains pointers into the given memory range, and don't forget to flush the method cache based on the range"	| oop |	self inline: false.	self compilerMapHookFrom: memStart to: memEnd.	"update interpreter variables"	self mapInterpreterOops.	self flushMethodCacheFrom: memStart to: memEnd.	"update pointers in root objects"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		((oop < memStart) or: [oop >= memEnd]) ifTrue: [			"Note: must not remap the fields of any object twice!!"			"remap this oop only if not in the memory range covered below"			self remapFieldsAndClassOf: oop.		].	].	"update pointers in the given memory range"	oop _ self oopFromChunk: memStart.	[oop < memEnd] whileTrue: [		(self isFreeObject: oop) ifFalse: [			self remapFieldsAndClassOf: oop.		].		oop _ self objectAfterWhileForwarding: oop.	].! !!Interpreter methodsFor: 'object memory support' stamp: 'JMM 3/5/2001 22:31'!mapInterpreterOops	"Map all oops in the interpreter's state to their new values during garbage collection or a become: operation."	"Assume: All traced variables contain valid oops."	| oop |	nilObj				_ self remap: nilObj.	falseObj				_ self remap: falseObj.	trueObj				_ self remap: trueObj.	specialObjectsOop	_ self remap: specialObjectsOop.	compilerInitialized ifFalse: [		stackPointer 		_ stackPointer - activeContext.	"*rel to active"		activeContext		_ self remap: activeContext.		stackPointer 		_ stackPointer + activeContext.	"*rel to active"		theHomeContext		_ self remap: theHomeContext.	].	instructionPointer 	_ instructionPointer - method.	"*rel to method"	method				_ self remap: method.	instructionPointer 	_ instructionPointer + method.	"*rel to method"	receiver			_ self remap: receiver.	messageSelector		_ self remap: messageSelector.	newMethod			_ self remap: newMethod.	methodClass			_ self remap: methodClass.	lkupClass			_ self remap: lkupClass.	receiverClass		_ self remap: receiverClass.	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			remapBuffer at: i put: (self remap: oop).		].	].! !!Interpreter methodsFor: 'method lookup cache' stamp: 'JMM 3/5/2001 22:57'!flushMethodCacheFrom: memStart to: memEnd	| probe |	"Flush entries in the method cache only if the oop address is within the given memory range.	This reduces overagressive cache clearing. Note the AtCache is fully flushed, 70% of the time	cache entries live in newspace, new objects die young"	probe _ 0.	1 to: MethodCacheEntries do:		[:i | (methodCache at: probe + MethodCacheSelector) = 0 ifFalse:			[			((((((methodCache at: probe + MethodCacheSelector) >= memStart) and: 				[(methodCache at: probe + MethodCacheSelector) < memEnd]) or: 			[(((methodCache at: probe + MethodCacheClass) >= memStart) and: 				[(methodCache at: probe + MethodCacheClass) < memEnd])]) or: 			[(((methodCache at: probe + MethodCacheMethod) >= memStart) and: 				[(methodCache at: probe + MethodCacheMethod) < memEnd])]) or: 			[(((methodCache at: probe + MethodCacheNative) >= memStart) and: 				[(methodCache at: probe + MethodCacheNative) < memEnd])])				ifTrue:					[methodCache at: probe + MethodCacheSelector put: 0]].		probe _ probe + MethodCacheEntrySize].	1 to: AtCacheTotalSize do: [ :i | atCache at: i put: 0 ].! !!Interpreter methodsFor: 'object access primitives' stamp: 'JMM 3/5/2001 22:59'!primitiveArrayBecome	"We must flush the method cache here, to eliminate stale references	to mutated classes and/or selectors."	| arg rcvr |	arg _ self stackTop.	rcvr _ self stackValue: 1.	self success: (self become: rcvr with: arg twoWay: true).	successFlag ifTrue: [ self pop: 1 ].! !!Interpreter methodsFor: 'object access primitives' stamp: 'JMM 3/5/2001 22:59'!primitiveArrayBecomeOneWay	"We must flush the method cache here, to eliminate stale references	to mutated classes and/or selectors."	| arg rcvr |	arg _ self stackTop.	rcvr _ self stackValue: 1.	self success: (self become: rcvr with: arg twoWay: false).	successFlag ifTrue: [ self pop: 1 ].! !