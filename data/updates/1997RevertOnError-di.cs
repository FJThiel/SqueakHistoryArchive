'From Squeak2.8alpha of 12 January 2000 [latest update: #1996] on 15 April 2000 at 10:45:52 pm'!"Change Set:		RevertOnErrorDate:			4 April 2000Author:			Dan IngallsIf a recursive error happens and you are inside an isolation layer, then this code will revoke the current isolation layer and open a debugger in the project associated with the outer layer.  Many formerly unrecoverable errors can now be diagnosed and repaired in this manner.  A long diagnostic message describes the situation and how to deal with it.This facility has been tested for all combinations of Morphic and MVC projects.  While the basic recovery mechanism works with MVC projects, some disagreement about the active process makes it necessary to issue a user interrupt (cmd-period) after the emergency project changes.  The hard work has been done.  Surely some lover of MVC will enjoy finishing the job.Also includes some new cursor logic that saves the current cursor, and reverts to a normal cursor when opening a debugger.  If the user proceeds form the debugger, then the cursor that had been in effect will be restored.  Removes the redundant CurrentCursor variable from InputSensor.Includes a menu item for 'propagate changes above' that has not yet been implemented (though it will be shortly)."!CodeHolder subclass: #Debugger	instanceVariableNames: 'interruptedProcess interruptedController contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC sourceMap tempNames isolationHead failedProject savedCursor '	classVariableNames: 'ContextStackKeystrokes ErrorRecursion '	poolDictionaries: ''	category: 'Tools-Debugger'!!Debugger commentStamp: '<historical>' prior: 0!I represent the machine state at the time of an interrupted process. I also represent a query path into the state of the process. The debugger is typically viewed through a window that views the stack of suspended contexts, the code for, and execution point in, the currently selected message, and inspectors on both the receiver of the currently selected message, and the variables in the current context.Special note on recursive errors:Some errors affect Squeak's ability to present a debugger.  This is normally an unrecoverable situation.  However, if such an error occurs in an isolation layer, Squeak will attempt to exit from the isolation layer and then present a debugger.  Here is the chain of events in such a recovery.	* A recursive error is detected.	* The current project is queried for an isolationHead	* Changes in the isolationHead are revoked	* The parent project of isolated project is returned to	* The debugger is opened there and execution resumes.If the user closes that debugger, execution continues in the outer project and layer.  If, after repairing some damage, the user proceeds from the debugger, then the isolationHead is re-invoked, the failed project is re-entered, and execution resumes in that world. !Object subclass: #InputSensor	instanceVariableNames: ''	classVariableNames: 'CurrentCursor InterruptSemaphore InterruptWatcherProcess '	poolDictionaries: ''	category: 'Kernel-Processes'!!ChangeSet methodsFor: 'isolation layers' stamp: 'di 4/13/2000 12:47'!isolatedProject	"Return the isolated project for which I am the changeSet."	^ isolatedProject! !!Debugger methodsFor: 'initialize' stamp: 'di 4/14/2000 16:24'!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg topView p |	Sensor flushKeyboard.	savedCursor _ Sensor currentCursor.	Sensor currentCursor: Cursor normal.	msg _ msgString.	(label beginsWith: 'Space is low') ifTrue: [msg _ self lowSpaceChoices, msgString].	isolationHead ifNotNil:		["We have already revoked the isolation layer -- now jump to the parent project."		msg _ self isolationRecoveryAdvice, msgString.		failedProject _ Project current.		isolationHead parent enterForEmergencyRecovery].	World ifNotNil:		[self buildMorphicNotifierLabelled: label message: msg.		^ Project current spawnNewProcessIfThisIsUI: interruptedProcess].	Display fullScreen.	topView _ self buildMVCNotifierViewLabel: label message: msg minSize: 350@((14 * 5) + 16 + self optionalButtonHeight).	ScheduledControllers activeController		ifNil: [p _ Display boundingBox center]		ifNotNil: [p _ ScheduledControllers activeController view displayBox center].	topView controller openNoTerminateDisplayAt: (p max: (200@60)).	^ topView! !!Debugger methodsFor: 'private' stamp: 'di 4/14/2000 15:24'!isolationRecoveryAdvice	"Return a notifier message string to be presented in case of recovery from recursive error by revoking the changes in an isolation layer.  This surely ranks as one of Squeak's longer help messages."	^ 'Warning!! You have encountered a recursive eror situation.Don''t panic, but do read the following advice.  If you were just fooling around, the simplest thing to do is to quit and NOT save, and restart Squeak.  If you care about recovery, then read on...In the process of diagnosing one error, further errors occurred, making it impossible to give you a debugger to work with.  Squeak has jumped to an outer project where many of the objects and code changes that might have caused this problem are not involved in normal operation.  If you are looking at this window, chances are that this first level of recovery was successful.  If there are changes you care a lot about, try to save them now.  Then, hopefully, from the state in this debugger, you can determine what the problem was and fix it.  Do not save this image until you are confident of its recovery.You are no longer in the world that is damaged.  The two most likely causes of recursive errors are malformed objects (for instance a corrupt value encountered in any display of the desktop) and recurring code errors (such as a change that causes errors in any attempt to display the desktop).In the case of malformed objects, you can attempt to repair them by altering various bindings in the corrupted environment.  Open this debugger and examine the state of the objects closest to the error.In the case of code errors, note that you are no longer in a world where the erroneous code is in effect.  The only simple option available is for you to browse to the changeSet for the project in distress, and remove one or more of the changes (later it will be possible to edit the code remotely from here).If you feel you have repaired the problem, then you may proceed from this debugger.  This will put you back in the project that failed with the changes that failed for another try.  Note that the debugger from which you are proceeding is the second one that occurred;  you will likely find the first one waiting for you when you reenter the failed project!!  Also note that if your error occurred while displaying a morph, it may now be flagged as undisplayable (red with yellow cross);  if so, use the morph debug menu to choose ''start drawing again''.If you have not repaired the problem, you should close this debugger and delete the failed project after retrieving whatever may be of value in it.Good luck.	- The Squeak Fairy GodmotherPS:  If you feel you need the help of a quantum mechanic, do NOT close this window.  Instead, the best thing to do (after saving anything that seems safe to save) would be to use the ''save as...'' command in the world menu, and give it a new image name, such as OOPS.  There is a good chance that someone who knows their way around Squeak can help you out.'! !!Debugger methodsFor: 'private' stamp: 'di 4/14/2000 16:24'!process: aProcess controller: aController context: aContext	^ self process: aProcess controller: aController context: aContext isolationHead: nil! !!Debugger methodsFor: 'private' stamp: 'di 4/14/2000 16:31'!process: aProcess controller: aController context: aContext isolationHead: projectOrNil	super initialize.	Smalltalk at: #MessageTally ifPresent: [:c | c new close].	contents _ nil. 	interruptedProcess _ aProcess.	interruptedController _ aController.	contextStackTop _ aContext.	self newStack: (contextStackTop stackOfSize: 1).	contextStackIndex _ 1.	externalInterrupt _ false.	selectingPC _ true.	isolationHead _ projectOrNil! !!Debugger methodsFor: 'private' stamp: 'di 4/14/2000 16:24'!resumeProcess: aTopView	Smalltalk isMorphic ifFalse: [aTopView erase].	savedCursor ifNotNil: [Sensor currentCursor: savedCursor].	isolationHead ifNotNil:		[failedProject enterForEmergencyRecovery.		isolationHead invoke. isolationHead _ nil].	interruptedProcess suspendedContext method			== (Process compiledMethodAt: #terminate)		ifFalse:		[contextStackIndex > 1			ifTrue: [interruptedProcess popTo: self selectedContext]			ifFalse: [interruptedProcess install: self selectedContext].		Smalltalk isMorphic			ifTrue: [Project current resumeProcess: interruptedProcess]			ifFalse: [ScheduledControllers						activeControllerNoTerminate: interruptedController						andProcess: interruptedProcess]].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil. "Before delete, so release doesn't terminate it"	Smalltalk isMorphic		ifTrue: [aTopView delete. World displayWorld]		ifFalse: [aTopView controller closeAndUnscheduleNoErase].	Smalltalk installLowSpaceWatcher.  "restart low space handler"	Processor terminateActive! !!Debugger class methodsFor: 'instance creation' stamp: 'di 4/14/2000 16:29'!context: aContext 	"Answer an instance of me for debugging the active process starting with the given context."	^ self context: aContext isolationHead: nil! !!Debugger class methodsFor: 'instance creation' stamp: 'di 4/14/2000 16:29'!context: aContext isolationHead: isolationHead	"Answer an instance of me for debugging the active process starting with the given context."	^ self new		process: Processor activeProcess		controller:			((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: aContext		isolationHead: isolationHead! !!Debugger class methodsFor: 'opening' stamp: 'di 4/14/2000 16:30'!openContext: aContext label: aString contents: contentsString	| isolationHead |	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	<primitive: 19> "Simulation guard"	ErrorRecursion not & Preferences logDebuggerStackToFile ifTrue:		[Smalltalk logError: aString inContext: aContext to: 'SqueakDebug.log'].	ErrorRecursion ifTrue:		[ErrorRecursion _ false.		(isolationHead _ Project current isolationHead)			ifNil: [self primitiveError: aString]			ifNotNil: [isolationHead revoke]].	ErrorRecursion _ true.	(Debugger context: aContext isolationHead: isolationHead)		openNotifierContents: contentsString		label: aString.	ErrorRecursion _ false.	Processor activeProcess suspend.! !!HandMorph methodsFor: 'world menu' stamp: 'di 4/14/2000 08:54'!changesMenu	"Build the changes menu for the world."	| menu |	menu _ (MenuMorph entitled: 'changes...') defaultTarget: self.	menu addStayUpItem.	menu add: 'file out current change set' target: Utilities action: #fileOutChanges.	menu balloonTextForLastItem: 'Write the current change set out to a file whose name reflects the change set name and the current date & time.'.	menu add: 'create new change set...' target: ChangeSorter action: #newChangeSet.	menu balloonTextForLastItem: 'Create a new change set and make it the current one.'.	menu add: 'methods in current change set' action: #browseChangedMessages.	menu balloonTextForLastItem: 'Open a message-list browser showing all methods in the current change set'.	menu add: 'check change set for slips' target: Smalltalk changes action: #lookForSlips.	menu balloonTextForLastItem: 'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu balloonTextForLastItem: 'Open a 3-paned changed-set viewing tool'.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu balloonTextForLastItem: 'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'.	menu addLine.	menu add: 'recently submitted methods' action: #openRecentChanges.	menu balloonTextForLastItem: 'Open a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.'.	menu add: 'recently logged changes...' 		action: #openChangesLog.	menu balloonTextForLastItem: 'Open a change-list browser on the latter part of the changes log.'.	menu add: 'recent log file...'		action: #fileForRecentLog.	menu balloonTextForLastItem: 'Create a file holding the logged changes (going as far back as you wish), and open a window on that file.'.	menu addLine.	menu add: 'save world as morph file' action: #saveWorldInFile.	menu balloonTextForLastItem: 'Save a file that, when reloaded, reconstitutes the current World.'.	menu addLine.	Project current isIsolated	ifTrue: [menu add: 'propagate changes upward' action: #propagateChanges.			menu balloonTextForLastItem: 'The changes made in this isolated project will propagate to projects up to the next isolation layer.']	ifFalse: [menu add: 'isolate changes of this project' action: #beIsolated.			menu balloonTextForLastItem: 'Isolate this project and its subprojects from the rest of the system.  Changes to methods here will be revoked when you leave this project.'].	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 4/14/2000 08:38'!beIsolated	"Establish this project as an isolation layer.	Further method changes made here will be revoked when you leave the project."	Project current beIsolated.! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 4/14/2000 08:52'!propagateChanges.	"The changes made in this isolated project will be propagated to projects above."	Project current propagateChanges.! !!InputSensor methodsFor: 'cursor' stamp: 'di 4/13/2000 12:15'!currentCursor	"The current cursor is maintained in class Cursor."	^ Cursor currentCursor! !!InputSensor methodsFor: 'cursor' stamp: 'di 4/13/2000 12:16'!currentCursor: newCursor 	"The current cursor is maintained in class Cursor."	Cursor currentCursor: newCursor.! !!Project methodsFor: 'menu messages' stamp: 'di 4/14/2000 12:32'!enterForEmergencyRecovery	"This version of enter invokes an absolute minimum of mechanism.	An unrecoverable error has been detected in an isolated project.	It is assumed that the old changeSet has already been revoked.	No new process gets spawned here.  This will happen in the debugger."	self == CurrentProject ifTrue: [^ self].	CurrentProject saveState.	CurrentProject _ self.	Display newDepthNoRestore: displayDepth.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	World isMorph ifTrue: [World pauseEventRecorder].	world isMorph		ifTrue:			["Entering a Morphic project"			World _ world.			world install.			world triggerOpeningScripts]		ifFalse:			["Entering an MVC project"			World _ nil.			Smalltalk at: #ScheduledControllers put: world.			ScheduledControllers restore].	activeProcess _ Processor activeProcess.! !!Project methodsFor: 'active process' stamp: 'di 4/14/2000 12:38'!spawnNewProcessIfThisIsUI: suspendedProcess	world isMorph ifFalse: [^self spawnNewProcess].	"does this ever happen?"	self activeProcess == suspendedProcess		ifTrue: ["Transcript show: 'spawning'; cr."				self spawnNewProcess ] 		ifFalse: ["Transcript show: 'not spawning'; cr" ].! !!Project methodsFor: 'isolation layers' stamp: 'di 4/15/2000 22:24'!isIsolated	^ isolatedHead! !!Project methodsFor: 'isolation layers' stamp: 'di 4/4/2000 21:10'!isolationHead	"Go up the parent chain and find the nearest isolated project."	isolatedHead == true ifTrue: [^ self].	self isTopProject ifTrue: [^ nil].	^ parentProject isolationHead! !!Project methodsFor: 'isolation layers' stamp: 'di 4/14/2000 09:01'!propagateChanges	"Assert these changes in the next higher isolation layer of the system."	isolatedHead ifFalse: [self error: 'You can only assert changes from isolated projects'].	self halt: 'Not Yet Implemented'."This will be done by installing a new changeSet for this project (initted for isolation).  With the old changeSet no longer in place, no revert will happen when we leave, and those changes will have effectively propagated up a level.  NOTE: for this to work in general, the changes here must be assimilated into the isolationSet for the next layer."! !!ScreenController methodsFor: 'menu messages' stamp: 'di 4/14/2000 08:38'!beIsolated	"Establish this project as an isolation layer.	Further method changes made here will be revoked when you leave the project."	Project current beIsolated.! !!ScreenController methodsFor: 'menu messages' stamp: 'di 4/14/2000 08:57'!propagateChanges.	"The changes made in this isolated project will be propagated to projects above."	Project current propagateChanges.! !!ScreenController methodsFor: 'nested menus' stamp: 'di 4/14/2000 08:56'!changesMenu	"Answer a menu for changes-related items"	^ SelectionMenu labelList:		#(	'keep this menu up'			'simple change sorter'			'dual change sorter'			'file out current change set'			'create new change set...'			'methods in current change set'			'check change set for slips'			'isolate methods of this project'			'propagate changes above'			'recently submitted methods'			'recently logged changes...'			'recent log file...'			)		lines: #(1 3 7 9)		selections: #(durableChangesMenuopenSimpleChangeSorter openChangeManagerfileOutChanges newChangeSet browseChangedMessages lookForSlipsbeIsolated propagateChangesbrowseRecentSubmissions browseRecentLog fileForRecentLog)"ScreenController new changesMenu startUp"! !Project removeSelector: #assert!Project removeSelector: #enter:revert:saveForRevert:noFrills:!Project removeSelector: #inForce:!Object subclass: #InputSensor	instanceVariableNames: ''	classVariableNames: 'InterruptSemaphore InterruptWatcherProcess '	poolDictionaries: ''	category: 'Kernel-Processes'!HandMorph removeSelector: #assert!Debugger class removeSelector: #context:isolationSet:!Debugger removeSelector: #process:controller:context:isolationSet:!CodeHolder subclass: #Debugger	instanceVariableNames: 'interruptedProcess interruptedController contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC sourceMap tempNames savedCursor isolationHead failedProject '	classVariableNames: 'ContextStackKeystrokes ErrorRecursion '	poolDictionaries: ''	category: 'Tools-Debugger'!