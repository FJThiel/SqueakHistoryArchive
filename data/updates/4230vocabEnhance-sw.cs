'From Squeak3.1alpha of 28 February 2001 [latest update: #4229] on 4 August 2001 at 1:26:32 am'!"Change Set:		vocabEnhance-swDate:			4 August 2001Author:			Scott WallaceA variety of enhancements and cleanups regarding vocabularies, instance browsers, and Viewers, in support of forthcoming omniuser scripting demos, including:*	An InstanceBrowser preset for omniuser tile-scripting can be brought up by either choosing the new item 'morph protocol (tiles)' from the debug menu in the halo, or by shift-clicking on the Viewer icon in the halo.  In either case, you get a non-windowlike InstanceBrowser on the morph, preset to exhibit the FullVocabulary but with the depth-of-coverage limited (initially) to just the object's own class.*	New protocols allow category-lists and method-lists-within-category to be obtained directly from a Vocabulary and a limitClass, without any longer requiring the presence of a phantom Viewer intermediary.*	Numbers now normally request the NumberVocabulary as the default to be used with them.*	Viewers maintain a memory of a desired limitClass (which detemines the farthest class whose methods and categories should be considered), and there is a UI for changing the limitClass.*	By default, InstanceBrowsers appear non-window-like, i.e., they do not have a title bar or associated controls.  This is governed by the currently-hard-coded Preference #suppressWindowTitlesInInstanceBrowsers.*	New items in the debug halo menu allow more Viewer and Protocol alternatives. "!!Object methodsFor: 'scripting' stamp: 'sw 8/3/2001 22:02'!methodInterfacesForCategory: aCategorySymbol inVocabulary: aVocabulary limitClass: aLimitClass	"Return a list of methodInterfaces for the receiver in the given category, given a vocabulary.  aCategorySymbol is the inherent category symbol, not necessarily the wording as expressed in the vocabulary."	| categorySymbol |	categorySymbol _ aCategorySymbol asSymbol.	(categorySymbol == #'instance variables') ifTrue:		"user-defined instance variables"		[^ self methodInterfacesForInstanceVariablesCategoryIn: aVocabulary].	(categorySymbol == #scripts) ifTrue:						"user-defined scripts"		[^ self methodInterfacesForScriptsCategoryIn: aVocabulary].	^ (self usableMethodInterfacesIn: (aVocabulary methodInterfacesInCategory: (aVocabulary translatedWordingFor: categorySymbol) forInstance: self ofClass: self class limitClass: aLimitClass))   "all others"! !!Object methodsFor: 'scripting' stamp: 'sw 8/3/2001 13:54'!methodInterfacesForInstanceVariablesCategoryIn: aVocabulary	"Return a collection of methodInterfaces for the instance-variables category.  The vocabulary parameter, at present anyway, is not used.  And for non-players, the method is at present vacuous in any case"	^  OrderedCollection new! !!Object methodsFor: 'scripting' stamp: 'sw 8/3/2001 13:53'!methodInterfacesForScriptsCategoryIn: aVocabulary	"Answer a list of method interfaces for the category #scripts, as seen in a viewer or other tool.  The vocabulary argument is not presently used.  Also, at present, only Players really do anyting interesting here."	^ OrderedCollection new! !!Object methodsFor: 'testing' stamp: 'sw 8/3/2001 14:56'!openInstanceBrowserWithTiles	"Open up an instance browser on me with tiles as the code type, and with the search level as desired."	| aBrowser |	aBrowser _ InstanceBrowser new.	aBrowser useVocabulary: Vocabulary fullVocabulary.	aBrowser limitClass: self class.	aBrowser openOnObject: self inWorld: ActiveWorld showingSelector: nil.	aBrowser toggleShowingTiles	"(2@3) openInstanceBrowserWithTiles.WatchMorph new openInstanceBrowserWithTiles"! !!Object methodsFor: 'viewer' stamp: 'sw 8/4/2001 00:51'!categoriesForViewer: aViewer	"Answer a list of categories to offer in the given viewer"	^ aViewer currentVocabulary categoryListForInstance: self ofClass: self class limitClass: aViewer limitClass! !!Object methodsFor: 'viewer' stamp: 'sw 8/3/2001 22:08'!categoriesForVocabulary: aVocabulary limitClass: aLimitClass	"Answer a list of categories of methods for the receiver when using the given vocabulary, given that one considers only methods that are implemented not further away than aLimitClass"	^ aVocabulary categoryListForInstance: self ofClass: self class limitClass: aLimitClass! !!Object methodsFor: 'viewer' stamp: 'sw 8/3/2001 21:22'!defaultLimitClassForVocabulary: aVocabulary	"Answer the class to use, by default, as the limit class on a protocol browser or viewer opened up on the receiver, within the purview of the Vocabulary provided"	^ (aVocabulary isKindOf: FullVocabulary)		ifTrue:			 [self class superclass == Object				ifTrue:					[self class]				ifFalse:					[self class superclass]]		ifFalse:			[ProtoObject]! !!Object methodsFor: 'viewer' stamp: 'sw 8/3/2001 18:19'!offerViewerMenuFor: aViewer event: evt	"Offer the primary Viewer menu to the user.  Copied up from Player code, but most of the functions suggested here don't work for non-Player objects, many aren't even defined, some relate to exploratory sw work not yet reflected in the current corpus.  We are early in the life cycle of this method..."	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu title: '**CAUTION -- UNDER CONSTRUCTION!!**Many things may not work!!', self nameForViewer.	(aViewer affordsUniclass and: [self belongsToUniClass not]) ifTrue:		[aMenu add: 'give me a Uniclass' action: #assureUniClass.		aMenu addLine].	aMenu add: 'choose vocabulary...' target: aViewer action: #chooseVocabulary.	aMenu add: 'choose limit class...' target: aViewer action: #chooseLimitClass.	aMenu balloonTextForLastItem: 'Specify which class should be the most generic one to have its methods shown in this Viewer'.	aMenu addLine.	self belongsToUniClass ifTrue:		[aMenu add: 'add a new instance variable' target: self selector: #addInstanceVariableIn: argument: aViewer.		aMenu add: 'add a new script' target: aViewer selector: #newPermanentScriptIn: argument: aViewer.		aMenu addLine.		aMenu add: 'make my class be first-class' target: self selector: #makeFirstClassClassIn: argument: aViewer.		aMenu add: 'move my changes up to my superclass' target: self action: #promoteChangesToSuperclass.		aMenu addLine].	aMenu add: 'tear off a tile' target: self selector: #launchTileToRefer.	aMenu addLine.	aMenu add: 'inspect me' target: self selector: #inspect.	aMenu add: 'inspect my class' target: self class action: #inspect.	aMenu addLine.	aMenu add: 'browse vocabulary' action: #haveFullProtocolBrowsed.	aMenu add: 'inspect this Viewer' target: aViewer action: #inspect.	aMenu popUpEvent: evt in: aViewer currentWorld"	aMenu add: 'references to me' target: aViewer action: #browseReferencesToObject.	aMenu add: 'toggle scratch pane' target: aViewer selector: #toggleScratchPane.	aMenu add: 'make a nascent script for me' target: aViewer selector: #makeNascentScript.	aMenu add: 'rename me' target: aViewer selector: #chooseNewNameForReference.	aMenu add: 'browse full' action: #browseOwnClassFull.	aMenu add: 'browse hierarchy' action: #browseOwnClassHierarchy.	aMenu add: 'set user level...' target: aViewer action: #setUserLevel.	aMenu add: 'browse sub-protocol' action: #browseOwnClassSubProtocol.	aMenu addLine."! !!Object methodsFor: 'viewer' stamp: 'sw 8/4/2001 00:51'!tilePhrasesForCategory: aCategorySymbol inViewer: aViewer	"Return a collection of phrases for the category.  If using classic tiles, only include phrases that have fewer than two arguments, because all that they can handle."	| interfaces itsSelector |	interfaces _ self methodInterfacesForCategory: aCategorySymbol inVocabulary: aViewer currentVocabulary limitClass: aViewer limitClass.	Preferences universalTiles ifFalse:		[interfaces _ interfaces select:			[:int |				itsSelector _ int selector.				itsSelector numArgs < 2 or:					"The lone two-arg loophole in classic tiles"					[#(color:sees:) includes: itsSelector]]].	^ interfaces collect:		[:aMethodInterface |			aMethodInterface wantsReadoutInViewer				ifTrue:					[aViewer phraseForVariableFrom: aMethodInterface]				ifFalse:					[aViewer phraseForCommandFrom: aMethodInterface]]! !!InstanceBrowser methodsFor: 'initialization' stamp: 'sw 8/3/2001 18:38'!windowWithLabel: aLabel	"Answer a SystemWindow associated with the receiver, with appropriate border characteristics"	| window |	"The first branch below provides a pretty nice effect -- a large draggable border when active, a minimal border when not -- but the problem is that we often rely on the title bar to convey useful information.  For the moment, whether the titled or nontitled variant is used is governed by the hard-coded preference named 'suppressWindowTitlesInInstanceBrowsers'"	Preferences suppressWindowTitlesInInstanceBrowsers		ifTrue:			[(window _ SystemWindow newWithoutLabel) model: self.			window setProperty: #borderWidthWhenActive toValue: 8.			window setProperty: #borderWidthWhenInactive toValue: 1.			window borderWidth: 8]		ifFalse:			[(window _ SystemWindow labelled: aLabel) model: self].	^ window! !!Morph methodsFor: 'player viewer' stamp: 'sw 8/3/2001 18:40'!openViewerForArgument	"Open up a viewer for a player associated with the morph in question.  Temporarily, if shift key is down, open up an instance browser on the morph itself, not the player, with tiles showing, instead"	ActiveEvent shiftPressed ifTrue:		[ActiveWorld abandonAllHalos.		^ self openInstanceBrowserWithTiles].	self presenter viewMorph: self! !!Morph methodsFor: 'debug and other' stamp: 'sw 8/4/2001 00:54'!buildDebugMenu: aHand	"Answer a debugging menu for the receiver.  The hand argument is seemingly historical and plays no role presently"	| aMenu aPlayer |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	(self hasProperty: #errorOnDraw) ifTrue:		[aMenu add: 'start drawing again' action: #resumeAfterDrawError.		aMenu addLine].	(self hasProperty: #errorOnStep) ifTrue:		[aMenu add: 'start stepping again' action: #resumeAfterStepError.		aMenu addLine].	aMenu add: 'inspect morph' action: #inspectInMorphic:.	aMenu add: 'inspect owner chain' action: #inspectOwnerChain.	Smalltalk isMorphic ifFalse:		[aMenu add: 'inspect morph (in MVC)' action: #inspect].	(self isKindOf: MorphicModel) ifTrue:		[aMenu add: 'inspect model' target: self model action: #inspect].	(aPlayer _ self player) ifNotNil:		[aMenu add: 'inspect player' target: aPlayer action: #inspect].     aMenu add: 'explore morph' target: self selector: #explore.	aPlayer ifNotNil:		[aPlayer class isUniClass ifTrue: [aMenu add: 'browse player class' target: aPlayer action: #browseHierarchy].		"aMenu add: 'browse player protocol' target: self action: #browseProtocolForPlayer"].	aMenu addLine.	aMenu add: 'viewer for Player' target: self player action: #beViewed.	aMenu balloonTextForLastItem: 'Opens a viewer on my Player -- this is the same thing you get if you click on the cyan "View" halo handle'.	aMenu add: 'viewer for Morph' target: self action: #viewMorphDirectly.	aMenu balloonTextForLastItem: 'Opens a Viewer on this Morph, rather than on its Player'.	aMenu addLine.	aMenu add: 'browse morph class' target: self selector: #browseHierarchy.	aMenu addLine.	aMenu add: 'morph protocol (text)' target: self selector: #haveFullProtocolBrowsed.	aMenu add: 'morph protocol (tiles)' target: self selector: #openInstanceBrowserWithTiles.	aMenu addLine.	self addViewingItemsTo: aMenu.	aMenu 		add: 'make own subclass' action: #subclassMorph;		add: 'internal name ' action: #choosePartName;		add: 'save morph in file'  action: #saveOnFile;		addLine;		add: 'call #tempCommand' action: #tempCommand;		add: 'define #tempCommand' action: #defineTempCommand;		addLine;		add: 'control-menu...' target: self selector: #invokeMetaMenu:;		add: 'edit balloon help' action: #editBalloonHelpText.	^ aMenu! !!Morph methodsFor: 'debug and other' stamp: 'sw 8/4/2001 00:33'!viewMorphDirectly	"Open a Viewer directly on the Receiver, i.e. no Player involved"	self presenter viewObjectDirectly: self renderedMorph	! !!CategoryViewer methodsFor: 'support' stamp: 'sw 8/4/2001 00:51'!limitClass	"Answer the receiver's limitClass"	^ self outerViewer limitClass! !!Number methodsFor: 'vocabulary' stamp: 'sw 8/3/2001 13:43'!vocabularyDemanded	"Answer the vocabulary normally preferred by this object"	^ Vocabulary numberVocabulary! !!Player methodsFor: 'slots-kernel' stamp: 'sw 8/3/2001 13:48'!methodInterfacesForInstanceVariablesCategoryIn: aVocabulary	"Return a collection of methodInterfaces for the instance-variables category.  The vocabulary parameter, at present anyway, is not used."	| aList anInterface itsSlotName |	aList _ OrderedCollection new.	self slotInfo associationsDo:		[:assoc |			anInterface _ MethodInterface new.			itsSlotName _ assoc key.			anInterface wording: itsSlotName selector: (Utilities getterSelectorFor: itsSlotName) type: assoc value type setter: (Utilities setterSelectorFor: itsSlotName).			anInterface setToRefetch.			aList add: anInterface].	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'sw 8/3/2001 13:52'!methodInterfacesForScriptsCategoryIn: aVocabulary	"Answer a list of method interfaces for the category #scripts, as seen in a viewer or other tool.  The vocabulary argument is not presently used."	^ {self methodInterfaceForEmptyScript}, self class scripts values! !!Player methodsFor: 'misc' stamp: 'sw 8/4/2001 00:50'!categoriesForViewer: aViewer	"Answer a list of category symbols to offer as alternatives in the viewer"	^  aViewer currentVocabulary categoryListForInstance: self ofClass: self class limitClass: aViewer limitClass! !!Player methodsFor: 'misc' stamp: 'sw 8/4/2001 00:47'!offerAlternateViewerMenuFor: aViewer event: evt	"Put up an alternate Viewer menu on behalf of the receiver."	| aMenu aWorld  |	aWorld _ aViewer world.	aMenu _ MenuMorph new defaultTarget: self.	costumes ifNotNil:		[(costumes size > 1 or: [costumes size == 1 and: [costumes first ~~ costume renderedMorph]])			ifTrue:				[aMenu add: 'forget other costumes' target: self selector: #forgetOtherCostumes]].	aMenu add: 'expunge empty scripts' target: self action: #expungeEmptyScripts.	aMenu addLine.	aMenu add: 'choose vocabulary...' target: aViewer action: #chooseVocabulary.	aMenu balloonTextForLastItem: 'Choose a different vocabulary for this Viewer.'.	aMenu add: 'choose limit class...' target: aViewer action: #chooseLimitClass.	aMenu balloonTextForLastItem: 'Specify what the limitClass should be for this Viewer -- i.e., the most generic class whose methods and categories should be considered here.'.	aMenu add: 'open standard lexicon' target: aViewer action: #openLexicon.	aMenu balloonTextForLastItem: 'open a window that shows the code for this object in traditional programmer format'.	aMenu add: 'open lexicon with search pane' target: aViewer action: #openSearchingProtocolBrowser.	aMenu balloonTextForLastItem: 'open a lexicon that has a type-in pane for search (not recommended!!)'.	aMenu addLine.	aMenu add: 'inspect morph' target: costume selector: #inspect.	aMenu add: 'inspect player' target: self selector: #inspect.	self belongsToUniClass ifTrue:		[aMenu add: 'browse class' target: self action: #browsePlayerClass.		aMenu add: 'inspect class' target: self class action: #inspect].	aMenu add: 'inspect this Viewer' target: aViewer selector: #inspect.	aMenu add: 'inspect this Vocabulary' target: aViewer currentVocabulary selector: #inspect.	aMenu addLine.	aMenu add: 'relaunch this Viewer' target: aViewer action: #relaunchViewer.	aMenu add: 'view morph directly' target: aViewer action: #viewMorphDirectly.	aMenu balloonTextForLastItem: 'opens a Viewer directly on the rendered morph.'.	aMenu popUpEvent: evt in: aWorld! !!Preferences class methodsFor: 'hard-coded prefs' stamp: 'sw 8/3/2001 15:08'!suppressWindowTitlesInInstanceBrowsers	"Hard-coded for the moment: answer whether instance browsers should suppresss their window titles"	^ true! !!Presenter methodsFor: 'viewer' stamp: 'sw 8/3/2001 18:31'!updateViewer: aViewer forceToShow: aCategorySymbol	"Update the given viewer to make sure it is in step with various possible changes in the outside world, and when reshowing it be sure it shows the given category"	| aPlayer aPosition newViewer oldOwner wasSticky barHeight cats itsVocabulary aCategory |	aCategory _ aCategorySymbol ifNotNil: [aViewer currentVocabulary translatedWordingFor: aCategorySymbol].	cats _ aViewer symbolsOfCategoriesCurrentlyShowing asOrderedCollection.	itsVocabulary _ aViewer currentVocabulary.	aCategory ifNotNil: [(cats includes: aCategorySymbol) ifFalse: [cats addFirst: aCategorySymbol]].	aPlayer _ aViewer scriptedPlayer.	aPosition _ aViewer position.	wasSticky _ aViewer isSticky.	newViewer _ aViewer species new visible: false.	barHeight _ aViewer submorphs first listDirection == #topToBottom		ifTrue:			[aViewer submorphs first submorphs first height]		ifFalse:			[0].	Preferences viewersInFlaps ifTrue:		[newViewer setProperty: #noInteriorThumbnail toValue: true].	newViewer rawVocabulary: itsVocabulary.	newViewer limitClass: aViewer limitClass.	newViewer initializeFor: aPlayer barHeight: barHeight includeDismissButton: aViewer hasDismissButton showCategories: cats.	wasSticky ifTrue: [newViewer beSticky].	oldOwner _ aViewer owner.	oldOwner ifNotNil:		[oldOwner replaceSubmorph: aViewer by: newViewer].		"It has happened that old readouts are still on steplist.  We may see again!!"	newViewer position: aPosition.	newViewer enforceTileColorPolicy.	newViewer visible: true.	newViewer world doIfNotNil: [:aWorld | aWorld startSteppingSubmorphsOf: newViewer].	newViewer layoutChanged! !!StandardViewer methodsFor: 'categories' stamp: 'sw 8/3/2001 18:22'!chooseLimitClass	"Put up a menu allowing the user to choose the most generic class to show"	| aMenu limitClass |	aMenu _ MenuMorph new defaultTarget: self.	limitClass _ self limitClass.	scriptedPlayer class withAllSuperclasses do:		[:aClass | 			aClass == ProtoObject				ifTrue:					[aMenu addLine].			aMenu add: aClass name selector: #setLimitClass: argument: aClass.			aClass == limitClass ifTrue:				[aMenu lastItem color: Color red].			aClass == limitClass ifTrue: [aMenu addLine]].	aMenu addTitle: 'Show only methodsimplemented at or above...'.  "heh heh -- somebody please find nice wording here!!"	aMenu popUpInWorld: self currentWorld! !!StandardViewer methodsFor: 'categories' stamp: 'sw 8/3/2001 18:17'!limitClass	"Answer the limit class to use in this viewer"	| aClass |	(aClass _ self valueOfProperty: #limitClass)  ifNotNil:		[^ aClass].	aClass _ scriptedPlayer defaultLimitClassForVocabulary: self currentVocabulary.	self setProperty: #limitClass toValue: aClass.	^ aClass! !!StandardViewer methodsFor: 'categories' stamp: 'sw 8/3/2001 18:31'!limitClass: aClass	"Set aClass as the limit class for this viewer, without side effects"	self setProperty: #limitClass toValue: aClass! !!StandardViewer methodsFor: 'categories' stamp: 'sw 8/3/2001 18:31'!setLimitClass: aClass	"Set aClass as the limit class for this viewer"	self limitClass: aClass.	self relaunchViewer! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'sw 8/4/2001 00:05'!selectorMenu	"Put up a menu of all selectors that my receiver could be sent.  Replace me with the one chosen.  (If fewer args, put the tiles for the extra arg to the side, in script's owner (world?).)	Go ahead and eval receiver to find out its type.  Later, mark selectors for side effects, and don't eval those.	Put up a table.  Each column is a viewer category."	| rec cats value catNames interfaces list setter wording all words ind aVocabulary limitClass |	rec _ owner receiverNode.	rec ifNil: [rec _ owner owner receiverNode].		rec ifNil: [rec _ owner owner owner receiverNode].	cats _ #().	all _ Set new.	rec ifNil: [^ self].	"Use types like (receiver resultType) instead?" 	"Global current Vocabulary must be set?"	value _ rec try.	value class == Error ifTrue: [^ nil].		aVocabulary _ self vocabularyToUseWith: value.	limitClass _ self limitClassToUseWith: value vocabulary: aVocabulary.	catNames _ value categoriesForVocabulary: aVocabulary limitClass: limitClass.	cats _ catNames collect: [:nn | 		list _ OrderedCollection new.		interfaces _ value methodInterfacesForCategory: nn inVocabulary: aVocabulary limitClass: limitClass.		interfaces do: [:mi | 			(all includes: mi selector) ifFalse: [				"list add: (self aSimpleStringMorphWith: mi elementWording).  Expensive"				words _ self splitAtCapsAndDownshifted: mi selector.					(words beginsWith: 'get ') ifTrue: [words _ words allButFirst: 4].				mi selector numArgs > 0 ifTrue: [words _ words, ' 5'].				list add: (self anUpdatingStringMorphWith: words special: true).				list last setProperty: #syntacticallyCorrectContents toValue: mi selector.				all add: mi selector].			setter _ mi companionSetterSelector asString.			(setter = 'nil') | (all includes: setter) ifFalse: ["need setters also"				wording _ (self translateToWordySetter: setter).				list add:  (self aSimpleStringMorphWith: wording, ' 5').				list last setProperty: #syntacticallyCorrectContents 					toValue: setter.				all add: setter]].		list].	(ind _ catNames indexOf: 'scripts') > 0 ifTrue: [		(cats at: ind) first contents = 'empty script' ifTrue: [			(cats at: ind) removeFirst]].	self chooseSelectorFrom: cats.	"The method replaceSel:menuItem: does the work.  		Replaces the selector."	! !!SyntaxMorph methodsFor: 'vocabulary' stamp: 'sw 8/4/2001 00:41'!limitClassToUseWith: aValue vocabulary: aVocabulary	"Answer the most generic whose method should be shown in a selector pop-up in the receiver that is put up on behalf of aValue"	(aValue isKindOf: Number) ifTrue: [^ Number].	"Ted: This hook allows you to intervene as suits your purposes here if you don't like the defaults."	^ aValue defaultLimitClassForVocabulary: aVocabulary	! !!SyntaxMorph methodsFor: 'vocabulary' stamp: 'sw 8/4/2001 00:41'!vocabularyToUseWith: aValue	"Answer a vocabulary to use with the given value"	(aValue isKindOf: Number) ifTrue: [^ Vocabulary numberVocabulary].	(aValue isKindOf: Time) ifTrue: [^ Vocabulary timeVocabulary].  "Ted -- I presume you will provide this!!"	^ self currentVocabulary! !!Vocabulary methodsFor: 'queries' stamp: 'sw 8/3/2001 22:01'!methodInterfacesInCategory: categoryName forInstance: anObject ofClass: aClass limitClass: aLimitClass	"Answer a list of method interfaces of all methods in the given category, provided they are implemented no further away than aLimitClass."	| defClass |	^ ((self allMethodsInCategory: categoryName forInstance: anObject ofClass: aClass) collect:		[:sel | methodInterfaces at: sel ifAbsent:			[MethodInterface new conjuredUpFor: sel class: aClass]]) select:				[:aMethodInterface |					defClass _ aClass whichClassIncludesSelector: aMethodInterface selector.					(defClass notNil and: [defClass includesBehavior: aLimitClass])]! !!Vocabulary class methodsFor: 'class initialization' stamp: 'sw 8/3/2001 22:54'!initializeStandardVocabularies	"Initialize a few standard vocabularies and place them in the AllVocabularies list."	AllVocabularies _ OrderedCollection new.	AllMethodInterfaces _ IdentityDictionary new.	self addVocabulary: EToyVocabulary new.	self addVocabulary: self newPublicVocabulary.	self addVocabulary: FullVocabulary new.	self addVocabulary: self newQuadVocabulary.	self addKiswahiliVocabulary.	self addGermanVocabulary.	self wonderlandVocabulary.  	"creates it and adds it"	self numberVocabulary.   		"ditto"	"Vocabulary initialize"! !!Vocabulary class methodsFor: 'type vocabularies' stamp: 'sw 8/3/2001 22:47'!newNumberVocabulary	"Answer a Vocabulary object representing the Number vocabulary to the list of AllVocabularies" 	| aVocabulary aMethodCategory aMethodInterface |	"Vocabulary newNumberVocabulary"	aVocabulary _ self new vocabularyName: #Number.		aVocabulary documentation: 'Numbers are things that can do arithmetic, have their magnitudes compared, etc.'.#((arithmetic 				'Basic numeric operation'		(* + - / // \\ abs negated quo: rem:))(comparing				'Determining which of two numbers is larger'		(= < > <= >= ~= ~~))(testing 					'Testing a number'		(even isDivisibleBy: negative odd positive sign))(#'mathematical functions'	'Trigonometric and exponential functions'		(cos exp ln log log: raisedTo: sin sqrt squared tan raisedToInteger:))(converting 				'Converting a number to another form'		(@ asInteger asPoint degreesToRadians radiansToDegrees asSmallAngleDegrees asSmallPositiveDegrees))(#'truncation and round off' 'Making a real number (with a decimal point) into an integer'		(ceiling floor roundTo: roundUpTo: rounded truncateTo: truncated))) do:		[:item | 			aMethodCategory _ ElementCategory new categoryName: item first.			aMethodCategory documentation: item second.			item third do:				[:aSelector | 					aMethodInterface _ MethodInterface new conjuredUpFor: aSelector class: (Number whichClassIncludesSelector: aSelector).					aVocabulary atKey: aSelector putMethodInterface: aMethodInterface.					aMethodCategory elementAt: aSelector put: aMethodInterface].			aVocabulary addCategory: aMethodCategory].	^ aVocabulary"(('truncation and round off' ceiling detentBy:atMultiplesOf:snap: floor roundTo: roundUpTo: rounded truncateTo: truncated)('testing' basicType even isDivisibleBy: isInf isInfinite isNaN isNumber isZero negative odd positive sign strictlyPositive)('converting' @ adaptToCollection:andSend: adaptToFloat:andSend: adaptToFraction:andSend: adaptToInteger:andSend: adaptToPoint:andSend: adaptToString:andSend: asInteger asNumber asPoint asSmallAngleDegrees asSmallPositiveDegrees degreesToRadians radiansToDegrees)('intervals' to: to:by: to:by:do: to:do:)('printing' defaultLabelForInspector isOrAreStringWith: newTileMorphRepresentative printOn: printStringBase: storeOn: storeOn:base: storeStringBase: stringForReadout)('comparing' closeTo:)('filter streaming' byteEncode:)('as yet unclassified' reduce)"! !!Vocabulary class methodsFor: 'type vocabularies' stamp: 'sw 8/3/2001 22:52'!numberVocabulary	"Answer the standard vocabulary representing numbers, creating it if necessary"	| aVocab |	^ self allVocabularies detect: [:aVocabulary | 		aVocabulary vocabularyName = 'Number'] ifNone:			[self addVocabulary: (aVocab _ self newNumberVocabulary).			aVocab]! !!Vocabulary class methodsFor: 'type vocabularies' stamp: 'sw 8/4/2001 01:03'!replaceNumberVocabulary	"Put a new Number vocabulary in place, since the old one was flawed.  No senders, called only by do-its" 	"Vocabulary replaceNumberVocabulary"	self resetMethodInterfaceRepository.	AllVocabularies remove: (self vocabularyNamed: 'Number') ifAbsent: [].	self numberVocabulary! !!WonderlandActor methodsFor: 'eToy-fake' stamp: 'sw 8/3/2001 13:56'!methodInterfacesForScriptsCategoryIn: aVocabulary	"Needed for showing emptyScript"	^ self methodInterfaceForEmptyScript! !Object removeSelector: #methodInterfacesForCategory:inViewer:!"Postscript:"Vocabulary initialize.!