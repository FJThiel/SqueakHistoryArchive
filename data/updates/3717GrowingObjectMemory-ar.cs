'From Squeak3.1alpha of 4 February 2001 [latest update: #3726] on 26 February 2001 at 12:10:05 am'!"Change Set:		GrowingObjectMemory-arDate:			25 February 2001Author:			Andreas RaabAdds the ability of growing and shrinking the ObjectMemory if the OS provides the necessary means of modifying the upper memory limit by a continuous chunk of memory.The defaults provided keep everything as is - one fixed portion of memory."!Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows freeContexts freeLargeContexts interruptCheckCounter displayBits totalObjectFoundAtStartup totalObjectCount growHeadroom shrinkThreshold '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize BlockContextProto CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassExternalAddress ClassExternalData ClassExternalFunction ClassExternalLibrary ClassExternalStructure ClassFloat ClassInteger ClassLargeNegativeInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClassMask CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero CtxtTempFrameStart DoAssertionChecks DoBalanceChecks Done ExternalObjectsArray FalseObject FloatProto GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextBit LargeContextSize MarkBit MethodContextProto NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotInterpret SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SizeMask SmallContextSize SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'VMConstruction-Interpreter'!!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 2/25/2001 17:36'!squeakHeaderFile	^'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#include "sqVirtualMachine.h"#define true 1#define false 0#define null 0  /* using "null" because nil is predefined in Think C *//* pluggable primitives macros *//* Note: All pluggable primitives are defined as	EXPORT(int) somePrimitive(void)   If the platform requires special declaration modifiers   the EXPORT macro can be redefined*/#define EXPORT(returnType) returnType/* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqImageFileStartLocation(fileRef, fileName, size)  0/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* platform-dependent macros for handling object memory *//* Note: The grow/shrink macros assume that the object memory can be extended   continuously at its prior end. The garbage collector cannot deal with ''holes''   in the object memory so the support code needs to reserve the virtual maximum   of pages that can be allocated beforehand. The amount of ''extra'' memory should   describe the amount of memory that can be allocated from the OS (including swap   space if the flag is set to true) and must not exceed the prior reserved memory.   (in other words: don''t you dare to report more free space then you can actually allocate).   The default implementation assumes a fixed size memory allocated at startup.*/#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)#define sqGrowMemoryBy(int oldLimit, int delta) oldLimit#define sqShrinkMemoryBy(int oldLimit, int delta) oldLimit#define sqMemoryExtraBytesLeft(int includingSwap) 0/* platform-dependent memory size adjustment macro *//* Note: This macro can be redefined to allows platforms with a   fixed application memory partition (notably, the Macintosh)   to reserve extra C heap memory for special applications that need   it (e.g., for a 3D graphics library). Since most platforms can   extend their application memory partition at run time if needed,   this macro is defined as a noop here and redefined if necessary   in sqPlatformSpecific.h.*/#define reserveExtraCHeapBytes(origHeapSize, bytesToReserve) origHeapSize/* platform-dependent millisecond clock macros *//* Note: The Squeak VM uses three different clocks functions for   timing. The primary one, ioMSecs(), is used to implement Delay   and Time millisecondClockValue. The resolution of this clock   determines the resolution of these basic timing functions. For   doing real-time control of music and MIDI, a clock with resolution   down to one millisecond is preferred, but a coarser clock (say,   1/60th second) can be used in a pinch. The VM calls a different   clock function, ioLowResMSecs(), in order to detect long-running   primitives. This function must be inexpensive to call because when   a Delay is active it is polled twice per primitive call. On several   platforms (Mac, Win32), the high-resolution system clock used in   ioMSecs() would incur enough overhead in this case to slow down the   the VM significantly. Thus, a cheaper clock with low resolution is   used to implement ioLowResMSecs() on these platforms. Finally, the   function ioMicroMSecs() is used only to collect timing statistics   for the garbage collector and other VM facilities. (The function   name is meant to suggest that the function is based on a clock   with microsecond accuracy, even though the times it returns are   in units of milliseconds.) This clock must have enough precision to   provide accurate timings, and normally isn''t called frequently   enough to slow down the VM. Thus, it can use a more expensive clock   that ioMSecs(). By default, all three clock functions are defined   here as macros based on the standard C library function clock().   Any of these macros can be overridden in sqPlatformSpecific.h.*/int ioMSecs(void);int ioLowResMSecs(void);int ioMicroMSecs(void);#define ioMSecs()		((1000 * clock()) / CLOCKS_PER_SEC)#define ioLowResMSecs()	((1000 * clock()) / CLOCKS_PER_SEC)#define ioMicroMSecs()	((1000 * clock()) / CLOCKS_PER_SEC)/* filename copy/transform macro. An opportunity to transform the filenames for   platforms with strange needs, anda simple encapsulation for everyone else*/#define sqFilenameFromString(dst, src, num) \if (1) { \	int i; \	for (i = 0; i < num; i++) { \		dst[i] = *((char *) (src + i)); \	} \	dst[num] = 0;\}/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioScreenDepth(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);int ioHasDisplayDepth(int depth);int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag);/* Power Management */int ioDisablePowerManager(int disableIfNonZero);/* User input recording I:   In general, either set of input function can be supported,   depending on the platform. This (first) set is state based   and should be supported even on platforms that make use   of the newer event driven API to support older images    without event support.*/int ioGetButtonState(void);int ioGetKeystroke(void);int ioMousePoint(void);int ioPeekKeystroke(void);/* Note: In an event driven architecture, ioProcessEvents is obsolete.   It can be implemented as a no-op since the image will check for   events in regular intervals. */int ioProcessEvents(void);/* User input recording II:   The following functions and definition can be used on   platform supporting events directly.*//* types of events */#define EventTypeNone 0#define EventTypeMouse 1#define EventTypeKeyboard 2#define EventTypeDragDropFiles 3/* keypress state for keyboard events */#define EventKeyChar 0#define EventKeyDown 1#define EventKeyUp 2/* button definitions */#define RedButtonBit 4#define BlueButtonBit 2#define YellowButtonBit 1/* modifier definitions */#define ShiftKeyBit 1#define CtrlKeyBit 2#define OptionKeyBit 4#define CommandKeyBit 8/* generic input event definition */typedef struct sqInputEvent {	int type; /* type of event; either one of EventTypeXXX */	unsigned int timeStamp; /* time stamp */     /* the interpretation of the following fields depend on the type of the event */	int unused1;	int unused2;	int unused3;	int unused4;	int unused5;	int unused6;} sqInputEvent;/* mouse input event definition */typedef struct sqMouseEvent {	int type; /* EventTypeMouse */	unsigned int timeStamp; /* time stamp */	int x; /* mouse position x */	int y; /* mouse position y */	int buttons; /* combination of xxxButtonBit */	int modifiers; /* combination of xxxKeyBit */	int reserved1; /* reserved for future use */	int reserved2; /* reserved for future use */} sqMouseEvent;/* keyboard input event definition */typedef struct sqKeyboardEvent {	int type; /* EventTypeKeyboard */	unsigned int timeStamp; /* time stamp */	int charCode; /* character code in Mac Roman encoding */	int pressCode; /* press code; any of EventKeyXXX */	int modifiers; /* combination of xxxKeyBit */	int reserved1; /* reserved for future use */	int reserved2; /* reserved for future use */	int reserved3; /* reserved for future use */} sqKeyboardEvent;/* drop files event definition:   DragEnter - drag operation from OS entered Squeak window   DragMove  - drag operation from OS moved within Squeak window   DragLeave - drag operation from OS left Squeak window   DragDrop  - drag operation dropped contents onto Squeak.*/#define DragEnter 1#define DragMove  2#define DragLeave 3#define DragDrop  4typedef struct sqDragDropFilesEvent {	int type; /* EventTypeDropFiles */	unsigned int timeStamp; /* time stamp */	int dragType; /* one of the DragXXX constants */	int x; /* mouse position x */	int y; /* mouse position y */	int modifiers; /* combination of xxxKeyBit */	int numFiles; /* number of files in transaction */	int reserved1; /* reserved for future use */} sqDragDropFilesEvent;/* set an asynchronous input semaphore index for events */int ioSetInputSemaphore(int semaIndex);/* retrieve the next input event from the OS */int ioGetNextEvent(sqInputEvent *evt);/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* image security traps */int ioCanRenameImage(void);int ioCanWriteImage(void);int ioDisableImageWrite(void);#ifdef DISABLE_SECURITY# define ioCanRenameImage() 1# define ioCanWriteImage() 1# define ioDisableImageWrite() 1#endif/* save/restore *//* Read the image from the given file starting at the given image offset */int readImageFromFileHeapSizeStartingAt(sqImageFile f, int desiredHeapSize, int imageOffset);/* NOTE: The following is obsolete - it is only provided for compatibility */#define readImageFromFileHeapSize(f, s) readImageFromFileHeapSizeStartingAt(f,s,0)/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* browser plug-in support */void plugInForceTimeToReturn(void);int plugInInit(char *imageName);int plugInNotifyUser(char *msg);void plugInSetStartTime(void);int plugInShutdown(void);int plugInTimeToReturn(void);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/*** pluggable primitive support ***//* NOTE: The following functions are those implemented by sqNamedPrims.c */int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength,  int moduleNameIndex, int moduleNameLength);int ioUnloadModuleOfLength(int moduleNameIndex, int moduleNameLength);int ioLoadFunctionFrom(char *functionName, char *pluginName);int ioShutdownAllModules(void);int ioUnloadModule(char *);int ioUnloadModuleOfLength(int moduleNameIndex, int moduleNameLength);char *ioListBuiltinModule(int moduleIndex);char *ioListLoadedModule(int moduleIndex);/* The next two are FFI entries!! (implemented in sqNamedPrims.c as well) */int ioLoadModuleOfLength(int moduleNameIndex, int moduleNameLength);int ioLoadSymbolOfLengthFromModule(int functionNameIndex, int functionNameLength, int moduleHandle);/* The next three functions must be implemented by sqXYZExternalPrims.c *//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName);/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle);/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle);/* The Squeak version this interpreter was generated from */extern const char *interpreterVersion;'! !!ObjectMemory methodsFor: 'initialization' stamp: 'ar 2/25/2001 23:45'!initializeMemoryFirstFree: firstFree 	"Initialize endOfMemory to the top of oop storage space, reserving some space for forwarding blocks, and create the freeBlock from which space is allocated. Also create a fake free chunk at endOfMemory to act as a sentinal for memory scans."	"Note: The amount of space reserved for forwarding blocks should be chosen to ensure that incremental compactions can usually be done in a single pass. However, there should be enough forwarding blocks so a full compaction can be done in a reasonable number of passes, say ten. (A full compaction requires N object-moving passes, where N = number of non-garbage objects / number of forwarding blocks).di 11/18/2000 Re totalObjectCount: Provide a margin of one byte per object to be used for forwarding pointers at GC time.  Since fwd blocks are 8 bytes, this means an absolute worst case of 8 passes to compact memory.  In most cases it will be adequate to do compaction in a single pass."	| fwdBlockBytes |	"reserve space for forwarding blocks"	fwdBlockBytes _ totalObjectCount bitAnd: 16rFFFFFFFC.	(memoryLimit - fwdBlockBytes) >= (firstFree + BaseHeaderSize) ifFalse: [		"reserve enough space for a minimal free block of BaseHeaderSize bytes"		fwdBlockBytes _ memoryLimit - (firstFree + BaseHeaderSize).	].	"set endOfMemory and initialize freeBlock"	endOfMemory _ memoryLimit - fwdBlockBytes.	freeBlock _ firstFree.	self setSizeOfFree: freeBlock to: (endOfMemory - firstFree).  "bytes available for oops"	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	DoAssertionChecks ifTrue: [		((freeBlock < endOfMemory) and: [endOfMemory < memoryLimit])			ifFalse: [ self error: 'error in free space computation' ].			(self oopFromChunk: endOfMemory) = endOfMemory			ifFalse: [ self error: 'header format must have changed' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'free block not properly initialized' ].	].! !!ObjectMemory methodsFor: 'initialization' stamp: 'ar 2/25/2001 23:45'!initializeObjectMemory: bytesToShift	"Initialize object memory variables at startup time. Assume endOfMemory is initially set (by the image-reading code) to the end of the last object in the image. Initialization redefines endOfMemory to be the end of the object allocation area based on the total available memory, but reserving some space for forwarding blocks."	"Assume: image reader initializes the following variables:		memory		endOfMemory		memoryLimit		specialObjectsOop		lastHash	"	"di 11/18/2000 fix slow full GC"	self inline: false.	"set the start of the young object space"	youngStart _ endOfMemory.	"image may be at a different address; adjust oops for new location"	totalObjectCount _ self adjustAllOopsBy: bytesToShift.	self initializeMemoryFirstFree: endOfMemory.		"initializes endOfMemory, freeBlock"	specialObjectsOop _ specialObjectsOop + bytesToShift.	"heavily used special objects"	nilObj	_ self splObj: NilObject.	falseObj	_ self splObj: FalseObject.	trueObj	_ self splObj: TrueObject.	rootTableCount _ 0.	child _ 0.	field _ 0.	parentField _ 0.	freeContexts _ NilContext.	freeLargeContexts _ NilContext.	allocationCount _ 0.	lowSpaceThreshold _ 0.	signalLowSpace _ false.	compStart _ 0.	compEnd _ 0.	fwdTableNext _ 0.	fwdTableLast _ 0.	remapBufferCount _ 0.	allocationsBetweenGCs _ 4000.  "do incremental GC after this many allocations"	tenuringThreshold _ 2000.  "tenure all suriving objects if count is over this threshold"	growHeadroom _ 4*1024*1024. "four megabyte of headroom when growing"	shrinkThreshold _ 8*1024*1024. "eight megabyte of free space before shrinking"	"garbage collection statistics"	statFullGCs _ 0.	statFullGCMSecs _ 0.	statIncrGCs _ 0.	statIncrGCMSecs _ 0.	statTenures _ 0.	statRootTableOverflows _ 0.	displayBits _ 0.  "support for the Acorn VM; ignored if zero"! !!ObjectMemory methodsFor: 'allocation' stamp: 'ar 2/25/2001 17:45'!bytesLeft: includingSwap	^(self sizeOfFree: freeBlock) "already commited"		+ (self sqMemoryExtraBytesLeft: includingSwap).! !!ObjectMemory methodsFor: 'allocation' stamp: 'ar 2/25/2001 16:36'!growObjectMemory: delta	"Attempt to grow the object memory by the given delta amount"	| limit |	limit _ self sqGrowMemory: memoryLimit By: delta.	limit = memoryLimit ifFalse:[		memoryLimit _ limit - 24. "remove a tad for safety"		self initializeMemoryFirstFree: freeBlock.	].! !!ObjectMemory methodsFor: 'allocation' stamp: 'ar 2/25/2001 16:36'!shrinkObjectMemory: delta	"Attempt to shrink the object memory by the given delta amount"	| limit |	limit _ self sqShrinkMemory: memoryLimit By: delta.	limit = memoryLimit ifFalse:[		memoryLimit _ limit - 24. "remove a tad for safety"		self initializeMemoryFirstFree: freeBlock.	].! !!ObjectMemory methodsFor: 'allocation' stamp: 'ar 2/25/2001 15:43'!sufficientSpaceAfterGC: minFree	"Return true if there is enough free space after doing a garbage collection. If not, signal that space is low."	| growSize |	self inline: false.	self incrementalGC.  "try to recover some space"	(self cCoerce: (self sizeOfFree: freeBlock) to: 'unsigned ')		< (self cCoerce: minFree to: 'unsigned ')		ifTrue:		[signalLowSpace ifTrue: [ ^ false ].  "give up; problem is already noted"		self fullGC.  "try harder"		"for stability, require more free space after doing an expensive full GC"		(self cCoerce: (self sizeOfFree: freeBlock) to: 'unsigned ')			>= ((self cCoerce: minFree to: 'unsigned ') + 15000)			ifTrue: [ ^ true ].  		"still not enough; attempt to grow object memory"		growSize _ (minFree - self sizeOfFree: freeBlock) + growHeadroom.		self growObjectMemory: growSize.		(self cCoerce: (self sizeOfFree: freeBlock) to: 'unsigned ')			>= ((self cCoerce: minFree to: 'unsigned ') + 15000)			ifTrue: [ ^ true ].  		"still not enough"		^false	].	^ true! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'ar 2/25/2001 23:44'!fullCompaction	"Move all accessible objects down to leave one big free chunk at the end of memory."	"Assume: Incremental GC has just been done to maximimize forwarding table space."	| sz |	"need not move objects below the first free chunk"	compStart _ self lowestFreeAfter: (self startOfMemory).	compStart = freeBlock ifTrue: [		"memory is already compact; only free chunk is at the end"		^ self initializeMemoryFirstFree: freeBlock	].	(sz _ self fwdTableSize: 8) < totalObjectCount ifTrue:[		"Try to grow OM to make a single pass full GC"		self growObjectMemory: (totalObjectCount - sz + 10000) * 8.		"Above may or may not work. 		If it does, we can do compaction in a single pass.		If not, we'll have to loop."	].	"work up through memory until all free space is at the end"	[compStart < freeBlock] whileTrue: [		"free chunk returned by incCompBody becomes start of next compaction"		compStart _ self incCompBody.  "bubble of free space moves up each time"	].! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'ar 2/25/2001 23:45'!fullGC	"Do a mark/sweep garbage collection of the entire object memory. Free inaccessible objects but do not move them."	| startTime |	self inline: false.	DoAssertionChecks ifTrue: [self reverseDisplayFrom: 0 to: 7].	self preGCAction: true.	startTime _ self ioMicroMSecs.	self clearRootsTable.	youngStart _ self startOfMemory.  "process all of memory"	self markPhase.	"Sweep phase returns the number of survivors.	Use the up-to-date version instead the one from startup."	totalObjectCount _ self sweepPhase.	self fullCompaction.	allocationCount _ 0.	statFullGCs _ statFullGCs + 1.	statFullGCMSecs _ statFullGCMSecs + (self ioMicroMSecs - startTime).	youngStart _ freeBlock.  "reset the young object boundary"	self postGCAction.	DoAssertionChecks ifTrue: [self reverseDisplayFrom: 0 to: 7].! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'ar 2/25/2001 15:14'!fwdTableSize: blkSize	"Estimate the number of forwarding blocks available for compaction"	| eom fwdFirst fwdLast |	self inline: false.	eom _ freeBlock + BaseHeaderSize.	"use all memory free between freeBlock and memoryLimit for forwarding table"	"Note: Forward blocks must be quadword aligned."	fwdFirst _ (eom + BaseHeaderSize + 7) bitAnd: 16rFFFFFFF8.	fwdLast _ memoryLimit - blkSize.  "last forwarding table entry"	"return the number of forwarding blocks available"	^ (fwdLast - fwdFirst) // blkSize  "round down"! !!Interpreter methodsFor: 'object memory support' stamp: 'ar 2/25/2001 15:43'!postGCAction	"Mark the active and home contexts as roots if old. This allows the interpreter to use storePointerUnchecked to store into them."	compilerInitialized		ifTrue:			[self compilerPostGC]		ifFalse:			[(activeContext    < youngStart) ifTrue: [ self beRootIfOld: activeContext ].			 (theHomeContext < youngStart) ifTrue: [ self beRootIfOld: theHomeContext ]].	(self sizeOfFree: freeBlock) > shrinkThreshold ifTrue:[		"Attempt to shrink memory after successfully reclaiming lots of memory"		self shrinkObjectMemory: (self sizeOfFree: freeBlock) - growHeadroom.	].! !!Interpreter methodsFor: 'memory space primitives' stamp: 'ar 2/25/2001 18:02'!primitiveBytesLeft	"Reports bytes available at this moment. For more meaningful results, calls to this primitive should be preceeded by a full or incremental garbage collection."	| aBool |	self methodArgumentCount = 0 ifTrue:[		"old behavior"		self pop: 1.		^self pushInteger: (self sizeOfFree: freeBlock)].	self methodArgumentCount = 1 ifTrue:[		"Including or excluding swap space"		aBool _ self booleanValueOf: self stackTop.		successFlag ifFalse:[^nil].		self pop: 2.		^self pushInteger: (self bytesLeft: aBool).	].	^self primitiveFail! !!Interpreter methodsFor: 'memory space primitives' stamp: 'ar 2/25/2001 17:38'!primitiveFullGC	"Do a quick, incremental garbage collection and return the number of bytes available (including swap space if dynamic memory management is supported)."	self pop: 1.	self incrementalGC.  "maximimize space for forwarding table"	self fullGC.	self pushInteger: (self bytesLeft: true).! !!Interpreter methodsFor: 'memory space primitives' stamp: 'ar 2/25/2001 17:19'!primitiveIncrementalGC	"Do a quick, incremental garbage collection and return the number of bytes immediately available. (Note: more space may be made available by doing a full garbage collection."	self pop: 1.	self incrementalGC.	self pushInteger: (self bytesLeft: false).! !!Interpreter methodsFor: 'other primitives' stamp: 'ar 2/25/2001 23:58'!primitiveVMParameter	"Behaviour depends on argument count:		0 args:	return an Array of VM parameter values;		1 arg:	return the indicated VM parameter;		2 args:	set the VM indicated parameter.	VM parameters are numbered as follows:		1	end of old-space (0-based, read-only)		2	end of young-space (read-only)		3	end of memory (read-only)		4	allocationCount (read-only)		5	allocations between GCs (read-write)		6	survivor count tenuring threshold (read-write)		7	full GCs since startup (read-only)		8	total milliseconds in full GCs since startup (read-only)		9	incremental GCs since startup (read-only)		10	total milliseconds in incremental GCs since startup (read-only)		11	tenures of surving objects since startup (read-only)		12-20 specific to the translating VM		21	root table size (read-only)		22	root table overflows since startup (read-only)		23	bytes of extra memory to reserve for VM buffers, plugins, etc.		24	memory headroom when growing object memory (rw)		25	memory threshold above which shrinking object memory (rw)	Note: Thanks to Ian Piumarta for this primitive."	| mem paramsArraySize result arg index |	mem _ self cCoerce: memory to: 'int'.	self cCode: '' inSmalltalk: [mem _ 0].	argumentCount = 0 ifTrue: [		paramsArraySize _ 25.		result _ self instantiateClass: (self splObj: ClassArray) indexableSize: paramsArraySize.		0 to: paramsArraySize - 1 do:			[:i | self storeWord: i ofObject: result withValue: (self integerObjectOf: 0)].		self storeWord: 0	ofObject: result withValue: (self integerObjectOf: youngStart - mem).		self storeWord: 1		ofObject: result withValue: (self integerObjectOf: freeBlock - mem).		self storeWord: 2	ofObject: result withValue: (self integerObjectOf: endOfMemory - mem).		self storeWord: 3	ofObject: result withValue: (self integerObjectOf: allocationCount).		self storeWord: 4	ofObject: result withValue: (self integerObjectOf: allocationsBetweenGCs).		self storeWord: 5	ofObject: result withValue: (self integerObjectOf: tenuringThreshold).		self storeWord: 6	ofObject: result withValue: (self integerObjectOf: statFullGCs).		self storeWord: 7	ofObject: result withValue: (self integerObjectOf: statFullGCMSecs).		self storeWord: 8	ofObject: result withValue: (self integerObjectOf: statIncrGCs).		self storeWord: 9	ofObject: result withValue: (self integerObjectOf: statIncrGCMSecs).		self storeWord: 10	ofObject: result withValue: (self integerObjectOf: statTenures).		self storeWord: 20	ofObject: result withValue: (self integerObjectOf: rootTableCount).		self storeWord: 21	ofObject: result withValue: (self integerObjectOf: statRootTableOverflows).		self storeWord: 22	ofObject: result withValue: (self integerObjectOf: extraVMMemory).		self storeWord: 23	ofObject: result withValue: (self integerObjectOf: shrinkThreshold).		self storeWord: 24	ofObject: result withValue: (self integerObjectOf: growHeadroom).		self pop: 1 thenPush: result.		^nil].	arg _ self stackTop.	(self isIntegerObject: arg) ifFalse: [^self primitiveFail].	arg _ self integerValueOf: arg.	argumentCount = 1 ifTrue: [	 "read VM parameter"		(arg < 1 or: [arg > 23]) ifTrue: [^self primitiveFail].		arg = 1		ifTrue: [result _ youngStart - mem].		arg = 2		ifTrue: [result _ freeBlock - mem].		arg = 3		ifTrue: [result _ endOfMemory - mem].		arg = 4		ifTrue: [result _ allocationCount].		arg = 5		ifTrue: [result _ allocationsBetweenGCs].		arg = 6		ifTrue: [result _ tenuringThreshold].		arg = 7		ifTrue: [result _ statFullGCs].		arg = 8		ifTrue: [result _ statFullGCMSecs].		arg = 9		ifTrue: [result _ statIncrGCs].		arg = 10		ifTrue: [result _ statIncrGCMSecs].		arg = 11		ifTrue: [result _ statTenures].		((arg >= 12) and: [arg <= 20]) ifTrue: [result _ 0].		arg = 21		ifTrue: [result _ rootTableCount].		arg = 22		ifTrue: [result _ statRootTableOverflows].		arg = 23		ifTrue: [result _ extraVMMemory].		arg = 24		ifTrue: [result _ shrinkThreshold].		arg = 25 	ifTrue: [result _ growHeadroom].		self pop: 2 thenPush: (self integerObjectOf: result).		^nil].	"write a VM parameter"	argumentCount = 2 ifFalse: [^self primitiveFail].	index _ self stackValue: 1.	(self isIntegerObject: index) ifFalse: [^self primitiveFail].	index _ self integerValueOf: index.	index <= 0 ifTrue: [^self primitiveFail].	successFlag _ false.	index = 5 ifTrue: [		result _ allocationsBetweenGCs.		allocationsBetweenGCs _ arg.		successFlag _ true].	index = 6 ifTrue: [		result _ tenuringThreshold.		tenuringThreshold _ arg.		successFlag _ true].	index = 23 ifTrue: [		result _ extraVMMemory.		extraVMMemory _ arg.		successFlag _ true].	index = 24 ifTrue: [		result _ shrinkThreshold.		arg > 0 ifTrue:[			shrinkThreshold _ arg.			successFlag _ true]].	index = 25 ifTrue: [		result _ growHeadroom.		arg > 0 ifTrue:[			growHeadroom _ arg.			successFlag _ true]].	successFlag ifTrue: [		self pop: 3 thenPush: (self integerObjectOf: result).  "return old value"		^ nil].	self primitiveFail.  "attempting to write a read-only parameter"! !!InterpreterSimulator methodsFor: 'memory access' stamp: 'ar 2/25/2001 16:36'!sqGrowObjectMemory: oldLimit By: delta	^oldLimit! !!InterpreterSimulator methodsFor: 'memory access' stamp: 'ar 2/25/2001 17:16'!sqMemoryExtraBytesLeft: includingSwap	^0! !!InterpreterSimulator methodsFor: 'memory access' stamp: 'ar 2/25/2001 16:36'!sqShrinkObjectMemory: oldLimit By: delta	^oldLimit! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ar 2/26/2001 00:08'!vmParameterAt: parameterIndex	"parameterIndex is a positive integer corresponding to one of the VM's internal	parameter/metric registers.  Answer with the current value of that register.	Fail if parameterIndex has no corresponding register.	VM parameters are numbered as follows:		1	end of old-space (0-based, read-only)		2	end of young-space (read-only)		3	end of memory (read-only)		4	allocationCount (read-only)		5	allocations between GCs (read-write)		6	survivor count tenuring threshold (read-write)		7	full GCs since startup (read-only)		8	total milliseconds in full GCs since startup (read-only)		9	incremental GCs since startup (read-only)		10	total milliseconds in incremental GCs since startup (read-only)		11	tenures of surving objects since startup (read-only)		12-20 specific to the translating VM		21	root table size (read-only)		22	root table overflows since startup (read-only)		23	bytes of extra memory to reserve for VM buffers, plugins, etc.		24	memory headroom when growing object memory (rw)		25	memory threshold above which shrinking object memory (rw)"	<primitive: 254>	self primitiveFailed! !Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows freeContexts freeLargeContexts interruptCheckCounter displayBits totalObjectCount shrinkThreshold growHeadroom '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize BlockContextProto CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassExternalAddress ClassExternalData ClassExternalFunction ClassExternalLibrary ClassExternalStructure ClassFloat ClassInteger ClassLargeNegativeInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClassMask CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero CtxtTempFrameStart DoAssertionChecks DoBalanceChecks Done ExternalObjectsArray FalseObject FloatProto GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextBit LargeContextSize MarkBit MethodContextProto NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotInterpret SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SizeMask SmallContextSize SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'VMConstruction-Interpreter'!