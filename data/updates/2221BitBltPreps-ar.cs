'From Squeak2.8alpha of 16 February 2000 [latest update: #2217] on 28 May 2000 at 1:05:44 pm'!"Change Set:		BitBltPreps-arDate:			28 May 2000Author:			Andreas RaabA preparation of BitBlt, ColorMap, and DisplayScreen for the next round of updates."!!BitBlt methodsFor: 'private' stamp: 'ar 5/26/2000 16:38'!getPluginName	"Private. Return the name of the plugin representing BitBlt.	Used for dynamically switching between different BB representations only."	^'BitBltPlugin'! !!BitBlt class methodsFor: 'instance creation' stamp: 'ar 5/28/2000 12:04'!asGrafPort	"Return the GrafPort associated with the receiver"	^GrafPort! !!BitBlt class methodsFor: 'instance creation' stamp: 'ar 5/28/2000 12:00'!current	"Return the class currently to be used for BitBlt"	^Display defaultBitBltClass! !!Canvas methodsFor: 'initialization' stamp: 'ar 5/27/2000 21:50'!finish	"If there are any pending operations on the receiver complete them. Do not return before all modifications have taken effect."	^self flush! !!ColorMap methodsFor: 'accessing' stamp: 'ar 5/27/2000 18:51'!inverseMap	"Return the inverse map of the receiver"	| newMasks newShifts |	colors ifNotNil:[^self error:'Not yet implemented'].	newMasks _ WriteStream on: (Array new: 4).	newShifts _ WriteStream on: (Array new: 4).	masks with: shifts do:[:mask :shift|		newMasks nextPut: (mask bitShift: shift).		newShifts nextPut: shift negated]! !!ColorMap methodsFor: 'accessing' stamp: 'ar 5/27/2000 19:16'!masks	^masks! !!ColorMap methodsFor: 'accessing' stamp: 'ar 5/27/2000 20:48'!rgbaBitMasks	"Return the rgba bit masks for the receiver"	^masks asArray with: shifts collect:[:m :s| m bitShift: s]! !!ColorMap methodsFor: 'accessing' stamp: 'ar 5/27/2000 19:16'!shifts	^shifts! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 5/27/2000 20:11'!mappingTo: aColorMap	"Compute a new color map through ARGB space. It is assumed that the receiver is mapping into canonical ARGB space and aColorMap from ARGB space."	| fixedMap |	fixedMap _ self class mappingFrom: masks to: aColorMap rgbaBitMasks.	self isIndexed ifTrue:[		"If the receiver is indexed then we need to map the colors as well"		^ColorMap			shifts: fixedMap shifts			masks: fixedMap masks			colors: (colors collect:[:pv| aColorMap mapPixel: pv])].	^fixedMap! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 5/27/2000 19:34'!mappingWith: aColorMap	"Compute a new color map through the receiver and aColorMap.	Both maps are assumed to be mappings into canonical ARGB space"	self = aColorMap ifTrue:[^nil]. "No mapping needed"	aColorMap isIndexed ifTrue:[^nil]. "We can't compute the inverse of an indexed map yet"	^self mappingTo: aColorMap inverseMap! !!ColorMap methodsFor: 'testing' stamp: 'ar 5/27/2000 19:06'!isFixed	"Return true if the receiver does not use a lookup mechanism for pixel mapping"	^self isIndexed not! !!ColorMap methodsFor: 'testing' stamp: 'ar 5/27/2000 19:06'!isIndexed	"Return true if the receiver uses a lookup mechanism for pixel mapping"	^colors notNil! !!ColorMap methodsFor: 'comparing' stamp: 'ar 5/27/2000 19:28'!= aColorMap	"Return true if the receiver is equal to aColorMap"	self species = aColorMap species ifFalse:[^false].	self isIndexed = aColorMap isIndexed ifFalse:[^false].	^self colors = aColorMap colors and:[		self shifts = aColorMap shifts and:[			self masks = aColorMap masks]]! !!ColorMap methodsFor: 'comparing' stamp: 'ar 5/27/2000 19:29'!hash	"Hash is re-implemented because #= is re-implemented"	^colors hash bitXor: (shifts hash bitXor: masks hash)! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 5/27/2000 20:09'!mapBitsFrom: srcBitMask to: dstBitMask	"Return an array consisting of the shift and the mask for	mapping component values out of srcBitMask and into dstBitMask.	While this computation is somewhat complicated it eases the batch	conversion of all the pixels in BitBlt."	| srcBits dstBits srcLow srcHigh dstLow dstHigh bits mask shift |	(srcBitMask = 0 or:[dstBitMask = 0]) ifTrue:[^#(0 0)]. "Zero mask and shift"	"Compute low and high bit position for source and dest bit mask"	srcLow _ srcBitMask lowBit - 1.	srcHigh _ srcBitMask highBit.	dstLow _ dstBitMask lowBit - 1.	dstHigh _ dstBitMask highBit.	"Compute the number of bits in source and dest bit mask"	srcBits _ srcHigh - srcLow.		dstBits _ dstHigh - dstLow.	"Compute the maximum number of bits we can transfer inbetween"	bits _ srcBits min: dstBits.	"Compute the (unshifted) transfer mask"	mask _ (1 bitShift: bits) - 1.	"Shift the transfer mask to the mask the highest n bits of srcBitMask"	mask _ mask bitShift: (srcHigh - bits).	"Compute the delta shift so that the most significant bit of the	source bit mask falls on the most significant bit of the dest bit mask.	Note that delta is used for #bitShift: so		shift > 0 : shift right		shift < 0 : shift left	e.g., if dstHigh > srcHigh we need to shift left and if dstHigh < srcHigh	we need to shift right. This leads to:"	shift _ dstHigh - srcHigh.	"And that's all we need"	^Array with: shift with: mask! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 5/27/2000 19:41'!mappingFrom: srcBitMasks to: dstBitMasks	"Return a color map mapping from the array of source bit masks	to the array of dest bit masks."	| shifts masks shiftAndMask |	shifts _ IntegerArray new: 4.	masks _ WordArray new: 4.	1 to: 4 do:[:i|		shiftAndMask _ self mapBitsFrom: (srcBitMasks at: i) to: (dstBitMasks at: i).		shifts at: i put: (shiftAndMask at: 1).		masks at: i put: (shiftAndMask at: 2).	].	^self shifts: shifts masks: masks! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 5/27/2000 20:08'!mappingFromARGB: dstBitMasks	"Return a ColorMap mapping from canonical ARGB space into dstBitMasks"	^self mappingFrom: #(16rFF0000 16rFF00 16rFF 16rFF000000) to: dstBitMasks! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 5/27/2000 20:08'!mappingToARGB: srcBitMasks	"Return a ColorMap mapping from srcBitMasks into canonical ARGB space"	^self mappingFrom: srcBitMasks to: #(16rFF0000 16rFF00 16rFF 16rFF000000)! !!FXBlt methodsFor: 'private' stamp: 'ar 5/26/2000 16:39'!getPluginName	"Private. Return the name of the plugin representing FXBlt.	Used for dynamically switching between different BB representations only."	^'FXBltPlugin'! !!FXBlt methodsFor: 'warping' stamp: 'ar 5/25/2000 22:05'!sourceForm: srcForm destRect: dstRectangle	"Set up a WarpBlt from the entire source Form to the given destination rectangle."	| w h |	sourceForm _ srcForm.	sourceX _ sourceY _ 0.	destX _ dstRectangle left.	destY _ dstRectangle top.	width _ dstRectangle width.	height _ dstRectangle height.	w _ srcForm width.	h _ srcForm height.	(w = width and:[h = height]) ifTrue:[		"Don't need no stinking warp"		warpQuad _ nil	] ifFalse:[		"Oh well ... "		w _ 16384 * (w - 1).		h _ 16384 * (h - 1).		warpQuad _ Array			with: 0@0 with: 0@h			with: w@h with: w@0.	].! !!FXBlt class methodsFor: 'instance creation' stamp: 'ar 5/28/2000 12:04'!asGrafPort	"Return the GrafPort associated with the receiver"	^FXGrafPort! !!FXGrafPort methodsFor: 'drawing support' stamp: 'ar 5/27/2000 22:00'!fillRect: rect offset: aPoint	"The offset is really just for stupid InfiniteForms."	| fc |	fillPattern class == InfiniteForm ifTrue:[		fc _ halftoneForm.		self fillColor: nil.		fillPattern displayOnPort: ((self clippedBy: rect) colorMap: nil) at: aPoint.		halftoneForm _ fc.		^self].	"Let's try it the fast way first"	(fillPattern isColor and:[destForm isFillAccelerated: combinationRule for: fillPattern])		ifTrue:[^destForm fill: (rect truncated intersect: self clipRect) 						rule: combinationRule fillColor: fillPattern].	destX _ rect left.	destY _ rect top.	sourceX _ 0.	sourceY _ 0.	width _ rect width.	height _ rect height.	self copyBits.! !!FXGrafPort methodsFor: 'drawing support' stamp: 'ar 5/28/2000 02:10'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	(sourceMap isNil and:[destMap isNil and:[colorMap isNil and:[fillPattern isNil]]]) ifTrue:[		"Let's try it the fast way if possible"		(sourceRect area > 1000 and:[destForm isBltAccelerated: rule for: aForm]) ifTrue:[			"Be agressive."			destForm allocateOrRecycleForm: aForm.			^destForm 				copyBits: sourceRect truncated				from: aForm 				at: aPoint asIntegerPoint				clippingBox: self clipRect truncated				rule: rule 				fillColor: fillPattern 				map: colorMap]].	sourceForm _ aForm.	combinationRule _ rule.	self sourceRect: sourceRect.	self destOrigin: aPoint.	self copyBits! !!FXGrafPort methodsFor: 'accessing' stamp: 'ar 5/28/2000 02:09'!contentsOfArea: aRectangle into: aForm	(aRectangle area > 1000 and:[destForm isBltAccelerated: Form over for: aForm]) ifTrue:[		"Be aggressive if the rectangle is large"		destForm allocateOrRecycleForm: aForm].	destForm 		displayOn: aForm 		at:  aRectangle origin		clippingBox: (0@0 extent: aRectangle extent).	^aForm! !!Form methodsFor: 'initialize-release' stamp: 'ar 5/26/2000 00:46'!finish	"If there are any pending operations on the receiver complete them. Do not return before all modifications have taken effect."! !!Form methodsFor: 'initialize-release' stamp: 'ar 5/26/2000 00:45'!flush	"If there are any pending operations on the receiver start doing them. In time, they will show up on the receiver but not necessarily immediately after this method returns."! !!Form methodsFor: 'accessing' stamp: 'ar 5/28/2000 12:03'!defaultCanvasClass	"Return the default canvas used for drawing onto the receiver"	^Display defaultCanvasClass! !!Form methodsFor: 'accessing' stamp: 'ar 5/27/2000 16:56'!displayScreen	"Return the display screen the receiver is allocated on. 	Forms in general are Squeak internal and not allocated on any particular display."	^nil! !!Form methodsFor: 'accessing' stamp: 'ar 5/28/2000 12:03'!getCanvas	"Return a Canvas that can be used to draw onto the receiver"	^self defaultCanvasClass on: self! !!Form methodsFor: 'accessing' stamp: 'ar 5/28/2000 00:48'!hasBeenModified	"Return true if something *might* have been drawn into the receiver"	^(bits == nil or:[bits class == ByteArray]) not	"Read the above as: If the receiver has forgotten its contents (bits == nil) 	or is still hibernated it can't be modified."! !!Form methodsFor: 'accessing' stamp: 'ar 5/28/2000 00:48'!hasBeenModified: aBool	"Change the receiver to reflect the modification state"	aBool ifTrue:[^self unhibernate].	self shouldPreserveContents		ifTrue:[self hibernate]		ifFalse:[bits _ nil]! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 5/28/2000 00:52'!unhibernate	"If my bitmap has been compressed into a ByteArray,	then expand it now, and return true."	bits == nil ifTrue:[bits _ Bitmap new: self bitsSize. ^true].	(bits isMemberOf: ByteArray)		ifTrue: [bits _ Bitmap decompressFromByteArray: bits. ^ true].	^ false! !!Form methodsFor: 'color mapping' stamp: 'ar 5/27/2000 18:17'!balancedPatternFor: aColor	"Return the pixel word for representing the given color on the receiver"	self isExternalForm		ifTrue:[^self bitPatternFor: aColor]		ifFalse:[^aColor balancedPatternForDepth: self depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/27/2000 18:17'!bitPatternFor: aColor	"Return the pixel word for representing the given color on the receiver"	self isExternalForm		ifTrue:[^self pixelWordFor: aColor]		ifFalse:[^aColor bitPatternForDepth: self depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/27/2000 20:12'!colormapFromARGB	"Return a ColorMap mapping from canonical ARGB space into the receiver.	Note: This version is optimized for Squeak forms."	| map nBits |	self isExternalForm ifTrue:[^ColorMap mappingFromARGB: self rgbaBitMasks].	self depth <= 8 ifTrue:[		map _ Color colorMapIfNeededFrom: 32 to: self depth.		map size = 512 ifTrue:[nBits _ 3].		map size = 4096 ifTrue:[nBits _ 4].		map size = 32768 ifTrue:[nBits _ 5].		^ColorMap			shifts: (Array 						with: 3 * nBits - 24						with: 2 * nBits - 16						with: 1 * nBits - 8						with: 0)			masks: (Array						with: (1 << nBits) - 1 << (24 - nBits)						with: (1 << nBits) - 1 << (16 - nBits)						with: (1 << nBits) - 1 << (8 - nBits)						with: 0)			colors: map].	self depth = 16 ifTrue:[		^ColorMap			shifts: #(-9 -6 -3 0)			masks: #(16rF80000 16rF800 16rF8 0)].	self depth = 32 ifTrue:[		^ColorMap			shifts: #(0 0 0 0)			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)].	self error:'Bad depth'! !!Form methodsFor: 'color mapping' stamp: 'ar 5/27/2000 20:13'!colormapIfNeededFor: destForm	"Return a ColorMap mapping from the receiver to destForm."	"Note: This is very magical for now - we really need to switch	to palettes here but as long as this isn't done we need something	that works."	| map nBits myBits |	(self isExternalForm or:[destForm isExternalForm]) ifTrue:[		^self colormapFromARGB mappingWith: destForm colormapFromARGB].	self depth = destForm depth ifTrue:[^nil]. "no conversion"	self depth <= 8 ifTrue:["Always map indexed"		^ColorMap			shifts: nil			masks: nil			colors: (Color colorMapIfNeededFrom: self depth to: destForm depth)].	(self depth = 16 and:[destForm depth = 32]) ifTrue:["Expand bits"		^ColorMap 			shifts: #( 9 6 3 0) 			masks: #(16r7C00 16r3E0 16r1F 0)].	(self depth = 32 and:[destForm depth = 16]) ifTrue:["Contract bits"		^ColorMap			shifts: #(-9 -6 -3 0)			masks: #(16rF80000 16rF800 16rF8 0)].	"destForm is indexed, I am non-indexed"	map _ Color colorMapIfNeededFrom: self depth to: destForm depth.	map size = 512 ifTrue:[nBits _ 3].	map size = 4096 ifTrue:[nBits _ 4].	map size = 32768 ifTrue:[nBits _ 5].	myBits _ depth == 16 ifTrue:[5] ifFalse:[8].	^ColorMap		shifts: {	(3 * nBits) - (3 * myBits).				(2 * nBits) - (2 * myBits).				(1 * nBits) - (1 * myBits).				0}		masks: {	(1 bitShift: nBits) - 1 bitShift: (3 * myBits - nBits).				(1 bitShift: nBits) - 1 bitShift: (2 * myBits - nBits).				(1 bitShift: nBits) - 1 bitShift: (1 * myBits - nBits).				0}		colors: map.! !!Form methodsFor: 'color mapping' stamp: 'ar 5/27/2000 20:14'!colormapToARGB	"Return a ColorMap mapping from the receiver into canonical ARGB space."	self isExternalForm ifTrue:[^self colormapFromARGB inverseMap].	self depth <= 8 ifTrue:[		^ColorMap			shifts: #(0 0 0 0)			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)			colors: (Color colorMapIfNeededFrom: self depth to: 32)].	self depth = 16 ifTrue:[		^ColorMap 			shifts: #( 9 6 3 0) 			masks: #(16r7C00 16r3E0 16r1F 0)].	self depth = 32 ifTrue:[		^ColorMap			shifts: #(0 0 0 0) 			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)].	self error:'Bad depth'! !!Form methodsFor: 'color mapping' stamp: 'ar 5/27/2000 18:18'!pixelValueFor: aColor	"Return the pixel word for representing the given color on the receiver"	self isExternalForm		ifTrue:[^self colormapFromARGB mapPixel: (aColor pixelValueForDepth: 32)]		ifFalse:[^aColor pixelValueForDepth: self depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/27/2000 18:18'!pixelWordFor: aColor	"Return the pixel word for representing the given color on the receiver"	| basicPattern |	self isExternalForm ifFalse:[^aColor pixelWordForDepth: self depth].	basicPattern _ self pixelValueFor: aColor.	self depth = 32 		ifTrue:[^basicPattern]		ifFalse:[^aColor pixelWordFor: self depth filledWith: basicPattern]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/27/2000 20:14'!rgbaBitMasks	"Return the masks for specifying the R,G,B, and A components in the receiver"	self depth <= 8		ifTrue:[^#(16rFF0000 16rFF00 16rFF 16rFF000000)].	self depth = 16		ifTrue:[^#(16r7C00 16r3E0 16r1F 16r0)].	self depth = 32		ifTrue:[^#(16rFF0000 16rFF00 16rFF 16rFF000000)].	self error:'Bad depth for form'! !!Form methodsFor: 'testing' stamp: 'ar 5/27/2000 16:54'!isExternalForm	^false! !!Form methodsFor: 'hardware acceleration' stamp: 'ar 5/27/2000 15:36'!isBltAccelerated: ruleInteger for: sourceForm	"Return true if the receiver can perform accelerated blts operations by itself"	^false! !!Form methodsFor: 'hardware acceleration' stamp: 'ar 5/27/2000 15:36'!isFillAccelerated: ruleInteger for: aColor	"Return true if the receiver can perform accelerated fill operations by itself"	^false! !!DisplayScreen methodsFor: 'private' stamp: 'ar 5/25/2000 23:43'!findAnyDisplayDepth	"Return any display depth that is supported on this system."	^self findAnyDisplayDepthIfNone:[		"Ugh .... now this is a biggie - a system that does not support		any of the Squeak display depths at all."		Smalltalk			logError:'Fatal error: This system has no support for any display depth at all.'			inContext: thisContext			to: 'SqueakDebug.log'.		Smalltalk quitPrimitive. "There is no way to continue from here"	].! !!DisplayScreen methodsFor: 'private' stamp: 'ar 5/25/2000 23:44'!findAnyDisplayDepthIfNone: aBlock	"Return any display depth that is supported on this system.	If there is none, evaluate aBlock."	#(1 2 4 8 16 32) do:[:bpp|		(self supportsDisplayDepth: bpp) ifTrue:[^bpp].	].	^aBlock value! !!DisplayScreen methodsFor: 'initialize-release' stamp: 'ar 5/26/2000 00:07'!release	"I am no longer Display. Release any resources if necessary"! !!DisplayScreen methodsFor: 'initialize-release' stamp: 'ar 5/28/2000 11:25'!shutDown 	"Minimize Display memory saved in image"	self setExtent: 240@120 depth: depth! !!DisplayScreen methodsFor: 'testing' stamp: 'ar 5/25/2000 23:34'!isB3DDisplayScreen	^false! !!DisplayScreen methodsFor: 'testing' stamp: 'ar 5/25/2000 23:34'!isDisplayScreen	^true! !!DisplayScreen methodsFor: 'blitter defaults' stamp: 'ar 5/28/2000 12:01'!defaultBitBltClass	"Return the BitBlt version to use when I am active"	^BitBlt! !!DisplayScreen methodsFor: 'blitter defaults' stamp: 'ar 5/28/2000 12:02'!defaultCanvasClass	"Return the WarpBlt version to use when I am active"	^FormCanvas! !!DisplayScreen methodsFor: 'blitter defaults' stamp: 'ar 5/28/2000 12:01'!defaultWarpBltClass	"Return the WarpBlt version to use when I am active"	^WarpBlt! !!DisplayScreen class methodsFor: 'snapshots' stamp: 'ar 5/28/2000 11:26'!shutDown 	"Minimize Display memory saved in image"	Display shutDown.! !!FormCanvas methodsFor: 'initialize-release' stamp: 'ar 5/27/2000 21:51'!finish	"If there are any pending operations on the receiver complete them. Do not return before all modifications have taken effect."	form finish! !!FXFormCanvas methodsFor: 'private' stamp: 'ar 5/27/2000 21:46'!setFillColor: aColor	"Install a new color used for filling."	| fillColor screen patternWord |	port sourceMap: nil; destMap: nil; colorMap: nil.	port sourceKey: nil.	fillColor _ self shadowColor ifNil:[aColor].	fillColor ifNil:[fillColor _ Color transparent].	fillColor isColor ifFalse:[		(aColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: aColor; combinationRule: Form over].	"Okay, so fillColor really *is* a color"	port sourceForm: nil.	fillColor isTranslucent ifFalse:[		port combinationRule: Form over.		port fillPattern: fillColor.		self depth = 8 ifTrue:[			"In 8 bit depth it's usually a good idea to use a stipple pattern"			port fillColor: (fillColor balancedPatternForDepth: 8)].		^self].	"fillColor is some translucent color"	self depth >= 8 ifTrue:[		"We can represent actual transparency"		port fillColor: (fillColor bitPatternForDepth: 32).		port destMap: form colormapToARGB.		port colorMap: form colormapFromARGB.		^port combinationRule: Form blend].	"Less than 8bit depth -- use stipple pattern"	screen _ Color translucentMaskFor: fillColor alpha depth: self depth.	patternWord _ fillColor pixelWordForDepth: self depth.	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).	port combinationRule: Form paint.! !!FXFormCanvas methodsFor: 'accessing' stamp: 'ar 5/28/2000 01:31'!contentsOfArea: aRectangle into: aForm	self flush.	port contentsOfArea: ((aRectangle origin + origin) negated extent: aRectangle extent)		into: aForm.	^aForm! !!HandMorph methodsFor: 'drawing' stamp: 'ar 5/28/2000 01:27'!savePatchFrom: aCanvas	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."	| damageRect myBnds |	damageRect _ myBnds _ self fullBounds.	savedPatch ifNotNil: [		damageRect _ myBnds merge: (savedPatch offset extent: savedPatch extent)].	(savedPatch == nil or: [savedPatch extent ~= myBnds extent])		ifTrue: [  "allocate new patch form if needed"			savedPatch _ Form extent: myBnds extent depth: aCanvas form depth].	aCanvas		contentsOfArea: (myBnds translateBy: aCanvas origin)		into: savedPatch.	savedPatch offset: myBnds topLeft.	^ damageRect! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 5/27/2000 21:51'!displayWorld	"Update this world's display."	| deferredUpdateMode updateNeeded worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	updateNeeded _ self damageRecorder updateIsNeeded.	updateNeeded ifFalse: [		self handsDo: [:h |			(h hasChanged and: [h needsToBeDrawn])				ifTrue: [updateNeeded _ true]]].	updateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdating.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawInvalidAreasOn: self canvas.  "repair world's damage on canvas"	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: self canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | h fullDrawOn: self canvas].  "draw hands onto world canvas"	false ifTrue: [  "*make this true to flash damaged areas for testing*"		self flashRects: allDamage color: Color black].	self canvas finish.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [allDamage do: [:r | Display forceToScreen: (r "translateBy: self viewBox origin")]]		ifFalse: [self canvas showAt: self viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: self canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!Project methodsFor: 'initialization' stamp: 'ar 5/27/2000 00:34'!installNewDisplay: extent depth: depth	"When entering a new project, install a new Display if necessary."	| params newDisplay oldDisplay |	params _ self rawParameters.	(params notNil and:[(self parameterAt: #enable3DAcceleration) == true]) ifTrue:[		Display isB3DDisplayScreen 			ifTrue:[^Display setExtent: extent depth: depth].		"Install a B3DDisplayScreen for future hardware acceleration"		newDisplay _ (Smalltalk at: #B3DDisplayScreen ifAbsent:[^self])					extent: extent depth: depth.	] ifFalse:[		"Otherwise check if the current Display is a DisplayScreen"		Display isB3DDisplayScreen			ifFalse:[^Display setExtent: extent depth: depth].				"Install a DisplayScreen for future hardware acceleration"		newDisplay _ (Smalltalk at: #DisplayScreen ifAbsent:[^self])					extent: extent depth: depth.	].	"Copy old contents of display to the (yet to be installed) newDisplay"	(FXBlt toForm: newDisplay) sourceForm: Display; combinationRule: 3; copyBits.	"And make it Display"	oldDisplay _ Display.	Display _ newDisplay.	Display beDisplay.	oldDisplay release.! !!Project methodsFor: 'menu messages' stamp: 'ar 5/25/2000 23:37'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg |	self == CurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [CurrentProject makeThumbnail].	(revertFlag | saveForRevert | forceRevert) ifFalse: [		(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [			self storeToMakeRoom]].	Smalltalk isMorphic ifTrue: [World triggerClosingScripts].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 					playerClass allSubInstancesDo: [:player | player pause]]].	returningFlag		ifTrue: [nextProject _ CurrentProject]		ifFalse: [previousProject _ CurrentProject].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil _ World pauseEventRecorder].	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: World].			world triggerOpeningScripts]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph		ifTrue:			[self spawnNewProcessAndTerminateOld: true]		ifFalse:			[showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController]! !!Project methodsFor: 'project parameters' stamp: 'ar 5/25/2000 23:23'!parameterAt: aSymbol	^self parameterAt: aSymbol ifAbsent:[nil]! !!Project methodsFor: 'project parameters' stamp: 'ar 5/25/2000 23:23'!parameterAt: aSymbol ifAbsent: aBlock	projectParameters ifNil:[^aBlock value].	^projectParameters at: aSymbol ifAbsent: aBlock! !!WarpBlt class methodsFor: 'instance creation' stamp: 'ar 5/28/2000 12:00'!current	"Return the class currently to be used for WarpBlt"	^Display defaultWarpBltClass! !