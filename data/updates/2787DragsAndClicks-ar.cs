'From Squeak2.9alpha of 13 June 2000 [latest update: #2825] on 7 October 2000 at 11:16:45 pm'!"Change Set:		DragsAndClicks-arDate:			7 October 2000Author:			Andreas RaabThis change set fixes a deeply buried confusion in #click: vs. #mouseDown: handling. When the event handler was extended to include the #doubleClick: and #startDrag handler the #click: handler was aliased to the #mouseDown: handler, thus completely messing up the notion of #click: being independent from #mouseDown: and only sent in response to some morph actually waiting for clicks.While seemingly harmless, the use of #mouseDown instead of an extra #click selector leads to the effect that #click / #drag / #doubleClick: mechanics needed to send #click *whenever* a drag was invoked (all current clients *did* handle both, #mouseDown and #startDrag so #click was essential for restoring accurate behavior). This in turn makes it impossible to distinguish between a drag and a click gesture. While the existing users (such as PluggableLists) did not rely on the explicit distinction between #click: and #drag: (the lists really want to get #mouseDown and are in no way interested in #click:) some of the new mechanics for halos *do* rely on a distinction between a click and a drag (a click being interpreted as transfering the halo and a drag being interpreted as dragging the current halo owner).The good news is that because the current users really want #mouseDown and not #click everything will work just fine."!Object subclass: #EventHandler	instanceVariableNames: 'mouseDownRecipient mouseDownSelector mouseStillDownRecipient mouseStillDownSelector mouseUpRecipient mouseUpSelector mouseEnterRecipient mouseEnterSelector mouseLeaveRecipient mouseLeaveSelector mouseEnterDraggingRecipient mouseEnterDraggingSelector mouseLeaveDraggingRecipient mouseLeaveDraggingSelector keyStrokeRecipient keyStrokeSelector valueParameter startDragRecipient startDragSelector doubleClickSelector doubleClickRecipient clickSelector clickRecipient '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!!EventHandler methodsFor: 'initialization' stamp: 'ar 10/7/2000 22:50'!adaptToWorld: aWorld	"If any of my recipients refer to a world or a hand, make them now refer	to the corresponding items in the new world.  (instVarNamed: is slow, later	use perform of two selectors.)"	| value newValue |	#(mouseDownRecipient mouseStillDownRecipient mouseUpRecipient	mouseEnterRecipient mouseLeaveRecipient mouseEnterDraggingRecipient	mouseLeaveDraggingRecipient clickRecipient doubleClickRecipient startDragRecipient keyStrokeRecipient valueParameter) do:		[:aName |		(value _ self instVarNamed: aName asString) ifNotNil:			[newValue _ nil.			value isMorph				ifTrue:					[value isWorldMorph ifTrue: [newValue _ aWorld].					value isHandMorph ifTrue: [newValue _ aWorld primaryHand]]				ifFalse: [(value isKindOf: Presenter) ifTrue: [newValue _ aWorld presenter]].			(newValue notNil and: [newValue ~~ value])				ifTrue:					[self instVarNamed: aName asString put: newValue]]]! !!EventHandler methodsFor: 'initialization' stamp: 'ar 10/7/2000 22:49'!forgetDispatchesTo: aSelector	"aSelector is no longer implemented by my corresponding Player, so don't call it any more"	mouseDownSelector == aSelector		ifTrue: [mouseDownRecipient _ mouseDownSelector _ nil].	mouseStillDownSelector == aSelector		ifTrue: [mouseStillDownRecipient _ mouseStillDownSelector _ nil].	mouseUpSelector == aSelector		ifTrue: [mouseUpRecipient _ mouseUpSelector _ nil].	mouseEnterSelector == aSelector		ifTrue: [mouseEnterRecipient _ mouseEnterSelector _ nil].	mouseLeaveSelector == aSelector		ifTrue: [mouseLeaveRecipient _ mouseLeaveSelector _ nil].	mouseEnterDraggingSelector == aSelector		ifTrue: [mouseEnterDraggingRecipient _ mouseEnterDraggingSelector _ nil].	mouseLeaveDraggingSelector == aSelector		ifTrue: [mouseLeaveDraggingRecipient _ mouseLeaveDraggingSelector _ nil].	clickSelector == aSelector		ifTrue: [clickRecipient _ clickSelector _ nil].	doubleClickSelector == aSelector		ifTrue: [doubleClickRecipient _ doubleClickSelector _ nil].	keyStrokeSelector == aSelector		ifTrue: [keyStrokeRecipient _ keyStrokeSelector _ nil].! !!EventHandler methodsFor: 'initialization' stamp: 'ar 10/7/2000 22:49'!on: eventName send: selector to: recipient	eventName = #mouseDown ifTrue:		[mouseDownRecipient _ recipient.  mouseDownSelector _ selector. ^ self].	eventName = #mouseStillDown ifTrue:		[mouseStillDownRecipient _ recipient.  mouseStillDownSelector _ selector. ^ self].	eventName = #mouseUp ifTrue:		[mouseUpRecipient _ recipient.  mouseUpSelector _ selector. ^ self].	eventName = #mouseEnter ifTrue:		[mouseEnterRecipient _ recipient.  mouseEnterSelector _ selector. ^ self].	eventName = #mouseLeave ifTrue:		[mouseLeaveRecipient _ recipient.  mouseLeaveSelector _ selector. ^ self].	eventName = #mouseEnterDragging ifTrue:		[mouseEnterDraggingRecipient _ recipient.  mouseEnterDraggingSelector _ selector. ^ self].	eventName = #mouseLeaveDragging ifTrue:		[mouseLeaveDraggingRecipient _ recipient.  mouseLeaveDraggingSelector _ selector. ^ self].	eventName = #click ifTrue:		[clickRecipient _ recipient. clickSelector _ selector. ^ self].	eventName = #doubleClick ifTrue:		[doubleClickRecipient _ recipient. doubleClickSelector _ selector. ^ self].	eventName = #startDrag ifTrue:		[startDragRecipient _ recipient. startDragSelector _ selector. ^ self].	eventName = #keyStroke ifTrue:		[keyStrokeRecipient _ recipient.  keyStrokeSelector _ selector. ^ self].	self error: 'Event name, ' , eventName , ' is not recognizable.'! !!EventHandler methodsFor: 'testing' stamp: 'ar 10/7/2000 22:56'!handlesClickOrDrag: evt	clickRecipient ifNotNil:[^true].	doubleClickRecipient ifNotNil:[^true].	startDragRecipient ifNotNil:[^true].	^false! !!EventHandler methodsFor: 'testing' stamp: 'ar 10/7/2000 22:56'!handlesMouseDown: evt	mouseDownRecipient ifNotNil: [^ true].	mouseStillDownRecipient ifNotNil: [^ true].	mouseUpRecipient ifNotNil: [^ true].	(self handlesClickOrDrag: evt) ifTrue:[^true].	^ false! !!EventHandler methodsFor: 'events' stamp: 'ar 10/7/2000 22:55'!click: event fromMorph: sourceMorph 	"This message is sent only when double clicks are handled."	^ self		send: clickSelector		to: clickRecipient		withEvent: event		fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'ar 10/7/2000 22:54'!mouseDown: event fromMorph: sourceMorph 	"Take double-clicks into account."	((self handlesClickOrDrag: event) and:[event redButtonPressed]) ifTrue:[		event hand waitForClicksOrDrag: sourceMorph event: event.	].	^self		send: mouseDownSelector		to: mouseDownRecipient		withEvent: event		fromMorph: sourceMorph.! !!EventHandler methodsFor: 'object fileIn' stamp: 'ar 10/7/2000 23:12'!convertmmmmmmmmmmmmmmkkvssdd0: varDict mmmmmmmmmmmmmmkkvssddcc0: smartRefStrm	"These variables are automatically stored into the new instance #('mouseDownRecipient' 'mouseDownSelector' 'mouseStillDownRecipient' 'mouseStillDownSelector' 'mouseUpRecipient' 'mouseUpSelector' 'mouseEnterRecipient' 'mouseEnterSelector' 'mouseLeaveRecipient' 'mouseLeaveSelector' 'mouseEnterDraggingRecipient' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingRecipient' 'mouseLeaveDraggingSelector' 'keyStrokeRecipient' 'keyStrokeSelector' 'valueParameter' 'startDragRecipient' 'startDragSelector' 'doubleClickSelector' 'doubleClickRecipient').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('clickSelector' 'clickRecipient')  If a non-nil value is needed, please assign it."! !!MouseClickState methodsFor: 'event handling' stamp: 'ar 10/7/2000 23:00'!handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| localEvt timedOut isDrag |	timedOut _ (evt timeStamp - firstClickTime) > dblClickTime.	localEvt _ evt transformedBy: (clickClient transformedFrom: aHand owner).	isDrag _ (localEvt cursorPoint - firstClickDown cursorPoint) r > dragThreshold.	clickState == #firstClickDown ifTrue: [		"Careful here - if we had a slow cycle we may have a timedOut mouseUp event"		(timedOut and:[localEvt isMouseUp not]) ifTrue:[			"timeout before #mouseUp -> keep waiting for drag"			clickState _ #firstClickTimedOut.			^true].		localEvt isMouseUp ifTrue:[			"If timedOut or the client's not interested in dbl clicks get outta here"			(timedOut or:[dblClickSelector isNil]) ifTrue:[				aHand resetClickState.				clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].				^true].			"Otherwise transfer to #firstClickUp"			firstClickUp _ localEvt.			clickState _ #firstClickUp.			^false].		isDrag ifTrue:["drag start"			aHand resetClickState.			dragSelector ifNotNil:[clickClient perform: dragSelector with: localEvt].			^true].		^false].	clickState == #firstClickTimedOut ifTrue:[		localEvt isMouseUp ifTrue:["neither drag nor double click"			aHand resetClickState.			clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].			^true].		isDrag ifTrue:["drag start"			aHand resetClickState.			dragSelector ifNotNil:[clickClient perform: dragSelector with: localEvt].			^true].		^false].	clickState = #firstClickUp ifTrue:[		(timedOut) ifTrue:[			"timed out after mouseUp - send #click: and mouseUp"			clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].			aHand resetClickState.			clickClient handleMouseUp: firstClickUp.			^true].		localEvt isMouseDown ifTrue:["double click"			aHand resetClickState.			dblClickSelector ifNotNil:[clickClient perform: dblClickSelector with: firstClickDown].			^false]].	^true! !EventHandler removeSelector: #handlesClick:!EventHandler removeSelector: #handlesDoubleClick:!EventHandler removeSelector: #handlesStartDrag:!