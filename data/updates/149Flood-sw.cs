'From Squeak 2.1 of June 30, 1998 on 6 July 1998 at 11:33:23 pm'!"Change Set:		Flood-swDate:			6 July 1998Author:			Scott Wallace<NOTE: This update includes a patched-in warning regarding the number of updates to follow - DI>A flood of various enhancements and fixes.  Includes John's WebBookMorph code, a new TabbedPalette with numerous new features, various enhancements to PasteUpMorph, and much else.  See separate memo for list"!(self confirm: 'WARNING: This is the first of almost 80 update files for Squeak 2.1.Unless your are maintaining an independent fork of Squeak, it wouldprobably be much simpler to move to verison 2.2 of Squeak.Choose YES only if you wish to proceed with the update process.Otherwise choose NO and close the notifier to abort the update process.')	ifFalse: [self halt]!Object subclass: #EToyHolder	instanceVariableNames: 'title scaffoldingBook playfield notInPlayfield eToyPalette '	classVariableNames: 'UserStuffBook '	poolDictionaries: ''	category: 'Experimental-EToy'!SketchMorph subclass: #BookPageThumbnailMorph	instanceVariableNames: 'page '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Books'!AlignmentMorph subclass: #BookPageSorterMorph	instanceVariableNames: 'book pageHolder '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Books'!AlignmentMorph subclass: #BooklikeMorph	instanceVariableNames: 'pageSize newPagePrototype '	classVariableNames: 'PageFlipSoundOn '	poolDictionaries: ''	category: 'Morphic-Books'!BooklikeMorph subclass: #BookMorph	instanceVariableNames: 'pages currentPage '	classVariableNames: 'PageFlipSoundOn '	poolDictionaries: ''	category: 'Morphic-Books'!SketchMorph subclass: #MorphThumbnail	instanceVariableNames: 'morphRepresented '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Books'!PasteUpMorph subclass: #IndexTabs	instanceVariableNames: 'highlightColor regularColor basicHeight '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Palettes'!Object subclass: #Presenter	instanceVariableNames: 'associatedMorph stopButton stepButton goButton balloonHelpEnabled mouseOverHalosEnabled soundsEnabled fenceEnabled coloredTilesEnabled viewerCache standardPlayer standardPlayfield standardPalette standardHolder playerList borderColorWhenRunning borderColorWhenStopped '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!Object subclass: #SqueakPage	instanceVariableNames: 'url title comment thumbnail contentsMorph creationTime creationAuthor lastChangeTime lastChangeAuthor '	classVariableNames: 'MaxThumbnailWidthOrHeight '	poolDictionaries: ''	category: 'Morphic-WebBooks'!Object subclass: #SqueakPageCache	instanceVariableNames: ''	classVariableNames: 'NextURL PageCache '	poolDictionaries: ''	category: 'Morphic-WebBooks'!StringButtonMorph subclass: #TabMorph	instanceVariableNames: 'morphToInstall '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Palettes'!BookPageSorterMorph subclass: #TabSorterMorph	instanceVariableNames: 'originalTabs '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Palettes'!StringMorph subclass: #TabTokenMorph	instanceVariableNames: 'tabRepresented '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Palettes'!BookMorph subclass: #TabbedPalette	instanceVariableNames: 'tabsMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Palettes'!AlignmentMorph subclass: #TabsMorph	instanceVariableNames: 'buttonOnColor buttonOffColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Experimental-EToy-Support'!RectangleMorph subclass: #ThumbnailMorph	instanceVariableNames: 'objectToView viewSelector lastSketchForm lastFormShown '	classVariableNames: 'RecursionDepth RecursionMax '	poolDictionaries: ''	category: 'Morphic-Widgets'!Morph subclass: #URLMorph	instanceVariableNames: 'url page isBookmark book '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-WebBooks'!BookMorph subclass: #ViewerBook	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!BooklikeMorph subclass: #WebBookMorph	instanceVariableNames: 'urls currentURL currentContents originalContents currentContentsChanged '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-WebBooks'!!BooklikeMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/4/1998 15:59'!initialize	"BooklikeMorph initialize"	PageFlipSoundOn _ true! !!BooklikeMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/4/1998 16:43'!turnOffSoundWhile: aBlock	"Turn off page flip sound during the given block."	| old |	old _ PageFlipSoundOn.	PageFlipSoundOn _ false.	aBlock value.	PageFlipSoundOn _ old! !!BookMorph class methodsFor: 'all' stamp: 'sw 7/4/1998 15:58'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book _ self new markAsPartsDonor.	book removeEverything; pageSize: 128@102; color: (Color gray: 0.9).	book borderWidth: 1; borderColor: Color black.	book beSticky.	book showPageControls; insertPage.	^ book! !!EToyHolder methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:43'!initialize	"Initialize this EToyHolder for a new, empty EToy."	title _ self defaultTitle.	playfield _ PasteUpMorph new.	playfield borderWidth: 4; borderColor: Color green.	playfield beSticky.	playfield setNameTo: 'playfield'.	playfield color: Color transparent.	playfield changed.	BooklikeMorph turnOffSoundWhile:		[scaffoldingBook _ TabbedPalette new setNameTo: 'Scaffolding'.		self initializeScaffoldingContentsForFreshEToy].! !!EToyHolder methodsFor: 'scaffolding' stamp: 'sw 7/4/1998 16:24'!initializeScaffoldingContentsForFreshEToy	"This is done for a fresh e-toy, not for one being loaded from disk"	self scaffoldingTabInfo doWithIndex:		[:quad :index |			scaffoldingBook addTabNamed: quad first color: (Color perform: quad second) muchLighter				atIndex: index.			self setInitialContentForScaffoldingTabNamed: quad first fromSelector: quad third].	EToyParameters fullEToyGraphics ifTrue: [self addDemoContentsToMailTab].	self addDemoContentsToSqueakTab.	EToyParameters fullEToyGraphics ifTrue: [self addDemoContentsToImagineersTab].	scaffoldingBook fullBounds.! !!EToyHolder methodsFor: 'scaffolding' stamp: 'sw 7/4/1998 16:23'!scaffoldingTabInfo	"Answer an array of quadruplets, with each quadruplet telling:		(1)	The tab title (with trailing blanks as needed for for spacing) 		(2)  The dominant color for the tab and its pages         (3)  The selector to call to get default contents from the EToyHolder	Individual EToyHolder subclasses can change this list		(4)  If #storeOnFile, then the contents should go out on the save file			If #dontStoreOnFile, then the contents are NOT stored on the save file, but				are instead supplied by the EToyHolder after the save-file is loaded"	^ #(  		('Toy'		blue		scaffoldingToyStrings		storeOnFile)		('Mail' 		brown		scaffoldingMailStrings		dontStoreOnFile)		('Squeak'	cyan		scaffoldingSqueakStrings	dontStoreOnFile)		('Imagis'	magenta	scaffoldingImagineersStrings dontStoreOnFile))! !!EToyHolder methodsFor: 'scaffolding' stamp: 'sw 7/4/1998 16:36'!setInitialContentForScaffoldingTabNamed: aName fromSelector: stringsSelector	| aBook |	(aBook _ scaffoldingBook  pageNamed: aName withBlanksTrimmed) ifNotNil:		[aBook removeEverything; showPageControls.		(self perform: stringsSelector) do:			[:str | aBook insertPageShowingString: str fontName: 'ComicPlain' fontSize:  16].		aBook firstPage]! !!EToyHolder methodsFor: 'demo stuff' stamp: 'sw 7/4/1998 16:15'!addDemoContentsToImagineersTab	| book pic page s |	book _ scaffoldingBook pageNamed: 'Imagis'.	book ifNil: [book _ scaffoldingBook pageNamed: 'Painting'].	book ifNotNil: [		book removeEverything; showPageControls.		s _ self scaffoldingImagineersStrings first.		book insertPageShowingString: s fontName: 'ComicPlain' fontSize: 16.		book insertPage.		pic _ SketchMorph new form: (ScriptingSystem formAtKey: 'CollagePic'); scalePoint: 0.7@0.7.		page _ book currentPage.		page extent: pic extent.		book currentPage addMorph: (pic position: page topLeft).		book firstPage].! !!EToyHolder methodsFor: 'demo stuff' stamp: 'sw 7/4/1998 16:36'!addDemoContentsToSqueakTab	| book s |	book _ scaffoldingBook pageNamed: 'Squeak'.	book ifNil: [book _ scaffoldingBook pageNamed: 'Help'].	book ifNotNil: [		book removeEverything; showPageControls.		s _ self scaffoldingSqueakStrings first.		book insertPageShowingString: s fontName: 'ComicPlain' fontSize: 16.		book firstPage].! !!EToyPlayer class methodsFor: 'instance creation' stamp: 'sw 7/4/1998 16:43'!openFromSaveFileOn: anEToyHolder	"Like openOn, but first fleshes out the scaffolding that needs to come from the image rather than from the save-file"	BooklikeMorph turnOffSoundWhile:		[anEToyHolder initializeScaffoldingContentsForReloadedEToy].	^ self openOn: anEToyHolder! !!Morph methodsFor: 'accessing' stamp: 'sw 7/6/1998 11:47'!balloonHelpTextForHandle: aHandle	|  itsSelector |	itsSelector _ aHandle eventHandler firstMouseSelector.	#(	(startRot:with:				'Rotate')		(startGrow:with:				'Change size') 		(doDup:with:				'Duplicate')		(maybeDoDup:with:			'Duplicate')		(doGrab:with:				'Pick up')		(startDrag:with:				'Move')		(doMenu:with:				'Menu')		(mouseDownOnHelpHandle:	'Help')		(tearOffTile					'Make a Tile')		(paintBackground			'Paint background')		(openViewerForArgument	'View me')		(dismiss						'Remove')		(editDrawing				'Repaint')		(startScale:with:				'Change scale') 		(chooseFont					'Change font')		(chooseStyle					'Change style')		(chooseEmphasis				'Change emphasis')		(makeNewDrawingWithin	'Paint new object'))  "This last one not currently in use"	do:		[:pair | itsSelector == pair first ifTrue: [^ pair last]].	^ 'unknown halo handle'! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 6/17/1998 16:04'!addMorphNearBack: aMorph	| bg |	(submorphs size > 0 and: [submorphs last mustBeBackmost]) ifTrue:		[bg _ submorphs last.		bg privateDelete].	self addMorphBack: aMorph.	bg ifNotNil: [self addMorphBack: bg]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 7/3/1998 11:02'!deleteSubmorphsWithProperty: aSymbol	submorphs copy do:		[:m | (m hasProperty: aSymbol) ifTrue: [m delete]]! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:30'!bottomLeft: aPoint	self bottom: aPoint y.	self left: aPoint x! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:08'!bottomRight: aPoint	self bottom: aPoint y.	self right: aPoint x! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:30'!topLeft: aPoint	self top: aPoint y.	self left: aPoint x! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:29'!topRight: aPoint	self top: aPoint y.	self right: aPoint x! !!Morph methodsFor: 'menu' stamp: 'sw 7/6/1998 21:52'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	costumee ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	aMenu addLine.	aMenu add: 'open viewer' action: #openViewerForArgument.	(self isKindOf: MorphThumbnail) ifFalse:		[aMenu add: 'make alias' action: #makeAliasForArgument].	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	((self isKindOf: SketchMorph) and: [GIFImports size > 0]) ifTrue:		[aMenu add: 'use imported graphic...' action: #chooseNewFormForSketchMorph].	self colorSettable ifTrue:		[aMenu add: 'change color...' action: #changeColor].	(aHandMorph argument pasteUpMorph morphsAt: aHandMorph menuTargetOffset) size > 2 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	"aMenu add: 'make mouse-sensitive' action: #makeMouseSensitive."	(owner == nil or: [self == owner submorphs last]) ifFalse:		[aMenu add: 'send to back' action: #goBehind]! !!Morph methodsFor: 'menu' stamp: 'sw 6/17/1998 14:14'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."	aCustomMenu add: 'add drop-shadow' action: #addDropShadow.	self isSticky		ifTrue:			[aCustomMenu add: 'stop being sticky' action: #toggleStickiness]		ifFalse:			[aCustomMenu add: 'start being sticky' action: #toggleStickiness].	aCustomMenu add: 'adhere to edge...' action: #adhereToEdge! !!Morph methodsFor: 'menu' stamp: 'sw 6/17/1998 14:32'!adhereToEdge	| menu |	menu _ MenuMorph new defaultTarget: self.	#(top right bottom left topLeft topRight bottomRight bottomLeft none) do:		[:anEdge |			menu add: anEdge asString selector: #setToAdhereToEdge: argument: anEdge.			((anEdge == #left) | (anEdge == #bottomLeft))				ifTrue:					[menu addLine]].	menu popUpAt: self position forHand: self primaryHand! !!Morph methodsFor: 'menu' stamp: 'sw 6/25/1998 10:57'!adhereToEdge: edgeSymbol	owner isHandMorph ifTrue: [^ self].	self perform: (edgeSymbol, ':') asSymbol withArguments: (Array with: (owner bounds perform: edgeSymbol))! !!Morph methodsFor: 'menu' stamp: 'sw 6/17/1998 14:25'!setToAdhereToEdge: anEdge	anEdge ifNil: [^ self].	anEdge == #none ifTrue: [^ self removeProperty: #edgeToAdhereTo].	self setProperty: #edgeToAdhereTo toValue: anEdge.	self layoutChanged! !!Morph methodsFor: 'change reporting' stamp: 'sw 6/17/1998 15:29'!ownerChanged	"The receiver's owner, some kind of a pasteup, has changed its layout."	| edgeSymbol |	(edgeSymbol _ self valueOfProperty: #edgeToAdhereTo) ifNotNil:		[self adhereToEdge: edgeSymbol]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/1/1998 18:01'!referencePlayfield	| former |	owner isPlayfieldLike ifTrue: [^ owner].	((owner isKindOf: HandMorph) and: [(former _ owner formerOwner) ~~ nil])		ifTrue:			[^ former isPlayfieldLike 				ifTrue:					[former]				ifFalse:					[former referencePlayfield]].	self isInWorld ifFalse: [^ nil].	^ self world submorphNamed: 'playfield'! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 6/30/1998 08:21'!aboutToBeGrabbedBy: aHand	| extentToHandToHand |	(extentToHandToHand _ self valueOfProperty: #expandedExtent)			ifNotNil:				[self removeProperty: #expandedExtent.				self extent: extentToHandToHand]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 7/2/1998 13:47'!highlightColor		| val |	^ (val _ self valueOfProperty: #highlightColor)		ifNotNil:			[val]		ifNil:			[owner highlightColor]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 7/2/1998 13:51'!highlightColor: aColor	self setProperty: #highlightColor toValue: aColor! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 7/2/1998 13:48'!regularColor		| val |	^ (val _ self valueOfProperty: #regularColor)		ifNotNil:			[val]		ifNil:			[owner regularColor]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 7/2/1998 13:51'!regularColor: aColor	self setProperty: #regularColor toValue: aColor! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 6/30/1998 17:02'!rootForGrabOf: aMorph	^ (self isSticky and: [self isPartsDonor not])		ifTrue:			[nil]		ifFalse:			[(owner = nil or: [owner isWorldOrHandMorph])				ifTrue:					[self]				ifFalse:					[owner allowSubmorphExtraction						ifTrue: [self]						ifFalse: [owner rootForGrabOf: aMorph]]]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 7/3/1998 12:34'!slideBackToFormerSituation: evt	| aForm formerOwner formerPosition aWorld origin startPoint endPoint |	aForm _ self imageForm offset: 0@0.	formerOwner _ evt hand formerOwner.	formerPosition _ evt hand formerPosition.	aWorld _ self world.	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	endPoint _ formerPosition + origin.	owner privateRemoveMorph: self.	aWorld displayWorld.	aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.	formerOwner addMorph: self.	self position: formerPosition.	self justDroppedInto: formerOwner event: evt.! !!Morph methodsFor: 'properties' stamp: 'sw 7/6/1998 14:38'!valueOfProperty: propName ifAbsent: aBlock	properties ifNil: [^ aBlock value].	^ properties at: propName ifAbsent: [aBlock value]! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 7/6/1998 17:48'!assuredCostumee	"Answer the receiver's costumee, a Player,, creating a new one if none currently exists"	costumee ifNil:		[self externalName.  "a default may be given if not named yet"		costumee _ self newPlayerInstance.  "Different morphs may demand different player types"		costumee costume: self.		self presenter ifNotNil: [self presenter flushPlayerListCache]].	^ costumee! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 6/25/1998 08:32'!slotNamesAndTypesForBank: aNumber	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts.  This remains somewhat awkward -- color is normally there, but for objects that only wear an image/sketch costume, offering color would be perplexing, so it's left to the costumes to decide.""		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "	^ aNumber == 2		ifTrue:			[#(	(color			color		readWrite	getColor				setColor:))]		ifFalse:			[Array new]! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 7/1/1998 18:02'!pasteUpMorph	"Answer the closest containing morph that is a PasteUp morph"	^ self ownerThatIsA: PasteUpMorph! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 6/29/1998 17:23'!usableDuplicateIn: aWorld	|  aName usedNames newPlayer newMorph |	newMorph _ self fullCopy.	costumee ifNotNil:		[newPlayer _ costumee duplicatedPlayerForCostume: newMorph.			"nb newPlayer has had his costume set to newMorph in the above-called method"		self isFlexMorph ifTrue: [newMorph renderedMorph costumee: newPlayer]. "???"		newMorph actorState: (costumee actorState shallowCopy initializeFor: newPlayer)].	(aName _ self knownName) == nil ifTrue:		[costumee ~~ nil ifTrue: [aName _ newMorph innocuousName]].  "Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ aWorld allKnownNames copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	newMorph justDuplicatedFrom: self.	newMorph removeProperty: #partsDonor.	newMorph privateOwner: nil.	(newPlayer ~~ nil and: [newMorph renderedMorph eventHandler ~~ nil]) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	newPlayer ifNotNil: [self presenter flushPlayerListCache].	^ newMorph! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 7/3/1998 17:24'!usableSiblingInstance	|  aName usedNames newPlayer newMorph |	self flag: #noteToTed.  "Note I've fallen back on veryDeepCopyWithoutCostumee here, because I want another instance of my Player's class rather than a new Player subclass."	newMorph _ self veryDeepCopyWithoutCostumee.	newPlayer _ costumee class new costume: newMorph.	self isFlexMorph ifTrue: [newMorph renderedMorph costumee: newPlayer]. "???"	newMorph actorState: (costumee actorState shallowCopy initializeFor: newPlayer).	(aName _ self knownName) == nil ifTrue:		[costumee ~~ nil ifTrue: [aName _ newMorph innocuousName]].  "Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	"newMorph justDuplicatedFrom: self.  NOT done for sibling inst"	newMorph privateOwner: nil.	(newMorph renderedMorph eventHandler ~~ nil) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	self presenter flushPlayerListCache.	^ newMorph! !!Morph methodsFor: 'jun98 additions' stamp: 'sw 6/30/1998 09:53'!clearPaletteArea	| pal |	(pal _ self standardPalette) ~~ nil ifTrue:		[pal showNoPalette]! !!Morph methodsFor: 'jun98 additions' stamp: 'sw 7/3/1998 16:45'!cursorPoint	"A convenience"	^ self primaryHand lastEvent cursorPoint! !!Morph methodsFor: 'jun98 additions' stamp: 'sw 7/3/1998 17:11'!hasSubmorphWithProperty: aSymbol	submorphs detect: [:m | m hasProperty: aSymbol] ifNone: [^ false].	^ true! !!Morph methodsFor: 'jun98 additions' stamp: 'sw 6/25/1998 15:50'!inspectOwnerChain	| c next |	c _ OrderedCollection with: self.	next _ self.	[(next _ next owner) ~~ nil] whileTrue: [c add: next].	c asArray inspectWithLabel: 'Owner chain for ', self printString! !!Morph methodsFor: 'jun98 additions' stamp: 'sw 7/6/1998 14:35'!newThumbnailOfHeight: aHeight	"Answer a morph who knows about me and looks like me.  A kind of alias"	^ MorphThumbnail new height: aHeight; morphRepresented: self! !!Morph methodsFor: 'jun98 additions' stamp: 'sw 7/3/1998 18:47'!submorphWithProperty: aSymbol	^ submorphs detect: [:aMorph | aMorph hasProperty: aSymbol] ifNone: [nil]! !!Morph methodsFor: 'jun98 additions' stamp: 'sw 7/3/1998 16:29'!substituteForMorph: aMorph beingDroppedOn: aPage	"Allows a morph that is one level above aPage in the containment hierarchy to have a say on which morph should be dropped"	^ nil ! !!Morph methodsFor: 'jun98 additions' stamp: 'sw 6/23/1998 16:00'!succeededInRevealing: aPlayer	aPlayer == costumee ifTrue: [^ true].	submorphs do:		[:m | (m succeededInRevealing: aPlayer) ifTrue: [^ true]].	^ false! !!Morph methodsFor: 'jun98 additions' stamp: 'sw 7/6/1998 15:40'!thumbnailOfHeight: aHeight	"Answer a morph who knows about me and looks like me.  A kind of alias"	^ MorphThumbnail new extent: aHeight @ aHeight; morphRepresented: self! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'sw 6/26/1998 15:37'!page: aMorph	page _ aMorph.	self computeThumbnail.	self setNameTo: aMorph externalName! !!BorderedMorph methodsFor: 'menu' stamp: 'sw 6/25/1998 08:34'!slotNamesAndTypesForBank: aNumber	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts"	^ aNumber == 2		ifTrue: 			[#(			(color			color		readWrite	getColor				setColor:)			(borderWidth 		number		readWrite	getBorderWidth	setBorderWidth:)			(borderColor			color		readWrite	getBorderColor	setBorderColor:))]		ifFalse:			[super slotNamesAndTypesForBank: aNumber]! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:27'!acceptSort	book acceptSortedContentsFrom: pageHolder.	self delete.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:39'!addControls	| b r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Okay';	actionSelector: #acceptSort).	r addMorphBack: (b fullCopy label: 'Cancel';	actionSelector: #delete).	self addMorphFront: r.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:28'!book: aBookMorph morphsToSort: morphList	book _ aBookMorph.	pageHolder removeAllMorphs.	pageHolder addAllMorphs: morphList.	pageHolder extent: pageHolder width@pageHolder fullBounds height.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:42'!closeButtonOnly	"Replace my default control panel with one that has only a close button."	| b r |	self firstSubmorph delete.  "remove old control panel"	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Close'; actionSelector: #delete).	self addMorphFront: r.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'sw 7/1/1998 18:36'!forBook: aBookMorph	book _ aBookMorph.	pageHolder removeAllMorphs.	pageHolder addAllMorphs:		(book pages collect: [:p | p thumbnailForPageSorter]).	pageHolder extent: pageHolder width@pageHolder fullBounds height.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 12:36'!initialize	super initialize.	self extent: 440@400;		orientation: #vertical;		centering: #topLeft;		hResizing: #spaceFill;		vResizing: #spaceFill;		inset: 3;		color: Color lightGray;		borderWidth: 2.	pageHolder _ PasteUpMorph new behaveLikeHolder extent: self extent - borderWidth.	pageHolder cursor: 0.	self addControls.	self addMorphBack: pageHolder.! !!BooklikeMorph commentStamp: 'sw 7/6/1998 23:33' prior: 0!A common superclass for BookMorph and WebBookMorph!!BooklikeMorph reorganize!('page controls' fullControlSpecs hidePageControls makePageControlsFrom: shortControlSpecs showPageControls)('menu commands' addCustomMenuItems:hand: clearNewPagePrototype firstPage insertPage sortPages)('misc' addBookMenuItemsTo:hand: currentPlayerDo: pageSize pageSize: playPageFlipSound presentResultMorph:)!!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 15:48'!fullControlSpecs	^ #(( '<--'		firstPage		'First page')		( '<-' 		previousPage	'Previous page')		('-'			deletePage		'Delete this page')		('<<>>'		invokeBookMenu 'Invoke menu')		('+'			insertPage		'Add a new page after this one')		('->'			nextPage		'Next page')		( '-->'		lastPage			'Final page'))! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 16:12'!hidePageControls	"Delete all submorphs answering to the property #pageControl"	self deleteSubmorphsWithProperty: #pageControl! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 16:16'!makePageControlsFrom: controlSpecs	| c aButton col row b |	c _ (color saturation > 0.1) ifTrue: [color lighter] ifFalse: [color darker].	aButton _ SimpleButtonMorph new target: self; borderColor: Color black; color: c.	col _ AlignmentMorph newColumn.	col color: c; borderWidth: 0; inset: 0.	col hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	row _ AlignmentMorph newRow.	row color: c; borderWidth: 0; inset: 0.	row hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	controlSpecs do: [:pair |		b _ aButton fullCopy			label: pair first;			actionSelector: pair second;			setBalloonText: pair third.		row addMorphBack: b.		(pair last asLowercase includesSubString: 'menu')			ifTrue: [b actWhen: #buttonDown]].  "pop up menu on mouseDown"	col addMorphBack: row.	^ col! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 17:48'!shortControlSpecs	^ #(( '<-'	previousPage	'Previous page')		('->'		nextPage		'Next page'))! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 16:13'!showPageControls	| spacer pageControls |	self hidePageControls.	spacer _ Morph new color: color; extent: 0@10.	spacer  setProperty: #pageControl toValue: true.	self addMorph: spacer.	pageControls _ Preferences noviceMode		ifTrue: [self makePageControlsFrom: self shortControlSpecs]		ifFalse: [self makePageControlsFrom: self fullControlSpecs].	pageControls borderWidth: 1; inset: 4.	pageControls  setProperty: #pageControl toValue: true.	pageControls setNameTo: 'Page Controls'.	self addMorph: pageControls.! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 17:36'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"This factoring allows subclasses to have different menu yet still use the super call for the rest of the metamenu."	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self addBookMenuItemsTo: aCustomMenu hand: aHandMorph! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 15:39'!clearNewPagePrototype	newPagePrototype _ nil! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 15:40'!firstPage	self goToPage: 1! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 17:18'!insertPage	self insertPageColored: self color! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 16:08'!sortPages	| sorter |	sorter _ BookPageSorterMorph new		book: self morphsToSort: self morphsForPageSorter.	sorter pageHolder cursor: self indexOfCurrentPage.	self presentResultMorph: sorter! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 15:56'!addBookMenuItemsTo: aCustomMenu hand: aHandMorph	(self hasSubmorphWithProperty: #pageControl)		ifTrue: [aCustomMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [aCustomMenu add: 'show page controls' action: #showPageControls]! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 16:50'!currentPlayerDo: aBlock	| aPlayer aPage |	(aPage _ self currentPage) ifNil: [^ self].	(aPlayer _ aPage costumee) ifNotNil:		[aBlock value: aPlayer]! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 15:36'!pageSize	^ pageSize! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 16:51'!pageSize: aPoint	pageSize _ aPoint! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 15:38'!playPageFlipSound	(self presenter soundsEnabled "user-controllable" and:		[PageFlipSoundOn])  "mechanism to suppress sounds at init time"			ifTrue: [self playSoundNamed: 'camera'].! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 16:09'!presentResultMorph: aMorph	"Add the given morph to the world."	self primaryHand attachMorph: aMorph"	aMorph position: self fullBounds topRight + (5@0).	self world addMorphFront: aMorph."! !!BookMorph commentStamp: 'sw 7/6/1998 23:33' prior: 0!Allows one or another "page" to show; orchestrates the page transitions; offers control panel for navigating among pages and for adding and deleting pages.!!BookMorph reorganize!('initialization' closeCurrentPageToDragNDrop initialize newPages: newPages:currentIndex: removeEverything setInitialState)('sorting' acceptSortedContentsFrom: morphsForPageSorter sortPages:)('accessing' allNonSubmorphMorphs currentPage pageNamed: pages pages:)('dropping/grabbing' acceptDroppingMorph:event: allowSubmorphExtraction beThoroughlyRepelling rootForGrabOf: wantsDroppedMorph:event:)('insert and delete' deletePage deletePageBasic insertPage:pageSize: insertPage:pageSize:atIndex: insertPageColored: insertPageLabel:morphs: insertPageShowingString:fontName:fontSize: insertPageShowingString:usingFont:)('zooming page turns' showPageTurningFeedbackFromOrigin:ascending:)('navigation' goToPage: goToPageMorph: goToPageMorphNamed: lastPage nextPage previousPage)('menu' addBookMenuItemsTo:hand: bookmarkForThisPage indexOfCurrentPage invokeBookMenu newTextMorph pasteBookPage setNewPagePrototype)('copying' copyRecordingIn: updateReferencesUsing:)('other' configureForKids makeMinimalControlsWithColor:title: releaseCachedState succeededInRevealing:)('object fileIn' convertbosfcepbbochvimolppcc0:bosfcepcbbochvimolppccn0: convertbosfcepbbochvimolppccs0:bosfcepbbochvimolppcc0: convertbosfcepcbbochvimolppcc0:bosfcepcbbochvimolppccn0:)('private')!!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:43'!initialize	super initialize.	self setInitialState.	pages _ OrderedCollection new.	self showPageControls.	self class turnOffSoundWhile: [self insertPage].! !!BookMorph methodsFor: 'initialization' stamp: 'sw 6/24/1998 09:23'!newPages: pageList	"Replace all my pages with the given list of BookPageMorphs.  After this call, currentPage may be invalid."	pages _ pages species new.	pages addAll: pageList! !!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:45'!removeEverything	currentPage _ nil.	pages _ OrderedCollection new.	self removeAllMorphs! !!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 17:03'!setInitialState	orientation _ #vertical.	centering _ #topLeft.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	inset _ 5.	color _ Color white.	pageSize _ 160@300.	openToDragNDrop _ true! !!BookMorph methodsFor: 'sorting' stamp: 'sw 6/25/1998 17:15'!acceptSortedContentsFrom: aHolder	"Update my page list from the given page sorter."	| goodPages rejects existingCursor toAdd newCursor |	goodPages _ OrderedCollection new.	rejects _ OrderedCollection new.	existingCursor _ aHolder cursor.	aHolder submorphs doWithIndex: [:m :i |		toAdd _ nil.		(m isKindOf: PasteUpMorph) ifTrue: [toAdd _ m].		(m isKindOf: BookPageThumbnailMorph) ifTrue: [toAdd _ m page].		toAdd ifNil:				[rejects add: m]			ifNotNil:				[goodPages add: toAdd.				i == existingCursor ifTrue: [newCursor _ goodPages size]]].	self newPages: goodPages.	goodPages size == 0 ifTrue: [self insertPage].	newCursor ifNil: [newCursor _ 1].	self goToPage: newCursor.	rejects size > 0 ifTrue: [self inform: rejects size printString, ' objects vanished in this process.']! !!BookMorph methodsFor: 'sorting' stamp: 'sw 6/25/1998 15:28'!morphsForPageSorter	^ pages collect: [:p | p thumbnailForPageSorter].! !!BookMorph methodsFor: 'sorting' stamp: 'jm 6/17/1998 21:35'!sortPages: evt	| sorter |	sorter _ BookPageSorterMorph new		book: self morphsToSort: self morphsForPageSorter.	sorter pageHolder cursor: (pages indexOf: currentPage ifAbsent: [0]).	evt == nil		ifTrue: [self world addMorphFront: sorter]		ifFalse: [evt hand attachMorph: sorter].! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/4/1998 16:40'!beThoroughlyRepelling	submorphs do: [:m | m beRepelling].	self beRepelling! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/4/1998 17:12'!rootForGrabOf: aMorph	| root |	openToDragNDrop ifFalse: [^ super rootForGrabOf: aMorph].	(aMorph = currentPage or: [aMorph owner = self])		ifTrue: [^ self rootForGrabOf: self].	root _ aMorph.	[root = self] whileFalse:		[root owner == currentPage ifTrue: [^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!BookMorph methodsFor: 'insert and delete' stamp: 'sw 6/24/1998 18:50'!deletePage	| message |	message _ 'Are you certain that youwant to delete this page andeverything that is on it? '.	(self confirm: message) ifTrue: 			[self deletePageBasic].	! !!BookMorph methodsFor: 'navigation' stamp: 'sw 7/6/1998 21:41'!goToPage: pageNumber	| pageIndex  oldOrigin aWorld oldRect oldPageNumber ascending newPage |	pages isEmpty ifTrue: [^ self].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	newPage _ pages at: pageIndex.	oldPageNumber _ pages indexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageNumber == nil) or: [newPage == currentPage])			ifTrue:				[nil]			ifFalse:				[oldPageNumber < pageIndex].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	currentPage ifNotNil:		[(oldRect _ currentPage screenRectangle) ifNotNil:			[oldOrigin _ oldRect origin].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		currentPage releaseCachedState; delete].	currentPage _ pages at: pageIndex.	self addMorphBack: currentPage.	aWorld ifNotNil:		[self world startSteppingSubmorphsOf: currentPage.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending].	self currentPlayerDo:		[:aPlayer | aPlayer runAllOpeningScripts].! !!BookMorph methodsFor: 'menu' stamp: 'sw 7/4/1998 17:06'!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue: [subMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [subMenu add: 'show page controls' action: #showPageControls].	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	(aHandMorph classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'Book...' subMenu: subMenu! !!BookMorph methodsFor: 'menu' stamp: 'sw 7/4/1998 16:06'!indexOfCurrentPage	^ pages indexOf: currentPage ifAbsent: [0]! !!BookMorph methodsFor: 'menu' stamp: 'sw 7/4/1998 17:08'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu sel |	aMenu _ MVCMenuMorph new.	aMenu addList:	#(			('sort pages'				sortPages)			('make bookmark'		bookmarkForThisPage)			('remove control panel'	hidePageControls)		).	(self primaryHand classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel].! !!BookMorph methodsFor: 'other' stamp: 'sw 6/30/1998 17:09'!makeMinimalControlsWithColor: aColor title: aString	| aButton aColumn aRow but |	aButton _ SimpleButtonMorph new target: self; borderColor: Color black; color: aColor; borderWidth: 0.	aColumn _ AlignmentMorph newColumn.	aColumn color: aButton color; borderWidth: 0; inset: 0.	aColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	aRow _ AlignmentMorph newRow.	aRow color: aButton color; borderWidth: 0; inset: 0.	aRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	aRow addTransparentSpacerOfSize: 40@0.	aRow addMorphBack: (but _ aButton fullCopy label: ' < ' ; actionSelector: #previousPage).	but setBalloonText: 'Go to previous page'.	aRow addTransparentSpacerOfSize: 82@0.	aRow addMorphBack: (StringMorph contents: aString) lock.	aRow addTransparentSpacerOfSize: 82@0.	aRow addMorphBack: (but _ aButton fullCopy label: ' > ' ; actionSelector: #nextPage).	but setBalloonText: 'Go to next page'.	aRow addTransparentSpacerOfSize: 40@0.	aColumn addMorphBack: aRow.	aColumn setNameTo: 'Page Controls'.		^ aColumn! !!BookMorph methodsFor: 'other' stamp: 'sw 7/4/1998 17:25'!succeededInRevealing: aPlayer	currentPage ifNotNil: [currentPage costumee == aPlayer ifTrue: [^ true]].	pages do:		[:aPage |			(aPage succeededInRevealing: aPlayer) ifTrue:				[self goToPageMorph: aPage.				^ true]].	^ false! !!EToyPalette methodsFor: 'initialization' stamp: 'sw 7/2/1998 14:47'!addButtonNamed: label selector: aSymbol	"Rerusticated to EToyPalette"	| b |	b _ StringButtonMorph new.	b	contents: label;		color: self buttonOffColor;		target: self;		actionSelector: aSymbol;		setNameTo: label.	self addMorphBack: b.! !!EToyPalette methodsFor: 'initialization' stamp: 'sw 7/2/1998 14:50'!buttonOffColor		| val |	^ (val _ self valueOfProperty: #buttonOffColor)		ifNotNil:			[val]		ifNil:			[Color r: 0.4 g: 0.2 b: 0.6]! !!EToyPalette methodsFor: 'widgets ' stamp: 'sw 7/4/1998 16:38'!controlsBook	"Return a book with pages containing controls"	| book col |	book _ BookMorph newSticky borderWidth: 2; setNameTo: 'Controls Book'.	book  removeEverything; showPageControls.		book insertPageLabel: nil		morphs: (Array with: (col _ AlignmentMorph newColumn)).	self addPageOneControlsTo: col.	col addTransparentSpacerOfSize: (1 @ 12).	Smalltalk at: #RecordingControlsMorph ifPresent: [:recorderClass |		col addMorphBack: recorderClass new beSticky.		col addTransparentSpacerOfSize: (1 @ 12)].	self addToggleButtonsTo: col forPage: 1.	book insertPageLabel: nil		morphs: (Array with: (col _ AlignmentMorph newColumn)).	self addPageTwoControlsTo: col.	self addToggleButtonsTo: col forPage: 2.	book openToDragNDrop: false.	book beThoroughlyRepelling.	book goToPage: 1.	^ book! !!EToyPalette methodsFor: 'widgets ' stamp: 'sw 7/4/1998 16:38'!suppliesBook	"Return a book with pages containing bins of parts.  Everything in the supplies book is for drag-n-drop"	| book |	book _ BookMorph newSticky borderWidth: 2; setNameTo: 'Misc'.	book  removeEverything; showPageControls.	book insertPageLabel: 'Shapes'		morphs: (Array with: (self partsDonorBinFor: self authoringWidgets)).		book insertPageLabel: 'Widgets'		morphs: (Array with: (self partsDonorBinFor: self alternateWidgets)).	book insertPageLabel: 'Holder, Joystick, Book'		morphs: (Array with: (self partsDonorBinFor: self page3Widgets)).	book		insertPageLabel: 'Values'		morphs: (Array with: (self partsBinFor: self presenter valueTiles)).	book		insertPageLabel: 'Comparing and Testing'		morphs: (Array with: (self partsBinFor: self presenter booleanTiles)).	book		insertPageLabel: 'Arithmetic'		morphs: (Array with: (self partsBinFor: self presenter arithmeticTiles)).	book goToPage: 1.	book openToDragNDrop: false.	book beThoroughlyRepelling.	^ book! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'sw 7/6/1998 16:37'!grabMorph: m	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor |	formerOwner _ m owner.	formerPosition _ m position.	m isTileLike ifTrue:		[editor _ m topEditor].	(m owner isKindOf: DropShadowMorph)		ifTrue:			[self grabMorph: m owner]		ifFalse:			[m aboutToBeGrabbedBy: self.			gridOn ifTrue: [m position: (m position grid: grid)].			self addMorphBack: m].	editor ifNotNil: [editor scriptEdited]! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 7/6/1998 21:26'!buildWorldMenu	"Build the meta menu for the world."	| menu subMenu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'go back' target: owner action: #goBack.	menu add: 'jump to...'		subMenu: (Project buildJumpToMenu: (MenuMorph new defaultTarget: Project)).	menu addLine.	menu add: 'paste morph' action: #pasteMorph.	menu add: 'new morph...' action: #newMorph.	World ifNotNil: [		subMenu _ MenuMorph new defaultTarget: self.		subMenu add: 'workspace' action: #openWorkspace.		subMenu add: 'browser' action: #openBrowser.		subMenu add: 'recent changes' action: #openRecentChanges.		subMenu add: 'change sorter' selector: #openChangeSorter: argument: 1.		subMenu add: 'dual sorter' selector: #openChangeSorter: argument: 2.		subMenu add: 'changes log' action: #openChangesLog.		subMenu add: 'file list' action: #openFileList.		subMenu add: 'transcript' action: #openTranscript.		subMenu add: 'project (mvc)' action: #openMVCProject.		subMenu add: 'project (morphic)' action: #openMorphicProject.		subMenu add: 'construction' action: #openConstructionProject.		subMenu add: 'project link...' action: #projectThumbnail.		subMenu addLine.		subMenu add: 'collapse all' action: #collapseAll.		subMenu add: 'expand all' action: #expandAll.		subMenu add: 'find window' action: #findWindow.		menu add: 'open...' subMenu: subMenu].	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'grab drawing from screen' action: #grabDrawingFromScreen.	subMenu add: 'read drawing from file' action: #importImageFromDisk.	subMenu add: 'make new drawing' target: self presenter associatedMorph action: #makeNewDrawingWithin.	menu add: 'graphics...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'add slot to model' action: #newVariable.	subMenu add: 'write init method for model' action: #writeInitMethodForModel.	subMenu add: 'grab model for this world' action: #grabModel.	menu add: 'model...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'restore display' action: #restoreDisplay.	subMenu add: 'set display depth...' action: #setDisplayDepth.	subMenu add: 'change background color' action: #changeBackgroundColor.	subMenu add: 'use texture background' target: self world action: #setStandardTexture.	subMenu add: 'unlock contents' action: #unlockWorldContents.	subMenu add: 'unhide hidden objects' action: #showHiders.	subMenu add: 'round up stray objects' action: #roundUpStrayObjects.	gridOn		ifTrue: [subMenu add: 'turn gridding off' action: #setGridding]		ifFalse: [subMenu add: 'turn gridding on' action: #setGridding].	menu add: 'viewing...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'update code from server' action: #updateFromServer.	subMenu addLine.	subMenu add: 'local host address' action: #reportLocalAddress.	subMenu add: 'connect remote user' action: #connectRemoteUser.	subMenu add: 'disconnect remote user' action: #disconnectRemoteUser.	subMenu add: 'disconnect all remote users' action: #disconnectAllRemoteUsers.	menu add: 'remote...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'read drawing from file' action: #importImageFromDisk.	subMenu add: 'save world in file' action: #saveWorldInFile.	subMenu add: 'read morph(s) from file' action: #readMorphFile.	menu add: 'file...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self world.	subMenu add: 'detachable scripting space' target: self action: #detachableScriptingSpace.	subMenu add: 'parts bin' target: self presenter action: #createStandardPartsBin.	subMenu add: 'control panel' target: self presenter action: #createControlPanel.	menu add: 'scripting...' subMenu: subMenu.	menu add: 'do...' target: Utilities action: #offerCommonRequests.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'inspect world' action: #inspectWorld.	subMenu add: 'inspect model' action: #inspectWorldModel.	subMenu add: 'clear palette area' action: #clearPaletteArea.	subMenu add: 'flush viewer cache' action: #flushViewerCache.	subMenu add: 'full screen' action: #fullScreen.	subMenu add: 'start MessageTally' action: #startMessageTally.	subMenu add: 'call #tempCommand' action: #callTempCommand.	subMenu add: 'show space left' action: #showSpaceLeft.	menu add: 'debug...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save' action: #saveSession.	subMenu add: 'save as...' action: #saveAs.	subMenu add: 'save and quit' action: #saveAndQuit.	subMenu add: 'quit...' action: #quitSession.	menu add: 'save / quit...' subMenu: subMenu.	^ menu! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 7/6/1998 13:26'!detachableScriptingSpace	| aPasteUp |	aPasteUp _ PasteUpMorph new color: Color white; borderWidth: 1; borderColor: Color green lighter; extent: 500@400.	self attachMorph: aPasteUp.	aPasteUp impartPrivatePresenter; setProperty: #automaticPhraseExpansion toValue: true; beSticky	! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 7/6/1998 21:52'!makeAliasForArgument	| aThumbnailMorph |	(argument notNil and: [self playfield notNil]) ifTrue:		[aThumbnailMorph _ argument newThumbnailOfHeight: 40.		aThumbnailMorph  setNameTo: '^ ', argument externalName.		self attachMorph: aThumbnailMorph]! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 7/6/1998 11:29'!openConstructionProject	| aSystemWindow |	self world addMorph: (aSystemWindow _ ProjectViewMorph newMorphicConstruction).	aSystemWindow model "the Project itself" enter: false! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 6/17/1998 13:58'!restoreDisplay	self world fullRepaintNeeded! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 7/3/1998 21:37'!makeNewDrawingInBounds: rect pasteUpMorph: aPasteUpMorph	| w newSketch newPlayer sketchEditor p aPaintBox |	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	newSketch _ self drawingClass new costumee: (newPlayer _ Player newUserInstance).	newPlayer costume: newSketch.	newSketch form: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor _ SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect ofWorld: w.	sketchEditor		afterNewPicDo: [:aForm :aRect |			newSketch form: aForm.			newSketch position: aRect origin.			newSketch forwardDirection: sketchEditor forwardDirection.			newSketch rotationDegrees: sketchEditor forwardDirection.			newSketch rotationStyle: sketchEditor rotationStyle.			aPasteUpMorph addMorphFront: newSketch.			w startSteppingSubmorphsOf: newSketch.			self presenter drawingJustCompleted: newSketch]		 ifNoBits:			[(aPaintBox _ self world paintBox) ifNotNil:				[aPaintBox delete].			p _ aPasteUpMorph standardPalette.			p ifNotNil: [p showNoPalette]].! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 7/6/1998 13:30'!rejectDropMorph: aMorph event: evt	"aMorph has been rejected, and must be put back somewhere.  There are three cases:	(1)  It remembers its former owner and position, and goes right back there	(2)  It remembers its former position only, in which case it was torn off from a parts bin, and the UI is that it floats back to its donor position and then vanishes.	(3)  Neither former owner nor position is remembered, in which case it is whisked to the Trash"	(formerOwner notNil and: [formerOwner isPartsBin not]) ifTrue:		[^ aMorph slideBackToFormerSituation: evt].	formerPosition ifNotNil:  "Position but no owner -- can just make it vanish"		[^ aMorph vanishAfterSlidingTo: formerPosition event: evt].			aMorph slideToTrash: evt! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 6/25/1998 09:28'!roundUpStrayObjects	self world roundUpStrays! !!HolderMorph methodsFor: 'accessing' stamp: 'sw 6/25/1998 08:33'!slotNamesAndTypesForBank: aBank	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts"	aBank == 2 ifFalse: [^ Array new].	^ #("		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "		(color			color		readWrite	getColor				setColor:)		(cursor 			number		readWrite	getCursor			setCursor:)		(valueAtCursor	player		readOnly	getValueAtCursor	unused)	)! !!MorphThumbnail commentStamp: 'sw 7/6/1998 23:33' prior: 0!A morph whose appearance is a thumbnail of some other morph.!!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 22:07'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'reveal original morph' action: #revealOriginal.	aCustomMenu add: 'grab original morph' action: #grabOriginal.! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 17:37'!computeThumbnail	| f scale |	f _ morphRepresented imageForm.	morphRepresented fullReleaseCachedState.	scale _ self height / f height.  "keep height invariant"	self form: (f magnify: f boundingBox by: scale smoothing: 2).	self extent: originalForm extent! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 22:08'!grabOriginal	self primaryHand attachMorph: morphRepresented! !!MorphThumbnail methodsFor: 'all' stamp: 'jm 11/17/97 14:01'!initialize	| f |	super initialize.	color _ Color lightGray.  "background color"	f _ Form extent: 60@80 depth: 16.	f fill: f boundingBox fillColor: color.	self form: f.! !!MorphThumbnail methodsFor: 'all' stamp: 'jm 11/17/97 17:30'!morphRepresented	^ morphRepresented! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 6/26/1998 15:37'!morphRepresented: aMorph	morphRepresented _ aMorph.	self computeThumbnail.	self setNameTo: aMorph externalName! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 22:04'!revealOriginal	((owner isKindOf: PasteUpMorph) and: [owner alwaysShowThumbnail])		ifTrue:			[^ self beep].	morphRepresented owner == nil ifTrue:		[^ owner replaceSubmorph: self by: morphRepresented].	self beep.! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 15:39'!thumbnailOfHeight: aHeight	self height: aHeight.	self computeThumbnail.	^ self! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 7/6/1998 22:42'!setPlayer: aPlayer	scriptedPlayer _ aPlayer.	self removeAllMorphs.	self addMorphBack: self rowBeforeParts.	self addTilesForPlayerParts.	self addTransparentSpacerOfSize: 1 @ 8.	self addMorphBack: self rowBeforeScripts.	self addMorphBack: self commandTilesPartsBin.	self isInWorld ifTrue: [self world startSteppingSubmorphsOf: self].	self beRepelling.	self layoutChanged! !!PartsViewer methodsFor: 'private' stamp: 'sw 6/24/1998 16:02'!rowBeforeParts	| r nail aButton aTextMorph aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	r addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Hit the X to remove this Viewer'.	r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousPartsBank; label: '<' font: aFont; color: self caretColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'Show previous bank of parts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextPartsBank; label: '>' font: aFont; color: self caretColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'Show next bank of parts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 7@5.	scriptedPlayer assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	r  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousCostume; label: '<' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to previous costume'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextCostume; label: '>' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to next costume'.	r addTransparentSpacerOfSize: 10@5.	nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #thumbnailMenuEvt:forMorph: to: scriptedPlayer.	r addMorphBack: nail.	nail setBalloonText: 'click here to get a menuto specify new costume,tear off a tile, etc..'.		^ r! !!PartsViewer methodsFor: 'private' stamp: 'sw 7/3/1998 17:31'!tileForArgType: typeSymbol	| aColor |	typeSymbol == #player ifTrue:		[^ self tileForPlayer:  self presenter standardPlayer].	aColor _ TilePadMorph colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	self error: 'Unrecognized type'! !!PasteUpMorph methodsFor: 'initialization' stamp: 'sw 6/18/1998 09:17'!initialize	owner _ nil.	submorphs _ EmptyArray.	borderWidth _ 1.	borderColor _ Color r: 0.861 g: 1.0 b: 0.722.	gradientDirection _ #vertical.	color _ Color r: 0.8 g: 1.0 b: 0.6.	fillColor2 _ color.	bounds _ 0@0 corner: 50@40.	cursor _ 1.	padding _ 3.	autoLineLayout _ false.	openToDragNDrop _ true.	lastTurtlePositions _ IdentityDictionary new.	self isWorldMorph ifTrue: [self setProperty: #automaticPhraseExpansion toValue: true]! !!PasteUpMorph methodsFor: 'display' stamp: 'sw 7/2/1998 15:09'!padding	^ padding! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 6/18/1998 09:10'!automaticPhraseExpansion	^ self hasProperty: #automaticPhraseExpansion! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 6/17/1998 12:58'!automaticViewing	^ (self standardPalette ~~ nil) and: [self hasProperty: #automaticViewing]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/6/1998 17:37'!morphToDropFrom: aMorph	| itsSelector aScriptor adjustment anEditor actualObject aUserScript ownersChoice aNail |	owner ifNotNil:		[(ownersChoice _ owner substituteForMorph: aMorph beingDroppedOn: self)			ifNotNil:	[^ ownersChoice]].	self alwaysShowThumbnail ifTrue:		[aNail _ aMorph thumbnailOfHeight: self heightForThumbnails.		aNail == aMorph ifFalse:			[aNail position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (aNail extent / aMorph extent)) rounded)].		^ aNail].	self expandPhrasesToScripts ifFalse: [^ aMorph].	(aMorph hasProperty: #newAnonymousScript) ifTrue: [^ self emptyAnonymousScriptorFrom: aMorph].	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].	(actualObject _ aMorph actualObject) ifNil: [^ aMorph].	aScriptor _ (itsSelector _ aMorph userScriptSelector) size > 0		ifTrue:			[actualObject isFlagshipForClass				ifFalse:					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: aMorph.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					["old note: ambiguous case: if there's a script editor on the world, drop down a button, else drop down the script editor"					aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.					aUserScript isTextuallyCoded						ifTrue: [^ self scriptorForTextualScript: itsSelector ofPlayer: actualObject].					((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:							[anEditor owner == self])						ifFalse:							[adjustment _ 50 @ 30.							anEditor]						ifTrue:							[adjustment _ 60 @ 20.							actualObject anonymousScriptEditorFor: aMorph]]]		ifFalse:   "It's a system-defined selector; construct an anonymous scriptor around it"			[adjustment _ 60 @ 20.			actualObject anonymousScriptEditorFor: aMorph].	aScriptor position: (self primaryHand position - adjustment).	^ aScriptor! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 4/14/1998 00:08'!repelsMorph: aMorph event: ev	isPartsBin == true ifTrue: [^ true].	openToDragNDrop ifFalse: [^ true].	(self wantsDroppedMorph: aMorph event: ev) ifFalse: [^ true].	^ super repelsMorph: aMorph event: ev "consults #repelling flag"! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/6/1998 17:37'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. If parts bin, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner == self ifTrue:			[self isPartsBin				ifTrue:					[(root renderedMorph isKindOf: MorphThumbnail)						ifTrue:							[^ root renderedMorph morphRepresented veryDeepCopy position: root renderedMorph position]						ifFalse:							[^ root topRendererOrSelf veryDeepCopy]].			self openToDragNDrop					ifTrue: [^ root]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 7/6/1998 13:22'!addCustomMenuItems: menu hand: aHandMorph	super addCustomMenuItems: menu hand: aHandMorph.	self addStackMenuItems: menu hand: aHandMorph.	self addPenMenuItems: menu hand: aHandMorph.	self addPlayfieldMenuItems: menu hand: aHandMorph.	menu addLine! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/17/1998 12:11'!addPenMenuItems: menu hand: aHandMorph	| subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'clear pen trails' action: #clearTurtleTrails.	subMenu add: 'all pens up' action: #liftAllPens.	subMenu add: 'all pens down' action: #lowerAllPens.	menu add: 'pens trails within...' subMenu: subMenu! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 7/6/1998 16:10'!addPlayfieldMenuItems: menu hand: aHandMorph	| subMenu prefix hasPalette |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save on file...' action: #saveOnFile.	subMenu add: 'navigate to...' action: #navigateTo.	subMenu add: 'round up strays' action: #roundUpStrays.	subMenu addLine.	#(	(autoLineLayout			'auto layout'			toggleAutoLineLayout)		(resizeToFit				'resize-to-fit'			toggleResizeToFit)		(indicateCursor			'showing cursor'		toggleIndicateCursor)		(isPartsBin				'being a parts bin'		toggleIsPartsBin)		(wantsMouseOverHalos	'mouse-over halos'		toggleMouseOverHalos))	do:		[:triplet |			prefix _ (self perform: triplet first) ifTrue: ['stop '] ifFalse: ['start '].			subMenu add:  (prefix, triplet second) action: triplet third].	prefix _ (self hasProperty: #automaticPhraseExpansion) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'phrase expansion') action: #toggleAutomaticPhraseExpansion.	prefix _ (self hasProperty: #alwaysShowThumbnail) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'showing thumbnails') action: #toggleAlwaysShowThumbnail.	(self hasProperty: #alwaysShowThumbnail) ifTrue:		[subMenu add: 'set thumbnail height...' action: #setThumbnailHeight].	(hasPalette _ self standardPalette ~~ nil) ifTrue:		[prefix _ self automaticViewing ifTrue: ['stop '] ifFalse: ['start '].		subMenu add: (prefix, 'automatic viewing') action: #toggleAutomaticViewing].	subMenu addLine.	hasPalette ifTrue: [subMenu add: 'clear palette area' action: #clearPaletteArea].	(self resizeToFit & self indicateCursor & self autoLineLayout) ifFalse:		[subMenu add: 'behave like a Holder' action: #behaveLikeHolder].	self backgroundSketch ifNotNil: [subMenu add: 'delete background painting' action: #deleteBackgroundPainting].	presenter ifNil:		[subMenu add: 'make detachable' action: #impartPrivatePresenter].	subMenu addTitle: 'Playfield'.	menu add: 'playfield options...' subMenu: subMenu.! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/17/1998 12:10'!addStackMenuItems: menu hand: aHandMorph	| subMenu |	self isStackLike		ifTrue:			[subMenu _ MenuMorph new defaultTarget: self.			subMenu add: 'new card' action: #newCard.			subMenu add: 'delete this card' action: #deleteCard.			subMenu add: 'go to next card' action: #goToNextCard.			subMenu add: 'go to previous card' action: #goToPreviousCard.			menu add: 'card & stack...' subMenu: subMenu]		ifFalse:			[menu add: 'become a stack' action: #becomeStack]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 7/6/1998 16:16'!setThumbnailHeight	|  reply |	reply _ FillInTheBlank		request: 'New height for thumbnails? '		initialAnswer: self heightForThumbnails printString.	reply isEmpty ifTrue: [^ self].	reply _ reply asNumber.	(reply > 0 and: [reply <= 150]) ifFalse:		[^ self inform: 'Please be reasonable!!'].	self setProperty: #heightForThumbnails toValue: reply.	self updateSubmorphThumbnails! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 7/6/1998 16:26'!toggleAlwaysShowThumbnail	(self hasProperty: #alwaysShowThumbnail)		ifTrue:			[self removeProperty: #alwaysShowThumbnail]		ifFalse:			[self setProperty: #alwaysShowThumbnail toValue: true].	self updateSubmorphThumbnails! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/18/1998 09:12'!toggleAutomaticPhraseExpansion	| expand |	expand _ self hasProperty: #automaticPhraseExpansion.	expand		ifTrue:			[self removeProperty: #automaticPhraseExpansion]		ifFalse:			[self setProperty: #automaticPhraseExpansion toValue: true]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/18/1998 09:13'!toggleAutomaticViewing	| current |	current _ self automaticViewing.	current		ifTrue:			[self removeProperty: #automaticViewing]		ifFalse:			[self setProperty: #automaticViewing toValue: true]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 7/6/1998 16:24'!updateSubmorphThumbnails	| thumbsUp aHeight itsThumbnail |	thumbsUp _ self alwaysShowThumbnail.	aHeight _ self heightForThumbnails.	self submorphs do:		[:aMorph | thumbsUp			ifTrue:				[itsThumbnail _ aMorph thumbnailOfHeight: aHeight.				(aMorph == itsThumbnail)					ifFalse:						[self replaceSubmorph: aMorph by: itsThumbnail]]			ifFalse:				[(aMorph isKindOf: MorphThumbnail)					ifTrue:						[self replaceSubmorph: aMorph by: aMorph morphRepresented]]]! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 6/18/1998 09:17'!expandPhrasesToScripts	^ self hasProperty: #automaticPhraseExpansion! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/24/1998 19:46'!allScriptEditors	^ self allMorphs select:		[:s | s isKindOf: ScriptEditorMorph]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/6/1998 14:19'!alwaysShowThumbnail	^ self hasProperty: #alwaysShowThumbnail! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/6/1998 14:39'!heightForThumbnails	^ self valueOfProperty: #heightForThumbnails ifAbsent: [40]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/23/1998 17:08'!impartPrivatePresenter	presenter ifNil:		[presenter _ Presenter new associatedMorph: self.		presenter initializeToggles.		presenter addStopStepGoButtons.		presenter addTrashCan.		presenter standardPlayer]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/3/1998 16:45'!mouseX	^ (self cursorPoint x) - self left! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/3/1998 16:45'!mouseY	^ self bottom - (self cursorPoint y)! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/17/1998 12:06'!navigateTo	self inform: 'Not quite yet!!Later, you can directly retargetthis area so that it displays thecontents of any url'.! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 22:02'!removeScriptingControls	self deleteSubmorphsWithProperty: #scriptingControl! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/25/1998 09:26'!roundUpStrays	self submorphsDo:		[:m |			m goHome.			m isPlayfieldLike ifTrue: [m roundUpStrays]]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/24/1998 18:13'!slotNamesAndTypesForBank: aBank	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts"	aBank == 1 ifTrue: [^ Array new].	aBank == 2 ifTrue: 	[^ #("		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "		(color			color		readWrite	getColor				setColor:)		(borderWidth 	number		readWrite	getBorderWidth		setBorderWidth:)		(borderColor		color		readWrite	getBorderColor		setBorderColor:)		(mouseX			number		readOnly	getMouseX			unused)		(mouseY		number		readOnly	getMouseY			unused))].	aBank == 3 ifTrue: 	[^ #("		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "		(cursor 			number		readWrite	getCursor			setCursor:)		(valueAtCursor	player		readOnly	getValueAtCursor	unused)									"readWrite						setValueAtCursor:")].	^ #()! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/29/1998 17:34'!startRunningAll	"Start running all scripted morphs.  Triggered by user hitting GO button"	self presenter flushPlayerListCache.  "Inefficient, but makes sure things come right whenever GO hit"	self presenter allExtantPlayers do: [:aPlayer | aPlayer costume residesInPartsBin ifFalse: [aPlayer startRunning]].	self world updateStatusForAllScriptEditors! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/29/1998 17:35'!stepAll	self presenter allExtantPlayers do:		[:aPlayer | 			aPlayer startRunning; step; stopRunning.			aPlayer costume goHome]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/29/1998 17:33'!stopRunningAll	"Stop running all scripted morphs.  Triggered by user hitting STOP button"	self presenter allExtantPlayers  do:		[:aPlayer |			aPlayer stopRunning.			aPlayer costume goHome].	self world updateStatusForAllScriptEditors! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/23/1998 17:38'!thumbnailForPageSorter	^ BookPageThumbnailMorph new page: self! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/24/1998 19:47'!updateStatusForAllScriptEditors	self allScriptEditors do: [:anEditor | anEditor updateStatus]! !!IndexTabs commentStamp: 'sw 7/6/1998 23:33' prior: 0!Used in conjunction wi[th a TabbedPalette -- each TabbedPalette has one.  Each submorph of an IndexTabs is a TabMorph.  When you click on one of the tabs, a corresponding action is taken -- sometimes, the existing palette gets replaced by the new one, other times, the tab results in some selector being invoked; in any case, tab highlighting takes place accordingly.!!IndexTabs reorganize!('initialization' initialize)('tabs' addActionTabWithTitle: addTab: addTabForBook: tabMorphs)('layout' basicHeight laySubpartsOutInOneRow)('selection' selectTab:)('highlighting' highlightColor highlightColor: highlightColor:regularColor: highlightTab: highlightTabFor: regularColor regularColor:)!!IndexTabs methodsFor: 'initialization' stamp: 'sw 7/3/1998 16:10'!initialize	super initialize.	padding _ 10.	basicHeight _ 14.	color _ Color transparent.	fillColor2 _ color.	borderWidth _ 0! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/4/1998 14:53'!addActionTabWithTitle: aString	|  aTab |	aTab _ TabMorph new.	aTab contents: aString.	self addMorphBack: aTab.	aTab highlightColor: self highlightColor; regularColor: self regularColor.	aTab color: self regularColor.	self laySubpartsOutInOneRow; layoutChanged.	^ aTab! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/3/1998 11:44'!addTab: aTab	self addMorphBack: aTab.	self laySubpartsOutInOneRow! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/4/1998 14:53'!addTabForBook: aBook	|  aTab |	aTab _ TabMorph new morphToInstall: aBook.	self addMorphBack: aTab.	aTab highlightColor: self highlightColor; regularColor: self regularColor.	aTab color: self regularColor.	self laySubpartsOutInOneRow; layoutChanged.	^ aTab! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/3/1998 12:42'!tabMorphs	"Presently all the submorphs are tabMorphs, but this still supports an earlier design where spacers are interleaved."	^ submorphs select: [:m | m isKindOf: TabMorph]! !!IndexTabs methodsFor: 'layout' stamp: 'sw 7/3/1998 18:37'!basicHeight	^ basicHeight! !!IndexTabs methodsFor: 'layout' stamp: 'sw 7/3/1998 18:37'!laySubpartsOutInOneRow	| aPosition |	aPosition _ self topLeft.	submorphs do:		[:aMorph |			aMorph position: (aPosition + (padding @ 0)).			aPosition _ aMorph topRight].	self extent: (((aPosition x - self left) "max: owner pageSize x") @ self basicHeight)! !!IndexTabs methodsFor: 'selection' stamp: 'sw 7/3/1998 18:43'!selectTab: aTab	| aWorld |	(aWorld _ self world) ifNotNil: [aWorld abandonAllHalos].  "nil can happen at init time"	self highlightTab: aTab.! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 14:56'!highlightColor	^ highlightColor ifNil: [Color yellow]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 13:29'!highlightColor: aColor	highlightColor _ aColor! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 13:43'!highlightColor: color1 regularColor: color2	"Apply these colors to all of the receiver's tabs"	highlightColor _ color1.	regularColor _ color2.	self tabMorphs do:		[:m | m highlightColor: color1.  m regularColor: color2]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 15:27'!highlightTab: aTab	self tabMorphs do: [:m |		m == aTab		ifTrue: [m color: m highlightColor]		ifFalse: [m color: m regularColor]]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/4/1998 14:58'!highlightTabFor: aBook	| theOne |	self tabMorphs do: [:m |		(m morphToInstall == aBook)				ifTrue: [m color: m highlightColor.  theOne _ m]				ifFalse: [m color: m regularColor]].	^ theOne! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 14:47'!regularColor	^ regularColor ifNil: [Color r: 0.4 g: 0.2 b: 0.6]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 13:29'!regularColor: aColor	regularColor _ aColor! !!PasteUpMorph class methodsFor: 'all' stamp: 'sw 6/30/1998 17:00'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| proto |	proto _ self new markAsPartsDonor.	proto color: Color green muchLighter; borderWidth: 1; 		borderColor: Color green darker; extent: 100 @ 80.	proto setProperty: #expandedExtent toValue: 300 @ 240.	proto beSticky.	^ proto! !!IndexTabs class reorganize!('all' defaultNameStemForInstances)!!IndexTabs class methodsFor: 'all' stamp: 'sw 7/2/1998 15:16'!defaultNameStemForInstances	"Answer a basis for names of default instances of the receiver"	^ 'tabs'! !!Player methodsFor: 'slots-user' stamp: 'sw 7/4/1998 18:06'!initialValueForSlotOfType: aType	aType == #number ifTrue: [^ (1 to: 9) atRandom].	aType == #boolean ifTrue: [^ true].	aType == #player ifTrue: [^ self costume presenter standardPlayer].	aType == #color ifTrue: [^ Color random].	aType == #string ifTrue: [^ 'abc'].	aType == #sound ifTrue: [^ 'croak'].	aType == #point ifTrue: [^ 20 @ 30].	^ nil! !!Player methodsFor: 'slots-user' stamp: 'sw 6/26/1998 18:11'!tearOffFancyWatcherFor: aSlotName	| aWatcher aTile getSel aLine aColor aTower |	aColor _ Color r: 0.903 g: 0.903 b: 1.0.	aLine _ AlignmentMorph newRow vResizing: #shrinkWrap; color: aColor.	aLine borderWidth: 1; borderColor: aColor darker.	aLine addMorphBack: (self tileReferringToSelf borderWidth: 0; typeColor: aColor; color: aColor; bePossessive).	aLine addTransparentSpacerOfSize: (4@0).	aTower _ AlignmentMorph newColumn color: aColor.	aTower addTransparentSpacerOfSize: (0 @ 1).	aTower addMorphBack: (StringMorph contents: aSlotName, ' = ' font: ScriptingSystem fontForTiles).	aLine addMorphBack: aTower.	aTile _ NumericReadoutTile new typeColor: aColor.	aWatcher _ UpdatingStringMorph new target: self.	aWatcher growable: true.	aWatcher growable: true;		getSelector: (getSel _ Utilities getterSelectorFor: aSlotName);		putSelector: (Utilities setterSelectorFor: aSlotName).	aTile addMorphBack: aWatcher.	aTile addArrows.	aTile setLiteralTo: (self perform: getSel) width: 30.	aLine addMorphBack: aTile.	aWatcher step; fitContents.	costume primaryHand attachMorph: aLine! !!Player methodsFor: 'slots-user' stamp: 'sw 7/3/1998 17:20'!tearOffWatcherFor: aSlotName	| aWatcher |	aWatcher _ UpdatingStringMorph new target: self.	aWatcher growable: true;		getSelector: (Utilities getterSelectorFor: aSlotName);		putSelector: (Utilities setterSelectorFor: aSlotName);		setNameTo: aSlotName.	aWatcher step.	costume primaryHand attachMorph: aWatcher! !!Player methodsFor: 'slots-user' stamp: 'sw 7/4/1998 18:03'!valueOfType: aType from: oldValue	"The user has changed a slot's type to aType; convert its former value, oldValue, to something of the appropriate type.  For now, does not take oldValue into account"	^ self initialValueForSlotOfType: aType! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 6/26/1998 15:30'!infoFor: aSlotName	"The user made a gesture asking for info/menu relating"	| aMenu slotSym reply aType |	aType _ self typeForSlot: aSlotName asSymbol.	aMenu _ MVCMenuMorph new.	aType == #number "later others" ifTrue:		[aMenu add: 'simple watcher' action: #simpleWatcher.		aMenu add: 'fancier watcher' action: #fancyWatcher].	(self slotInfo includesKey: (slotSym _ aSlotName asSymbol))		ifTrue:  "User slot"			[aMenu add: 'change data type' action: #chooseSlotType.			aMenu add: 'remove "', aSlotName, '"' action: #removeSlot.			aMenu add: 'rename  "', aSlotName, '"' action: #renameSlot].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: (aSlotName asString, ' (', aType, ')').	reply _  aMenu invokeAt: costume primaryHand position in: costume world.	reply == nil ifTrue: [^ self].	reply == #chooseSlotType ifTrue: [^ self chooseSlotTypeFor: slotSym].	reply == #removeSlot ifTrue: [^ self removeSlotNamed:  slotSym].	reply == #renameSlot ifTrue: [^ self renameSlot: slotSym].	reply == #simpleWatcher ifTrue: [^ self tearOffWatcherFor: slotSym].	reply == #fancyWatcher ifTrue: [^ self tearOffFancyWatcherFor: slotSym]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 6/29/1998 17:33'!okayToDestroyScriptNamed: scriptName	costume world presenter allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptInvoking: scriptName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 6/29/1998 17:33'!okayToRemoveSlotNamed: aSlotName	costume world presenter allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptReferencing: aSlotName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-execution' stamp: 'sw 7/3/1998 20:22'!runAllClosingScripts	"Run all the receiver's scripts marked as #closing.  Return a boolean indicating whether any such scripts were encountered and run"	| any |	any _ false.	self instantiatedUserScriptsDo:		[:aScriptInstantiation | aScriptInstantiation runIfClosing ifTrue: [any _ true]].	^ any! !!Player methodsFor: 'scripts-execution' stamp: 'sw 7/3/1998 20:21'!runAllOpeningScripts	"Run all the receiver's scripts marked as #opening.  Return a boolean indicating whether any such scripts were encountered and run"	| any |	any _ false.	self instantiatedUserScriptsDo:		[:aScriptInstantiation | aScriptInstantiation runIfOpening ifTrue: [any _ true]].	^ any! !!Player methodsFor: 'scripts-standard' stamp: 'sw 7/6/1998 14:05'!beep: soundName	costume world soundsEnabled		ifTrue: [self playSoundNamed: soundName]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 7/3/1998 17:35'!initiatePainting	(costume isKindOf: PasteUpMorph) ifTrue:		[costume makeNewDrawingWithin]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 7/2/1998 09:53'!standardCommandsForBank: aBank	"Return a list of typed-command arrays of the form:		<result type> <command> <argType>" 	(aBank = 1) ifTrue:		[^ #((command forward: number)			(command turn: number)			(command wearCostumeOf: player)			(command moveToward: player)			(command beep: sound))].	(aBank = 2) ifTrue:		[^ #((command show)			(command hide)			(command bounce: sound)			(command wrap)			(command goToRightOf: player)		"	(command stopProgramatically)  "			(command stopScript: string)			(command startScript: string))].	(aBank == 3 and: [costume isKindOf: PasteUpMorph]) ifTrue:		[^ #((command goToNextCard)			(command goToPreviousCard)			(command newCard)			(command deleteCard)			(command initiatePainting))].	^ #()! !!Player methodsFor: 'scripts-standard' stamp: 'sw 7/2/1998 10:04'!startScript: scriptName	scriptName ifNil: [^ self].	Symbol hasInterned: scriptName ifTrue:		[:sym | self instantiatedUserScriptsDo:			[:aUserScript | aUserScript selector == sym				ifTrue:					[aUserScript status: #ticking.					^ costume world updateStatusForAllScriptEditors]]]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 7/2/1998 10:05'!stopScript: scriptName	scriptName ifNil: [^ self].	Symbol hasInterned: scriptName ifTrue:		[:sym | self instantiatedUserScriptsDo:			[:aUserScript | aUserScript selector == sym				ifTrue:					[aUserScript status: #normal.					^ costume world updateStatusForAllScriptEditors]]]! !!Player methodsFor: 'misc' stamp: 'sw 6/25/1998 17:14'!getInfo	"Open up some kind of editing window on the receiver's class comment, perhaps -- to be hooked up, perhaps, both via the viewer thumbnail and from the player's costume's red-dot menu" 	self notYetImplemented	"self class comment editxxx"! !!Player methodsFor: 'misc' stamp: 'sw 7/5/1998 15:30'!grabPlayerIn: aWorld	aWorld primaryHand attachMorph: costume		! !!Player methodsFor: 'misc' stamp: 'sw 6/25/1998 08:42'!revealPlayerIn: aWorld	| aMorph |	(aMorph _ self costume) isInWorld ifTrue: [^ aMorph goHome].	"It's hidden somewhere; search for it"	aWorld submorphs do:		[:m | (m succeededInRevealing: self) ifTrue: [^ self]].	self inform: 'Sorry.  Unaccountably, this objectseems to be irretrievably lost'			! !!Player methodsFor: 'misc' stamp: 'sw 7/5/1998 15:27'!thumbnailMenuEvt: anEvent forMorph: aMorph	"The mouse went down in the thumbnail of a Viewer"	| aMenu aWorld |	aWorld _ aMorph world.	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'choose costume...' action: #newCostume.	aMenu add: 'tile representing me' action: #tearOffTileForSelf.	"aMenu add: 'get info...' action: #getInfo.  "	aMenu add: 'reveal this object' target: self selector: #revealPlayerIn: argument: aWorld.	aMenu add: 'grab this object' target: self selector: #grabPlayerIn: argument: aWorld.	aMenu popUpAt: aWorld primaryHand position event: aWorld primaryHand lastEvent! !!Presenter methodsFor: 'button creation' stamp: 'sw 6/17/1998 14:53'!addStandardControls	|  aControl |	self addStopStepGoButtonsTo: associatedMorph.	self addLeftHandButtons. 	self "er, add..." standardPlayer.	self addTrashCan.	"Save button"	aControl _ SimpleButtonMorph newSticky position: (380 @ (associatedMorph height - 30)).	aControl label: 'Save'; setProperty: #scriptingControl toValue: true.	aControl target: associatedMorph; actionSelector: #saveOnFile.	aControl setToAdhereToEdge: #bottom.	associatedMorph addMorph: aControl! !!Presenter methodsFor: 'button creation' stamp: 'sw 6/17/1998 14:34'!addTrashCan	| aControl aPosition |	(associatedMorph findA: TrashCanMorph) ifNotNil: [^ self].	aControl _ TrashCanMorph newSticky.	aPosition _ associatedMorph positionNear: (associatedMorph bottomRight - (58@76)) forExtent: aControl extent adjustmentSuggestion:  (-10 @ 0).	aControl position: aPosition.	associatedMorph addMorph: aControl.	aControl startStepping.	aControl setProperty: #scriptingControl toValue: true.	aControl setToAdhereToEdge: #bottomRight! !!Presenter methodsFor: 'button creation' stamp: 'sw 6/24/1998 15:14'!goButton	| aDict |	goButton == nil  ifTrue:		[aDict _ ScriptingSystem formDictionary.		goButton _ ThreePhaseButtonMorph new.		goButton image:  (aDict at: 'GoPicOn');			offImage: (aDict at: 'GoPic');			pressedImage: (aDict at: 'GoPicOn');			actionSelector: #goUp:with:; 			arguments: (Array with: nil with: goButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Go Button';			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottom;			setBalloonText:'Resume runningall paused scripts'].	goButton isInWorld ifFalse:		[associatedMorph addMorph: (goButton beRepelling position: (self stepButton topRight + (1@0)))].	^ goButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 6/25/1998 12:10'!stepButton	| aDict aPosition |	stepButton ifNil:		[aDict _ ScriptingSystem formDictionary.		stepButton _ ThreePhaseButtonMorph new.		stepButton image:  (aDict at: 'StepPicOn');			offImage: (aDict at: 'StepPic'); pressedImage:  (aDict at: 'StepPicOn');				arguments: (Array with: nil with: stepButton);			setNameTo: 'Step Button'; 			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottom;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Run every pausedscript exactly once.  Keepthe mouse button down over "Step"and everything will keep runninguntil you release it'].	stepButton isInWorld ifFalse:		[aPosition _ associatedMorph			positionNear:				(self stopButton topRight + (1@0))			 forExtent:				stepButton extent			adjustmentSuggestion:				(0 @ (stepButton height negated)).		associatedMorph addMorph: (stepButton beRepelling position: aPosition)].	^ stepButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 6/30/1998 15:54'!stopButton	| aDict aPosition anExtent |	stopButton ifNil:		[aDict _ ScriptingSystem formDictionary.		stopButton _ ThreePhaseButtonMorph new.		stopButton image:  (aDict at: 'StopPic');			offImage: (aDict at: 'StopPic'); pressedImage:  (aDict at: 'StopPicOn').		stopButton actionSelector: #stopUp:with:; 			arguments: (Array with: nil with: stopButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Stop Button'; 			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottomLeft;			setBalloonText:'Pause all ticking scripts.'].	stopButton isInWorld ifFalse:		[anExtent _ stopButton extent.		aPosition _ (associatedMorph left + 128) @ (associatedMorph bottom - 30).		aPosition _ associatedMorph positionNear: aPosition forExtent:  anExtent adjustmentSuggestion: (0 @ (anExtent y negated)).		associatedMorph addMorph: (stopButton beRepelling position: aPosition)].		^ stopButton! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 7/3/1998 12:25'!classNamesForStandardPartsBin	^	#(			(RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph PaintInvokingMorph  StringMorph)		(TabbedPalette)		(BasicButton JoystickMorph ClockMorph RecordingControlsMorph))! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 7/6/1998 14:07'!controlPanel	|  aPanel aSize |	(aPanel _ associatedMorph world allMorphs detect:		[:aMorph | ((aMorph isKindOf: PasteUpMorph) and: [aMorph hasProperty: #controlPanel])]				ifNone: [nil]) notNil			ifTrue:				[^ aPanel].	aSize _ 186 @ 50.	aPanel _ PasteUpMorph new extent: aSize.	aPanel color: Color white; padding: 9; borderWidth: 1; borderColor: Color blue.	aPanel addAllMorphs: self toggleButtons. 	aPanel laySubpartsOutInOneRow.	aPanel setProperty: #controlPanel toValue: true; setNameTo: 'Control Panel'.	^ aPanel ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 7/6/1998 14:07'!createControlPanel	associatedMorph primaryHand attachMorph: self controlPanel ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 7/3/1998 12:26'!customPagesForPartsBin	| aPage |	^ #(BookMorph WebBookMorph) collect:		[:sym |			aPage _ self newPageForStandardPartsBin.			aPage addMorphBack: (Smalltalk at: sym) authoringPrototype.			aPage addMorphBack: associatedMorph previousPageButton markAsPartsDonor.			aPage addMorphBack: associatedMorph nextPageButton markAsPartsDonor.			aPage fixLayout.			aPage]! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/30/1998 17:06'!newStandardPartsBin	| aBook aPage aSize |	aSize _ 340 @ 160.	aBook _ BookMorph new color: Color blue veryMuchLighter.	aBook borderWidth: 2.	aBook removeEverything.	aBook openToDragNDrop: false.	aBook addMorphBack: (aBook makeMinimalControlsWithColor: Color transparent title: 'Parts Bin').	self classNamesForStandardPartsBin do:		[:aList |			aPage _ self newPageForStandardPartsBin.			aList do:				[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].			aPage fixLayout.			aBook insertPage: aPage pageSize: aSize].	self customPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	self tilesPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	aBook goToPage: 1.	^ aBook! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/16/1998 16:17'!standardPalette: aPalette	standardPalette _ aPalette! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 7/4/1998 14:23'!createStandardPlayer	| aMorph |	aMorph _ ImageMorph new image: (ScriptingSystem formDictionary at: 'standardPlayer').	associatedMorph addMorphFront: aMorph.	standardPlayer _ aMorph assuredCostumee renameTo: 'dot'.	aMorph setBalloonText: 'hrrumph, grr'.	self positionStandardPlayer.	^ standardPlayer	"ScriptingSystem formDictionary at: 'standardPlayer' put: (GIFImports at: 'broom')"! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 7/4/1998 14:29'!positionStandardPlayer	standardPlayer costume position: (associatedMorph bottomLeft - (0 @ standardPlayer costume height))! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 6/17/1998 16:05'!standardPlayer	standardPlayer ifNil:		[self createStandardPlayer].	standardPlayer costume isInWorld ifFalse: [associatedMorph addMorphNearBack: standardPlayer costume].	^ standardPlayer! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 08:44'!borderColorWhenRunning	borderColorWhenRunning ifNil:		[borderColorWhenRunning _ ScriptingSystem runningPlayfieldBorderColor].	^ borderColorWhenRunning! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 15:27'!borderColorWhenStopped	borderColorWhenStopped ifNil:		[borderColorWhenStopped _ ScriptingSystem frozenPlayfieldBorderColor].	^ borderColorWhenStopped! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 08:58'!startRunningScripts	self stopButtonState: false.	self stepButtonState: false.	self goButtonState: true.	associatedMorph startRunningAll.	associatedMorph borderColor: self borderColorWhenRunning.	ThumbnailMorph recursionReset.  "needs to be done once in a while"! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/29/1998 17:37'!stepStillDown: dummy with: theButton	self stepButtonState: true.	self stopButtonState: false.	associatedMorph stepAll.	associatedMorph world displayWorld.	(Delay forMilliseconds: 200) wait.	self stepButtonState: false.	self stopButtonState: true! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 08:45'!stopRunningScripts	self stopButtonState: true.	self stepButtonState: false.	self goButtonState: false.	associatedMorph stopRunningAll.	associatedMorph borderColor: self borderColorWhenStopped! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/29/1998 17:23'!stopUp: dummy with: theButton	self flushPlayerListCache.  "catch guys not in cache but who're running"	self stopRunningScripts! !!Presenter methodsFor: 'tile support' stamp: 'sw 6/25/1998 13:29'!valueTiles	| tiles |	tiles _ OrderedCollection new.	tiles add: (5 newTileMorphRepresentative typeColor: (TilePadMorph colorForType: #number)).	tiles add: ((4 @ 9) newTileMorphRepresentative typeColor: (TilePadMorph colorForType: #point)).	tiles add: (ColorTileMorph new typeColor: (TilePadMorph colorForType: #color)).	tiles add: (TileMorph new typeColor: (TilePadMorph colorForType: #number);			setExpression: '(180 atRandom)'			label: 'random').	tiles add: RandomNumberTile new.	^ tiles! !!Presenter methodsFor: 'viewer' stamp: 'sw 7/4/1998 15:02'!viewMorph: aMorph	| aPlayer aViewer aPalette |	Sensor leftShiftDown ifFalse:		[(aPalette _ aMorph standardPalette) ifNotNil:			[^ aPalette viewMorph: aMorph]].	aPlayer _ aMorph assuredCostumee.	associatedMorph addMorph: (aViewer _ self nascentPartsViewer).	aViewer setPlayer: aPlayer.	aViewer makeAllTilesGreen.	aMorph primaryHand attachMorph: aViewer! !!Presenter methodsFor: 'misc' stamp: 'sw 7/3/1998 20:41'!drawingJustCompleted: aSketchMorph	| pal aPaintBox |	(aPaintBox _ associatedMorph paintBox) ifNotNil:		[aPaintBox delete].	(aSketchMorph pasteUpMorph hasProperty: #automaticViewing)		ifTrue:			[(pal _ aSketchMorph standardPalette) ifNotNil:				[pal viewMorph: aSketchMorph]]! !!Presenter methodsFor: 'misc' stamp: 'sw 6/17/1998 10:58'!morph: aMorph droppedIntoPasteUpMorph: aPasteUpMorph	aPasteUpMorph automaticViewing ifTrue: [aPasteUpMorph standardPalette viewMorph: aMorph]! !!Presenter methodsFor: 'misc' stamp: 'sw 6/17/1998 10:16'!standardPlayfield: aPlayfield	standardPlayfield _ aPlayfield! !!Presenter methodsFor: 'misc' stamp: 'sw 7/6/1998 22:23'!toggleButtons	| aButton aDict aList |	aDict _ ScriptingSystem formDictionary.	aList _ #(	('Balloons'	'BalloonsOn'		'BalloonsOff' 	toggleShowBalloons	balloonHelpEnabled)	('Sounds'	'SoundOn'		'SoundOff'  		toggleSoundsEnabled	soundsEnabled)	('Fence'		'FenceOn'		'FenceOff'  		toggleFence			fenceEnabled)) with:	#('Balloon Help:If green, then when thecursor pauses over an objectthat has balloon help,that help balloon is shown''Sounds:If green, sounds will be heard when appropriate; ifred, sounds are suppressed.''Fence:If green, an invisible "fence"keeps your objects from strayingoutside their containers whentheir scripts move them.')	collect:			[:q :helpString |			aButton _ ToggleButtonMorph new setNameTo: q first.			aButton onImage: (aDict at: q second);				offImage: (aDict at: q third);				pressedImage: nil;				actionSelector: q fourth;				stateSelector: q last;				actWhen: #buttonDown; target: self;				setInitialState;  "Obtains it from target"				setBalloonText: helpString;				extent: (aDict at: q second) extent.			aButton].	^ aList! !!Presenter methodsFor: 'playerList' stamp: 'sw 6/29/1998 17:17'!allExtantPlayers	"Inefficient and ultimately unacceptable, but for the current round of demos it will help keep things from stalling just because they're on hidden book pages.  Produces a list of all Player objects associated with any Morph in the tree beneath the receiver's associatedMorph.  Call #flushPlayerListCache to force recomputation."	playerList ifNotNil:		[^ playerList].	^ playerList _ (associatedMorph allMorphsIncludingBookPages select: [:m | m costumee ~~ nil] thenCollect: [:m | m costumee]) asArray! !!Presenter methodsFor: 'playerList' stamp: 'sw 6/29/1998 17:17'!flushPlayerListCache	playerList _ nil! !!EToyPlayer methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:27'!addExtrasFor: anEToyHolder inWorld: aWorld	self standardPlayer! !!Project methodsFor: 'release' stamp: 'sw 7/6/1998 11:16'!canDiscardEdits	"Don't regard a window of mine as one to be discarded as part of a 'closeUnchangedWindows' sweep"	^ false! !!Project class methodsFor: 'instance creation' stamp: 'sw 7/6/1998 11:23'!newMorphicConstruction	"ProjectView open: Project newMorphicConstruction"	| aProject |	aProject _ self newMorphic.	aProject world configureForConstruction.	^ aProject! !!ProjectView class methodsFor: 'as yet unclassified' stamp: 'sw 7/6/1998 19:44'!openAndEnter: aProject 	"Answer an instance of me for the argument, aProject. It is created on the	display screen."	| topView |	topView _ self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView window: (RealEstateAgent initialFrameFor: topView).	ScheduledControllers schedulePassive: topView controller.	aProject enter: false! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'sw 7/6/1998 11:27'!newMorphicConstruction	"Return an instance of me on a new Morphic project (in a SystemWindow)."	| proj window |	proj _ Project newMorphicConstruction.	window _ (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/6/1998 20:44'!durableChangesMenu 	Utilities durableChangesMenu! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/6/1998 20:49'!durableHelpMenu 	Utilities durableHelpMenu! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/6/1998 20:22'!durableOpenMenu 	Utilities durableOpenMenu! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/6/1998 21:00'!durableScreenMenu 	Utilities durableScreenMenu! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/6/1998 20:48'!durableWindowMenu 	Utilities durableWindowMenu! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/6/1998 11:12'!openConstructionProject	ProjectView openAndEnter: Project newMorphicConstruction! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/6/1998 18:59'!openSimpleChangeSorter	ChangeSorter new open! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 20:45'!changesMenu	"Answer a menu for changes-related items"	ChangesMenu == nil ifTrue: 		[ChangesMenu _ SelectionMenu labelList:		#(	'file out changes'			'simple change sorter'			'dual change sorter'			'browse changed methods'			'browse recent submissions'			'recent change log'			'durable changes menu')		lines: #(1 3 6)		selections: #(fileOutChanges openSimpleChangeSorter openChangeManager browseChangedMessages browseRecentSubmissions browseRecentLog durableChangesMenu)].	^ ChangesMenu"ScreenController new changesMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 20:50'!helpMenu	"Answer the help menu to be put up as a screen submenu"	^ SelectionMenu labelList:		#(	'preferences...'			'update code from server'			'about this system...'			'command-key help'			'useful expressions'			'set author initials...'			'set desktop color...'			'set display depth...'			'full screen on'			'full screen off' ) , 			(Array with: ((Preferences valueOfFlag: #disableSounds)							ifTrue: ['turn sound on']							ifFalse: ['turn sound off'])) , 		#(	'view GIF imports'			'space left'			'vm statistics' 			'durable help menu')		lines: #(2 5 8 11 14)		selections: #(editPreferences  absorbUpdatesFromServer aboutThisSystem openCommandKeyHelp openStandardWorkspace setAuthorInitials setDesktopColor setDisplayDepth fullScreenOn fullScreenOff soundOnOrOff viewGIFImports garbageCollect vmStatistics durableHelpMenu)"ScreenController new helpMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 20:54'!openMenu	"ScreenController initialize"	OpenMenu == nil ifTrue:		[OpenMenu _ SelectionMenu labelList:		#(	'browser'			'workspace'			'file list'			'transcript'			'simple change sorter'			'dual change sorter'			'project (mvc)'			'project (morphic)'			'project (morphic construction)'			'morphic window'			'morphic construction window'			'durable open menu'			)		lines: #(6 9 11)		selections: #(openBrowser openWorkspace openFileList openTranscript  openSimpleChangeSorter openChangeManager openProject  openMorphicProject  openConstructionProject  openMorphicWorld openMorphicConstructionWorld durableOpenMenu)].	^ OpenMenu"ScreenController  new openMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:05'!popUpMenuFor: aSymbol	| reply |	reply _ (self perform: aSymbol) startUp.	reply ifNil: [^ self].	self perform: reply! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:14'!presentChangesMenu	self popUpMenuFor: #changesMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentHelpMenu	self popUpMenuFor: #helpMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentOpenMenu	self popUpMenuFor: #openMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:16'!presentWindowMenu	self popUpMenuFor: #windowMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:17'!projectScreenMenu	"Answer the project screen menu."	ProjectScreenMenu == nil ifTrue:		[ProjectScreenMenu _ SelectionMenu labelList:		#(	'previous project'			'  jump to project...'			'restore display'			'open a new...'			'changes...'			'window...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit...'			'keep this menu up')		lines: #(2 3 8 12)		selections: #(returnToPreviousProject jumpToProject restoreDisplay presentOpenMenu presentChangesMenu presentWindowMenu presentHelpMenu commonRequests  snapshot saveAs snapshotAndQuit quit durableScreenMenu)].	^ ProjectScreenMenu"ScreenController new projectScreenMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 20:48'!windowMenu	"Answer a menu for windows-related items.  "	^ SelectionMenu labelList:		#(	'find window...'			'find changed browsers...'			'find changed windows...'			'collapse all windows'			'expand all windows'			'close unchanged windows') ,			(Array with: (StandardSystemView cachingBits							ifTrue: ['dont save bits (compact)']							ifFalse: ['save bits (fast)'])				with: ((Preferences valueOfFlag: #reverseWindowStagger)							ifTrue: ['tile windows']							ifFalse: ['stagger windows'])				with: 'durable window menu')		lines: #(3 5 6 8)		selections: #(findWindow chooseDirtyBrowser chooseDirtyWindow				collapseAll expandAll				closeUnchangedWindows				fastWindows changeWindowPolicy				durableWindowMenu)"ScreenController new windowMenu startUpScreenController initialize"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:06'!yellowButtonActivity	"Put up the alternate yellow button activity if appropriate, else defer to the old way.  2/7/96 sw	 : if shift key down, do find window.	 : project screen menu different from regular (top) screen menu"	| reply aMenu |	Sensor leftShiftDown ifTrue: [^ self findWindow].	aMenu _ self projectScreenMenu.	(reply _ aMenu startUp) isNil ifTrue: [^ super controlActivity].	(#(changesMenu helpMenu openMenu windowMenu miscMenu) includes: reply)		ifTrue:  "submenu called for"			[^ self popUpMenuFor: reply].	^ self perform: reply! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 6/23/1998 11:59'!chooseTrigger	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"	| aMenu reply standardStati aScriptInstantiation |	standardStati _ #(normal paused ticking mouseDown mouseStillDown mouseUp mouseEnter mouseLeave opening closing "keyStroke").	aScriptInstantiation _ self scriptInstantiation.	aMenu _ SelectionMenu labelList:  #(		'normal -- run when called'		'paused -- ready to run all the time'		'ticking -- run all the time'		'mouseDown -- run when mouse goes down on me'		'mouseStillDown -- while mouse still down'		'mouseUp -- when mouse comes back up'		'mouseEnter -- when mouse enters me with button up'		'mouseLeave -- when mouse exits me with button up'		'opening -- when I am being opened'		'closing -- when I am being closed'	"	'keyStroke -- run when user hits a key' "		)		lines: #(1 3 8  "9")		selections: standardStati.	reply _ aMenu startUpWithCaption: 'When should this script run?'.	(reply == #keyStroke) ifTrue: [^ self inform: 'user-scripted fieldingof keystrokes is notyet available.'].	reply ifNotNil: 		[aScriptInstantiation status: reply.  "Gets event handlers fixed up"		reply == #ticking ifTrue: [playerScripted costume startStepping].		self updateStatus]! !!ScriptEvaluatorMorph methodsFor: 'all' stamp: 'sw 7/4/1998 18:02'!wantsDroppedMorph: aMorph	^ false   "though later we could drop onto formal args in the header"! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 7/3/1998 20:20'!runIfClosing	| result |	(result _ status == #closing) ifTrue:		[player perform: selector].	^ result! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 7/3/1998 20:19'!runIfOpening	| result |	(result _ status == #opening) ifTrue:		[player perform: selector].	^ result! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 13:47'!comment	comment ifNil: [^ ''] ifNotNil: [^ comment].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:12'!comment: aString	aString isEmpty		ifTrue: [comment _ nil]		ifFalse: [comment _ aString].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 13:45'!contentsMorph	^ contentsMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/25/1998 12:41'!saveMorph: aMorph author: authorString	"Save the given morph as this page's contents. Update its thumbnail and inform references to this URL that the page has changed."	"Details: updateThumbnail releases the cached state of the saved page contents after computing the thumbnail."	| n |	contentsMorph _ aMorph.	n _ aMorph knownName.	n ifNotNil: [self title: n].	creationAuthor ifNil: [		creationAuthor _ authorString.		creationTime _ Time totalSeconds].	lastChangeAuthor _ authorString.	lastChangeTime _ Time totalSeconds.	self updateThumbnail.	self postChangeNotification.! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 17:45'!thumbnail	^ thumbnail! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 13:47'!title	title ifNil: [^ ''] ifNotNil: [^ title].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:12'!title: aString	aString isEmpty		ifTrue: [title _ nil]		ifFalse: [title _ aString].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/25/1998 10:51'!url	url ifNil: [^ ''] ifNotNil: [^ url].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/25/1998 10:51'!url: aString	aString isEmpty		ifTrue: [url _ nil]		ifFalse: [url _ aString].! !!SqueakPage methodsFor: 'private' stamp: 'jm 6/25/1998 12:14'!postChangeNotification	"Inform all thumbnails and books that this page has been updated."	URLMorph allInstancesDo: [:m | m pageHasChanged: self].	WebBookMorph allInstancesDo: [:m | m pageHasChanged: self].! !!SqueakPage methodsFor: 'private' stamp: 'jm 6/18/1998 11:31'!updateThumbnail	"Update my thumbnail from my morph."	| f scale scaleX scaleY shrunkF |	contentsMorph ifNil: [thumbnail _ nil. ^ self].	f _ contentsMorph imageForm.	scaleX _ MaxThumbnailWidthOrHeight asFloat / f height.	scaleY _ MaxThumbnailWidthOrHeight asFloat/ f width.	scale _ scaleX min: scaleY.  "choose scale that maintains aspect ratio"	shrunkF _ (f magnify: f boundingBox by: scale@scale smoothing: 2).	thumbnail _ Form extent: shrunkF extent depth: 8.  "force depth to be 8"	shrunkF displayOn: thumbnail.	contentsMorph allMorphsDo: [:m | m releaseCachedState].! !!SqueakPage class methodsFor: 'all' stamp: 'jm 6/18/1998 11:15'!initialize	"SqueakPage initialize"	MaxThumbnailWidthOrHeight _ 60.! !!SqueakPage class methodsFor: 'all' stamp: 'sw 7/6/1998 11:49'!newURLAndPageFor: aMorph	"Create a new SqueakPage whose contents is the given morph. Assign a URL for that page, record it in the page cache, and answer its URL."	| pg newURL stamp |	pg _ self new.	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: aMorph author: stamp.	newURL _ SqueakPageCache generateURL.	SqueakPageCache atURL: newURL put: pg.	^ newURL ! !!SqueakPageCache commentStamp: 'sw 7/6/1998 23:33' prior: 0!A global cache of web pages known to this Squeak image. All pages currently live only in memory; management of pages stored on servers and the local disk will be added later.Since there is a single, global page cache, it is implemented entirely as class methods.!!SqueakPageCache class methodsFor: 'class initialization' stamp: 'jm 6/16/1998 18:12'!initialize	"SqueakPageCache initialize"	(PageCache notNil and: [PageCache size > 0]) ifTrue: [		(self confirm: 'Are you certain that you wish to delete all SqueakPages?')			ifFalse: [^ self]].	NextURL _ 1.	PageCache _ Dictionary new: 100.! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/25/1998 11:06'!allURLs	"Answer a collection of URLs for all pages in the cache."	^ PageCache keys! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/25/1998 11:07'!atURL: aURLString	"Answer the page corresponding to this URL. Evaluate the given block if there is no entry for the given URL."	^ PageCache at: aURLString		ifAbsent: [self error: 'no page with the given URL in the cache']! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/16/1998 15:39'!atURL: aURLString ifAbsent: failBlock	"Answer the page corresponding to this URL. Evaluate the given block if there is no entry for the given URL."	^ PageCache at: aURLString ifAbsent: failBlock! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/25/1998 11:07'!atURL: aURLString put: aSqueakPage	"Store the given page in the cache entry for the given URL."	aSqueakPage url: aURLString.	PageCache at: aURLString put: aSqueakPage.! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/25/1998 11:08'!generateURL	"Generate an unused URL for an in-memory page."	"SqueakPageCache generateURL"	| url |	NextURL ifNil: [NextURL _ 1].	NextURL _ NextURL + 1.	url _ 'memoryPage', NextURL printString.	[PageCache includesKey: url] whileTrue: [		NextURL _ NextURL + 1.		url _ 'memoryPage', NextURL printString].	^ url! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/16/1998 18:12'!removeURL: aURLString	"Remove the cache entry for the given URL. Do nothing if it has no cache entry."	PageCache removeKey: aURLString ifAbsent: [].! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'jm 6/25/1998 11:11'!deleteUnreferencedPages	"Remove any pages that are not current referred to by any book or URL morph."	"Details: Since unreferenced pages could refer to other pages, this process is iterated until no unreferenced pages can be found. It currently does not collect cycles."	"SqueakPageCache deleteUnreferencedPages"	| unreferenced |	[true] whileTrue: [		Smalltalk garbageCollect.		unreferenced _ PageCache keys.		URLMorph allInstancesDo: [:m | unreferenced remove: m url ifAbsent: []].		WebBookMorph allInstancesDo: [:book |			book urls do: [:url | unreferenced remove: url ifAbsent: []]].		unreferenced size = 0 ifTrue: [^ self].		unreferenced do: [:url | PageCache removeKey: url ifAbsent: []]].! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'jm 6/25/1998 13:00'!releaseCachedStateOfPages	"Note: This shouldn't be necessary if we are doing a good job of releasing cached state as we go. If running this doesn't do very much, we're doing well!!"	"SqueakPageCache releaseCachedStateOfPages"	| memBytes |	memBytes _ Smalltalk garbageCollect.	PageCache do: [:pg |		pg contentsMorph allMorphsDo: [:m | m releaseCachedState]].	^ (Smalltalk garbageCollect - memBytes) printString, ' bytes recovered'! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 6/29/1998 18:02'!frozenPlayfieldBorderColor	^ Color red! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 6/30/1998 09:50'!runningPlayfieldBorderColor	^ Color green! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 7/4/1998 14:36'!patchInNewStandardPlayerForm	"ScriptingSystem patchInNewStandardPlayerForm"	self formDictionary at: 'standardPlayer' put:		(Form extent: 3@3	depth: 16 fromArray: #( 17969 0 1177634353 1177616384 17969 0) offset: 0@0)! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 7/6/1998 22:47'!wordingForOperator: aString	| toTest |	toTest _ aString asString.	#(	(forward:				'forward by')		(turn:					'turn by')		(beep:					'make sound')		(bounce:				'bounce')		(stopProgramatically	'stop')		(stopScript				'stop script')		(wearCostumeOf:		'look like')		(moveToward:			'move toward')		(goToRightOf:			'align after')		(stopScript:				'stop script')		(startScript:				'start script')		(max:					'max')		(min:					'min')		(=						'=?'))	do:		[:pair | toTest = pair first ifTrue: [^ pair second]].	^ toTest! !!String methodsFor: 'displaying' stamp: 'sw 7/3/1998 18:31'!newTileMorphRepresentative	^ TileMorph new setLiteral: self! !!TabMorph commentStamp: 'sw 7/6/1998 23:33' prior: 0!A tab in a palette.  The contents is the name to be shown.  If it represents a book, that book is pointed to in my morphToInstall.!!TabMorph reorganize!('all' morphToInstall morphToInstall: representsBook tabSelected)!!TabMorph methodsFor: 'all' stamp: 'sw 7/2/1998 15:28'!morphToInstall	^ morphToInstall! !!TabMorph methodsFor: 'all' stamp: 'sw 7/2/1998 15:38'!morphToInstall: m	morphToInstall _ m.	self contents: m externalName.	self actionSelector: #tabSelected.	self target: self! !!TabMorph methodsFor: 'all' stamp: 'sw 7/3/1998 11:42'!representsBook	^ morphToInstall ~~ nil! !!TabMorph methodsFor: 'all' stamp: 'sw 7/3/1998 20:25'!tabSelected	"Called when the receiver is hit.  First, bulletproof against someone having taken the structure apart.  My own action basically requires that my grand-owner be aTabbedPalette"	costumee ifNotNil: [costumee runAllOpeningScripts ifTrue: [^ self]].	(owner isKindOf: IndexTabs) ifFalse: [^ self beep].	(owner owner isKindOf: TabbedPalette) ifFalse: [^ self beep].	owner owner selectTab: self! !!TabMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/2/1998 16:48'!defaultNameStemForInstances	^ 'tab'! !!TabMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/3/1998 11:49'!forBook: aBook	^ self new morphToInstall: aBook! !!TabSorterMorph commentStamp: 'sw 7/6/1998 23:33' prior: 0!A sorter for the tabs of a TabbedPalette!!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:05'!acceptSort	"Reconstitute the palette based on what is found in the sorter"	| rejects toAdd oldOwner tabsToUse |	tabsToUse _ OrderedCollection new.	rejects _ OrderedCollection new.	pageHolder submorphs doWithIndex: [:m :i |		toAdd _ nil.		(m isKindOf: BookMorph) ifTrue:			[toAdd _ TabMorph forBook: m].		(m isKindOf: TabTokenMorph) ifTrue:			[toAdd _ m tabRepresented contents: m contents].		toAdd ifNil:				[rejects add: m]			ifNotNil:				[tabsToUse add: toAdd]].	tabsToUse size == 0 ifTrue: [^ self inform: 'Sorry, must have at least one tab'].	book newTabs: tabsToUse.	oldOwner _ owner.	self delete.	oldOwner addMorphFront: book! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 15:24'!addControls	| b r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Okay';	actionSelector: #acceptSort).	r addMorphBack: (b fullCopy label: 'Cancel';	actionSelector: #cancelSort).	self addMorphFront: r.! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:06'!cancelSort	| oldOwner |	oldOwner _ owner.	self delete.	oldOwner addMorphFront: book! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 18:51'!initialize	super initialize.	self removeAllMorphs.	self extent: 300@100.	pageHolder _ PasteUpMorph new.	pageHolder resizeToFit: true; autoLineLayout: true; fixLayout; layoutChanged.	pageHolder extent: self extent - borderWidth.	pageHolder padding: 8.	pageHolder cursor: 0.	self addControls.	self addMorphBack: pageHolder! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/5/1998 15:57'!sortTabsFor: aTabbedPalette	| actualTabs |	actualTabs _ aTabbedPalette tabMorphs.	self book: aTabbedPalette morphsToSort:		(actualTabs collect:			[:aTab | TabTokenMorph new forTab: aTab]).	self position: aTabbedPalette position.	self setNameTo: 'Tab Sorter for ', aTabbedPalette externalName.	aTabbedPalette owner addMorphFront: self! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:30'!substituteForMorph: aMorph beingDroppedOn: aPage	(aMorph isKindOf: BookMorph) ifFalse: [^ nil].	^ TabTokenMorph new forTab: (TabMorph new morphToInstall: aMorph)! !!TabTokenMorph commentStamp: 'sw 7/6/1998 23:33' prior: 0!An element of a TabSorter.!!TabTokenMorph reorganize!('all' forTab: justDroppedInto:event: tabRepresented)!!TabTokenMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:02'!forTab: aTab	tabRepresented _ aTab.	self contents: aTab contents! !!TabTokenMorph methodsFor: 'all' stamp: 'sw 7/5/1998 15:51'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	super justDroppedInto: aMorph event: anEvent.	self world ifNotNil: [self world abandonAllHalos]! !!TabTokenMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:03'!tabRepresented	^ tabRepresented! !!TabbedPalette commentStamp: 'sw 7/6/1998 23:33' prior: 0!A structure of tabs and associated books.  Pressing a tab brings into focus the associated book.  Some tabs can have simple actions rather than books as their focus -- in this case, the palette is cleared and the action taken. !!TabbedPalette reorganize!('initialization' addTabForBook: addTabNamed:color:atIndex: defaultPageSize initialize newTabs: setInitialState)('scraps tab' addScrapsTab addToTrash: hasScrapsTab scrapsBook)('viewer tab' addViewerTab hasViewerTab selectViewerTab viewMorph:)('palette menu' addBookMenuItemsTo:hand: addMenuTab addScriptableTab hasMenuTab showPaletteMenu)('misc menu items' becomeStandardPalette recolorTabs showNoPalette sortTabs:)('user-interface' repelsMorph:event: selectTab: selectTabNamed: selectTabOfBook: tabMorphs wantsDroppedMorph:event:)('miscellaneous' currentPalette showPageTurningFeedbackFromOrigin:ascending: succeededInRevealing: tabsMorph)!!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/2/1998 17:52'!addTabForBook: aBook	| aTab |	aTab _ tabsMorph addTabForBook: aBook.	pages add: aBook.	currentPage ifNil: [currentPage _ aBook].	^ aTab! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:19'!addTabNamed: str color: aColor atIndex: anIndex	| aBook |	aBook _ BookMorph new setNameTo: str.	aBook color: aColor.	self addTabForBook: aBook! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/3/1998 18:05'!defaultPageSize	^ 156 @ 232! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/3/1998 18:10'!initialize	super initialize.	pageSize _ self defaultPageSize.	self removeEverything.	color _ Color r: 0.0 g: 0.6 b: 0.6.  "background for menu bar, primarily"	borderWidth _ 1.	tabsMorph _ IndexTabs new.	self addMorph: tabsMorph! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/4/1998 14:57'!newTabs: tabsList	"Reconstitute the palette based on info in the tabs list"	| itsBook color1 color2 |	pages _ pages species new.	tabsMorph ifNotNil:		[color1 _ tabsMorph  highlightColor.		color2 _ tabsMorph regularColor.		tabsMorph delete].	tabsMorph _ IndexTabs new.	self addMorphFront: tabsMorph.	color1 ifNotNil:		[tabsMorph highlightColor: color1 regularColor: color2].	currentPage ifNotNil:		[currentPage delete.		currentPage _ nil].	tabsList do:		[:aTab |			tabsMorph addTab: aTab.			(itsBook _ aTab morphToInstall) ifNotNil:					[pages add: itsBook.					currentPage ifNil: [currentPage _ itsBook]]].! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 9/14/97 01:12'!setInitialState	super setInitialState.	inset _ 0.	pageSize _ 156 @ 232! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 7/3/1998 16:55'!addScrapsTab	| scrapsBook |	scrapsBook _ BookMorph new pageSize: pageSize; setNameTo: 'scraps'.	scrapsBook removeEverything; insertPage.	scrapsBook setProperty: #scraps toValue: true.	self addTabForBook: scrapsBook.	self standardPalette ifNil:		[self becomeStandardPalette]! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 7/3/1998 18:13'!addToTrash: aMorph	"Paste the object onto a page of my Scraps tab. This is only called in situations where a presenter has a standard palette specified."	| aPage aBook |	self hasScrapsTab ifFalse:		[self addScrapsTab].	aBook _ self scrapsBook.	aMorph position: aBook pages first position + (0@40).	aBook pages do: [:pp | 		(pp submorphs size = 1 and: [pp hasProperty: #trash]) ifTrue:  "perhaps remove that property here"			["page is blank"			^ pp addMorph: aMorph]].	aPage _ aBook insertPageLabel: 'From Trash Can:'		morphs: (Array with: aMorph).	aPage setProperty: #trash toValue: true! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 6/24/1998 18:36'!hasScrapsTab	pages detect: [:p | (p hasProperty: #scraps)] ifNone: [^ false].	^ true! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 6/24/1998 18:42'!scrapsBook	^ pages detect: [:p | p hasProperty: #scraps] ifNone: [nil]! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 7/3/1998 11:18'!addViewerTab	| viewerBook |	viewerBook _ ViewerBook new removeEverything setNameTo: 'view'.	self addTabForBook: viewerBook.	self standardPalette ifNil:		[self becomeStandardPalette]! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 6/16/1998 16:02'!hasViewerTab	pages detect: [:p | (p isKindOf: ViewerBook)] ifNone: [^ false].	^ true! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 7/3/1998 11:17'!selectViewerTab	| viewerTab |	viewerTab _ tabsMorph submorphs detect: [:m | m morphToInstall isKindOf: ViewerBook] ifNone: [^ self beep].	^ self selectTab: viewerTab! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 7/6/1998 17:48'!viewMorph: aMorph	"The receiver is expected to have a viewer tab; select it, and target it to aMorph"	self hasViewerTab ifFalse: [self addViewerTab].	self selectViewerTab.	currentPage setPlayer: aMorph assuredCostumee.	self presenter flushPlayerListCache.  "A precaution in case aMorph is no longer in world, owing to palette sharing.  This is not very attractive"	self layoutChanged.	self ownerChanged.! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/3/1998 17:12'!addBookMenuItemsTo: aCustomMenu hand: aHandMorph	self hasMenuTab		ifFalse:			[aCustomMenu add: 'add palette menu' action: #addMenuTab].	aCustomMenu add: 'become the Standard palette' action: #becomeStandardPalette! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/3/1998 21:00'!addMenuTab	| aTab |	aTab _ self tabsMorph addActionTabWithTitle: '<>'.	aTab target: self; actionSelector: #showPaletteMenu;		setProperty: #tabsMenu toValue: true;		actWhen: #buttonDown! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/3/1998 21:03'!addScriptableTab	| aTab |	aTab _ tabsMorph addActionTabWithTitle: 'aTab'.	aTab actionSelector: #tabSelected; target: aTab.	^ aTab! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/3/1998 17:11'!hasMenuTab	^ self hasSubmorphWithProperty: #tabsMenu! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/3/1998 20:54'!showPaletteMenu	| aMenu evt |	evt _ self primaryHand lastEvent.	aMenu _ MenuMorph new defaultTarget: self.	self currentPalette ifNotNil:		[aMenu add:  'clear' action: #showNoPalette.		aMenu addLine].	aMenu add:  'sort tabs' action: #sortTabs:.	aMenu add:  'choose new colors for tabs' action: #recolorTabs.	aMenu add:  'make me the Standard palette' action: #becomeStandardPalette.	aMenu addLine.	self hasViewerTab ifFalse:	[aMenu add:  'add "view" tab' action: #addViewerTab].	self hasScrapsTab ifFalse:	[aMenu add:  'add "scraps" tab' action: #addScrapsTab].	aMenu add: 'add a tab for me to script' action: #addScriptableTab.	aMenu addTitle: 'Palette'.	aMenu popUpAt: self cursorPoint event: evt! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 6/16/1998 16:17'!becomeStandardPalette	self presenter standardPalette: self! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 7/4/1998 14:12'!recolorTabs	"Prompt the user for new on and off colors for tabs"	| onColor offColor |	self inform: 'Choose the ''on'' color'.	onColor _ Color fromUser.	self inform: 'Okay, now please choosethe ''off'' color'.	offColor _ Color fromUser.	tabsMorph highlightColor: onColor regularColor: offColor.	currentPage ifNotNil:		[tabsMorph highlightTabFor: currentPage]! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 7/3/1998 18:49'!showNoPalette	| aMenuTab |	currentPage ifNotNil: [currentPage delete].	currentPage _ nil.	(aMenuTab _ tabsMorph submorphWithProperty: #tabsMenu) ifNotNil:		[tabsMorph highlightTab: aMenuTab].	self changed! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 7/3/1998 18:17'!sortTabs: evt	TabSorterMorph new sortTabsFor: self.  "it directly replaces me"	self delete! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 10/18/97 18:03'!repelsMorph: aMorph event: ev	^ openToDragNDrop not! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/3/1998 11:16'!selectTab: aTab	| currentPalette |	self currentPalette ifNotNil: [self currentPalette currentPlayerDo:		[:aPlayer | aPlayer runAllClosingScripts]].	tabsMorph selectTab: aTab.	self goToPageMorph: aTab morphToInstall.	(currentPalette _ self currentPalette) ifNotNil:		[currentPalette layoutChanged.		currentPalette currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts]]! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/5/1998 15:38'!selectTabNamed: aName	"For bkwrd compat with etoys"	| aTab |	aTab _ self tabMorphs detect: [:m | m contents = aName] ifNone: [nil].	aTab ifNil: [self error: 'tab not found'].	tabsMorph selectTab: aTab! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/5/1998 15:40'!selectTabOfBook: aBook	self tabMorphs do:		[:aTab | aTab morphToInstall == aBook ifTrue: [^ self selectTab: aTab]]! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/5/1998 15:38'!tabMorphs	^ tabsMorph tabMorphs! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 5/31/1998 00:20'!wantsDroppedMorph: aMorph event: evt	(tabsMorph bounds containsPoint: evt cursorPoint) ifTrue:		[^ false  "unless it's a book, perhaps, someday"].	^ currentPage wantsDroppedMorph: aMorph event: evt! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'sw 6/23/1998 12:31'!currentPalette	"A stylistic convenience to reduce confusion caused by the fact that a palette is a book of books"	^ currentPage! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'sw 9/30/97 10:10'!showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending	(PageFlipSoundOn and: [oldOrigin ~~ nil])		ifTrue:			[Display fadeImageHorFine: currentPage imageForm at: oldOrigin]! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'sw 7/5/1998 15:40'!succeededInRevealing: aPlayer	| result |	result _ super succeededInRevealing: aPlayer.	result ifTrue:		["BookMorph code will have called goToPageNumber:; here, we just need to get the tab selection right here"		self selectTabOfBook: self currentPalette].	^ result! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'jm 11/16/97 17:59'!tabsMorph	^ tabsMorph! !!TabbedPalette class methodsFor: 'all' stamp: 'sw 7/4/1998 16:36'!authoringPrototype	| aTabbedPalette aBook aTab |	aTabbedPalette _ self new markAsPartsDonor.	aTabbedPalette pageSize: 180 @ 88.	aTabbedPalette tabsMorph highlightColor: Color red regularColor: Color blue.	aTabbedPalette addMenuTab.	aBook _ BookMorph new setNameTo: 'one'; pageSize: aTabbedPalette pageSize.	aBook color: Color blue muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: EllipseMorph authoringPrototype.	aTab _ aTabbedPalette addTabForBook: aBook.	aBook _ BookMorph new setNameTo: 'two'; pageSize: aTabbedPalette pageSize.	aBook color: Color red muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: CurveMorph authoringPrototype.	aTabbedPalette addTabForBook: aBook.	aTabbedPalette selectTab: aTab.	aTabbedPalette beSticky.	^ aTabbedPalette! !!TabbedPalette class methodsFor: 'all' stamp: 'sw 6/3/1998 21:27'!defaultNameStemForInstances	^ 'tabbedPalette'! !!TabsMorph methodsFor: 'all' stamp: 'sw 7/2/1998 14:11'!buttonOffColor	^ buttonOffColor ifNil: [Color r: 0.4 g: 0.2 b: 0.6]! !!TabsMorph methodsFor: 'all' stamp: 'sw 7/1/1998 16:17'!buttonOnColor	^ buttonOnColor ifNil: [Color red]! !!TabsMorph methodsFor: 'all' stamp: 'sw 7/1/1998 16:19'!buttonOnColor: color1 buttonOffColor: color2	"Apply these colors to all of the receiver's tabs"	buttonOnColor _ color1.	buttonOffColor _ color2.	self stringButtonSubmorphs do:		[:m | m buttonOnColor: color1.  m buttonOffColor: color2]! !!TextMorph methodsFor: 'containment' stamp: 'sw 6/25/1998 10:44'!ownerChanged	super ownerChanged.	container ifNotNil:		[self releaseParagraph]! !!ThumbnailMorph methodsFor: 'all' stamp: 'sw 6/24/1998 17:05'!drawOn: aCanvas	"Draw a small view of a morph in another place. Guard against infinite recursion if that morph has a thumbnail of itself inside."	| actualViewee diag viewedMorphBox myBox scale c shrunkForm |	super drawOn: aCanvas.	actualViewee _ self actualViewee.	actualViewee ifNil: [^ self]. 	actualViewee isInWorld		ifTrue:			[(RecursionDepth _ RecursionDepth + 1) > RecursionMax ifTrue: [^ self].			(actualViewee isKindOf: SketchMorph)				ifTrue:					[diag _ actualViewee form extent r asInteger.					viewedMorphBox _						(actualViewee bounds center - (diag // 2)) extent: diag@diag]				ifFalse:					[viewedMorphBox _ actualViewee fullBounds].			myBox _ self innerBounds.			scale _ myBox width / (viewedMorphBox width max: viewedMorphBox		height).			c _ FormCanvas extent: viewedMorphBox extent depth: aCanvas depth.			c _ c copyOffset: viewedMorphBox topLeft negated.			actualViewee fullDrawOn: c.		"recursion happens here"			shrunkForm _ c form magnify: c form boundingBox by: scale smoothing: 1.			lastFormShown _ shrunkForm.			RecursionDepth _ RecursionDepth - 1]		ifFalse:			[lastFormShown ifNotNil: [shrunkForm _ lastFormShown]].	shrunkForm ifNotNil:		[aCanvas image: shrunkForm at: self center - shrunkForm boundingBoxcenter]! !!TileMorph methodsFor: 'initialization' stamp: 'sw 7/2/1998 09:50'!setLiteral: anObject	| m |	type _ #literal.	m _ UpdatingStringMorph contents: ' ' font: ScriptingSystem fontForTiles.  "BUT this doesn't do it, damnit"	m target: self; getSelector: #literal; putSelector: #literal:.	(anObject isKindOf: String) ifTrue: [m useStringFormat].	self addMorph: m.	self literal: anObject.! !!TileMorph methodsFor: 'accessing' stamp: 'sw 7/4/1998 18:01'!resultType	type == #literal ifTrue:		[(literal isKindOf: Number) ifTrue: [^ #number].		(literal isKindOf: String) ifTrue: [^ #string].		(literal isKindOf: Point) ifTrue: [^ #point].		(literal isKindOf: String) ifTrue: [^ #string].		(literal isKindOf: Boolean) ifTrue: [^ #boolean].		(literal isKindOf: Morph) ifTrue: [^ #costume]  "This last one dubious!!"].	type == #expression ifTrue:		[^ #number].	type == #objRef ifTrue: [^ #player].	^ #unknown! !!TileMorph methodsFor: 'private' stamp: 'sw 6/26/1998 16:26'!updateLiteralLabel	"now works for operator tiles also"	|  desiredW leader myLabel |	(myLabel _ self labelMorph) ifNil: [^ self].	myLabel contents:		(type == #literal			ifTrue:				[literal stringForReadout] 			ifFalse: [operatorReadoutString 				ifNil:		[ScriptingSystem wordingForOperator: operatorOrExpression]				ifNotNil:  	[operatorReadoutString]]).	leader _ (upArrow ifNil: [0] ifNotNil: [UpArrowAllowance]) + 4.	desiredW _ leader + myLabel width.	suffixArrow ifNotNil: [desiredW _ desiredW + SuffixArrowAllowance].	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	myLabel position: (self left + (leader + 0)) @ (bounds top + 3); fullBounds.	suffixArrow ifNotNil: [suffixArrow align: suffixArrow topRight with:				bounds topRight + (-2 @ (self height // 2)) - (0 @ (suffixArrow height // 2))].	self changed! !!TrashCanMorph methodsFor: 'dropping' stamp: 'sw 6/24/1998 18:33'!acceptDroppingMorph: aMorph event: evt	| palette |	self world soundsEnabled ifTrue: [self class playDeleteSound].	evt hand endDisplaySuppression.	self state: #off.	aMorph delete.	palette _ self standardPalette.	palette ifNotNil: [palette addToTrash: aMorph].! !!URLMorph commentStamp: 'sw 7/6/1998 23:33' prior: 0!This morph represents a URL for a SqueakPage. It displays the thumbnail for the associated page, if available. Used in page sorters and for bookmarks.This morph has several options:  a. It can act like a thumbnail for sorting (in which case it can be picked up and dragged) or it acts as a bookmark (in which case clicking on it activates it).  b. If it is a bookmorph, it can act on a particular book or it can act on whatever book it happens to be in at the time. The former is primarily used for making a graphical page index allowing random access to any page in the book.!!URLMorph methodsFor: 'initialization' stamp: 'jm 6/17/1998 07:16'!initialize	super initialize.	color _ Color lightGray.	isBookmark _ false.! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 21:49'!book	^ book! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 21:49'!book: aWebBookMorph	"Set the book morph to be invoked when this url is used as a bookmark. If nil, then this bookmark operates on whatever book it is currently in."	book _ aWebBookMorph.! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 07:16'!isBookmark	^ isBookmark! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 07:17'!isBookmark: aBoolean	"Make this morph behave as a clickable bookmark if the argument is true."	isBookmark _ aBoolean.! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:07'!page	"Answer the cached page that this morph represents."	^ page! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 07:05'!url	"Answer the URL for the page that this morph represents."	^ url! !!URLMorph methodsFor: 'drawing' stamp: 'jm 6/25/1998 11:14'!drawOn: aCanvas	"Draw thumbnail for my page, if it is available. Otherwise, just draw a rectangle." 	| thumbnail |	aCanvas frameRectangle: bounds width: 1 color: Color blue.	thumbnail _ self thumbnailOrNil.	thumbnail		ifNil: [aCanvas fillRectangle: (bounds insetBy: 1) color: color]		ifNotNil: [aCanvas image: thumbnail at: bounds origin + 1].! !!URLMorph methodsFor: 'event handling' stamp: 'jm 6/17/1998 07:18'!handlesMouseDown: evt	^ isBookmark! !!URLMorph methodsFor: 'event handling' stamp: 'jm 6/17/1998 21:50'!mouseDown: evt	| bk |	book		ifNil: [bk _ self enclosingBook]		ifNotNil: [bk _ book].	bk ifNotNil: [bk goToURL: url].! !!URLMorph methodsFor: 'updating' stamp: 'jm 6/17/1998 14:15'!pageHasChanged: aSqueakPage	"The given page has changed. Update this morph if it refers to the given page."	| thumbnail |	page == aSqueakPage ifFalse: [^ self].  "this change does not affect me"	thumbnail _ self thumbnailOrNil.	thumbnail ifNotNil: [		self extent: (thumbnail extent + 2).		self changed].! !!URLMorph methodsFor: 'private' stamp: 'jm 6/17/1998 07:28'!enclosingBook	"Answer the inner-most book that contains this morph, or nil if there isn't one."	| m |	m _ owner.	[m == nil] whileFalse: [		(m isKindOf: WebBookMorph) ifTrue: [^ m].		m _ m owner].	^ nil! !!URLMorph methodsFor: 'private' stamp: 'jm 6/17/1998 14:21'!setURL: aURLString page: aSqueakPage	"Initialize the receiver for the given URL and page."	url _ aURLString.	page _ aSqueakPage.	self pageHasChanged: page.! !!URLMorph methodsFor: 'private' stamp: 'jm 6/17/1998 07:05'!thumbnailOrNil	"Answer the thumbnail Form for the page this morph represents. Answer nil if no thumbnail is available."	page ifNil: [^ nil].	^ page thumbnail! !!URLMorph class methodsFor: 'instance creation' stamp: 'jm 6/17/1998 07:35'!newBookmarkForURL: aURLString	^ (self newForURL: aURLString) isBookmark: true! !!URLMorph class methodsFor: 'instance creation' stamp: 'jm 6/17/1998 07:09'!newForURL: aURLString	| pg |	pg _ SqueakPageCache		atURL: aURLString		ifAbsent: [^ self new setURL: aURLString page: nil].	^ self new setURL: aURLString page: pg! !!UpdatingStringMorph methodsFor: 'initialization' stamp: 'sw 6/26/1998 07:41'!initialize	super initialize.	format _ #default.  "formats: #string, #default"	target _ getSelector _ putSelector _ nil.	growable _ true! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'sw 6/26/1998 07:31'!step	| s |	hasFocus ifFalse:		["update contents, but only if user isn't editing this string"		s _ self readFromTarget.		s = contents ifFalse:			[self updateContentsFrom: s]]! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'sw 6/26/1998 07:31'!updateContentsFrom: aValue	self growable		ifTrue:			[self contents: aValue]		ifFalse:			[self contentsClipped: aValue]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 6/26/1998 07:22'!addCustomMenuItems: menu hand: aHandMorph	| prefix |	super addCustomMenuItems: menu hand: aHandMorph.	prefix _ self growable		ifTrue:			['stop']		ifFalse:			['start'].	menu add: prefix, ' being growable' action: #toggleGrowability! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 6/26/1998 07:47'!toggleGrowability	growable _ self growable not.	self updateContentsFrom: self readFromTarget.	growable ifTrue: [self fitContents]! !!Utilities class methodsFor: 'identification' stamp: 'sw 7/6/1998 11:49'!authorInitialsPerSe	"Answer the currently-prevailing author initials, such as they, empty or not"	^ AuthorInitials! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 7/6/1998 20:17'!durableChangesMenu	"Utilities durableChangesMenu"	self windowFromMenu: ScheduledControllers screenController changesMenu target: ScheduledControllers screenController title: 'Changes'! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 7/6/1998 21:00'!durableScreenMenu	"Utilities durableScreenMenu"	self windowFromMenu: ScheduledControllers screenController projectScreenMenu target: ScheduledControllers screenController title: 'Squeak'! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 7/6/1998 20:56'!windowFromMenu: aMenu target: aTarget title: aTitle	| n labelList colorPattern targetList selectionList |	"Utilities windowFromMenu: ScheduledControllers screenController helpMenu target: ScheduledControllers screenController title: 'Help'"	n _ aMenu selections size.	(aMenu selections last includesSubString: 'urable') ifTrue: [n _ n - 1].	labelList _ (1 to: n) asArray  collect:		[:ind | aMenu labelString lineNumber: ind].	colorPattern _ #(lightRed lightGreen lightBlue lightYellow lightGray lightCyan lightMagenta lightOrange).				targetList _  (1 to: n) asArray  collect: [:ind | aTarget].	selectionList _ aMenu selections.	self windowMenuWithLabels:  labelList colorPattern: colorPattern targets: targetList selections: selectionList title: aTitle! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 7/6/1998 20:10'!windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList title: aTitle	| aWorld n   colorList  pos delta aButton  rightmost widthToUse |	aWorld _ WorldMorph new.	n _ labelList size.	colorList _  (1 to: n) asArray  collect:		[:ind | Color perform: (colorPattern at: (ind \\ colorPattern size + 1))].				pos _ 4 @ 6.	delta _ 0 @ 30.	rightmost _ 0.	1 to: labelList size do:		[:index |			aButton _ SimpleButtonMorph new.			aButton label: (labelList at: index); 				color: (colorList at: index); 				target: (targetList at: index);				actionSelector: (selectionList at: index);				position: pos.			rightmost _ rightmost max: aButton right.			pos _ pos + delta.			aWorld addMorphBack: aButton].	widthToUse _ rightmost + 10.	aWorld submorphs do:		[:m | m position: (((widthToUse - m width) // 2) @ m position y)].	aWorld setProperty: #initialExtent toValue: (widthToUse @ (aButton bottom + 10)).	aWorld openWithTitle: aTitle! !!ViewerBook commentStamp: 'sw 7/6/1998 23:33' prior: 0!Serves as the container for displaying one or more viewers in a tabbed palette.!!ViewerBook methodsFor: 'all' stamp: 'sw 6/19/1998 18:25'!partsViewer	^ submorphs size == 0 ifTrue: [nil] ifFalse: [submorphs first]! !!ViewerBook methodsFor: 'all' stamp: 'sw 7/1/1998 18:04'!setPlayer: aPlayer	| aPartsViewer |	"currentPage ifNotNil: [currentPage partsViewer scriptedPlayer == aPlayer ifTrue: [^ self]]."	self flag: #deferred.  "viewer cache soon"	"self presenter viewerCache at: aPlayer ifPresent:		[^ self ".	self world "temporarily, so it can get initialized!!" addMorph:		(aPartsViewer _ PartsViewer newSticky).	aPartsViewer setPlayer: aPlayer.	self presenter coloredTilesEnabled ifFalse:		[aPartsViewer makeAllTilesGreen].	self removeAllMorphs.	self newPages: (OrderedCollection with: aPartsViewer) currentIndex: 1! !!WebBookMorph commentStamp: 'sw 7/6/1998 23:33' prior: 0!A viewer for a collection of URLs for SqueakPages. Pages can be stepped through in sequence or a bookmark can be used to jump to a specific page.!!WebBookMorph methodsFor: 'initialization' stamp: 'jm 6/17/1998 14:35'!initialize	super initialize.	self setInitialState.	self showPageControls.	self class turnOffSoundWhile: [self insertPage].! !!WebBookMorph methodsFor: 'initialization' stamp: 'sw 6/25/1998 17:01'!removeEverything	self setInitialState.	urls _ OrderedCollection new.	self removeAllMorphs! !!WebBookMorph methodsFor: 'initialization' stamp: 'jm 6/17/1998 14:18'!setInitialState	orientation _ #vertical.	centering _ #topLeft.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	inset _ 5.	color _ Color white.	urls _ OrderedCollection new.	currentURL _ nil.	currentContents _ nil.	pageSize _ 200@250.! !!WebBookMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 14:04'!currentPage	^ currentContents! !!WebBookMorph methodsFor: 'accessing' stamp: 'jm 6/16/1998 14:28'!urls	^ urls! !!WebBookMorph methodsFor: 'accessing' stamp: 'jm 6/25/1998 13:27'!urls: urlList	urls _ urlList copy asOrderedCollection.	self class turnOffSoundWhile: [		urls size = 0 ifTrue: [self insertPage].		self goToPage: 1].! !!WebBookMorph methodsFor: 'page sorting' stamp: 'jm 6/17/1998 15:21'!acceptSortedContentsFrom: aHolderMorph	"Update my url list from the given page sorter."	| newURLs |	newURLs _ urls species new.	aHolderMorph submorphsDo: [:m |		(m isKindOf: URLMorph) ifTrue: [newURLs add: m url]].	urls _ newURLs.	urls isEmpty ifTrue: [^ self insertPage].	self goToPage: aHolderMorph cursor.! !!WebBookMorph methodsFor: 'page sorting' stamp: 'jm 6/17/1998 22:23'!bookmarksForAllPages	| mList sorter |	mList _ self morphsForPageSorter.	mList do: [:m | m isBookmark: true; book: self].	sorter _ BookPageSorterMorph new book: self morphsToSort: mList.	sorter closeButtonOnly.	sorter pageHolder cursor: (urls indexOf: currentURL ifAbsent: [0]).	self presentResultMorph: sorter.! !!WebBookMorph methodsFor: 'page sorting' stamp: 'sw 7/4/1998 16:07'!indexOfCurrentPage	^ urls indexOf: currentURL ifAbsent: [0]! !!WebBookMorph methodsFor: 'page sorting' stamp: 'jm 6/16/1998 18:18'!morphsForPageSorter	| pg sorterMorphs |	sorterMorphs _ OrderedCollection new: urls size.	urls do: [:url |		pg _ SqueakPageCache atURL: url ifAbsent: [nil].		pg ifNotNil: [sorterMorphs addLast: (URLMorph newForURL: url)]].	^ sorterMorphs! !!WebBookMorph methodsFor: 'menu' stamp: 'jm 6/17/1998 22:25'!invokeBookMenu	"Answer the menu for the the book-control panel."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('save page'					savePage)		('reload page'				reloadPage)		('bookmark for this page'	bookmarkForThisPage)		('bookmarks for all pages'	bookmarksForAllPages)		('sort pages'					sortPages)		('text'						newTextMorph)		('hide page controls'			hidePageControls)		('save book'					saveBookToFile)).	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu invokeOn: self defaultSelection: nil.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/17/1998 22:23'!bookmarkForThisPage	"Make a Bookmark for the current URL."	| b |	currentURL ifNil: [^ self].	self savePage.	b _ URLMorph newBookmarkForURL: currentURL.	self presentResultMorph: b.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/17/1998 14:50'!deletePage	| oldURL |	(self confirm: 'Really delete this page?') ifFalse: [^ self].	oldURL _ currentURL.	self nextPage.	urls remove: oldURL ifAbsent: [].	urls isEmpty ifTrue: [self insertPage].! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/25/1998 10:37'!goToPage: pageNumber	| i |	urls isEmpty ifTrue: [^ self].	i _ pageNumber asInteger.	pageNumber < 1 ifTrue: [i _ urls size].	pageNumber > urls size ifTrue: [i _ 1].	self goToURL: (urls at: i).! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/25/1998 11:57'!goToURL: aURLString	| newIndex ascending oldIndex pg |	newIndex _ urls indexOf: aURLString.	newIndex = 0		ifTrue: [ascending _ nil]		ifFalse: [			oldIndex _ urls indexOf: currentURL ifAbsent: [0].			ascending _ newIndex > oldIndex].	self savePageIfNecessary.	pg _ SqueakPageCache atURL: aURLString ifAbsent: [^ self].	currentURL _ aURLString.	self revealPage: pg contentsMorph ascending: ascending.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/16/1998 18:20'!lastPage	self goToPage: urls size.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/17/1998 22:23'!newTextMorph	"Create a new, empty TextMorph that can be placed in this book."	self presentResultMorph: (TextMorph new extent: currentContents width@30).! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/16/1998 14:04'!nextPage	| i |	currentURL == nil ifTrue: [^ self goToPage: 1].	i _ (urls indexOf: currentURL ifAbsent: [0]) + 1.	self goToPage: i.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/16/1998 14:04'!previousPage	| i |	currentURL == nil ifTrue: [^ self goToPage: 1].	i _ (urls indexOf: currentURL ifAbsent: [2]) - 1.	self goToPage: i.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/25/1998 12:46'!reloadPage	"Reload the current page."	currentContentsChanged _ false.  "don't ask about changes"	self goToURL: currentURL. ! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/16/1998 14:18'!saveBookToFile	"Save this book in a file."	| fileName s |	self ensurePagesAreExternal ifFalse: [^ self].	fileName _ FillInTheBlank request: 'File name for this Book?'.	fileName isEmpty ifTrue: [^ self].  "abort"	s _ SmartRefStream newFileNamed: fileName, '.morph'.	s nextPut: self fullCopy.	s close.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/25/1998 10:45'!savePage	"Save the current page."	currentContentsChanged _ true.  "force save to happen"	self savePageIfNecessary.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/17/1998 14:02'!setNewPagePrototype	"Record the current page as the prototype to be copied when inserting new pages."	currentContents ifNotNil:		[newPagePrototype _ currentContents fullCopy].! !!WebBookMorph methodsFor: 'updating' stamp: 'jm 6/25/1998 12:44'!pageHasChanged: aSqueakPage	"The given page has changed. Update this morph if it refers to the given page."	| myPage |	myPage _ SqueakPageCache atURL: currentURL ifAbsent: [nil].	myPage == aSqueakPage ifFalse: [^ self].  "this change does not affect me"	currentContentsChanged ifFalse: [		myPage contentsMorph == originalContents ifTrue: [^ self].		self class turnOffSoundWhile: [self goToURL: currentURL]]. ! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/16/1998 18:21'!ensurePagesAreExternal	"Check that all the pages referred to by this book have external homes, and answer false if they do not. Answer true if all pages have external homes or if the user decides to proceed anyway. Pages without external homes will be missing when the book is read back in."	self halt: 'not yet implemented'.! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/25/1998 11:18'!insertPageColored: aColor	| sz bw bc newContents newURL |	newPagePrototype		ifNil: [			currentContents				ifNil: [					sz _ pageSize.					bw _ 0.					bc _ Color blue muchLighter]				ifNotNil: [					sz _ currentContents extent.					bw _ currentContents borderWidth.					bc _ currentContents borderColor].			newContents _ PasteUpMorph new extent: sz; color: aColor.			newContents borderWidth: bw; borderColor: bc]		ifNotNil: [			newContents _ newPagePrototype fullCopy].	newContents resizeToFit: false.	newURL _ SqueakPage newURLAndPageFor: newContents.	urls isEmpty		ifTrue: [urls add: newURL]		ifFalse: [urls add: newURL after: currentURL].	self nextPage.! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/17/1998 14:05'!insertPageLabel: labelString morphs: morphList	| pg m c labelAllowance |	self insertPage.	pg _ currentContents.	labelString ifNotNil:			[m _ (TextMorph new extent: pg width@20; contents: labelString).		m lock.		m position: pg position + (((pg width - m width) // 2) @ 5).		pg addMorph: m.		labelAllowance _ 40]		ifNil:			[labelAllowance _ 0].	"use a column to align the given morphs, then add them to the page"	c _ AlignmentMorph newColumn centering: #center.	c addAllMorphs: morphList.	c position: pg position + (0 @ labelAllowance).	pg addAllMorphs: morphList.	^ pg! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/18/1998 12:10'!layoutChanged	super layoutChanged.	currentContentsChanged _ true.! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/17/1998 22:22'!presentResultMorph: aMorph	"Add the given morph to the world."	aMorph position: self fullBounds topRight + (5@0).	self world addMorphFront: aMorph.! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/25/1998 11:58'!revealPage: aMorph ascending: ascending	| w r oldOrigin |	w _ self world.	w ifNotNil: [self primaryHand newKeyboardFocus: nil].	currentContents ifNotNil: [		(r _ currentContents screenRectangle) ifNotNil: [oldOrigin _ r origin].		currentContents delete].	originalContents _ aMorph.	currentContents _ aMorph fullCopy.	self addMorphBack: currentContents.	w ifNotNil: [		w startSteppingSubmorphsOf: currentContents.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending].	currentContentsChanged _ false.! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/25/1998 13:06'!savePageIfNecessary	"About to go to a new page; save the current page if necessary."	| oldPage morphToSave |	currentContentsChanged ifNil: [currentContentsChanged _ false].	currentContentsChanged ifFalse: [		"no need to save, but do release cached state of viewed page"		originalContents allMorphsDo: [:m | m releaseCachedState].		^ self].	oldPage _ SqueakPageCache atURL: currentURL ifAbsent: [^ self].	oldPage contentsMorph ~~ originalContents ifTrue: [		(self confirm: 'Someone else has changed this page; save this copy?')			ifFalse: [^ self]].	morphToSave _ currentContents fullCopy.	currentContentsChanged _ false.	originalContents _ morphToSave.	oldPage saveMorph: morphToSave author: Utilities authorInitials. ! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/18/1998 12:31'!showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending	| f |	((ascending == nil) | (oldOrigin == nil) | (currentContents == nil))		ifTrue: [^ self].	PageFlipSoundOn ifTrue: [		f _ currentContents imageForm.		self playPageFlipSound.		Display wipeImage: f				at: oldOrigin				delta: (ascending ifTrue: [0@-10] ifFalse: [0@10])].! !!WebBookMorph class methodsFor: 'all' stamp: 'sw 6/25/1998 17:25'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book _ self new markAsPartsDonor.	book removeEverything; pageSize: 128@102; color: Color white.	book borderWidth: 1; borderColor: Color black.	book showPageControls; insertPage.	book layoutChanged.	^ book! !!WebBookMorph class methodsFor: 'all' stamp: 'jm 9/24/97 08:42'!initialize	"WebBookMorph initialize"	PageFlipSoundOn _ true.! !!WebBookMorph class methodsFor: 'all' stamp: 'jm 6/25/1998 13:28'!newFromOldBook: oldBookMorph	"Make a new instance of me whose pages are copies of the pages in the given book. Does not modify the original book."	| urlList |	urlList _ oldBookMorph pages collect:		[:oldPg | SqueakPage newURLAndPageFor: oldPg fullCopy].	^ self new urls: urlList! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 7/6/1998 08:48'!configureForConstruction	self presenter addTrashCan; standardPlayer.	self addMorph: (self presenter newStandardPartsBin position: 10@10)! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 6/18/1998 09:10'!initialize	super initialize.	color _ (Color r:0.937 g: 0.937 b: 0.937).	fillColor2 _ color.	hands _ Array new.	self addHand: HandMorph new.	viewBox _ canvas _ nil.	damageRecorder _ DamageRecorder new.	stepList _ OrderedCollection new.	lastStepTime _ 0.	self setProperty: #automaticPhraseExpansion toValue: true.	model _ nil.! !!WorldMorph methodsFor: 'painting support' stamp: 'sw 6/25/1998 14:44'!paintBox	"Return the painting controls widget (PaintBoxMorph) to be used for painting in this world. If there is not already a PaintBox morph, or if it has been deleted from this world, create a new one."	| newPaintBox refPoint aPalette |	self allMorphsDo: [:m | (m isKindOf: PaintBoxMorph) ifTrue: [^ m]].	self allMorphsDo: [:m | (m isKindOf: EToyPalette) ifTrue: [		^ m showPaintPaletteNoSelection]].	"Does not create an object"	refPoint _ (aPalette _ self standardPalette)		ifNotNil:			[aPalette showNoPalette.			aPalette topRight + (0 @ 12)]		ifNil:			[self topRight].	newPaintBox _ PaintBoxMorph new.	newPaintBox position: (refPoint - (newPaintBox width @ 0)). 	self addMorph: newPaintBox.	^ newPaintBox! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 6/25/1998 08:35'!slotNamesAndTypesForBank: aNumber	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts."	^ aNumber == 2		ifTrue:			[#(	(color			color		readWrite	getColor				setColor:)				(mouseX			number		readOnly	getMouseX			unused)				(mouseY		number		readOnly	getMouseY			unused))]		ifFalse:			[Array new]! !!EToyWorld methodsFor: 'misc' stamp: 'sw 7/4/1998 16:43'!showEtoyNumber: ind	"Show that etoy, from the list I have"	| holderToInstall |	frontCover ifNotNil: [		userName _ (frontCover findA: TextMorph) contents asString].	BooklikeMorph turnOffSoundWhile:		[holderToInstall _ etoys at: ind.		holderToInstall internalizeIfNecessary.		EToyPlayer new initializeFor: holderToInstall inWorld: self].	Display wipeImage: self imageForm at: viewBox origin delta: -1@0 clippingBox: self viewBox.! !!WorldMorph class methodsFor: 'all' stamp: 'sw 7/6/1998 22:22'!openWithStandardPartsBinShowing	"WorldMorph openWithStandardPartsBinShowing"	| aWorld anExtent aButton |	anExtent _  700 @ 500.	aWorld _ self new setProperty: #initialExtent toValue: anExtent.	aWorld extent: anExtent.	aWorld presenter addTrashCan.	aButton _ aWorld presenter newControlsButton.	aWorld addMorph: aButton.	aButton adhereToEdge: #bottomLeft.	aWorld addMorph: ((aWorld presenter newStandardPartsBin) position: 10@10).	MorphWorldView openOn: aWorld label: 'Construction' extent: anExtent! !BooklikeMorph initialize!BookMorph class removeSelector: #turnOffSoundWhile:!EToyHolder removeSelector: #standardPlayer:!EToyHolder removeSelector: #standardPlayerInWorld:!Morph removeSelector: #buttonOnColor:!Morph removeSelector: #buttonOffColor:!Morph removeSelector: #mouseX!Morph removeSelector: #addButtonNamed:selector:!Morph removeSelector: #mouseY!Morph removeSelector: #buttonOnColor!Morph removeSelector: #buttonOffColor!BookPageSorterMorph removeSelector: #cancelSort!BookMorph removeSelector: #previousPageZoomingFrom:!BookMorph removeSelector: #addDressing!BookMorph removeSelector: #goToPage:zoomingFrom:!BookMorph removeSelector: #addCustomMenuItems:hand:!BookMorph removeSelector: #minimalKidsControlSpecs!BookMorph removeSelector: #insertPage!BookMorph removeSelector: #makeAuthoringPageControlsColored:!BookMorph removeSelector: #pageControls:!BookMorph removeSelector: #makeKidsPageControlsColored:!BookMorph removeSelector: #playPageFlipSound!BookMorph removeSelector: #kidControlSpecs!BookMorph removeSelector: #nextPageZoomingFrom:!BookMorph removeSelector: #firstPage!BookMorph removeSelector: #addKidsDressing!BookMorph removeSelector: #makePageControlsFrom:color:!BookMorph removeSelector: #pageSize:!BookMorph removeSelector: #switchToAuthorMode!BookMorph removeSelector: #makePageControls!BookMorph removeSelector: #authorControlSpecs!BookMorph removeSelector: #insertPageLabel:morphs:secondColumnMorphs:!BookMorph removeSelector: #clearNewPagePrototype!BookMorph removeSelector: #deleteControls!BookMorph removeSelector: #toggleCopyContents!HandMorph removeSelector: #stopRunningAll!HandMorph removeSelector: #startRunningAll!Presenter removeSelector: #suppliesBook!EToyPlayer removeSelector: #startRunningScripts!EToyPlayer removeSelector: #stopRunningScripts!ScreenController removeSelector: #topScreenMenu!ScriptEvaluatorMorph removeSelector: #rootForGrabOf:!SmartRefStream removeSelector: #mouseWillPlaytgpspm0!SqueakPage initialize!SqueakPageCache initialize!WebBookMorph initialize!WorldMorph removeSelector: #flushPlayerListCache!WorldMorph removeSelector: #removeScriptingControls!WorldMorph removeSelector: #stopRunningAll!WorldMorph removeSelector: #allExtantPlayers!WorldMorph removeSelector: #startRunningAll!WorldMorph removeSelector: #allScriptEditors!WorldMorph removeSelector: #stepAll!WorldMorph removeSelector: #updateStatusForAllScriptEditors!WorldMorph removeSelector: #layoutChanged!"Postscript:"ScriptingSystem patchInNewStandardPlayerForm.ScreenController initialize!