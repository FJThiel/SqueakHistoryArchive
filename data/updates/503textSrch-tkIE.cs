'From Squeak 2.3 beta of Nov 25, 1998 on 21 December 1998 at 5:56:07 pm'!!Morph methodsFor: 'accessing' stamp: 'tk 12/16/1998 11:54'!userString	"Do I have a text string to be searched on?"	^ nil! !!BookMorph commentStamp: 'tk 12/19/1998 09:10' prior: 0!Allows one or another "page" to show; orchestrates the page transitions; offers control panel for navigating among pages and for adding and deleting pages.To write a book out to the disk or to a file server, decide what folder it goes in.  Construct a url to a typical page:	file://myDisk/folder/myBook1.sp	ftp://aServer/folder/myBook1.spChoose "send all pages to server" from the book's menu (press the <> part of the controls).  Choose "use page numbers".  Paste in the url.To load an existing book, find its ".bo" file in the file list browser.  Choose "load as book".Multiple people may modify a book.  If other people may have changed a book you have on your screen, choose "reload all from server".Add or modify a page, and choose "send this page to server".The polite thing to do is to reload before changing a book.  Then write one or all pages soon after making your changes.  If you store a stale book, it will wipe out changes that other people made in the mean time.!!BookMorph methodsFor: 'initialization' stamp: 'tk 12/19/1998 10:41'!fromRemoteStream: strm	"Make a book from an index and a bunch of pages on a server.  NOT showing any page!!"	| remote dict |	remote _ strm fileInObjectAndCode.	self initialize.	pages _ OrderedCollection new.	2 to: remote size do: [:ii | pages add: (remote at: ii)].	currentPage fullReleaseCachedState; delete.	"the blank one"	currentPage _ remote at: 2.	dict _ remote at: 1.	self setProperty: #modTime toValue: (dict at: #modTime).	dict at: #allText ifPresent: [:val |		self setProperty: #allText toValue: val].	dict at: #allTextUrls ifPresent: [:val |		self setProperty: #allTextUrls toValue: val].	^ self! !!BookMorph methodsFor: 'initialization' stamp: 'tk 12/19/1998 10:41'!fromURL: url	"Make a book from an index and a bunch of pages on a server.  NOT showing any page!!"	| strm |	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	self fromRemoteStream: strm.	self setProperty: #url toValue: url.	^ self! !!BookMorph methodsFor: 'accessing' stamp: 'tk 12/16/1998 12:05'!userString	"Do I have a text string to be searched on?"	| list |	self getAllText.	list _ OrderedCollection new.	(self valueOfProperty: #allText ifAbsent: #()) do: [:aList |		list addAll: aList].	^ list! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/17/1998 11:40'!findText: wants	"turn to the next page that has all of the strings mentioned on it.  Maybe highlight one?  allText and allTextUrls have been set.  (is case insensitive now?)"	"Later sort wants so longest key is first"	| allText good thisWord here fromHereOn startToHere array |	allText _ self valueOfProperty: #allText ifAbsent: [#()].	here _ self pageNumberOf: currentPage.	fromHereOn _ here to: pages size.	startToHere _ 1 to: here-1.	fromHereOn do: [:pageNo | 		array _ allText at: pageNo.		good _ true.		wants do: [:searchString | "each key"			good ifTrue: [thisWord _ false.				array do: [:longString |					(longString findString: searchString startingAt: 1 						caseSensitive: false) > 0 ifTrue: [thisWord _ true]].				good _ thisWord]].		good ifTrue: ["all are on this page"			self goToPage: pageNo.			"highlight the text?"			^ true]].	startToHere do: [:pageNo | 		array _ allText at: pageNo.		good _ true.		wants do: [:searchString | "each key"			good ifTrue: [thisWord _ false.				array do: [:longString |					(longString findString: searchString startingAt: 1 						caseSensitive: false) > 0 ifTrue: [thisWord _ true]].				good _ thisWord]].		good ifTrue: ["all are on this page"			self goToPage: pageNo.			"highlight the text?"			^ true]].	^ false! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/19/1998 09:30'!getAllText	"Collect the text for each page.  Just point at strings so don't have to recopy them.  Parallel array of urls for ID of pages.	allText = Array (pages size) of arrays (fields in it) of strings of text.	allTextUrls = Array (pages size) of urls or page numbers.	For any page that is out, text data came from .bo file on server.  	Is rewritten when one or all pages are stored."	| oldUrls oldStringLists allText allTextUrls aUrl which |	oldUrls _ self valueOfProperty: #allTextUrls ifAbsent: [#()].	oldStringLists _ self valueOfProperty: #allText ifAbsent: [#()].	allText _ pages collect: [:pg | OrderedCollection new].	allTextUrls _ Array new: pages size.	pages doWithIndex: [:aPage :ind | aUrl _ aPage url.  aPage isInMemory 		ifTrue: [(allText at: ind) addAll: aPage allStrings.			aUrl ifNil: [aUrl _ ind].			allTextUrls at: ind put: aUrl]		ifFalse: ["Order of pages on server may be different.  (later keep up to date?)"			which _ oldUrls indexOf: aUrl.			allTextUrls at: ind put: aUrl.			which = 0 ifFalse: [allText at: ind put: (oldStringLists at: which)]]].	self setProperty: #allText toValue: allText.	self setProperty: #allTextUrls toValue: allTextUrls.	^ allText! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/16/1998 12:26'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu sel |	aMenu _ MVCMenuMorph new.	aMenu addList:	#(			('sort pages'				sortPages)			('make bookmark'		bookmarkForThisPage)			('make thumbnail'		thumbnailForThisPage)			('remove control panel'	hidePageControls)		).	(self primaryHand classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.	aMenu add: 'search for text' action: #textSearch.	aMenu add: 'send all pages to server' action: #savePagesOnURL.	aMenu add: 'send this page to server' action: #saveOneOnURL.	aMenu add: 'reload all from server' action: #reload.	aMenu add: 'keep in one file' action: #keepTogether.	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel].! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/19/1998 11:27'!reload	"Fetch the pages of this book from the server again.  For all pages that have not been modified, keep current ones.  Use new pages.  For each, look up in cache, if time there is equal to time of new, and its in, use the current morph.	Later do fancy things when a page has changed here, and also on the server."	| url onServer onPgs sq |	(url _ self valueOfProperty: #url) ifNil: ["for .bo index file"		url _ FillInTheBlank 			request: 'url of the place where this book''s index is stored.Must begin with file:// or ftp://' 			initialAnswer: (self getStemUrl, '.bo').		url size > 0 ifTrue: [self setProperty: #url toValue: url]			ifFalse: [^ self]].	onServer _ self class new fromURL: url.	"Later: test book times?"	onPgs _ onServer pages collect: [:out |		sq _ SqueakPageCache pageCache at: out url ifAbsent: [nil].		(sq ~~ nil and: [sq contentsMorph isInMemory])			ifTrue: [((out sqkPage lastChangeTime > sq lastChangeTime) or: 					  [sq contentsMorph == nil]) 						ifTrue: [SqueakPageCache atURL: out url put: out sqkPage.							out]						ifFalse: [sq contentsMorph]]			ifFalse: [SqueakPageCache atURL: out url put: out sqkPage.				out]].	self newPages: onPgs currentIndex: 1.		"later stay at current page"	self setProperty: #modTime toValue: (onServer valueOfProperty: #modTime).	self setProperty: #allText toValue: (onServer valueOfProperty: #allText).	self setProperty: #allTextUrls toValue: (onServer valueOfProperty: #allTextUrls).! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/17/1998 10:37'!saveAsNumberedURLs	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, name that page file by its page number.  Any pages that are already totally out will stay that way."	| stem list |stem _ self getStemUrl.	"user must approve"stem size = 0 ifTrue: [^ self].pages doWithIndex: [:aPage :ind | 	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage saveOnURL: stem,(ind printString),'.sp'.		self presenter ifNotNil: [self presenter flushPlayerListCache].		]].list _ pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list _ (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/21/1998 16:51'!saveIndexOfOnly: aPage	"Modify the index of this book on a server.  Read the index, modify the entry for just this page, and write back.  See saveIndexOnURL."	| holder mine sf remoteFile strm remote pageURL num pre index after sp dict allText allTextUrls |	mine _ self valueOfProperty: #url.	mine ifNil: [^ self saveIndexOnURL].	Cursor wait showWhile: [strm _ (ServerFile new fullPath: mine) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	remote _ strm fileInObjectAndCode.	dict _ remote at: 1.	allText _ dict at: #allText ifAbsent: [nil].	"remote, not local"	allTextUrls _ dict at: #allTextUrls ifAbsent: [nil].	(pageURL _ aPage url) ifNil: [self error: 'just had one!!'].	2 to: remote size do: [:ii | 		((remote at: ii) url findString: pageURL startingAt: 1 						caseSensitive: false) > 0 ifTrue: [index _ ii].	"fast"		(remote at: ii) xxxReset].	index ifNil: ["new page, what existing page does it follow?"		num _ self pageNumberOf: aPage.		1 to: num-1 do: [:ii | (pages at: ii) url ifNotNil: [pre _ (pages at: ii) url]].		pre ifNil: [after _ remote size+1]			ifNotNil: ["look for it on disk, put me after"				2 to: remote size do: [:ii | 					((remote at: ii) url findString: pre startingAt: 1 								caseSensitive: false) > 0 ifTrue: [after _ ii+1]]].		remote copyReplaceFrom: after to: after-1 with: #(1).		allText ifNotNil: [			dict at: #allText put: (allText copyReplaceFrom: after-1 to: after-2 with: #(())).			dict at: #allTextUrls put: (allTextUrls copyReplaceFrom: after-1 to: after-2 with: #(()))].		index _ after].	sp _ aPage sqkPage copy.	"is there"	holder _ MorphObjectOut new xxxSetUrl: sp url page: sp.	sp contentsMorph: holder.	remote at: index put: holder.	(dict at: #modTime ifAbsent: [0]) < Time totalSeconds ifTrue:		[dict at: #modTime put: Time totalSeconds].	allText ifNotNil: [		(dict at: #allText) at: index-1 put: aPage allStrings.		(dict at: #allTextUrls) at: index-1 put: pageURL].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: remote.		remoteFile close].! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/21/1998 16:28'!saveIndexOnURL	"Make up an index to the pages of this book, with thumbnails, and store it on the server.  (aDictionary, aMorphObjectOut, aMorphObjectOut, aMorphObjectOut).  The last part corresponds exactly to what pages looks like when they are all out.  Each holds onto a SqueakPage, which holds a url and a thumbnail."	| dict list pg holder mine sf remoteFile |	pages size = 0 ifTrue: [^ self].	dict _ Dictionary new.  dict at: #modTime put: Time totalSeconds.	"self getAllText MUST have been called at start of this operation."	dict at: #allText put: (self valueOfProperty: #allText).	dict at: #allTextUrls put: (self valueOfProperty: #allTextUrls).	list _ pages copy.	"paste dict on front below"	"Fix up the entries, should already be done"	list doWithIndex: [:out :ind |		out isInMemory ifTrue: [  			(pg _ out valueOfProperty: #SqueakPage) ifNil: [				out saveOnURLbasic].			pg _ (out valueOfProperty: #SqueakPage) copy.			holder _ MorphObjectOut new xxxSetUrl: pg url page: pg.			pg contentsMorph: holder.			list at: ind put: holder]].	list _ (Array with: dict), list.	mine _ self valueOfProperty: #url.	mine ifNil: [mine _ self getStemUrl, '.bo'.		self setProperty: #url toValue: mine].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: list.		remoteFile close].! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/21/1998 17:28'!saveOneOnURL	"Write out this single page in this book that are not showing, onto a server.  See savePagesOnURL.  (Don't compute the texts, only this page's is written.)"	| stem ind |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.'.		^ self].	"Don't give the chance to put in a different place.  Assume named by number"	stem _ self getStemUrl.	"user must approve"	stem size = 0 ifTrue: [^ self].	ind _ self pageNumberOf: currentPage.	currentPage isInMemory ifTrue: ["not out now"			currentPage saveOnURL: stem,(ind printString),'.sp'].	self saveIndexOfOnly: currentPage.! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/19/1998 10:00'!savePagesOnURL	"Write out all pages in this book onto a server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are not in memory will stay that way.  The local disk could be the server."	| response list |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.'.		^ self].	self getAllText.	"stored with index later"	response _ (PopUpMenu labels: 'Use page numbers\Type in file names\Save in a new place (using page numbers)\Save in a new place (typing names)' withCRs)			startUpWithCaption: 'Each page will be a file on the server.  \Do you want to page numbers be the names of the files? \or name each one yourself?' withCRs.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].	response = 0 ifTrue: [^ self].pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage saveOnURLbasic.		self presenter ifNotNil: [self presenter flushPlayerListCache].		]].	"ask user if no url"list _ pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list _ (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/16/1998 11:16'!textSearch	"search the text on all pages of this book"	| wanted wants |	wanted _ FillInTheBlank request: 'words to search for.  Order is not important.Beginnings of words are OK.'.	wants _ wanted findTokens: Character separators.	self getAllText.		"save in allText, allTextUrls"	^ self findText: wants	"goes to the page and highlights the text"! !!ObjectOut commentStamp: 'tk 12/18/1998 21:24' prior: 0!I am a stand-in for an object that is out on the disk.  The object that is out on the disk is the head of a tree of objects that are out.  See SqueakPage.When any message is sent to me, I don't understand it, and bring in my true object.  I become myself with the objects and resend the message.  I may not represent the object nil.  The file is represented as a url, and that url may point at any file on the net.  page is a SqueakPage.If the cache already has an object, widely in use, that claims to be the object for my url, what do I do?  I can't become him, since others believe that he is the true object.  Run through memory and replace refs to me with refs to him.  Be careful not to trigger a fault.  Become me to a string, then find pointers and replace?[[[They don't want to end up holding an ObjectOut.  (would oscillate back and forth)  This is a problem.  A user could bring in two trees that both refer to a 3rd url.  (check with cache before installing any new ObjectOut) Two trees could be written to the same url.Or, I remain an ObjectOut, and keep getting notUnderstood, and keep returning the other guy.Or I smash the cache, and install MY page and object.  Other guy is a copy -- still in, but with no place in the cache.  When we both write to the same url, there will be trouble.]  No -- search and replace.]]]!!ObjectOut methodsFor: 'access' stamp: 'tk 12/18/1998 21:29'!xxxReset	"mark as never brought in"	recursionFlag _ nil! !!PasteUpMorph methodsFor: 'misc' stamp: 'tk 12/17/1998 11:27'!allStrings	"return an Array of strings of text in my submorphs"	| list string |	list _ OrderedCollection new.	self allMorphsDo: [:sub | 		(string _ sub userString) ifNotNil: [list add: string]].	^ list! !!PasteUpMorph methodsFor: 'misc' stamp: 'tk 12/17/1998 10:39'!stopRunningAll	"Stop running all scripted morphs.  Triggered by user hitting STOP button"	self presenter allExtantPlayers do: [:aPlayer |		aPlayer stopRunning.		aPlayer costume goHome].	self world updateStatusForAllScriptEditors! !!StringMorph methodsFor: 'accessing' stamp: 'tk 12/16/1998 11:55'!userString	"Do I have a text string to be searched on?"	^ contents! !!TextMorph methodsFor: 'accessing' stamp: 'tk 12/16/1998 11:58'!userString	"Do I have a text string to be searched on?"	^ text string! !BookMorph class removeSelector: #savePagesOfAllBooks!