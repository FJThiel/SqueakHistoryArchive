'From Squeak3.1alpha of 5 February 2001 [latest update: #4070] on 24 May 2001 at 10:05:14 pm'!"Change Set:		GCWeakScanFixDate:			24 May 2001Author:			Bob Arning / Dan IngallsFixes a bug that caused weak fields of an object to be traced if the object was the top-level argument to markAndTrace:."!!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'di 5/24/2001 22:00'!markAndTrace: oop	"Mark all objects reachable from the given one.	Trace from the given object even if it is old.	Do not trace if it is already marked.	Mark it only if it is a young object."	"Tracer state variables:		child		object being examined		field		next field of child to examine		parentField	field where child was stored in its referencing object"	| header lastFieldOffset action |	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifFalse: [^ 0  "already marked"].	"record tracing status in object's header"	header _ (header bitAnd: AllButTypeMask) bitOr: HeaderTypeGC.	oop >= youngStart ifTrue: [ header _ header bitOr: MarkBit ].  "mark only if young"	self longAt: oop put: header.	"initialize the tracer state machine"	parentField _ GCTopMarker.	child _ oop.	(self isWeak: oop)		ifTrue: ["Set lastFieldOffset before the weak fields in the receiver"				lastFieldOffset := (self nonWeakFieldsOf: oop) << 2]		ifFalse: ["Do it the usual way"				lastFieldOffset _ self lastPointerOf: oop].	field _ oop + lastFieldOffset.	action _ StartField.	"run the tracer state machine until all objects reachable from oop are marked"	[action = Done] whileFalse: [		action = StartField	ifTrue: [ action _ self startField ].		action = StartObj		ifTrue: [ action _ self startObj ].		action = Upward		ifTrue: [ action _ self upward ].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'di 5/24/2001 21:58'!startObj	"Start tracing the object 'child' and answer the next action. The object may be anywhere in the middle of being swept itself. See comment in markAndTrace for explanation of tracer state variables."	| oop header lastFieldOffset |	self inline: true.	oop _ child.	oop < youngStart ifTrue: [		"old object; skip it"		 field _ oop.		^ Upward	].	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue:		["unmarked; mark and trace"		"Do not trace the object's indexed fields if it's a weak class"		(self isWeak: oop)			ifTrue: ["Set lastFieldOffset before the weak fields in the receiver"					lastFieldOffset := (self nonWeakFieldsOf: oop) << 2]			ifFalse: ["Do it the usual way"					lastFieldOffset _ self lastPointerOf: oop].		header _ header bitAnd: AllButTypeMask.		header _ (header bitOr: MarkBit) bitOr: HeaderTypeGC.		self longAt: oop put: header.		field _ oop + lastFieldOffset.		^ StartField	"trace its fields and class"	] ifFalse: [		"already marked; skip it"		field _ oop.		^ Upward	].! !