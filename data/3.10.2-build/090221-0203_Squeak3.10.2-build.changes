'From Squeak3.10.2 of ''5 June 2008'' [latest update: #7179] on 5 June 2008 at 3:23:01 pm'!!ATestCase methodsFor: 'as yet unclassified' stamp: 'dvf 9/18/2006 21:28'!testRequirement  "  self debug: #testRequirement  "  | class |  class := Object            subclass: #AClassForTest            instanceVariableNames: ''            classVariableNames: ''            poolDictionaries: ''            category: self class category.  [   class compile: 'call                    ^ self isCalled'.   self assert: (class requiredSelectors includes: #isCalled).   class compile: 'isCalled                    ^ 1'.   "Fail here:"   self deny: (class requiredSelectors includes: #isCalled)]  ensure: [class removeFromSystem] ! !!AbstractFont methodsFor: 'testing' stamp: 'yo 2/12/2007 19:34'!isFontSet	^ false.! !!ActorState methodsFor: 'initialization' stamp: 'sw 5/13/1998 16:37'!initializeFor: aPlayer	| aNewDictionary |	owningPlayer := aPlayer.	instantiatedUserScriptsDictionary ifNil: [^ self].	aNewDictionary := IdentityDictionary new.	instantiatedUserScriptsDictionary associationsDo: 		[:assoc |			aNewDictionary at: assoc key put: (assoc value shallowCopy player: aPlayer)].	instantiatedUserScriptsDictionary := aNewDictionary.! !!ActorState methodsFor: 'pen' stamp: 'sw 4/22/1998 13:44'!choosePenSize	| menu sz |	menu := CustomMenu new.	1 to: 10 do: [:w | menu add: w printString action: w].	sz := menu startUp.	sz ifNotNil: [penSize := sz]! !!ActorState methodsFor: 'pen' stamp: 'sw 4/22/1998 13:35'!getPenColor	penColor ifNil: [penColor := self defaultPenColor].	^ penColor! !!ActorState methodsFor: 'pen' stamp: 'sw 4/22/1998 13:43'!getPenSize	penSize ifNil: [penSize := self defaultPenSize].	^ penSize! !!ActorState methodsFor: 'pen' stamp: 'sw 2/4/98 18:07'!liftPen	penDown := false! !!ActorState methodsFor: 'pen' stamp: 'sw 2/4/98 14:58'!lowerPen	penDown := true! !!ActorState methodsFor: 'pen' stamp: 'sw 2/4/98 18:03'!penColor: aColor	penColor := aColor! !!ActorState methodsFor: 'pen' stamp: 'tk 10/4/2001 16:43'!setPenArrowheads: aBoolean	penArrowheads := aBoolean! !!ActorState methodsFor: 'pen' stamp: 'sw 4/22/1998 13:51'!setPenColor: aColor	penColor := aColor! !!ActorState methodsFor: 'pen' stamp: 'sw 4/22/1998 13:47'!setPenDown: aBoolean	penDown := aBoolean! !!ActorState methodsFor: 'pen' stamp: 'sw 4/22/1998 13:45'!setPenSize: aNumber	penSize := aNumber! !!ActorState methodsFor: 'pen' stamp: 'sw 4/16/2003 12:26'!trailStyle	"Answer the receiver's trailStyle.  For backward compatibility, if the old penArrowheads slot is in found to be set, use it as a guide for initialization"	^ trailStyle ifNil: [trailStyle := penArrowheads == true ifTrue: [#arrows] ifFalse: [#lines]]! !!ActorState methodsFor: 'pen' stamp: 'sw 3/11/2003 11:28'!trailStyle: aSymbol	"Set the trail style to the given symbol"	trailStyle := aSymbol! !!ActorState methodsFor: 'position' stamp: 'jm 4/24/1998 21:31'!fractionalPosition: aPoint	fractionalPosition := aPoint asFloatPoint.! !!ActorState methodsFor: 'script instantiations' stamp: 'sw 4/9/98 22:35'!instantiatedUserScriptsDictionary	instantiatedUserScriptsDictionary ifNil: [instantiatedUserScriptsDictionary := IdentityDictionary new].	^ instantiatedUserScriptsDictionary! !!AlignmentMorph methodsFor: '*eToys-initialization' stamp: 'ar 10/25/2000 17:53'!addUpDownArrowsFor: aMorph	"Add a column of up and down arrows that serve to send upArrowHit and downArrowHit to aMorph when they're pressed/held down"	| holder downArrow upArrow |	holder := Morph new extent: 16 @ 16; beTransparent.	downArrow := ImageMorph new image: (ScriptingSystem formAtKey: 'DownArrow').	upArrow := ImageMorph new image: (ScriptingSystem formAtKey: 'UpArrow').	upArrow position: holder bounds topLeft + (2@2).	downArrow align: downArrow bottomLeft				with: holder topLeft + (0 @ TileMorph defaultH) + (2@-2).	holder addMorph: upArrow.	holder addMorph: downArrow.	self addMorphBack: holder.	upArrow on: #mouseDown send: #upArrowHit to: aMorph.	upArrow on: #mouseStillDown send: #upArrowHit to: aMorph.	downArrow on: #mouseDown send: #downArrowHit to: aMorph.	downArrow on: #mouseStillDown send: #downArrowHit to: aMorph.! !!AllPlayersTool methodsFor: 'initialization' stamp: 'sw 12/8/2004 11:12'!addHeaderRow	"Add the header morph at the top of the tool"	| aRow title aButton |	aRow := AlignmentMorph newRow.	aRow listCentering: #justified; color: Color transparent.	aButton := self tanOButton.	aButton actionSelector: #delete.	aRow addMorphFront: aButton.	aRow addMorphBack: (title := StringMorph contents: 'Gallery of Players' translated).	title setBalloonText: 'Double-click here to refresh the contents' translated.	title on: #doubleClick send: #reinvigorate to: self.	aRow addMorphBack: self helpButton.	self addMorphFront: aRow.! !!AllPlayersTool methodsFor: 'initialization' stamp: 'sw 7/28/2004 20:48'!initializeFor: aPresenter	"Initialize the receiver as a tool which shows, and allows the user to change the status of, all the instantiations of all the user-written scripts in the scope of the containing pasteup's presenter"	| placeHolder |	self color: Color brown muchLighter muchLighter; wrapCentering: #center; cellPositioning: #topCenter; vResizing: #shrinkWrap; hResizing: #shrinkWrap.	self useRoundedCorners.	self borderStyle: BorderStyle complexAltInset; borderWidth: 4; borderColor: (Color r: 0.452 g: 0.839 b: 1.0).  "Color fromUser"	self addHeaderRow.	placeHolder := Morph new beTransparent.	placeHolder extent: 200@1.	self addMorphBack: placeHolder.	ActiveWorld presenter reinvigoratePlayersTool: self ! !!AllPlayersTool methodsFor: 'menus' stamp: 'sw 7/28/2004 22:58'!presentHelp	"Sent when a Help button is hit; provide the user with some form of help for the tool at hand"	| aString aTextMorph |	aString := 'About the Gallery of PlayersClick on an object''s picture to reveal its location.Click on the turquoise eye to open the object''s viewer.Click on an object''s name to obtain a tile representing the object.   Double-click on the title ("Gallery of Players") to refresh the tool;this may allow you to see newly-added or newly-scripted objects.'.	aTextMorph :=  TextMorph new contents: aString translated.	aTextMorph useRoundedCorners; borderWidth: 3; borderColor: Color gray; margins: 3@3.	aTextMorph backgroundColor: Color blue muchLighter.	aTextMorph beAllFont: (StrikeFont familyName: #ComicBold size: 18);	 centered; lock.	AlignmentMorph new beTransparent		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		addMorphBack: aTextMorph;		openInHand! !!AllPlayersTool methodsFor: 'reinvigoration' stamp: 'sw 7/19/2004 16:37'!invigorateButton	"Answer a button that triggers reinvigoration"	| aButton |	aButton := IconicButton new target: self;		borderWidth: 0;		labelGraphic: (ScriptingSystem formAtKey: #Refresh);		color: Color transparent; 		actWhen: #buttonUp;		actionSelector: #reinvigorate;		yourself.	aButton setBalloonText: 'Click here to refresh the list of players'.	^ aButton! !!AllPlayersTool methodsFor: 'reinvigoration' stamp: 'sw 7/19/2004 16:17'!menuButton	"Answer a button that brings up a menu.  Useful when adding new features, but at present is between uses"	| aButton |	aButton := IconicButton new target: self;		borderWidth: 0;		labelGraphic: (ScriptingSystem formAtKey: #TinyMenu);		color: Color transparent; 		actWhen: #buttonDown;		actionSelector: #offerMenu;		yourself.	aButton setBalloonText: 'click here to get a menu with further options'.	^ aButton! !!AllScriptsTool methodsFor: 'initialization' stamp: 'dgd 9/19/2003 14:34'!addSecondLineOfControls	"Add the second line of controls"	| aRow outerButton aButton worldToUse |	aRow := AlignmentMorph newRow listCentering: #center; color: Color transparent.	outerButton := AlignmentMorph newRow.	outerButton wrapCentering: #center; cellPositioning: #leftCenter.	outerButton color:  Color transparent.	outerButton hResizing: #shrinkWrap; vResizing: #shrinkWrap.	outerButton addMorph: (aButton := UpdatingThreePhaseButtonMorph checkBox).	aButton		target: self;		actionSelector: #toggleWhetherShowingOnlyActiveScripts;		getSelector: #showingOnlyActiveScripts.	outerButton addTransparentSpacerOfSize: (4@0).	outerButton addMorphBack: (StringMorph contents: 'tickers only' translated) lock.	outerButton setBalloonText: 'If checked, then only scripts that are paused or ticking will be shown' translated.	aRow addMorphBack: outerButton.	aRow addTransparentSpacerOfSize: 20@0.	aRow addMorphBack: self helpButton.	aRow addTransparentSpacerOfSize: 20@0.	outerButton := AlignmentMorph newRow.	outerButton wrapCentering: #center; cellPositioning: #leftCenter.	outerButton color:  Color transparent.	outerButton hResizing: #shrinkWrap; vResizing: #shrinkWrap.	outerButton addMorph: (aButton := UpdatingThreePhaseButtonMorph checkBox).	aButton		target: self;		actionSelector: #toggleWhetherShowingAllInstances;		getSelector: #showingAllInstances.	outerButton addTransparentSpacerOfSize: (4@0).	outerButton addMorphBack: (StringMorph contents: 'all instances' translated) lock.	outerButton setBalloonText: 'If checked, then entries for all instances will be shown, but if not checked, scripts for only one representative of each different kind of object will be shown.  Consult the help available by clicking on the purple ? for more information.' translated.	aRow addMorphBack: outerButton.	self addMorphBack: aRow.	worldToUse := self isInWorld ifTrue: [self world] ifFalse: [ActiveWorld].	worldToUse presenter reinvigorateAllScriptsTool: self.	self layoutChanged.! !!AllScriptsTool methodsFor: 'initialization' stamp: 'sw 12/8/2004 11:26'!initializeFor: ignored	"Initialize the receiver as a tool which shows, and allows the user to change the status of, all the instantiations of all the user-written scripts in the scope of the containing pasteup's presenter"	| aRow aButton |	showingOnlyActiveScripts := true.	showingAllInstances := true.	showingOnlyTopControls := true.	self color: Color brown muchLighter muchLighter; wrapCentering: #center; cellPositioning: #topCenter; vResizing: #shrinkWrap; hResizing: #shrinkWrap.	self useRoundedCorners.	self borderWidth: 4; borderColor: Color brown darker.	aRow := AlignmentMorph newRow.	aRow listCentering: #justified; color: Color transparent.	aButton := self tanOButton.	aButton actionSelector: #delete.	aRow addMorphFront: aButton.	aRow addMorphBack: ScriptingSystem scriptControlButtons.	aRow addMorphBack: self openUpButton.	self addMorphFront: aRow.! !!AllScriptsTool methodsFor: 'initialization' stamp: 'dgd 9/19/2003 14:35'!presentHelp	"Sent when a Help button is hit; provide the user with some form of help for the tool at hand"	| aString |	aString := 'This tool allows you to see all the scripts for all the objects in this project.Sometimes you are only interested in those scripts that are ticking, or that are *ready* to tick when you hit the GO button (which are said to be "paused.")Check "tickers only" if you only want to see such scripts -- i.e., scripts that are either paused or ticking.If "tickers only" is *not* checked, then all scripts will be shown, whatever their status.The other checkbox, labeled "all instances", only comes into play if you have created "multiple sibling instances" (good grief) of the same object, which share the same scripts; if you have such things, it is often convenient to see the scripts of just *one* such sibling, because it will take up less space and require less mindshare -- and note that you can control a script for an object *and* all its siblings from the menu of that one that you see, via menu items such as "propagate status to siblings".If "all instances" is checked, scripts for all sibling instances will be shown, whereas if "all instances" is *not* checked, only one of each group of siblings will be selected to have its scripts shown.But how do you get "multiple sibling instances" of the same object?  There are several ways:(1)  Use the "make a sibling instance" or the "make multiple siblings..." menu item in the halo menu of a scripted object(2)  Use the "copy" tile in a script.(3)  Request "give me a copy now" from the menu associated with the "copy" item in a ViewerIf you have on your screen multiple sibling instances of the same object, then you may or may want to see them all in the All Scripts tool, and that is what the "all instances" checkbox governs.Set "all instances" if you want a separate entry for each instance, asopposed to a single representative of that kind of object.Note that if you obtain a copy of an object by using the green halo handle, it will *not* be a sibling instance of the original.  It will in many ways seem to be, because it will start out its life having the same scripts as the original.  But it will then lead an independent life, so that changes to scripts of the original will not be reflected in it, and vice-versa.This is an important distinction, and an unavoidable one because people sometimes want the deep sharing of sibling instances and sometimes they clearly do not.  But the truly understandable description of these concepts and distinctions certainly lies *ahead* of us!!'.	(StringHolder new contents: aString translated)		openLabel: 'About the All Scripts tool' translated! !!AllScriptsTool methodsFor: 'toggles' stamp: 'sw 12/8/2004 11:28'!openUpButton	"Answer a button whose action would be to open up the receiver or snap it back closed"	| aButton aForm |	aButton := IconicButton new borderWidth: 0.	aForm := ScriptingSystem formAtKey: #PowderBlueOpener.	aForm ifNil:		[aForm := Form extent: 13@22 depth: 16 fromArray: #( 0 0 12017 787558129 0 0 0 0 12017 787561309 995965789 787558129 0 0 0 787561309 995965789 995965789 995965789 787546112 0 12017 995965789 995965789 995965789 995965789 995962609 0 12017 995965789 995965789 995965789 995965789 995962609 0 787561309 995965789 995965789 995965789 995965789 995965789 787546112 787561309 995965789 995965789 995965789 995965789 995965789 787546112 787561309 995965789 995950593 80733 995965789 995965789 787546112 787561309 995965789 65537 65537 80733 995965789 787546112 787561309 995950593 80733 995950593 80733 995965789 787546112 787561309 995950593 80733 995950593 80733 995965789 787546112 787561309 995950593 65537 65537 80733 995965789 787546112 787561309 995965789 65537 65537 995965789 995965789 787546112 787561309 995965789 995965789 995965789 995965789 995965789 787546112 787561309 995965789 995965789 995965789 995965789 995965789 787546112 787561309 995965789 995965789 995965789 995965789 995965789 787546112 787561309 995965789 995965789 995965789 995965789 995965789 787546112 12017 995965789 995965789 995965789 995965789 995962609 0 12017 995965789 995965789 995965789 995965789 995962609 0 0 787561309 995965789 995965789 995965789 787546112 0 0 12017 787561309 995965789 787558129 0 0 0 0 12017 787558129 0 0 0) offset: 0@0.		ScriptingSystem saveForm: aForm atKey: #PowderBlueOpener].	aButton labelGraphic: aForm.	aButton		target: self;		color: Color transparent;		actionSelector: #toggleWhetherShowingOnlyTopControls;		setBalloonText: 'open or close the lower portion that shows individual scripts' translated.	^ aButton! !!AllScriptsTool methodsFor: 'toggles' stamp: 'sw 11/13/2001 19:43'!showingOnlyTopControls	"Answer whether the receiver is currently showing only the top controls" 	^ showingOnlyTopControls ifNil: [showingOnlyTopControls := true]! !!AllScriptsTool methodsFor: 'toggles' stamp: 'sw 11/14/2001 00:32'!toggleWhetherShowingAllInstances	"Toggle whether the receiver is showing all instances or only one exemplar per uniclass"	showingAllInstances := showingAllInstances not.	self presenter reinvigorateAllScriptsTool: self! !!AllScriptsTool methodsFor: 'toggles' stamp: 'sw 11/14/2001 00:32'!toggleWhetherShowingOnlyActiveScripts	"Toggle whether the receiver is showing only active scripts"	showingOnlyActiveScripts := showingOnlyActiveScripts not.	self presenter reinvigorateAllScriptsTool: self! !!AllScriptsTool methodsFor: 'toggles' stamp: 'sw 11/14/2001 00:32'!toggleWhetherShowingOnlyTopControls	"Toggle whether the receiver is showing only the stop/step/go line or the full whammy"	| aCenter |	showingOnlyTopControls := self showingOnlyTopControls not.	aCenter := self center x.	self showingOnlyTopControls		ifTrue:			[self removeAllButFirstSubmorph]		ifFalse:			[self addSecondLineOfControls.			self presenter reinvigorateAllScriptsTool: self].	WorldState addDeferredUIMessage:		[self center: (aCenter @ self center y)]	! !!AllScriptsTool class methodsFor: 'instance creation' stamp: 'sw 6/12/2001 11:52'!allScriptsToolForActiveWorld	"Launch an AllScriptsTool to view scripts of the active world"	| aTool |	aTool := self newColumn.	aTool initializeFor: ActiveWorld presenter.	^ aTool! !!AllScriptsTool class methodsFor: 'instance creation' stamp: 'sw 1/30/2001 23:06'!launchAllScriptsToolFor: aPresenter	"Launch an AllScriptsTool to view scripts of the given presenter"	| aTool |	aTool := self newColumn.	aTool initializeFor: aPresenter.	self currentHand attachMorph: aTool.	aPresenter associatedMorph world startSteppingSubmorphsOf: aTool! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'wiz 1/1/2007 20:21'!step	| d |	images isEmpty ifTrue: [^ self].			nextTime > Time millisecondClockValue		ifTrue: [^self].	self changed .	self image: (images at:	(imageIndex _ imageIndex \\ images size + 1)).	self changed . 	d _ (delays at: imageIndex) ifNil: [0].	nextTime := Time millisecondClockValue + d! !!Arc methodsFor: 'accessing'!center: aPoint 	"Set aPoint to be the receiver's center."	center := aPoint! !!Arc methodsFor: 'accessing'!center: aPoint radius: anInteger 	"The receiver is defined by a point at the center and a radius. The 	quadrant is not reset."	center := aPoint.	radius := anInteger! !!Arc methodsFor: 'accessing'!center: aPoint radius: anInteger quadrant: section 	"Set the receiver's quadrant to be the argument, section. The size of the 	receiver is defined by the center and its radius."	center := aPoint.	radius := anInteger.	quadrant := section! !!Arc methodsFor: 'accessing'!quadrant: section 	"Set the part of the circle represented by the receiver to be the argument, 	section."	quadrant := section! !!Arc methodsFor: 'accessing'!radius: anInteger 	"Set the receiver's radius to be the argument, anInteger."	radius := anInteger! !!Arc methodsFor: 'display box access'!computeBoundingBox	| aRectangle aPoint |	aRectangle := center - radius + form offset extent: form extent + (radius * 2) asPoint.	aPoint := center + form extent.	quadrant = 1 ifTrue: [^ aRectangle encompass: center x @ aPoint y].	quadrant = 2 ifTrue: [^ aRectangle encompass: aPoint x @ aPoint y].	quadrant = 3 ifTrue: [^ aRectangle encompass: aPoint x @ center y].	quadrant = 4 ifTrue: [^ aRectangle encompass: center x @ center y]! !!Arc methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm	| nSegments line angle sin cos xn yn xn1 yn1 |	nSegments := 12.0.	line := Line new.	line form: self form.	angle := 90.0 / nSegments.	sin := (angle * (2 * Float pi / 360.0)) sin.	cos := (angle * (2 * Float pi / 360.0)) cos.	quadrant = 1		ifTrue: 			[xn := radius asFloat.			yn := 0.0].	quadrant = 2		ifTrue: 			[xn := 0.0.			yn := 0.0 - radius asFloat].	quadrant = 3		ifTrue: 			[xn := 0.0 - radius asFloat.			yn := 0.0].	quadrant = 4		ifTrue: 			[xn := 0.0.			yn := radius asFloat].	nSegments asInteger		timesRepeat: 			[xn1 := xn * cos + (yn * sin).			yn1 := yn * cos - (xn * sin).			line beginPoint: center + (xn asInteger @ yn asInteger).			line endPoint: center + (xn1 asInteger @ yn1 asInteger).			line				displayOn: aDisplayMedium				at: aPoint				clippingBox: clipRect				rule: anInteger				fillColor: aForm.			xn := xn1.			yn := yn1]! !!Arc methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	| newArc tempCenter |	newArc := Arc new.	tempCenter := aTransformation applyTo: self center.	newArc center: tempCenter x asInteger @ tempCenter y asInteger.	newArc quadrant: self quadrant.	newArc radius: (self radius * aTransformation scale x) asInteger.	newArc form: self form.	newArc		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Arc class methodsFor: 'examples'!example	"Click the button somewhere on the screen. The designated point will	be the center of an Arc with radius 50 in the 4th quadrant."	| anArc aForm |	aForm := Form extent: 1 @ 30.	"make a long thin Form for display"	aForm fillBlack.						"turn it black"	anArc := Arc new.	anArc form: aForm.					"set the form for display"	anArc radius: 50.0.	anArc center: Sensor waitButton.	anArc quadrant: 4.	anArc displayOn: Display.	Sensor waitButton	"Arc example"! !!ArchiveViewer methodsFor: 'archive operations' stamp: 'edc 5/7/2007 11:34'!openNewArchive	|  result |	result := FileList2 modalFileSelector .	result ifNil: [ ^self ].	self fileName: (result directory fullNameFor: result name).! !!ArchiveViewer methodsFor: 'archive operations' stamp: 'edc 7/13/2006 17:46'!saveArchive	| result name |		name := FileDirectory  localNameFor: labelString .	self canSaveArchive ifFalse: [ ^self ].	result := FillInTheBlank		request: 'Name this zip '		initialAnswer:  name		centerAt: Display center.	result ifNil: [ ^self ].		(archive canWriteToFileNamed: result)		ifFalse: [ self inform: name, ' is used by one or more membersin your archive, and cannot be overwritten.Try writing to another file name'.			^self ].	[ archive writeToFileNamed: result ] on: Error do: [ :ex | self inform: ex description. ].	self setLabel: name asString.	self changed: #memberList	"in case CRC's and compressed sizes got set"! !!ArchiveViewer methodsFor: 'initialization' stamp: 'edc 11/23/2007 09:32'!createListHeadingUsingFont: font	| sm |	sm := StringMorph contents: ' order  uncomp   comp   CRC-32       date     time     file name'.	font ifNotNil: [ sm font: font ].	^(AlignmentMorph newColumn)		color: self defaultBackgroundColor;		addMorph: sm;		yourself.! !!ArchiveViewer methodsFor: 'member list' stamp: 'edc 11/23/2007 09:32'!displayLineFor: aMember	| stream dateTime index |	index := self archive members indexOf: aMember.	stream := WriteStream on: (String new: 60).	dateTime := Time dateAndTimeFromSeconds: aMember lastModTime. 	stream	nextPutAll: (index printString padded: #left to: 4 with: $  );	space;		nextPutAll: (aMember uncompressedSize printString padded: #left to: 8 with: $  );		space; space;		nextPutAll: (aMember compressedSize printString padded: #left to: 8 with: $  );		space; space;		nextPutAll: (aMember crc32String );		space; space.	dateTime first printOn: stream format: #(3 2 1 $- 2 1 2).	stream space; space.	dateTime second print24: true showSeconds: false on: stream.	stream space; space;		nextPutAll: (aMember fileName ).	^stream contents! !!ArchiveViewer methodsFor: 'member list' stamp: 'edc 11/23/2007 09:51'!memberMenu: menu shifted: shifted	| services |	menu		add: 'Comment archive' target: self selector: #commentArchive;		balloonTextForLastItem: 'Add a comment for the entire archive'.	self selectedMember ifNotNilDo: [ :member |		menu			addLine;			add: 'Inspect member' target: self selector: #inspectMember;			balloonTextForLastItem: 'Inspect the selected member';			add: 'Comment member' target: self selector: #commentMember;			balloonTextForLastItem: 'Add a comment for the selected member';			addLine;			add: 'member go up in order ' target: self selector: #upMember;			add: 'member go down in order ' target: self selector: #downMember;			add: 'select member order ' target: self selector: #toIndexPlace;			addLine.		services := FileList itemsForFile: member fileName.		menu addServices2: services for: self extraLines: #().	].	^menu! !!ArchiveViewer methodsFor: 'member operations' stamp: 'edc 7/13/2006 12:10'!addMember	| result local full |	self canAddMember ifFalse: [ ^self ].	result := FileList2 modalFileSelector .	result ifNil: [ ^self ].	local := result directory localNameFor: result name.	full := result directory fullNameFor: result name.		(archive addFile: full as: local)		desiredCompressionMethod: ZipArchive compressionDeflated.	self memberIndex: self members size.	self changed: #memberList.! !!ArchiveViewer methodsFor: 'member order' stamp: 'edc 11/23/2007 09:18'!downMember| temp |	temp := (self archive members) at: memberIndex.	self archive members at: memberIndex put: (self archive members at: memberIndex  + 1).	self archive members at: (memberIndex  +1) put: temp.	self memberIndex:  0.	self changed: #memberList.! !!ArchiveViewer methodsFor: 'member order' stamp: 'edc 11/23/2007 09:57'!toIndexPlace| index max temp |max := self archive members size.index :=0.[index := (FillInTheBlank		request: 'To which index '		initialAnswer:  '1'		centerAt: Display center) asInteger.		index between: 1 and: max] whileFalse.	temp := (self archive members) at: memberIndex.	self archive members at: memberIndex put: (self archive members at: index).	self archive members at: index put: temp.	self memberIndex:  0.	self changed: #memberList.! !!ArchiveViewer methodsFor: 'member order' stamp: 'edc 11/23/2007 09:57'!upMember| temp |	temp := (self archive members) at: memberIndex.	self archive members at: memberIndex put: (self archive members at: memberIndex  -1).	self archive members at: (memberIndex  -1) put: temp.	self memberIndex:  0.	self changed: #memberList.! !!ArchiveViewer class methodsFor: 'fileIn/Out' stamp: 'edc 6/26/2007 07:09'!services		^ Array 		with: self serviceAddToNewZip		with: self serviceOpenInZipViewer										! !!Array methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:08'!preMultiplyByMatrix: m	"Answer m+*self where m is a Matrix."	|s|	m columnCount = self size ifFalse: [self error: 'dimensions do not conform'].	^(1 to: m rowCount) collect: [:row |		s := 0.		1 to: self size do: [:k | s := (m at: row at: k) * (self at: k) + s].		s]! !!Array methodsFor: 'converting' stamp: 'ar 4/10/2005 18:03'!evalStrings	   "Allows you to construct literal arrays.    #(true false nil '5@6' 'Set new' '''text string''') evalStrings    gives an array with true, false, nil, a Point, a Set, and a String    instead of just a bunch of Symbols"    | it |    ^ self collect: [:each |        it := each.        each == #true ifTrue: [it := true].		      each == #false ifTrue: [it := false].        each == #nil ifTrue: [it := nil].        (each isString and:[each isSymbol not]) ifTrue: [			it := Compiler evaluate: each].        each class == Array ifTrue: [it := it evalStrings].        it]! !!Array methodsFor: 'file in/out' stamp: 'tk 9/28/2000 15:35'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  If I am one of two shared global arrays, write a proxy instead."self == (TextConstants at: #DefaultTabsArray) ifTrue: [	dp := DiskProxy global: #TextConstants selector: #at: args: #(DefaultTabsArray).	refStrm replace: self with: dp.	^ dp].self == (TextConstants at: #DefaultMarginTabsArray) ifTrue: [	dp := DiskProxy global: #TextConstants selector: #at: args: #(DefaultMarginTabsArray).	refStrm replace: self with: dp.	^ dp].^ super objectForDataStream: refStrm! !!Array methodsFor: 'private' stamp: 'md 1/20/2006 16:53'!hasLiteralThorough: literal	"Answer true if literal is identical to any literal in this array, even if imbedded in further array structures or closure methods"	| lit |	1 to: self size do: [:index |		(lit := self at: index) == literal ifTrue: [^ true].		(lit hasLiteralThorough: literal) ifTrue: [^ true]].	^ false! !!Array methodsFor: 'private' stamp: 'sma 6/3/2000 21:39'!hasLiteral: literal	"Answer true if literal is identical to any literal in this array, even 	if imbedded in further array structure. This method is only intended 	for private use by CompiledMethod hasLiteralSymbol:"	| lit |	1 to: self size do: 		[:index | 		(lit := self at: index) == literal ifTrue: [^ true].		(lit class == Array and: [lit hasLiteral: literal]) ifTrue: [^ true]].	^ false! !!Array methodsFor: 'private' stamp: 'md 3/1/2006 21:09'!hasLiteralSuchThat: testBlock	"Answer true if testBlock returns true for any literal in this array, even if imbedded in 	further Arrays or CompiledMethods.  This method is only intended for private use by 	CompiledMethod 	hasLiteralSuchThat:"	| lit |	1 to: self size do: [:index |		(testBlock value: (lit := self at: index)) ifTrue: [^ true].		(lit hasLiteralSuchThat: testBlock) ifTrue: [^ true]].	^ false! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:16'!braceWith: a	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array := self new: 1.	array at: 1 put: a.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:15'!braceWith: a with: b 	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array := self new: 2.	array at: 1 put: a.	array at: 2 put: b.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:17'!braceWith: a with: b with: c 	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array := self new: 3.	array at: 1 put: a.	array at: 2 put: b.	array at: 3 put: c.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:17'!braceWith: a with: b with: c with: d	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array := self new: 4.	array at: 1 put: a.	array at: 2 put: b.	array at: 3 put: c.	array at: 4 put: d.	^ array! !!ArrayTest methodsFor: 'testing' stamp: 'dc 5/24/2007 10:56'!testNewWithSize	|array|	array := Array new: 5.	self assert: array size = 5.	1 to: 5 do: [:index | self assert: (array at: index) isNil]! !!ArrayTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:40'!testAtWrap	|tabTest|	tabTest := #(5 6 8).	self assert:(tabTest atWrap: 2) = 6.	self assert:(tabTest atWrap:7) = 5.	self assert:( tabTest atWrap:5) = 6.	self assert:(tabTest atWrap:0)= 8.	self assert:(tabTest atWrap:1)= 5.	self assert:(tabTest atWrap:-2) = 5.! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 17:36'!swapHalves		"A normal switch in endianness (byte order in words) reverses the order of 4 bytes.  That is not correct for SoundBuffers, which use 2-bytes units.  If a normal switch has be done, this method corrects it further by swapping the two halves of the long word.	This method is only used for 16-bit quanities in SoundBuffer, ShortIntegerArray, etc."	| hack blt |	"The implementation is a hack, but fast for large ranges"	hack := Form new hackBits: self.	blt := (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: 0; destY: 0; height: self size; width: 2.	blt sourceX: 0; destX: 2; copyBits.  "Exchange bytes 0&1 with 2&3"	blt sourceX: 2; destX: 0; copyBits.	blt sourceX: 0; destX: 2; copyBits.! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 6/1/2000 11:57'!isSorted	"Return true if the receiver is sorted by the given criterion.	Optimization for isSortedBy: [:a :b | a <= b]."	| lastElm elm |	self isEmpty ifTrue: [^ true].	lastElm := self first.	2 to: self size do: 		[:index | 		elm := self at: index.		lastElm <= elm ifFalse: [^ false].		lastElm := elm].	^ true! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 6/1/2000 11:58'!isSortedBy: aBlock	"Return true if the receiver is sorted by the given criterion."	| lastElm elm |	self isEmpty ifTrue: [^ true].	lastElm := self first.	2 to: self size do: 		[:index | 		elm := self at: index.		(aBlock value: lastElm value: elm) ifFalse: [^ false].		lastElm := elm].	^ true! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:28'!mergeFirst: first middle: middle last: last into: dst by: aBlock	"Private. Merge the sorted ranges [first..middle] and [middle+1..last] 	of the receiver into the range [first..last] of dst."	| i1 i2 val1 val2 out |	i1 := first.	i2 := middle + 1.	val1 := self at: i1.	val2 := self at: i2.	out := first - 1.  "will be pre-incremented"	"select 'lower' half of the elements based on comparator"	[(i1 <= middle) and: [i2 <= last]] whileTrue:		[(aBlock value: val1 value: val2)			ifTrue: [dst at: (out := out + 1) put: val1.					val1 := self at: (i1 := i1 + 1)]			ifFalse: [dst at: (out := out + 1) put: val2.					i2 := i2 + 1.					i2 <= last ifTrue: [val2 := self at: i2]]].	"copy the remaining elements"	i1 <= middle		ifTrue: [dst replaceFrom: out + 1 to: last with: self startingAt: i1]		ifFalse: [dst replaceFrom: out + 1 to: last with: self startingAt: i2]! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:26'!mergeSortFrom: first to: last src: src dst: dst by: aBlock	"Private. Split the range to be sorted in half, sort each half, and 	merge the two half-ranges into dst."	| middle |	first = last ifTrue: [^ self].	middle := (first + last) // 2.	self mergeSortFrom: first to: middle src: dst dst: src by: aBlock.	self mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.	src mergeFirst: first middle: middle last: last into: dst by: aBlock! !!ArrayedCollection methodsFor: 'private'!storeElementsFrom: firstIndex to: lastIndex on: aStream	| noneYet defaultElement arrayElement |	noneYet := true.	defaultElement := self defaultElement.	firstIndex to: lastIndex do: 		[:index | 		arrayElement := self at: index.		arrayElement = defaultElement			ifFalse: 				[noneYet					ifTrue: [noneYet := false]					ifFalse: [aStream nextPut: $;].				aStream nextPutAll: ' at: '.				aStream store: index.				aStream nextPutAll: ' put: '.				aStream store: arrayElement]].	^noneYet! !!ArrayedCollection class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newArray |	newArray := self new: aCollection size.	1 to: aCollection size do: [:i | newArray at: i put: (aCollection at: i)].	^ newArray"	Array newFrom: {1. 2. 3}	{1. 2. 3} as: Array	{1. 2. 3} as: ByteArray	{$c. $h. $r} as: String	{$c. $h. $r} as: Text"! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'ar 5/17/2001 19:50'!newFromStream: s	"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk."	| len |	self isPointers | self isWords not ifTrue: [^ super newFromStream: s].		"super may cause an error, but will not be called."	s next = 16r80 ifTrue:		["A compressed format.  Could copy what BitMap does, or use a 		special sound compression format.  Callers normally compress their own way."		^ self error: 'not implemented'].	s skip: -1.	len := s nextInt32.	^ s nextWordsInto: (self basicNew: len)! !!ArrayedCollection class methodsFor: 'instance creation'!with: anObject 	"Answer a new instance of me, containing only anObject."	| newCollection |	newCollection := self new: 1.	newCollection at: 1 put: anObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation'!with: firstObject with: secondObject 	"Answer a new instance of me, containing firstObject and secondObject."	| newCollection |	newCollection := self new: 2.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation'!with: firstObject with: secondObject with: thirdObject 	"Answer a new instance of me, containing only the three arguments as	elements."	| newCollection |	newCollection := self new: 3.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation'!with: firstObject with: secondObject with: thirdObject with: fourthObject 	"Answer a new instance of me, containing only the three arguments as	elements."	| newCollection |	newCollection := self new: 4.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer a new instance of me, containing only the five arguments as	elements."	| newCollection |	newCollection := self new: 5.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'sw 10/24/1998 22:22'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer a new instance of me, containing only the 6 arguments as elements."	| newCollection |	newCollection := self new: 6.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	newCollection at: 6 put: sixthObject.	^ newCollection! !!AssignmentTileMorph methodsFor: 'code generation' stamp: 'sw 2/6/2002 01:25'!operatorForAssignmentSuffix: aString	"Answer the operator associated with the receiver, assumed to be one of the compound assignments"	| toTest |	toTest := aString asString.	#(	('Incr:'				'+')		('Decr:'				'-')		('Mult:'				'*'))	do:		[:pair | toTest = pair first ifTrue: [^ pair second]].	^ toTest	"AssignmentTileMorph new operatorForAssignmentSuffix: 'Incr:'"! !!AssignmentTileMorph methodsFor: 'initialization' stamp: 'yo 1/30/2005 11:11'!computeOperatorOrExpression	"Compute the operator or expression to use, and set the wording correectly on the tile face"	| aSuffix wording anInterface getter doc |	operatorOrExpression := (assignmentRoot, assignmentSuffix) asSymbol.	aSuffix := self currentVocabulary translatedWordingFor:  assignmentSuffix.	getter := Utilities getterSelectorFor: assignmentRoot.	anInterface := self currentVocabulary methodInterfaceAt: getter ifAbsent: [Vocabulary eToyVocabulary methodInterfaceAt: getter ifAbsent: [nil]].	wording := anInterface ifNotNil: [anInterface wording] ifNil: [assignmentRoot copyWithout: $:].	(anInterface notNil and: [(doc := anInterface documentation) notNil])		ifTrue:			[self setBalloonText: doc].	operatorReadoutString := wording translated, ' ', aSuffix. 	self line1: operatorReadoutString.	self addArrowsIfAppropriate! !!AssignmentTileMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:44'!initialize"initialize the state of the receiver"	super initialize.""	type := #operator.	assignmentSuffix := ':'! !!AssignmentTileMorph methodsFor: 'initialization' stamp: 'sw 1/17/1999 21:10'!setAssignmentSuffix: aString	assignmentSuffix := aString.	self computeOperatorOrExpression.	type := #operator. 	self line1: (ScriptingSystem wordingForOperator: operatorOrExpression).	self addArrowsIfAppropriate; updateLiteralLabel! !!AssignmentTileMorph methodsFor: 'initialization' stamp: 'yo 1/1/2004 19:50'!setRoot: aString	"Establish the assignment root, and update the label on the tile"	assignmentRoot := aString.	self updateLiteralLabel! !!AssignmentTileMorph methodsFor: 'initialization' stamp: 'sw 2/16/98 01:12'!setRoot: aString dataType: aSymbol	assignmentRoot := aString.	assignmentSuffix := ':'.	dataType := aSymbol.	self updateLiteralLabel! !!Association methodsFor: 'accessing'!key: aKey value: anObject 	"Store the arguments as the variables of the receiver."	key := aKey.	value := anObject! !!Association methodsFor: 'accessing'!value: anObject 	"Store the argument, anObject, as the value of the receiver."	value := anObject! !!Association methodsFor: 'objects from disk' stamp: 'tk 10/3/2000 13:03'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  If I am a known global, write a proxy that will hook up with the same resource in the destination system."	^ (Smalltalk associationAt: key ifAbsent: [nil]) == self 		ifTrue: [dp := DiskProxy global: #Smalltalk selector: #associationOrUndeclaredAt: 							args: (Array with: key).			refStrm replace: self with: dp.			dp]		ifFalse: [self]! !!AsyncFile methodsFor: 'as yet unclassified' stamp: 'ar 6/3/2007 22:13'!open: fullFileName forWrite: aBoolean	"Open a file of the given name, and return a handle for that file. Answer the receiver if the primitive succeeds, nil otherwise.	If openForWrite is true, then:		if there is no existing file with this name, then create one		else open the existing file in read-write mode	otherwise:		if there is an existing file with this name, then open it read-only		else answer nil."	"Note: if an exisiting file is opened for writing, it is NOT truncated. If truncation is desired, the file should be deleted before being opened as an asynchronous file."	"Note: On some platforms (e.g., Mac), a file can only have one writer at a time."	| semaIndex |	name := fullFileName.	writeable := aBoolean.	semaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	fileHandle := self primOpen: name asVmPathName forWrite: writeable semaIndex: semaIndex.	fileHandle ifNil: [		Smalltalk unregisterExternalObject: semaphore.		semaphore := nil.		^ nil].! !!AttributedTextStream methodsFor: 'access' stamp: 'ar 10/16/2001 22:57'!currentAttributes: newAttributes	"set the current attributes"	(currentRun > 0 and:[currentAttributes ~= newAttributes]) ifTrue:[		attributeRuns nextPut: currentRun.		attributeValues nextPut: currentAttributes.		currentRun := 0.	].	currentAttributes := newAttributes.! !!AttributedTextStream methodsFor: 'retrieving the text' stamp: 'ar 10/16/2001 22:39'!contents	| ans |	currentRun > 0 ifTrue:[		attributeValues nextPut: currentAttributes.		attributeRuns nextPut: currentRun.		currentRun := 0].	ans := Text new: characters size.	"this is declared private, but it's exactly what I need, and it's declared as exactly what I want it to do...."	ans setString: characters contents  setRuns: 		(RunArray runs: attributeRuns contents values: attributeValues contents).	^ans! !!AttributedTextStream methodsFor: 'stream protocol' stamp: 'ar 10/16/2001 22:38'!nextPut: aChar	currentRun := currentRun + 1.	characters nextPut: aChar! !!AttributedTextStream methodsFor: 'stream protocol' stamp: 'ar 10/16/2001 22:38'!nextPutAll: aString	"add an entire string with the same attributes"	currentRun := currentRun + aString size.	characters nextPutAll: aString.! !!AttributedTextStream methodsFor: 'private-initialization' stamp: 'ar 10/16/2001 22:40'!initialize	characters := WriteStream on: String new.	currentAttributes := OrderedCollection new.	currentRun := 0.	attributeValues := WriteStream on: (Array new: 50).	attributeRuns := WriteStream on: (Array new: 50).	! !!Bag methodsFor: 'accessing' stamp: 'tao 1/5/2000 18:25'!cumulativeCounts	"Answer with a collection of cumulative percents covered by elements so far."	| s n |	s := self size / 100.0. n := 0.	^ self sortedCounts asArray collect:		[:a | n := n + a key. (n / s roundTo: 0.1) -> a value]! !!Bag methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:35'!size	"Answer how many elements the receiver contains."	| tally |	tally := 0.	contents do: [:each | tally := tally + each].	^ tally! !!Bag methodsFor: 'accessing' stamp: 'sma 6/15/2000 17:00'!sortedCounts	"Answer with a collection of counts with elements, sorted by decreasing	count."	| counts |	counts := SortedCollection sortBlock: [:x :y | x >= y].	contents associationsDo:		[:assn |		counts add: (Association key: assn value value: assn key)].	^ counts! !!Bag methodsFor: 'accessing'!sortedElements	"Answer with a collection of elements with counts, sorted by element."	| elements |	elements := SortedCollection new.	contents associationsDo: [:assn | elements add: assn].	^elements! !!Bag methodsFor: 'removing' stamp: 'sma 5/12/2000 14:32'!remove: oldObject ifAbsent: exceptionBlock 	"Refer to the comment in Collection|remove:ifAbsent:."	| count |	count := contents at: oldObject ifAbsent: [^ exceptionBlock value].	count = 1		ifTrue: [contents removeKey: oldObject]		ifFalse: [contents at: oldObject put: count - 1].	^ oldObject! !!Bag methodsFor: 'private' stamp: 'sma 5/12/2000 14:49'!setContents: aDictionary	contents := aDictionary! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'tk 12/9/97 13:34'!mimeDecode	"Convert a stream in base 64 with only a-z,A-Z,0-9,+,/ to a full byte stream of characters.  Reutrn a whole stream for the user to read."	| nibA nibB nibC nibD |	[mimeStream atEnd] whileFalse: [		(nibA := self nextValue) ifNil: [^ dataStream].		(nibB := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibA bitShift: 2) + (nibB bitShift: -4)) asCharacter.		nibB := nibB bitAnd: 16rF.		(nibC := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibB bitShift: 4) + (nibC bitShift: -2)) asCharacter.		nibC := nibC bitAnd: 16r3.		(nibD := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibC bitShift: 6) + nibD) asCharacter.		].	^ dataStream! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'tk 12/9/97 13:39'!mimeDecodeToByteArray	"Convert a stream in base 64 with only a-z,A-Z,0-9,+,/ to a full ByteArray of 0-255 values.  Reutrn a whole stream for the user to read."	| nibA nibB nibC nibD |	[mimeStream atEnd] whileFalse: [		(nibA := self nextValue) ifNil: [^ dataStream].		(nibB := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibA bitShift: 2) + (nibB bitShift: -4)).		nibB := nibB bitAnd: 16rF.		(nibC := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibB bitShift: 4) + (nibC bitShift: -2)).		nibC := nibC bitAnd: 16r3.		(nibD := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibC bitShift: 6) + nibD).		].	^ dataStream! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'ls 2/10/2001 13:26'!mimeEncode	"Convert from data to 6 bit characters."	| phase1 phase2 raw nib lineLength |	phase1 := phase2 := false.	lineLength := 0.	[dataStream atEnd] whileFalse: [		lineLength >= 70 ifTrue: [ mimeStream cr.  lineLength := 0. ].		data := raw := dataStream next asInteger.		nib := (data bitAnd: 16rFC) bitShift: -2.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw := dataStream next) ifNil: [raw := 0. phase1 := true].		data := ((data bitAnd: 3) bitShift: 8) + raw asInteger.		nib := (data bitAnd: 16r3F0) bitShift: -4.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw := dataStream next) ifNil: [raw := 0. phase2 := true].		data := ((data bitAnd: 16rF) bitShift: 8) + (raw asInteger).		nib := (data bitAnd: 16rFC0) bitShift: -6.		mimeStream nextPut: (ToCharTable at: nib+1).		nib := (data bitAnd: 16r3F).		mimeStream nextPut: (ToCharTable at: nib+1).		lineLength := lineLength + 4.].	phase1 ifTrue: [mimeStream skip: -2; nextPut: $=; nextPut: $=.			^ mimeStream].	phase2 ifTrue: [mimeStream skip: -1; nextPut: $=.			^ mimeStream].! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'tk 12/9/97 13:21'!nextValue	"The next six bits of data char from the mimeStream, or nil.  Skip all other chars"	| raw num |	[raw := mimeStream next.	raw ifNil: [^ nil].	"end of stream"	raw == $= ifTrue: [^ nil].	num := FromCharTable at: raw asciiValue + 1.	num ifNotNil: [^ num].	"else ignore space, return, tab, ..."	true] whileTrue.! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 2/19/2000 15:53'!decodeInteger: mimeString	| bytes sum |	"Decode the MIME string into an integer of any length"	bytes := (Base64MimeConverter mimeDecodeToBytes: 				(ReadStream on: mimeString)) contents.	sum := 0.	bytes reverseDo: [:by | sum := sum * 256 + by].	^ sum! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 2/21/2000 17:22'!encodeInteger: int	| strm |	"Encode an integer of any length and return the MIME string"	strm := ReadWriteStream on: (ByteArray new: int digitLength).	1 to: int digitLength do: [:ii | strm nextPut: (int digitAt: ii)].	strm reset.	^ ((self mimeEncode: strm) contents) copyUpTo: $=	"remove padding"! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 13:53'!initialize	FromCharTable := Array new: 256.	"nils"	ToCharTable := Array new: 64.	($A asciiValue to: $Z asciiValue) doWithIndex: [:val :ind | 		FromCharTable at: val+1 put: ind-1.		ToCharTable at: ind put: val asCharacter].	($a asciiValue to: $z asciiValue) doWithIndex: [:val :ind | 		FromCharTable at: val+1 put: ind+25.		ToCharTable at: ind+26 put: val asCharacter].	($0 asciiValue to: $9 asciiValue) doWithIndex: [:val :ind | 		FromCharTable at: val+1 put: ind+25+26.		ToCharTable at: ind+26+26 put: val asCharacter].	FromCharTable at: $+ asciiValue + 1 put: 62.	ToCharTable at: 63 put: $+.	FromCharTable at: $/ asciiValue + 1 put: 63.	ToCharTable at: 64 put: $/.	! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 12/12/97 11:41'!mimeDecodeToBytes: aStream 	"Return a RWBinaryOrTextStream of the original ByteArray.  aStream has only 65 innocuous character values.  aStream is not binary.  (See class comment). 4 bytes in aStream goes to 3 bytes in output."	| me |	aStream position: 0.	me := self new mimeStream: aStream.	me dataStream: (RWBinaryOrTextStream on: (ByteArray new: aStream size * 3 // 4)).	me mimeDecodeToByteArray.	me dataStream position: 0.	^ me dataStream! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 13:01'!mimeDecodeToChars: aStream 	"Return a ReadWriteStream of the original String.  aStream has only 65 innocuous character values.  It is not binary.  (See class comment). 4 bytes in aStream goes to 3 bytes in output."	| me |	aStream position: 0.	me := self new mimeStream: aStream.	me dataStream: (ReadWriteStream on: (String new: aStream size * 3 // 4)).	me mimeDecode.	me dataStream position: 0.	^ me dataStream! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 12:28'!mimeEncode: aStream	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."	| me |	aStream position: 0.	me := self new dataStream: aStream.	me mimeStream: (ReadWriteStream on: (String new: aStream size + 20 * 4 // 3)).	me mimeEncode.	me mimeStream position: 0.	^ me mimeStream! !!BitEditor methodsFor: 'control defaults'!redButtonActivity	| formPoint displayPoint |	model depth = 1 ifTrue:		["If this is just a black&white form, then set the color to be		the opposite of what it was where the mouse was clicked"		formPoint := (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.		color := 1-(view workingForm pixelValueAt: formPoint).		squareForm fillColor: (color=1 ifTrue: [Color black] ifFalse: [Color white])].	[sensor redButtonPressed]	  whileTrue: 		[formPoint := (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.		displayPoint := view displayTransform: formPoint.		squareForm 			displayOn: Display			at: displayPoint 			clippingBox: view insetDisplayBox 			rule: Form over			fillColor: nil.		view changeValueAt: formPoint put: color]! !!BitEditor methodsFor: 'initialize-release'!release	super release.	squareForm release.	squareForm := nil! !!BitEditor methodsFor: 'menu messages' stamp: 'BG 12/5/2003 13:53'!getCurrentColor	| formExtent form c |	c := Color colorFromPixelValue: color depth: Display depth.	formExtent := 30@30" min: 10@ 10//(2+1@2)".  "compute this better"	form := Form extent: formExtent depth: Display depth.	form borderWidth: 5.	form border: form boundingBox width: 4 fillColor: Color white.	form fill: form boundingBox fillColor: c.	^form! !!BitEditor methodsFor: 'menu messages' stamp: 'BG 12/5/2003 13:21'!setColor: aColor 	"Set the color that the next edited dots of the model to be the argument,  	aSymbol. aSymbol can be any color changing message understood by a  	Form, such as white or black."	color := aColor pixelValueForDepth: Display depth.	squareForm fillColor: aColor.	self changed: #getCurrentColor! !!BitEditor methodsFor: 'menu messages' stamp: 'sma 3/15/2000 21:10'!setTransparentColor	squareForm fillColor: Color gray.	color := Color transparent! !!BitEditor methodsFor: 'view access'!view: aView	super view: aView.	scale := aView transformation scale.		scale := scale x rounded @ scale y rounded.	squareForm := Form extent: scale depth: aView model depth.	squareForm fillBlack! !!BitEditor class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 14:48'!initialize	"The Bit Editor is the only controller to override the use of the blue	button with a different pop-up menu. Initialize this menu."	YellowButtonMenu := SelectionMenu		labels:'cancelacceptfile outtest'		lines: #(2 3)		selections: #(cancel accept fileOut test)	"BitEditor initialize"! !!BitEditor class methodsFor: 'examples'!magnifyOnScreen	"Bit editing of an area of the display screen. User designates a 	rectangular area that is magnified by 8 to allow individual screens dots to	be modified. red button is used to set a bit to black and yellow button is	used to set a bit to white. Editor is not scheduled in a view. Original	screen location is updated immediately. This is the same as FormEditor	magnify."	| smallRect smallForm scaleFactor tempRect |	scaleFactor := 8 @ 8.	smallRect := Rectangle fromUser.	smallRect isNil ifTrue: [^self].	smallForm := Form fromDisplay: smallRect.	tempRect := self locateMagnifiedView: smallForm scale: scaleFactor.	"show magnified form size until mouse is depressed"	self		openScreenViewOnForm: smallForm 		at: smallRect topLeft 		magnifiedAt: tempRect topLeft 		scale: scaleFactor	"BitEditor magnifyOnScreen."! !!BitEditor class methodsFor: 'examples'!magnifyWithSmall"	Also try:	BitEditor openOnForm:		(Form extent: 32@32 depth: Display depth)	BitEditor openOnForm:		((MaskedForm extent: 32@32 depth: Display depth)		withTransparentPixelValue: -1)"	"Open a BitEditor viewing an area on the screen which the user chooses"	| area form |	area := Rectangle fromUser.	area isNil ifTrue: [^ self].	form := Form fromDisplay: area.	self openOnForm: form	"BitEditor magnifyWithSmall."! !!BitEditor class methodsFor: 'instance creation'!openOnForm: aForm 	"Create and schedule a BitEditor on the form aForm at its top left corner. 	Show the small and magnified view of aForm."	| scaleFactor |	scaleFactor := 8 @ 8.	^self openOnForm: aForm		at: (self locateMagnifiedView: aForm scale: scaleFactor) topLeft		scale: scaleFactor! !!BitEditor class methodsFor: 'instance creation'!openOnForm: aForm at: magnifiedLocation scale: scaleFactor 	"Create and schedule a BitEditor on the form aForm. Show the small and 	magnified view of aForm."	| aScheduledView |	aScheduledView := self				bitEdit: aForm				at: magnifiedLocation				scale: scaleFactor				remoteView: nil.	aScheduledView controller openDisplayAt:		aScheduledView displayBox topLeft + (aScheduledView displayBox extent / 2)! !!BitEditor class methodsFor: 'instance creation' stamp: 'sma 3/11/2000 11:29'!openScreenViewOnForm: aForm at: formLocation magnifiedAt: magnifiedLocation scale: scaleFactor	"Create and schedule a BitEditor on the form aForm. Show the magnified	view of aForm in a scheduled window."	| smallFormView bitEditor savedForm r |	smallFormView := FormView new model: aForm.	smallFormView align: smallFormView viewport topLeft with: formLocation.	bitEditor := self bitEdit: aForm at: magnifiedLocation scale: scaleFactor remoteView: smallFormView.	savedForm := Form fromDisplay: (r := bitEditor displayBox expandBy: (0@23 corner: 0@0)).	bitEditor controller startUp.	savedForm displayOn: Display at: r topLeft.	bitEditor release.	smallFormView release.	"BitEditor magnifyOnScreen."! !!BitEditor class methodsFor: 'private' stamp: 'BG 12/4/2003 10:18'!bitEdit: aForm at: magnifiedFormLocation scale: scaleFactor remoteView: remoteView	"Create a BitEditor on aForm. That is, aForm is a small image that will 	change as a result of the BitEditor changing a second and magnified 	view of me. magnifiedFormLocation is where the magnified form is to be 	located on the screen. scaleFactor is the amount of magnification. This 	method implements a scheduled view containing both a small and 	magnified view of aForm. Upon accept, aForm is updated."	| aFormView scaledFormView bitEditor topView extent menuView lowerRightExtent |	scaledFormView := FormHolderView new model: aForm.	scaledFormView scaleBy: scaleFactor.	bitEditor := self new.	scaledFormView controller: bitEditor.	bitEditor setColor: Color black.	topView := ColorSystemView new.	remoteView == nil ifTrue: [topView label: 'Bit Editor'].	topView borderWidth: 2.	topView addSubView: scaledFormView.	remoteView == nil		ifTrue:  "If no remote view, then provide a local view of the form"			[aFormView := FormView new model: scaledFormView workingForm.			aFormView controller: NoController new.			aForm height < 50				ifTrue: [aFormView borderWidthLeft: 0 right: 2 top: 2 bottom: 2]				ifFalse: [aFormView borderWidthLeft: 0 right: 2 top: 2 bottom: 0].			topView addSubView: aFormView below: scaledFormView]		 ifFalse:  "Otherwise, the remote one should view the same form"			[remoteView model: scaledFormView workingForm].	lowerRightExtent := remoteView == nil			ifTrue:				[(scaledFormView viewport width - aFormView viewport width) @					(aFormView viewport height max: 50)]			ifFalse:				[scaledFormView viewport width @ 50].	menuView := self buildColorMenu: lowerRightExtent colorCount: 1.	menuView model: bitEditor.	menuView borderWidthLeft: 0 right: 0 top: 2 bottom: 0.	topView		addSubView: menuView		align: menuView viewport topRight		with: scaledFormView viewport bottomRight.	extent := scaledFormView viewport extent + (0 @ lowerRightExtent y)			+ (4 @ 4).  "+4 for borders"	topView minimumSize: extent.	topView maximumSize: extent.	topView translateBy: magnifiedFormLocation.	topView insideColor: Color white.	^topView! !!BitEditor class methodsFor: 'private' stamp: 'BG 12/5/2003 13:40'!buildColorMenu: extent colorCount: nColors	"See BitEditor magnifyWithSmall."	| menuView form aSwitchView	 button formExtent highlightForm color leftOffset |	menuView := FormMenuView new.	menuView window: (0@0 corner: extent).	formExtent := 30@30 min: extent//(nColors*2+1@2).  "compute this better"	leftOffset := extent x-(nColors*2-1*formExtent x)//2.	highlightForm := Form extent: formExtent.	highlightForm borderWidth: 4.	1 to: nColors do: [:index | 		color := (nColors = 1			ifTrue: [#(black)]			ifFalse: [#(black gray)]) at: index.		form := Form extent: formExtent.		form fill: form boundingBox fillColor: (Color perform: color).		form borderWidth: 5.		form border: form boundingBox width: 4 fillColor: Color white.		button := Button new.		aSwitchView := PluggableButtonView			on: button			getState: #isOn			action: #turnOn			label: #getCurrentColor.		index = 1			ifTrue: [button onAction: [menuView model setColor: Color fromUser.									  aSwitchView label: menuView model getCurrentColor;									                  displayView					                     ]				    ]			ifFalse: [button onAction: [menuView model setTransparentColor]].		aSwitchView			shortcutCharacter: ((nColors=3 ifTrue: ['xvn'] ifFalse: ['xn']) at: index);			label: form;			window: (0@0 extent: form extent);			translateBy: (((index - 1) * 2 * form width) + leftOffset)@(form height // 2);			borderWidth: 1.		menuView addSubView: aSwitchView].	^ menuView! !!BlockClosure methodsFor: 'accessing' stamp: 'ms 5/10/2007 11:21'!hasLiteralThorough: literal	"Answer true if literal is identical to any literal imbedded in my method"	method == literal ifTrue: [^ true].	^ method hasLiteralThorough: literal from: self! !!BlockClosure methodsFor: 'comparing' stamp: 'ms 8/8/2007 11:49'!= other	self class == other class ifFalse: [^ false].	self env = other env ifFalse: [^ false].	self method == other method ifTrue: [^true].	^ self method = other method! !!BlockClosure methodsFor: 'evaluating' stamp: 'ar 8/17/2007 13:14'!valueWithin: aDuration onTimeout: timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| theProcess delay watchdog |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: TimedOut ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	^ [	watchdog resume.					"start up the watchdog"		self ensure:[							"evaluate the receiver"			theProcess := nil.				"it has completed, so ..."			delay delaySemaphore signal.	"arrange for the watchdog to exit"		]] on: TimedOut do: [ :e | timeoutBlock value ].! !!BlockClosureTest methodsFor: 'utils' stamp: 'ms 5/9/2007 12:44'!exempleBlock	"BlockClosureTest>>#exempleBlock"	| b |	i := 21. 	j := 0.	b := #(1 2 3) .	b value.	^j! !!BlockClosureTest methodsFor: 'utils' stamp: 'ms 5/9/2007 11:47'!exempleClosure	"BlockClosureTest>>#exempleClosure"	(i:= i-1) > 0 		ifTrue: [j := j+1 . #(1 2 3) value.] 		ifFalse:[j]! !!BlockClosureTest methodsFor: 'utils' stamp: 'ms 8/8/2007 11:47'!exempleClosureEqual1	^3 + 7! !!BlockClosureTest methodsFor: 'utils' stamp: 'ms 8/8/2007 11:47'!exempleClosureEqual2	^3 + 7! !!BlockClosureTest methodsFor: 'running' stamp: 'ms 5/10/2007 11:27'!setUp	closure := BlockClosureTest >> #exempleClosure createBlock: self.	BlockClosureTest >> #exempleBlock literalAt: 2 put: closure.	BlockClosureTest >> #exempleClosure literalAt: 1 put: closure! !!BlockClosureTest methodsFor: 'tests' stamp: 'ms 5/10/2007 11:24'!testComparing	"self debug: #testComparing"		self shouldnt: [(BlockClosureTest>>#exempleBlock) = (BlockClosureTest>>#exempleBlock)] raise: Error.	self assert: (BlockClosureTest>>#exempleBlock) = (BlockClosureTest>>#exempleBlock).	self assert: ((BlockClosureTest>>#exempleBlock) valueWithReceiver: self arguments: #()) = 20! !!BlockClosureTest methodsFor: 'tests' stamp: 'ms 8/8/2007 11:48'!testComparingEqual		self assert: ((BlockClosureTest>>#exempleClosureEqual1) createBlock: self) 		= ((BlockClosureTest>>#exempleClosureEqual2)  createBlock: self).! !!BlockClosureTest methodsFor: 'tests' stamp: 'ms 5/10/2007 11:30'!testHasLiteral	"self debug: #testComparing"	self shouldnt: [closure hasLiteralThorough: #exemple]		raise: Error.	self assert: (closure hasLiteralThorough: #exemple) not! !!BlockContext methodsFor: 'evaluating' stamp: 'ar 8/17/2007 13:15'!valueWithin: aDuration onTimeout: timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| theProcess delay watchdog |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: TimedOut ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	^ [	watchdog resume.				"start up the watchdog"		self ensure:[						"evaluate the receiver"			theProcess := nil.				"it has completed, so ..."			delay delaySemaphore signal.	"arrange for the watchdog to exit"		]] on: TimedOut do: [ :e | timeoutBlock value ].! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36'!addCornerGrips	self		addMorphBack: (TopLeftGripMorph new target: self; position: self position).	self		addMorphBack: (TopRightGripMorph new target: self; position: self position).	self		addMorphBack: (BottomLeftGripMorph new target: self;position: self position).	self		addMorphBack: (BottomRightGripMorph new target: self;position: self position)! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36'!addPaneHSplitterBetween: topMorph and: bottomMorphs	| targetY minX maxX splitter |	targetY _ topMorph layoutFrame bottomFraction.	minX _ (bottomMorphs detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.	maxX _ (bottomMorphs detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.	splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.	splitter layoutFrame: (LayoutFrame		fractions: (minX @ targetY corner: maxX @ targetY)		offsets: (((topMorph layoutFrame leftOffset ifNil: [0]) @ 0 corner: (topMorph layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (topMorph layoutFrame bottomOffset ifNil: [0]))).	self addMorphBack: (splitter position: self position).! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:34'!addPaneSplitters	| splitter remaining target targetX sameX minY maxY targetY sameY minX maxX |	self removePaneSplitters.	self removeCornerGrips.	remaining _ submorphs reject: [:each | each layoutFrame rightFraction = 1].	[remaining notEmpty] whileTrue:		[target _ remaining first.		targetX _ target layoutFrame rightFraction.		sameX _ submorphs select: [:each | each layoutFrame rightFraction = targetX].		minY _ (sameX detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.		maxY _ (sameX detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.		splitter layoutFrame: (LayoutFrame			fractions: (targetX @ minY corner: targetX @ maxY)			offsets: ((0 @ (target layoutFrame topOffset ifNil: [0]) corner: 4 @ (target layoutFrame bottomOffset ifNil: [0])) translateBy: (target layoutFrame rightOffset ifNil: [0]) @ 0)).		self addMorphBack: (splitter position: self position).		remaining _ remaining copyWithoutAll: sameX].	remaining _ submorphs copy reject: [:each | each layoutFrame bottomFraction = 1].	[remaining notEmpty]		whileTrue: [target _ remaining first.			targetY _ target layoutFrame bottomFraction.			sameY _ submorphs select: [:each | each layoutFrame bottomFraction = targetY].			minX _ (sameY detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.			maxX _ (sameY detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.			splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.			splitter layoutFrame: (LayoutFrame				fractions: (minX @ targetY corner: maxX @ targetY)				offsets: (((target layoutFrame leftOffset ifNil: [0]) @ 0 corner: (target layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (target layoutFrame bottomOffset ifNil: [0]))).			self addMorphBack: (splitter position: self position).			remaining _ remaining copyWithoutAll: sameY].	self linkSubmorphsToSplitters.	self splitters do: [:each | each comeToFront].! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:37'!addPaneVSplitterBetween: leftMorph and: rightMorphs 	| targetX minY maxY splitter |	targetX _ leftMorph layoutFrame rightFraction.	minY _ (rightMorphs detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.	maxY _ (rightMorphs detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.	splitter layoutFrame: (LayoutFrame		fractions: (targetX @ minY corner: targetX @ maxY)		offsets: ((0 @ (leftMorph layoutFrame topOffset ifNil: [0]) corner: (4@ (leftMorph layoutFrame bottomOffset ifNil: [0]))) translateBy: (leftMorph layoutFrame rightOffset ifNil: [0]) @ 0)).	self addMorphBack: (splitter position: self position).! !!BraceNode methodsFor: '*eToys-tiles' stamp: 'di 11/13/2000 21:17'!asMorphicSyntaxIn: parent	| row |	row := (parent addRow: #brace on: self) layoutInset: 1.	row addMorphBack: (StringMorph new contents: 		(String streamContents: [:aStream | self printOn: aStream indent: 0])).	^row! !!BreakpointManager class methodsFor: 'install-uninstall' stamp: 'tpr 9/26/2006 16:14'!installInClass: aClass selector: aSymbol 	"Install a new method containing a breakpoint.	The receiver will remember this for unstalling it later"	| breakMethod |	breakMethod _ self compilePrototype: aSymbol in: aClass.	breakMethod isNil		ifTrue: [^ nil].	self installed at: breakMethod put: aClass >> aSymbol. "old method"	aClass class basicAddSelector: aSymbol withMethod: breakMethod.! !!Button methodsFor: 'state'!turnOff	"Sets the state of the receiver to 'off'. The off action of the receiver is not  	executed."	on := false! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/9/2001 09:43'!actWhen: condition	(#(buttonDown mouseDown) includes: condition) ifTrue: [ actWhen := #mouseDown ].	(#(buttonUp mouseUp) includes: condition) ifTrue: [ actWhen := #mouseUp ].	(#(whilePressed mouseStillDown) includes: condition) ifTrue: [ actWhen := #mouseStillDown ].	self setEventHandlers: true.! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/8/2001 08:46'!actionSelector: aSymbolOrString	aSymbolOrString isEmptyOrNil ifTrue: [^actionSelector := nil].	aSymbolOrString = 'nil' ifTrue: [^actionSelector := nil].	actionSelector := aSymbolOrString asSymbol.! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/15/2001 09:35'!addTextToButton: aStringOrText	| tm existing |	existing := self currentTextMorphsInButton.	existing do: [ :x | x delete].	aStringOrText ifNil: [^self].	tm := TextMorph new contents: aStringOrText.	tm 		fullBounds;		lock;		align: tm center with: visibleMorph center;		setProperty: #textAddedByButtonProperties toValue: true;		setToAdhereToEdge: #center.	"maybe the user would like personal control here"	"visibleMorph extent: (tm extent * 1.5) rounded."	visibleMorph addMorphFront: tm.! !!ButtonProperties methodsFor: 'accessing'!arguments: aCollection	arguments := aCollection asArray copy.! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/15/2001 09:18'!currentLook	^currentLook ifNil: [currentLook := #normal]! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/14/2001 18:18'!currentTextInButton	| existing |	existing := self currentTextMorphsInButton.	existing isEmpty ifTrue: [^nil].	^existing first! !!ButtonProperties methodsFor: 'accessing' stamp: 'yo 11/30/2005 14:20'!establishEtoyLabelWording	"Set the label wording, unless it has already been manually edited"	| itsName |	self isTileScriptingElement ifFalse: [^self].	itsName := target externalName.	self addTextToButton: itsName, ' ', arguments first.	visibleMorph setBalloonText: 		('click to run the script "{1}" in player named "{2}"' translated format: {arguments first. itsName}).! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/8/2001 16:15'!mouseDownHaloColor: x	mouseDownHaloColor := x! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/8/2001 16:31'!mouseDownHaloWidth: x	mouseDownHaloWidth := x! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/8/2001 16:16'!mouseOverHaloColor: x	mouseOverHaloColor := x! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/8/2001 16:31'!mouseOverHaloWidth: x	mouseOverHaloWidth := x! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/14/2001 18:30'!stateCostumes	^stateCostumes ifNil: [stateCostumes := Dictionary new]! !!ButtonProperties methodsFor: 'accessing'!target: anObject	target := anObject! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/8/2001 15:43'!visibleMorph: x	visibleMorph ifNotNil: [self setEventHandlers: false].	visibleMorph := x.	visibleMorph ifNotNil: [self setEventHandlers: true].! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/10/2001 13:59'!wantsRolloverIndicator: aBoolean	wantsRolloverIndicator := aBoolean.	wantsRolloverIndicator ifTrue: [		self setEventHandlers: true.	].! !!ButtonProperties methodsFor: 'copying' stamp: 'jm 7/28/97 11:52'!updateReferencesUsing: aDictionary	"If the arguments array points at a morph we are copying, then point at the new copy.  And also copies the array, which is important!!"	super updateReferencesUsing: aDictionary.	arguments := arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !!ButtonProperties methodsFor: 'copying' stamp: 'tk 1/6/1999 17:55'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].arguments := arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!ButtonProperties methodsFor: 'copying' stamp: 'RAA 3/16/2001 08:21'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target := target.		Weakly copied""actionSelector := actionSelector.		a Symbol""arguments := arguments.		All weakly copied"actWhen := actWhen veryDeepCopyWith: deepCopier."oldColor := oldColor veryDeepCopyWith: deepCopier."visibleMorph := visibleMorph.	"I guess this will have been copied already if needed"delayBetweenFirings := delayBetweenFirings.mouseDownHaloColor := mouseDownHaloColor.stateCostumes := stateCostumes veryDeepCopyWith: deepCopier.currentLook := currentLook.! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/8/2001 09:55'!delayBetweenFirings: millisecondsOrNil	delayBetweenFirings := millisecondsOrNil! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/15/2001 09:21'!displayCostume: aSymbol	self currentLook == aSymbol ifTrue: [^true].	self stateCostumes at: aSymbol ifPresent: [ :aForm |		currentLook := aSymbol.		visibleMorph wearCostume: aForm.		^true	].	^false! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/9/2001 17:08'!doButtonAction: evt	| arity |	target ifNil: [^self].	actionSelector ifNil: [^self].	arguments ifNil: [arguments := #()].	Cursor normal showWhile: [		arity := actionSelector numArgs.		arity = arguments size ifTrue: [			target perform: actionSelector withArguments: arguments		].		arity = (arguments size + 1) ifTrue: [			target perform: actionSelector withArguments: {evt},arguments		].		arity = (arguments size + 2) ifTrue: [			target perform: actionSelector withArguments: {evt. visibleMorph},arguments		].	]! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/14/2001 19:01'!editButtonsScript: evt	"The user has touched my Scriptor halo-handle.  Bring up a Scriptor on the script of the button."	| cardsPasteUp cardsPlayer anEditor scriptSelector |	cardsPasteUp := self pasteUpMorph.	(cardsPlayer := cardsPasteUp assuredPlayer) assureUniClass.	scriptSelector := self figureOutScriptSelector.	scriptSelector ifNil: [		scriptSelector := cardsPasteUp scriptSelectorToTriggerFor: self.		anEditor := cardsPlayer newTextualScriptorFor: scriptSelector.		evt hand attachMorph: anEditor.		^self	].	(cardsPlayer class selectors includes: scriptSelector) ifTrue: [		anEditor := cardsPlayer scriptEditorFor: scriptSelector.		evt hand attachMorph: anEditor.		^self	].	"Method somehow got removed; I guess we start aftresh"	scriptSelector := nil.	^ self editButtonsScript! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/14/2001 18:40'!mouseDown: evt	self displayCostume: #mouseDown.	mouseDownTime := Time millisecondClockValue.	nextTimeToFire := nil.	delayBetweenFirings ifNotNil: [		nextTimeToFire := mouseDownTime + delayBetweenFirings.	].	self wantsRolloverIndicator ifTrue: [		visibleMorph 			addMouseActionIndicatorsWidth: mouseDownHaloWidth 			color: mouseDownHaloColor.	].	actWhen == #mouseDown ifFalse: [^self].	(visibleMorph containsPoint: evt cursorPoint) ifFalse: [^self].	self doButtonAction: evt."=====	aMorph .	now := Time millisecondClockValue.	oldColor := color. 	actWhen == #buttonDown		ifTrue: [self doButtonAction]		ifFalse: [	self updateVisualState: evt; refreshWorld].	dt := Time millisecondClockValue - now max: 0.	dt < 200 ifTrue: [(Delay forMilliseconds: 200-dt) wait].	self mouseStillDown: evt.====="! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/9/2001 08:57'!mouseStillDown: evt	(visibleMorph containsPoint: evt cursorPoint) ifFalse: [^self].	nextTimeToFire ifNil: [^self].	nextTimeToFire <= Time millisecondClockValue ifTrue: [		self doButtonAction: evt.		nextTimeToFire := Time millisecondClockValue + self delayBetweenFirings.		^self	].! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/9/2001 12:27'!replaceVisibleMorph: aNewMorph	| old oldOwner oldText |	old := visibleMorph.	oldText := self currentTextInButton.	self visibleMorph: nil.	old buttonProperties: nil.	aNewMorph buttonProperties: self.	self visibleMorph: aNewMorph.	self addTextToButton: oldText.	oldOwner := old owner ifNil: [^self].	oldOwner replaceSubmorph: old by: aNewMorph.! !!ButtonProperties methodsFor: 'initialization' stamp: 'ar 3/17/2001 20:12'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	target := target adaptedToWorld: aWorld.! !!ButtonProperties methodsFor: 'initialization' stamp: 'RAA 3/9/2001 09:47'!initialize	wantsRolloverIndicator := false.	delayBetweenFirings := nil.	mouseOverHaloWidth := 10.	mouseOverHaloColor := Color blue alpha: 0.3.	mouseDownHaloWidth := 15.	mouseDownHaloColor := Color blue alpha: 0.7.	arguments := #().! !!ButtonProperties methodsFor: 'menu' stamp: 'yo 3/16/2005 20:58'!setActWhen	| selections |	selections := #(mouseDown mouseUp mouseStillDown).	actWhen := (SelectionMenu labels: (selections collect: [:t | t translated]) selections: selections)		startUpWithCaption: 'Choose one of the following conditions' translated! !!ButtonProperties methodsFor: 'menu' stamp: 'yo 3/16/2005 20:53'!setActionSelector	| newSel |	newSel := FillInTheBlank		request:'Please type the selector to be sent tothe target when this button is pressed' translated		initialAnswer: actionSelector.	newSel isEmpty ifFalse: [self actionSelector: newSel].! !!ButtonProperties methodsFor: 'menu' stamp: 'yo 3/14/2005 13:07'!setArguments	| s newArgs newArgsArray |	s := WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs := FillInTheBlank		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods' translated		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray := Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!ButtonProperties methodsFor: 'menu'!setLabel	| newLabel |	newLabel := FillInTheBlank		request:'Please a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel].! !!ButtonProperties class methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 17:29'!ellipticalButtonWithText: aStringOrText	| m prop |	m := EllipseMorph new.	prop := m ensuredButtonProperties.	prop		target: #(1 2 3);		actionSelector: #inspect;		actWhen: #mouseUp;		addTextToButton: aStringOrText;		wantsRolloverIndicator: true.	^m! !!ButtonProperties class methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 08:31'!test1	| m prop |	m := EllipseMorph new.	prop := m ensuredButtonProperties.	prop		target: #(1 2 3);		actionSelector: #inspect;		actWhen: #mouseUp.	m openInWorld.! !!ButtonProperties class methodsFor: 'as yet unclassified' stamp: 'nb 6/17/2003 12:25'!test3	| m |	(m := self ellipticalButtonWithText: 'Hello world') openInWorld.	m ensuredButtonProperties		target: Beeper;		actionSelector: #beep;		delayBetweenFirings: 1000.! !!ByteArray methodsFor: 'platform independent access' stamp: 'jmb 12/3/2004 14:54'!doubleAt: index bigEndian: bool 	"Return a 64 bit float starting from the given byte index"	| w1 w2 dbl |	w1 := self unsignedLongAt: index bigEndian: bool.	w2 := self unsignedLongAt: index + 4 bigEndian: bool.	dbl := Float new: 2. 	bool		ifTrue: [dbl basicAt: 1 put: w1.			dbl basicAt: 2 put: w2]		ifFalse: [dbl basicAt: 1 put: w2.			dbl basicAt: 2 put: w1].	^ dbl! !!ByteArray methodsFor: 'platform independent access' stamp: 'jmb 12/3/2004 14:54'!doubleAt: index put: value bigEndian: bool 	"Store a 64 bit float starting from the given byte index"	| w1 w2 |	bool		ifTrue: [w1 := value basicAt: 1.			w2 := value basicAt: 2]		ifFalse: [w1 := value basicAt: 2.			w2 := value basicAt: 1]. 	self unsignedLongAt: index put: w1 bigEndian: bool.	self unsignedLongAt: index + 4 put: w2 bigEndian: bool.	^ value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:44'!longAt: index bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 w h |	aBool ifTrue:[		b0 := self at: index.		b1 := self at: index+1.		b2 := self at: index+2.		w := self at: index+3.	] ifFalse:[		w := self at: index.		b2 := self at: index+1.		b1 := self at: index+2.		b0 := self at: index+3.	].	"Minimize LargeInteger arithmetic"	h := ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.	b2 = 0 ifFalse:[w := (b2 bitShift: 8) + w].	h = 0 ifFalse:[w := (h bitShift: 16) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 8/2/2003 19:29'!longAt: index put: value bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 := value bitShift: -24.	b0 := (b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80).	b0 < 0 ifTrue:[b0 := 256 + b0].	b1 := (value bitShift: -16) bitAnd: 255.	b2 := (value bitShift: -8) bitAnd: 255.	b3 := value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:57'!shortAt: index bigEndian: aBool	"Return a 16 bit integer quantity starting from the given byte index"	| uShort |	uShort := self unsignedShortAt: index bigEndian: aBool.	^(uShort bitAnd: 16r7FFF) - (uShort bitAnd: 16r8000)! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index bigEndian: aBool	"Return a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 w |	aBool ifTrue:[		b0 := self at: index.		b1 := self at: index+1.		b2 := self at: index+2.		w := self at: index+3.	] ifFalse:[		w := self at: index.		b2 := self at: index+1.		b1 := self at: index+2.		b0 := self at: index+3.	].	"Minimize LargeInteger arithmetic"	b2 = 0 ifFalse:[w := (b2 bitShift: 8) + w].	b1 = 0 ifFalse:[w := (b1 bitShift: 16) + w].	b0 = 0 ifFalse:[w := (b0 bitShift: 24) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index put: value bigEndian: aBool	"Store a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 := value bitShift: -24.	b1 := (value bitShift: -16) bitAnd: 255.	b2 := (value bitShift: -8) bitAnd: 255.	b3 := value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'zip archive' stamp: 'nk 8/21/2004 15:23'!lastIndexOfPKSignature: aSignature	"Answer the last index in me where aSignature (4 bytes long) occurs, or 0 if not found"	| a b c d |	a := aSignature first.	b := aSignature second.	c := aSignature third.	d := aSignature fourth.	(self size - 3) to: 1 by: -1 do: [ :i |		(((self at: i) = a)			and: [ ((self at: i + 1) = b)				and: [ ((self at: i + 2) = c)					and: [ ((self at: i + 3) = d) ]]])						ifTrue: [ ^i ]	].	^0! !!ByteArray class methodsFor: 'byte based hash' stamp: 'SqR 8/21/2002 16:21'!hashBytes: aByteArray startingWith: speciesHash	"Answer the hash of a byte-indexed collection,	using speciesHash as the initial value.	See SmallInteger>>hashMultiply.	The primitive should be renamed at a	suitable point in the future"	| byteArraySize hash low |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	self var: #aHash declareC: 'int speciesHash'.	self var: #aByteArray declareC: 'unsigned char *aByteArray'.	byteArraySize := aByteArray size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: byteArraySize do: [:pos |		hash := hash + (aByteArray basicAt: pos).		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash! !!ByteString methodsFor: 'comparing' stamp: 'bf 8/31/2004 13:50'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	self var: #key declareC: 'unsigned char *key'.	self var: #body declareC: 'unsigned char *body'.	self var: #matchTable declareC: 'unsigned char *matchTable'.	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index := 1.			[(matchTable at: (body at: startIndex+index-1) asciiValue + 1)				= (matchTable at: (key at: index) asciiValue + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!ByteString methodsFor: 'converting' stamp: 'yo 11/11/2002 12:20'!convertFromCompoundText	| readStream writeStream converter |	readStream := self readStream.	writeStream := String new writeStream.	converter := CompoundTextConverter new.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		writeStream nextPut: (converter nextFromStream: readStream)].	^ writeStream contents! !!ByteString methodsFor: 'converting' stamp: 'mir 7/20/2004 15:50'!convertFromSystemString	| readStream writeStream converter |	readStream := self readStream.	writeStream := String new writeStream.	converter := LanguageEnvironment defaultSystemConverter.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		writeStream nextPut: (converter nextFromStream: readStream)].	^ writeStream contents! !!ByteString methodsFor: 'converting' stamp: 'ar 7/21/2007 21:51'!substrings	"Answer an array of the substrings that compose the receiver."	| result end beginning |	result := WriteStream on: (Array new: 10).	end := 0.	"find one substring each time through this loop"	[ "find the beginning of the next substring"	beginning := self indexOfAnyOf: CSNonSeparators 							startingAt: end+1 ifAbsent: [ nil ].	beginning ~~ nil ] whileTrue: [		"find the end"		end := self indexOfAnyOf: CSSeparators 					startingAt: beginning ifAbsent: [ self size + 1 ].		end := end - 1.		result nextPut: (self copyFrom: beginning to: end).	].	^result contents! !!ByteString class methodsFor: 'primitives' stamp: 'yo 12/15/2005 13:44'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>	self var: #string1 declareC: 'unsigned char *string1'.	self var: #string2 declareC: 'unsigned char *string2'.	self var: #order declareC: 'unsigned char *order'.	len1 := string1 size.	len2 := string2 size.	1 to: (len1 min: len2) do:		[:i |		c1 := order at: (string1 basicAt: i) + 1.		c2 := order at: (string2 basicAt: i) + 1.		c1 = c2 ifFalse: 			[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!ByteString class methodsFor: 'primitives' stamp: 'ar 2/3/2001 16:12'!findFirstInString: aString  inSet: inclusionMap  startingAt: start	| i stringSize |	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>	self var: #aString declareC: 'unsigned char *aString'.	self var: #inclusionMap  declareC: 'char *inclusionMap'.	inclusionMap size ~= 256 ifTrue: [ ^0 ].	i := start.	stringSize := aString size.	[ i <= stringSize and: [ (inclusionMap at: (aString at: i) asciiValue+1) = 0 ] ] whileTrue: [ 		i := i + 1 ].	i > stringSize ifTrue: [ ^0 ].	^i! !!ByteString class methodsFor: 'primitives' stamp: 'ar 2/3/2001 16:13'!indexOfAscii: anInteger inString: aString startingAt: start	| stringSize |	<primitive: 'primitiveIndexOfAsciiInString' module: 'MiscPrimitivePlugin'>	self var: #aCharacter declareC: 'int anInteger'.	self var: #aString declareC: 'unsigned char *aString'.	stringSize := aString size.	start to: stringSize do: [:pos |		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].	^ 0! !!ByteString class methodsFor: 'primitives' stamp: 'ar 9/28/2001 04:35'!stringHash: aString initialHash: speciesHash	| stringSize hash low |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	self var: #aHash declareC: 'int speciesHash'.	self var: #aString declareC: 'unsigned char *aString'.	stringSize := aString size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: stringSize do: [:pos |		hash := hash + (aString at: pos) asciiValue.		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash! !!CardPlayer methodsFor: 'as template' stamp: 'tk 5/29/2001 22:44'!matchIndex	| tms |	"Index of one we are looking at, in the cards that matched the last search with this template."	tms := self class classPool at: #TemplateMatches ifAbsent: [^ 0].	^ (tms at: self ifAbsent: [#(0 0)]) second.! !!CardPlayer methodsFor: 'as template' stamp: 'tk 5/29/2001 22:47'!matchIndex: newPlace	| tms pair |	"One we are looking at, in cards that matched the last template search."	tms := self class classPool at: #TemplateMatches ifAbsent: [		self class addClassVarName: 'TemplateMatches'.		self class classPool at: #TemplateMatches put: IdentityDictionary new].	pair := tms at: self ifAbsent: [tms at: self put: (Array new: 2)].	pair at: 2 put: newPlace.	newPlace = 0 ifTrue: [^ self].	pair first ifNil: [^ self].	(costume valueOfProperty: #myStack ifAbsent: [^ self]) goToCard: 		((pair first "list") at: newPlace).	self changed: #matchIndex.	"update my selection"! !!CardPlayer methodsFor: 'as template' stamp: 'tk 5/31/2001 16:46'!matchNames	| list str ll tms stk crds |	"List of names of cards that matched the last template search."	tms := self class classPool at: #TemplateMatches ifAbsent: [^ #()].	list := (tms at: self ifAbsent: [#(#() 0)]) first.	stk := costume valueOfProperty: #myStack ifAbsent: [nil].	crds := stk ifNil: [#()] ifNotNil: [stk cards].	^ list collect: [:cd | 		str := ''.		(ll := cd allStringsAfter: nil) ifNotNil: [			str := ll inject: '' into: [:strr :this | strr, this]]. 		(str copyFrom: 1 to: (30 min: str size)), '...  (' , (crds indexOf: cd) printString, ')'].		"Maybe include a card title?"! !!CardPlayer methodsFor: 'card data' stamp: 'tk 5/25/2001 17:42'!asKeys	| keys kk vd gotData |	"Take my fields, tokenize the text, and return as an array in the same order as variableDocks.  Simple background fields on the top level.  If no data, return nil."	keys := self class variableDocks copy.	gotData := false.	1 to: keys size do: [:ind |		kk := nil.		vd := self class variableDocks at: ind.		vd type == #text ifTrue: [			kk := (self perform: vd playerGetSelector) string					findTokens: Character separators.			kk isEmpty ifTrue: [kk := nil] ifFalse: [gotData := true]].		keys at: ind put: kk].	^ gotData ifTrue: [keys] ifFalse: [nil]! !!CardPlayer methodsFor: 'card data' stamp: 'sw 10/13/2000 16:46'!commitCardPlayerData	"Transport data back from the morphs that may be holding it into the instance variables that must hold it when the receiver is not being viewed"	| prior |	self class variableDocks do:		[:aDock | aDock storeMorphDataInInstance: self].	prior := nil.	privateMorphs := OrderedCollection new.	self costume ifNotNil:		[self costume submorphs do:			[:aMorph | aMorph renderedMorph isShared				ifFalse:					[aMorph setProperty: #priorMorph toValue: prior.					privateMorphs add: aMorph.					aMorph delete].			prior := aMorph]]! !!CardPlayer methodsFor: 'card data' stamp: 'sw 11/14/2000 11:21'!commitCardPlayerDataFrom: aPlayfield	"Transport data back from the morphs that may be holding it into the instance variables that must hold it when the receiver is not being viewed"	| prior itsOrigin |	itsOrigin := aPlayfield topLeft.	self class variableDocks do:		[:aDock | aDock storeMorphDataInInstance: self].	prior := nil.	privateMorphs := OrderedCollection new.	self costume ifNotNil:		[self costume submorphs do:			[:aMorph | aMorph renderedMorph isShared				ifFalse:					[aMorph setProperty: #priorMorph toValue: prior.					privateMorphs add: aMorph.					aMorph delete.					aMorph position: (aMorph position - itsOrigin)].			prior := aMorph]]! !!CardPlayer methodsFor: 'card data' stamp: 'tk 1/16/2001 16:12'!installPrivateMorphsInto: aBackground	"The receiver is being installed as the current card in a given pasteup morph being used as a background.  Install the receiver's private morphs into that playfield"	| prior originToUse |	self flag: #deferred.  "not robust if the background is showing a list view"	privateMorphs ifNotNil: [privateMorphs do:		[:aMorph |			originToUse := aBackground topLeft.			prior := aMorph valueOfProperty: #priorMorph ifAbsent: [nil].			aMorph position: (aMorph position + originToUse).			(prior notNil and: [aBackground submorphs includes: prior])				ifTrue:					[aBackground addMorph: aMorph after: prior]				ifFalse:					[aBackground addMorphFront: aMorph].		aMorph removeProperty: #priorMorph]]! !!CardPlayer methodsFor: 'card data' stamp: 'tk 5/25/2001 17:02'!match: keys fields: docks	| longString |	"see if each key occurs in my corresponding text instance."	keys withIndexDo: [:kk :ind |		kk ifNotNil: [			longString := (self perform: (docks at: ind) playerGetSelector) string.			kk do: [:aKey |				((longString findString: aKey startingAt: 1 caseSensitive: false) > 0)					ifFalse: [^ false]]]]. 	"all keys must match"	^ true! !!CardPlayer methodsFor: 'scripts-kernel' stamp: 'svp 10/15/2001 14:44'!renameScript: oldSelector newSelector: newSelector	"Find all buttons that fire this script and tell them the new name"	| stack |	super renameScript: oldSelector newSelector: newSelector.	costume allMorphsDo: [:mm |		self retargetButton: mm oldSelector: oldSelector newSelector: newSelector].	stack := costume valueOfProperty: #myStack.	stack ifNotNil:		[stack cards do: [:cc |			cc privateMorphs do: [:pp | 				pp allMorphsDo: [:mm |					self retargetButton: mm oldSelector: oldSelector newSelector: newSelector]]]]! !!CardPlayer class methodsFor: 'slots' stamp: 'md 7/23/2006 15:13'!compileAccessorsFor: varName	"Compile instance-variable accessor methods for the given variable name"	| nameString |	nameString := varName asString capitalized.	self compileSilently: ('get', nameString, '	^ ', varName)		classified: 'access'.	self compileSilently: ('set', nameString, ': val	', varName, ' := val')		classified: 'access'! !!CardPlayer class methodsFor: 'slots' stamp: 'NS 1/30/2004 13:11'!removeAccessorsFor: varName	"Remove the instance-variable accessor methods associated with varName"	| nameString |	nameString := varName asString capitalized.	self removeSelectorSilently: ('get', nameString) asSymbol.	self removeSelectorSilently: ('set', nameString, ':') asSymbol! !!CardPlayer class methodsFor: 'user-defined inst vars' stamp: 'sw 12/6/2001 20:36'!resortInstanceVariables: newList	"Accept a new ordering for instance variables"	variableDocks := newList collect: [:aName | variableDocks detect: [:d | d variableName = aName]].	self setNewInstVarNames: newList asOrderedCollection.	self newVariableDocks: variableDocks.! !!CardPlayer class methodsFor: 'user-defined inst vars' stamp: 'tk 8/26/2001 16:58'!setNewInstVarNames: listOfStrings	"Make listOfStrings be the new list of instance variable names for the receiver"	| disappearing firstAppearing instVarString instVarList |	instVarList := self instVarNames asOrderedCollection.	disappearing := instVarList copy.	disappearing removeAllFoundIn: listOfStrings.	disappearing do:		[:oldName | 	self removeAccessorsFor: oldName].	firstAppearing := listOfStrings copy.	firstAppearing removeAllFoundIn: instVarList.	instVarString := String streamContents:		[:aStream | listOfStrings do: [:aString | aStream nextPutAll: aString; nextPut: $ ]].	superclass subclass: self name instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	firstAppearing do:		[:newName | self compileAccessorsFor: newName].! !!CardPlayer class methodsFor: 'variable docks' stamp: 'md 3/1/2006 09:17'!setSlotInfoFromVariableDocks	"Get the slotInfo fixed up after a change in background shape.  Those instance variables that are proactively added by the user will persist, whereas those that are automatically generated will be updated"	| aDock newInfo |		self slotInfo copy do:  "Remove old automatically-created slots"		[:aSlotInfo | (aDock := aSlotInfo variableDock) ifNotNil:			[slotInfo removeKey: aDock variableName]].	self variableDocks do:  [:dock | "Generate fresh slots from variable docks"			newInfo := SlotInformation new type: dock variableType.			newInfo variableDock: dock.			slotInfo at: dock variableName asSymbol put: newInfo]! !!CardPlayer class methodsFor: 'variable docks' stamp: 'sw 10/13/2000 16:39'!variableDocks	"Answer the list of variable docks in the receiver.  Initialize the variable-dock list if not already done."	variableDocks ifNil: [variableDocks := OrderedCollection new].	^ variableDocks! !!CardPlayer class methodsFor: 'variable docks' stamp: 'sw 10/13/2000 16:39'!variableDocks: dockList	"Set the variable-dock list as indicated"	variableDocks := dockList! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:10'!setUp	categorizer := Categorizer defaultList: #(a b c d e).	categorizer classifyAll: #(a b c) under: 'abc'.	categorizer addCategory: 'unreal'.! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:17'!testClassifyNewElementNewCategory	categorizer classify: #f under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')(''nice'' f)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:18'!testClassifyNewElementOldCategory	categorizer classify: #f under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'' f)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:17'!testClassifyOldElementNewCategory	categorizer classify: #e under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'')(''nice'' e)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:54'!testClassifyOldElementOldCategory	categorizer classify: #e under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'' e)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:22'!testDefaultCategoryIsTransient	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	categorizer classifyAll: #(d e) under: #abc.	self assert: categorizer printString ='(''abc'' a b c d e)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/11/2007 15:15'!testNullCategory	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	| aCategorizer |	aCategorizer := Categorizer defaultList: #().	self assert: aCategorizer printString ='(''as yet unclassified'')'.	self assert: aCategorizer categories = #('no messages').	aCategorizer classify: #a under: #b.	self assert: aCategorizer printString ='(''b'' a)'.	self assert: aCategorizer categories = #(b).! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:57'!testRemoveEmptyCategory	categorizer removeCategory: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:55'!testRemoveExistingElement	categorizer removeElement: #a.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' b c)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:59'!testRemoveNonEmptyCategory	self should: [categorizer removeCategory: #abc] raise: Error.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:59'!testRemoveNonExistingCategory	categorizer removeCategory: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:57'!testRemoveNonExistingElement	categorizer removeElement: #f.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/11/2007 14:49'!testRemoveThenRename	categorizer removeCategory: #unreal.	categorizer renameCategory: #abc toBe: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''unreal'' a b c)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:14'!testUnchanged	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 9/13/2001 19:55'!categoryNameWhoseTranslatedWordingIs: aWording	"Answer the category name with the given wording"	| result |	result := self currentVocabulary categoryWhoseTranslatedWordingIs: aWording.	^ result		ifNotNil:			[result categoryName]		ifNil:			[aWording]! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/30/2001 13:45'!categoryWording: aCategoryWording	"Make the category with the given wording be my current one."	| actualPane |	(actualPane := namePane renderedMorph) firstSubmorph contents: aCategoryWording; color: Color black.	actualPane extent: actualPane firstSubmorph extent.	self removeAllButFirstSubmorph. "that being the header"	self addAllMorphs:		((scriptedPlayer tilePhrasesForCategory: chosenCategorySymbol inViewer: self)).	self enforceTileColorPolicy.	self secreteCategorySymbol.	self world ifNotNil: [self world startSteppingSubmorphsOf: self].	self adjustColorsAndBordersWithin.	owner ifNotNil: [owner isStandardViewer ifTrue: [owner fitFlap]]! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 3/2/2004 23:53'!chooseCategory	"The mouse went down on my category-list control; pop up a list of category choices"	| aList aMenu reply aLinePosition lineList |	aList := scriptedPlayer categoriesForViewer: self.	aLinePosition := aList indexOf: #miscellaneous ifAbsent: [nil].	aList := aList collect:			[:aCatSymbol | self currentVocabulary categoryWordingAt: aCatSymbol].	lineList := aLinePosition ifNil: [#()] ifNotNil: [Array with: aLinePosition].	aList size == 0 ifTrue: [aList add: ScriptingSystem nameForInstanceVariablesCategory translated].	aMenu := CustomMenu labels: aList lines: lineList selections: aList.	reply := aMenu startUpWithCaption: 'category' translated.	reply ifNil: [^ self].	self chooseCategoryWhoseTranslatedWordingIs: reply asSymbol! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 9/13/2001 19:49'!chosenCategorySymbol: aCategorySymbol	"Make the given category be my current one."	| aCategory wording |	chosenCategorySymbol := aCategorySymbol.	aCategory := self currentVocabulary categoryAt: chosenCategorySymbol.	wording := aCategory ifNil: [aCategorySymbol] ifNotNil: [aCategory wording].	self categoryWording: wording! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 2/23/2001 22:29'!currentCategory	"Answer the symbol representing the receiver's currently-selected category"	| current |	current := namePane renderedMorph firstSubmorph contents.	^ current ifNotNil: [current asSymbol] ifNil: [#basic]! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 9/13/2001 19:57'!nextCategory	"Change the receiver to point at the category following the one currently seen"	| aList anIndex newIndex already aChoice |	aList := (scriptedPlayer categoriesForViewer: self) collect:		[:aCatSymbol | self currentVocabulary categoryWordingAt: aCatSymbol].	already := self outerViewer ifNil: [#()] ifNotNil: [self outerViewer categoriesCurrentlyShowing].	anIndex := aList indexOf: self currentCategory ifAbsent: [0].	newIndex := anIndex = aList size		ifTrue:		[1]		ifFalse:		[anIndex + 1].	[already includes: (aChoice := aList at: newIndex)] whileTrue:		[newIndex := (newIndex \\ aList size) + 1].	self chooseCategoryWhoseTranslatedWordingIs: aChoice! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 9/13/2001 19:53'!previousCategory	"Change the receiver to point at the category preceding the one currently seen"	| aList anIndex newIndex already aChoice |	aList := (scriptedPlayer categoriesForViewer: self) collect:		[:aCatSymbol | self currentVocabulary categoryWordingAt: aCatSymbol].	already := self outerViewer ifNil: [#()] ifNotNil: [self outerViewer categoriesCurrentlyShowing].	anIndex := aList indexOf: self currentCategory ifAbsent: [aList size + 1].	newIndex := anIndex = 1		ifTrue:		[aList size]		ifFalse:		[anIndex - 1].	[already includes: (aChoice := aList at: newIndex)] whileTrue:		[newIndex := newIndex = 1 ifTrue: [aList size] ifFalse: [newIndex - 1]].	self chooseCategoryWhoseTranslatedWordingIs: aChoice! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 9/13/2001 19:50'!secreteCategorySymbol	"Set my chosenCategorySymbol by translating back from its representation in the namePane.  Answer the chosenCategorySymbol"	| aCategory |	aCategory := self currentVocabulary categoryWhoseTranslatedWordingIs: self currentCategory.	^ chosenCategorySymbol := aCategory		ifNotNil:			[aCategory categoryName]		ifNil:			[self currentCategory]! !!CategoryViewer methodsFor: 'categories' stamp: 'nk 9/2/2004 19:37'!showCategoriesFor: aSymbol	"Put up a pop-up list of categories in which aSymbol is filed; replace the receiver with a CategoryViewer for the one the user selects, if any"	| allCategories aVocabulary hits meths chosen |	aVocabulary := self currentVocabulary.	allCategories := scriptedPlayer categoriesForVocabulary: aVocabulary limitClass: ProtoObject.	hits := allCategories select:		[:aCategory | 			meths := aVocabulary allMethodsInCategory: aCategory forInstance: scriptedPlayer ofClass: scriptedPlayer class.			meths includes: aSymbol].	hits isEmpty ifTrue: [ ^self ].	chosen := (SelectionMenu selections: hits) startUp.	chosen isEmptyOrNil ifFalse:		[self outerViewer addCategoryViewerFor: chosen atEnd: true]	! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 5/29/2001 11:41'!updateCategoryNameTo: aName	"Update the category name, because of a language change."	| actualPane |	(actualPane := namePane firstSubmorph) contents: aName; color: Color black.	namePane extent: actualPane extent.	self world ifNotNil: [self world startSteppingSubmorphsOf: self]! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 7/25/2004 15:37'!addIsOverColorDetailTo: aRow	"Special-casee code for the boolean-valued phrase variously known as is-over-color or sees-color."	| clrTile |	aRow addMorphBack: (Morph new color: self color; extent: 2@10).  "spacer"	aRow addMorphBack: (clrTile := Color blue newTileMorphRepresentative)."The following commented-out code put a readout up; the readout was very nice, but was very consumptive of cpu time, which is why the is-over-color tile got removed from the viewer long ago.  Now is-over-color is reinstated to the viewer, minus the expensive readout...""	aRow addMorphBack: (AlignmentMorph new beTransparent).	readout := UpdatingStringMorphWithArgument new			target: scriptedPlayer; getSelector: #seesColor:; growable: false; putSelector: nil;			argumentTarget: clrTile colorSwatch argumentGetSelector: #color.	readout useDefaultFormat.	aTile := StringReadoutTile new typeColor: Color lightGray lighter.	aTile addMorphBack: readout.	aRow addMorphBack: aTile.	aTile setLiteralTo: (scriptedPlayer seesColor: clrTile colorSwatch color) printString width: 30"! !!CategoryViewer methodsFor: 'entries' stamp: 'md 11/14/2003 16:21'!addTouchesADetailTo: aRow	| clrTile |	aRow addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	aRow addMorphBack: (clrTile := self tileForSelf).	aRow addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"	"readout := UpdatingStringMorphWithArgument new			target: scriptedPlayer; getSelector: #seesColor:; growable: false; putSelector: nil;			argumentTarget: clrTile colorSwatch argumentGetSelector: #color.	readout useDefaultFormat.	aTile := StringReadoutTile new typeColor: Color lightGray lighter.	aTile addMorphBack: readout.	aRow addMorphBack: aTile.	aTile setLiteralTo: (scriptedPlayer seesColor: clrTile colorSwatch color) printString width: 30"! !!CategoryViewer methodsFor: 'entries' stamp: 'md 11/14/2003 16:20'!infoButtonFor: aScriptOrSlotSymbol	"Answer a fully-formed morph that will serve as the 'info button' alongside an entry corresponding to the given slot or script symbol.  If no such button is appropriate, answer a transparent graphic that fills the same space."	| aButton |	(self wantsRowMenuFor: aScriptOrSlotSymbol) ifFalse:		["Fill the space with sweet nothing, since there is no meaningful menu to offer"		aButton := RectangleMorph new beTransparent extent: (17@20).		aButton borderWidth: 0.		^ aButton].	aButton := IconicButton new labelGraphic: Cursor menu.	aButton target: scriptedPlayer;		actionSelector: #infoFor:inViewer:;		arguments: (Array with:aScriptOrSlotSymbol with: self);		color: Color transparent;		borderWidth: 0;		shedSelvedge;		actWhen: #buttonDown.	aButton setBalloonText: 'Press here to get a menu' translated.	^ aButton! !!CategoryViewer methodsFor: 'entries' stamp: 'yo 8/18/2005 10:37'!phraseForCommandFrom: aMethodInterface	"Answer a phrase for the non-slot-like command represented by aMethodInterface - classic tiles"	| aRow resultType cmd names argType argTile selfTile aPhrase balloonTextSelector stat inst aDocString universal tileBearingHelp |	aDocString := aMethodInterface documentation.	aDocString = 'no help available' ifTrue: [aDocString := nil].	names := scriptedPlayer class namedTileScriptSelectors.	resultType := aMethodInterface resultType.	cmd := aMethodInterface selector.	(universal := scriptedPlayer isUniversalTiles)		ifTrue:			[aPhrase := scriptedPlayer universalTilesForInterface: aMethodInterface]		ifFalse: [cmd numArgs == 0			ifTrue:				[aPhrase := PhraseTileMorph new vocabulary: self currentVocabulary.				aPhrase setOperator: cmd					type: resultType					rcvrType: #Player]			ifFalse:				["only one arg supported in classic tiles, so if this is fed				with a selector with > 1 arg, results will be very strange"				argType := aMethodInterface typeForArgumentNumber: 1.				aPhrase := PhraseTileMorph new vocabulary: self currentVocabulary.				(self isSpecialPatchReceiver: scriptedPlayer and: cmd) ifTrue: [					aPhrase setOperator: cmd						type: resultType						rcvrType: #Patch						argType: argType.				] ifFalse: [					aPhrase setOperator: cmd						type: resultType						rcvrType: #Player						argType: argType.				].				(self isSpecialPatchCase: scriptedPlayer and: cmd) ifTrue: [					argTile := (Vocabulary vocabularyForType: argType) defaultArgumentTileFor: scriptedPlayer.				] ifFalse: [					argTile := ScriptingSystem tileForArgType: argType.				].				(#(bounce: wrap:) includes: cmd) ifTrue:					["help for the embattled bj"					argTile setLiteral: 'silence'; updateLiteralLabel].				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(scriptedPlayer slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector := #userSlot].	(scriptedPlayer belongsToUniClass and: [scriptedPlayer class includesSelector: cmd])		ifTrue:			[aDocString ifNil:				[aDocString := (scriptedPlayer class userScriptForPlayer: scriptedPlayer selector: cmd) documentation].			aDocString ifNil:				[balloonTextSelector := #userScript]].	tileBearingHelp := universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]. 	aDocString		ifNotNil:			[tileBearingHelp setBalloonText: aDocString]		ifNil:			[balloonTextSelector ifNil:				[tileBearingHelp setProperty: #inherentSelector toValue: cmd.				balloonTextSelector := #methodComment].			tileBearingHelp balloonTextSelector: balloonTextSelector].	aPhrase markAsPartsDonor.	cmd == #emptyScript ifTrue:		[aPhrase setProperty: #newPermanentScript toValue: true.		aPhrase setProperty: #newPermanentPlayer toValue: scriptedPlayer.		aPhrase submorphs second setBalloonText: 'drag and drop to add a new script' translated].	universal ifFalse:		[selfTile := self tileForSelf.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile].	aRow := ViewerLine newRow borderWidth: 0; color: self color.	aRow elementSymbol: cmd asSymbol.	aRow addMorphBack: (ScriptingSystem tryButtonFor: aPhrase).	aRow addMorphBack: (Morph new extent: 2@2; beTransparent).	aRow addMorphBack: (self infoButtonFor: cmd).	aRow addMorphBack: aPhrase.	aPhrase on: #mouseEnter send: #addCommandFeedback to: aRow.	aPhrase on: #mouseLeave send: #removeHighlightFeedback to: aRow.	aPhrase on: #mouseLeaveDragging send: #removeHighlightFeedback to: aRow.	(names includes: cmd) ifTrue:		[aPhrase userScriptSelector: cmd.		cmd numArgs == 0 ifTrue:			[aPhrase beTransparent.			aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.			aRow addMorphBack: (stat := (inst := scriptedPlayer scriptInstantiationForSelector: cmd) statusControlMorph).			inst updateStatusMorph: stat]].	aRow beSticky; disableDragNDrop.	^ aRow! !!CategoryViewer methodsFor: 'entries' stamp: 'yo 3/7/2005 08:45'!phraseForVariableFrom: aMethodInterface	"Return a structure consisting of tiles and controls and a readout representing a 'variable' belonging to the player, complete with an appropriate readout when indicated.  Functions in both universalTiles mode and classic mode.  Slightly misnamed in that this path is used for any methodInterface that indicates an interesting resultType."	| anArrow slotName getterButton cover inner aRow doc setter tryer universal hotTileForSelf spacer buttonFont varName |	aRow := ViewerLine newRow		color: self color;		beSticky;		elementSymbol: (slotName := aMethodInterface selector);		wrapCentering: #center;		cellPositioning: #leftCenter.	(universal := scriptedPlayer isUniversalTiles) ifFalse:		[buttonFont := Preferences standardEToysFont.			aRow addMorphBack: (Morph new color: self color;					 extent: (((buttonFont widthOfString: '!!') + 8) @ (buttonFont height + 6));					 yourself)].  "spacer"	aRow addMorphBack: (self infoButtonFor: slotName).	aRow addMorphBack: (Morph new color: self color; extent: 0@10).  " vertical spacer"	universal		ifTrue:			[inner := scriptedPlayer universalTilesForGetterOf: aMethodInterface.			cover := Morph new color: Color transparent.			cover extent: inner fullBounds extent.			(getterButton := cover copy) addMorph: cover; addMorphBack: inner.			cover on: #mouseDown send: #makeUniversalTilesGetter:event:from: 					to: self withValue: aMethodInterface.			aRow addMorphFront:  (tryer := ScriptingSystem tryButtonFor: inner).			tryer color: tryer color lighter lighter]		ifFalse:			[hotTileForSelf := self tileForSelf bePossessive.			hotTileForSelf  on: #mouseDown send: #makeGetter:event:from:				to: self				withValue: (Array with: aMethodInterface selector with: aMethodInterface resultType).			aRow addMorphBack: hotTileForSelf.			aRow addMorphBack: (spacer := Morph new color: self color; extent: 2@10).			spacer on: #mouseEnter send: #addGetterFeedback to: aRow.			spacer on: #mouseLeave send: #removeHighlightFeedback to: aRow.			spacer on: #mouseLeaveDragging send: #removeHighlightFeedback to: aRow.			spacer  on: #mouseDown send: #makeGetter:event:from:				to: self				withValue: (Array with: aMethodInterface selector with: aMethodInterface resultType).			hotTileForSelf on: #mouseEnter send: #addGetterFeedback to: aRow.			hotTileForSelf on: #mouseLeave send: #removeHighlightFeedback to: aRow.			hotTileForSelf on: #mouseLeaveDragging send: #removeHighlightFeedback to: aRow.			getterButton := self getterButtonFor: aMethodInterface selector type: aMethodInterface resultType].	aRow addMorphBack: getterButton.	getterButton on: #mouseEnter send: #addGetterFeedback to: aRow.	getterButton on: #mouseLeave send: #removeHighlightFeedback to: aRow.	getterButton on: #mouseLeaveDragging send: #removeHighlightFeedback to: aRow.	(doc := aMethodInterface documentation) ifNotNil:		[getterButton setBalloonText: doc].	(scriptedPlayer slotInfo includesKey: (varName := Utilities inherentSelectorForGetter: slotName)) "user slot"		ifTrue:			["aRow addTransparentSpacerOfSize: 3@0.			aRow addMorphBack: (self slotTypeMenuButtonFor: varName)"].	universal ifFalse:		[(slotName == #seesColor:) ifTrue:			[self addIsOverColorDetailTo: aRow.			^ aRow].		(slotName == #touchesA:) ifTrue:			[self addTouchesADetailTo: aRow.			^ aRow].		(slotName == #overlaps: or: [ slotName == #overlapsAny:]) ifTrue:			[self addOverlapsDetailTo: aRow.			^ aRow]].	aRow addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"	(setter := aMethodInterface companionSetterSelector) ifNotNil:		[aRow addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"		anArrow := universal 			ifTrue: [self arrowSetterButton: #newMakeSetterFromInterface:evt:from:  						args: aMethodInterface]			ifFalse: [self arrowSetterButton: #makeSetter:from:forPart:						args: (Array with: slotName with: aMethodInterface resultType)].		anArrow beTransparent.		universal ifFalse:			[anArrow on: #mouseEnter send: #addSetterFeedback to: aRow.			anArrow on: #mouseLeave send: #removeHighlightFeedback to: aRow.			anArrow on: #mouseLeaveDragging send: #removeHighlightFeedback to: aRow].		aRow addMorphBack: anArrow].	(#(color:sees: playerSeeingColor copy touchesA: overlaps: getTurtleAt: getTurtleOf:) includes: slotName) ifFalse: 		[(universal and: [slotName == #seesColor:]) ifFalse:			[aMethodInterface wantsReadoutInViewer ifTrue: 				[aRow addMorphBack: (self readoutFor: slotName type: aMethodInterface resultType readOnly: setter isNil getSelector: aMethodInterface selector putSelector: setter)]]].	anArrow ifNotNil: [anArrow step].	^ aRow! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 7/4/2004 01:09'!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Answer a readout morph for the given part"	| readout delta |	readout := (Vocabulary vocabularyForType: partType) updatingTileForTarget: scriptedPlayer partName: partName getter: getSelector setter: putSelector.	(partType == #Number) ifTrue:		[(delta := scriptedPlayer arrowDeltaFor: getSelector) = 1			ifFalse:				[readout setProperty: #arrowDelta toValue: delta].		scriptedPlayer setFloatPrecisionFor: readout updatingStringMorph].	readout step.	^ readout! !!CategoryViewer methodsFor: 'entries' stamp: 'nk 10/14/2004 10:54'!wantsRowMenuFor: aSymbol	"Answer whether a viewer row for the given symbol should have a menu button on it"	| elementType |	true ifTrue: [^ true].  "To allow show categories item.  So someday this method can be removed, and its sender can stop sending it..."	elementType := scriptedPlayer elementTypeFor: aSymbol vocabulary: self currentVocabulary.	(elementType == #systemScript) ifTrue: [^ false].	((elementType == #systemSlot) and:		[#(color:sees: touchesA: overlaps: overlapsAny:) includes: aSymbol]) ifTrue: [^ false].	^ true! !!CategoryViewer methodsFor: 'e-toy support' stamp: 'sw 9/13/2001 19:16'!adoptVocabulary: aVocabulary	"Adopt the given vocabulary as the one used in this viewer."	| aCategory |	chosenCategorySymbol ifNil: [^ self delete].	aCategory := aVocabulary categoryAt: chosenCategorySymbol.	aCategory ifNil: [self delete] ifNotNil: [self updateCategoryNameTo: aCategory wording].	super adoptVocabulary: aVocabulary! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'dgd 9/1/2003 13:51'!arrowSetterButton: sel args: argArray	| m |	m := RectangleMorph new		color: (ScriptingSystem colorForType: #command);		extent: 24@TileMorph defaultH;		borderWidth: 0.	m addMorphCentered: (ImageMorph new image: (ScriptingSystem formAtKey: 'Gets')).	m setBalloonText: 'drag from here to obtain an assignment phrase.' translated.	m on: #mouseDown send: sel		to: self		withValue: argArray.	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'dgd 9/1/2003 13:51'!arrowSetterButtonFor: partName type: partType	| m |	m := RectangleMorph new		color: (ScriptingSystem colorForType: #command);		extent: 24@TileMorph defaultH;		borderWidth: 0.	m addMorphCentered: (ImageMorph new image: (ScriptingSystem formAtKey: 'Gets')).	m setBalloonText: 'drag from here to obtain an assignment phrase.' translated.	m on: #mouseDown send: #makeSetter:event:from:		to: self		withValue: (Array with: partName with: partType).	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 9/27/2001 04:23'!getterButtonFor: getterSelector type: partType	"Answer a classic-tiles getter button for a part of the given name"	| m inherent wording |	m := TileMorph new adoptVocabulary: self currentVocabulary.	inherent := Utilities inherentSelectorForGetter: getterSelector.	wording := (scriptedPlayer slotInfo includesKey: inherent)		ifTrue: [inherent]		ifFalse: [self currentVocabulary tileWordingForSelector: getterSelector].	m setOperator: getterSelector andUseWording: wording.	m typeColor: (ScriptingSystem colorForType: partType).	m on: #mouseDown send: #makeGetter:event:from:		to: self		withValue: (Array with: getterSelector with: partType).	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'yo 3/24/2005 13:12'!getterTilesFor: getterSelector type: aType 	"Answer classic getter for the given name/type"	"aPhrase := nil, assumed"	| selfTile selector aPhrase |	(#(#color:sees: #colorSees) includes: getterSelector) 		ifTrue: [aPhrase := self colorSeesPhrase].	(#(#getPatchValueIn:) includes: getterSelector)		ifTrue: [aPhrase := self patchValuePhrase].	(#(#getRedComponentIn:) includes: getterSelector)		ifTrue: [aPhrase := self colorComponentPhraseFor: #red].	(#(#getGreenComponentIn:) includes: getterSelector)		ifTrue: [aPhrase := self colorComponentPhraseFor: #green].	(#(#getBlueComponentIn:) includes: getterSelector)		ifTrue: [aPhrase := self colorComponentPhraseFor: #blue].	(#(#getUphillIn:) includes: getterSelector)		ifTrue: [aPhrase := self patchUphillPhrase].	(#(#bounceOn:) includes: getterSelector)		ifTrue: [aPhrase := self bounceOnPhrase].	(#(#bounceOn:color: #bounceOnColor:) includes: getterSelector)		ifTrue: [aPhrase := self bounceOnColorPhrase].	(getterSelector = #getDistanceTo:)		ifTrue: [aPhrase := self distanceToPhrase].	(getterSelector = #getAngleTo:)		ifTrue: [aPhrase := self angleToPhrase].	(getterSelector = #getTurtleOf:)		ifTrue: [aPhrase := self turtleOfPhrase].	(#(#seesColor: #isOverColor) includes: getterSelector) 		ifTrue: [aPhrase := self seesColorPhrase].	(#(#overlaps: #overlaps) includes: getterSelector) 		ifTrue: [aPhrase := self overlapsPhrase].	(#(#overlapsAny: #overlapsAny) includes: getterSelector) 		ifTrue: [aPhrase := self overlapsAnyPhrase].	(#(#touchesA: #touchesA) includes: getterSelector) 		ifTrue: [aPhrase := self touchesAPhrase].	aPhrase ifNil: 			[aPhrase := PhraseTileMorph new setSlotRefOperator: getterSelector asSymbol						type: aType].	selfTile := self tileForSelf bePossessive.	selfTile position: aPhrase firstSubmorph position.	aPhrase firstSubmorph addMorph: selfTile.	selector := aPhrase submorphs second.	(#(#getPatchValueIn: getUphillIn:) includes: getterSelector) ifFalse: [		(Vocabulary vocabularyNamed: aType capitalized) 			ifNotNilDo: [:aVocab | aVocab wantsSuffixArrow ifTrue: [selector addSuffixArrow]].	].	selector updateLiteralLabel.	aPhrase enforceTileColorPolicy.	^aPhrase! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 4/6/2001 00:59'!makeGetter: args event: evt from: aMorph	"Hand the user tiles representing a classic getter on the slot represented by aMorph"	| tiles |	tiles := self getterTilesFor: args first type: args second.	owner		ifNotNil:	[self primaryHand attachMorph: tiles]		ifNil: 		[^ tiles]! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'yo 8/10/2005 17:29'!makeSetterForColorComponent: selectorAndTypePair componentName: componentName event: evt from: aMorph 	| argType m argTile selfTile argValue actualGetter |	argType := selectorAndTypePair second.	componentName = #red ifTrue: [actualGetter := #setRedComponentIn:].	componentName = #green ifTrue: [actualGetter := #setGreenComponentIn:].	componentName = #blue ifTrue: [actualGetter := #setBlueComponentIn:].	m := PhraseTileMorph new 				setColorComponentRoot: actualGetter				componentName: componentName				type: #command				rcvrType: #Patch				argType: argType				vocabulary: self currentVocabulary.	argValue := self scriptedPlayer 				perform: selectorAndTypePair first asSymbol with: nil.	(argValue isKindOf: Player) 		ifTrue: [argTile := argValue tileReferringToSelf]		ifFalse: 			[argTile := ScriptingSystem tileForArgType: argType.			(argType == #Number and: [argValue isNumber]) 				ifTrue: 					[(scriptedPlayer decimalPlacesForGetter: actualGetter) 						ifNotNilDo: [:places | (argTile findA: UpdatingStringMorph) decimalPlaces: places]].			argTile				setLiteral: argValue;				updateLiteralLabel].	argTile position: m lastSubmorph position.	m lastSubmorph addMorph: argTile.	selfTile := self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	m enforceTileColorPolicy.	m submorphs second setPatchDefaultTo: scriptedPlayer defaultPatchPlayer.	m openInHand! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'RAA 4/6/2001 13:28'!makeUniversalTilesGetter: aMethodInterface event: evt from: aMorph	"Button in viewer performs this to make a universal-tiles getter and attach it to hand."	| newTiles |	newTiles := self newGetterTilesFor: scriptedPlayer methodInterface: aMethodInterface.	newTiles setProperty: #beScript toValue: true.	owner		ifNotNil:			[ActiveHand attachMorph: newTiles.			newTiles align: newTiles topLeft with: evt hand position + (7@14)]		ifNil:			[^ newTiles]! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'nk 10/14/2004 10:53'!newGetterTilesFor: aPlayer methodInterface: aMethodInterface	"Return universal tiles for a getter on this property.  Record who self is."	| ms argTile argArray |	ms := MessageSend receiver: aPlayer selector: aMethodInterface selector arguments: #().	"Handle three idiosyncratic cases..."	aMethodInterface selector == #color:sees: ifTrue:		[argTile := ScriptingSystem tileForArgType: #Color.		argArray := Array with: argTile colorSwatch color with: argTile colorSwatch color copy. 		ms arguments: argArray].	aMethodInterface selector == #seesColor: ifTrue:		[argTile := ScriptingSystem tileForArgType: #Color.		ms arguments: (Array with: argTile colorSwatch color)].	(#(touchesA: overlaps: overlapsAny:) includes: aMethodInterface selector) ifTrue:		[argTile := ScriptingSystem tileForArgType: #Player.		ms arguments: (Array with: argTile actualObject)].	^ ms asTilesIn: aPlayer class globalNames: (aPlayer class officialClass ~~ CardPlayer)			"For CardPlayers, use 'self'.  For others, name it, and use its name."! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'ar 3/17/2001 14:17'!newMakeSetter: aSpec event: evt from: aMorph	"Button in viewer performs this to make a new style tile and attach to hand."	| m |	m := self newTilesFor: scriptedPlayer setter: aSpec.	owner ifNotNil: [self primaryHand attachMorph: m.			m align: m topLeft with: evt hand position + (7@14)]		ifNil: [^ m].! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'RAA 4/6/2001 13:28'!newMakeSetterFromInterface: aMethodInterface evt: evt from: aMorph 	"Button in viewer performs this to make a new style tile and attach to hand."	| m |	m := self newSetterTilesFor: scriptedPlayer methodInterface: aMethodInterface.	m setProperty: #beScript toValue: true.	owner		ifNotNil: [self primaryHand attachMorph: m.			m align: m topLeft with: evt hand position + (7@14)]		ifNil: [^ m]! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'tk 9/30/2001 11:20'!newSetterTilesFor: aPlayer methodInterface: aMethodInterface	"Return universal tiles for a setter on this property.  Record who self is."	| ms argValue makeSelfGlobal phrase |	argValue := aPlayer perform: aMethodInterface selector.	ms := MessageSend receiver: aPlayer 		selector: aMethodInterface companionSetterSelector 		arguments: (Array with: argValue).	makeSelfGlobal := aPlayer class officialClass ~~ CardPlayer.	phrase := ms asTilesIn: aPlayer class globalNames: makeSelfGlobal.			"For CardPlayers, use 'self'.  For others, name it, and use its name."	makeSelfGlobal ifFalse: [phrase setProperty: #scriptedPlayer toValue: aPlayer].	^ phrase! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 11/16/2001 14:44'!newTilesFor: aPlayer setter: aSpec	| ms  argValue |	"Return universal tiles for a getter on this property.  Record who self is."	argValue := aPlayer perform: (Utilities getterSelectorFor: aSpec second asSymbol).	ms := MessageSend receiver: aPlayer selector: aSpec ninth arguments: (Array with: argValue).	^ ms asTilesIn: aPlayer class globalNames: (aPlayer class officialClass ~~ CardPlayer)			"For CardPlayers, use 'self'.  For others, name it, and use its name."! !!CategoryViewer methodsFor: 'header pane' stamp: 'sw 8/31/2004 14:01'!addHeaderMorph	"Add the header at the top of the viewer, with a control for choosing the category, etc."	| header aButton |	header := AlignmentMorph newRow color: self color; wrapCentering: #center; cellPositioning: #leftCenter.	aButton := self tanOButton.	header addMorph: aButton.	aButton actionSelector: #delete;		setBalloonText: 'remove this pane from the screendon''t worry -- nothing will be lost!!.' translated.	self maybeAddArrowsTo: header.	header beSticky.	self addMorph: header.	self addNamePaneTo: header.	chosenCategorySymbol := #basic! !!CategoryViewer methodsFor: 'header pane' stamp: 'dgd 9/1/2003 13:47'!maybeAddArrowsTo: header	"Maybe add up/down arrows to the header"	| wrpr |	header addTransparentSpacerOfSize: 5@5.	header addUpDownArrowsFor: self.	(wrpr := header submorphs last) submorphs second setBalloonText: 'previous category' translated.		wrpr submorphs first  setBalloonText: 'next category' translated! !!CategoryViewer methodsFor: 'initialization' stamp: 'dgd 8/16/2004 21:51'!initializeFor: aPlayer categoryChoice: aChoice	"Initialize the receiver to be associated with the player and category specified"	self listDirection: #topToBottom;		hResizing: #spaceFill;		vResizing: #spaceFill;		borderWidth: 1;		beSticky.	self color: Color green muchLighter muchLighter.	scriptedPlayer := aPlayer.	self addHeaderMorph.	self chooseCategoryWhoseTranslatedWordingIs: aChoice! !!CategoryViewer methodsFor: 'macpal' stamp: 'sw 5/4/2001 05:24'!currentVocabulary	"Answer the vocabulary currently installed in the viewer.  The outer StandardViewer object holds this information."	| outerViewer |	^  (outerViewer := self outerViewer)		ifNotNil:			[outerViewer currentVocabulary]		ifNil:			[(self world ifNil: [ActiveWorld]) currentVocabularyFor: scriptedPlayer]! !!CategoryViewer methodsFor: 'support' stamp: 'yo 9/28/2004 18:24'!booleanPhraseForBounceOnColorOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setBounceOnColorOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	"getterPhrase submorphs second setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer)."	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 9/27/2004 15:00'!booleanPhraseForBounceOnOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setBounceOnOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	"getterPhrase submorphs second setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer)."	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 6/17/2004 10:02'!booleanPhraseForGetAngleToOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setAngleToOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	getterPhrase submorphs second setTurtleDefaultTo: scriptedPlayer.	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 10/13/2004 01:39'!booleanPhraseForGetColorComponentOfType: retrieverType componentName: componentName retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setGetColorComponentOperator: retrieverOp componentName: componentName type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	getterPhrase submorphs second setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer).	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 6/15/2004 18:45'!booleanPhraseForGetDistanceToOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setDistanceToOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	getterPhrase submorphs second setTurtleDefaultTo: scriptedPlayer.	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 6/15/2004 16:38'!booleanPhraseForGetPatchValueOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setGetPixelOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	getterPhrase submorphs second setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer).	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 10/9/2004 10:39'!booleanPhraseForGetTurtleAtOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setTurtleAtOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	getterPhrase submorphs second setTurtleDefaultTo: scriptedPlayer.	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 3/7/2005 08:41'!booleanPhraseForGetTurtleOfOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setTurtleOfOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	"getterPhrase submorphs second setTurtleDefaultTo: scriptedPlayer."	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 6/15/2004 16:39'!booleanPhraseForGetUpHillOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setUpHillOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	getterPhrase submorphs second setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer).	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'sw 9/27/2001 13:28'!booleanPhraseForRetrieverOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setOperator: retrieverOp type: retrieverType rcvrType: #Player.	getterPhrase submorphs last setSlotRefOperator: retrieverOp.	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 3/24/2005 11:18'!booleanPhraseFromPhrase: phrase	"Answer, if possible, a boolean-valued phrase derived from the phrase provided"	|  retrieverOp retrieverTile |	(phrase isKindOf: ParameterTile) ifTrue: [^ phrase booleanComparatorPhrase].	phrase isBoolean ifTrue: [^ phrase].	((scriptedPlayer respondsTo: #costume) 		and:[scriptedPlayer costume isInWorld not]) ifTrue: [^ Array new].	((retrieverTile := phrase submorphs last) isKindOf: TileMorph) ifFalse: [^ phrase].	retrieverOp := retrieverTile operatorOrExpression.	(Vocabulary vocabularyForType: phrase resultType)		affordsCoercionToBoolean ifTrue: [			retrieverOp =  #getPatchValueIn: ifTrue: [				^ self booleanPhraseForGetPatchValueOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp =  #getRedComponentIn: ifTrue: [				^ self booleanPhraseForGetColorComponentOfType: phrase resultType componentName: #red  retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp =  #getGreenComponentIn: ifTrue: [				^ self booleanPhraseForGetColorComponentOfType: phrase resultType componentName: #green  retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp =  #getBlueComponentIn: ifTrue: [				^ self booleanPhraseForGetColorComponentOfType: phrase resultType componentName: #blue retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #getUphillIn: ifTrue: [				^ self booleanPhraseForGetUpHillOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #getDistanceTo: ifTrue: [				^ self booleanPhraseForGetDistanceToOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #getAngleTo: ifTrue: [				^ self booleanPhraseForGetAngleToOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #bounceOn: ifTrue: [				^ self booleanPhraseForBounceOnOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			(retrieverOp = #bounceOn:color: or: [retrieverOp = #bounceOnColor:]) ifTrue: [				^ self booleanPhraseForBounceOnColorOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #getTurtleAt: ifTrue: [				^ self booleanPhraseForGetTurtleAtOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #getTurtleOf: ifTrue: [				^ self booleanPhraseForGetTurtleOfOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			^ self booleanPhraseForRetrieverOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.		].	^ phrase! !!CategoryViewer methodsFor: 'support' stamp: 'sw 3/1/1999 11:57'!invisiblySetPlayer: aPlayer	scriptedPlayer := aPlayer! !!CategoryViewer methodsFor: 'support' stamp: 'sw 8/6/2001 19:42'!limitClass	"Answer the receiver's limitClass"	| outer |	^ (outer := self outerViewer)		ifNotNil:			[outer limitClass]		ifNil:			[ProtoObject]! !!ChangeHooksTest methodsFor: 'Running' stamp: 'rej 9/29/2007 10:24'!tearDown	super tearDown.	self removeGeneratedTestClasses.	ChangeSet newChanges: previousChangeSet.	ChangesOrganizer removeChangeSet: testsChangeSet.	previousChangeSet := nil.	testsChangeSet := nil.! !!ChangeList methodsFor: 'menu actions' stamp: 'pk 10/17/2006 09:33'!selectAllConflicts	"Selects all method definitions in the receiver which are also in any existing change set in the system.  This makes no statement about whether the content of the methods differ, only whether there is a change represented."	|  aClass aChange |	Cursor read showWhile: 		[1 to: changeList size do:			[:i | aChange := changeList at: i.			listSelections at: i put:				(aChange type = #method				and: [(aClass := aChange methodClass) notNil				and: [ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector:  aChange methodSelector]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'pk 10/17/2006 09:34'!selectConflictsWith	"Selects all method definitions for which there is ALSO an entry in the specified changeSet or changList chosen by the user. 4/11/96 tk"	| aStream all index |	aStream := WriteStream on: (String new: 200).	(all := ChangesOrganizer allChangeSets copy) do:		[:sel | aStream nextPutAll: (sel name contractTo: 40); cr].	ChangeList allSubInstancesDo:		[:sel | aStream nextPutAll: (sel file name); cr.			all addLast: sel].	aStream skip: -1.	index := (UIManager default chooseFrom: (aStream contents substrings)).	index > 0 ifTrue: [		self selectConflicts: (all at: index)].! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/17/2006 22:26'!event: anEvent	"Hook for SystemChangeNotifier"	anEvent itemKind = SystemChangeNotifier classKind ifTrue: [		anEvent isRemoved 			ifTrue: [self noteRemovalOf: anEvent item].		anEvent isAdded 			ifTrue: [self addClass: anEvent item].		anEvent isModified 			ifTrue: [anEvent anyChanges ifTrue: [self changeClass: anEvent item from: anEvent oldItem]].		anEvent isCommented 			ifTrue: [self commentClass: anEvent item].		anEvent isRenamed 			ifTrue: [self renameClass: anEvent item from: anEvent oldName to: anEvent newName].		anEvent isReorganized			ifTrue: [self reorganizeClass: anEvent item].		anEvent isRecategorized			ifTrue: [self changeClass: anEvent item from: anEvent item].	].	anEvent itemKind = SystemChangeNotifier methodKind ifTrue: [		anEvent isAdded			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: nil].		anEvent isModified			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: anEvent oldItem].		anEvent isRemoved			ifTrue: [self removeSelector: anEvent itemSelector class: anEvent itemClass priorMethod: anEvent item lastMethodInfo: {anEvent item sourcePointer. anEvent itemProtocol}].		anEvent isRecategorized			ifTrue: [self reorganizeClass: anEvent itemClass].	].! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/19/2006 17:52'!renameClass: class from: oldName to: newName 	"Include indication that a class has been renamed."	| recorder oldMetaClassName newMetaClassName |	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet renameClass: class as: newName].	(recorder _ self changeRecorderFor: oldName)		noteChangeType: #rename;		noteNewName: newName asSymbol.			"store under new name (metaclass too)"	changeRecords at: newName put: recorder.	changeRecords removeKey: oldName.	self noteClassStructure: class.	newMetaClassName := newName, ' class'.	oldMetaClassName := oldName, ' class'.	recorder _ changeRecords at: oldMetaClassName ifAbsent: [^ nil].	changeRecords at: newMetaClassName put: recorder.	changeRecords removeKey: oldMetaClassName.	recorder noteNewName: newMetaClassName! !!ChangeSet class methodsFor: 'current changeset' stamp: 'wiz 9/19/2006 03:21'!current	"return the current changeset	assure first that we have a named changeset. To cure mantis #4535. "	current isMoribund		ifTrue: [(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed'))] .	^ current! !!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 9/8/2006 21:05'!resetCurrentToNewUnnamedChangeSet 	current := self new.  	self newChanges: current ! !!ChangeSetCategory methodsFor: 'miscellaneous' stamp: 'pk 10/17/2006 09:36'!reconstituteList	"Clear out the receiver's elements and rebuild them"	| newMembers |	"First determine newMembers and check if they have not changed..."	newMembers := ChangesOrganizer allChangeSets select:		[:aChangeSet | ChangesOrganizer perform: membershipSelector with: aChangeSet].	(newMembers collect: [:cs | cs name]) = keysInOrder ifTrue: [^ self  "all current"].	"Things have changed.  Need to recompute the whole category"	self clear.	newMembers do:		[:aChangeSet | self fasterElementAt: aChangeSet name asSymbol put: aChangeSet] ! !!ChangeSetCategory methodsFor: 'queries' stamp: 'pk 10/17/2006 09:34'!changeSetList	"Answer the list of change-set names in the category"	| aChangeSet |	self reconstituteList.	keysInOrder size == 0 ifTrue:		["don't tolerate emptiness, because ChangeSorters gag when they have no change-set selected"		aChangeSet := ChangesOrganizer assuredChangeSetNamed: 'New Changes'.		self elementAt: aChangeSet name put: aChangeSet].	^ keysInOrder reversed! !!ChangeSetCategory methodsFor: 'queries' stamp: 'pk 10/17/2006 09:35'!includesChangeSet: aChangeSet	"Answer whether the receiver includes aChangeSet in its retrieval list"	^ ChangesOrganizer perform: membershipSelector with: aChangeSet! !!ChangeSetCategory methodsFor: 'services' stamp: 'pk 10/17/2006 09:34'!fileOutAllChangeSets	"File out all the nonempty change sets in the current category, suppressing the checks for slips that might otherwise ensue.  Obtain user confirmation before undertaking this possibly prodigious task."	| aList |	aList := self elementsInOrder select:		[:aChangeSet  | aChangeSet isEmpty not].	aList size == 0 ifTrue: [^ self inform: 'sorry, all the change sets in this category are empty'].	(self confirm: 'This will result in filing out ', aList size printString, ' change set(s)Are you certain you want to do this?') ifFalse: [^ self].	Preferences setFlag: #checkForSlips toValue: false during: 		[ChangesOrganizer fileOutChangeSetsNamed: (aList collect: [:m | m name]) asSortedArray]! !!ChangeSetCategory methodsFor: 'services' stamp: 'pk 10/17/2006 09:34'!fillAggregateChangeSet	"Create a change-set named Aggregate and pour into it all the changes in all the change-sets of the currently-selected category"	| aggChangeSet |	aggChangeSet :=  ChangesOrganizer assuredChangeSetNamed: #Aggregate.	aggChangeSet clear.	aggChangeSet setPreambleToSay: '"Change Set:		AggregateCreated at ', Time now printString, ' on ', Date today printString, ' by combining all the changes in all the change sets in the category ', categoryName printString, '"'.	(self elementsInOrder copyWithout: aggChangeSet) do:		[:aChangeSet  | aggChangeSet assimilateAllChangesFoundIn: aChangeSet].	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup] ! !!ChangeSetCategoryWithParameters methodsFor: 'as yet unclassified' stamp: 'pk 10/17/2006 09:36'!includesChangeSet: aChangeSet	"Answer whether the receiver includes aChangeSet in its retrieval list"	^ ChangesOrganizer perform: membershipSelector withArguments: { aChangeSet } , parameters! !!ChangeSetCategoryWithParameters methodsFor: 'as yet unclassified' stamp: 'pk 10/17/2006 09:36'!reconstituteList	"Clear out the receiver's elements and rebuild them"	| newMembers |	"First determine newMembers and check if they have not changed..."	newMembers := ChangesOrganizer allChangeSets select:		[:aChangeSet | ChangesOrganizer perform: membershipSelector withArguments: { aChangeSet }, parameters].	(newMembers collect: [:cs | cs name]) = keysInOrder ifTrue: [^ self  "all current"].	"Things have changed.  Need to recompute the whole category"	self clear.	newMembers do:		[:aChangeSet | self fasterElementAt: aChangeSet name asSymbol put: aChangeSet]! !!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'wiz 8/13/2006 17:55'!testInitialChangeSet	"Run this to assure the initial changeset is named. Checks bug found in 3.9 7052."	"self new testInitialChangeSet"	"self run:  #testInitialChangeSet"	self deny: (ChangeSet current printString = 'a ChangeSet named <no name -- garbage?>') .	^true! !!ChangeSorter methodsFor: 'access' stamp: 'pk 10/17/2006 09:37'!showChangeSetNamed: aName	self showChangeSet: (ChangesOrganizer changeSetNamed: aName) ! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/3/2007 15:37'!annotationForPackageforSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing 	information about the given selector and class"	"requestList"| aCategory |aClass ifNil: [ ^nil] .aSelector ifNil: [ aClass theNonMetaClass category asString ] .aSelector ifNotNil: [ aCategory := aClass organization categoryOfElement: aSelector.(aCategory notNil and: [ aCategory first = $* ]) 	ifTrue: [^ aCategory asString]] .	"Ok. So the selector catagory does not indicate our package. We defer to the class catagory"^ aClass theNonMetaClass category asString.	! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 16:56'!beginNote"return the string at the beginning of item annotation"^' {'! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 16:56'!endNote"return the string at the beginning of item annotation"^'}'! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 17:21'!noteString: aString^ self beginNote , aString asString , self endNote! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/3/2007 15:39'!packageNoteForClass: aClass selector: aSelector "return the category name that represents the package name for aClass>>aSelector.when selector is nil or in a normal catagory return "| package |package := (self annotationForPackageforSelector: aSelector			ofClass: aClass) ifNil: ['<class was deleted???>'] .^ self noteString: package! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 17:17'!withoutItemAnnotation: aStringOrNil"return the current item without the package annotation we added on"| endItemIndex |aStringOrNil ifNil: [^nil] .( endItemIndex := aStringOrNil findString: self beginNote) = 0	ifTrue: [^ aStringOrNil ] .^ aStringOrNil first: endItemIndex - 1! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:36'!browseMethodConflicts	"Check to see if any other change set also holds changes to any methods in the selected change set; if so, open a browser on all such."	| aList |	aList := myChangeSet 		messageListForChangesWhich: [ :aClass :aSelector |			(ChangesOrganizer allChangeSetsWithClass: aClass selector: aSelector) size > 1		]		ifNone: [^ self inform: 'No other change set has changesfor any method in this change set.'].		MessageSet 		openMessageList: aList 		name: 'Methods in "', myChangeSet name, '" that are also in other change sets (', aList size printString, ')'	! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:48'!changeSetCategories	^ ChangesOrganizer changeSetCategories! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:48'!chooseChangeSetCategory	"Present the user with a list of change-set-categories and let her choose one"	|  cats aMenu result |	self okToChange ifFalse: [^ self].	Smalltalk isMorphic ifTrue: [^ self chooseChangeSetCategoryInMorphic].  "gives balloon help"	cats := self changeSetCategories elementsInOrder.	aMenu := SelectionMenu		labels: (cats collect: [:cat | cat categoryName])		selections: cats.	result := aMenu startUp.	result ifNotNil:		[changeSetCategory := result.		self changed: #changeSetList.		(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangesOrganizer changeSetNamed: self changeSetList first)].		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:48'!chooseChangeSetCategoryInMorphic	"Present the user with a list of change-set-categories and let her choose one.  In this morphic variant, we include balloon help"	|  aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'Choose the category ofchange sets to show inthis Change Sorter(red = current choice)'.	self changeSetCategories elementsInOrder do:		[:aCategory |			aMenu add: aCategory categoryName target: self selector: #showChangeSetCategory: argument: aCategory.			aCategory == changeSetCategory ifTrue:				[aMenu lastItem color: Color red].			aMenu balloonTextForLastItem: aCategory documentation].	aMenu popUpInWorld! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:36'!chooseCngSet	"Present the user with an alphabetical list of change set names, and let her choose one"	| changeSetsSortedAlphabetically chosen |	self okToChange ifFalse: [^ self].	changeSetsSortedAlphabetically := self changeSetList asSortedCollection:		[:a :b | a asLowercase withoutLeadingDigits < b asLowercase withoutLeadingDigits].	chosen := (SelectionMenu selections: changeSetsSortedAlphabetically)			startUp.	chosen ifNil: [^ self].	self showChangeSet: (ChangesOrganizer changeSetNamed: chosen)! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!makeNewCategory	"Create a new, static change-set category, which will be populated entirely by change sets that have been manually placed in it"	| catName aCategory |	catName := UIManager default request: 'Please give the new category a name' initialAnswer: ''.	catName isEmptyOrNil ifTrue: [^ self].	catName := catName asSymbol.	(self changeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	aCategory := StaticChangeSetCategory new categoryName: catName.	self changeSetCategories elementAt: catName put: aCategory.	aCategory addChangeSet: myChangeSet.	self showChangeSetCategory: aCategory! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!makeNewCategoryShowingClassChanges	"Create a new, static change-set category, which will be populated entirely by change sets that have been manually placed in it"	| catName aCategory clsName |	clsName := self selectedClass ifNotNil: [self selectedClass name ] ifNil: [''].	clsName := UIManager default request: 'Which class?' initialAnswer: clsName.	clsName isEmptyOrNil ifTrue: [^ self].	catName := ('Changes to ', clsName) asSymbol.	(self changeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	aCategory := ChangeSetCategoryWithParameters new categoryName: catName.	aCategory membershipSelector: #changeSet:containsClass: ; parameters: { clsName }.	self changeSetCategories elementAt: catName put: aCategory.	aCategory reconstituteList.	self showChangeSetCategory: aCategory! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!removeCategory	"Remove the current category"	| itsName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ self inform: 'sorry, you can only remove manually-added categories.'].	(self confirm: 'Really remove the change-set-categorynamed ', (itsName := changeSetCategory categoryName), '?') ifFalse: [^ self].	self changeSetCategories removeElementAt: itsName.	self setDefaultChangeSetCategory.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:36'!removePrompting: doPrompt	"Completely destroy my change set.  Check if it's OK first, and if doPrompt is true, get the user to confirm his intentions first."	| message aName changeSetNumber msg |	aName := myChangeSet name.	myChangeSet okayToRemove ifFalse: [^ self]. "forms current changes for some project"	(myChangeSet isEmpty or: [doPrompt not]) ifFalse:		[message := 'Are you certain that you want to remove (destroy) the change setnamed  "', aName, '" ?'.		(self confirm: message) ifFalse: [^ self]].	doPrompt ifTrue:		[msg := myChangeSet hasPreamble			ifTrue:				[myChangeSet hasPostscript					ifTrue:						['a preamble and a postscript']					ifFalse:						['a preamble']]			ifFalse:				[myChangeSet hasPostscript					ifTrue:						['a postscript']					ifFalse:						['']].		msg isEmpty ifFalse:			[(self confirm: 'Caution!!  This change set has', msg, ' which will belost if you destroy the change set.Do you really want to go ahead with this?') ifFalse: [^ self]]].	"Go ahead and remove the change set"	changeSetNumber := myChangeSet name initialIntegerOrNil.	changeSetNumber ifNotNil: [SystemVersion current unregisterUpdate: changeSetNumber].	ChangesOrganizer removeChangeSet: myChangeSet.	self showChangeSet: ChangeSet current.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!renameCategory	"Obtain a new name for the category and, if acceptable, apply it"	| catName oldName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ self inform: 'sorry, you can only rename manually-added categories.'].	catName := UIManager default request: 'Please give the new category a name' initialAnswer:  (oldName := changeSetCategory categoryName).	catName isEmptyOrNil ifTrue: [^ self].	(catName := catName asSymbol) = oldName ifTrue: [^ self inform: 'no change.'].	(self changeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	changeSetCategory categoryName: catName.	self changeSetCategories removeElementAt: oldName.	self changeSetCategories elementAt: catName put: changeSetCategory.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!showCategoriesOfChangeSet	"Show a list of all the categories in which the selected change-set occurs at the moment.  Install the one the user chooses, if any."	| aMenu |	Smalltalk isMorphic		ifFalse:			[self inform:'Only available in morphic, right now, sorry.It would not take much to make thisalso work in mvc, so if you areinclined to do that, thanks in advance...']		ifTrue:			[aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'Categories whichcontain change set"', myChangeSet name, '"'.			self changeSetCategories elementsInOrder do:				[:aCategory |					(aCategory includesChangeSet: myChangeSet)						ifTrue:							[aMenu add: aCategory categoryName target: self selector: #showChangeSetCategory: argument: aCategory.						aCategory == changeSetCategory ifTrue:							[aMenu lastItem color: Color red]].						aMenu balloonTextForLastItem: aCategory documentation].				aMenu popUpInWorld]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:37'!showChangeSetCategory: aChangeSetCategory	"Show the given change-set category"		changeSetCategory := aChangeSetCategory.	self changed: #changeSetList.	(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangesOrganizer changeSetNamed: self changeSetList first)].	self changed: #relabel! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:14'!basicClassList	"Computed.  View should try to preserve selections, even though index changes"	^ myChangeSet ifNotNil: [myChangeSet changedClassNames] ifNil: [OrderedCollection new]! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:35'!classList	"return the classlist with package note appended."		^ self basicClassList collect: [: each | 		each asString, (self packageNoteForClass: (Smalltalk classNamed: each) selector: nil) ] .! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:37'!fileOutClass	"this is a hack!!!! makes a new change set, called the class name, adds author initials to try to make a unique change set name, files it out and removes it. kfr 16 june 2000" 	| aSet |	"File out the selected class set."     aSet := self class newChangeSet: (self withoutItemAnnotation: currentClassName).	aSet absorbClass: self selectedClassOrMetaClass name from: myChangeSet.	aSet fileOut.	self class removeChangeSet: aSet.	parent modelWakeUp.	"notice object conversion methods created"! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:38'!forgetClass	"Remove all mention of this class from the changeSet"	self okToChange ifFalse: [^ self].	currentClassName ifNotNil: [		myChangeSet removeClassChanges: (self withoutItemAnnotation: currentClassName).		currentClassName := nil.		currentSelector := nil.		self showChangeSet: myChangeSet].! !!ChangeSorter methodsFor: 'code pane' stamp: 'wiz 2/3/2007 01:34'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType | 	self clearUserEditFlag.	currentClassName ifNil: [^ contents := myChangeSet preambleString ifNil: ['']].	class := self selectedClassOrMetaClass.	(sel := self selectedMessageName) == nil		ifFalse: [changeType := (myChangeSet atSelector: (sel := sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents := 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents := 'Added then removed (see versions)'].			class ifNil: [^ contents := 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents := 'Method was added, but cannot be found!!'].			contents := class sourceCodeAt: sel.			(#(prettyPrint colorPrint prettyDiffs) includes: contentsSymbol) ifTrue:				[contents :=  class prettyPrinterClass					format: contents in: class notifying: nil contentsSymbol: contentsSymbol].			self showingAnyKindOfDiffs				ifTrue: [contents := self diffFromPriorSourceFor: contents].			^ contents := contents asText makeSelectorBoldIn: class]		ifTrue: [strm := WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ contents := strm contents].! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:13'!basicMessageList 	| probe newSelectors className |	currentClassName ifNil: [^ #()].	className := (self withoutItemAnnotation: currentClassName) .	probe := (className endsWith: ' class')		ifTrue: [className]		ifFalse: [className asSymbol].	newSelectors := myChangeSet selectorsInClass: probe.	(newSelectors includes: (self selectedMessageName)) 		ifFalse: [currentSelector := nil].	^ newSelectors asSortedCollection! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:32'!copyMethodToOther	"Place this change in the other changeSet also"	| other cls sel |	self checkThatSidesDiffer: [^ self].	currentSelector ifNotNil:		[other := (parent other: self) changeSet.		cls := self selectedClassOrMetaClass.		sel := self selectedMessageName.		other absorbMethod: sel class: cls from: myChangeSet.		(parent other: self) showChangeSet: other]! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:32'!messageList 	| thisClass |	(thisClass := self selectedClassOrMetaClass) ifNil: [^ #() ] .	^self basicMessageList collect: [ :each |		each asString , (self packageNoteForClass: thisClass selector: each) ] .! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 7/22/2007 22:13'!moveMethodToOther	"Place this change in the other changeSet and remove it from this side"	| other cls sel |	self checkThatSidesDiffer: [^self].	self okToChange ifFalse: [^Beeper beep].	currentSelector ifNotNil: 			[other := (parent other: self) changeSet.			other == myChangeSet ifTrue: [^Beeper  beep].			cls := self selectedClassOrMetaClass.			sel := self selectedMessageName.			other 				absorbMethod: sel				class: cls				from: myChangeSet.			(parent other: self) showChangeSet: other.			self forget	"removes the method from this side"]! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:33'!selectedMessageName	currentSelector ifNil: [^ nil].	^ (self withoutItemAnnotation: currentSelector) asSymbol! !!ChangeSorter methodsFor: 'toolbuilder' stamp: 'wiz 2/1/2007 15:37'!buildWith: builder	"		ToolBuilder open: ChangeSorter.	"	|  windowSpec |	windowSpec := builder pluggableWindowSpec new.	windowSpec label: 'Change Sorter'.	windowSpec model: self.	windowSpec children: OrderedCollection new.	self buildWith: builder in: windowSpec rect: (0@0 extent: 1@1).	^builder build: windowSpec! !!ChangeSorter methodsFor: 'traits' stamp: 'wiz 2/3/2007 01:34'!selectedClassOrMetaClass	"Careful, the class may have been removed!!"	| cName tName className |	currentClassName ifNil: [^ nil].	className := (self withoutItemAnnotation: currentClassName) .	(className endsWith: ' class')		ifTrue: [cName _ (className copyFrom: 1 to: className size-6) asSymbol.				^ (Smalltalk at: cName ifAbsent: [^nil]) class].	(currentClassName endsWith: ' classTrait')		ifTrue: [tName _ (className copyFrom: 1 to: className size-11) asSymbol.				^ (Smalltalk at: tName ifAbsent: [^nil]) classTrait].	cName _ className asSymbol.	^ Smalltalk at: cName ifAbsent: [nil]! !!ChangeSorter commentStamp: '<historical>' prior: 0!I display a ChangeSet.  Two of me are in a DualChangeSorter.!!ChangeSorter class methodsFor: 'class initialization' stamp: 'pk 10/17/2006 09:10'!initialize	"ChangeSorter initialize"	FileList registerFileReader: self.	self registerInFlapsRegistry.! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 08:59'!allChangeSetNames	^ ChangesOrganizer allChangeSetNames! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:00'!allChangeSets	^ ChangesOrganizer allChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!allChangeSetsWithClass: class selector: selector	^ ChangesOrganizer allChangeSetsWithClass: class selector: selector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:19'!assuredChangeSetNamed: aName	^ ChangesOrganizer assuredChangeSetNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:01'!basicNewChangeSet: newName	^ ChangesOrganizer basicNewChangeSet: newName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:03'!belongsInAdditions: aChangeSet	^ ChangesOrganizer belongsInAdditions: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:03'!belongsInAll: aChangeSet	^ ChangesOrganizer belongsInAll: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:03'!belongsInMyInitials: aChangeSet	^ ChangesOrganizer belongsInMyInitials: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:04'!belongsInNumbered: aChangeSet	^ ChangesOrganizer belongsInNumbered: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:04'!belongsInProjectChangeSets: aChangeSet	^ ChangesOrganizer belongsInProjectChangeSets: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:06'!belongsInProjectsInRelease:  aChangeSet	^ ChangesOrganizer belongsInProjectsInRelease:  aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:06'!belongsInRecentUpdates: aChangeSet	^ ChangesOrganizer belongsInRecentUpdates: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:20'!buildAggregateChangeSet	^ ChangesOrganizer buildAggregateChangeSet	! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!changeSet: aChangeSet containsClass: aClass	^ ChangesOrganizer changeSet: aChangeSet containsClass: aClass! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:07'!changeSetCategoryNamed: aName	^ ChangesOrganizer changeSetCategoryNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!changeSetNamed: aName	^ ChangesOrganizer changeSetNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:07'!changeSetNamesInReleaseImage	^ ChangesOrganizer changeSetNamesInReleaseImage! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:08'!changeSetNamesInThreeOh	^ ChangesOrganizer changeSetNamesInThreeOh! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!changeSetsNamedSuchThat: nameBlock	^ ChangesOrganizer changeSetsNamedSuchThat: nameBlock! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:20'!countOfChangeSetsWithClass: aClass andSelector: aSelector	^ ChangesOrganizer countOfChangeSetsWithClass: aClass andSelector: aSelector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:16'!deleteChangeSetsNumberedLowerThan: anInteger	^ ChangesOrganizer deleteChangeSetsNumberedLowerThan: anInteger! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:21'!doesAnyChangeSetHaveClass: aClass andSelector: aSelector	^ ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector: aSelector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!existingOrNewChangeSetNamed: aName	^ ChangesOrganizer existingOrNewChangeSetNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:23'!fileOutChangeSetsNamed: nameList	^ ChangesOrganizer fileOutChangeSetsNamed: nameList! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!gatherChangeSets	^ ChangesOrganizer gatherChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!highestNumberedChangeSet	^ ChangesOrganizer highestNumberedChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:10'!initializeChangeSetCategories	^ ChangesOrganizer initializeChangeSetCategories! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!mostRecentChangeSetWithChangeForClass: class selector: selector	^ ChangesOrganizer mostRecentChangeSetWithChangeForClass: class selector: selector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:01'!newChangeSet	^ ChangesOrganizer newChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:02'!newChangeSet: aName	^ ChangesOrganizer newChangeSet: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:02'!newChangesFromStream: aStream named: aName	^ ChangesOrganizer newChangesFromStream: aStream named: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:11'!noteChangeSetsInRelease	^ ChangesOrganizer noteChangeSetsInRelease! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:14'!promoteToTop: aChangeSet	^ ChangesOrganizer promoteToTop: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:21'!recentUpdateMarker	^ ChangesOrganizer recentUpdateMarker! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:22'!recentUpdateMarker: aNumber	^ ChangesOrganizer recentUpdateMarker: aNumber! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'asm 4/10/2003 12:42'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(ChangeSorter			prototypicalToolWindow		'Change Set'			'A tool that allows you to view and manipulate all the code changes in a single change set')						forFlapNamed: 'Tools']! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:16'!removeChangeSet: aChangeSet	^ ChangesOrganizer removeChangeSet: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:17'!removeChangeSetsNamedSuchThat: nameBlock	^ ChangesOrganizer removeChangeSetsNamedSuchThat: nameBlock! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:17'!removeEmptyUnnamedChangeSets	^ ChangesOrganizer removeEmptyUnnamedChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:22'!reorderChangeSets	^ ChangesOrganizer reorderChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:22'!secondaryChangeSet	^ ChangesOrganizer secondaryChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'ar 9/27/2005 19:56'!unload	"Unload the receiver from global registries"	self environment at: #FileList ifPresent: [:cl |	cl unregisterFileReader: self].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!ChangeSorter class methodsFor: 'browse' stamp: 'sd 11/20/2005 21:28'!browseChangeSetsWithClass: class selector: selector	"Put up a menu comprising a list of change sets that hold changes for the given class and selector.  If the user selects one, open a single change-sorter onto it"	| hits index |	hits := self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ self inform: class name, '.', selector , 'is not in any change set'].	index := hits size == 1		ifTrue:	[1]		ifFalse:	[(UIManager default chooseFrom: (hits collect: [:cs | cs name])					lines: #())].	index = 0 ifTrue: [^ self].	(ChangeSorter new myChangeSet: (hits at: index)) open.! !!ChangeSorter class methodsFor: 'browse' stamp: 'sd 11/20/2005 21:28'!browseChangeSetsWithSelector: aSelector	"Put up a list of all change sets that contain an addition, deletion, or change of any method with the given selector"	| hits index |	hits := self allChangeSets select: 		[:cs | cs hasAnyChangeForSelector: aSelector].	hits isEmpty ifTrue: [^ self inform: aSelector , 'is not in any change set'].	index := hits size == 1		ifTrue:	[1]		ifFalse:	[(UIManager default chooseFrom: (hits collect: [:cs | cs name])					lines: #())].	index = 0 ifTrue: [^ self].	(ChangeSetBrowser new myChangeSet: (hits at: index)) open"ChangeSorter browseChangeSetsWithSelector: #clearPenTrails"! !!ChangeSorter class methodsFor: 'browse' stamp: 'sw 6/13/2001 00:56'!prototypicalToolWindow	"Answer a window representing a prototypical instance of the receiver"	^ self new morphicWindow applyModelExtent! !!ChangesOrganizer commentStamp: 'pk 10/17/2006 09:25' prior: 0!Changes organizer!!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!allChangeSetNames	^ self allChangeSets collect: [:c | c name]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!allChangeSets	"Return the list of all current ChangeSets"	^ChangeSet allChangeSets! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!allChangeSetsWithClass: class selector: selector	class ifNil: [^ #()].	^ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!changeSet: aChangeSet containsClass: aClass	| theClass |	theClass := Smalltalk classNamed: aClass.	theClass ifNil: [^ false].	^ aChangeSet containsClass: theClass! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!changeSetNamed: aName	"Return the change set of the given name, or nil if none found.  1/22/96 sw"	^ChangeSet named: aName! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!changeSetsNamedSuchThat: nameBlock	^ChangeSet changeSetsNamedSuchThat: nameBlock! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!existingOrNewChangeSetNamed: aName	^ChangeSet existingOrNewChangeSetNamed: aName! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!gatherChangeSets		"ChangeSorter gatherChangeSets"	^ChangeSet gatherChangeSets! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!highestNumberedChangeSet	"ChangeSorter highestNumberedChangeSet"	| aList |	aList := (ChangeSet allChangeSetNames select: [:aString | aString startsWithDigit] thenCollect:		[:aString | aString initialIntegerOrNil]).	^ (aList size > 0)		ifTrue:			[aList max]		ifFalse:			[nil]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!mostRecentChangeSetWithChangeForClass: class selector: selector	| hits |	hits := self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ 'not in any change set'].	^ 'recent cs: ', hits last name! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!promoteToTop: aChangeSet	"Make aChangeSet the first in the list from now on"	^ChangeSet promoteToTop: aChangeSet! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!assuredChangeSetNamed: aName	"Answer a change set of the given name.  If one already exists, answer that, else create a new one and answer it."	| existing |	^ (existing := self changeSetNamed: aName)		ifNotNil:			[existing]		ifNil:			[self basicNewChangeSet: aName]! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!buildAggregateChangeSet	"Establish a change-set named Aggregate which bears the union of all the changes in all the existing change-sets in the system (other than any pre-existing Aggregate).  This can be useful when wishing to discover potential conflicts between a disk-resident change-set and an image.  Formerly very useful, now some of its unique contributions have been overtaken by new features"	| aggregateChangeSet |	aggregateChangeSet := self existingOrNewChangeSetNamed: 'Aggregate'.	aggregateChangeSet clear.	self allChangeSets do:		[:aChangeSet | aChangeSet == aggregateChangeSet ifFalse:			[aggregateChangeSet assimilateAllChangesFoundIn: aChangeSet]]"ChangeSorter buildAggregateChangeSet"	! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!countOfChangeSetsWithClass: aClass andSelector: aSelector	"Answer how many change sets record a change for the given class and selector"	^ (self allChangeSetsWithClass: aClass selector: aSelector) size! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!doesAnyChangeSetHaveClass: aClass andSelector: aSelector	"Answer whether any known change set bears a change for the given class and selector"	^ (self countOfChangeSetsWithClass: aClass andSelector: aSelector) > 0! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!recentUpdateMarker	"Answer the number representing the threshold of what counts as 'recent' for an update number.  This allow you to use the RecentUpdates category in a ChangeSorter to advantage"	^ RecentUpdateMarker ifNil: [RecentUpdateMarker := 0]! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!recentUpdateMarker: aNumber	"Set the recent update marker as indicated"	^ RecentUpdateMarker := aNumber! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!reorderChangeSets	"Change the order of the change sets to something more convenient:		First come the project changesets that come with the release.  These are mostly empty.		Next come all numbered updates.		Next come all remaining changesets	In a ChangeSorter, they will appear in the reversed order."	"ChangeSorter reorderChangeSets"	| newHead newMid newTail |	newHead := OrderedCollection new.	newMid := OrderedCollection new.	newTail := OrderedCollection new.	ChangeSet allChangeSets do:		[:aChangeSet |			(self belongsInProjectsInRelease: aChangeSet)				ifTrue:					[newHead add: aChangeSet]				ifFalse:					[(self belongsInNumbered: aChangeSet)						ifTrue:							[newMid add: aChangeSet]						ifFalse:							[newTail add: aChangeSet]]].	ChangeSet allChangeSets: newHead, newMid, newTail.	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup]! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!secondaryChangeSet	^ChangeSet secondaryChangeSet! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!basicNewChangeSet: newName	^ChangeSet basicNewChangeSet: newName! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!newChangeSet	"Prompt the user for a name, and establish a new change set of	that name (if ok), making it the current changeset.  Return nil	of not ok, else return the actual changeset."	| newName newSet |	newName := UIManager default		request: 'Please name the new change set:'		initialAnswer: ChangeSet defaultName.	newName isEmptyOrNil ifTrue:		[^ nil].	newSet := self basicNewChangeSet: newName.	newSet ifNotNil:		[ChangeSet  newChanges: newSet].	^ newSet! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!newChangeSet: aName	"Makes a new change set called aName, add author initials to try to	ensure a unique change set name."	| newName |	newName := aName , FileDirectory dot , Utilities authorInitials.	^ self basicNewChangeSet: newName! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!newChangesFromStream: aStream named: aName	^ChangeSet newChangesFromStream: aStream named: aName! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInAdditions: aChangeSet	"Answer whether a change set belongs in the Additions category, which is fed by all change sets that are neither numbered nor in the initial release"	^ (((self belongsInProjectsInRelease: aChangeSet) or:		[self belongsInNumbered: aChangeSet])) not! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInAll: aChangeSet	"Answer whether a change set belongs in the All category"	^ true ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInMyInitials: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet name endsWith: ('-', Utilities authorInitials)! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 10/17/2006 09:04'!belongsInNumbered: aChangeSet	"Answer whether a change set belongs in the Numbered category. "	^  aChangeSet name startsWithDigit! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInProjectChangeSets: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet belongsToAProject! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInProjectsInRelease:  aChangeSet	"Answer whether a change set belongs in the ProjectsInRelease category.  You can hand-tweak this to suit your working style.  This just covers the space of project names in the 2.9, 3.0, and 3.1a systems"	| aString |	^ ((aString := aChangeSet name) beginsWith: 'Play With Me') or: [self changeSetNamesInReleaseImage includes: aString]! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInRecentUpdates: aChangeSet	"Answer whether a change set belongs in the RecentUpdates category."	^ aChangeSet name startsWithDigit and:			[aChangeSet name asInteger >= self recentUpdateMarker]! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!changeSetCategoryNamed: aName	"Answer the changeSetCategory of the given name, or nil if none"	^ ChangeSetCategories elementAt: aName asSymbol ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!changeSetNamesInReleaseImage	"Answer a list of names of project change sets that come pre-shipped in the latest sytem release.  On the brink of shipping a new release, call 'ChangeSorter noteChangeSetsInRelease'  "	^ ChangeSetNamesInRelease ifNil:		[ChangeSetNamesInRelease := self changeSetNamesInThreeOh]! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!changeSetNamesInThreeOh	"Hard-coded: answer a list of names of project change sets that came pre-shipped in Squeak 3.0"	^ #('The Worlds of Squeak' 'Fun with Morphic' 'Games' 'Fun With Music' 'Building with Squeak' 'Squeak and the Internet' 'Squeak in 3D' 'More About Sound' ) ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 10/17/2006 10:03'!initialize	"Initialize the class variables"	ChangeSetCategories ifNil:		[self initializeChangeSetCategories].	RecentUpdateMarker := 0.! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!initializeChangeSetCategories	"Initialize the set of change-set categories"	"ChangeSorter initializeChangeSetCategories"	| aCategory |	ChangeSetCategories := ElementCategory new categoryName: #ChangeSetCategories.	aCategory := ChangeSetCategory new categoryName: #All.	aCategory membershipSelector: #belongsInAll:.	aCategory documentation: 'All change sets known to the system'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #Additions.	aCategory membershipSelector: #belongsInAdditions:.	aCategory documentation: 'All unnumbered change sets except those representing projects in the system as initially released.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #MyInitials.	aCategory membershipSelector: #belongsInMyInitials:.	aCategory documentation: 'All change sets whose names end with the current author''s initials.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #Numbered.	aCategory membershipSelector: #belongsInNumbered:.	aCategory documentation: 'All change sets whose names start with a digit -- normally these will be the official updates to the system.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #ProjectChangeSets.	aCategory membershipSelector: #belongsInProjectChangeSets:.	aCategory documentation: 'All change sets that are currently associated with projects present in the system right now.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #ProjectsInRelease.	aCategory membershipSelector: #belongsInProjectsInRelease:.	aCategory documentation: 'All change sets belonging to projects that were shipped in the initial release of this version of Squeak'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #RecentUpdates.	aCategory membershipSelector: #belongsInRecentUpdates:.	aCategory documentation: 'Updates whose numbers are at or beyond the number I have designated as the earliest one to qualify as Recent'.	ChangeSetCategories addCategoryItem: aCategory.	ChangeSetCategories elementsInOrder do: [:anElem | anElem reconstituteList] ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!noteChangeSetsInRelease	"Freshly compute what the change sets in the release are; to be called manually just before a release"	ChangeSetNamesInRelease := (Project allProjects collect: [:p | p name]) asSet asOrderedCollection."ChangeSorter noteChangeSetsInRelease"! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!unload	"Unload the receiver from global registries"	self environment at: #FileList ifPresent: [:cl |	cl unregisterFileReader: self].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!deleteChangeSetsNumberedLowerThan: anInteger	"Delete all changes sets whose names start with integers smaller than anInteger"	self removeChangeSetsNamedSuchThat:		[:aName | aName first isDigit and: [aName initialIntegerOrNil < anInteger]].	"ChangesOrganizer deleteChangeSetsNumberedLowerThan: (ChangeSorter highestNumberedChangeSet name initialIntegerOrNil - 500)"! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!removeChangeSet: aChangeSet	"Remove the given changeSet.  Caller must assure that it's cool to do this"	^ChangeSet removeChangeSet: aChangeSet! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!removeChangeSetsNamedSuchThat: nameBlock	(self changeSetsNamedSuchThat: nameBlock)		do: [:cs | self removeChangeSet: cs]! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed,		and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| toGo |	(toGo := (self changeSetsNamedSuchThat: [:csName | csName beginsWith: 'Unnamed'])		select: [:cs | cs isEmpty and: [cs okayToRemoveInforming: false]])		do: [:cs | self removeChangeSet: cs].	self inform: toGo size printString, ' change set(s) removed.'! !!ChangesOrganizer class methodsFor: 'utilities' stamp: 'pk 2/6/2006 09:49'!fileOutChangeSetsNamed: nameList	"File out the list of change sets whose names are provided"     "ChangeSorter fileOutChangeSetsNamed: #('New Changes' 'miscTidies-sw')"	| notFound aChangeSet infoString empty |	notFound := OrderedCollection new.	empty := OrderedCollection new.	nameList do:		[:aName | (aChangeSet := self changeSetNamed: aName)			ifNotNil:				[aChangeSet isEmpty					ifTrue:						[empty add: aName]					ifFalse:						[aChangeSet fileOut]]			ifNil:				[notFound add: aName]].	infoString := (nameList size - notFound size) printString, ' change set(s) filed out'.	notFound size > 0 ifTrue:		[infoString := infoString, '', notFound size printString, ' change set(s) not found:'.		notFound do:			[:aName | infoString := infoString, '', aName]].	empty size > 0 ifTrue:		[infoString := infoString, '', empty size printString, ' change set(s) were empty:'.		empty do:			[:aName | infoString := infoString, '', aName]].	self inform: infoString! !!Character methodsFor: 'converting' stamp: 'yo 8/16/2004 11:35'!asLowercase	"If the receiver is uppercase, answer its matching lowercase Character."	"A tentative implementation.  Eventually this should consult the Unicode table."	| v |	v := self charCode.	(((8r101 <= v and: [v <= 8r132]) or: [16rC0 <= v and: [v <= 16rD6]]) or: [16rD8 <= v and: [v <= 16rDE]])		ifTrue: [^ Character value: value + 8r40]		ifFalse: [^ self]! !!Character methodsFor: 'converting' stamp: 'ar 4/9/2005 21:51'!asUnicode	| table charset v |	self leadingChar = 0 ifTrue: [^ value].	charset := EncodedCharSet charsetAt: self leadingChar.	charset isCharset ifFalse: [^ self charCode].	table := charset ucsTable.	table isNil ifTrue: [^ 16rFFFD].	v := table at: self charCode + 1.	v = -1 ifTrue: [^ 16rFFFD].	^ v.! !!Character methodsFor: 'converting' stamp: 'ar 4/9/2005 22:25'!asUnicodeChar	"@@@ FIXME: Make this use asUnicode and move it to its lonely sender @@@"	| table charset v |	self leadingChar = 0 ifTrue: [^ value].	charset := EncodedCharSet charsetAt: self leadingChar.	charset isCharset ifFalse: [^ self].	table := charset ucsTable.	table isNil ifTrue: [^ Character value: 16rFFFD].	v := table at: self charCode + 1.	v = -1 ifTrue: [^ Character value: 16rFFFD].	^ Character leadingChar: charset unicodeLeadingChar code: v.! !!Character methodsFor: 'converting' stamp: 'yo 8/16/2004 11:34'!asUppercase	"If the receiver is lowercase, answer its matching uppercase Character."	"A tentative implementation.  Eventually this should consult the Unicode table."		| v |	v := self charCode.	(((8r141 <= v and: [v <= 8r172]) or: [16rE0 <= v and: [v <= 16rF6]]) or: [16rF8 <= v and: [v <= 16rFE]])		ifTrue: [^ Character value: value - 8r40]		ifFalse: [^ self]! !!Character methodsFor: 'converting' stamp: 'yo 8/11/2003 21:18'!basicSqueakToIso	| asciiValue |	value < 128 ifTrue: [^ self].	value > 255 ifTrue: [^ self].	asciiValue := #(196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232 234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252 134 176 162 163 167 149 182 223 174 169 153 180 168 128 198 216 129 177 138 141 165 181 142 143 144 154 157 170 186 158 230 248 191 161 172 166 131 173 178 171 187 133 160 192 195 213 140 156 150 151 147 148 145 146 247 179 253 159 185 164 139 155 188 189 135 183 130 132 137 194 202 193 203 200 205 206 207 204 211 212 190 210 218 219 217 208 136 152 175 215 221 222 184 240 254 255 256 ) at: self asciiValue - 127.	^ Character value: asciiValue.! !!Character methodsFor: 'converting' stamp: 'ar 4/10/2005 16:05'!macToSqueak	"Convert the receiver from MacRoman to Squeak encoding"	| asciiValue |	value < 128 ifTrue: [^ self].	value > 255 ifTrue: [^ self].	asciiValue := #(196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232 234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252 134 176 162 163 167 149 182 223 174 169 153 180 168 128 198 216 129 177 138 141 165 181 142 143 144 154 157 170 186 158 230 248 191 161 172 166 131 173 178 171 187 133 160 192 195 213 140 156 150 151 147 148 145 146 247 179 255 159 185 164 139 155 188 189 135 183 130 132 137 194 202 193 203 200 205 206 207 204 211 212 190 210 218 219 217 208 136 152 175 215 221 222 184 240 253 254 ) at: self asciiValue - 127.	^ Character value: asciiValue.! !!Character methodsFor: 'printing' stamp: 'lr 1/3/2007 19:30'!storeOn: aStream	"Common character literals are preceded by '$', however special need to be encoded differently: for some this might be done by using one of the shortcut constructor methods for the rest we have to create them by ascii-value."	| name |	(value between: 33 and: 255)		ifTrue: [ aStream nextPut: $$; nextPut: self ]		ifFalse: [			name := self class constantNameFor: self.			name notNil				ifTrue: [ aStream nextPutAll: self class name; space; nextPutAll: name ]				ifFalse: [					aStream 						nextPut: $(; nextPutAll: self class name; 						nextPutAll: ' value: '; print: value; nextPut: $) ] ].! !!Character methodsFor: 'private' stamp: 'ar 4/9/2005 22:18'!setValue: newValue	value ifNotNil:[^self error:'Characters are immutable'].	value := newValue.! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'wiz 4/9/2006 20:30'!nbsp	"non-breakable space. Latin1 encoding common usage."	^ Character value: 160! !!Character class methodsFor: 'instance creation'!digitValue: x 	"Answer the Character whose digit value is x. For example, answer $9 for 	x=9, $0 for x=0, $A for x=10, $Z for x=35."	| index |	index := x asInteger.	^CharacterTable at: 		(index < 10			ifTrue: [48 + index]			ifFalse: [55 + index])		+ 1! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:20'!add: aCharacter	"I automatically become a WideCharacterSet if you add a wide character to myself"		aCharacter asciiValue >= 256		ifTrue: [| wide |			wide := WideCharacterSet new.			wide addAll: self.			wide add: aCharacter.			self become: wide.			^aCharacter].	map at: aCharacter asciiValue + 1 put: 1.	^aCharacter! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:09'!includes: aCharacter	aCharacter asciiValue >= 256		ifTrue: ["Guard against wide characters"			^false].	^(map at: aCharacter asciiValue + 1) > 0! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:20'!remove: aCharacter	aCharacter asciiValue >= 256		ifFalse: ["Guard against wide characters"			map at: aCharacter asciiValue + 1 put: 0].	^aCharacter! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:02'!size	^map sum! !!CharacterSet methodsFor: 'conversion' stamp: 'nice 3/23/2007 02:28'!byteComplement	"return a character set containing precisely the single byte characters the receiver does not"		| set |	set _ CharacterSet allCharacters.	self do: [ :c | set remove: c ].	^set! !!CharacterSet methodsFor: 'conversion' stamp: 'nice 3/23/2007 02:29'!complement	"return a character set containing precisely the characters the receiver does not"		^CharacterSetComplement of: self! !!CharacterSet methodsFor: 'private' stamp: 'ls 8/17/1998 20:30'!initialize	map := ByteArray new: 256 withAll: 0.! !!CharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 23:22'!wideCharacterMap	"used for comparing with WideCharacterSet"		| wide |	wide := WideCharacterSet new.	wide addAll: self.	^wide wideCharacterMap! !!CharacterSet methodsFor: 'testing' stamp: 'nice 5/9/2006 23:23'!hasWideCharacters	^false! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:42'!allCharacters	"return a set containing all characters"	| set |	set := self empty.	0 to: 255 do: [ :ascii | set add: (Character value: ascii) ].	^set! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 1/3/1999 12:52'!newFrom: aCollection	| newCollection |	newCollection := self new.	newCollection addAll: aCollection.	^newCollection! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/18/1998 00:40'!separators	"return a set containing just the whitespace characters"	| set |	set := self empty.	set addAll: Character separators.	^set! !!CharacterSetComplement methodsFor: 'comparing' stamp: 'nice 3/23/2007 02:19'!= anObject	"Implementation note: we do not test if equal to a WideCharacterSet,	because it is unlikely that WideCharacterSet is as complete as self"		^self class == anObject class and: [		absent = anObject complement ]! !!CharacterSetComplement methodsFor: 'comparing' stamp: 'nice 3/23/2007 02:16'!hash	^absent hash bitXOr: self class hash! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:06'!add: aCharacter	"a character is present if not absent"		(absent includes: aCharacter) ifTrue: [absent remove: aCharacter].	^aCharacter! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:11'!do: aBlock	"evaluate aBlock with each character in the set.	don't do it, there are too many..."	self shouldNotImplement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:07'!includes: aCharacter	^(absent includes: aCharacter) not! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:15'!reject: aBlock	"Implementation note: rejecting present is selecting absent"		^(absent select: aBlock) complement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:06'!remove: aCharacter	"This means a character is absent from myself"		^absent add: aCharacter! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:15'!select: aBlock	"Implementation note: selecting present is rejecting absent"		^(absent reject: aBlock) complement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:10'!size	"Is this 2**32-absent size ?"		^self shouldNotImplement! !!CharacterSetComplement methodsFor: 'private' stamp: 'nice 3/23/2007 02:21'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"	^absent byteArrayMap collect: [:i | 1 - i]! !!CharacterSetComplement methodsFor: 'converting' stamp: 'nice 3/23/2007 02:08'!complement	"return a character set containing precisely the characters the receiver does not"		^absent copy! !!CharacterSetComplement methodsFor: 'initialize-release' stamp: 'nice 3/23/2007 02:25'!complement: aCharacterSet	"initialize with the complement"		absent := aCharacterSet! !!CharacterSetComplement methodsFor: 'testing' stamp: 'nice 3/23/2007 02:12'!hasWideCharacters	"This is a guess that absent is not holding each and every possible wideCharacter..."		^true! !!CharacterSetComplement commentStamp: 'nice 3/23/2007 02:27' prior: 0!CharacterSetComplement is a space efficient implementation of (CharacterSet complement) taking care of WideCharacter (code > 255)instance variables:	absent <CharacterSet> contains character that are not in the set (i.e. my complement)!!CharacterSetComplement class methodsFor: 'instance creation' stamp: 'nice 3/23/2007 02:25'!of: aCharacterSet	"answer the complement of aCharacterSet"		^ super new complement: aCharacterSet! !!Circle class methodsFor: 'examples'!exampleOne 	"Click any button somewhere on the screen. The point will be the center	of the circcle of radius 150."	| aCircle aForm |	aForm := Form extent: 1@30.	aForm fillBlack.	aCircle := Circle new.	aCircle form: aForm.	aCircle radius: 150.	aCircle center: Sensor waitButton.	aCircle displayOn: Display		"Circle exampleOne"! !!Circle class methodsFor: 'examples'!exampleTwo	"Designate a rectangular area that should be used as the brush for	displaying the circle. Click any button at a point on the screen which	will be the center location for the circle. The curve will be displayed	with a long black form."	| aCircle aForm |	aForm := Form fromUser.	aCircle := Circle new.	aCircle form: aForm.	aCircle radius: 150.	aCircle center: Sensor waitButton.	aCircle displayOn: Display at: 0 @ 0 rule: Form reverse 	 "Circle exampleTwo"! !!CircleMorph methodsFor: 'parts bin' stamp: 'wiz 1/5/2007 16:23'!initialize	^super initialize		extent: 40@40;		color: Color green lighter;		yourself! !!CircleMorphBugs methodsFor: 'as yet unclassified' stamp: 'wiz 4/18/2007 00:57'!testCircleInstance"""self run: #testCircleInstance" | circ |self assert: (circ := CircleMorph initializedInstance) extent = circ extent x asPoint! !!Class methodsFor: 'class name' stamp: 'rw 10/7/2006 08:30'!rename: aString 	"The new name of the receiver is the argument, aString."	| oldName newName |	(newName _ aString asSymbol) = (oldName _ self name)		ifTrue: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	name _ newName.	self environment renameClass: self from: oldName! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'cmm 8/7/2005 18:20'!setUp	previousChangeSet := ChangeSet current.	testsChangeSet := ChangeSet new.	ChangeSet newChanges: testsChangeSet.	SystemChangeNotifier uniqueInstance		notify: self		ofSystemChangesOfItem: #class		change: #Renamed		using: #verifyRenameEvent:.	super setUp! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'pk 5/13/2007 14:16'!tearDown	self removeEverythingInSetFromSystem: testsChangeSet.	ChangeSet newChanges: previousChangeSet.	ChangesOrganizer removeChangeSet: testsChangeSet.	previousChangeSet := nil.	testsChangeSet := nil.	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self.	super tearDown.! !!ClassRenameFixTest methodsFor: 'Tests' stamp: 'cmm 8/7/2005 18:21'!renameClassUsing: aBlock	| createdClass foundClasses |	originalName := self newUniqueClassName.	createdClass := Object 		subclass: originalName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'ClassRenameFix-GeneradClass'.	newClassName := self newUniqueClassName.	aBlock value: createdClass value: newClassName.	self assert: (Smalltalk classNamed: originalName) isNil.	self assert: (Smalltalk classNamed: newClassName) notNil.	foundClasses := Smalltalk organization listAtCategoryNamed: 'ClassRenameFix-GeneradClass'.	self assert: (foundClasses notEmpty).	self assert: (foundClasses includes: newClassName).	self assert: (createdClass name = newClassName).! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57'!deleteClass	| cl |	cl := Smalltalk at: className ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57'!deleteRenamedClass	| cl |	cl := Smalltalk at: renamedName ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:05'!setUp	className := #TUTU.	renamedName := #RenamedTUTU.	self deleteClass.	self deleteRenamedClass.	Object subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'KernelTests-Classes'! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:08'!tearDown	self deleteClass.	self deleteRenamedClass! !!ClassTest methodsFor: 'testing' stamp: 'rw 10/17/2006 22:13'!testRenaming	"self debug: #testRenaming"	"self run: #testRenaming"		| oldName newMetaclassName class |	oldName := className.	newMetaclassName := (renamedName, #' class') asSymbol.	class := Smalltalk at: oldName.	class class compile: 'dummyMeth'.	class rename: renamedName.	self assert: class name = renamedName.	self assert: (ChangeSet current changedClassNames includes: renamedName). 	self assert: (ChangeSet current changedClassNames includes: newMetaclassName).	! !!Clipboard methodsFor: 'accessing' stamp: 'yo 8/11/2003 19:07'!clearInterpreter	interpreter := nil.! !!Clipboard methodsFor: 'accessing' stamp: 'edc 5/8/2007 17:04'!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."	| string decodedString |	string := self primitiveClipboardText withSqueakLineEndings.	(string isEmpty			or: [string = contents asString])		ifTrue: [^ contents].	decodedString := self interpreter fromSystemClipboard: string.	^ decodedString = contents asString 		ifTrue: [contents]		ifFalse: [decodedString asText].! !!Clipboard methodsFor: 'accessing' stamp: 'yo 8/11/2003 19:12'!clipboardText: text 	| string |	string := text asString.	self noteRecentClipping: text asText.	contents := text asText.	string := self interpreter toSystemClipboard: string.	self primitiveClipboardText: string.! !!Clipboard methodsFor: 'accessing' stamp: 'mir 7/20/2004 15:44'!setInterpreter	interpreter := LanguageEnvironment defaultClipboardInterpreter.	interpreter ifNil: [		"Should never be reached, but just in case."		interpreter := NoConversionClipboardInterpreter new].! !!Clipboard methodsFor: 'initialize' stamp: 'ar 1/15/2001 18:34'!initialize	contents := '' asText.	recent := OrderedCollection new.! !!Clipboard class methodsFor: 'accessing' stamp: 'ar 1/15/2001 18:33'!default	^Default ifNil:[Default := self new].! !!Clipboard class methodsFor: 'accessing' stamp: 'ar 1/15/2001 18:48'!default: aClipboard	"So that clients can switch between different default clipboards"	Default := aClipboard.! !!CodeHolder methodsFor: 'annotation' stamp: 'pk 10/17/2006 09:38'!annotationForSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing  	information about the given selector and class"	| stamp sendersCount implementorsCount aCategory separator aString aList aComment aStream requestList |	aSelector == #Comment		ifTrue: [^ self annotationForClassCommentFor: aClass].	aSelector == #Definition		ifTrue: [^ self annotationForClassDefinitionFor: aClass].	aSelector == #Hierarchy		ifTrue: [^ self annotationForHierarchyFor: aClass].	aStream := ReadWriteStream on: ''.	requestList := self annotationRequests.	separator := requestList size > 1				ifTrue: [self annotationSeparator]				ifFalse: [''].	requestList		do: [:aRequest | 			aRequest == #firstComment				ifTrue: [aComment := aClass firstCommentAt: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #masterComment				ifTrue: [aComment := aClass supermostPrecodeCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #documentation				ifTrue: [aComment := aClass precodeCommentOrInheritedCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #timeStamp				ifTrue: [stamp := self timeStamp.					aStream						nextPutAll: (stamp size > 0								ifTrue: [stamp , separator]								ifFalse: ['no timeStamp' , separator])].			aRequest == #messageCategory				ifTrue: [aCategory := aClass organization categoryOfElement: aSelector.					aCategory						ifNotNil: ["woud be nil for a method no longer present,  							e.g. in a recent-submissions browser"							aStream nextPutAll: aCategory , separator]].			aRequest == #sendersCount				ifTrue: [sendersCount := (self systemNavigation allCallsOn: aSelector) size.					sendersCount := sendersCount == 1								ifTrue: ['1 sender']								ifFalse: [sendersCount printString , ' senders'].					aStream nextPutAll: sendersCount , separator].			aRequest == #implementorsCount				ifTrue: [implementorsCount := self systemNavigation numberOfImplementorsOf: aSelector.					implementorsCount := implementorsCount == 1								ifTrue: ['1 implementor']								ifFalse: [implementorsCount printString , ' implementors'].					aStream nextPutAll: implementorsCount , separator].			aRequest == #priorVersionsCount				ifTrue: [self						addPriorVersionsCountForSelector: aSelector						ofClass: aClass						to: aStream].			aRequest == #priorTimeStamp				ifTrue: [stamp := VersionsBrowser								timeStampFor: aSelector								class: aClass								reverseOrdinal: 2.					stamp						ifNotNil: [aStream nextPutAll: 'prior time stamp: ' , stamp , separator]].			aRequest == #recentChangeSet				ifTrue: [aString := ChangesOrganizer mostRecentChangeSetWithChangeForClass: aClass selector: aSelector.					aString size > 0						ifTrue: [aStream nextPutAll: aString , separator]].			aRequest == #allChangeSets				ifTrue: [aList := ChangesOrganizer allChangeSetsWithClass: aClass selector: aSelector.					aList size > 0						ifTrue: [aList size = 1								ifTrue: [aStream nextPutAll: 'only in change set ']								ifFalse: [aStream nextPutAll: 'in change sets: '].							aList								do: [:aChangeSet | aStream nextPutAll: aChangeSet name , ' ']]						ifFalse: [aStream nextPutAll: 'in no change set'].					aStream nextPutAll: separator]].	^ aStream contents! !!CodeHolder methodsFor: 'controls' stamp: 'dtl 1/28/2007 09:17'!contentsSymbolQuints	"Answer a list of quintuplets representing information on the alternative views available in the code pane		first element:	the contentsSymbol used		second element:	the selector to call when this item is chosen.		third element:	the selector to call to obtain the wording of the menu item.		fourth element:	the wording to represent this view		fifth element:	balloon help	A hypen indicates a need for a seperator line in a menu of such choices"	^ #((source			togglePlainSource 			showingPlainSourceString	'source'		'the textual source code as written')(documentation	toggleShowDocumentation	showingDocumentationString	'documentation'		'the first comment in the method')-(prettyPrint		togglePrettyPrint 			prettyPrintString			'prettyPrint'			'the method source presented in a standard text format')(colorPrint		toggleColorPrint				colorPrintString				'colorPrint'			'the method source in a standard text format with colors to distinguish structural parts') -(showDiffs		toggleRegularDiffing		showingRegularDiffsString	'showDiffs'				'the textual source diffed from its prior version')(prettyDiffs		togglePrettyDiffing			showingPrettyDiffsString	'prettyDiffs'		'formatted textual source diffed from formatted form of prior version')-(decompile		toggleDecompile				showingDecompileString		'decompile'			'source code decompiled from byteCodes')(byteCodes		toggleShowingByteCodes		showingByteCodesString		'byteCodes'			'the bytecodes that comprise the compiled method')-(tiles			toggleShowingTiles 			showingTilesString			'tiles'				'universal tiles representing the method'))! !!CodeHolder methodsFor: '*eToys-tiles' stamp: 'nk 4/28/2004 10:14'!installTilesForSelection	"Install universal tiles into the code pane."	| source aSelector aClass tree syn tileScriptor aWindow codePane |	(aWindow := self containingWindow)		ifNil: [self error: 'hamna dirisha'].	tileScriptor := ((aSelector := self selectedMessageName) isNil					or: [(aClass := self selectedClassOrMetaClass whichClassIncludesSelector: aSelector) isNil])				ifTrue: [PluggableTileScriptorMorph new]				ifFalse: [source := aClass sourceCodeAt: aSelector.					tree := Compiler new								parse: source								in: aClass								notifying: nil.					(syn := tree asMorphicSyntaxUsing: SyntaxMorph) parsedInClass: aClass.					syn inAPluggableScrollPane].	codePane := aWindow				findDeepSubmorphThat: [:m | (m isKindOf: PluggableTextMorph)						and: [m getTextSelector == #contents]]				ifAbsent: [].	codePane		ifNotNil: [codePane hideScrollBars].	codePane		ifNil: [codePane := aWindow						findDeepSubmorphThat: [:m | m isKindOf: PluggableTileScriptorMorph]						ifAbsent: [self error: 'no code pane']].	tileScriptor color: aWindow paneColorToUse;		 setProperty: #hideUnneededScrollbars toValue: true.	aWindow replacePane: codePane with: tileScriptor.	currentCompiledMethod := aClass				ifNotNil: [aClass compiledMethodAt: aSelector].	tileScriptor owner clipSubmorphs: true.	tileScriptor extent: codePane extent! !!CodeHolder methodsFor: '*eToys-tiles' stamp: 'rhi 1/4/2002 11:15'!showTiles: aBoolean	"Set the showingTiles as indicated.  The fact that there are initially no senders of this reflects that fact that initially this trait is only directly settable through the UI; later there may be senders, such as if one wanted to set a system up so that all newly-opened browsers showed tiles rather than text."	aBoolean		ifTrue:			[contentsSymbol := #tiles]		ifFalse:			[contentsSymbol == #tiles ifTrue: [contentsSymbol := #source]].	self setContentsToForceRefetch.	self changed: #contents! !!CodeHolder methodsFor: '*eToys-tiles' stamp: 'sw 2/14/2001 15:27'!toggleShowingTiles	"Toggle whether tiles should be shown in the code pane"	self okToChange ifTrue:		[self showingTiles			ifTrue:				[contentsSymbol := #source.				self setContentsToForceRefetch.				self installTextualCodingPane.				self contentsChanged]			ifFalse:				[contentsSymbol := #tiles.				self installTilesForSelection.				self changed: #tiles]]! !!Collection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:34'!size	"Answer how many elements the receiver contains."	| tally |	tally := 0.	self do: [:each | tally := tally + 1].	^ tally! !!Collection methodsFor: 'comparing' stamp: 'SqR 8/3/2000 13:36'!hash	"Answer an integer hash value for the receiver such that,	  -- the hash value of an unchanged object is constant over time, and	  -- two equal objects have equal hash values"	| hash |	hash := self species hash.	self size <= 10 ifTrue:		[self do: [:elem | hash := hash bitXor: elem hash]].	^hash bitXor: self size hash! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:22'!asArray	"Answer an Array whose elements are the elements of the receiver.	Implementation note: Cannot use ''Array withAll: self'' as that only	works for SequenceableCollections which support the replacement 	primitive."	| array index |	array := Array new: self size.	index := 0.	self do: [:each | array at: (index := index + 1) put: each].	^ array! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:22'!asByteArray	"Answer a ByteArray whose elements are the elements of the receiver.	Implementation note: Cannot use ''ByteArray withAll: self'' as that only	works for SequenceableCollections which support the replacement 	primitive."	| array index |	array := ByteArray new: self size.	index := 0.	self do: [:each | array at: (index := index + 1) put: each].	^ array! !!Collection methodsFor: 'converting' stamp: 'LC 6/18/2001 18:46'!asSkipList: aSortBlock 	"Answer a SkipList whose elements are the elements of the 	receiver. The sort order is defined by the argument, aSortBlock."	| skipList |	skipList := SortedCollection new: self size.	skipList sortBlock: aSortBlock.	skipList addAll: self.	^ skipList! !!Collection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:46'!asSortedCollection: aSortBlock 	"Answer a SortedCollection whose elements are the elements of the 	receiver. The sort order is defined by the argument, aSortBlock."	| aSortedCollection |	aSortedCollection := SortedCollection new: self size.	aSortedCollection sortBlock: aSortBlock.	aSortedCollection addAll: self.	^ aSortedCollection! !!Collection methodsFor: 'converting' stamp: 'hg 12/26/2001 23:53'!topologicallySortedUsing: aSortBlock 	"Answer a SortedCollection whose elements are the elements of the 	receiver, but topologically sorted. The topological order is defined 	by the argument, aSortBlock."	| aSortedCollection |	aSortedCollection := SortedCollection new: self size.	aSortedCollection sortBlock: aSortBlock.	self do: [:each | aSortedCollection addLast: each].	"avoids sorting"	^ aSortedCollection sortTopologically! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:45'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection := self species new.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:52'!count: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the number of elements that answered true."	| sum |	sum := 0.	self do: [:each | (aBlock value: each) ifTrue: [sum := sum + 1]].	^ sum! !!Collection methodsFor: 'enumerating'!detectMax: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the highest magnitude.	If collection empty, return nil.  This method might also be called elect:."	| maxElement maxValue val |	self do: [:each | 		maxValue == nil			ifFalse: [				(val := aBlock value: each) > maxValue ifTrue: [					maxElement := each.					maxValue := val]]			ifTrue: ["first element"				maxElement := each.				maxValue := aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ maxElement! !!Collection methodsFor: 'enumerating'!detectMin: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the lowest number.	If collection empty, return nil."	| minElement minValue val |	self do: [:each | 		minValue == nil			ifFalse: [				(val := aBlock value: each) < minValue ifTrue: [					minElement := each.					minValue := val]]			ifTrue: ["first element"				minElement := each.				minValue := aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ minElement! !!Collection methodsFor: 'enumerating'!detectSum: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Return the sum of the answers."	| sum |	sum := 0.	self do: [:each | 		sum := (aBlock value: each) + sum].  	^ sum! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:57'!do: elementBlock separatedBy: separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between."	| beforeFirst | 	beforeFirst := true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [separatorBlock value].		elementBlock value: each]! !!Collection methodsFor: 'enumerating' stamp: 'dvf 6/10/2000 18:32'!groupBy: keyBlock having: selectBlock 	"Like in SQL operation - Split the recievers contents into collections of 	elements for which keyBlock returns the same results, and return those 	collections allowed by selectBlock. keyBlock should return an Integer."	| result key |	result := PluggableDictionary integerDictionary.	self do: 		[:e | 		key := keyBlock value: e.		(result includesKey: key)			ifFalse: [result at: key put: OrderedCollection new].		(result at: key)			add: e].	^ result := result select: selectBlock! !!Collection methodsFor: 'enumerating'!inject: thisValue into: binaryBlock 	"Accumulate a running value associated with evaluating the argument, 	binaryBlock, with the current value of the argument, thisValue, and the 	receiver as block arguments. For instance, to sum the numeric elements 	of a collection, aCollection inject: 0 into: [:subTotal :next | subTotal + 	next]."	| nextValue |	nextValue := thisValue.	self do: [:each | nextValue := binaryBlock value: nextValue value: each].	^nextValue! !!Collection methodsFor: 'enumerating'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for 	which aBlock evaluates to true. Answer the new collection."	| newCollection |	newCollection := self species new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:02'!sum	"This is implemented using a variant of the normal inject:into: pattern. 	The reason for this is that it is not known whether we're in the normal 	number line, i.e. whether 0 is a good initial value for the sum. 	Consider a collection of measurement objects, 0 would be the unitless 	value and would not be appropriate to add with the unit-ed objects."	| sum sample |	sample := self anyOne.	sum := self inject: sample into: [:accum :each | accum + each].	^ sum - sample! !!Collection methodsFor: 'printing' stamp: 'gk 1/14/2005 08:27'!asStringOn: aStream delimiter: delimString last: lastDelimString	"Print elements on a stream separated	with a delimiter between all the elements and with	a special one before the last like: 'a, b and c'.	Uses #asString instead of #print:	Note: Feel free to improve the code to detect the last element."	| n sz |	n := 1.	sz := self size.	self do: [:elem |		n := n + 1.		aStream nextPutAll: elem asString]	separatedBy: [		aStream nextPutAll: (n = sz ifTrue: [lastDelimString] ifFalse: [delimString])]! !!Collection methodsFor: 'printing' stamp: 'fbs 1/14/2005 10:54'!printOn: aStream delimiter: delimString last: lastDelimString	"Print elements on a stream separated	with a delimiter between all the elements and with	a special one before the last like: 'a, b and c'	Note: Feel free to improve the code to detect the last element."	| n sz |	n := 1.	sz := self size.	self do: [:elem |		n := n + 1.		aStream print: elem]	separatedBy: [		n = sz			ifTrue: [aStream print: lastDelimString]			ifFalse: [aStream print: delimString]]! !!Collection methodsFor: 'printing'!storeOn: aStream 	"Refer to the comment in Object|storeOn:."	| noneYet |	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' new)'.	noneYet := true.	self do: 		[:each | 		noneYet			ifTrue: [noneYet := false]			ifFalse: [aStream nextPut: $;].		aStream nextPutAll: ' add: '.		aStream store: each].	noneYet ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!Collection methodsFor: 'testing'!occurrencesOf: anObject 	"Answer how many of the receiver's elements are equal to anObject."	| tally |	tally := 0.	self do: [:each | anObject = each ifTrue: [tally := tally + 1]].	^tally! !!Collection methodsFor: 'private'!toBraceStack: itsSize 	"Push receiver's elements onto the stack of thisContext sender.  Error if receiver does	 not have itsSize elements or if receiver is unordered.	 Do not call directly: this is called by {a. b} := ... constructs."	self size ~= itsSize ifTrue:		[self error: 'Trying to store ', self size printString,					' values into ', itsSize printString, ' variables.'].	thisContext sender push: itsSize fromIndexable: self! !!Collection class methodsFor: 'private' stamp: 'lr 11/4/2003 12:07'!initialize	"Set up a Random number generator to be used by atRandom when the 	user does not feel like creating his own Random generator."	RandomForPicking := Random new.	MutexForPicking := Semaphore forMutualExclusion! !!CollectionTest methodsFor: 'testing' stamp: 'wbk 7/26/2007 12:41'!testPrintingArrayWithMetaclass	self assert: {Array class} printString = '{Array class}'! !!Color methodsFor: 'html' stamp: 'hmm 11/1/2006 23:28'!printHtmlString	"answer a string whose characters are the html representation  	of the receiver"	^ ((self red * 255) asInteger printStringBase: 16 length: 2 padded: true)	, ((self green * 255) asInteger printStringBase: 16 length: 2 padded: true)	, ((self blue * 255) asInteger printStringBase: 16 length: 2 padded: true)! !!ColorSeerTile methodsFor: 'initialization' stamp: 'mir 7/12/2004 20:23'!initialize"initialize the state of the receiver"	| m1 m2 desiredW wording |	super initialize.""	self removeAllMorphs.	"get rid of the parts of a regular Color tile"	type := #operator.	operatorOrExpression := #color:sees:.	wording := (Vocabulary eToyVocabulary				methodInterfaceAt: operatorOrExpression				ifAbsent: []) wording.	m1 := StringMorph contents: wording font: ScriptingSystem fontForTiles.	m2 := Morph new extent: 12 @ 8;								color: (Color						r: 0.8						g: 0						b: 0).	desiredW := m1 width + 6.	self extent: (desiredW max: self basicWidth)			@ self class defaultH.	m1 position: bounds center x - (m1 width // 2) @ (bounds top + 5).	m2 position: bounds center x - (m2 width // 2) + 3 @ (bounds top + 8).	self addMorph: m1;		 addMorphFront: m2.	colorSwatch := m2! !!ColorSeerTile methodsFor: 'initialization' stamp: 'mir 7/15/2004 15:20'!updateWordingToMatchVocabulary	"The current vocabulary has changed; change the wording on my face, if appropriate"	| aMethodInterface |	aMethodInterface := self currentVocabulary methodInterfaceAt: operatorOrExpression ifAbsent: [Vocabulary eToyVocabulary methodInterfaceAt: operatorOrExpression ifAbsent: [^ self]].	self labelMorph contents: aMethodInterface wording.	self setBalloonText: aMethodInterface helpMessage.! !!ColorSwatch methodsFor: 'as yet unclassified' stamp: 'sw 7/13/1999 13:39'!argument: arg	argument := arg! !!ColorSwatch methodsFor: 'setting' stamp: 'sw 3/23/2001 12:12'!setTargetColor: aColor	"Set the target color as indicated"	putSelector ifNotNil:		[self color: aColor.		contents := aColor.		target perform: self putSelector withArguments: (Array with: argument with: aColor)]! !!ColorTileMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:44'!initialize"initialize the state of the receiver"	super initialize.""	type := #literal.	self addColorSwatch! !!ColorTileMorph methodsFor: 'initialization' stamp: 'yo 7/2/2004 17:33'!updateWordingToMatchVocabulary	| stringMorph |	stringMorph := submorphs detect: [:morph | morph class == StringMorph] ifNone: [^ self].	stringMorph contents: 'color' translated.! !!ColorTileMorph methodsFor: 'other' stamp: 'yo 7/2/2004 17:33'!addColorSwatch	| m1 m2 desiredW |	m1 := StringMorph contents: 'color' translated font: ScriptingSystem fontForTiles.	m2 := Morph new extent: 12@8; color: (Color r: 0.8 g: 0 b: 0).	desiredW := m1 width + 6.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	m2 position: (bounds center x - (m2 width // 2)) @ (m1 bottom - 1).	self addMorph: m1; addMorph: m2.	colorSwatch := m2! !!CompiledMethod methodsFor: 'literals' stamp: 'ms 5/10/2007 11:21'!hasLiteralThorough: aLiteral from: aBlock	"Answer true if any literal in this method is literal, even if embedded in array structure or within its pragmas."	| literal |	self pragmas do: [ :pragma |		(pragma hasLiteral: aLiteral) ifTrue: [ ^ true ] ].	2 to: self numLiterals + 1 do: [ :index | 		literal := self objectAt: index.		literal == aLiteral  ifTrue: [ ^ true ].		literal == aBlock ifFalse:[ (literal hasLiteralThorough: aLiteral) ifTrue: [ ^ true ]] ].	^ false.! !!Compiler methodsFor: 'error handling' stamp: 'stephaneducassse 11/5/2005 16:39'!interactive	"this version of the method is necessary to load code from MC else the interactive mode is one. 	This method is really bad since it links the compiler package with the Tools	one. The solution would be to have a real SyntaxError exception belonging to the 	compiler package and not a subclass of StringHolder - sd Nov 2005"	"the code submitted by PlusTools is ideally the one that should be used	interactive	      ^requestor ~~ nil "		^ (requestor == nil or: [requestor isKindOf: SyntaxError]) not! !!Compiler methodsFor: 'public access' stamp: 'ab 3/23/2005 16:47'!compiledMethodFor: aString in: aContext to: aReceiver	"evaluate aString in the given context, and return the result.  2/2/96 sw"	| result |	result _ self				compiledMethodFor: aString 				in: aContext 				to: aReceiver 				notifying: nil				ifFail: [^#Failed] 				logged: false.	^ result! !!Compiler methodsFor: 'public access' stamp: 'ab 3/23/2005 16:48'!compiledMethodFor: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."	| methodNode method |	class _ (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode _ self translate: sourceStream noPattern: true ifFail:		[^failBlock value].	method _ methodNode generate: #(0 0 0 0).	self interactive ifTrue:		[method _ method copyWithTempNames: methodNode tempNames].		logFlag ifTrue: [SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext].	^ method.! !!Compiler methodsFor: 'public access' stamp: 'md 10/16/2006 09:53'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	| methodNode method value toLog itsSelectionString itsSelection |	class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	method selector ifNil: [method selector: #DoIt].	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ])		executeMethod: method.	logFlag ifTrue:		[toLog := ((requestor respondsTo: #selection)  and:			[(itsSelection := requestor selection) notNil] and:			[(itsSelectionString := itsSelection asString) isEmptyOrNil not] )			ifTrue: 				[itsSelectionString]			ifFalse:				[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext ].	^ value.! !!Complex methodsFor: 'comparing' stamp: 'hmm 11/1/2006 23:29'!= anObject	anObject isNumber ifFalse: [^false].	anObject isComplex		ifTrue: [^ (real = anObject real) & (imaginary = anObject imaginary)]		ifFalse: [^ anObject adaptToComplex: self andSend: #=]! !!Complex methodsFor: 'testing' stamp: 'hmm 11/1/2006 23:34'!isNumber	^ true! !!CompoundTileMorph methodsFor: 'code generation' stamp: 'jm 5/29/1998 10:26'!storeCodeBlockFor: scriptPart on: aStream indent: tabCount	| rows r |	rows := scriptPart tileRows.	1 to: rows size do: [:i |		tabCount timesRepeat: [aStream tab].		r := rows at: i.		r do: [:t | t storeCodeOn: aStream indent: tabCount].		i < rows size ifTrue: [aStream nextPut: $.; cr]].! !!CompoundTileMorph methodsFor: 'event handling' stamp: 'tk 2/28/2001 21:25'!mouseDown: evt 	"Pretend we picked up the tile and then put it down for a trial  	positioning."	"The essence of ScriptEditor mouseEnter:"	| ed ss guyToTake |"	self isPartsDonor ifTrue:[		dup := self duplicate.		evt hand attachMorph: dup.		dup position: evt position.		^self].	submorphs isEmpty 			never true		ifTrue: [^ self]."	(ed := self enclosingEditor) ifNil: [^evt hand grabMorph: self].	guyToTake := self.	owner class == TilePadMorph		ifTrue: ["picking me out of another phrase"			(ss := submorphs first) class == TilePadMorph				ifTrue: [ss := ss submorphs first].			guyToTake :=  ss veryDeepCopy].	evt hand grabMorph: guyToTake.	ed startStepping.	ed mouseEnterDragging: evt.	ed setProperty: #justPickedUpPhrase toValue: true.! !!CompoundTileMorph methodsFor: 'event handling' stamp: 'jm 10/18/97 21:03'!mouseEnter: evt	"Resume drop-tracking in enclosing editor"	| ed |	(ed := self enclosingEditor) ifNotNil:		[ed mouseLeave: evt]! !!CompoundTileMorph methodsFor: 'event handling' stamp: 'jm 10/18/97 21:02'!mouseLeave: evt	"Resume drop-tracking in enclosing editor"	| ed |	(ed := self enclosingEditor) ifNotNil:		[ed mouseEnter: evt]! !!CompoundTileMorph methodsFor: 'initialization' stamp: 'sw 7/22/2004 00:13'!initialize	"initialize the state of the receiver"	| r stringMorph |	super initialize.	self layoutInset: 2.	self listDirection: #topToBottom.	self hResizing: #shrinkWrap; vResizing: #shrinkWrap; cellInset: (0 @ 1); minCellSize: (200@14).	"NB: hResizing gets reset to #spaceFill below, after the standalone structure is created"	r := AlignmentMorph newRow color: color;				 layoutInset: 0.	r setProperty: #demandsBoolean toValue: true.	r addMorphBack: (Morph new color: color;			 extent: 2 @ 5).	"spacer"	stringMorph := StringMorph new contents: 'Test' translated.	stringMorph name: 'Test'.	r addMorphBack: stringMorph.	r addMorphBack: (Morph new color: color;			 extent: 5 @ 5).	"spacer"	r addMorphBack: (testPart := BooleanScriptEditor new borderWidth: 0;					 layoutInset: 1).	testPart color: Color transparent.	testPart hResizing: #spaceFill.	self addMorphBack: r.	r := AlignmentMorph newRow color: color;				 layoutInset: 0.	r addMorphBack: (Morph new color: color;			 extent: 30 @ 5).	"spacer"	stringMorph := StringMorph new contents: 'Yes' translated.	stringMorph name: 'Yes'.	r addMorphBack: stringMorph.	r addMorphBack: (Morph new color: color;			 extent: 5 @ 5).	"spacer"	r addMorphBack: (yesPart := ScriptEditorMorph new borderWidth: 0;					 layoutInset: 2).	yesPart hResizing: #spaceFill.	yesPart color: Color transparent.	self addMorphBack: r.	r := AlignmentMorph newRow color: color;				 layoutInset: 0.	r addMorphBack: (Morph new color: color;			 extent: 35 @ 5).	"spacer"	stringMorph := StringMorph new contents: 'No' translated.	stringMorph name: 'No'.	r addMorphBack: stringMorph.	r addMorphBack: (Morph new color: color;			 extent: 5 @ 5).	"spacer"	r addMorphBack: (noPart := ScriptEditorMorph new borderWidth: 0;					 layoutInset: 2).	noPart hResizing: #spaceFill.	noPart color: Color transparent.	self addMorphBack: r.	self bounds: self fullBounds.	self updateWordingToMatchVocabulary. 	self hResizing:#spaceFill! !!CompoundTileMorph methodsFor: 'initialization' stamp: 'nk 10/8/2004 11:56'!updateWordingToMatchVocabulary	| labels |	labels := OrderedCollection new.	self submorphs do: [:submorph |		submorph submorphs do: [:subsubmorph |			subsubmorph class == StringMorph ifTrue: [labels add: subsubmorph]]].	labels do: [:label | label knownName ifNotNilDo: [ :nm | label acceptValue: nm translated ]]! !!CompoundTileMorph methodsFor: 'miscellaneous' stamp: 'di 5/6/1998 21:10'!tile: tile isOnLineAfter: previousTile	"Return true if the given tile is not on the same line at the previous tile or if the previous tile is nil."	| tileRow previousRow |	previousTile ifNil: [^ true].	tileRow := tile owner.	[tileRow isMemberOf: AlignmentMorph]		whileFalse: [tileRow := tileRow owner].  "find the owning row"	previousRow := previousTile owner.	[previousRow isMemberOf: AlignmentMorph]		whileFalse: [previousRow := previousRow owner].  "find the owning row"	^ tileRow ~~ previousRow! !!CompoundTileMorph methodsFor: 'mouse'!targetPartFor: aMorph	"Return the row into which the given morph should be inserted."	| centerY |	centerY := aMorph fullBounds center y.	(Array with: testPart with: yesPart with: noPart) do: [:m |		(centerY <= m bounds bottom) ifTrue: [^ m]].	^ noPart! !!ContextPart methodsFor: 'private' stamp: 'dik 9/3/2007 13:00'!doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message."	| value |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ PrimitiveFailToken"					(primitiveIndex = 19) ifTrue:[		ToolSet 			debugContext: self			label:'Code simulation error'			contents: nil].	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: ((BlockContext newForMethod: receiver home method)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	(primitiveIndex = 82 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments first from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: (arguments at: 2)					super: false].	primitiveIndex = 186 ifTrue: [ "closure value"		| m |		m _ receiver method.		arguments size = m numArgs ifFalse: [^ PrimitiveFailToken].		^ self activateMethod: m			withArgs: arguments			receiver: receiver			class: receiver class].	primitiveIndex = 187 ifTrue: [ "closure valueWithArguments:"		| m args |		m _ receiver method.		args _ arguments first.		args size = m numArgs ifFalse: [^ PrimitiveFailToken].		^ self activateMethod: m			withArgs: args			receiver: receiver			class: receiver class].	primitiveIndex = 188 ifTrue: [ "object withArgs:executeMethod:"		| m args |		args _ arguments first.		m _ arguments second.		args size = m numArgs ifFalse: [^ PrimitiveFailToken].		^ self activateMethod: m			withArgs: args			receiver: receiver			class: receiver class].	arguments size > 6 ifTrue: [^ PrimitiveFailToken].	primitiveIndex = 117 		ifTrue:[value _ self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]		ifFalse:[value _ receiver tryPrimitive: primitiveIndex withArgs: arguments].	value == PrimitiveFailToken		ifTrue: [^ PrimitiveFailToken]		ifFalse: [^ self push: value]! !!ControlManager methodsFor: 'accessing' stamp: 'ar 6/5/1998 21:49'!activeController: aController 	"Set aController to be the currently active controller. Give the user 	control in it."	<primitive: 19> "Simulation guard"	activeController := aController.	(activeController == screenController)		ifFalse: [self promote: activeController].	activeControllerProcess := 			[activeController startUp.			self searchForActiveController] newProcess.	activeControllerProcess priority: Processor userSchedulingPriority.	activeControllerProcess resume! !!ControlManager methodsFor: 'accessing'!activeControllerNoTerminate: aController andProcess: aProcess	"Set aController to be the currently active controller and aProcess to be 	the the process that handles controller scheduling activities in the 	system. This message differs from activeController:andProcess: in that it 	does not send controlTerminate to the currently active controller."	self inActiveControllerProcess		ifTrue: 			[aController~~nil				ifTrue: [(scheduledControllers includes: aController)							ifTrue: [self promote: aController]							ifFalse: [self error: 'Old controller not scheduled']].			activeController := aController.			activeController == nil				ifFalse: [activeController controlInitialize].			activeControllerProcess := aProcess.			activeControllerProcess resume]		ifFalse: 			[self error: 'New active controller process must be set from old one'] ! !!ControlManager methodsFor: 'accessing'!noteNewTop	newTopClicked := true! !!ControlManager methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:06'!restore: aRectangle below: index without: aView	"Restore all windows visible in aRectangle, but without aView"	| view | 	view := (scheduledControllers at: index) view.	view == aView ifTrue: 		[index >= scheduledControllers size ifTrue: [^ self].		^ self restore: aRectangle below: index+1 without: aView].	view displayOn: ((BitBlt current toForm: Display) clipRect: aRectangle).	index >= scheduledControllers size ifTrue: [^ self].	(aRectangle areasOutside: view windowBox) do:		[:rect | self restore: rect below: index + 1 without: aView]! !!ControlManager methodsFor: 'initialize-release'!initialize	"Initialize the receiver to refer to only the background controller."	| screenView |	screenController := ScreenController new.	screenView := FormView new.	screenView model: (InfiniteForm with: Color gray) controller: screenController.	screenView window: Display boundingBox.	scheduledControllers := OrderedCollection with: screenController! !!ControlManager methodsFor: 'initialize-release'!release 	"Refer to the comment in Object|release."	scheduledControllers == nil		ifFalse: 			[scheduledControllers 				do: [:controller | (controller isKindOf: Controller)								ifTrue: [controller view release]								ifFalse: [controller release]].			scheduledControllers := nil]! !!ControlManager methodsFor: 'scheduling'!activateTranscript	"There is known to be a Transcript open in the current project; activate it.  2/5/96 sw"	| itsController |	itsController := scheduledControllers detect:			[:controller | controller model == Transcript]		ifNone:			[^ self].	self activeController: itsController.	(activeController view labelDisplayBox			intersect: Display boundingBox) area < 200				ifTrue: [activeController move].	Processor terminateActive! !!ControlManager methodsFor: 'scheduling' stamp: 'rbb 2/18/2005 10:50'!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically := Sensor shiftPressed.	controllers := OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size == 0 ifTrue: [^ self].	listToUse := sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels := String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: (labels findTokens: Character cr) asArray).	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!ControlManager methodsFor: 'scheduling' stamp: 'dtl 4/6/2005 23:20'!interruptName: labelString preemptedProcess: theInterruptedProcess	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| suspendingList newActiveController preemptedProcess |	preemptedProcess := theInterruptedProcess ifNil: [Processor preemptedProcess].	preemptedProcess == activeControllerProcess		ifFalse: [(suspendingList := preemptedProcess suspendingList) == nil				ifTrue: [preemptedProcess suspend]				ifFalse: [suspendingList remove: preemptedProcess.						preemptedProcess offList]].	(suspendingList := activeControllerProcess suspendingList) == nil		ifTrue: [activeControllerProcess == Processor activeProcess					ifTrue: [activeControllerProcess suspend]]		ifFalse: [suspendingList remove: activeControllerProcess ifAbsent:[].				activeControllerProcess offList].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController :=		(Debugger			openInterrupt: labelString			onProcess: preemptedProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!ControlManager methodsFor: 'scheduling' stamp: 'RAA 7/7/2000 09:22'!resetActiveController	"When saving a morphic project whose parent is mvc, we need to set this up first"	activeController := nil.	activeControllerProcess := Processor activeProcess.! !!ControlManager methodsFor: 'scheduling'!searchForActiveController	"Find a scheduled controller that wants control and give control to it. If 	none wants control, then see if the System Menu has been requested."	| aController |	activeController := nil.	activeControllerProcess := Processor activeProcess.	self activeController: self nextActiveController.	Processor terminateActive! !!ControlManager methodsFor: 'scheduling' stamp: 'rbb 2/18/2005 10:52'!windowFromUser	"Present a menu of window titles, and returns the StandardSystemController belonging to the one that gets chosen, or nil if none"	| controllers labels index |	controllers := OrderedCollection new.	labels := String streamContents:		[:strm |		scheduledControllers do:			[:controller | controller == screenController ifFalse:				[controllers addLast: controller.				strm nextPutAll: (controller view label contractTo: 40); cr]].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: (labels findTokens: Character cr) asArray).	^ index > 0		ifTrue:			[controllers at: index]		ifFalse:			[nil]! !!ControlManager methodsFor: 'private'!nextActiveController	"Answer the controller that would like control.  	If there was a click outside the active window, it's the top window	that now has the mouse, otherwise it's just the top window."	(newTopClicked notNil and: [newTopClicked])		ifTrue: [newTopClicked := false.				^ scheduledControllers 					detect: [:aController | aController isControlWanted]					ifNone: [scheduledControllers first]]		ifFalse: [^ scheduledControllers first]! !!Controller methodsFor: 'basic control sequence' stamp: 'RAA 1/30/2001 19:06'!interActivityPause	"if we are looping quickly, insert a short delay.  Thus if we are just doing UI stuff, we won't take up much CPU"	| currentTime wait |	MinActivityLapse ifNotNil: [		lastActivityTime ifNotNil: [ 			currentTime := Time millisecondClockValue.			wait := lastActivityTime + MinActivityLapse - currentTime.			wait > 0 ifTrue: [ 				wait <= MinActivityLapse  "big waits happen after a snapshot"					ifTrue: [DisplayScreen checkForNewScreenSize.							(Delay forMilliseconds: wait) wait ]. ]. ]. ].	lastActivityTime := Time millisecondClockValue.! !!Controller methodsFor: 'control defaults'!controlToNextLevel	"Pass control to the next control level (that is, to the Controller of a 	subView of the receiver's view) if possible. The receiver finds the 	subView (if any) of its view whose inset display box (see 	View|insetDisplayBox) contains the sensor's cursor point. The Controller 	of this subView is then given control if it answers true in response to 	the message Controller|isControlWanted."	| aView |	aView := view subViewWantingControl.	aView ~~ nil ifTrue: [aView controller startUp]! !!Controller methodsFor: 'initialize-release'!initialize	"Initialize the state of the receiver. Subclasses should include 'super 	initialize' when redefining this message to insure proper initialization."	sensor := InputSensor default! !!Controller methodsFor: 'initialize-release'!release	"Breaks the cycle between the receiver and its view. It is usually not 	necessary to send release provided the receiver's view has been properly 	released independently."	model := nil.	view ~~ nil		ifTrue: 			[view controller: nil.			view := nil]! !!Controller methodsFor: 'model access'!model: aModel 	"Controller|model: and Controller|view: are sent by View|controller: in 	order to coordinate the links between the model, view, and controller. In 	ordinary usage, the receiver is created and passed as the parameter to 	View|controller: so that the receiver's model and view links can be set 	up by the view."	model := aModel! !!Controller methodsFor: 'sensor access'!sensor: aSensor	"Set the receiver's sensor to aSensor."	sensor := aSensor! !!Controller methodsFor: 'view access'!view: aView 	"Controller|view: and Controller|model: are sent by View|controller: in 	order to coordinate the links between the model, view, and controller. In 	ordinary usage, the receiver is created and passed as the parameter to 	View|controller: and the receiver's model and view links are set up 	automatically by the view."	view := aView! !!Controller class methodsFor: 'initialization' stamp: 'ls 7/13/1998 00:47'!MinActivityLapse: milliseconds	"minimum time to delay between calls to controlActivity"	MinActivityLapse := milliseconds ifNotNil: [ milliseconds rounded ].! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'apb 2/15/2007 15:22'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the	path name delimiter from FileDirectory."	FileDirectory pathNameDelimiter = $:		ifTrue: [^ self defaultToCR].	FileDirectory pathNameDelimiter = $/		ifTrue: [((SmalltalkImage current getSystemAttribute: 1002) beginsWith: 'darwin')				ifTrue: [^ self defaultToCR]				ifFalse: [^ self defaultToLF]].	FileDirectory pathNameDelimiter = $\		ifTrue: [^ self defaultToCRLF].	"in case we don't know"	^ self defaultToCR! !!CurveFitter methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm	| pa pb k s p1 p2 p3 line |	line := Line new.	line form: self form.	collectionOfPoints size < 3 ifTrue: [self error: 'Curve must have three points'].	p1 := self firstPoint.	p2 := self secondPoint.	p3 := self thirdPoint.	s := Path new.	s add: p1.	pa := p2 - p1.	pb := p3 - p2.	k := 5 max: pa x abs + pa y abs + pb x abs + pb y abs // 20.	"k is a guess as to how many line segments to use to approximate 	the curve."	1 to: k do: 		[:i | 		s add: pa * i // k + p1 * (k - i) + (pb * (i - 1) // k + p2 * (i - 1)) // (k - 1)].	s add: p3.	1 to: s size - 1 do: 		[:i | 		line beginPoint: (s at: i).		line endPoint: (s at: i + 1).		line displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!CurveFitter methodsFor: 'displaying' stamp: '6/9/97 10:16 di'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	| transformedPath newCurveFitter |	transformedPath := aTransformation applyTo: self.	newCurveFitter := CurveFitter new.	newCurveFitter firstPoint: transformedPath firstPoint.	newCurveFitter secondPoint: transformedPath secondPoint.	newCurveFitter thirdPoint: transformedPath thirdPoint.	newCurveFitter form: self form.	newCurveFitter		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!CurveFitter class methodsFor: 'examples' stamp: '6/9/97 10:16 di'!example	"Designate three locations on the screen by clicking any button. The	curve determined by the points will be displayed with a long black form."	| aCurveFitter aForm |  	aForm := Form extent: 1@30.			"make a long thin Form for display "	aForm fillBlack.							"turn it black"	aCurveFitter := CurveFitter new.	aCurveFitter form: aForm.						"set the form for display"				"collect three Points and show them on the dispaly"	aCurveFitter firstPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter firstPoint.	aCurveFitter secondPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter secondPoint.	aCurveFitter thirdPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter thirdPoint.	aCurveFitter displayOn: Display					"display the CurveFitter"	"CurveFitter example"! !!CurveFitter class methodsFor: 'instance creation'!new	| newSelf | 	newSelf := super new: 3.	newSelf add: 0@0.	newSelf add: 0@0.	newSelf add: 0@0.	^newSelf! !!CustomMenu methodsFor: 'compatibility' stamp: 'sw 2/16/2002 00:57'!arguments	"Answer my arguments, initializing them to an empty collection if they're found to be nil."	^ arguments ifNil: [arguments := OrderedCollection new]! !!CustomMenu methodsFor: 'compatibility' stamp: 'sw 2/16/2002 00:57'!targets	"Answer my targets, initializing them to an empty collection if found to be nil"	^ targets ifNil: [targets := OrderedCollection new]! !!CustomMenu methodsFor: 'construction' stamp: 'dhhi 9/14/2000 22:39'!add: aString action: actionItem	"Add the given string as the next menu item. If it is selected, the given action (usually but not necessarily a symbol) will be returned to the client."	| s |	aString ifNil: [^ self addLine].	s := String new: aString size + 2.	s at: 1 put: Character space.	s replaceFrom: 2 to: s size - 1 with: aString.	s at: s size put: Character space.	labels addLast: s.	selections addLast: actionItem.! !!CustomMenu methodsFor: 'construction'!addLine	"Append a line to the menu after the last entry. Suppress duplicate lines."	(lastDivider ~= selections size) ifTrue: [		lastDivider := selections size.		dividers addLast: lastDivider].! !!CustomMenu methodsFor: 'construction' stamp: 'jm 8/20/1998 08:34'!labels: aString font: aFont lines: anArrayOrNil	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	| labelList linesArray |	labelList := (aString findTokens: String cr) asArray.	anArrayOrNil		ifNil: [linesArray := #()]		ifNotNil: [linesArray := anArrayOrNil].	1 to: labelList size do: [:i |		self add: (labelList at: i) action: (labelList at: i).		(linesArray includes: i) ifTrue: [self addLine]].	font ifNotNil: [font := aFont].! !!CustomMenu methodsFor: 'construction' stamp: 'yo 8/28/2002 22:34'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelList isString		ifTrue: [labelArray := labelList findTokens: String cr]		ifFalse: [labelArray := labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!CustomMenu methodsFor: 'initialize-release' stamp: 'sumim 2/10/2002 01:26'!initialize	labels := OrderedCollection new.	selections := OrderedCollection new.	dividers := OrderedCollection new.	lastDivider := 0.	targets := OrderedCollection new.	arguments := OrderedCollection new	! !!CustomMenu methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:01'!title: aTitle	title := aTitle! !!CustomMenu methodsFor: 'invocation' stamp: 'jm 11/17/97 16:54'!invokeOn: targetObject defaultSelection: defaultSelection	"Invoke the menu with the given default selection (i.e. one of my 'action' symbols). Answer the 'action' selector associated with the menu item chosen by the user or nil if none is chosen."	| sel |	sel := self startUp: defaultSelection.	sel = nil ifFalse: [		sel numArgs = 0			ifTrue: [^ targetObject perform: sel]			ifFalse: [^ targetObject perform: sel with: nil]].	^ nil! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 11/16/2002 23:45'!invokeOn: targetObject orSendTo: anObject	"Pop up this menu and return the result of sending to the target object the selector corresponding to the menu item selected by the user. Return  nil if no item is selected.  If the chosen selector has arguments, obtain appropriately.  If the recipient does not respond to the resulting message, send it to the alternate object provided"	| aSelector anIndex recipient |	^ (aSelector := self startUp) ifNotNil:		[anIndex := self selection.		recipient := ((targets := self targets) isEmptyOrNil or: [anIndex > targets size])			ifTrue:				[targetObject]			ifFalse:				[targets at: anIndex].		aSelector numArgs == 0			ifTrue:				[recipient perform: aSelector orSendTo: anObject]			ifFalse:				[recipient perform: aSelector withArguments: (self arguments at: anIndex)]]! !!CustomMenu methodsFor: 'private' stamp: 'sw 12/10/1999 11:21'!build	"Turn myself into an invokable ActionMenu."	| stream |	stream := WriteStream on: (String new).	labels do: [:label | stream nextPutAll: label; cr].	(labels isEmpty) ifFalse: [stream skip: -1].  "remove final cr"	super labels: stream contents		font: MenuStyle defaultFont		lines: dividers! !!CustomMenu methodsFor: 'private' stamp: 'di 4/14/1999 21:28'!preSelect: action	"Pre-select and highlight the menu item associated with the given action."	| i |	i := selections indexOf: action ifAbsent: [^ self].	marker ifNil: [self computeForm].	marker := marker		align: marker topLeft		with: (marker left)@(frame inside top + (marker height * (i - 1))).	selection := i.! !!CustomMenu class methodsFor: 'example' stamp: 'sw 11/8/1999 17:27'!example	"CustomMenu example"	| menu |	menu := CustomMenu new.	menu add: 'apples' action: #apples.	menu add: 'oranges' action: #oranges.	menu addLine.	menu addLine.  "extra lines ignored"	menu add: 'peaches' action: #peaches.	menu addLine.	menu add: 'pears' action: #pears.	menu addLine.	^ menu startUp: #apples"NB:  The following is equivalent to the above, but uses the compact #fromArray: consruct:	(CustomMenu fromArray:		#(	('apples'		apples)			('oranges'		oranges)			-			-			('peaches'		peaches)			-			('pears'			pears)			-))				startUp: #apples"! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:29'!bypass	"Return my reference as is."	^self reference! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:29'!forbidden	self error: 'Forbidden reference usage'! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 18:01'!include	"Return my expanded value."	^value ifNil: [SAXWarning signal: 'XML undefined entity ' , name printString]! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 18:06'!includedInLiteral	"Return my expanded value."	^self include! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:30'!reference	"Return my reference as is."	^self class leadIn , self name , ';'! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 1/4/2002 19:40'!name	^name! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:25'!name: aString	name _ aString asSymbol! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:22'!ndata	^ndata! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:22'!ndata: aString	ndata _ aString! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 11/16/2000 10:54'!value	^value! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 11/16/2000 10:55'!value: aString	value _ aString! !!DTDEntityDeclaration methodsFor: 'invocation' stamp: 'mir 11/16/2000 21:23'!registerIn: aParser	aParser entity: self name put: self! !!DTDEntityDeclaration methodsFor: 'invocation' stamp: 'mir 1/15/2002 15:08'!valueForContext: aContext	^self perform: (self class behaviorForContext: aContext)! !!DTDEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:14'!behaviorForContext: aContext	^self contextBehavior at: aContext! !!DTDEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:15'!contextBehavior	^contextBehavior! !!DTDEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:27'!leadIn	^'&'! !!DTDEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/15/2002 18:02'!initialize	"DTDEntityDeclaration initialize"	contextBehavior _ Dictionary new.	contextBehavior		at: #content put: #include ;		at: #attributeValueContent put: #includedInLiteral ;		at: #attributeValue put: #forbidden ;		at: #entityValue put: #bypass ;		at: #dtd put: #forbidden ! !!DTDEntityDeclaration class methodsFor: 'instance creation' stamp: 'mir 11/16/2000 20:13'!name: aString value: aValueString	^self new		name: aString;		value: aValueString! !!DTDExternalEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/14/2002 18:15'!initialize	"DTDExternalEntityDeclaration initialize"	contextBehavior _ Dictionary new.	contextBehavior		at: #content put: #include ;		at: #attributeValueContent put: #includedInLiteral ;		at: #attributeValue put: #forbidden ;		at: #entityValue put: #bypass ;		at: #dtd put: #forbidden ! !!DTDParameterEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:30'!includePE	"Return my expanded value."	^self include! !!DTDParameterEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 23:21'!notRecognized	SAXMalformedException signal: 'Malformed entity.'! !!DTDParameterEntityDeclaration methodsFor: 'invocation' stamp: 'mir 11/28/2000 17:26'!registerIn: aParser	aParser parameterEntity: self name put: self! !!DTDParameterEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/14/2002 18:15'!initialize	"DTDParameterEntityDeclaration initialize"	contextBehavior _ Dictionary new.	contextBehavior		at: #content put: #notRecognized: ;		at: #attributeValueContent put: #notRecognized: ;		at: #attributeValue put: #notRecognized: ;		at: #entityValue put: #include: ;		at: #dtd put: #includePE:! !!DTDParameterEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:27'!leadIn	^'%'! !!DataType methodsFor: '*eToys-tiles' stamp: 'sw 1/4/2005 00:45'!updatingTileForTarget: aTarget partName: partName getter: getter setter: setter	"Answer, for classic tiles, an updating readout tile for a part with the receiver's type, with the given getter and setter"	| aTile displayer actualSetter |	actualSetter := setter ifNotNil:		[(#(none #nil unused) includes: setter) ifTrue: [nil] ifFalse: [setter]].	aTile := self newReadoutTile.	displayer := UpdatingStringMorph new		getSelector: getter;		target: aTarget;		growable: true;		minimumWidth: 24;		putSelector: actualSetter.	"Note that when typeSymbol = #number, the #target: call above will have dealt with floatPrecision details"	self setFormatForDisplayer: displayer.	aTile addMorphBack: displayer.	(actualSetter notNil and: [self wantsArrowsOnTiles]) ifTrue: [aTile addArrows].		getter numArgs == 0 ifTrue:		[aTile setLiteralInitially: (aTarget perform: getter)].	^ aTile! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 4/13/2006 10:21'!asUTC	^ offset isZero		ifTrue: [self]		ifFalse: [self utcOffset: 0]! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 00:55'!asDuration	"Answer the duration since midnight."	^ Duration seconds: seconds nanoSeconds: nanos! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'kph 10/13/2006 04:33'!setJdn: j seconds: s nano: n offset: ojdn := j.seconds := s.nanos :=  n.offset :=  o.! !!DateAndTime methodsFor: 'private' stamp: 'gk 8/30/2006 22:59'!normalize: i ticks: ticks base: base	| tick div quo rem |	tick := ticks at: i.	div := tick digitDiv: base neg: tick negative.	quo := (div at: 1) normalize.	rem := (div at: 2) normalize.	rem < 0 ifTrue: [ quo := quo - 1. rem := base + rem ].	ticks at: (i-1) put: ((ticks at: i-1) + quo).	ticks at: i put: rem! !!DateAndTime methodsFor: 'private' stamp: 'gk 8/30/2006 23:01'!ticks: ticks offset: utcOffset	"ticks is {julianDayNumber. secondCount. nanoSeconds}"	self normalize: 3 ticks: ticks base: NanosInSecond.	self normalize: 2 ticks: ticks base: SecondsInDay.	jdn	_ ticks at: 1.	seconds	_ ticks at: 2.	nanos := ticks at: 3.	offset := utcOffset! !!DateAndTime commentStamp: 'brp 5/13/2003 08:07' prior: 0!I represent a point in UTC time as defined by ISO 8601. I have zero duration.My implementation uses three SmallIntegers and a Duration:jdn		- julian day number.seconds	- number of seconds since midnight.nanos	- the number of nanoseconds since the second.offset	- duration from UTC.The nanosecond attribute is almost always zero but it defined for full ISO compliance and is suitable for timestamping.!!DateAndTime class methodsFor: 'ansi protocol' stamp: 'gk 8/31/2006 00:49'!clockPrecision	"One nanosecond precision"	^ Duration seconds: 0 nanoSeconds: 1! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'KLC 5/9/2008 20:13'!now 	| nanoTicks msm |	nanoTicks := (msm := self milliSecondsSinceMidnight) * 1000000.	(LastTick < nanoTicks) ifTrue: [		LastTick := nanoTicks.		^ self todayAtMilliSeconds: msm].	LastTickSemaphore critical: [	 	 		LastTick _  LastTick + 1.		^ self todayAtNanoSeconds: LastTick]" [ 10000 timesRepeat: [ self now. ] ] timeToRun / 10000.0 . If calls to DateAndTime-c-#now are within a single millisecond the semaphore code to ensure that (self now <= self now) slows things down considerably by a factor of about 20.The actual speed of a single call to DateAndTime-now in milliseconds is demonstrated by the unguarded method below.[ 100000 timesRepeat: [ self todayAtMilliSeconds: (self milliSecondsSinceMidnight) ] ] timeToRun / 100000.0 .  0.00494 0.00481 0.00492 0.00495  "! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'gk 8/31/2006 01:00'!fromSeconds: seconds	"Answer a DateAndTime since the Squeak epoch: 1 January 1901"	^ self basicNew ticks: (Array with: SqueakEpoch with: seconds with: 0) offset: self localOffset! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'kph 12/11/2006 21:13'!millisecondClockValue	^ self clock millisecondClockValue! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'kph 12/9/2006 23:46'!totalSeconds	^ self clock totalSeconds! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 6/13/2007 23:07'!localOffset	"Answer the duration we are offset from UTC"	^ LocalOffset ifNil:[ LocalOffset := self localTimeZone offset ]! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 10/20/2007 13:56'!milliSecondsSinceMidnight		| msm msClock |		msClock := self millisecondClockValue. 	(msClock < LastMilliSeconds) 		ifTrue:[ "rolled over" MilliSecondOffset := MilliSecondOffset + (SmallInteger maxVal // 2) + 1 ].	LastMilliSeconds := msClock.	[ msm := msClock + MilliSecondOffset. 	 (msm >= 86400000) ] 		whileTrue: [ "next day" 			LastTick := -1.			DaysSinceEpoch := DaysSinceEpoch + 1. 			MilliSecondOffset := MilliSecondOffset - 86400000 ].	"day rolled over sanity check"	((LastTick = -1) and: [		(Duration days: SqueakEpoch hours: 0 minutes: 0 seconds: 								(self clock totalSeconds)) days ~= DaysSinceEpoch ]) 		ifTrue: 				[  self initializeOffsets. 				 ^ self milliSecondsSinceMidnight ].		^msm! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 12/19/2006 15:01'!readFrom: aStream	| bc year month day hour minute second nanos offset buffer ch |	aStream peek = $- ifTrue: [ aStream next. bc _ -1] ifFalse: [bc _ 1].	year _ (aStream upTo: $-) asInteger * bc.	month _ (aStream upTo: $-) asInteger.	day _ (aStream upTo: $T) asInteger.	hour _ (aStream upTo: $:) asInteger. 	buffer _ '00:' copy. ch _ nil.	minute _ WriteStream on: buffer.	[ aStream atEnd | (ch = $:) | (ch = $+) | (ch = $-) ]		whileFalse: [ ch _ minute nextPut: aStream next. ].	(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $: ].	minute _ ((ReadStream on: buffer) upTo: ch) asInteger.	buffer _ '00.' copy.	second _ WriteStream on: buffer.	[ aStream atEnd | (ch = $.) | (ch = $+) | (ch = $-) ]		whileFalse: [ ch _ second nextPut: aStream next. ].	(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $. ].	second _ ((ReadStream on: buffer) upTo: ch) asInteger.	buffer _ '000000000+' copy.	(ch = $.) ifTrue: [ 		nanos _ WriteStream on: buffer.		[ aStream atEnd | ((ch := aStream next) = $+) | (ch = $-) ]			whileFalse: [ nanos nextPut: ch. ].		(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $+ ].	].	nanos _ buffer asInteger.	aStream atEnd		ifTrue: [ offset _ self localOffset ]		ifFalse:		 	[offset _ Duration fromString: (ch asString, '0:', aStream upToEnd).			(offset = self localOffset) ifTrue: [ offset _ self localOffset ]].	^ self		year: year		month: month		day: day		hour: hour		minute: minute		second: second		nanoSecond:  nanos		offset: offset.	"	'-1199-01-05T20:33:14.321-05:00' asDateAndTime		' 2002-05-16T17:20:45.1+01:01' asDateAndTime		' 2002-05-16T17:20:45.02+01:01' asDateAndTime		' 2002-05-16T17:20:45.003+01:01' asDateAndTime		' 2002-05-16T17:20:45.0004+01:01' asDateAndTime  		' 2002-05-16T17:20:45.00005' asDateAndTime		' 2002-05-16T17:20:45.000006+01:01' asDateAndTime		' 2002-05-16T17:20:45.0000007+01:01' asDateAndTime		' 2002-05-16T17:20:45.00000008-01:01' asDateAndTime   		' 2002-05-16T17:20:45.000000009+01:01' asDateAndTime  		' 2002-05-16T17:20:45.0000000001+01:01' asDateAndTime   		' 2002-05-16T17:20' asDateAndTime		' 2002-05-16T17:20:45' asDateAndTime		' 2002-05-16T17:20:45+01:57' asDateAndTime 		' 2002-05-16T17:20:45-02:34' asDateAndTime 		' 2002-05-16T17:20:45+00:00' asDateAndTime		' 1997-04-26T01:02:03+01:02:3' asDateAndTime  	"! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 12/11/2006 20:36'!todayAtMilliSeconds: milliSecondsSinceMidnight	 ^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (milliSecondsSinceMidnight // 1000) 			nano: (milliSecondsSinceMidnight  \\ 1000 * 1000000  ) 			offset: self localOffset	 " [ 100000 timesRepeat: [ self fromMilliSeconds: self milliSecondsSinceMidnight. ] ] timeToRun.    "! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 12/11/2006 20:36'!todayAtNanoSeconds: nanoSecondsSinceMidnight	^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (nanoSecondsSinceMidnight // 1000000000) 			nano: (nanoSecondsSinceMidnight  \\ 1000000000  ) 			offset: self localOffset ! !!DateAndTime class methodsFor: 'clock provider' stamp: 'kph 12/11/2006 20:14'!clock 	 "the provider of real time seconds/milliseconds."	^ ClockProvider ! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'kph 6/13/2007 23:05'!initialize	super initialize.	ClockProvider := Time.	LastTickSemaphore := Semaphore forMutualExclusion.	LastMilliSeconds := 0.	LocalOffset := nil.	LastTick := 0.	Smalltalk addToStartUpList: self.	self startUp: true.! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'kph 6/16/2007 06:51'!initializeOffsets 	| epochianSeconds secondsSinceMidnight nowSecs  |	  	LastTick := 0.  	nowSecs :=  self clock secondsWhenClockTicks.	LastMilliSeconds := self millisecondClockValue. 	epochianSeconds := Duration days: SqueakEpoch hours: 0 minutes: 0 seconds: nowSecs.	DaysSinceEpoch := epochianSeconds days.	secondsSinceMidnight := (epochianSeconds - (Duration days: DaysSinceEpoch hours: 0 minutes: 0 seconds: 0)) asSeconds.  	MilliSecondOffset := (secondsSinceMidnight * 1000 - LastMilliSeconds).	LocalOffset := nil.  ! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'kph 12/13/2006 21:46'!startUp: resuming 	resuming ifFalse: [^ self].		[ self initializeOffsets ] fork.	! !!DateAndTime class methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:39'!localTimeZone	"Answer the local time zone"	^ LocalTimeZone ifNil: [ LocalTimeZone _ TimeZone default ]! !!DateAndTime class methodsFor: 'accessing' stamp: 'nk 3/30/2004 09:53'!localTimeZone: aTimeZone	"Set the local time zone"	"	DateAndTime localTimeZone: (TimeZone offset:  0 hours name: 'Universal Time' abbreviation: 'UTC').	DateAndTime localTimeZone: (TimeZone offset: -8 hours name: 'Pacific Standard Time' abbreviation: 'PST').	"	LocalTimeZone := aTimeZone! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'KLC 5/9/2008 20:37'!testPrecision	"Verify that the clock is returning a value with accuracy of better than 1 second.  For now it seems sufficient to get two values and verify they are not the same."	self		assert: (DateAndTime now ~= DateAndTime now)! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'kph 12/19/2006 15:04'!testReadFromself assert: ('-1199-01-05T20:33:14.321-05:00' asDateAndTime printString = '-1199-01-05T20:33:14.321-05:00').self assert: ('2002-05-16T17:20:45.1+01:01' asDateAndTime printString = '2002-05-16T17:20:45.1+01:01').self assert:	(' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString = '2002-05-16T17:20:45.02+01:01').  self assert:	('2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString =  '2002-05-16T17:20:45.000000009+01:01').self assert: (' 2002-05-16T17:20' asDateAndTime printString = '2002-05-16T17:20:00+00:00').self assert: ('2002-05-16T17:20:45' asDateAndTime printString = '2002-05-16T17:20:45+00:00' ).self assert: (' 2002-05-16T17:20:45+01:57' asDateAndTime printString = '2002-05-16T17:20:45+01:57').self assert: (' 2002-05-16T17:20:45-02:34' asDateAndTime = '2002-05-16T17:20:45-02:34').self assert: ('2002-05-16T17:20:45+00:00' asDateAndTime = '2002-05-16T17:20:45+00:00').self assert: ('1997-04-26T01:02:03+01:02:3' asDateAndTime = '1997-04-26T01:02:03+01:02:3').  	 ! !!Debugger methodsFor: 'accessing' stamp: 'al 7/29/2004 14:37'!contents: aText notifying: aController 	"The retrieved information has changed and its source must now be  	updated. In this case, the retrieved information is the method of the  	selected context."	| selector classOfMethod category h ctxt originalClassOfMethod |	contextStackIndex = 0		ifTrue: [^ false].	self selectedContext isExecutingBlock		ifTrue: [h := self selectedContext finalBlockHome.			h				ifNil: [self inform: 'Method not found for block, can''t edit'.					^ false].			(self confirm: 'I will have to revert to the method fromwhich this block originated.  Is that OK?')				ifTrue: [self resetContext: h]				ifFalse: [^ false]].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	selector == self selectedMessageName		ifFalse: [self inform: 'can''t change selector'.			^ false].	originalClassOfMethod := classOfMethod traitOrClassOfSelector: selector.	selector := originalClassOfMethod				compile: aText				classified: category				notifying: aController.	selector		ifNil: [^ false].	"compile cancelled"	contents := aText.	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext ifFalse: [		self inform: 'Method saved, but current context unchangedbecause of unwind error. Click OK to see error'.	] ifTrue: [		interruptedProcess			restartTopWith: (classOfMethod compiledMethodAt: selector);		 	stepToSendOrReturn.		contextVariablesInspector object: nil.		theMethodNode := Preferences browseWithPrettyPrint			ifTrue: [ctxt methodNodeFormattedAndDecorated: Preferences colorWhenPrettyPrinting]			ifFalse: [ctxt methodNode].		sourceMap := theMethodNode sourceMap.		tempNames := theMethodNode tempNames.	].	self resetContext: ctxt.	^ true! !!Debugger methodsFor: 'context stack menu' stamp: 'sd 11/20/2005 21:27'!buildMorphicNotifierLabelled: label message: messageString	| notifyPane window contentTop extentToUse |	self expandStack.	window := (PreDebugWindow labelled: label) model: self.	contentTop := 0.25.	extentToUse := 450 @ 156. "nice and wide to show plenty of the error msg"	window addMorph: (self buttonRowForPreDebugWindow: window)				frame: (0@0 corner: 1 @ contentTop).	Preferences eToyFriendly | messageString notNil		ifFalse:			[notifyPane := PluggableListMorph on: self list: #contextStackList				selected: #contextStackIndex changeSelected: #debugAt:				menu: nil keystroke: nil]		ifTrue:			[notifyPane := PluggableTextMorph on: self text: nil accept: nil				readSelection: nil menu: #debugProceedMenu:.			notifyPane editString: (self preDebugNotifierContentsFrom: messageString);				askBeforeDiscardingEdits: false].	window addMorph: notifyPane frame: (0@contentTop corner: 1@1).	"window deleteCloseBox.		chickened out by commenting the above line out, sw 8/14/2000 12:54"	window setBalloonTextForCloseBox.	^ window openInWorldExtent: extentToUse! !!Debugger methodsFor: 'initialize' stamp: 'ab 3/23/2005 14:03'!customButtonSpecs	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."	| list |	list _ #(('Proceed'	proceed				'close the debugger and proceed.')		('Restart'		restart				'reset this context to its start.')		('Into'			send				'step Into message sends')		('Over'			doStep				'step Over message sends')		('Through'		stepIntoBlock		'step into a block')		('Full Stack'		fullStack			'show full stack')		('Where'		where				'select current pc range')		('Tally'			tally				'time in milliseconds to execute')).	Preferences restartAlsoProceeds ifTrue:		[list _ list collect: [:each |			each second == #restart				ifTrue: [each copy at: 3 put: 'proceed from the beginning of this context.'; yourself]				ifFalse: [each]]].	^ list! !!Debugger methodsFor: 'controls' stamp: 'md 2/24/2006 15:44'!addOptionalButtonsTo: window at: fractions plus: verticalOffset 	"Add button panes to the window. A row of custom	debugger-specific buttons (Proceed, Restart, etc.) is always	added, and if optionalButtons is in force, then the standard	code-tool buttons are also added. Answer the verticalOffset	plus the height added."	| delta buttons anOffset |	anOffset := (Preferences optionalButtons					and: [Preferences extraDebuggerButtons])				ifTrue: [super						addOptionalButtonsTo: window						at: fractions						plus: verticalOffset]				ifFalse: [verticalOffset].	delta := self defaultButtonPaneHeight.	buttons := self customButtonRow.	buttons color: Color white; borderWidth: 0.	window		addMorph: buttons		fullFrame: (LayoutFrame				fractions: fractions				offsets: (0 @ anOffset corner: 0 @ (anOffset + delta - 1))).	^ anOffset + delta! !!Debugger methodsFor: 'tally support' stamp: 'ab 5/22/2007 14:17'!getSelectedText	| m interval text |	m := self getTextMorphWithSelection.	interval := m selectionInterval.	text := m text.	^ text copyFrom: interval first to: interval last	! !!Debugger methodsFor: 'tally support' stamp: 'ab 5/22/2007 14:17'!getTextMorphWithSelection	"This is extremely ugly... We I need to get a reference of the code pane, which is not easily accessible"	^ (self dependents select: [:m| m isKindOf: PluggableTextMorph]) 		detect: [:m| m selectionInterval first > 1] ifNone: [nil]! !!Debugger methodsFor: 'tally support' stamp: 'ab 5/22/2007 13:35'!tally	self getTextMorphWithSelection ifNotNilDo: [:o| o tallyIt] ifNil: [Beeper beep]! !!Delay methodsFor: 'delaying' stamp: 'ar 8/30/2007 19:32'!wait	"Schedule this Delay, then wait on its semaphore. The current process will be suspended for the amount of time specified when this Delay was created."	self schedule.	[delaySemaphore wait] ifCurtailed:[self unschedule].! !!Delay methodsFor: 'public' stamp: 'ar 7/10/2007 21:49'!beingWaitedOn	"Answer whether this delay is currently scheduled, e.g., being waited on"	^beingWaitedOn! !!Delay methodsFor: 'public' stamp: 'ar 7/10/2007 21:49'!beingWaitedOn: aBool	"Indicate whether this delay is currently scheduled, e.g., being waited on"	beingWaitedOn := aBool! !!Delay methodsFor: 'public' stamp: 'ar 7/10/2007 20:56'!delayDuration	^delayDuration! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:24'!activate	"Private!! Make the receiver the Delay to be awoken when the next timer interrupt occurs. This method should only be called from a block protected by the AccessProtect semaphore."	TimerEventLoop ifNotNil:[^nil].	ActiveDelay := self.	ActiveDelayStartTime := Time millisecondClockValue.	ActiveDelayStartTime > resumptionTime ifTrue:[		ActiveDelay signalWaitingProcess.		SuspendedDelays isEmpty ifTrue:[			ActiveDelay := nil.			ActiveDelayStartTime := nil.		] ifFalse:[SuspendedDelays removeFirst activate].	] ifFalse:[		TimingSemaphore initSignals.		Delay primSignal: TimingSemaphore atMilliseconds: resumptionTime.	].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:55'!schedule	"Private!! Schedule this Delay, but return immediately rather than waiting. The receiver's semaphore will be signalled when its delay duration has elapsed."	beingWaitedOn ifTrue: [self error: 'This Delay has already been scheduled.'].	TimerEventLoop ifNotNil:[^self scheduleEvent].	AccessProtect critical: [		beingWaitedOn := true.		resumptionTime := Time millisecondClockValue + delayDuration.		ActiveDelay == nil			ifTrue: [self activate]			ifFalse: [				resumptionTime < ActiveDelay resumptionTime					ifTrue: [						SuspendedDelays add: ActiveDelay.						self activate]					ifFalse: [SuspendedDelays add: self]]].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 22:33'!scheduleEvent	"Schedule this delay"	resumptionTime := Time millisecondClockValue + delayDuration.	AccessProtect critical:[		ScheduledDelay := self.		TimingSemaphore signal.	].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:55'!unschedule	"Unschedule this Delay. Do nothing if it wasn't scheduled."	| done |	TimerEventLoop ifNotNil:[^self unscheduleEvent].	AccessProtect critical: [		done := false.		[done] whileFalse:			[SuspendedDelays remove: self ifAbsent: [done := true]].		ActiveDelay == self ifTrue: [			SuspendedDelays isEmpty				ifTrue: [					ActiveDelay := nil.					ActiveDelayStartTime := nil]				ifFalse: [					SuspendedDelays removeFirst activate]]].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:56'!unscheduleEvent	AccessProtect critical:[		FinishedDelay := self.		TimingSemaphore signal.	].! !!Delay commentStamp: 'stephaneducasse 10/1/2005 21:07' prior: 0!I am the main way that a process may pause for some amount of time.  The simplest usage is like this:	(Delay forSeconds: 5) wait.An instance of Delay responds to the message 'wait' by suspending the caller's process for a certain amount of time. The duration of the pause is specified when the Delay is created with the message forMilliseconds: or forSeconds:. A Delay can be used again when the current wait has finished. For example, a clock process might repeatedly wait on a one-second Delay.The maximum delay is (SmallInteger maxVal // 2) milliseconds, or about six days. A delay in progress when an image snapshot is saved is resumed when the snapshot is re-started. Delays work across millisecond clock roll-overs.For a more complex example, see  #testDelayOf:for:rect: .A word of advice:This is THE highest priority code which is run in Squeak, in other words it is time-critical. The speed of this code is critical for accurate responses, it is critical for network services, it affects every last part of the system.In short: Don't fix it if it ain't broken!! This code isn't supposed to be beautiful, it's supposed to be fast!! The reason for duplicating code is to make it fast. The reason for not using ifNil:[]ifNotNil:[] is that the compiler may not inline those. Since the effect of changes are VERY hard to predict it is best to leave things as they are for now unless there is an actual need to change anything!!Delay class methodsFor: 'timer process' stamp: 'ar 8/24/2007 12:36'!handleTimerEvent	"Handle a timer event; which can be either:		- a schedule request (ScheduledDelay notNil)		- an unschedule request (FinishedDelay notNil)		- a timer signal (not explicitly specified)	We check for timer expiry every time we get a signal."	| nowTick nextTick |	"Wait until there is work to do."	TimingSemaphore wait.	"Process any schedule requests"	ScheduledDelay ifNotNil:[		"Schedule the given delay"		self scheduleDelay: ScheduledDelay.		ScheduledDelay := nil.	].	"Process any unschedule requests"	FinishedDelay ifNotNil:[		self unscheduleDelay: FinishedDelay.		FinishedDelay := nil.	].	"Check for clock wrap-around."	nowTick := Time millisecondClockValue.	nowTick < ActiveDelayStartTime ifTrue: [		"clock wrapped"		self saveResumptionTimes.		self restoreResumptionTimes.	].	ActiveDelayStartTime := nowTick.	"Signal any expired delays"	[ActiveDelay notNil and:[nowTick >= ActiveDelay resumptionTime]] whileTrue:[		ActiveDelay signalWaitingProcess.		SuspendedDelays isEmpty 			ifTrue: [ActiveDelay := nil] 			ifFalse:[ActiveDelay := SuspendedDelays removeFirst].	].	"And signal when the next request is due. We sleep at most 1sec here	as a soft busy-loop so that we don't accidentally miss signals."	nextTick := nowTick + 1000.	ActiveDelay ifNotNil:[nextTick := nextTick min: ActiveDelay resumptionTime].	nextTick := nextTick min: SmallInteger maxVal.	"Since we have processed all outstanding requests, reset the timing semaphore so	that only new work will wake us up again. Do this RIGHT BEFORE setting the next	wakeup call from the VM because it is only signaled once so we mustn't miss it."	TimingSemaphore initSignals.	Delay primSignal: TimingSemaphore atMilliseconds: nextTick.	"This last test is necessary for the obscure case that the msecs clock rolls over	after nowTick has been computed (unlikely but not impossible). In this case we'd	wait for MillisecondClockMask msecs (roughly six days) or until another delay gets	scheduled (which may not be any time soon). In any case, since handling the	condition is easy, let's just deal with it"	Time millisecondClockValue < nowTick ifTrue:[TimingSemaphore signal]. "retry"! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/11/2007 09:04'!runTimerEventLoop	"Run the timer event loop."	[		[RunTimerEventLoop] whileTrue: [self handleTimerEvent]	] on: Error do:[:ex|		"Clear out the process so it does't get killed"		TimerEventLoop := nil.		"Launch the old-style interrupt watcher"		self startTimerInterruptWatcher.		"And pass the exception on"		ex pass.	].! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 22:32'!scheduleDelay: aDelay	"Private. Schedule this Delay."	aDelay beingWaitedOn: true.	ActiveDelay ifNil:[		ActiveDelay := aDelay	] ifNotNil:[		aDelay resumptionTime < ActiveDelay resumptionTime ifTrue:[			SuspendedDelays add: ActiveDelay.			ActiveDelay := aDelay.		] ifFalse: [SuspendedDelays add: aDelay].	].! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/11/2007 10:18'!startTimerEventLoop	"Start the timer event loop"	"Delay startTimerEventLoop"	self stopTimerEventLoop.	self stopTimerInterruptWatcher.	AccessProtect := Semaphore forMutualExclusion.	ActiveDelayStartTime := Time millisecondClockValue.	SuspendedDelays := 		Heap withAll: (SuspendedDelays ifNil:[#()])			sortBlock: [:d1 :d2 | d1 resumptionTime <= d2 resumptionTime].	TimingSemaphore := Semaphore new.	RunTimerEventLoop := true.	TimerEventLoop := [self runTimerEventLoop] newProcess.	TimerEventLoop priority: Processor timingPriority.	TimerEventLoop resume.	TimingSemaphore signal. "get going"! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 22:32'!startTimerInterruptWatcher	"Reset the class variables that keep track of active Delays and re-start the timer interrupt watcher process. Any currently scheduled delays are forgotten."	"Delay startTimerInterruptWatcher"	| p |	self stopTimerEventLoop.	self stopTimerInterruptWatcher.	TimingSemaphore := Semaphore new.	AccessProtect := Semaphore forMutualExclusion.	SuspendedDelays := 		SortedCollection sortBlock: 			[:d1 :d2 | d1 resumptionTime <= d2 resumptionTime].	ActiveDelay := nil.	p := [self timerInterruptWatcher] newProcess.	p priority: Processor timingPriority.	p resume.! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 21:26'!stopTimerEventLoop	"Stop the timer event loop"	RunTimerEventLoop := false.	TimingSemaphore signal.	TimerEventLoop := nil.! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 21:32'!stopTimerInterruptWatcher	"Reset the class variables that keep track of active Delays and re-start the timer interrupt watcher process. Any currently scheduled delays are forgotten."	"Delay startTimerInterruptWatcher"	self primSignal: nil atMilliseconds: 0.	TimingSemaphore ifNotNil:[TimingSemaphore terminateProcess].! !!Delay class methodsFor: 'timer process' stamp: 'ar 8/30/2007 19:59'!unscheduleDelay: aDelay	"Private. Unschedule this Delay."	aDelay beingWaitedOn ifFalse:[^self].	ActiveDelay == aDelay ifTrue: [		SuspendedDelays isEmpty ifTrue:[			ActiveDelay := nil.		] ifFalse: [			ActiveDelay := SuspendedDelays removeFirst.		]	] ifFalse:[		SuspendedDelays remove: aDelay ifAbsent: [].	].	aDelay beingWaitedOn: false.! !!Delay class methodsFor: 'class initialization' stamp: 'ar 7/11/2007 18:16'!initialize	"Delay initialize"	self startTimerEventLoop.! !!Dictionary methodsFor: 'accessing'!associationAt: key ifAbsent: aBlock 	"Answer the association with the given key.	If key is not found, return the result of evaluating aBlock."	| index assoc |	index := self findElementOrNil: key.	assoc := array at: index.	nil == assoc ifTrue: [ ^ aBlock value ].	^ assoc! !!Dictionary methodsFor: 'accessing' stamp: 'tk 4/9/1999 10:22'!associationDeclareAt: aKey	"Return an existing association, or create and return a new one.  Needed as a single message by ImageSegment.prepareToBeSaved."	| existing |	^ self associationAt: aKey ifAbsent: [		(Undeclared includesKey: aKey)			ifTrue: 				[existing := Undeclared associationAt: aKey.				Undeclared removeKey: aKey.				self add: existing]			ifFalse: 				[self add: aKey -> false]]! !!Dictionary methodsFor: 'accessing' stamp: 'dvf 9/17/2003 16:03'!associations	"Answer a Collection containing the receiver's associations."	| out |	out := WriteStream on: (Array new: self size).	self associationsDo: [:value | out nextPut: value].	^ out contents! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 14:59'!at: key ifAbsent: aBlock 	"Answer the value associated with the key or, if key isn't found,	answer the result of evaluating aBlock."	| assoc |	assoc := array at: (self findElementOrNil: key).	assoc ifNil: [^ aBlock value].	^ assoc value! !!Dictionary methodsFor: 'accessing' stamp: 'di 3/7/2001 15:29'!at: key ifPresentAndInMemory: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| v |	v := self at: key ifAbsent: [^ nil].	v isInMemory ifFalse: [^ nil].	^ aBlock value: v! !!Dictionary methodsFor: 'accessing' stamp: 'jm 5/15/1998 07:20'!at: key ifPresent: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| v |	v := self at: key ifAbsent: [^ nil].	^ aBlock value: v! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 15:00'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a	new entry for key and set is value to anObject. Answer anObject."	| index assoc |	index := self findElementOrNil: key.	assoc := array at: index.	assoc		ifNil: [self atNewIndex: index put: (Association key: key value: anObject)]		ifNotNil: [assoc value: anObject].	^ anObject! !!Dictionary methodsFor: 'accessing'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet := Set new: self size.	self keysDo: [:key | aSet add: key].	^ aSet! !!Dictionary methodsFor: 'accessing' stamp: 'sma 6/18/2000 12:56'!keysSortedSafely	"Answer a SortedCollection containing the receiver's keys."	| sortedKeys |	sortedKeys := SortedCollection new: self size.	sortedKeys sortBlock:		[:x :y |  "Should really be use <obj, string, num> compareSafely..."		((x isString and: [y isString])			or: [x isNumber and: [y isNumber]])			ifTrue: [x < y]			ifFalse: [x class == y class				ifTrue: [x printString < y printString]				ifFalse: [x class name < y class name]]].	self keysDo: [:each | sortedKeys addLast: each].	^ sortedKeys reSort! !!Dictionary methodsFor: 'accessing' stamp: 'ar 7/11/1999 07:28'!values	"Answer a Collection containing the receiver's values."	| out |	out := WriteStream on: (Array new: self size).	self valuesDo: [:value | out nextPut: value].	^ out contents! !!Dictionary methodsFor: 'adding'!add: anAssociation	| index element |	index := self findElementOrNil: anAssociation key.	element := array at: index.	element == nil		ifTrue: [self atNewIndex: index put: anAssociation]		ifFalse: [element value: anAssociation value].	^ anAssociation! !!Dictionary methodsFor: 'enumerating' stamp: 'dtl 2/17/2003 09:40'!associationsSelect: aBlock 	"Evaluate aBlock with each of my associations as the argument. Collect	into a new dictionary, only those associations for which aBlock evaluates	to true."	| newCollection |	newCollection := self species new.	self associationsDo: 		[:each | 		(aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!Dictionary methodsFor: 'enumerating'!collect: aBlock 	"Evaluate aBlock with each of my values as the argument.  Collect the	resulting values into a collection that is like me. Answer with the new	collection."	| newCollection |	newCollection := OrderedCollection new: self size.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!Dictionary methodsFor: 'enumerating'!select: aBlock 	"Evaluate aBlock with each of my values as the argument. Collect into a	new dictionary, only those associations for which aBlock evaluates to	true."	| newCollection |	newCollection := self species new.	self associationsDo: 		[:each | 		(aBlock value: each value) ifTrue: [newCollection add: each]].	^newCollection! !!Dictionary methodsFor: 'printing'!storeOn: aStream	| noneYet |	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' new)'.	noneYet := true.	self associationsDo: 			[:each | 			noneYet				ifTrue: [noneYet := false]				ifFalse: [aStream nextPut: $;].			aStream nextPutAll: ' add: '.			aStream store: each].	noneYet ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!Dictionary methodsFor: 'removing' stamp: 'di 4/4/2000 11:47'!keysAndValuesRemove: keyValueBlock	"Removes all entries for which keyValueBlock returns true."	"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method."	| removals |	removals := OrderedCollection new.	self associationsDo:		[:assoc | (keyValueBlock value: assoc key value: assoc value)			ifTrue: [removals add: assoc key]]. 	removals do:		[:aKey | self removeKey: aKey]! !!Dictionary methodsFor: 'removing'!removeKey: key ifAbsent: aBlock 	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| index assoc |	index := self findElementOrNil: key.	assoc := array at: index.	assoc == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^ assoc value! !!Dictionary methodsFor: 'testing'!occurrencesOf: anObject 	"Answer how many of the receiver's elements are equal to anObject."	| count |	count := 0.	self do: [:each | anObject = each ifTrue: [count := count + 1]].	^count! !!Dictionary methodsFor: 'user interface' stamp: 'hg 10/3/2001 20:47'!explorerContents	| contents |		contents := OrderedCollection new.	self keysSortedSafely do: [:key |		contents add: (ObjectExplorerWrapper			with: (self at: key)			name: (key printString contractTo: 32)			model: self)].	^contents! !!Dictionary methodsFor: 'private'!keyAt: index	"May be overridden by subclasses so that fixCollisions will work"	| assn |	assn := array at: index.	assn == nil ifTrue: [^ nil]				ifFalse: [^ assn key]! !!Dictionary methodsFor: 'private'!noCheckAdd: anObject	"Must be defined separately for Dictionary because (self findElementOrNil:) expects a key, not an association.  9/7/96 tk"	array at: (self findElementOrNil: anObject key) put: anObject.	tally := tally + 1! !!Dictionary methodsFor: 'private'!rehash	"Smalltalk rehash."	| newSelf |	newSelf := self species new: self size.	self associationsDo: [:each | newSelf noCheckAdd: each].	array := newSelf array! !!Dictionary methodsFor: 'private' stamp: 'md 10/5/2005 15:42'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Dictionary class methodsFor: 'instance creation'!newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary := self new: aDict size.	aDict associationsDo:		[:x |		(newDictionary includesKey: x key)			ifTrue: [self error: 'Duplicate key: ', x key printString]			ifFalse: [newDictionary add: x]].	^ newDictionary"	NewDictionary newFrom: {1->#a. 2->#b. 3->#c}	{1->#a. 2->#b. 3->#c} as: NewDictionary	NewDictionary newFrom: {1->#a. 2->#b. 1->#c}	{1->#a. 2->#b. 1->#c} as: NewDictionary"! !!DisplayTextView methodsFor: 'accessing'!centered	centered := true.	self centerText! !!DisplayTextView methodsFor: 'accessing'!fillColor: aForm 	"Set aForm to be the mask used when displaying the receiver's model."	mask := aForm! !!DisplayTextView methodsFor: 'accessing'!rule: anInteger 	"Set anInteger to be the rule used when displaying the receiver's model."	rule := anInteger! !!DisplayTextView methodsFor: 'initialize-release'!initialize 	"Refer to the comment in View|initialize."	super initialize.	centered := false! !!DisplayTextView methodsFor: 'model access'!model: aDisplayText 	"Refer to the comment in View|model:."	super model: aDisplayText.	editParagraph := model asParagraph.	self centerText! !!DisplayTextView methodsFor: 'private'!positionText	| box |	box := (self displayBox insetBy: 6@6) origin extent: editParagraph boundingBox extent.	editParagraph wrappingBox: box clippingBox: box.	self centerText! !!DisplayTextView class methodsFor: 'examples'!example2		"Create a standarad system view with two parts, one editable, the other not."	| topView aDisplayTextView |	topView := StandardSystemView new.	topView label: 'Text Editor'.	aDisplayTextView := self new model: 'test string label' asDisplayText.	aDisplayTextView controller: NoController new.	aDisplayTextView window: (0 @ 0 extent: 100 @ 100).	aDisplayTextView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	topView addSubView: aDisplayTextView.	aDisplayTextView := self new model: 'test string' asDisplayText.	aDisplayTextView window: (0 @ 0 extent: 100 @ 100).	aDisplayTextView borderWidth: 2.	topView		addSubView: aDisplayTextView		align: aDisplayTextView viewport topLeft		with: topView lastSubView viewport topRight.	topView controller open	"DisplayTextView example2"! !!DisplayTextView class methodsFor: 'examples'!example3		"Create a passive view of some text on the screen."	| view |	view:= self new model: 'this is a test of one lineand the second line' asDisplayText.	view translateBy: 100@100.		view borderWidth: 2.	view display.	view release	"DisplayTextView example3"! !!DisplayTextView class methodsFor: 'examples'!example4		"Create four passive views of some text on the screen with fat borders."	| view |	view:= self new model: 'this is a test of one lineand the second line' asDisplayText.	view translateBy: 100@100.		view borderWidth: 5.	view display.	3 timesRepeat: [view translateBy: 100@100. view display].	view release	"DisplayTextView example4"! !!Duration methodsFor: 'ansi protocol' stamp: 'gk 8/30/2006 23:42'!days	"Answer the number of days the receiver represents."	^ seconds quo: SecondsInDay! !!Duration methodsFor: 'ansi protocol' stamp: 'KLC 5/12/2008 13:42'!seconds	"Answer the number of seconds the receiver represents."	^seconds rem: SecondsInMinute! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 4/13/2006 10:20'!isZero	^ seconds = 0 and: [ nanos = 0 ]! !!Duration methodsFor: 'private' stamp: 'gk 8/31/2006 01:33'!seconds: secondCount nanoSeconds: nanoCount 	"Private - only used by Duration class"	seconds _ secondCount.	nanos _ nanoCount rounded! !!Duration methodsFor: 'private' stamp: 'gk 8/30/2006 23:41'!ticks	"Answer an array {days. seconds. nanoSeconds}. Used by DateAndTime and Time."	| days |	days _ self days.	^ Array 		with: days		with: seconds - (days * SecondsInDay)		with: nanos! !!Duration class methodsFor: 'ansi protocol' stamp: 'gk 8/31/2006 01:09'!days: days hours: hours minutes: minutes seconds: seconds	^ self days: days hours: hours minutes: minutes seconds: seconds nanoSeconds: 0! !!Duration class methodsFor: 'ansi protocol' stamp: 'gk 8/30/2006 23:18'!days: days seconds: seconds	^ self basicNew seconds: days * SecondsInDay + seconds nanoSeconds: 0! !!Duration class methodsFor: 'ansi protocol' stamp: 'gk 8/31/2006 01:34'!seconds: seconds	^ self seconds: seconds nanoSeconds: 0! !!Duration class methodsFor: 'ansi protocol' stamp: 'gk 8/31/2006 00:09'!zero	^ self basicNew seconds: 0 nanoSeconds: 0! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:25'!days: aNumber	^ self seconds: aNumber * SecondsInDay nanoSeconds: 0! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:26'!days: days hours: hours minutes: minutes seconds: seconds nanoSeconds: nanos	 	^ self seconds: ((days * SecondsInDay) 						+ (hours * SecondsInHour)							+ (minutes * SecondsInMinute) 								+ seconds)		nanoSeconds: nanos! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:07'!fromString: aString	^ self readFrom: (ReadStream on: aString)! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:26'!hours: aNumber	^ self seconds: aNumber * SecondsInHour nanoSeconds: 0! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:35'!milliSeconds: milliCount	"Since seconds is 0 we can call the instance directly."	^ self basicNew seconds: 0 nanoSeconds: milliCount * NanosInMillisecond! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:27'!minutes: aNumber	^ self seconds: aNumber * SecondsInMinute nanoSeconds: 0! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:30'!nanoSeconds: nanos	"This method is slow. If you have nanos less than 10^6 you should use #seconds:nanoSeconds: instead."	| quo |	quo _ nanos quo: NanosInSecond.	^ self basicNew		seconds: quo		nanoSeconds: nanos - (quo * NanosInSecond)! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:32'!seconds: seconds nanoSeconds: nanos	^ self basicNew		seconds: seconds truncated		nanoSeconds: seconds fractionPart * NanosInSecond + nanos! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/30/2006 23:20'!weeks: aNumber	^ self days: (aNumber * 7) seconds: 0! !!DurationTest methodsFor: 'testing' stamp: 'KLC 5/12/2008 13:41'!testSeconds	self assert: aDuration seconds =   4.	self assert: (Duration  nanoSeconds: 2) seconds = 0.	self assert: (Duration nanoSeconds: 999999999) seconds = 0.	self assert: (Duration nanoSeconds: 1000000001) seconds = 1.	self assert: (Duration  seconds: 2) seconds = 2.		self assert: (Duration  days: 1 hours: 2 minutes: 3 seconds:4) seconds = 4.	self deny: (Duration  days: 1 hours: 2 minutes: 3 seconds:4) seconds = (1*24*60*60+(2*60*60)+(3*60)+4).	! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:26'!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f := SimpleButtonMorph new		target: self;		label: aString;		color: aColor;		borderColor: aColor muchDarker;		actionSelector: aSymbol;		setBalloonText: helpString.	self field: aSymbol is: f.	col := (self inAColumn: {f}) hResizing: #shrinkWrap.	^col! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 05:57'!commResult: anArrayOfAssociations	| aDictionary |	aDictionary := Dictionary new.	anArrayOfAssociations do: [ :each | aDictionary add: each].	resultQueue nextPut: aDictionary! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/8/2000 18:33'!editEvent: anEvent for: aMorph	| answer |	(aMorph bounds containsPoint: anEvent cursorPoint) ifFalse: [^self].	answer := FillInTheBlankMorph		request: 'Enter a new ',aMorph balloonText		initialAnswer: aMorph contents.	answer isEmptyOrNil ifTrue: [^self].	aMorph contents: answer! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 10:05'!flashIndicator: aSymbol	| now |	now := Time millisecondClockValue.	(LastFlashTime notNil and: [(Time millisecondClockValue - now) abs < 500]) ifTrue: [^self].	LastFlashTime := now.	self trulyFlashIndicator: aSymbol! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 16:42'!handleResult: aDictionary	| m |	aDictionary at: #commFlash ifPresent: [ :ignore | ^self flashIndicator: #communicating].	self resetIndicator: #communicating.	m := aDictionary at: #message ifAbsent: ['unknown message'].	m = 'OK' ifTrue: [^self].	self reportError: m! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 17:32'!indicatorFieldNamed: aSymbol color: aColor help: helpString	| f col |	f := EllipseMorph new		extent: 10@10;		color: aColor;		setBalloonText: helpString.	self field: aSymbol is: f.	col := (self inAColumn: {f}) hResizing: #shrinkWrap.	^col! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 08:18'!resetIndicator: aSymbol	| indicator firstColor |	indicator := fields at: aSymbol ifAbsent: [^self].	firstColor := indicator 		valueOfProperty: #firstColor		ifAbsent: [^self].	indicator color: firstColor.	self world displayWorldSafely.! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/8/2000 18:35'!textEntryFieldNamed: aSymbol with: aString help: helpString	| f col |	f := (StringMorph new contents: aString)		setBalloonText: helpString;		on: #mouseUp send: #editEvent:for: to: self.	self field: aSymbol is: f.	col := (self inAColumn: {f}) color: Color white; hResizing: #shrinkWrap.	^col! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 10:05'!trulyFlashIndicator: aSymbol	| indicator firstColor |	indicator := fields at: aSymbol ifAbsent: [^self].	firstColor := indicator 		valueOfProperty: #firstColor		ifAbsent: [			indicator setProperty: #firstColor toValue: indicator color.			indicator color		].	indicator color: (indicator color = firstColor ifTrue: [Color white] ifFalse: [firstColor]).	self world displayWorldSafely.! !!EToyCommunicatorMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:32'!initialize	"initialize the state of the receiver"	super initialize.	""	self vResizing: #shrinkWrap;	 hResizing: #shrinkWrap.	resultQueue := SharedQueue new.	fields := Dictionary new.	self useRoundedCorners! !!EToyCommunicatorMorph methodsFor: 'stepping and presenter' stamp: 'RAA 7/10/2000 10:14'!step	| state |	[resultQueue isEmpty] whileFalse: [		self handleResult: resultQueue next	].	(state := self valueOfProperty: #flashingState ifAbsent: [0]) > 0 ifTrue: [		self borderColor: (			(self valueOfProperty: #flashingColors ifAbsent: [{Color green. Color red}]) atWrap: state		).		self setProperty: #flashingState toValue: state + 1	].! !!EToyCommunicatorMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 16:13'!instanceReport	"for cleaning up Alan's demo""EToySenderMorph instanceReport"	| answer resp |	Smalltalk garbageCollect.	answer := self allInstances collect: [ :each |		{			each.			[each ipAddress] on: Error do: [ 'no ipAddress'].			each owner 					ifNil: ['* no owner *'] 					ifNotNil: [each owner innocuousName,' ',each owner printString].			each world ifNil: ['-----no project-----'] ifNotNil: [each world project name].		}	].	resp := (PopUpMenu labels: 'IP Address\Project\Owner' withCRs) startUpWithCaption: 					'Sorted by'.	resp = 1 ifTrue: [		^(answer asSortedCollection: [ :a :b | a second <= b second]) asArray explore	].	resp = 2 ifTrue: [		^(answer asSortedCollection: [ :a :b | a fourth <= b fourth]) asArray explore	].	resp = 3 ifTrue: [		^(answer asSortedCollection: [ :a :b | a third <= b third]) asArray explore	].	answer explore! !!EToyGenericDialogMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:54'!initialize	"initialize the state of the receiver"super initialize.""	namedFields := Dictionary new.		self rebuild! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 09:57'!genericMenu: aMenu	| menu |	currentSelection ifNil: [		aMenu add: '*nothing selected*' target: self selector: #yourself.		^aMenu	].	menu := DumberMenuMorph new defaultTarget: self.	menu 		add: 'expand all below me' target: self selector: #expandAllBelow;		add: 'addChild' target: self selector: #addChild;		add: 'delete' target: self  selector: #deleteSelectedItem.	^ menu! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 10:36'!inAWindow	| window  |	window := (SystemWindow labelled: 'HText') model: self.	window 		addMorph: self notInAWindow		frame: (0@0 corner: 1@1).     ^ window! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 09:43'!notInAWindow	| listMorph |	(listMorph := EToyHierarchicalTextMorph 		on: self		list: #getList		selected: #getCurrentSelection		changeSelected: #noteNewSelection:		menu: #genericMenu:		keystroke: nil).	listMorph autoDeselect: false.     ^ listMorph! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 00:40'!topNode: aTextNode	topNode := aTextNode! !!EToyHierarchicalTextMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 02:08'!adjustSubmorphPositions	| p h w |	p := 0@0.	w := self width.	scroller submorphsDo: [ :each |		h := each position: p andWidth: w.		p := p + (0@h)	].	self 		changed;		layoutChanged;		setScrollDeltas.! !!EToyHierarchicalTextMorph methodsFor: 'geometry' stamp: 'RAA 7/30/2000 01:50'!extent: aPoint	| wasDifferent |	wasDifferent := self extent ~= aPoint.	super extent: aPoint.	wasDifferent ifTrue: [self adjustSubmorphPositions].! !!EToyHierarchicalTextMorph methodsFor: 'selection' stamp: 'RAA 7/30/2000 10:05'!selectedMorph: aMorph	selectedMorph == aMorph ifTrue: [^self].	self unhighlightSelection.	selectedMorph := aMorph.	self highlightSelection! !!EToyHierarchicalTextMorph class methodsFor: 'instance creation' stamp: 'RAA 8/8/2000 14:34'!new	| listMorph model |	model := EToyHierarchicalTextGizmo new 		topNode: EToyTextNode newNode.	(listMorph := EToyHierarchicalTextMorph 		on: model		list: #getList		selected: #getCurrentSelection		changeSelected: #noteNewSelection:		menu: #genericMenu:		keystroke: nil).	listMorph autoDeselect: false.     ^ listMorph! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2001 20:56'!copyOutDetails	| newDetails |	newDetails := Dictionary new.	self fieldToDetailsMappings do: [ :each |		namedFields at: each first ifPresent: [ :field |			newDetails at: each second put: field contents string		].	].	namedFields at: 'projectname' ifPresent: [ :field |		newDetails at: 'projectname' put: field contents string withBlanksTrimmed.	].	^newDetails! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 12:45'!project: aProject actionBlock: aBlock	theProject := aProject.	actionBlock := aBlock.	projectDetails := theProject world valueOfProperty: #ProjectDetails ifAbsent: [Dictionary new]! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 11:08'!projectDetails: aDictionary	projectDetails := aDictionary.! !!EToyProjectDetailsMorph methodsFor: 'initialization' stamp: 'dgd 11/3/2004 17:55'!rebuild	| bottomButtons |	self removeAllMorphs.	self addARow: {		self			lockedString: 'Please describe this project' translated			font: Preferences standardEToysTitleFont.	}.	self addARow: {self space }.	self addARow: {		self rightLockedString: 'Name:' translated.		self inAColumnForText: {self fieldForProjectName}	}.	self expandedFormat ifTrue: [		self fieldToDetailsMappings do: [ :each |			self addARow: {				self rightLockedString: each third translated.				self inAColumnForText: {(self genericTextFieldNamed: each first) height: each fourth}			}.		].	].	self addARow: {self space }.	bottomButtons := self expandedFormat		ifTrue: [ { self okButton. self cancelButton } ]		ifFalse: [ { self okButton. self expandButton. self cancelButton } ].	self addARow: bottomButtons.	self fillInDetails.! !!EToyProjectDetailsMorph class methodsFor: 'as yet unclassified' stamp: 'tak 3/15/2005 15:52'!getFullInfoFor: aProject ifValid: aBlock expandedFormat: expandedFormat	| me |	(me := self basicNew)		expandedFormat: expandedFormat;		project: aProject		actionBlock: [ :x | 			aProject world setProperty: #ProjectDetails toValue: x.			x at: 'projectname' ifPresent: [ :newName | 				aProject renameTo: newName.			].			me delete.			aBlock value.		];		initialize;		becomeModal;		openCenteredInWorld! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'ar 9/28/2000 13:53'!closeMyFlapIfAny	| myFlap allTabs myTab myWorld |	myWorld := self world.	myFlap := self nearestOwnerThat: [ :each | each isFlap].	myFlap ifNil: [^self].	allTabs := myWorld submorphs select: [ :each | each isFlapTab].	myTab := allTabs detect: [ :each | each referent == myFlap] ifNone: [^self].	myTab hideFlap.	myWorld displayWorldSafely.	! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 12:02'!jumpToProject	| selection |	selection := (Project buildJumpToMenu: CustomMenu new) startUp.	self closeMyFlapIfAny.	Project jumpToSelection: selection! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/27/2000 22:47'!mouseMove: evt in: aMorph	| start tuple project url pvm |	start := aMorph valueOfProperty: #mouseDownPoint ifAbsent: [^self].	(start dist: evt cursorPoint) abs < 5 ifTrue: [^self].	aMorph removeProperty: #mouseDownPoint.	evt hand hasSubmorphs ifTrue: [^self].	tuple := aMorph valueOfProperty: #projectParametersTuple ifAbsent: [^self].	project := tuple fourth first.	(project notNil and: [project world notNil]) ifTrue: [		^evt hand attachMorph: (ProjectViewMorph on: project).	].	url := tuple third.	url isEmptyOrNil ifTrue: [^self].	pvm := ProjectViewMorph new.	pvm		project: (DiskProxy global: #Project selector: #namedUrl: args: {url});		lastProjectThumbnail: tuple second.	evt hand attachMorph: pvm.! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'nb 6/17/2003 12:25'!mouseUp: evt in: aMorph	| tuple project url |	(aMorph boundsInWorld containsPoint: evt cursorPoint) ifFalse: [^self].	tuple := aMorph valueOfProperty: #projectParametersTuple ifAbsent: [^Beeper beep].	project := tuple fourth first.	(project notNil and: [project world notNil]) ifTrue: [self closeMyFlapIfAny. ^project enter].	url := tuple third.	url isEmptyOrNil ifTrue: [^Beeper beep].	self closeMyFlapIfAny.	ProjectLoading thumbnailFromUrl: url."---	newTuple := {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.---"! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'dgd 9/20/2003 18:52'!rebuild	| history r1 |	history := ProjectHistory currentHistory mostRecentCopy.	changeCounter := ProjectHistory changeCounter.	self removeAllMorphs.	self rubberBandCells: false. "enable growing"	r1 := self addARow: {		self inAColumn: {			StringMorph new contents: 'Jump...' translated; lock.		}.	}.	r1 on: #mouseUp send: #jumpToProject to: self.	history do: [ :each |		(			self addARow: {				(self inAColumn: {					StretchyImageMorph new form: each second; minWidth: 35; minHeight: 35; lock				}) vResizing: #spaceFill.				self inAColumn: {					StringMorph new contents: each first; lock.					"StringMorph new contents: each third; lock."				}.			}		)			color: Color paleYellow;			borderWidth: 1;			borderColor: #raised;			vResizing: #spaceFill;			on: #mouseUp send: #mouseUp:in: to: self;			on: #mouseDown send: #mouseDown:in: to: self;			on: #mouseMove send: #mouseMove:in: to: self;			on: #mouseLeave send: #mouseLeave:in: to: self;			setProperty: #projectParametersTuple toValue: each;			setBalloonText: (each third isEmptyOrNil ifTrue: ['not saved'] ifFalse: [each third])	]."---	newTuple := {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.---"! !!EToyProjectQueryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/18/2000 12:18'!project: ignored actionBlock: aBlock	actionBlock := aBlock.	projectDetails := Dictionary new.! !!EToyProjectQueryMorph class methodsFor: 'as yet unclassified' stamp: 'tak 3/15/2005 16:37'!onServer: aProjectServer	"EToyProjectQueryMorph onServer: SuperSwikiServer testOnlySuperSwiki"	| criteria clean |	(self basicNew)		project: nil		actionBlock: [ :x | 			criteria := OrderedCollection new.			x keysAndValuesDo: [ :k :v |				(clean := v withBlanksTrimmed) isEmpty					ifFalse: [criteria add: k,': *',clean,'*']].			aProjectServer queryProjectsAndShow: criteria];		initialize;		becomeModal;		openCenteredInWorld! !!EToyProjectQueryMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 10/18/2000 12:34'!test1: aProject"EToyProjectQueryMorph test1: nil"	| criteria clean |	(self basicNew)		project: aProject		actionBlock: [ :x | 			criteria := OrderedCollection new.			x keysAndValuesDo: [ :k :v |				(clean := v withBlanksTrimmed) isEmpty ifFalse: [					criteria add: k,': *',clean,'*'				].			].			SuperSwikiServer testOnlySuperSwiki queryProjectsAndShow: criteria		];		initialize;		openCenteredInWorld! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:25'!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f := SimpleButtonMorph new		target: self;		label: aString translated font: self myFont;		color: aColor;		borderColor: aColor muchDarker;		actionSelector: aSymbol;		setBalloonText: helpString translated.	col := (self inAColumn: {f}) hResizing: #spaceFill.	^col! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'yo 2/23/2005 17:25'!fieldForProjectName	| tm |	tm := self genericTextFieldNamed: 'projectname'.	tm crAction: (MessageSend receiver: self selector: #doOK).	tm setBalloonText: 'Pick a name 24 characters or less and avoid the following characters: : < > | / \ ? * " .' translated.	^tm	! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 13:55'!project: aProject actionBlock: aBlock	theProject := aProject.	actionBlock := aBlock.	(namedFields at: 'projectname') contentsWrapped: theProject name.! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'pk 10/17/2006 09:39'!validateTheProjectName	| proposed |	proposed _ (namedFields at: 'projectname') contents string withBlanksTrimmed.	proposed isEmpty ifTrue: [		self inform: 'I do need a name for the project' translated.		^false	].	proposed size > 24 ifTrue: [		self inform: 'Please make the name 24 characters or less' translated.		^false	].	(Project isBadNameForStoring: proposed) ifTrue: [		self inform: 'Please remove any funny characters from the name' translated.		^false	].	proposed = theProject name ifTrue: [^true].	(ChangesOrganizer changeSetNamed: proposed) ifNotNil: [		Utilities inform: 'Sorry that name is already used' translated.		^false	].	^true! !!EToySystem class methodsFor: 'development support' stamp: 'sd 5/11/2003 22:13'!loadJanForms	"EToySystem loadJanForms"	| aReferenceStream newFormDict |	aReferenceStream := ReferenceStream fileNamed: 'JanForms'.	newFormDict := aReferenceStream next.	aReferenceStream close.	newFormDict associationsDo:		[:assoc | Imports default importImage: assoc value named: assoc key]! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 10:05'!addNewChildAfter: anotherOrNilOrZero	| where newNode |	anotherOrNilOrZero == 0 ifTrue: [		newNode := EToyTextNode newNode.		children := {newNode} asOrderedCollection,children.		^newNode	].	where := children indexOf: anotherOrNilOrZero ifAbsent: [children size].	children add: (newNode := EToyTextNode newNode) afterIndex: where.	^newNode! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 10:33'!firstDisplayedOnLevel: level	firstDisplay := false.	text addAttribute: (TextFontChange fontNumber: ((5 - level) max: 1)).! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 09:53'!showInOpenedState	| answer |	answer := self valueOfProperty: #showInOpenedState ifAbsent: [false].	self removeProperty: #showInOpenedState.	^answer! !!EToyTextNode methodsFor: 'initialization' stamp: 'RAA 7/30/2000 17:09'!initialize	| newStyle |	super initialize.	firstDisplay := true.	children := OrderedCollection new.	(newStyle := TextStyle named: #Palatino) ifNotNil: [		textStyle := newStyle copy defaultFontIndex: 2	].! !!EToyTextNodeWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 11:51'!parentWrapper: anotherWrapper	parentWrapper := anotherWrapper! !!EToyVocabulary methodsFor: 'initialization' stamp: 'sw 12/18/2000 14:33'!includesSelector: aSelector forInstance: anInstance ofClass: aTargetClass limitClass: mostGenericClass	"Answer whether the vocabulary includes the given selector for the given class (and instance, if provided), only considering method implementations in mostGenericClass and lower"	| classToUse aClass theKeys |	(aTargetClass isUniClass and:		[(aTargetClass namedTileScriptSelectors includes: aSelector) or:			[(((theKeys := aTargetClass slotInfo keys collect:				[:anInstVarName | Utilities getterSelectorFor: anInstVarName])) includes: aSelector)					or:						[(theKeys collect: [:anInstVarName | Utilities setterSelectorFor: anInstVarName]) includes: aSelector]]]) ifTrue: [^ true].	(methodInterfaces includesKey: aSelector) ifFalse: [^ false].	classToUse := self classToUseFromInstance: anInstance ofClass: aTargetClass.	^ (aClass := classToUse whichClassIncludesSelector: aSelector)		ifNil:			[false]		ifNotNil:			[aClass includesBehavior: mostGenericClass]! !!EToyVocabulary methodsFor: 'method list' stamp: 'sw 10/7/2004 17:09'!allMethodsInCategory: aCategoryName forInstance: anObject ofClass: aClass	"Answer a list of all methods in the etoy interface which are in the given category, on behalf of anObject, or if it is nil, aClass"	| aCategory unfiltered suitableSelectors isAll |	aCategoryName ifNil: [^ OrderedCollection new].	aClass isUniClass ifTrue:		[aCategoryName = ScriptingSystem nameForScriptsCategory ifTrue:			[^ aClass namedTileScriptSelectors].		aCategoryName = ScriptingSystem nameForInstanceVariablesCategory ifTrue:			[^ aClass slotInfo keys asSortedArray collect:				[:anInstVarName | Utilities getterSelectorFor: anInstVarName]]].	unfiltered := (isAll := aCategoryName = self allCategoryName)		ifTrue:			[methodInterfaces collect: [:anInterface | anInterface selector]]		ifFalse:			[aCategory := categories detect: [:cat | cat categoryName = aCategoryName] 							ifNone: [^ OrderedCollection new].			aCategory elementsInOrder collect: [:anElement | anElement selector]].	(anObject isKindOf: Player) ifTrue:		[suitableSelectors := anObject costume selectorsForViewer.		unfiltered := unfiltered  select:			[:aSelector | suitableSelectors includes: aSelector]].	(isAll and: [aClass isUniClass]) ifTrue:		[unfiltered addAll: aClass namedTileScriptSelectors.		unfiltered addAll: (aClass slotInfo keys asSortedArray collect:			[:anInstVarName | Utilities getterSelectorFor: anInstVarName])].	^ (unfiltered copyWithoutAll: #(dummy unused)) asSortedArray! !!EmphasizedMenu methodsFor: 'emphasis'!emphases: emphasisArray	emphases := emphasisArray! !!EmphasizedMenu methodsFor: 'emphasis' stamp: 'fc 2/19/2004 22:07'!onlyBoldItem: itemNumber	"Set up emphasis such that all items are plain except for the given item number.  "	emphases := (Array new: selections size) atAllPut: #normal.	emphases at: itemNumber put: #bold! !!EmphasizedMenu methodsFor: 'private' stamp: 'fc 2/20/2004 11:01'!setEmphasis	"Set up the receiver to reflect the emphases in the emphases array.  "	| selStart selEnd currEmphasis |		labelString := labelString asText.	emphases isEmptyOrNil ifTrue: [^ self].	selStart := 1.	1 to: selections size do:		[:line |			selEnd := selStart + (selections at: line) size - 1.			((currEmphasis := emphases at: line) size > 0 and: [currEmphasis ~~ #normal]) ifTrue:				[labelString addAttribute: (TextEmphasis perform: currEmphasis)					from: selStart to: selEnd].			selStart := selEnd + 2]! !!EmphasizedMenu class methodsFor: 'examples' stamp: 'sw 9/11/97 16:14'!example2	"EmphasizedMenu example2"	| aMenu |	aMenu := EmphasizedMenu selections: #('One' 'Two' 'Three' 'Four').	aMenu onlyBoldItem: 3.	^ aMenu startUpWithCaption: 'Only the Bold'! !!EmphasizedMenu class methodsFor: 'instance creation' stamp: 'sw 12/23/96'!selectionAndEmphasisPairs: interleavedList	"An alternative form of call.  "	| selList  emphList |	selList := OrderedCollection new.	emphList := OrderedCollection new.	interleavedList pairsDo:		[:aSel :anEmph |			selList add: aSel.			emphList add: anEmph].	^ self selections:selList emphases: emphList! !!EtoyLoginMorph methodsFor: 'actions' stamp: 'dgd 10/8/2003 18:58'!doOK	| proposed |	proposed := theNameMorph contents string.	proposed isEmpty ifTrue: [^self inform: 'Please enter your login name' translated].	proposed size > 24 ifTrue: [^self inform: 'Please make the name 24 characters or less' translated].	(Project isBadNameForStoring: proposed) ifTrue: [		^self inform: 'Please remove any funny characters' translated	].	(actionBlock value: proposed) ifTrue:[self delete].! !!EtoyLoginMorph methodsFor: 'building' stamp: 'dgd 11/2/2004 21:26'!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f := SimpleButtonMorph new		target: self;		label: aString font: self myFont;		color: aColor;		borderColor: aColor muchDarker;		actionSelector: aSymbol;		setBalloonText: helpString.	col := (self inAColumn: {f}) hResizing: #spaceFill.	^col! !!EtoyLoginMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 16:01'!defaultColor	"answer the default color/fill style for the receiver"	| result |	result := GradientFillStyle ramp: {0.0					-> (Color							r: 0.5							g: 0.5							b: 1.0). 1.0					-> (Color							r: 0.8							g: 0.8							b: 1.0)}.	result origin: self bounds origin.	result direction: 0 @ self bounds height.	^ result! !!EtoyLoginMorph methodsFor: 'initialize' stamp: 'ar 9/24/2000 00:09'!name: aString actionBlock: aBlock cancelBlock: altBlock	theName := aString.	actionBlock := aBlock.	cancelBlock := altBlock.	theNameMorph contentsWrapped: theName.	theNameMorph editor selectAll.! !!EtoyLoginMorph methodsFor: 'initialize' stamp: 'ar 9/23/2000 23:52'!rebuild	self removeAllMorphs.	self addARow: { (StringMorph contents:'') lock }.	self addARow: {		(StringMorph contents: 'Please enter your Squeak login name' font: self myFont) lock.	}.	(self addARow: {		(theNameMorph := TextMorph new			beAllFont: self myFont;			crAction: (MessageSend receiver: self selector: #doOK);			extent: 300@20;			contentsWrapped: 'the old name';			setBalloonText: 'Enter your name and avoid the following characters: : < > | / \ ? * "'			).	}) color: Color white; borderColor: Color black; borderWidth: 1.	self addARow: {		self okButton.		self cancelButton.	}.	self addARow: { (StringMorph contents:'') lock }.! !!EtoyLoginMorph class methodsFor: 'instance creation' stamp: 'ar 8/23/2001 21:37'!loginAndDo: aBlock ifCanceled: cancelBlock	"EtoyLoginMorph loginAndDo:[:n| true] ifCanceled:[]"	| me |	(me := self new)		name: 'your name' actionBlock: aBlock cancelBlock: cancelBlock;		fullBounds;		position: Display extent - me extent // 2;		openInWorld.	me position: me position + (0@40).! !!EtoyUpdatingThreePhaseButtonMorph methodsFor: 'stepping and presenter' stamp: 'RAA 7/11/2000 12:18'!step	| newBoolean |	state == #pressed ifTrue: [^ self].	newBoolean := target perform: getSelector withArguments: arguments.	newBoolean == self isOn		ifFalse:			[self state: (newBoolean ifTrue: [#on] ifFalse: [#off])]! !!EtoyUpdatingThreePhaseButtonMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/8/2000 13:34'!setFormsCheckedForm := (Form	extent: 12@12	depth: 32	fromArray: #( 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 4278190081 4278190081 4278190081 0 0 0 0 0 0 0 0 4278190081 2003331177 4278190081 4278190081 0 0 0 0 0 0 0 4278190081 2003331177 0 4278190081 4278190081 0 0 0 0 0 0 4278190081 2003331177 0 0 4278190081 4278190081 0 4278190081 0 0 0 4278190081 2003331177 0 0 0 4278190081 4278190081 0 2003331177 4278190081 0 4278190081 2003331177 0 0 0 0 4278190081 4278190081 0 0 2003331177 4278190081 2003331177 0 0 0 0 0 4278190081 4278190081 0 0 0 2003331177 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081)	offset: 0@0).MouseDownForm := UncheckedForm := (Form	extent: 12@12	depth: 32	fromArray: #( 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081)	offset: 0@0)! !!EventHandler methodsFor: '*eToys-initialization' stamp: 'jcg 9/21/2001 12:57'!forgetDispatchesTo: aSelector	"aSelector is no longer implemented by my corresponding Player, so don't call it any more"	mouseDownSelector == aSelector		ifTrue: [mouseDownRecipient := mouseDownSelector := nil].	mouseMoveSelector == aSelector		ifTrue: [mouseMoveRecipient := mouseMoveSelector := nil].	mouseStillDownSelector == aSelector		ifTrue: [mouseStillDownRecipient := mouseStillDownSelector := nil].	mouseUpSelector == aSelector		ifTrue: [mouseUpRecipient := mouseUpSelector := nil].	mouseEnterSelector == aSelector		ifTrue: [mouseEnterRecipient := mouseEnterSelector := nil].	mouseLeaveSelector == aSelector		ifTrue: [mouseLeaveRecipient := mouseLeaveSelector := nil].	mouseEnterDraggingSelector == aSelector		ifTrue: [mouseEnterDraggingRecipient := mouseEnterDraggingSelector := nil].	mouseLeaveDraggingSelector == aSelector		ifTrue: [mouseLeaveDraggingRecipient := mouseLeaveDraggingSelector := nil].	clickSelector == aSelector		ifTrue: [clickRecipient := clickSelector := nil].	doubleClickSelector == aSelector		ifTrue: [doubleClickRecipient := doubleClickSelector := nil].	doubleClickTimeoutSelector == aSelector		ifTrue: [doubleClickTimeoutRecipient := doubleClickTimeoutSelector := nil].	keyStrokeSelector == aSelector		ifTrue: [keyStrokeRecipient := keyStrokeSelector := nil].! !!FileList methodsFor: 'own services' stamp: 'edc 4/24/2007 09:49'!viewContentsInWorkspace	"View the contents of my selected file in a new workspace"		| aString aFileStream aName |	aString := (aFileStream := directory readOnlyFileNamed: self fullName) setConverterForCode contentsOfEntireFile.	aName := aFileStream localName.	aFileStream close.	UIManager default edit: aString withSqueakLineEndings label: 'Workspace from ', aName! !!FilePackage methodsFor: 'conflict checker' stamp: 'pk 10/17/2006 09:39'!checkForMoreRecentUpdateThanChangeSet: updateNumberChangeSet pseudoClass: pseudoClass selector: selector	"Returns the source code for a conflict if a conflict is found, otherwise returns nil."	| classOrMeta allChangeSets moreRecentChangeSets conflictingChangeSets changeRecordSource classAndMethodPrintString |	classAndMethodPrintString _ pseudoClass name, (pseudoClass hasMetaclass ifTrue: [' class'] ifFalse: ['']), '>>', selector asString.	changeRecordSource _ pseudoClass sourceCode at: selector.	changeRecordSource isText		ifTrue: [changeRecordSource _ Text					fromString: 'method: ', classAndMethodPrintString, ' was removed']		ifFalse: [changeRecordSource stamp isEmptyOrNil ifTrue:					[self notify: 'Warning: ', classAndMethodPrintString, ' in ', self packageName, ' has no timestamp/initials!!']].	pseudoClass exists ifFalse:		[(self classes at: pseudoClass name) hasDefinition			ifTrue: [^ nil  "a method was added for a newly defined class; not a conflict"]			ifFalse: [self class logCr; log: 'CONFLICT found for ', classAndMethodPrintString, '... class ', pseudoClass name asString, ' does not exist in the image and is not defined in the file'.					^ changeRecordSource]].	classOrMeta _ pseudoClass realClass.	"Only printout the replacing methods here, but we still check for removed methods too in the rest of this method."	(self class verboseConflicts and: [classOrMeta includesSelector: selector])		ifTrue: [self class logCr; log: '...checking ', classOrMeta asString, '>>', selector asString].	allChangeSets _ ChangesOrganizer allChangeSets.	moreRecentChangeSets _ allChangeSets				copyFrom: (allChangeSets indexOf: updateNumberChangeSet)				to: (allChangeSets size).	conflictingChangeSets _ (moreRecentChangeSets select:		[:cs | (cs atSelector: selector class: classOrMeta) ~~ #none]).	conflictingChangeSets isEmpty ifTrue: [^ nil].	self class logCr; log: 'CONFLICT found for ', classAndMethodPrintString,				(' with newer changeset' asPluralBasedOn: conflictingChangeSets).	conflictingChangeSets do: [:cs | self class log: ' ', cs name].	^ changeRecordSource! !!FilePackage methodsFor: 'conflict checker' stamp: 'pk 10/17/2006 09:39'!findUpdateChangeSetMatching: updateNumber	"Find update-changeset beginning with updateNumber, or reasonably close."	"This is to account for the fact that many changeset files are output from final releases, but may be tested for conflicts in a following alpha image, which will often not include that particular update-changeset from the final release but will contain ones near it.  For example, if the file updateNumber is 5180 (from 3.5 final), but the image has no update-changeset beginning with 5180 because it's a 3.6alpha image (which starts at 5181), it will try up to 5190 and down to 5170 for a close match."	| updateNumberChangeSet updateNumberToTry |	updateNumberToTry _ updateNumber.	updateNumberChangeSet _ nil.	[updateNumberChangeSet isNil and: [updateNumberToTry notNil]] whileTrue:		[updateNumberChangeSet _ ChangesOrganizer allChangeSets			detect: [:cs | (cs name beginsWith: updateNumberToTry asString)							and: [(cs name at: (updateNumberToTry asString size + 1)) isDigit not]]			ifNone: [nil].		updateNumberToTry >= updateNumber ifTrue:			[updateNumberToTry < (updateNumber + 10)				ifTrue: [updateNumberToTry _ updateNumberToTry + 1]				ifFalse: [updateNumberToTry _ updateNumber]].		updateNumberToTry <= updateNumber ifTrue:			[updateNumberToTry > (updateNumber - 10)				ifTrue: [updateNumberToTry _ updateNumberToTry - 1]				ifFalse: [updateNumberToTry _ nil  "we're done trying"]].		].	updateNumberChangeSet ifNil:		[(self confirm: 'Warning: No changeset beginning with ',updateNumber asString, ' (within +/- 10) was found in the image.You must have changesets going back this far in your imagein order to accurately check for conflicts.Proceed anyway?')			ifTrue: [updateNumberChangeSet _ ChangesOrganizer allChangeSets first]].	^ updateNumberChangeSet! !!FilePackage methodsFor: 'reading' stamp: 'edc 4/1/2007 07:58'!fromStream: aStream named: aName	| chgRec changes |	changes := ChangeSet scanFile: aStream from: 0 to: aStream size.	aStream close.	('Processing ', aName) 		displayProgressAt: Sensor cursorPoint		from: 1		to: changes size		during:[:bar|			1 to: changes size do:[:i|				bar value: i.				chgRec := changes at: i.				self perform: (chgRec type copyWith: $:) asSymbolwith: chgRec.			].		].! !!FilePackage class methodsFor: 'instance creation' stamp: 'edc 4/1/2007 07:57'!fromStream: aStream named: aName	^self new fromStream: aStream named: aName! !!FileStream methodsFor: 'fileIn/Out' stamp: 'pk 10/17/2006 09:39'!fileIntoNewChangeSet	"File all of my contents into a new change set." 	self readOnly.	ChangesOrganizer newChangesFromStream: self named: (self localName)! !!FillInTheBlank methodsFor: 'accessing' stamp: 'jm 4/28/1998 06:18'!acceptOnCR: aBoolean	acceptOnCR := aBoolean.! !!FillInTheBlank methodsFor: 'accessing' stamp: 'jm 5/6/1998 15:13'!done: aBoolean	done := aBoolean.! !!FillInTheBlank methodsFor: 'accessing' stamp: 'sw 1/31/2000 14:45'!responseUponCancel: resp	responseUponCancel := resp! !!FillInTheBlank methodsFor: 'initialize-release' stamp: 'sw 1/31/2000 14:42'!initialize	super initialize.	acceptOnCR := false.	done := false.	responseUponCancel := ''! !!FillInTheBlank methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:59'!convertToCurrentVersion: varDict refStream: smartRefStrm		varDict at: 'responseUponCancel' ifAbsent: [responseUponCancel := ''].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!FillInTheBlank methodsFor: 'private' stamp: 'sma 6/18/2000 10:54'!show: fillInView	| savedArea |	savedArea := Form fromDisplay: fillInView displayBox.	fillInView display.	contents isEmpty		ifFalse: [fillInView lastSubView controller selectFrom: 1 to: contents size].	(fillInView lastSubView containsPoint: Sensor cursorPoint)		ifFalse: [fillInView lastSubView controller centerCursorInView].	fillInView controller startUp.	fillInView release.	savedArea displayOn: Display at: fillInView viewport topLeft.	^ contents! !!FillInTheBlankController methodsFor: 'basic control sequence' stamp: 'th 9/17/2002 16:46'!controlInitialize	model acceptOnCR ifFalse: [^ super controlInitialize].	self setMark: self markBlock stringIndex.	self setPoint: self pointBlock stringIndex.	self initializeSelection.	beginTypeInBlock := nil.! !!FillInTheBlankController methodsFor: 'basic control sequence' stamp: 'jm 5/6/1998 15:11'!controlTerminate	| topController |	super controlTerminate.	topController := view topView controller.	topController ifNotNil: [topController close].! !!FillInTheBlankView class methodsFor: 'instance creation' stamp: 'jm 4/28/1998 08:35'!multiLineOn: aFillInTheBlank message: queryString centerAt: aPoint answerHeight: answerHeight	"Answer an instance of me on aFillInTheBlank asking the question queryString. Allow the reply to be multiple lines, and make the user input view the given height."	| messageView answerView topView |	messageView := DisplayTextView new		model: queryString asDisplayText;		borderWidthLeft: 2 right: 2 top: 2 bottom: 0;		controller: NoController new.	messageView		window: (0@0 extent: (messageView window extent max: 200@30));		centered.	answerView := self new		model: aFillInTheBlank;		window: (0@0 extent: (messageView window width@answerHeight));		borderWidth: 2.	topView := View new model: aFillInTheBlank.	topView controller: ModalController new.	topView addSubView: messageView.	topView addSubView: answerView below: messageView.	topView align: topView viewport center with: aPoint.	topView window:		(0 @ 0 extent:			(messageView window width) @			  (messageView window height + answerView window height)).	topView translateBy:		(topView displayBox amountToTranslateWithin: Display boundingBox).	^ topView! !!FillInTheBlankView class methodsFor: 'instance creation' stamp: 'jdr 6/4/2000 15:03'!requestPassword: aFillInTheBlank message: queryString centerAt: aPoint answerHeight: answerHeight	"Answer an instance of me on aFillInTheBlank asking the question queryString. Allow the reply to be multiple lines, and make the user input view the given height."	| messageView answerView topView myPar pwdFont myArray myStyle |	aFillInTheBlank acceptOnCR: true.	messageView := DisplayTextView new		model: queryString asDisplayText;		borderWidthLeft: 2 right: 2 top: 2 bottom: 0;		controller: NoController new.	messageView		window: (0@0 extent: (messageView window extent max: 200@30));		centered.	answerView := self new		model: aFillInTheBlank;		window: (0@0 extent: (messageView window width@answerHeight));		borderWidth: 2.	" now answerView to use the password font"	myPar := answerView displayContents.	pwdFont := (StrikeFont passwordFontSize: 12).	myArray := Array new: 1.	myArray at: 1 put: pwdFont.	myStyle := TextStyle fontArray: myArray.	myPar setWithText: (myPar text) style: myStyle.	topView := View new model: aFillInTheBlank.	topView controller: ModalController new.	topView addSubView: messageView.	topView addSubView: answerView below: messageView.	topView align: topView viewport center with: aPoint.	topView window:		(0 @ 0 extent:			(messageView window width) @			  (messageView window height + answerView window height)).	topView translateBy:		(topView displayBox amountToTranslateWithin: Display boundingBox).	^ topView! !!FixedFaceFont methodsFor: 'initialize-release' stamp: 'rej 9/29/2007 09:04'!initialize	"This used to be the default textstyle, but it needs to be a StrikeFont and not a TTCFont and sometimes the default textstyle is a TTCFont.  So, we use a typical StrikeFont as the default fallback font."	baseFont := StrikeFont defaultSized: 12.	self passwordFont! !!Flaps class methodsFor: 'flaps registry' stamp: 'edc 12/9/2006 09:23'!defaultsQuadsDefiningWidgetsFlap	"Answer a structure defining the default Widgets flap.     previously in quadsDefiningWidgetsFlap"	^ #(	(TrashCanMorph			new						'Trash'				'A tool for discarding objects')	(AllScriptsTool			allScriptsToolForActiveWorld	'All Scripts' 		'A tool that lets you see and control all the running scripts in your project')	(PaintInvokingMorph	new						'Paint'				'Drop this into an area to start making a fresh painting there')	(GeeMailMorph			new						'Gee-Mail'			'A place to present annotated content')	(RecordingControlsMorph	authoringPrototype		'Sound'				'A device for making sound recordings.')	"(MPEGMoviePlayerMorph	authoringPrototype		'Movie Player'		'A Player for MPEG movies')"	(FrameRateMorph		authoringPrototype			'Frame Rate'		'An indicator of how fast your system is running')	(MagnifierMorph		newRound					'Magnifier'			'A magnifying glass')	(ScriptingSystem		newScriptingSpace			'Scripting'			'A confined place for drawing and scripting, with its own private stop/step/go buttons.')	(ScriptingSystem		holderWithAlphabet			'Alphabet'			'A source for single-letter objects')	(BouncingAtomsMorph	new						'Bouncing Atoms'	'Atoms, mate')	(ObjectsTool				newStandAlone				'Object Catalog'		'A tool that lets you browse the catalog of objects')	) asOrderedCollection! !!FloatArray methodsFor: 'arithmetic' stamp: 'laza 3/24/2000 13:07'!dot: aFloatVector	"Primitive. Return the dot product of the receiver and the argument.	Fail if the argument is not of the same size as the receiver."	| result |	"<primitive:'primitiveFloatArrayDotProduct'>"	self size = aFloatVector size ifFalse:[^self error:'Must be equal size'].	result := 0.0.	1 to: self size do:[:i|		result := result + ((self at: i) * (aFloatVector at: i)).	].	^result! !!FloatArray methodsFor: 'comparing' stamp: 'ar 5/3/2001 13:02'!hash	| result |	<primitive:'primitiveHashArray' module: 'FloatArrayPlugin'>	result := 0.	1 to: self size do:[:i| result := result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!FloatArray methodsFor: 'comparing' stamp: 'ar 2/2/2001 15:47'!= aFloatArray 	| length |	<primitive: 'primitiveEqual' module: 'FloatArrayPlugin'>	aFloatArray class = self class ifFalse: [^ false].	length := self size.	length = aFloatArray size ifFalse: [^ false].	1 to: self size do: [:i | (self at: i)			= (aFloatArray at: i) ifFalse: [^ false]].	^ true! !!FloatTest methodsFor: 'NaN behavior' stamp: 'rej 10/7/2007 20:40'!testNaN2	"Two NaN values are always considered to be different.	On an little-endian machine (32 bit Intel), Float nan is 16rFFF80000 16r00000000.	On a big-endian machine (PowerPC), Float nan is 16r7FF80000 16r00000000. Changing	the bit pattern of the first word of a NaN produces another value that is still	considered equal to NaN. This test should work on both little endian and big	endian machines. However, it is not guaranteed to work on future 64 bit versions	of Squeak, for which Float may have different internal representations."	"FloatTest new testNaN2"	| nan1 nan2 |	nan1 := Float nan copy.	nan2 := Float nan copy.	"test two instances of NaN with the same bit pattern"	self deny: nan1 = nan2.	self deny: nan1 = nan2.	self deny: nan1 = nan1.	self assert: nan1 == nan1.	"change the bit pattern of nan1"	self assert: nan1 size = 2.	self assert: (nan1 at: 2) = 0.	nan1 at: 1 put: (nan1 at: 1) + 999.	self assert: nan1 isNaN.	self assert: nan2 isNaN.	self deny: (nan1 at: 1) = (nan2 at: 1).	"test two instances of NaN with different bit patterns"	self deny: nan1 = nan2.	self deny: nan1 = nan2.	self deny: nan1 = nan1.	self assert: nan1 == nan1! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 1/10/2007 02:29'!testFractionAsFloat2	"test rounding to nearest even"			self assert: ((1<<52)+0+(1/4)) asFloat asTrueFraction = ((1<<52)+0).	self assert: ((1<<52)+0+(1/2)) asFloat asTrueFraction = ((1<<52)+0).	self assert: ((1<<52)+0+(3/4)) asFloat asTrueFraction = ((1<<52)+1).	self assert: ((1<<52)+1+(1/4)) asFloat asTrueFraction = ((1<<52)+1).	self assert: ((1<<52)+1+(1/2)) asFloat asTrueFraction = ((1<<52)+2).	self assert: ((1<<52)+1+(3/4)) asFloat asTrueFraction = ((1<<52)+2).! !!Form methodsFor: 'testing' stamp: 'ar 7/21/2007 21:37'!isAllWhite	"Answer whether all bits in the receiver are white"	| word |	self unhibernate.	word := Color white pixelWordForDepth: self depth.	1 to: bits size do: [:i | (bits at: i) = word ifFalse: [^ false]].	^ true! !!FormButtonCache methodsFor: 'accessing'!form: aForm	"Set the receiver's form to be the argument."	form := aForm! !!FormButtonCache methodsFor: 'accessing'!initialState: aBoolean	"Set the receiver's initial state, on or off, to be the argument."	initialState := aBoolean! !!FormButtonCache methodsFor: 'accessing'!offset: anInteger	"Set the receiver's offset."	offset := anInteger! !!FormButtonCache methodsFor: 'accessing'!value: aCharacter	"Set the receiver's key character."	value := aCharacter! !!FormEditor methodsFor: 'editing tools'!changeTool: aCharacter 	"Change the value of the instance variable tool to be the tool 	corresponding to aCharacter. Typically sent from a Switch in a 	FormMenuView."	previousTool := tool.	tool := self selectTool: aCharacter.	(#(singleCopy repeatCopy line curve block) includes: tool)		ifFalse:			[self perform: tool]! !!FormEditor methodsFor: 'editing tools' stamp: 'BG 12/10/2003 16:21'!curve	"Conic-section specified by three points designated by: first point--press 	red button second point--release red button third point--click red button. 	The resultant curve on the display is displayed according to the current 	form and mode."	| firstPoint secondPoint thirdPoint curve drawForm |	"sensor noButtonPressed ifTrue: [^self]."	firstPoint := self cursorPoint.	secondPoint := self rubberBandFrom: firstPoint until: [sensor noButtonPressed].	thirdPoint :=  self rubberBandFrom: secondPoint until: [sensor redButtonPressed].	Display depth > 1	  ifTrue:	    [self deleteRubberBandFrom: secondPoint to: thirdPoint.	     self deleteRubberBandFrom: firstPoint to: secondPoint].	curve := CurveFitter new.	curve firstPoint: firstPoint.	curve secondPoint: secondPoint.	curve thirdPoint: thirdPoint.	drawForm := form asFormOfDepth: Display depth.	Display depth > 1 ifTrue:	  [drawForm mapColor: Color white to: Color transparent; 	               mapColor: Color black to: color].	curve form: drawForm.	curve		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: (Display depth > 1 ifTrue: [mode ~= Form erase ifTrue: [Form paint] ifFalse: [mode]]										ifFalse: [mode])		fillColor: (Display depth = 1 ifTrue: [color] ifFalse: [nil]). 	sensor waitNoButton.	hasUnsavedChanges contents: true.! !!FormEditor methodsFor: 'editing tools'!eraseMode	"Set the mode for the tools that copy the form onto the display to erase. 	Leaves the tool set in its previous state."	mode := 4.	tool := previousTool! !!FormEditor methodsFor: 'editing tools' stamp: 'BG 12/12/2003 15:51'!line	"Line is specified by two points from the mouse: first point--press red 	button; second point--release red button. The resultant line is displayed 	according to the current form and mode."	| firstPoint endPoint drawForm |	drawForm := form asFormOfDepth: Display depth.		 Display depth > 1 	  ifTrue:	    [drawForm mapColor: Color white to: Color transparent; 	                 mapColor: Color black to: color].	           	firstPoint := self cursorPoint.	endPoint := self rubberBandFrom: firstPoint until: [sensor noButtonPressed].	endPoint isNil ifTrue: [^self].	Display depth > 1 ifTrue: [self deleteRubberBandFrom: firstPoint to: endPoint.].	(Line from: firstPoint to: endPoint withForm: drawForm)		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: (Display depth > 1 ifTrue: [mode ~= Form erase ifTrue: [Form paint] ifFalse: [mode]]								ifFalse: [mode])		fillColor: (Display depth = 1 ifTrue: [color] ifFalse: [nil]).  		hasUnsavedChanges contents: true.! !!FormEditor methodsFor: 'editing tools'!magnify	"Allow for bit editing of an area of the Form. The user designates a 	rectangular area that is scaled by 5 to allow individual screens dots to be 	modified. Red button is used to set a bit to black, and yellow button is 	used to set a bit to white. Editing continues until the user depresses any 	key on the keyboard."	| smallRect smallForm scaleFactor tempRect |	scaleFactor := 8@8.	smallRect := (Rectangle fromUser: grid) intersect: view insetDisplayBox.	smallRect isNil ifTrue: [^self].	smallForm := Form fromDisplay: smallRect.	"Do this computation here in order to be able to save the existing display screen."	tempRect := BitEditor locateMagnifiedView: smallForm scale: scaleFactor.	BitEditor		openScreenViewOnForm: smallForm 		at: smallRect topLeft 		magnifiedAt: tempRect topLeft 		scale: scaleFactor.	tool := previousTool! !!FormEditor methodsFor: 'editing tools' stamp: 'jm 6/30/1999 15:46'!newSourceForm	"Allow the user to define a new source form for the FormEditor. Copying 	the source form onto the display is the primary graphical operation. 	Resets the tool to be repeatCopy."	| dForm interiorPoint interiorColor |	dForm := Form fromUser: grid.	"sourceForm must be only 1 bit deep"	interiorPoint := dForm extent // 2.	interiorColor := dForm colorAt: interiorPoint.	form := (dForm makeBWForm: interiorColor) reverse				findShapeAroundSeedBlock:					[:f | f pixelValueAt: interiorPoint put: 1].	form := form trimBordersOfColor: Color white.	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!overMode	"Set the mode for the tools that copy the form onto the display to over. 	Leaves the tool set in its previous state."	mode := Form over.	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!reverseMode	"Set the mode for the tools that copy the form onto the display to reverse. 	Leaves the tool set in its previous state."	mode := Form reverse.	tool := previousTool! !!FormEditor methodsFor: 'editing tools' stamp: 'BG 2/25/2001 21:36'!setColor: aColor	"Set the mask (color) to aColor.	Hacked to invoke color chooser if not B/W screen.	Leaves the tool set in its previous state."	self normalizeColor:  (unNormalizedColor := Display depth > 1							ifTrue: [Color fromUser]							ifFalse: [aColor]).	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!togglexGridding	"Turn x (horizontal) gridding off, if it is on, and turns it on, if it is off. 	Does not change the primary tool."	xgridOn		ifTrue: 			[grid := 1 @ grid y.			xgridOn := false]		ifFalse: 			[grid := togglegrid x @ grid y.			xgridOn := true].	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!toggleyGridding	"Turn y (vertical) gridding off, if it is on, and turns it on, if it is off. 	Does not change the primary tool."	ygridOn		ifTrue: 			[grid := grid x @ 1.			ygridOn := false]		ifFalse: 			[grid := grid x @ togglegrid y.			ygridOn := true].	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!underMode	"Set the mode for the tools that copy the form onto the display to under. 	Leaves the tool set in its previous state."	mode := Form under.	tool := previousTool! !!FormEditor methodsFor: 'initialize-release'!release	"Break the cycle between the Controller and its view. It is usually not 	necessary to send release provided the Controller's view has been properly 	released independently."	super release.	form := nil! !!FormEditor methodsFor: 'private' stamp: 'jm 12/4/97 10:22'!normalizeColor: aColor	color := aColor.! !!FormEditor methodsFor: 'private' stamp: 'BG 12/10/2003 16:47'!rubberBandFrom: startPoint until: aBlock	| endPoint previousEndPoint |	previousEndPoint := startPoint.	[aBlock value] whileFalse:		[(endPoint := self cursorPoint) = previousEndPoint 			ifFalse:			[(Line from: startPoint to: previousEndPoint withForm: form) 				displayOn: Display				at: 0 @ 0				clippingBox: view insetDisplayBox				rule: Form reverse				fillColor: Color gray.			(Line from: startPoint to: endPoint withForm: form)				displayOn: Display				at: 0 @ 0				clippingBox: view insetDisplayBox				rule: Form reverse				fillColor: Color gray.			previousEndPoint  := endPoint]].	(Line from: startPoint to: previousEndPoint withForm: form)		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: Form reverse		fillColor: (Display depth = 1 ifTrue: [Color gray] ifFalse: [Color black]).	^endPoint! !!FormEditor methodsFor: 'private' stamp: 'BG 12/5/2003 22:58'!setVariables	tool := #repeatCopy.	previousTool := tool.	grid := 1 @ 1.	togglegrid := 8 @ 8.	xgridOn := false.	ygridOn := false.	mode := Form over.	form := Form extent: 8 @ 8.	form fillBlack.	unNormalizedColor := color := Color black.	hasUnsavedChanges := ValueHolder new contents: false.! !!FormEditor methodsFor: 'private' stamp: 'BG 12/12/2003 15:50'!trackFormUntil: aBlock	| previousPoint cursorPoint displayForm |	previousPoint := self cursorPoint.	displayForm := Form extent: form extent depth: form depth.	displayForm copy: (0 @ 0 extent: form extent)	               from: form	               to: 0 @ 0	               rule: Form over.	Display depth > 1 ifTrue: [displayForm reverse]. 	displayForm displayOn: Display at: previousPoint rule: Form reverse.	[aBlock value] whileFalse:		[cursorPoint := self cursorPoint.		(FlashCursor or: [cursorPoint ~= previousPoint])			ifTrue:			[displayForm displayOn: Display at: previousPoint rule: Form reverse.			displayForm displayOn: Display at: cursorPoint rule: Form reverse.			previousPoint := cursorPoint]].	displayForm displayOn: Display at: previousPoint rule: Form reverse.	^previousPoint! !!FormEditor class methodsFor: 'class initialization'!flashCursor: aBoolean	FlashCursor := aBoolean	"FormEditor flashCursor: true"! !!FormEditor class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 15:06'!initialize	FlashCursor := false.	self setKeyboardMap.	YellowButtonMenu := SelectionMenu 		labels:'acceptcanceleditfile out'		lines: #(2)		selections: #(accept cancel edit fileOut).	"FormEditor initialize"! !!FormEditor class methodsFor: 'instance creation'!openFullScreenForm	"Create and schedule an instance of me on the form whose extent is the 	extent of the display screen."	| topView |	topView := self createFullScreenForm.	topView controller 		openDisplayAt: (topView viewport extent//2)	"FormEditor openFullScreenForm."! !!FormEditor class methodsFor: 'instance creation'!openOnForm: aForm	"Create and schedule an instance of me on the form aForm."	| topView |	topView := self createOnForm: aForm.	topView controller open! !!FormEditor class methodsFor: 'private' stamp: 'di 1/16/98 15:46'!createFullScreenForm	"Create a StandardSystemView for a FormEditor on the form whole screen."	| formView formEditor menuView topView extent aForm |	aForm := Form extent: (Display extent x @ (Display extent y - 112)) depth: Display depth.	formView := FormHolderView new model: aForm.	formView borderWidthLeft: 0 right: 0 top: 0 bottom: 1.	formEditor := formView controller.	menuView := FormMenuView new makeFormEditorMenu model: formEditor.	formEditor model: menuView controller.	topView := StandardSystemView new.	topView backgroundColor: #veryLightGray.	topView model: aForm.	topView addSubView: formView.	topView 		addSubView: menuView		align: menuView viewport topCenter		with: formView viewport bottomCenter + (0@16).	topView window: 		(formView viewport 			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))).	topView label: 'Form Editor'.	extent := topView viewport extent.	topView minimumSize: extent.	topView maximumSize: extent.	^topView! !!FormEditor class methodsFor: 'private' stamp: 'BG 12/5/2003 23:18'!createOnForm: aForm	"Create a StandardSystemView for a FormEditor on the form aForm."	| formView formEditor menuView aView topView extent topViewBorder |	topViewBorder := 2.	formView := FormHolderView new model: aForm.	formEditor := formView controller.	menuView := FormMenuView new makeFormEditorMenu model: formEditor.	formEditor model: aForm.	aView := View new.	aView model: aForm.	aView addSubView: formView.	aView 		addSubView: menuView		align: menuView viewport topCenter		with: formView viewport bottomCenter + (0@16).	aView window: 		((formView viewport 			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))) 		  expandBy: (0@topViewBorder corner: 0@0)).	topView := "ColorSystemView" FormEditorView new.	topView model: formEditor.	topView backgroundColor: #veryLightGray.	topView addSubView: aView.	topView label: 'Form Editor'.	topView borderWidth: topViewBorder.	extent := topView viewport extent.	topView minimumSize: extent.	topView maximumSize: extent.	^topView! !!FormEditor class methodsFor: 'private'!setKeyboardMap	"Keyboard Mapping."	SelectKey:=$a.	SingleCopyKey:=$s.			"tools"	RepeatCopyKey:=$d.	LineKey:=$f.	CurveKey:=$g.	BlockKey:=$h.	OverKey:=$j.				"modes"	UnderKey:=$k.	ReverseKey:=$l.	EraseKey:=$;.	InKey:=$'.					"file In"	BitEditKey:=$z.	WhiteKey:=$x.				"colors"	LightGrayKey:=$c.	GrayKey:=$v.	DarkGrayKey:=$b.	BlackKey:=$n.	TogglexGridKey:=$m.		"gridding"	ToggleyGridKey:=$,.	ChangeGridsKey:=$..	OutKey:=$/					"file Out"! !!FormHolderView methodsFor: 'displaying'!displayView 	"Display the Form associated with this View according to the rule and	fillColor specifed by this class."	| oldOffset |	oldOffset := displayedForm offset.	displayedForm offset: 0@0.	displayedForm		displayOn: Display		transformation: self displayTransformation		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor.	displayedForm offset: oldOffset! !!FormHolderView methodsFor: 'initialize-release'!release	super release.	displayedForm release.	displayedForm := nil! !!FormHolderView methodsFor: 'model access'!model: aForm	super model: aForm.	displayedForm := aForm deepCopy! !!FormInspectView methodsFor: 'as yet unclassified' stamp: 'di 9/23/1998 10:55'!displayView 	"Display the form as a value in an inspector.  8/11/96 sw"	"Defeated form scaling for HS FormInspector.  8/20/96 di"	| scale |	Display fill: self insetDisplayBox fillColor: Color white.	model selectionIndex == 0 ifTrue: [^ self].	scale := self insetDisplayBox extent / model selection extent.	scale := (scale x min: scale y) min: 1.	model selection		displayOn: Display		transformation: (WindowingTransformation			scale: scale asPoint			translation: self insetDisplayBox topLeft - model selection offset)		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor! !!FormMenuController methodsFor: 'control defaults' stamp: 'jm 4/7/98 20:59'!processMenuKey	"The user typed a key on the keyboard. Perform the action of the button whose shortcut is that key, if any."	| aView |	aView := view subViewContainingCharacter: sensor keyboard.	aView ~~ nil ifTrue: [aView performAction].! !!FormMenuView methodsFor: 'private' stamp: 'BG 12/4/2003 14:22'!makeButton: index	| buttonCache button |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.	button := Button newOff.	button onAction: [model changeTool: buttonCache value].	self makeViews: buttonCache for: button.! !!FormMenuView methodsFor: 'private' stamp: 'BG 12/4/2003 14:23'!makeColorConnections: indexInterval	| connector buttonCache button aSwitchView |	connector := Object new.  "a dummy model for connecting dependents"	indexInterval do: [:index |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.		buttonCache initialState = #true			ifTrue: [button := OneOnSwitch newOn]			ifFalse: [button := OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView := self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!FormMenuView methodsFor: 'private' stamp: 'BG 12/4/2003 14:23'!makeConnections: indexInterval	| connector buttonCache button aSwitchView |	connector := Object new.  "a dummy model for connecting dependents."	indexInterval do: [:index |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.		buttonCache initialState = #true			ifTrue: [button := OneOnSwitch newOn]			ifFalse: [button := OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView := self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!FormMenuView methodsFor: 'private' stamp: 'BG 12/4/2003 15:24'!makeGridSwitch: index	| buttonCache button |	buttonCache := FormButtons at: index.	buttonCache form: (FormButtons at: index) form copy.	buttonCache initialState = #true		ifTrue: [button := Switch newOn]		ifFalse: [button := Switch newOff].	button onAction: [model changeTool: buttonCache value].	button offAction: [model changeTool: buttonCache value].	self makeViews: buttonCache for: button.! !!FormMenuView methodsFor: 'private' stamp: 'BG 12/4/2003 14:23'!makeSwitch: index	| buttonCache button |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.	buttonCache initialState = #true		ifTrue: [button := Switch newOn]		ifFalse: [button := Switch newOff].	button onAction: [model changeTool: buttonCache value].	self makeViews: buttonCache for: button.! !!FormMenuView methodsFor: 'private' stamp: 'jm 4/7/98 20:24'!makeViews: cache for: aSwitch	| form aSwitchView |	form := cache form.	aSwitchView := PluggableButtonView		on: aSwitch		getState: #isOn		action: #switch.	aSwitchView		label: form;		shortcutCharacter: cache value;		window: (0@0 extent: form extent);		translateBy: cache offset;		borderWidth: 1.	self addSubView: aSwitchView.	^ aSwitchView! !!FormMenuView class methodsFor: 'class initialization' stamp: 'jm 3/27/98 14:54'!fileOut	"Save the FormEditor button icons."	"FormMenuView fileOut"	| names |	names := 		#('select.form' 'singlecopy.form' 'repeatcopy.form' 'line.form' 'curve.form'		'block.form' 'over.form' 'under.form' 'reverse.form' 'erase.form' 'in.form'		'magnify.form' 'white.form' 'lightgray.form' 'gray.form' 'darkgray.form' 'black.form'		'xgrid.form' 'ygrid.form' 'togglegrids.form' 'out.form').	1 to: FormButtons size do: [:i |		(FormButtons at: i) form writeOnFileNamed: (names at: i)].	SpecialBorderForm writeOnFileNamed: 'specialborderform.form'.	BorderForm writeOnFileNamed: 'borderform.form'.! !!FormMenuView class methodsFor: 'class initialization' stamp: 'md 7/23/2006 16:41'!initialize2	"The icons for the menu are typically stored on files. In order to avoid reading them every time, they are stored in a collection in a class variable, along with their offset, tool value, and initial visual state (on or off)."	"FormMenuView initialize"	| offsets keys states names button |	offsets _ OrderedCollection new: 21.	#(0 64 96 128 160 192 256 288 320 352 420) do: [:i | offsets addLast: i@0].  "First row"	#(0 64 96 128 160 192 256 304 352 420) do: [:i | offsets addLast: i@48].  "Second row"	offsets _ offsets asArray.	keys _ #($a $s $d $f $g $h $j $k $l $; $' $z $x $c $v $b $n $m $, $. $/ ).  "Keyboard"	states _ #(		#false #false #true #false #false #false #true #false #false #false #false		#false #false #false #false #false #true #false #false #false #false).  "Initial button states"	names _ 		#('select.form' 'singlecopy.form' 'repeatcopy.form' 'line.form' 'curve.form'		'block.form' 'over.form' 'under.form' 'reverse.form' 'erase.form' 'in.form'		'magnify.form' 'white.form' 'lightgray.form' 'gray.form' 'darkgray.form' 'black.form'		'xgrid.form' 'ygrid.form' 'togglegrids.form' 'out.form').  "Files of button images"	FormButtons _ OrderedCollection new.	1 to: 21 do: [:index |		button _ FormButtonCache new.		button form: (Form fromFileNamed: (names at: index)).		button offset: (offsets at: index).		button value: (keys at: index).		button initialState: (states at: index).		FormButtons addLast: button].	SpecialBorderForm  _ Form fromFileNamed: 'specialborderform.form'.	BorderForm _ Form fromFileNamed: 'borderform.form'.! !!FormTest methodsFor: 'tests' stamp: 'ar 7/21/2007 21:41'!testIsAllWhite	"self run: #testIsAllWhite"	"Make sure #isAllWhite works for all bit depths"	| form |	#(-32 -16 -8 -4 -2 -1 1 2 4 8 16 32) do:[:d|		form := Form extent: 16@16 depth: d.		form fillBlack.		self deny: form isAllWhite.		form fillWhite.		self assert: form isAllWhite.	].! !!FormTest commentStamp: 'ar 7/21/2007 21:39' prior: 0!Various tests for class form.!!FormView methodsFor: 'accessing'!fillColor: aForm 	"Set the display mask for displaying the receiver's model to be the 	argument, aForm."	mask := aForm! !!FormView methodsFor: 'accessing'!rule: anInteger 	"Set the display rule for the receiver to be the argument, anInteger."	rule := anInteger! !!FormView methodsFor: 'displaying' stamp: 'hmm 7/21/97 20:45'!displayView 	"Refer to the comment in View|displayView."	| oldOffset |	super displayView.	insideColor == nil ifFalse: [Display fill: self insetDisplayBox fillColor: insideColor].	oldOffset := model offset.	model offset: "borderWidth origin" 0@0.	model		displayOn: Display		transformation: self displayTransformation		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor.	model offset: oldOffset! !!FormView class methodsFor: 'examples'!exampleOne	"Frame a Form (specified by the user) with a border of 2 bits in width and display it offset 60 x 40 from the cornor of the display screen. "	| f view |	f := Form fromUser.	view := self new model: f.	view translateBy: 60 @ 40.	view borderWidth: 2.	view display.	view release	"FormView exampleOne"! !!FormView class methodsFor: 'examples'!exampleTwo	"Frame a Form (specified by the user) that is scaled by 2. The border is 2 bits in width. Displays at location 60, 40."	| f view |	f := Form fromUser.	view := self new model: f.	view scaleBy: 2.0.	view translateBy: 60 @ 40.	view borderWidth: 2.	view display.	view release	"FormView exampleTwo"! !!FormView class methodsFor: 'examples' stamp: 'BG 12/5/2003 14:45'!open: aForm named: aString	"FormView open: ((Form extent: 100@100) borderWidth: 1) named: 'Squeak' "	"Open a window whose model is aForm and whose label is aString."	| topView aView |	topView := StandardSystemView new.	topView model: aForm.	topView label: aString.	topView minimumSize: aForm extent;	          maximumSize: aForm extent.	aView := FormView new.	aView model: aForm.	aView window: (aForm boundingBox expandBy: 2).	aView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	topView addSubView: aView.	topView controller open! !!Fraction methodsFor: 'converting' stamp: 'nice 1/10/2007 02:07'!asFloat	"Answer a Float that closely approximates the value of the receiver.	This implementation will answer the closest floating point number to	the receiver.	It uses the IEEE 754 round to nearest even mode	(can happen in case denominator is a power of two)"		| a b q r exponent floatExponent n ha hb hq q1 |	a := numerator abs.	b := denominator abs.	ha := a highBit.	hb := b highBit.		"If both numerator and denominator are represented exactly in floating point number,	then fastest thing to do is to use hardwired float division"	(ha < 54 and: [hb < 54]) ifTrue: [^numerator asFloat / denominator asFloat].		"Try and obtain a mantissa with 54 bits.	First guess is rough, we might get one more bit or one less"	exponent := ha - hb - 54.	exponent > 0		ifTrue: [b := b bitShift: exponent]		ifFalse: [a := a bitShift: exponent negated].	q := a quo: b.	r := a - (q * b).	hq := q highBit.		"check for gradual underflow, in which case we should use less bits"	floatExponent := exponent + hq - 1.	n := floatExponent > -1023		ifTrue: [54]		ifFalse: [54 + floatExponent + 1022].		hq > n		ifTrue: [exponent := exponent + hq - n.			r := (q bitAnd: (1 bitShift: hq - n) - 1) * b + r.			q := q bitShift: n - hq].	hq < n		ifTrue: [exponent := exponent + hq - n.			q1 := (r bitShift: n - hq) quo: b.			q := (q bitShift: n - hq) bitAnd: q1.			r := (r bitShift: n - hq) - (q1 * b)].			"check if we should round upward.	The case of exact half (q bitAnd: 1) isZero not & (r isZero)	will be handled by Integer>>asFloat"	((q bitAnd: 1) isZero or: [r isZero])		ifFalse: [q := q + 1].			^ (self positive		ifTrue: [q asFloat]		ifFalse: [q asFloat negated])		timesTwoPower: exponent! !!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'pk 10/17/2006 09:40'!fileIntoNewChangeSet: fullFileName	"FileIn the contents of a gzipped file"	| zipped unzipped cs |	cs := Smalltalk at: #ChangesOrganizer ifAbsent: [ ^self ].	zipped := self on: (FileStream readOnlyFileNamed: fullFileName).	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	cs newChangesFromStream: unzipped named: (FileDirectory localNameFor: fullFileName)! !!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'pk 10/17/2006 09:41'!fileReaderServicesForFile: fullName suffix: suffix 	| services |	(suffix = 'gz') | (suffix = '*')		ifFalse: [^ #()].	services := OrderedCollection new.	(suffix = '*') | (fullName asLowercase endsWith: '.cs.gz') | (fullName asLowercase endsWith: '.mcs.gz')		ifTrue: [services add: self serviceFileIn.			(Smalltalk includesKey: #ChangSet)				ifTrue: [services add: self serviceFileIntoNewChangeSet]].	services addAll: self services.	^ services! !!GeeMailMorph methodsFor: '*eToys-customevents-stepping and presenter' stamp: 'nk 10/12/2003 13:23'!step	"For each submorph of thePasteUp that has just been scrolled into view, fire the script named #scrolledIntoView, if any.	For each submorph of thePasteUp that has just been scrolled out of view, fire the script named #scrolledOutOfView, if any."	| lastVisible nowVisible newlyVisible newlyInvisible |	super step.	lastVisible := self visibleMorphs.	nowVisible := (thePasteUp submorphs copyWithoutAll: (self allTextPlusMorphs))		select: [ :m | self bounds intersects: (m boundsIn: self world) ].	newlyInvisible := lastVisible difference: nowVisible.	newlyInvisible do: [ :ea | ea triggerEvent: #scrolledOutOfView ].	newlyVisible := nowVisible difference: lastVisible.	newlyVisible do: [ :ea | ea triggerEvent: #scrolledIntoView ].	self visibleMorphs: nowVisible.	! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:26'!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f := SimpleButtonMorph new		target: self;		label: aString;		color: aColor;		borderColor: aColor muchDarker;		actionSelector: aSymbol;		setBalloonText: helpString.	col := (self inAColumn: {f}) hResizing: #shrinkWrap.	^col! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 16:41'!clearSliderFeedback	| feedBack |	feedBack := self valueOfProperty: #sliderFeedback ifAbsent: [^self].	feedBack delete! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 16:22'!inAColumn: aCollectionOfMorphs	| col |	col := AlignmentMorphBob1 newColumn		color: Color transparent;		vResizing: #shrinkWrap;		layoutInset: 1;		wrapCentering: #center;		cellPositioning: #topCenter.	aCollectionOfMorphs do: [ :each | col addMorphBack: each].	^col! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 12:27'!inARow: aCollectionOfMorphs	| row |	row := AlignmentMorphBob1 newRow		color: Color transparent;		vResizing: #shrinkWrap;		layoutInset: 1;		wrapCentering: #center;		cellPositioning: #leftCenter.	aCollectionOfMorphs do: [ :each | row addMorphBack: each].	^row! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:22'!mouseAdjust: evt in: aMorph	| fractionalPosition feedBack testExtent |	feedBack := self showSliderFeedback: nil.	feedBack world ifNil: [		feedBack bottomLeft: evt cursorPoint - (0@8)	].	testExtent := 100@100.		"the real extent may change"	fractionalPosition := (evt cursorPoint - aMorph topLeft) / testExtent.	self 		perform: (aMorph valueOfProperty: #changeSelector)		with: fractionalPosition! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 13:09'!openNearTarget	| w wb tb leftOverlap rightOverlap topOverlap bottomOverlap best |	w := myTarget world ifNil: [World].	wb := w bounds.	self fullBounds.	tb := myTarget boundsInWorld.	leftOverlap := self width - (tb left - wb left).	rightOverlap := self width - (wb right - tb right).	topOverlap := self height - (tb top - wb top).	bottomOverlap := self height - (wb bottom - tb bottom).	best := nil.	{		{leftOverlap. #topRight:. #topLeft}.		{rightOverlap. #topLeft:. #topRight}.		{topOverlap. #bottomLeft:. #topLeft}.		{bottomOverlap. #topLeft:. #bottomLeft}.	} do: [ :tuple |		(best isNil or: [tuple first < best first]) ifTrue: [best := tuple].	].	self perform: best second with: (tb perform: best third).	self bottom: (self bottom min: wb bottom) rounded.	self right: (self right min: wb right) rounded.	self top: (self top max: wb top) rounded.	self left: (self left max: wb left) rounded.	self openInWorld: w.! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:12'!showSliderFeedback: aString	| feedBack |	feedBack := self 		valueOfProperty: #sliderFeedback 		ifAbsent: [			feedBack := AlignmentMorph newRow				hResizing: #shrinkWrap;				vResizing: #shrinkWrap;				color: (Color yellow" alpha: 0.6");				addMorph: (					TextMorph new 						contents: '?';						beAllFont: ((TextStyle default fontOfSize: 24) emphasized: 1)				).			self setProperty: #sliderFeedback toValue: feedBack.			feedBack		].	aString ifNotNil: [		feedBack firstSubmorph contents: aString asString.		feedBack world ifNil: [feedBack openInWorld].	].	^feedBack! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:01'!targetMorph: x	myTarget := x! !!GenericPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:16'!initialize	"initialize the state of the receiver"	super initialize.	""	self layoutInset: 4.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	thingsToRevert := Dictionary new.	self useRoundedCorners! !!GraphicSymbolInstance methodsFor: 'accessing'!graphicSymbol: aGraphicSymbol 	"Set the argument, aGraphicSymbol, to be the graphic symbol that the 	receiver displays."	graphicSymbol := aGraphicSymbol! !!GraphicSymbolInstance methodsFor: 'transforming'!transformation: aWindowingTransformation 	"Set the argument, aWindowingTransformation, to be the receiver's 	display transformation."	transformation := aWindowingTransformation! !!GraphicSymbolInstance class methodsFor: 'examples'!example	"Simply evaluate the method and two GraphicSymbolInstances, each	displaying a transformation of the same graphic symbol, will be	presented on the screen. Clears the screen to white."	| gate instance1 instance2 trans1 trans2 line arc f|	Display fillWhite.			"clear the Screen."	f := Form extent: 2@2.	f fillBlack.	gate:= GraphicSymbol new.		"make a logic gate out of lines and arcs."	line:=Line new.  line beginPoint: -20@-20.  line endPoint: 0@-20. line form: f.	gate add: line.	line:=Line new.  line beginPoint: -20@20.  line endPoint: 0@20. line form: f.	gate add: line.	line:=Line new.  line beginPoint: 0@-40.  line endPoint: 0@40. line form: f.	gate add: line.	arc := Arc new. arc center: 0@0 radius: 40 quadrant: 1.	arc form: f.	gate add: arc.	arc := Arc new. arc center: 0@0 radius: 40 quadrant: 4.	arc form: f.	gate add: arc.			"one instance at 1/2 scale."	trans1:=WindowingTransformation identity.		trans1:= trans1 scaleBy: 0.5@0.5.	trans1:= trans1 translateBy: 100@100.			"the other instance at 2 times scale"	trans2:=WindowingTransformation identity.		trans2:= trans2 scaleBy: 2.0@2.0.	trans2:= trans2 translateBy: 200@200.	instance1 := GraphicSymbolInstance new.	instance1 transformation: trans1.	instance1 graphicSymbol: gate.	instance2 := GraphicSymbolInstance new.	instance2 transformation: trans2.	instance2 graphicSymbol: gate.			"display both instances of the logic gate"	instance1 displayOn: Display					transformation: WindowingTransformation identity					clippingBox: Display boundingBox					rule: Form under					fillColor: nil.	instance2 displayOn: Display					transformation: WindowingTransformation identity					clippingBox: Display boundingBox					rule: Form under					fillColor: nil	"GraphicSymbolInstance example"! !!GraphicTile methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:45'!initialize"initialize the state of the receiver"	super initialize.""	type := #literal.	self		useForm: (ScriptingSystem formAtKey: #Menu)! !!GraphicTile methodsFor: 'initialization' stamp: 'sw 4/3/2001 15:52'!setLiteral: anObject	"Set the receiver's literal to be anObject. No readout morph here."	type := #literal.	self setLiteralInitially: anObject.! !!GraphicTile methodsFor: 'initialization' stamp: 'sw 4/3/2001 15:40'!useForm: aForm	"Set the receiver to represent the given form"	| thumbnail |	self removeAllMorphs.	literal := aForm.	thumbnail := ThumbnailMorph  new objectToView: self viewSelector: #literal.	self addMorphBack: thumbnail.	thumbnail extent: 16 @ 16.! !!HandBugs methodsFor: 'as yet unclassified' stamp: 'wiz 4/18/2007 00:57'!testTargetPoint"self new testTargetPoint""self run: #testTargetPoint"self shouldnt: [ ActiveHand targetPoint ] raise: Error .! !!HandMorph methodsFor: 'accessing' stamp: 'wiz 12/4/2006 00:16'!targetPoint	"Return the new position of the target.	I.E. return the position of the hand less 	the original distance between hand and target position"	^ self position - targetOffset! !!Heap methodsFor: 'accessing' stamp: 'jcg 3/8/2003 02:00'!indexUpdateBlock: aBlockOrNil	indexUpdateBlock := aBlockOrNil.	indexUpdateBlock fixTemps.! !!Heap methodsFor: 'accessing' stamp: 'ar 7/1/1999 04:21'!sortBlock: aBlock	sortBlock := aBlock.	sortBlock fixTemps.	self reSort.! !!Heap methodsFor: 'adding' stamp: 'jcg 3/8/2003 02:07'!add: anObject	"Include newObject as one of the receiver's elements. Answer newObject."	tally = array size ifTrue:[self grow].	array at: (tally := tally + 1) put: anObject.	self updateObjectIndex: tally.	self upHeap: tally.	^anObject! !!Heap methodsFor: 'growing' stamp: 'ar 7/1/1999 04:18'!growTo: newSize	"Grow to the requested size."	| newArray |	newArray := Array new: (newSize max: tally).	newArray replaceFrom: 1 to: array size with: array startingAt: 1.	array := newArray! !!Heap methodsFor: 'private' stamp: 'ar 9/15/2000 17:12'!privateRemoveAt: index	"Remove the element at the given index and make sure the sorting order is okay"	| removed |	removed := array at: index.	array at: index put: (array at: tally).	array at: tally put: nil.	tally := tally - 1.	index > tally ifFalse:[		"Use #downHeapSingle: since only one element has been removed"		self downHeapSingle: index].	^removed! !!Heap methodsFor: 'private' stamp: 'ar 7/1/1999 04:35'!setCollection: aCollection	array := aCollection.	tally := 0.! !!Heap methodsFor: 'private' stamp: 'ar 9/10/1999 13:18'!setCollection: aCollection tally: newTally	array := aCollection.	tally := newTally.! !!Heap methodsFor: 'private-heap' stamp: 'jcg 3/8/2003 02:11'!downHeap: anIndex	"Check the heap downwards for correctness starting at anIndex.	 Everything above (i.e. left of) anIndex is ok."	| value k n j |	anIndex = 0 ifTrue:[^self].	n := tally bitShift: -1.	k := anIndex.	value := array at: anIndex.	[k <= n] whileTrue:[		j := k + k.		"use max(j,j+1)"		(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])				ifTrue:[ j := j + 1].		"check if position k is ok"		(self sorts: value before: (array at: j)) 			ifTrue:[	"yes -> break loop"					n := k - 1]			ifFalse:[	"no -> make room at j by moving j-th element to k-th position"					array at: k put: (array at: j).					self updateObjectIndex: k.					"and try again with j"					k := j]].	array at: k put: value.	self updateObjectIndex: k.! !!Heap methodsFor: 'private-heap' stamp: 'jcg 3/8/2003 02:11'!downHeapSingle: anIndex	"This version is optimized for the case when only one element in the receiver can be at a wrong position. It avoids one comparison at each node when travelling down the heap and checks the heap upwards after the element is at a bottom position. Since the probability for being at the bottom of the heap is much larger than for being somewhere in the middle this version should be faster."	| value k n j |	anIndex = 0 ifTrue:[^self].	n := tally bitShift: -1.	k := anIndex.	value := array at: anIndex.	[k <= n] whileTrue:[		j := k + k.		"use max(j,j+1)"		(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])				ifTrue:[	j := j + 1].		array at: k put: (array at: j).		self updateObjectIndex: k.		"and try again with j"		k := j].	array at: k put: value.	self updateObjectIndex: k.	self upHeap: k! !!Heap methodsFor: 'private-heap' stamp: 'jcg 3/8/2003 02:12'!upHeap: anIndex	"Check the heap upwards for correctness starting at anIndex.	 Everything below anIndex is ok."	| value k kDiv2 tmp |	anIndex = 0 ifTrue:[^self].	k := anIndex.	value := array at: anIndex.	[ (k > 1) and:[self sorts: value before: (tmp := array at: (kDiv2 := k bitShift: -1))] ] 		whileTrue:[			array at: k put: tmp.			self updateObjectIndex: k.			k := kDiv2].	array at: k put: value.	self updateObjectIndex: k.! !!HeapTest methodsFor: 'examples' stamp: 'md 2/12/2006 15:33'!heapExample	"HeapTest new heapExample"	"Create a sorted collection of numbers, remove the elements	sequentially and add new objects randomly.	Note: This is the kind of benchmark a heap is designed for."	| n rnd array time sorted |	n := 5000. "# of elements to sort"	rnd := Random new.	array := (1 to: n) collect:[:i| rnd next].	"First, the heap version"	time := Time millisecondsToRun:[		sorted := Heap withAll: array.		1 to: n do:[:i| 			sorted removeFirst.			sorted add: rnd next].	].	Transcript cr; show:'Time for Heap: ', time printString,' msecs'.	"The quicksort version"	time := Time millisecondsToRun:[		sorted := SortedCollection withAll: array.		1 to: n do:[:i| 			sorted removeFirst.			sorted add: rnd next].	].	Transcript cr; show:'Time for SortedCollection: ', time printString,' msecs'.! !!HeapTest methodsFor: 'examples' stamp: 'md 2/12/2006 15:34'!heapSortExample	"HeapTest new heapSortExample"	"Sort a random collection of Floats and compare the results with	SortedCollection (using the quick-sort algorithm) and 	ArrayedCollection>>mergeSortFrom:to:by: (using the merge-sort algorithm)."	| n rnd array  time sorted |	n := 10000. "# of elements to sort"	rnd := Random new.	array := (1 to: n) collect:[:i| rnd next].	"First, the heap version"	time := Time millisecondsToRun:[		sorted := Heap withAll: array.		1 to: n do:[:i| sorted removeFirst].	].	Transcript cr; show:'Time for heap-sort: ', time printString,' msecs'.	"The quicksort version"	time := Time millisecondsToRun:[		sorted := SortedCollection withAll: array.	].	Transcript cr; show:'Time for quick-sort: ', time printString,' msecs'.	"The merge-sort version"	time := Time millisecondsToRun:[		array mergeSortFrom: 1 to: array size by: [:v1 :v2| v1 <= v2].	].	Transcript cr; show:'Time for merge-sort: ', time printString,' msecs'.! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:26'!testCharacterHex| result |result _ $a hex.self assert: result = '61'.result _ $A hex.self assert: result = '41'.! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:39'!testColorPrintHtmlStringself assert: (Color red printHtmlString ) = ( Color red asHTMLColor allButFirst asUppercase).! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:21'!testIntegerHex| result |result _ 15 asInteger hex.self assert: result = '0F'.result _ 0 asInteger hex.self assert: result = '00'.result _ 255 asInteger hex.self assert: result = 'FF'.result _ 90 asInteger hex.self assert: result = '5A'.! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:44'!testStringAsHex| result |result _ 'abc' asHex.self assert: result = '616263'.! !!HexTest commentStamp: 'JPF 6/26/2007 10:15' prior: 0!Rather than testing a single class, this set of tests looks at the interactions between Character, String, Integer and Color using hex and printStringHex!!IdentityDictionary methodsFor: 'private' stamp: 'RAA 1/10/2001 14:57'!fasterKeys	"This was taking some time in publishing and we didn't really need a Set"	| answer index |	answer := Array new: self size.	index := 0.	self keysDo: [:key | answer at: (index := index + 1) put: key].	^ answer! !!IdentityDictionary methodsFor: 'private' stamp: 'md 10/5/2005 15:41'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| finish hash start element |	finish := array size.	finish > 4096		ifTrue: [hash := anObject identityHash * (finish // 4096)]		ifFalse: [hash := anObject identityHash].	start := (hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!IdentitySet methodsFor: 'private' stamp: 'md 10/5/2005 15:42'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| finish hash start element |	finish := array size.	finish > 4096		ifTrue: [hash := anObject identityHash * (finish // 4096)]		ifFalse: [hash := anObject identityHash].	start := (hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 14:47'!isExpanded: aBoolean	| tm |	super isExpanded: aBoolean.	tm := self repositionText.	isExpanded ifFalse: [		self height: tm height.	].	self addMorph: tm.	"tm clipToOwner: isExpanded not."		"not really working right yet"! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 16:06'!position: p andWidth: w	| widthChanged |	widthChanged := self width ~= w.	self position: p.	self width: w.	submorphs isEmpty ifTrue: [^self height].	widthChanged ifTrue: [		self repositionText.	].	self height: self desiredHeight.	^self desiredHeight! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 19:19'!repositionText	| sRect tm |	sRect := self textMorphBounds.	(tm := complexContents withoutListWrapper)		"clipToOwner: isExpanded not;"		position: sRect origin;		width: sRect width.	isExpanded ifTrue: [		tm extent: sRect width@10.		tm contents: tm contents wrappedTo: sRect width.		tm extent: sRect width@10.	] ifFalse: [		tm contentsAsIs: tm contents.		tm extent: tm extent.		"force bounds recompute"	].	tm lock: isExpanded not."{tm. tm bounds. sRect} explore."	^tm! !!IndentingListParagraphMorph methodsFor: 'drawing' stamp: 'RAA 1/26/2001 10:26'!drawToggleOn: aCanvas in: aRectangle	| aForm |	aCanvas 		fillRectangle: (bounds withRight: aRectangle right)		color: container color.	complexContents hasContents ifFalse: [^self].	aForm := isExpanded 		ifTrue: [container expandedForm]		ifFalse: [container notExpandedForm].	^aCanvas 		paintImage: aForm 		at: aRectangle topLeft! !!IndentingListParagraphMorph methodsFor: 'event handling' stamp: 'RAA 7/31/2000 10:04'!keyStroke: evt	| char |	char := evt keyCharacter.	evt controlKeyPressed ifTrue: [		char = Character cr ifTrue: [			container model addSibling.			^true	"we did handle it"		].		char = Character tab ifTrue: [			container model addNewChildAfter: 0.			^true	"we did handle it"		].	].	^false	"we did not handle it"! !!IndentingListParagraphMorph methodsFor: 'initialization' stamp: 'RAA 7/31/2000 09:52'!initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel	super initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel.	self width: hostList width.	complexContents withoutListWrapper firstDisplay ifTrue: [		complexContents withoutListWrapper firstDisplayedOnLevel: indentLevel.		isExpanded := true.	].	complexContents withoutListWrapper showInOpenedState ifTrue: [		isExpanded := true.	].	self addMorph: self repositionText.! !!Inspector methodsFor: '*eToys-menu commands' stamp: 'sw 10/23/2000 18:25'!tearOffTile	"Tear off a tile that refers to the receiver's selection, and place it in the mophic hand"	| objectToRepresent |	objectToRepresent := self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	self currentHand attachMorph: (TileMorph new referTo: objectToRepresent)	! !!Installer methodsFor: 'action report' stamp: 'kph 1/11/2007 00:22'!actionMatch: theLine reportOn: report ifNoMatch: aBlock	| line |		line := theLine withBlanksCondensed.		((line beginsWith: 'Installer install:') | (line beginsWith: 'Installer do:')) 		ifTrue: [ ^self webAction: theLine reportOn: report ].			((line beginsWith: 'Installer installUrl:') and: 		[ | ext |		 ext :=  (line readStream upToAll: '''.') copyAfterLast: $..		 (#( 'cs' 'st' 'mcz' 'sar') includes: ext) not ]) ifTrue: [ ^self urlAction: theLine reportOn: report ].	(line beginsWith: 'Installer mantis fixBug:') ifTrue: [ ^self mantisAction: theLine reportOn: report ].			aBlock value.! !!Installer methodsFor: 'action report' stamp: 'kph 1/8/2007 11:14'!extractFromHtml: html option: allOrLast	|  start stop test in |	start := self markersBegin.	stop :=  self markersEnd.	test := self markersTest.			 	in := ReadWriteStream with: String new.			[ html upToAll: start; atEnd ] 		whileFalse: [			| chunk |			(allOrLast == #last) ifTrue: [ in resetToStart ]. 			chunk := html upToAll: stop.			self isSkipLoadingTestsSet ifTrue: [ chunk := chunk readStream upToAll: test ].			in nextPutAll: chunk. 		 ].	^self removeHtmlMarkupFrom: in reset	 ! !!Installer methodsFor: 'action report' stamp: 'kph 1/8/2007 11:19'!mantisAction: line reportOn: report		| param mantis |		mantis := Installer mantis.		param :=  line readStream upTo: $: ; upTo: $..		mantis setBug: ((param readStream upTo: $'; atEnd)		 ifTrue: [  param ]		 ifFalse: [ param readStream upTo: $'; upTo: $' ]).		self reportSection: line on: report.			report nextPutAll: (mantis replaceEntitiesIn: mantis markersBegin readStream).		self reportFor: line page: mantis maScript on: report.		report nextPutAll: (mantis replaceEntitiesIn: mantis markersEnd readStream); cr.	! !!Installer methodsFor: 'action report' stamp: 'kph 1/8/2007 08:17'!reportFor: theLine page: thePage on: report  		[ thePage atEnd ] whileFalse: [ 		| line |		line := thePage nextLine.		self actionMatch: line reportOn: report ifNoMatch: [ report nextPutAll: line; cr. ] 		].! !!Installer methodsFor: 'action report' stamp: 'kph 1/8/2007 11:20'!reportSection: line on: report		report isEmpty ifFalse: [ report cr ].		report nextPutAll: '">>>> ' ; nextPutAll: (line copyWithout: $"); nextPut: $"; cr.	! !!Installer methodsFor: 'action report' stamp: 'kph 1/8/2007 11:19'!urlAction: line reportOn: report  	url :=  line readStream upTo: $' ; upTo: $'.  		self reportSection: line on: report.	(pageDataStream := self urlGet: self urlToDownload) 		ifNil: [ self error: 'unable to contact host' ].	 		self reportFor: line page: pageDataStream on: report ! !!Installer methodsFor: 'action report' stamp: 'kph 1/8/2007 11:19'!webAction: line reportOn: report		package :=  line readStream upTo: $' ; upTo: $'.	self reportSection: line on: report.	 	url := self webFindUrlToDownload.		self reportFor: line page: pageDataStream on: report ! !!Installer methodsFor: 'auto answering' stamp: 'kph 10/17/2006 13:07'!answer: aString with: anAnswer^self answers add: ( Array with: aString with: anAnswer )! !!Installer methodsFor: 'auto answering' stamp: 'kph 10/17/2006 14:30'!suppress: aMessagemessagesToSuppress add: aMessage! !!Installer methodsFor: 'accessing' stamp: 'kph 10/17/2006 13:06'!answers^ answers ifNil: [ answers := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 06:55'!answers: anObject	"Set the value of answers"	answers := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 11/7/2006 05:06'!bug	"Answer the value of bug"	^ bug! !!Installer methodsFor: 'accessing' stamp: 'kph 12/21/2006 02:42'!date: anObject	"Set the value of markers"	date := anObject asDate! !!Installer methodsFor: 'accessing' stamp: 'kph 1/8/2007 07:22'!desc	 	^ desc! !!Installer methodsFor: 'accessing' stamp: 'kph 1/8/2007 07:22'!desc: anObject	desc := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 11/12/2006 16:16'!infoself sm ifTrue: [ ^ self smInfo  ].self wsm ifNotNil: [ ^ self wsmInfo  ].! !!Installer methodsFor: 'accessing' stamp: 'kph 1/5/2007 00:08'!installself logErrorDuring: [	self mc ifNotNil: [ ^self mcInstall ].	self wsm ifNotNil: [ ^self wsmInstall ].	self sm ifTrue: [ ^self smInstall ].	self url ifNotNil: [ ^self urlInstall ].	self package ifNotNil: [ ^self webInstall ].] ! !!Installer methodsFor: 'accessing' stamp: 'kph 10/18/2006 11:29'!install: packageNameCollectionOrDetectBlockself package: packageNameCollectionOrDetectBlock.self install! !!Installer methodsFor: 'accessing' stamp: 'kph 12/21/2006 02:07'!isSkipLoadingTestsSet^SkipLoadingTests ifNil: [ false ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 06:55'!ma	"Answer the value of ma"	^ ma! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 07:07'!ma: aUrl 	"Set the value of host"	ma := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!Installer methodsFor: 'accessing' stamp: 'kph 1/4/2007 07:06'!markers	"Answer the value of markers"	^ markers ifNil: [ '<code st>..."test ...</code st>' ]! !!Installer methodsFor: 'accessing' stamp: 'kph 11/7/2006 05:06'!markers: anObject	"Set the value of markers"	markers := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:38'!mc	"Answer the value of mc"	^ mc! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 07:07'!mc: aUrl 	"Set the value of host"	mc := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/17/2006 14:30'!messagesToSuppress^ messagesToSuppress ifNil: [ messagesToSuppress := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 06:55'!messagesToSuppress: anObject	"Set the value of messagesToSuppress"	messagesToSuppress := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 2/1/2007 20:01'!open	self sm ifTrue: [ self classSMLoader open ].self mc ifNotNil: [self mcRepository morphicOpen: nil ].! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 04:05'!package	"Answer the value of package"	^ package! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 04:05'!package: anObject	"Set the value of package"	package := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 11/12/2006 16:23'!packages	self sm ifTrue: [ ^self smPackages ].self mc ifNotNil: [ ^self mcRepository allFileNames ].self wsm ifNotNil: [ ^self wsmPackagesByName keys ].! !!Installer methodsFor: 'accessing' stamp: 'kph 11/7/2006 05:06'!packages: anObject	"Set the value of packages"	packages := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 04:16'!password	"Answer the value of password"	^ password  ifNil: [ '' ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 03:56'!password: anObject	"Set the value of password"	password := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 11/8/2006 00:56'!printOn: s s nextPutAll: '(Installer'.self sm ifTrue: [ s nextPutAll: ' squeakmap' ].self ma ifNotNil: [ s nextPutAll: ' mantis' ].self wsm ifNotNil: [ s nextPutAll: ' websqueakmap' ].self url ifNotNil: [ s nextPutAll: ' url:''', self url,'''' ].self mc ifNotNil: [ s nextPutAll: ' repository:''', self mc,'''' ].s nextPut: $).self project ifNotNil: [ s nextPutAll: ' project:';  						nextPutAll: '''', self project, ''''.					   self package ifNotNil: [ s nextPutAll: '; '] ].					self package ifNotNil: [ s nextPutAll: ' package:';  						 nextPutAll: '''', self package asString, '''' ].					s nextPut: $..! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:30'!project	"Answer the value of project"	^ project! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:33'!project: anObject	"Set the value of project"	project := anObject.	^self copy.! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:55'!sm	"Answer the value of sm"	^ sm ifNil: [ false ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:38'!sm: anObject	"Set the value of sm"	sm := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 11/7/2006 04:23'!url^url! !!Installer methodsFor: 'accessing' stamp: 'kph 11/7/2006 04:23'!url: aUrl  url := aUrl! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 04:15'!user	"Answer the value of user"	^ user ifNil: [ '' ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 03:56'!user: anObject	"Set the value of user"	user := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 10/21/2006 05:50'!versions	self sm ifTrue: [ ^self smVersions ].self mc ifNotNil: [ ^self mcVersions ].self wsm ifNotNil: [ ^self wsmVersions ].! !!Installer methodsFor: 'script bindings' stamp: 'kph 1/8/2007 00:11'!bindingOf: aString 		Bindings isNil ifTrue: [ Bindings := Dictionary new].	(Bindings includesKey: aString)		ifFalse: [Bindings at: aString put: nil].	^ Bindings associationAt: aString.! !!Installer methodsFor: 'script bindings' stamp: 'kph 1/11/2007 02:03'!unload: categoryMatchesString  (SystemOrganization categoriesMatching: categoryMatchesString) do: [ :cat |      self logCR: 'Unloading ', cat. 	(MCPackage named: cat)  workingCopy unload.	SystemOrganization removeCategory: cat. ]."Until Mantis 5718 is addressed" Smalltalk at: #PackagePaneBrowser ifPresent: [ :ppbClass | ppbClass allInstancesDo: [ :ppb | ppb updatePackages ]  ]. Smalltalk at: #Browser ifPresent: [ :bClass | bClass allInstancesDo: [ :b | b updateSystemCategories ] ].! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:48'!bug: aBugNo"Installer mantis viewBug: 5639."	| page text | 	self setBug: aBugNo.		page := self maPage. 	text := String streamContents: [ :str |						#('Bug ID' 'Category' 'Severity' 'Reproducibility' 'Date Submitted' 			'Date Updated' 'Reporter' 'View Status' 'Handler' 			'Priority' 'Resolution' 'Status' 'Product Version' 'Summary' 'Description' 'Additional Information' ) 				do: [ :field |						| f |						f := self maRead: page field: field.			str nextPutAll: f key; nextPutAll: ': '; nextPutAll: f value; cr.		].		str nextPutAll: 'Notes: '; cr.		(self maReadNotes: page) do: [ :note | str nextPutAll: note; cr; cr ].				str nextPutAll: 'Files: '; nextPutAll: self maFiles keys asArray printString.	]. 	^ text	! !!Installer methodsFor: 'mantis' stamp: 'kph 12/18/2006 04:11'!bug: aBugNo fix: aFileName	^ self bug: aBugNo fix: aFileName date: nil! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 10:08'!bug: aBugNo fix: aFileName date: aDate 	| stream |	self setBug: aBugNo.	self logCR: 'obtaining ', aFileName, '...'.	stream := self maStreamForFile: aFileName.	self ditchOldChangeSetFor: aFileName.	self maCheckDateAgainst: aDate.	self install: aFileName from: stream.	self class fixesApplied add: aBugNo.			^ date! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:49'!bug: aBugNo retrieve: aFileName	 self setBug: aBugNo.	^ (self maStreamForFile: aFileName) contents! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:48'!bug: aBugNo view: aFileName	| file list |		self setBug: aBugNo.		file :=  self maStreamForFile: aFileName.	list := self classChangeList new			scanFile:  file from: 1 to: file size.		 	self classChangeList open: list name: (aFileName, ' mantis: ', aBugNo printString) 		multiSelect: true.! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 10:10'!ensureFix: aBugNo	| fixesAppliedNumbers |		self setBug: aBugNo.		fixesAppliedNumbers := self class fixesApplied collect: [ :fixDesc | fixDesc asInteger ].		(fixesAppliedNumbers includes: bug) ifFalse: [ self fixBug: aBugNo ]! !!Installer methodsFor: 'mantis' stamp: 'kph 1/7/2007 16:18'!ensureFixes: aBugNos	aBugNos do: [ :bugNo | self ensureFixes: bugNo ].! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:40'!evaluate: streamstream fileIn.! !!Installer methodsFor: 'mantis' stamp: 'kph 12/18/2006 04:12'!fixBug: aBugNo	^ self fixBug: aBugNo date: nil! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 11:45'!fixBug: aBugNo date: aDate	self setBug: aBugNo.	 	self install: self maUrl from: self maScript.		self maCheckDateAgainst: aDate.			! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:43'!install: aFileName from: stream| ext installSelector |	 	self log: 'installing...'. 	ext := aFileName copyAfterLast: $..	installSelector := ('install', ext asUppercase, ':from:') asSymbol.		self withAnswersDo:	[		(self respondsTo: installSelector)			ifTrue: [ self perform: installSelector with: aFileName with: stream ]			ifFalse: [ self installDefault: aFileName from: stream ].	]. 	self log: '.done' ! !!Installer methodsFor: 'mantis' stamp: 'kph 1/30/2007 01:06'!installCS: aFileName from: stream	self ditchOldChangeSetFor: aFileName.	self newChangeSetFromStream: stream named: (self validChangeSetName: aFileName).! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:42'!installDefault: aFileName from: streamstream fileIn.! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:42'!installGZ: aFileName from: stream 	"FileIn the contents of a gzipped stream"	| zipped unzipped |	 	zipped := self classGZipReadStream on: stream.	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	self  newChangeSetFromStream: unzipped named:aFileName.	! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:42'!installMCZ: aFileName from: stream 	self classMczInstaller ifNotNilDo: [ :reader | ^reader installStream: stream].  	self classMCMczReader ifNotNilDo: [ :reader | ^(reader versionFromStream: stream) load]. 	self error: 'no monticello readers available'.  ! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:42'!installSAR: aFileName from: stream  | newCS |	self classSARInstaller withCurrentChangeSetNamed: aFileName		do: [:cs | newCS := cs. self classSARInstaller new fileInFrom: stream].	newCS isEmpty ifTrue: [ self classChangeSet removeChangeSet: newCS ]! !!Installer methodsFor: 'mantis' stamp: 'kph 1/4/2007 06:43'!justFixBug: aBugNo	^self class skipLoadingTests: true during: [ self fixBug: aBugNo date: nil ]! !!Installer methodsFor: 'mantis' stamp: 'kph 1/4/2007 06:43'!justFixBug: aBugNo date: d	^self class skipLoadingTests: true during: [ self fixBug: aBugNo date: d ]! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 11:37'!maFiles  | file files bugPage id  |   files := Dictionary new.  bugPage := self maPage. [  id := bugPage upToAll: 'href="file_download.php?file_id='; upTo: $&.  file := bugPage upToAll: 'amp;type=bug"' ; upTo: $<.  ((file size > 1) and: [file first = $>]) ifTrue: [ files at: file copyWithoutFirst put: id ].  id notEmpty ] whileTrue.^files ! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:54'!maPage  "  self mantis bug: 5251. " | page |page :=  self httpGet: self maUrl. date := ((self maRead: page field: 'Date Updated') value upTo: $ ) asDate. ^page reset! !!Installer methodsFor: 'mantis' stamp: 'kph 12/23/2006 04:50'!maRead: page field: fieldKey	 | value | 	value := page upToAll: ('!!-- ', fieldKey, ' -->'); upToAll: '<td'; upTo: $>; upToAll: '</td>'.		page upTo: $<.		page peek = $t ifTrue: [ value := page upToAll: 'td'; upTo: $>; upToAll: '</td>' ].	  	^Association key: fieldKey value: value withBlanksTrimmed! !!Installer methodsFor: 'mantis' stamp: 'kph 12/23/2006 05:54'!maReadNotes: page 	 |  notes note  | 	notes := OrderedCollection new.	[ page upToAll: 'tr class="bugnote"'; upTo: $>.	  page atEnd ]			whileFalse: [ 		note := (self removeHtmlMarkupFrom: (page upToAll: '</tr>') readStream) contents.		note := note withBlanksCondensed.		"note replaceAll: Character cr with: $ ."		note replaceAll: Character lf with: Character cr.		notes add: note  	].		^notes! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 10:01'!maScript 	^self extractFromHtml: self maPage option: #last! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:48'!maStreamForFile: aFileName	| fileId  | 	fileId :=  self maFiles at: aFileName ifAbsent: [ self error: aFileName, ' not found' ]. 	^ self httpGet: (self ma, 'file_download.php?file_id=' , fileId , '&type=bug').	 ! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:54'!maUrl 	^ url := self ma, 'view.php?id=', bug asString ! !!Installer methodsFor: 'mantis' stamp: 'kph 12/18/2006 04:08'!maUrlFor: maBugNo 	^ url := self ma, 'view.php?id=', maBugNo asString  ! !!Installer methodsFor: 'mantis' stamp: 'kb 12/18/2006 13:01'!newChangeSetFromStream: aStream named: aName 	"This code is based upon ChangeSet-c-#newChangesFromStream:named: which is in 3.9,	implemented here for previous versions. The second branch is for 3.8, where ChangeSets	are loaded by ChangeSorter. "	| oldChanges newName newSet newStream |	(self classChangeSet respondsTo: #newChangesFromStream:named:) 		ifTrue: [ ^self classChangeSet newChangesFromStream: aStream named:aName ].	(self classChangeSorter respondsTo: #newChangesFromStream:named:)		ifTrue: [ ^self classChangeSorter newChangesFromStream: aStream named: aName ].	oldChanges := ChangeSet current. 	"so a Bumper update can find it"	newName := aName sansPeriodSuffix.	newSet := self classChangeSet basicNewNamed: newName.	[newSet		ifNotNil: [(aStream respondsTo: #converter:)				ifTrue: [newStream := aStream]				ifFalse: [newStream := self classMultiByteBinaryOrTextStream with: aStream contentsOfEntireFile.					newStream reset].			self classChangeSet newChanges: newSet.			newStream setConverterForCode.			newStream fileInAnnouncing: 'Loading ' , newName , '...'.			Transcript cr; show: 'File ' , aName , ' successfully filed in to change set ' , newName].	aStream close]		ensure: [self classChangeSet newChanges: oldChanges].	 	^ newSet! !!Installer methodsFor: 'mantis' stamp: 'edc 5/8/2007 16:45'!preambleCsForRB: aBugNo"Installer mantis preambleCsForRB: 5936."	| page text   | 	self setBug: aBugNo.		page := self maPage. 	text := String streamContents: [ :str |						#('Reporter'  'Summary' 'Description' 'Additional Information' ) 				do: [ :field |						| f |						f := self maRead: page field: field.			str nextPutAll: f key; nextPutAll: ': '; nextPutAll: f value; cr.		]	]. 	^ text	! !!Installer methodsFor: 'mantis' stamp: 'kph 1/30/2007 14:18'!setBug: stringOrNumber   | str |  stringOrNumber isInteger ifTrue: [ bug := stringOrNumber. desc := ''. ^self ].  bug := stringOrNumber asInteger. str := str printString.  desc := stringOrNumber copyFrom: (str size + 1) to: (stringOrNumber size) ! !!Installer methodsFor: 'mantis' stamp: 'kph 12/21/2006 01:28'!skipTests! !!Installer methodsFor: 'mantis' stamp: 'kph 12/23/2006 06:02'!viewBug: aBugNo	^Workspace new contents: (self bug: aBugNo); openLabel: ('Mantis ', aBugNo printString).! !!Installer methodsFor: 'class references' stamp: 'kph 12/23/2006 02:05'!classChangeList^Smalltalk at: #ChangeList  ifAbsent: [ self error: 'ChangeList not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 11/16/2006 22:17'!classChangeSet^Smalltalk at: #ChangeSet  ifAbsent: [ self error: 'ChangeSet not present' ]! !!Installer methodsFor: 'class references' stamp: 'kb 12/18/2006 12:40'!classChangeSorter^Smalltalk at: #ChangeSorter ifAbsent: [ self error: 'ChangeSorter not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 11/16/2006 22:16'!classGZipReadStream^Smalltalk at: #GZipReadStream  ifAbsent: [ self error: 'Compression not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 11/16/2006 15:42'!classHTTPSocket^Smalltalk at: #HTTPSocket ifAbsent: [ self error: 'Network package not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 11/17/2006 03:15'!classMCHttpRepository^Smalltalk at: #MCHttpRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!Installer methodsFor: 'class references' stamp: 'kph 11/17/2006 02:46'!classMCMczReader^Smalltalk at: #MCMczReader ifAbsent: [ nil ]	! !!Installer methodsFor: 'class references' stamp: 'kph 11/17/2006 02:44'!classMczInstaller^Smalltalk at: #MczInstaller ifAbsent: [ nil ]	! !!Installer methodsFor: 'class references' stamp: 'kph 11/23/2006 03:18'!classMultiByteBinaryOrTextStream^Smalltalk at: #MultiByteBinaryOrTextStream  ifAbsent: [ self error: 'MultiByteBinaryOrTextStream not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 11/16/2006 15:40'!classSARInstaller^Smalltalk at: #SARInstaller  ifAbsent: [ self error: 'SARInstaller not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 2/1/2007 20:02'!classSMLoader^Smalltalk at: #SMLoader  ifAbsent: [ self error: 'SqueakMap Loader not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 11/16/2006 15:40'!classSMSqueakMap^Smalltalk at: #SMSqueakMap  ifAbsent: [ self error: 'SqueakMap not present' ]! !!Installer methodsFor: 'utils' stamp: 'kph 1/30/2007 15:15'!ditchOldChangeSetFor: aFileName 	| changeSetName | 	changeSetName := (self validChangeSetName: aFileName) sansPeriodSuffix.	(self classChangeSet named: changeSetName)		ifNotNil: [  					(self logCR:'Removing old change set ', changeSetName) cr.				self classChangeSet removeChangeSet: (self classChangeSet named: changeSetName) ].! !!Installer methodsFor: 'utils' stamp: 'kph 12/18/2006 06:50'!httpGet: aUrl	| page |	page := self classHTTPSocket httpGet: aUrl accept: 'application/octet-stream'.   	(page respondsTo: #reset)  ifFalse: [ self error: 'unable to contact web site' ]. 	^ page	! !!Installer methodsFor: 'utils' stamp: 'kph 12/21/2006 02:51'!maCheckDateAgainst: okDate	(okDate notNil and: [date < okDate asDate ]) ifTrue: [ self notify: 'bug ', self bug asString, ' updated on ', date printString ]. ! !!Installer methodsFor: 'utils' stamp: 'kph 1/7/2007 15:57'!viewUrl	^Workspace new contents: (self urlGet contents); openLabel: self urlToDownload.! !!Installer methodsFor: 'url' stamp: 'kph 1/10/2007 04:50'!isHtmlStream: page	"matches  '<!!DOCTYPE HTML', and <html>' "		| first |			first := (page next: 14) asUppercase.		^ (first = '<!!DOCTYPE HTML') | (first beginsWith: '<HTML>')	! !!Installer methodsFor: 'url' stamp: 'kph 12/21/2006 01:54'!markersBegin		 	 	 ^ self markers upTo: $.! !!Installer methodsFor: 'url' stamp: 'kph 12/23/2006 04:02'!markersEnd		"return the third marker or the second if there are only two"		| str  a |		 	 	 str := self markers readStream.	 a := str upToAll: '...'; upToAll: '...'.	 str atEnd  ifTrue: [ ^a ] ifFalse: [ ^str upToEnd ]	! !!Installer methodsFor: 'url' stamp: 'kph 12/21/2006 01:56'!markersTest		 	 	 ^ self markers readStream upToAll: '...'; upToAll: '...'! !!Installer methodsFor: 'url' stamp: 'kph 1/8/2007 11:16'!removeHtmlMarkupFrom: in 	| out | 	out := ReadWriteStream on: (String new: 100).	[ in atEnd ] whileFalse: [ 		out nextPutAll: (in upTo: $<).		(((in upTo: $>) asLowercase beginsWith: 'br') and: [ (in peek = Character cr) ]) ifTrue: [ in next ].		].		^self replaceEntitiesIn: out reset.! !!Installer methodsFor: 'url' stamp: 'kph 1/8/2007 11:15'!replaceEntitiesIn: in	| out |		out := ReadWriteStream on: (String new: 100).	[ in atEnd ] whileFalse: [ 		out nextPutAll: ((in upTo: $&) replaceAll: Character lf with: Character cr).		in atEnd ifFalse: [ out nextPutAll: (self class entities at: (in upTo: $;) ifAbsent: '?') ].		].	^out reset! !!Installer methodsFor: 'url' stamp: 'kph 1/7/2007 02:15'!urlGet^ self urlGet: self urlToDownload! !!Installer methodsFor: 'url' stamp: 'kph 1/10/2007 04:35'!urlGet: aUrl	| page |	page := HTTPSocket httpGet: aUrl accept: 'application/octet-stream'.   	(page respondsTo: #reset)  ifFalse: [ ^ nil ]. 	(self isHtmlStream: page) ifTrue: [ page := self extractFromHtml: page option: nil ].	^ page reset	! !!Installer methodsFor: 'url' stamp: 'kph 1/8/2007 07:03'!urlInstall "Installer installUrl: 'wiki.squeak.org/742'." 	self logCR: 'retrieving ', self urlToDownload , ' ...'.		(pageDataStream := self urlGet: self urlToDownload) 		ifNil: [ self error: 'unable to contact host' ].	 	self install: self urlToDownload from: pageDataStream.		^ pageDataStream ! !!Installer methodsFor: 'url' stamp: 'kph 1/4/2007 23:49'!urlToDownload	^ (self url, (self package ifNil: [ '' ])) asUrl asString.	 ! !!Installer methodsFor: 'url' stamp: 'kph 1/7/2007 02:16'!urlView^ self urlGet: self urlToDownload! !!Installer methodsFor: 'url' stamp: 'kb 12/18/2006 13:30'!validChangeSetName: aFileName	" dots in the url confuses the changeset loader. I replace them with dashes" 	self url ifNotNil: [ | asUrl |		asUrl := Url absoluteFromText: aFileName.		^String streamContents: [:stream |			stream nextPutAll: (asUrl authority copyReplaceAll: '.' with: '-').			asUrl path allButLastDo: [:each |				stream					nextPutAll: '/';					nextPutAll: (each copyReplaceAll: '.' with: '-') ].			stream				nextPutAll: '/';				nextPutAll: asUrl path last ] ].	^aFileName! !!Installer methodsFor: 'logging' stamp: 'kph 12/18/2006 04:51'!log: text^Transcript show: text.! !!Installer methodsFor: 'logging' stamp: 'kph 12/18/2006 04:53'!logCR: text^ Transcript cr; show: text! !!Installer methodsFor: 'logging' stamp: 'kph 1/30/2007 01:28'!logErrorDuring: block(IsSetToTrapErrors == false) ifTrue: [ ^ block value ].block on: Error do: [ :e | self logCR: e messageText. ]! !!Installer methodsFor: 'searching' stamp: 'kph 1/4/2007 23:59'!match: aMatch	^self packagesMatching: aMatch! !!Installer methodsFor: 'searching' stamp: 'kph 11/12/2006 23:19'!packagesMatching: aMatchself sm ifTrue: [ ^ (self packages select: [ :p | aMatch match: p name ]) collect: [ :p | self copy package: p name; yourself ] ].self mc ifNotNil: [ ^ (self packages select: [ :p | ( aMatch , '.mcz' ) match: p ]) collect: [ :p | self copy package: p ; yourself ] ].self wsm ifNotNil: [ ^ (self packages select: [ :p | ( aMatch) match: p ]) collect: [ :p | self copy package: p ; yourself ] ].^'search type not supported'! !!Installer methodsFor: 'searching' stamp: 'kph 11/12/2006 23:19'!search: aMatchself sm ifTrue: [ ^ self smSearch: ('*',aMatch,'*') ].self mc ifTrue: [ ^ self mcSearch: ('*',aMatch,'*')  ].self wsm ifNotNil: [ ^ self wsmSearch: ('*',aMatch,'*')  ].^'search type not supported'! !!Installer methodsFor: 'searching' stamp: 'kph 11/12/2006 23:28'!smSearch: aMatch  	| results |		results := Set new.	self packages do: [ :pkg |		({ 'name:',pkg name.		   'summary:', pkg summary.		   'description:', pkg description.		   'author:', pkg author. } anySatisfy: [ :field | aMatch match: field ])		 ifTrue: [ results add: (self copy package: pkg name) ]. 	].	^results! !!Installer methodsFor: 'monticello' stamp: 'kph 11/17/2006 03:16'!mcInstall	| repository sortMczs files fileToLoad  version detectFileBlock  count |	self logCR: 'installing ', self package asString, '...'.	self package isString ifTrue: [ detectFileBlock := [ :file | file beginsWith: self package ] ].	(self package isKindOf: Array) 			ifTrue: [ detectFileBlock :=  [ :file | (self package detect: [ :item | file beginsWith: item ] ifNone: [ false ]) ~= false ] ].	self package isBlock ifTrue: [ detectFileBlock := self package ].  	repository := self mcRepository.	sortMczs := [:a :b |         	[(a findBetweenSubStrs: #($.)) allButLast last asInteger > (b findBetweenSubStrs: #($.)) allButLast last asInteger] on: Error do: [:ex | false]].	"several attempts to read files - repository readableFileNames sometimes fails"	count := 0. fileToLoad := nil.		[count := count + 1.	 (fileToLoad = nil) and:[ count < 5 ] ] 		whileTrue: [						files := repository readableFileNames asSortedCollection: sortMczs.						fileToLoad := files detect: detectFileBlock ifNone: [ nil ].																						].	version := repository versionFromFileNamed: fileToLoad.	version workingCopy repositoryGroup addRepository: repository.	repository creationTemplate: 'MCHttpRepository        	location: ''', self mcUrl, '''        	user: ''', self user, '''        	password: ''', self password, ''''.	self log: ' ', version fileName, '...'.	self withAnswersDo: [ version load ].	self log: 'done'.! !!Installer methodsFor: 'monticello' stamp: 'kph 11/16/2006 17:47'!mcRepository^self classMCHttpRepository location: (self mcUrl) user: self user password: self password.! !!Installer methodsFor: 'monticello' stamp: 'kph 12/17/2006 17:58'!mcUrl^ self mc, (self project ifNil: [''])! !!Installer methodsFor: 'monticello' stamp: 'kph 10/21/2006 05:47'!mcVersions^ (self packages select: [ :p | ( self package,'-*.mcz' ) match: p ]) collect: [ :p | self copy package: p  ; yourself ]. ! !!Installer methodsFor: 'monticello' stamp: 'kph 10/21/2006 06:52'!withAnswersDo: aBlock	(aBlock respondsTo: #valueSuppressingMessages:supplyingAnswers: )		ifTrue: [aBlock valueSuppressingMessages: self messagesToSuppress supplyingAnswers: self answers.]		ifFalse: [ aBlock value ]! !!Installer methodsFor: 'squeakmap' stamp: 'kph 10/21/2006 06:54'!smInstall 	| pkgAndVersion releases release |	pkgAndVersion := self smPackageAndVersion.	self logCR: 'installing ', self package, ' from SqueakMap...'.	releases := self smReleasesForPackage: pkgAndVersion first. 		release := pkgAndVersion last isEmpty ifTrue: [ releases last ]					ifFalse:[ releases detect: [ :rel | rel version = pkgAndVersion last ] ]. 		self withAnswersDo: [ release install ].	self log: ' done'.! !!Installer methodsFor: 'squeakmap' stamp: 'kph 10/17/2006 15:24'!smPackageAndVersion| p |p := ReadStream on: self package .^Array with: (p upTo: $() with: (p upTo: $)).! !!Installer methodsFor: 'squeakmap' stamp: 'kph 2/1/2007 19:14'!smPackages	^self classSMSqueakMap default packagesByName! !!Installer methodsFor: 'squeakmap' stamp: 'kph 11/16/2006 15:40'!smReleasesForPackage: name ^(self classSMSqueakMap default packageWithName: name) releases! !!Installer methodsFor: 'squeakmap' stamp: 'kph 11/12/2006 16:54'!smVersions ^ (self smReleasesForPackage: self package) collect: [ :v | self copy package: (v package name,'(',v version,')'); yourself. ]  ! !!Installer methodsFor: 'web install' stamp: 'kph 1/30/2007 00:53'!webFindUrlToDownload	self class webSearchPath do: [ :pathSpec | 		| potentialUrl readPathSpec  |			readPathSpec := pathSpec readStream.		potentialUrl := (readPathSpec upTo: $*), package, (readPathSpec upToEnd ifNil: [ '' ]).			pageDataStream := self urlGet: potentialUrl.				pageDataStream notNil ifTrue: [ ^potentialUrl ]	].	^nil! !!Installer methodsFor: 'web install' stamp: 'kph 1/30/2007 00:56'!webInstall "Installer install: 'MyPage'." 	url := self webFindUrlToDownload ifNil: [ self logCR: 'url not found'. self error: 'url not found' ].		self logCR: 'found ',  url, ' ...'.		pageDataStream size > 0 		ifTrue: [ self install: url from: pageDataStream ]		ifFalse: [ self logCR: '...',url,' was empty' ].		^ pageDataStream.	! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 10/21/2006 01:37'!wsm	"Answer the value of wsm"		^ wsm! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 10/21/2006 01:37'!wsm: aUrl 	"Set the value of host"	wsm := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 12/18/2006 06:49'!wsmDownloadUrl | pkgAndVersion packageId packageName packageVersion releaseAutoVersion downloadPage |	pkgAndVersion := self smPackageAndVersion.	packageName := pkgAndVersion first.	packageVersion := pkgAndVersion last.	packageVersion isEmpty ifTrue: [ packageVersion := #latest ].	packageId := self wsmPackagesByName at: packageName.	releaseAutoVersion := (self wsmReleasesFor: packageId) at: packageVersion.					 	downloadPage := self httpGet: (self wsm,'packagebyname/', packageName,'/autoversion/', releaseAutoVersion,'/downloadurl') asUrl asString.				 		 	^ downloadPage contents	! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 1/8/2007 06:43'!wsmInstall 	| downloadUrl |	self logCR: 'finding ', self package, ' from websqueakmap(', self wsm, ') ...'.	downloadUrl := self wsmDownloadUrl.		self logCR: 'found at ', downloadUrl asString, ' ...'.	 	self install: downloadUrl from: (self httpGet: downloadUrl).	! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 12/18/2006 06:51'!wsmPackagesByName	| html id name | 		packages ifNotNil: [ ^packages ].		packages := Dictionary new.		html := self httpGet: (self wsm, 'packagesbyname').		[		id := html upToAll: '/package/'; upToAll: '">'.		name := html upTo: $<.				(id notEmpty and: [ name notEmpty ]) 	] whileTrue: [ packages at: name put: id ].	^ packages		! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 12/18/2006 06:50'!wsmReleasesFor: packageId	| html autoVersion version releases |			releases := Dictionary new.		html := self httpGet: (self wsm, '/package/', packageId ).		[		releases at: #latest put: autoVersion.		autoVersion := html upToAll: '/autoversion/'; upTo: $".		version := html upTo: $-; upTo: $<.				(autoVersion notEmpty and: [version notEmpty ]) 	] whileTrue: [ releases at: version put: autoVersion ].	^ releases	! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 10/21/2006 06:04'!wsmVersions| pkgAndVersion packageId packageName packageVersion versions |	pkgAndVersion := self smPackageAndVersion.	packageName := pkgAndVersion first.	packageVersion := pkgAndVersion last.	packageVersion isEmpty ifTrue: [ packageVersion := #latest ].	packageId := self wsmPackagesByName at: packageName.		versions := (self wsmReleasesFor: packageId) keys.	versions remove: #latest.		^ versions collect: [ :version | self copy package: (packageName,'(', version ,')'); yourself ]. ! !!Installer commentStamp: 'kph 1/7/2007 22:53' prior: 0!Installer provides a simple Domain Specific Language for installing packages from monticello and squeakmap of various version.One design decision is to be able to paste scripts a workspace and run and tested from there without any special editing.Installer can also be used as a squeak startup document with various commandline parameters.example 1 (non working example)unix$ squeak Squeak3.8-7067 http://installer.pbwiki.com/f/Installer.st Url="http://..." saveas="MyImage" postinstall=Tester done=quitThis will load installer as the startup document, installer will install a file/script from the given url, then the image will be saved in the given filename, and processing is then passed on to the class Tester, once complete the image will quit.supported parameters:P|PATH=prefix1*suffix1;...;prefixN*suffixNI|IN|INSTALL=aPage (needs PATH)U|URL=aUrlO|OUT|SAVEAS=aFileName+S|SAVEP|TEST|POSTINSTALL=aClassName | aPage(given PATH) | aUrlDONE= save | quit | save&quit | aClassName+SKIPTESTSexample 2: (working example)unix$ squeak Squeak3.8-7067 http://installer.pbwiki.com/f/Installer.st path=wiki.squeak.org/squeak/;installer.pbwiki.com/*-alt in=CommandLineExample2 done=quit.===Examples - Using SqueakMap1)squeakmap := Installer squeakmap.squeakmap install: 'DynamicBindings'.squeakmap open. "opens the squeak map loader gui"2)Installer squeakmap install: 'DynamicBindings'.3) Alternatively using websqueakmap which uses http (similar usage api to squeakmap)squeakmap := Installer websqueakmap.squeakmap package: 'DynamicBindings'; install.4) Abbreviated instanciationsqueakmap := Installer sm. "squeakmap"squeakmap := Installer wsm. "web-squeakmap"5) Finding Packages by Name(Installer sm match: 'Labby*') explore.6) Obtaining List of Package Versions(Installer sm package: 'Labby & Walker'; versions)  explore.  6) Searching PackagesInstaller sm search: 'seaside'.Installer sm search: 'author:*Smith'. "fields available for searching: author: name:, summary:,description:"7) Specify specific version of a package for installationInstaller sm install: 'Labby(17)'.Examples - Using Monticello1)squeaksource := Installer repository: 'http://www.squeaksource.com'.seaside := squeaksource project: 'Seaside'.seaside install: 'Comet-lr.8';		install: 'Scriptaculous'.2) squeaksource := Installer repository: 'http://www.squeaksource.com'		squeaksource project: 'Seaside';			  install: 'Comet-lr.8;			  install: 'Scriptaculous'.3) Supplying user/password.squeaksource := Installer repository: 'http://www.squeaksource.com'.squeaksource user: 'me'; password: 'asecret'.4) Abbreviated instanciation for convenience.squeaksource := Installer squeakSource.orsqueaksource := Installer ss.Examples - install straight from a url		1a)(Installer url: 'http://minnow.cc.gatech.edu/squeak/uploads/5889/MakeTestsGreen39.cs') install.1b)Installer installUrl: 'http://minnow.cc.gatech.edu/squeak/uploads/5889/MakeTestsGreen39.cs'.2)| page |page := Installer url: 'http://minnow.cc.gatech.edu/squeak/uploads/5889/'.page package: 'MakeTestsGreen39.cs'.page install.3)In html page scripts are delimited by <code st>...</code st>| page |page := Installer url: 'http://wiki.squeak.org/squeak/742'.page install.4)specify your own delimeters| page |page := Installer url: 'http://wiki.squeak.org/742'.page markers: 'beginning of script...end of script'.page install.Note: Scripts embedded in html or a swiki page may need to escape some entities.Supported entities are &amp; &gt; &lt; &star; &quot; (see Installer-c-entities)Examples - Using Mantis1 . Viewing a file uploaded to a mantis bug reportInstaller mantis bug: 4874 view: 'Join.4.cs'.1. Installing a file uploaded to a mantis bug reportInstaller mantis bug: 4874 fix: 'Join.4.cs'.2. as above, inform user if bug report has been updated since a given date Installer mantix	bug: 4874 fix: 'JoinTest.1.cs' date: '12-18-06'. 	3. Install or view a fix for a given bug.Installer mantis viewBug: 4874.Installer mantis fixBug: 4874.The fix script is published in a note added to the bug report page with the following syntax"fix begin" Installer mantis bug: 474 fix: 'Join.4.cs'."fix test" Installer mantis bug: 474 fix: 'JoinTest.1.cs' date: '12-18-06'. "fix end"4. Install a fix for a given bug, ignoring all test code(test code being delimeted by: "fix test" ... "fix end" )Installer mantis justFixBug: 474.orInstaller mantis justFixBug: 474 date: '12-19-06'.!!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 12/21/2006 02:08'!cancelSkipLoadingTests"sets a flag to un-ignore loading of the testing portion of scripts embedded in pages"SkipLoadingTests := false. ! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 1/11/2007 00:17'!do: webPageNameself webSearchPath isEmpty ifTrue: [ ^self error: 'search path not set' ].^(self new package: webPageName) install.! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 12/23/2006 05:46'!entities^ Entities ifNil: [ Entities := "enough entities to be going on with"  Dictionary new.Entities at: 'lt' put: '<';	at: 'gt' put: '>';	at: 'amp' put: '&';	at: 'star' put: '*';	at: 'quot' put: '"';	at: 'nbsp' put: ' '; 	yourself] ! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 1/7/2007 16:13'!fixesApplied^ Fixes ifNil: [ Fixes := OrderedCollection new ].! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 1/8/2007 07:42'!install: webPageNameself webSearchPath isEmpty ifTrue: [ ^self error: 'search path not set' ].^(self new package: webPageName) install.! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 1/8/2007 07:42'!installUrl: urlString^ (self url: urlString) install.! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 12/21/2006 01:49'!skipLoadingTests"sets a flag to ignore loading of the testing portion of scripts embedded in pages"SkipLoadingTests := true. ! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 1/4/2007 06:42'!skipLoadingTests: yesNo during: block	| oldValue |	oldValue := SkipLoadingTests.	SkipLoadingTests := yesNo.		block ensure:[ SkipLoadingTests := oldValue ].! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 1/8/2007 08:37'!view: webPageNameOrUrl| theReport |theReport := String streamContents: [ :report | 	(webPageNameOrUrl beginsWith: 'http://') ifTrue: [ 		self new urlAction: ('Installer installUrl: ', (webPageNameOrUrl printString),'.')  							 reportOn: report.	]	ifFalse: [		self new webAction: ('Installer install: ', (webPageNameOrUrl printString),'.')  							 reportOn: report.	].].Workspace new contents: (theReport contents); openLabel: webPageNameOrUrl.^theReport contents! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 10/21/2006 01:38'!websqueakmap^self new wsm: 'http://map.squeak.org'; yourself! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 10/21/2006 01:38'!websqueakmap: host^self new wsm: host; yourself! !!Installer class methodsFor: 'accessing system' stamp: 'kph 2/14/2007 07:36'!classProjectLauncher^Smalltalk at: #ProjectLauncher ifAbsent: [ self error: 'ProjectLauncher not present' ]! !!Installer class methodsFor: 'accessing system' stamp: 'kph 1/5/2007 02:52'!classes^ Smalltalk! !!Installer class methodsFor: 'accessing system' stamp: 'kph 1/5/2007 02:50'!smalltalkImage^ SmalltalkImage current! !!Installer class methodsFor: 'accessing system' stamp: 'kph 1/5/2007 02:53'!sourceFiles^ SourceFiles! !!Installer class methodsFor: 'documentation' stamp: 'kph 1/10/2007 04:52'!history"7 Jan 2007  !!Installer fixBug: <aBugNo>aBugNo can now be a number or a string, beginning with a number. This allows the mantis bug report summary to be used verbatim.It also provides more infomarion for Installer to support self documentation.!!Install fix if not already installed Installer ensureFix: <aBugNoOrString> Installer ensureFixes: #(1 2 3 4)Installer now keeps a list of fix <aBugNoOrString> that have been installed up to this point.#ensureFix: will only install the fix if it has not already been loaded.note that only the bugNumber not the description is significant in the check.8 Jan 2007!!Installer view: <webPageNameOrUrl>Provided that web page based scripts follow some simple rules, installer can collate the scripts from web pages into a single workspace where you can manually 'doit' portions as you wish.The report generation is not very clever, it only matches on: 'Installer install:' ,  'Installer installUrl:', and 'Installer mantis fixBug:' note these lines must be properly completed with an ending $. (period).also invoked by commandline option VIEW=<webPageNameOrUrl>10 Jan 2007!!Now matches simpler htmlCheck for an html page, now matches'<!!DOCTYPE HTML' and <html> the allows use of pbwiki's raw=bare option which returns iframe embeddable html without the usual headers."! !!Installer class methodsFor: 'instanciation' stamp: 'kph 3/14/2007 21:07'!mantis	^ self mantis: 'http://bugs.squeak.org/'! !!Installer class methodsFor: 'instanciation' stamp: 'kph 12/21/2006 04:26'!mantis: host^self new	ma: host; 			markers: '&quot;fix begin&quot;...&quot;fix test&quot;...&quot;fix end&quot;'; 			yourself.! !!Installer class methodsFor: 'instanciation' stamp: 'kph 10/15/2006 06:37'!squeakmap^self new sm: true; yourself! !!Installer class methodsFor: 'accessing' stamp: 'kph 1/16/2007 19:28'!path: aString	"convenience abbreviation"	self webSearchPathFrom: aString! !!Installer class methodsFor: 'accessing' stamp: 'kph 11/12/2006 16:37'!repository: host  ^self new mc: host ! !!Installer class methodsFor: 'accessing' stamp: 'kph 11/10/2006 00:48'!url: urlString^self new url: urlString; yourself! !!Installer class methodsFor: 'accessing' stamp: 'kph 1/5/2007 00:18'!webSearchPath"a search path item, has the following format. prefix*suffix"^ WebSearchPath ifNil: [ WebSearchPath := OrderedCollection new ].! !!Installer class methodsFor: 'accessing' stamp: 'kph 1/5/2007 04:19'!webSearchPathFrom: string	| reader result |		reader := string readStream.	result := OrderedCollection new.		[ reader atEnd ] whileFalse: [ result add: (reader upTo: $;) ].	WebSearchPath := result.! !!Installer class methodsFor: 'instanciation-abbreviated' stamp: 'kph 11/12/2006 16:30'!sm^self squeakmap! !!Installer class methodsFor: 'instanciation-abbreviated' stamp: 'kph 11/17/2006 01:52'!squeaksource^self repository: 'http://www.squeaksource.com'! !!Installer class methodsFor: 'instanciation-abbreviated' stamp: 'kph 11/17/2006 01:53'!ss^self squeaksource ! !!Installer class methodsFor: 'instanciation-abbreviated' stamp: 'kph 11/12/2006 16:35'!wsm^self websqueakmap! !!Installer class methodsFor: 'utility' stamp: 'kph 1/10/2007 15:27'!unload: categoryMatchesString ^ self new unload: categoryMatchesString! !!Integer methodsFor: 'printing' stamp: 'JPF 6/26/2007 21:11'!hex"receiver is in range 0 to 255. Returns a two 'digit' hexadecimal representation of the receiver.If you want no padding use asHexDigit or printStringHex. i.e.     15 printStringHex ==  'F'     15 asHexDigit == $F     15 hex == '0F'"^self printStringBase: 16 length: 2 padded: true! !!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33'!uversionEqual: anObject	^anObject isInteger and: [ self = anObject ]! !!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33'!uversionLessThan: anObject	^anObject isInteger and: [ self < anObject ]! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:40'!at: index	| word |	<primitive: 165>	word := self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:40'!at: index put: anInteger	| word |	<primitive: 166>	anInteger < 0		ifTrue:["word := 16r100000000 + anInteger"				word := (anInteger + 1) negated bitInvert32]		ifFalse:[word := anInteger].	self  basicAt: index put: word.	^anInteger! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 23:34'!atAllPut: anInteger	| word |	anInteger < 0		ifTrue:["word := 16r100000000 + anInteger"				word := (anInteger + 1) negated bitInvert32]		ifFalse:[word := anInteger].	self primFill: word.! !!Interval methodsFor: 'accessing' stamp: 'BG 6/15/2004 22:58'!indexOf: anElement startingAt: startIndex ifAbsent: exceptionBlock   "  startIndex is an positive integer, the collection index where the search is started. "   " during the computation of  val , floats are only used when the receiver contains floats "   | index val |   (self rangeIncludes: anElement)       ifFalse: [^0].   	val _ (anElement - self first)  / self increment.	val fractionPart abs * 100000000 < step abs	  ifFalse: [^0]	  ifTrue: [index := val rounded + 1].   " finally, the value of  startIndex  comes into play: "   ^index < startIndex      ifTrue: [0]      ifFalse: [index].! !!Interval methodsFor: 'enumerating'!collect: aBlock	| nextValue result |	result := self species new: self size.	nextValue := start.	1 to: result size do:		[:i |		result at: i put: (aBlock value: nextValue).		nextValue := nextValue + step].	^ result! !!Interval methodsFor: 'enumerating'!do: aBlock	| aValue |	aValue := start.	step < 0		ifTrue: [[stop <= aValue]				whileTrue: 					[aBlock value: aValue.					aValue := aValue + step]]		ifFalse: [[stop >= aValue]				whileTrue: 					[aBlock value: aValue.					aValue := aValue + step]]! !!Interval methodsFor: 'enumerating' stamp: 'apb 4/22/2007 12:38'!reverseDo: aBlock 	"Evaluate aBlock for each element of my interval, in reverse order."	| aValue |	aValue := self last.	step < 0		ifTrue: [[start >= aValue]				whileTrue: [aBlock value: aValue.					aValue := aValue - step]]		ifFalse: [[start <= aValue]				whileTrue: [aBlock value: aValue.					aValue := aValue - step]]! !!Interval methodsFor: 'private'!setFrom: startInteger to: stopInteger by: stepInteger	start := startInteger.	stop := stopInteger.	step := stepInteger! !!Interval methodsFor: 'private' stamp: 'di 4/24/2000 13:56'!valuesInclude: aNumber	"Private - answer whether or not aNumber is one of the enumerated values in this interval."	| val |	val := (aNumber - self first) asFloat / self increment.	^ val fractionPart abs < (step * 1.0e-10)! !!IntervalTest methodsFor: 'tests' stamp: 'apb 4/22/2007 12:34'!testDo	| s i |	s := OrderedCollection new.	i := (10 to: 20).	i do: [ :each | s addLast: each].	self assert: (s hasEqualElements: i)! !!IntervalTest methodsFor: 'tests' stamp: 'apb 4/22/2007 12:35'!testReverseDo	| s i |	s := OrderedCollection new.	i := 10 to: 20.	i		reverseDo: [:each | s addFirst: each].	self		assert: (s hasEqualElements: i)! !!IntervalTest methodsFor: 'tests' stamp: 'apb 4/22/2007 12:36'!testReverseUnevenDo	| s i |	s := OrderedCollection new.	i := 10 to: 20 by: 3.	i		reverseDo: [:each | s addFirst: each].	self		assert: (s hasEqualElements: i)! !!IntervalTest methodsFor: 'tests' stamp: 'apb 4/22/2007 12:39'!testUnevenDo	| s i |	s := OrderedCollection new.	i := 10 to: 20 by: 3.	i		do: [:each | s addLast: each].	self		assert: (s hasEqualElements: i)! !!KedamaAngleToTile methodsFor: 'initialization support' stamp: 'yo 1/30/2005 10:57'!addTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'thetaTo' translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Player.	m1 addMorph: m2.	desiredW := m1 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	turtleTile := m1.! !!KedamaAngleToTile methodsFor: 'initialization' stamp: 'yo 6/17/2004 10:03'!initialize	super initialize.	type := #Player.	operatorOrExpression := #getAngleTo:.	self addTile.! !!KedamaAngleToTile methodsFor: 'tile protocol' stamp: 'yo 1/30/2005 11:19'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'thetaTo' translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: turtleTile.! !!KedamaAttributeDictionary methodsFor: 'all' stamp: 'yo 8/28/2004 00:45'!getAttribute: aSymbol of: anObject	| attributes |	attributes := dictionaries at: anObject ifAbsent: [^ nil].	^ attributes at: aSymbol ifAbsent: [nil].! !!KedamaAttributeDictionary methodsFor: 'all' stamp: 'yo 8/28/2004 00:46'!initialize	dictionaries := IdentityDictionary new.! !!KedamaAttributeDictionary methodsFor: 'all' stamp: 'yo 8/28/2004 00:46'!setAttribute: aSymbol of: anObject to: value	| attributes |	attributes := dictionaries at: anObject ifAbsentPut: [IdentityDictionary new].	attributes at: aSymbol put: value.! !!KedamaBounceOnColorTile methodsFor: 'initalization support' stamp: 'yo 1/30/2005 10:56'!addPlayerTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'bounce on' translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Player.	m1 addMorph: m2.	desiredW := m1 width + 6.	m2 := ColorTileMorph new.	"m3 := Morph new extent: 12@8; color: (Color r: 0.8 g: 0.0 b: 0.0)."	desiredW := desiredW + m2 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	"m2 addMorph: m3."	m2 position: ((bounds center x - (m2 width // 2)) + 3)@ (bounds top + 1).	self addMorphBack: m2.	self addMorphFront: m1.	self addMorphFront: label.	playerTile := m1.	colorTile := m2.! !!KedamaBounceOnColorTile methodsFor: 'initialization' stamp: 'yo 9/28/2004 18:43'!initialize	super initialize.	type := #Player.	operatorOrExpression := #bounceOn:color:.	self addPlayerTile.! !!KedamaBounceOnColorTile methodsFor: 'tile protocol' stamp: 'yo 1/30/2005 10:56'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'bounce on' translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: playerTile.! !!KedamaBounceOnTile methodsFor: 'initialization support' stamp: 'yo 1/30/2005 10:58'!addPlayerTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'bounce on' translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Player.	m1 addMorph: m2.	desiredW := m1 width + 6.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	playerTile := m1.! !!KedamaBounceOnTile methodsFor: 'initialization' stamp: 'yo 9/27/2004 14:53'!initialize	super initialize.	type := #Player.	operatorOrExpression := #bounceOn:.	self addPlayerTile.! !!KedamaBounceOnTile methodsFor: 'tile protocol' stamp: 'yo 1/30/2005 10:56'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'bounce on' translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: playerTile.! !!KedamaCategoryViewer methodsFor: 'support' stamp: 'yo 4/3/2005 23:14'!booleanPhraseFromPhrase: phrase	| outerPhrase |	outerPhrase := super booleanPhraseFromPhrase: phrase.	outerPhrase replacePlayerInReadoutWith: scriptedPlayer.	^ outerPhrase.! !!KedamaCategoryViewer methodsFor: 'get/set slots' stamp: 'yo 4/4/2005 08:41'!getterTilesFor: getterSelector type: aType	| phrase |	phrase := super getterTilesFor: getterSelector type: aType.	phrase replacePlayerInReadoutWith: scriptedPlayer.	^ phrase.! !!KedamaDistanceToTile methodsFor: 'initalization support' stamp: 'yo 1/30/2005 10:59'!addTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'distanceTo' translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Player.	m1 addMorph: m2.	desiredW := m1 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	turtleTile := m1.! !!KedamaDistanceToTile methodsFor: 'initialization' stamp: 'yo 6/14/2004 15:58'!initialize	super initialize.	type := #Player.	operatorOrExpression := #getDistanceTo:.	self addTile.! !!KedamaDistanceToTile methodsFor: 'tile protocol' stamp: 'yo 1/30/2005 10:59'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'distanceTo' translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: turtleTile.! !!KedamaExamplerPlayer methodsFor: 'player protocol' stamp: 'yo 9/27/2004 16:24'!addInstanceVarNamed: aName withValue: aValue	self basicAddInstanceVarNamed: aName withValue: aValue.	"turtles := kedamaWorld turtlesOf: self."	turtles addInstanceVarVectorNamed: aName withValue: aValue.! !!KedamaExamplerPlayer methodsFor: 'player protocol' stamp: 'yo 3/25/2005 11:45'!chooseSlotTypeFor: aGetter	"Let the user designate a type for the slot associated with the given getter"	| typeChoices typeChosen slotName |	slotName := Utilities inherentSelectorForGetter: aGetter.	typeChoices := Vocabulary typeChoices.	typeChosen := (SelectionMenu labelList: (typeChoices collect: [:t | t translated]) lines: #() selections: typeChoices) startUpWithCaption: 		('Choose the TYPEfor ' translated, slotName, '(currently ' translated, (self slotInfoAt: slotName) type translated, ')').	typeChosen isEmptyOrNil ifTrue: [^ self].	(self typeForSlot: slotName) capitalized = typeChosen ifTrue: [^ self].	(self slotInfoAt: slotName) type: typeChosen.	self class allInstancesDo:   "allSubInstancesDo:"		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName))].	turtles setVectorSlotTypeFor: slotName typeChosen: typeChosen.	sequentialStub ifNotNil: [sequentialStub setScalarSlotTypeFor: slotName typeChosen: typeChosen].	self updateAllViewers.	"does siblings too"! !!KedamaExamplerPlayer methodsFor: 'subclass players management' stamp: 'yo 9/27/2004 16:34'!createSequenceStub	| class |	class := self class createSequencialStubSubclass.	sequentialStub := class new.	sequentialStub kedamaWorld: kedamaWorld.	sequentialStub examplerPlayer: self.	sequentialStub turtles: turtles.! !!KedamaExamplerPlayer methodsFor: 'subclass players management' stamp: 'yo 9/28/2004 14:03'!createTurtles	turtles := self class createTurtleSubclass new.	turtles kedamaWorld: kedamaWorld.	turtles exampler: self.	^ turtles.! !!KedamaExamplerPlayer methodsFor: 'method management' stamp: 'yo 9/27/2004 16:25'!compileInstVarAccessorsFor: varName	self basicCompileInstVarAccessorsFor: varName.	"turtles := kedamaWorld turtlesOf: self."	turtles compileVectorInstVarAccessorsFor: varName.	sequentialStub compileScalarInstVarAccessorsFor: varName.! !!KedamaExamplerPlayer methodsFor: 'debug support' stamp: 'yo 10/22/2004 07:26'!copyAllMethodsAgain	| c result |	c := turtles class.	result := (ClassBuilder new)		name: c name		inEnvironment: c environment		subclassOf: c superclass		type: c typeOfClass		instanceVariableNames: KedamaTurtleVectorPlayer instanceVariablesString		classVariableNames: KedamaTurtleVectorPlayer classVariablesString		poolDictionaries: KedamaTurtleVectorPlayer sharedPoolsString		category: c category.	turtles class copyAllCategoriesUnobtrusivelyFrom: KedamaTurtleVectorPlayer.	sequentialStub ifNotNil: [sequentialStub class copyAllCategoriesUnobtrusivelyFrom: KedamaSequenceExecutionStub].! !!KedamaExamplerPlayer methodsFor: 'deleting' stamp: 'yo 10/8/2004 11:06'!delete	| anInstance |	turtles delete.	sequentialStub delete.	self class removeFromSystem: false.	anInstance := UnscriptedPlayer new.	self become: anInstance.! !!KedamaExamplerPlayer methodsFor: 'command execution' stamp: 'yo 9/27/2004 16:26'!doCommand: aBlock	| ret |	ret := self doExamplerCommand: aBlock.	turtles ifNotNil: [aBlock value: turtles].	^ ret.! !!KedamaExamplerPlayer methodsFor: 'command execution' stamp: 'yo 9/27/2004 16:26'!doDieCommand: aBlock	| ret origSize |	ret := self doExamplerCommand: aBlock.	turtles initializeDeletingIndex.	origSize := turtles size.	1 to: origSize do: [:i |		i > origSize ifTrue: [^ ret].		sequentialStub index: (turtles nextDeletingIndex).		aBlock value: sequentialStub.	].	^ ret.! !!KedamaExamplerPlayer methodsFor: 'command execution' stamp: 'yo 9/28/2004 10:21'!doSequentialCommand: aBlock	| ret |	ret := self doExamplerCommand: aBlock.	self getGrouped ifFalse: [		1 to: turtles size do: [:i |			sequentialStub index: i.			aBlock value: sequentialStub.		].	] ifTrue: [		aBlock value: turtles.	].	turtles invalidateTurtleMap.	^ ret.! !!KedamaExamplerPlayer methodsFor: 'accessing' stamp: 'yo 9/23/2004 17:15'!kedamaWorld: k	kedamaWorld := k.! !!KedamaExamplerPlayer methodsFor: 'accessing' stamp: 'yo 4/3/2005 17:56'!nearestIDFor: aNumber	| whoArray last next smaller bigger |	whoArray := turtles arrays first.	whoArray isEmpty ifTrue: [^ nil].	aNumber < whoArray first ifTrue: [^ whoArray first].	last := whoArray at: 1.	2 to: whoArray size do: [:i |		(last <= aNumber and: [aNumber < (next := whoArray at: i)]) ifTrue: [			smaller := last.			bigger := next.			(smaller - aNumber) abs <= (bigger - aNumber) abs ifTrue: [^ smaller] ifFalse: [^ bigger].		].		last := next.	].	^ last.! !!KedamaExamplerPlayer methodsFor: 'accessing' stamp: 'yo 4/4/2005 13:59'!whoAt: index	| whoArray |	whoArray := turtles arrays first.	index < 1 ifTrue: [^ 0].	index > whoArray size ifTrue: [^ 0].	^ whoArray at: index.! !!KedamaFloatArray methodsFor: 'arithmetic' stamp: 'yo 10/25/2004 15:40'!* other	| result |	other isNumber ifTrue: [		result := KedamaFloatArray new: self size.		^ self primMulScalar: self and: other into: result.	].	((other isMemberOf: WordArray) or: [other isMemberOf: KedamaFloatArray]) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primMulArray: self and: other into: result.	].	^ super * other.! !!KedamaFloatArray methodsFor: 'arithmetic' stamp: 'yo 10/25/2004 15:30'!+ other	| result |	other isNumber ifTrue: [		result := KedamaFloatArray new: self size.		^ self primAddScalar: self and: other into: result.	].	((other isMemberOf: WordArray) or: [other isMemberOf: KedamaFloatArray]) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primAddArray: self and: other into: result.	].	^ super + other.! !!KedamaFloatArray methodsFor: 'arithmetic' stamp: 'yo 10/25/2004 15:40'!- other	| result |	other isNumber ifTrue: [		result := KedamaFloatArray new: self size.		^ self primSubScalar: self and: other into: result.	].	((other isMemberOf: WordArray) or: [other isMemberOf: KedamaFloatArray]) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primSubArray: self and: other into: result.	].	^ super - other.! !!KedamaFloatArray methodsFor: 'arithmetic' stamp: 'yo 10/25/2004 15:41'!/ other	| result |	other isNumber ifTrue: [		result := KedamaFloatArray new: self size.		^ self primDivScalar: self and: other into: result.	].	((other isMemberOf: WordArray) or: [other isMemberOf: KedamaFloatArray]) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primDivArray: self and: other into: result.	].	^ super / other.! !!KedamaGetColorComponentTile methodsFor: 'initalization support' stamp: 'yo 10/12/2004 22:32'!addPatchTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: (operatorOrExpression asString copyWithout: $:) font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Patch.	m1 addMorph: m2.	desiredW := m1 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	patchTile := m1.! !!KedamaGetColorComponentTile methodsFor: 'initalization support' stamp: 'yo 10/12/2004 22:31'!componentName: aSymbol	aSymbol = #blue ifTrue: [		operatorOrExpression := #getBlueComponentIn:.	].	aSymbol = #green ifTrue: [		operatorOrExpression := #getGreenComponentIn:.	].	aSymbol = #red ifTrue: [		operatorOrExpression := #getRedComponentIn:.	].	self addPatchTile.! !!KedamaGetColorComponentTile methodsFor: 'initialization' stamp: 'yo 10/12/2004 22:29'!initialize	super initialize.	type := #Patch.	operatorOrExpression := #getBlueComponentIn:.	self addPatchTile.	self line1: 'getBlueComponentIn:'.! !!KedamaGetColorComponentTile methodsFor: 'tile protocol' stamp: 'yo 10/12/2004 22:32'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: (operatorOrExpression asString copyWithout: $:) font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: patchTile.! !!KedamaGetPixelValueTile methodsFor: 'initialization support' stamp: 'yo 1/30/2005 11:03'!addPatchTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'getValueIn' translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Patch.	m1 addMorph: m2.	desiredW := m1 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	patchTile := m1.! !!KedamaGetPixelValueTile methodsFor: 'initialization support' stamp: 'yo 1/30/2005 11:04'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'patchValueIn' translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: patchTile.! !!KedamaGetPixelValueTile methodsFor: 'initialization' stamp: 'yo 10/8/2004 07:45'!initialize	super initialize.	type := #Patch.	operatorOrExpression := #getPatchValueIn:.	self addPatchTile.	self line1: 'getPatchValueIn:'.! !!KedamaMorph methodsFor: 'event handling' stamp: 'ar 7/8/2006 20:25'!acceptDroppingMorph: morphToDrop event: evt	| f turtle |	(morphToDrop renderedMorph isKindOf: SketchMorph) ifFalse: [		^morphToDrop rejectDropMorphEvent: evt.	].	f := morphToDrop renderedMorph rotatedForm.	f := f magnify: f boundingBox by: (1.0 / self pixelsPerPatch asFloat) smoothing: 1.	turtle := self player newTurtleSilently.	turtle createTurtlesAsIn: f originAt: ((morphToDrop topLeft - self topLeft) / self pixelsPerPatch asFloat) asIntegerPoint.	"turtle isGroup: true."	turtle color: (self dominantColorWithoutTransparent: f).! !!KedamaMorph methodsFor: 'event handling' stamp: 'ar 7/8/2006 20:25'!dominantColorWithoutTransparent: aForm	| tally max maxi |	aForm depth > 16 ifTrue:		[^self dominantColorWithoutTransparent: (aForm asFormOfDepth: 16)].	tally := aForm tallyPixelValues.	max := maxi := 0.	tally withIndexDo: [:n :i | n > max ifTrue: [ i ~= 1 ifTrue: [max := n. maxi := i]]].	^ Color colorFromPixelValue: maxi - 1 depth: aForm depth! !!KedamaMorph methodsFor: 'setup' stamp: 'yo 9/9/2004 15:24'!addToPatchDisplayList: p	| a |	a := patchesToDisplay copyWithout: p.	patchesToDisplay := a copyWith: p.! !!KedamaMorph methodsFor: 'setup' stamp: 'yo 9/14/2004 20:24'!addToTurtleDisplayList: p	| a |	(p isKindOf: KedamaExamplerPlayer) ifFalse: [^ self].	a := turtlesToDisplay copyWithout: p.	turtlesToDisplay := a copyWith: p.! !!KedamaMorph methodsFor: 'setup' stamp: 'yo 9/27/2004 10:26'!clearAll	"Reset this StarSqueak world. All patch variables are cleared, all turtles are removed, and all demons are turned off."	patchVarDisplayForm := Form extent: dimensions depth: 32.	self initializePatch.	self recreateMagnifiedDisplayForm.	self initializeTurtlesDict.	turtleCount := 0.	lastTurtleID := 0.	self color: Color black.! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 6/17/2004 17:56'!display	"Display this world on the Display. Used for debugging."	| c |	c := FormCanvas extent: (dimensions * pixelsPerPatch) depth: 32.	c := c copyOffset: bounds origin negated.	self drawOn: c.	c form display.! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 9/27/2004 10:28'!drawOn: aCanvas	"Display this StarSqueak world."	| result |	"Time millisecondClockValue printString displayAt: 0@0."	self player ifNil: [^ aCanvas fillRectangle: (self bounds) color: self color].	patchVarDisplayForm fillColor: self color.	patchesToDisplay do: [:p |		p displayPatchVariableOn: patchVarDisplayForm.	].	self drawTurtlesOnForm: patchVarDisplayForm.	pixelsPerPatch = 1 ifTrue: [		aCanvas drawImage: patchVarDisplayForm at: bounds origin.	] ifFalse: [		result := self zoom: patchVarDisplayForm into: magnifiedDisplayForm factor: pixelsPerPatch.		result ifNil: [			aCanvas warpImage: patchVarDisplayForm transform: (MatrixTransform2x3 withScale: pixelsPerPatch) at: self innerBounds origin.		] ifNotNil: [			aCanvas drawImage: magnifiedDisplayForm at: bounds origin.		]	].	autoChanged ifTrue: [self changed].! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 9/9/2004 15:16'!removeAllFromPatchDisplayList	patchesToDisplay := #().! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 9/9/2004 15:19'!removeAllFromTurtleDisplayList	turtlesToDisplay := #().! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 1/20/2005 19:52'!bottomEdgeMode: aSymbol	bottomEdgeMode := aSymbol asSymbol.	bottomEdgeMode == #wrap ifTrue: [		bottomEdgeModeMnemonic := 1.		^ self	].	bottomEdgeMode == #stick ifTrue: [		bottomEdgeModeMnemonic := 2.		^ self	].	(bottomEdgeMode == #bounce or: [bottomEdgeMode == #bouncing]) ifTrue: [		bottomEdgeModeMnemonic := 3.		^ self	].! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 4/6/2005 12:59'!colorAt: aLocalPoint	| pix |	pix := patchVarDisplayForm pixelValueAt: (aLocalPoint // pixelsPerPatch) asIntegerPoint.	^ Color colorFromPixelValue: (pix bitOr: 16rFF000000) depth: 32.! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 1/20/2005 19:52'!leftEdgeMode: aSymbol	leftEdgeMode := aSymbol asSymbol.	leftEdgeMode == #wrap ifTrue: [		leftEdgeModeMnemonic := 1.		^ self	].	leftEdgeMode == #stick ifTrue: [		leftEdgeModeMnemonic := 2.		^ self	].	(leftEdgeMode == #bounce or: [leftEdgeMode == #bouncing]) ifTrue: [		leftEdgeModeMnemonic := 3.		^ self	].! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 6/11/2004 01:06'!pixelsPerPatch: anInteger	"Set the width of one patch in pixels. Larger numbers scale up this StarSqueak world, but numbers larger than 2 or 3 result in a blocky look. The useful range is 1 to 10."	pixelsPerPatch := (anInteger rounded max: 1) min: 10.	super extent: dimensions * pixelsPerPatch.	self recreateMagnifiedDisplayForm! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 1/20/2005 19:52'!rightEdgeMode: aSymbol	rightEdgeMode := aSymbol asSymbol.	rightEdgeMode == #wrap ifTrue: [		rightEdgeModeMnemonic := 1.		^ self	].	rightEdgeMode == #stick ifTrue: [		rightEdgeModeMnemonic := 2.		^ self	].	(rightEdgeMode == #bounce or: [rightEdgeMode == #bouncing]) ifTrue: [		rightEdgeModeMnemonic := 3.		^ self	].! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 1/20/2005 19:53'!topEdgeMode: aSymbol	topEdgeMode := aSymbol asSymbol.	topEdgeMode == #wrap ifTrue: [		topEdgeModeMnemonic := 1.		^ self	].	topEdgeMode == #stick ifTrue: [		topEdgeModeMnemonic := 2.		^ self	].	(topEdgeMode == #bounce or: [topEdgeMode == #bouncing])  ifTrue: [		topEdgeModeMnemonic := 3.		^ self	].! !!KedamaMorph methodsFor: 'turtles' stamp: 'KR 4/14/2006 15:52'!calcTurtlesCount	turtleCount := 0.	turtlesDict do: [:a | turtleCount := turtleCount + a size].	SmalltalkImage current vmParameterAt: 5 put: ((turtleCount * 3) min: 16000 max: 4000).	SmalltalkImage current vmParameterAt: 6 put: ((turtleCount * 6) min: 32000 max: 8000).! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 7/20/2005 22:34'!deleteTurtleID: who of: examplerPlayer	"Delete the given turtle from this world."	| array |	array := examplerPlayer turtles.	array ifNil: [^ self].	turtlesDictSemaphore critical: [		array deleteTurtleID: who.	].	self calcTurtlesCount.	examplerPlayer costume renderedMorph privateTurtleCount: array size.	"examplerPlayer allOpenViewers do: [:v | v resetWhoIfNecessary]."! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/20/2004 09:28'!lastWhoOf: exampler	| turtles |	turtles := turtlesDict at: exampler ifAbsent: [nil].	^ (turtles arrays first) at: turtles arrays first size.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/27/2004 16:29'!makePrototypeOfExampler: examplerPlayer color: cPixel	| array inst info |	array := examplerPlayer turtles.	info := array info.	array size > 0 ifTrue: [		inst := array makePrototypeFromFirstInstance.		cPixel ifNotNil: [inst at: (info at: #color) put: cPixel].		^ inst.	].	inst := Array new: array instSize.	info associationsDo: [:assoc |		inst at: (assoc value) put: (examplerPlayer perform: (Utilities getterSelectorFor: assoc key)).	].	cPixel ifNotNil: [inst at: (info at: #color) put: cPixel] ifNil: [inst at: (info at: #color) put: ((examplerPlayer getColor pixelValueForDepth: 32) bitAnd: 16rFFFFFF)].	inst at: (info at: #visible) put: ((inst at: (info at: #visible)) ifTrue: [1] ifFalse: [0]).	^ inst.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/27/2004 16:29'!makeReplicatedTurtles: count examplerPlayer: tp color: c ofPrototype: prototype randomize: randomizeFlag	| array inst |	array := tp turtles.	inst := prototype ifNil: [self makePrototypeOfExampler: tp color: c].	turtlesDictSemaphore critical: [		array addTurtlesCount: count ofPrototype: inst for: self randomize: randomizeFlag.	].	self calcTurtlesCount.	self changed.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/28/2004 14:16'!makeTurtlesAtPositionsIn: positionAndColorArray examplerPlayer: tp ofPrototype: prototype	| array inst |	array := tp turtles.	inst := prototype ifNil: [self makePrototypeOfExampler: tp].	turtlesDictSemaphore critical: [array addTurtlesCount: positionAndColorArray first size ofPrototype: inst for: self positionAndColorArray: positionAndColorArray].	self calcTurtlesCount.	self changed.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/28/2004 14:13'!makeTurtles: count examplerPlayer: tp color: c ofPrototype: prototype turtles: turtles randomize: randomizeFlag	| array inst |	array := tp turtles.	(turtlesDict keys includes: tp) ifFalse: [		self addToTurtleDisplayList: tp.		turtlesDict at: tp put: (array := turtles).	].	inst := prototype ifNil: [self makePrototypeOfExampler: tp color: c].	turtlesDictSemaphore critical: [array setTurtlesCount: count prototype: inst for: self randomize: randomizeFlag].	self calcTurtlesCount.	self changed.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/14/2004 17:34'!nextTurtleID	^ lastTurtleID := lastTurtleID + 1.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/14/2004 20:28'!removeFromTurtleDisplayList: examplerPlayer	turtlesToDisplay := turtlesToDisplay copyWithout: examplerPlayer.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/27/2004 16:30'!setTurtlesCount: count examplerPlayer: tp color: cPixel	| prototype |	prototype := self makePrototypeOfExampler: tp color: cPixel.	turtlesDictSemaphore critical: [(tp turtles) setTurtlesCount: count prototype: prototype for: self randomize: true].	self calcTurtlesCount.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/27/2004 16:30'!turtlesCountOf: exampler	| array |	array := exampler turtles.	array ifNil: [^ 0].	^ array size.! !!KedamaMorph methodsFor: 'etoys' stamp: 'yo 6/11/2004 11:20'!categoriesForViewer	"Answer a list of symbols representing the categories to offer in the viewer, in order"	^ super categoriesForViewer."	| aList |	aList := OrderedCollection new.	aList addAllFirstUnlessAlreadyPresent: (self class additionsToViewerCategories collect:				[:categorySpec | categorySpec first]).	^ aList"! !!KedamaMorph methodsFor: 'deleting' stamp: 'yo 10/8/2004 11:11'!delete	| c |	super delete.	turtlesDict keysDo: [:k |		self deleteAllTurtlesOfExampler: k.		c := k costume.		c ifNotNil: [c renderedMorph delete].	].! !!KedamaMorph methodsFor: 'initialization' stamp: 'yo 9/17/2004 19:34'!initialize	super initialize.	dimensions := self class defaultDimensions.  "dimensions of this StarSqueak world in patches"	wrapX := dimensions x asFloat.	wrapY := dimensions y asFloat.	pixelsPerPatch := 2.	super extent: dimensions * pixelsPerPatch.	self assuredPlayer assureUniClass.	self clearAll.  "be sure this is done once in case setup fails to do it"	autoChanged := true.	self leftEdgeMode: #wrap.	self rightEdgeMode: #wrap.	self topEdgeMode: #wrap.	self bottomEdgeMode: #wrap.	turtlesDictSemaphore := Semaphore forMutualExclusion.! !!KedamaMorph methodsFor: 'initialization' stamp: 'yo 9/9/2004 15:15'!initializePatch	| f |	f := self player addPatchVarNamed: #patch.	patchesToDisplay := Array new: 0.	self addToPatchDisplayList: f.	^ f.! !!KedamaMorph methodsFor: 'initialization' stamp: 'yo 9/28/2004 14:12'!initializeTurtlesDict	turtlesDict := IdentityDictionary new.	turtlesToDisplay := Array new.! !!KedamaMorph methodsFor: 'private' stamp: 'yo 9/14/2004 18:47'!isVisible: examplerPlayer	| turtleMorph |	turtleMorph := examplerPlayer costume.	turtleMorph visible ifFalse: [^ false].	turtleMorph owner isRenderer ifFalse: [^ true].	^ turtleMorph owner visible.! !!KedamaMorph methodsFor: 'private' stamp: 'yo 6/6/2004 23:25'!recreateMagnifiedDisplayForm	magnifiedDisplayForm := Form extent: self dimensions * pixelsPerPatch depth: 32.	self changed.! !!KedamaMorph methodsFor: 'menu' stamp: 'yo 6/16/2004 08:56'!setScale	| reply |	reply := FillInTheBlank		request: 'Set the number of pixels per patch (a number between 1 and 10)?'		 initialAnswer: pixelsPerPatch printString.	reply isEmpty ifTrue: [^ self].	self pixelsPerPatch: reply asNumber.! !!KedamaMorph methodsFor: 'utils' stamp: 'yo 3/23/2005 12:24'!random: range	"Answer a random integer between 0 and range."	| r val |	<primitive: 'randomRange' module: 'KedamaPlugin'>	r := range < 0 ifTrue: [range negated] ifFalse: [range].	RandomSeed := ((RandomSeed * 1309) + 13849) bitAnd: 65535.	val := (RandomSeed * (r + 1)) >> 16.	^ range < 0 ifTrue: [val negated] ifFalse: [^ val].! !!KedamaMorph class methodsFor: 'class initialization' stamp: 'yo 9/2/2004 23:23'!initialize	"Kedama initialize"	RandomSeed := 17.! !!KedamaMorph class methodsFor: 'class initialization' stamp: 'yo 10/23/2005 20:33'!newSet	| k p t s w |	k := self new.	p := k assuredPlayer getPatch costume renderedMorph.	t := k assuredPlayer newTurtleForSet.	s := SelectionMorph new.	w := PasteUpMorph new.	w extent: 400@400.	p position: 275@50.	t position: 300@175.	k position: 25@25.	w addMorph: k.	w addMorph: t.	w addMorph: p.	w addMorph: s.	s bounds: w bounds.	s selectSubmorphsOf: w.	^ s.! !!KedamaMorph class methodsFor: 'global primitive backup' stamp: 'yo 10/11/2004 11:47'!degreesToRadians: degrees	| deg q headingRadians |	deg := 90.0 - degrees.	q := (deg / 360.0) asInteger.	deg < 0.0 ifTrue: [q := q - 1].	headingRadians := (deg - (q * 360.0)) * 0.0174532925199433.	^ headingRadians.! !!KedamaMorph class methodsFor: 'global primitive backup' stamp: 'yo 10/11/2004 12:45'!radiansToDegrees: radians	| degrees deg |	degrees := radians / 0.0174532925199433.	deg := 90.0 - degrees.	deg > 0.0 ifFalse: [deg := deg + 360.0].	^ deg.! !!KedamaMorph class methodsFor: 'global primitive backup' stamp: 'yo 10/10/2004 09:07'!scalarXAt: index xArray: xArray headingArray: headingArray value: val destWidth: destWidth leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode	| newX headingRadians |	newX := val.	newX < 0.0 ifTrue: [		leftEdgeMode = 1 ifTrue: [			"wrap"			newX := newX + destWidth.		].		leftEdgeMode = 2 ifTrue: [			"stick"			newX := 0.0.		].		leftEdgeMode = 3 ifTrue: [			"bounce"			newX := 0.0 - newX.			headingRadians := headingArray at: index.			headingRadians <  3.141592653589793				ifTrue: [headingArray at: index put: 3.141592653589793 - headingRadians]				ifFalse: [headingArray at: index put: 9.42477796076938 - headingRadians].		].	].	newX >= destWidth ifTrue: [		rightEdgeMode = 1 ifTrue: [			newX := newX - destWidth.		].		rightEdgeMode = 2 ifTrue: [			newX := destWidth - 0.000001.		].		rightEdgeMode = 3 ifTrue: [			newX := (destWidth - 0.000001) - (newX - destWidth).			headingRadians := headingArray at: index.			headingRadians < 3.141592653589793				ifTrue: [headingArray at: index put: (3.141592653589793 - headingRadians)]				ifFalse: [headingArray at: index put: (9.42477796076938 - headingRadians)].		]	].	xArray at: index put: newX.! !!KedamaMorph class methodsFor: 'global primitive backup' stamp: 'yo 10/10/2004 09:09'!scalarYAt: index yArray: yArray headingArray: headingArray value: val destHeight: destHeight topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode	| newY |	newY := val.	newY < 0.0 ifTrue: [		topEdgeMode = 1 ifTrue: [			"wrap"			newY := newY + destHeight.		].		topEdgeMode = 2 ifTrue: [			"stick"			newY := 0.0.		].		topEdgeMode = 3 ifTrue: [			"bounce"			newY := 0.0 - newY.			headingArray at: index put: (6.283185307179586 - (headingArray at: index)).		].	].	newY >= destHeight ifTrue: [		bottomEdgeMode = 1 ifTrue: [			newY := newY - destHeight.		].		bottomEdgeMode = 2 ifTrue: [			newY := destHeight - 0.000001.		].		bottomEdgeMode = 3 ifTrue: [			newY := (destHeight - 0.000001) - (newY - destHeight).			headingArray at: index put: (6.283185307179586 - (headingArray at: index)).		]	].	yArray at: index put: newY.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/7/2004 10:21'!autoChanged: aBoolean	autoChanged := aBoolean.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 8/18/2005 10:56'!basicPixelAtX: xPos y: yPos	| x y i |	x := xPos truncated.	y := yPos truncated.	((x < 0) or: [y < 0]) ifTrue: [^ 0].	((x >= form width) or: [y >= form height]) ifTrue: [^ 0].	i := ((y * form width) + x) + 1.	form bits class == ByteArray ifTrue: [form unhibernate].	^ form bits at: i.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 11/30/2005 12:07'!basicPixelAtX: xPos y: yPos put: value	| x y i v |	x := xPos truncated.	y := yPos truncated.	v := value asInteger min: 16rFFFFFFFF max: 0.	((x < 0) or: [y < 0]) ifTrue: [^ self].	((x >= form width) or: [y >= form height]) ifTrue: [^ self].	i := ((y * form width) + x) + 1.	form bits class == ByteArray ifTrue: [form unhibernate].	form bits at: i put: v.	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 10/13/2004 01:59'!blueComponentFrom: another	| pix anotherPix |	0 to: self height - 1 do: [:y |		0 to: self width -1 do: [:x |			pix := self pixelAtX: x y: y.			anotherPix := (another pixelAtX: x y: y) bitAnd: 16rFF.			pix := (pix bitAnd: 16rFFFF00) bitOr: (anotherPix).			self pixelAtX: x y: y put: pix.		].	].! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/3/2004 21:29'!colorAtX: xPos y: yPos put: aColor	| pixel |	pixel := aColor pixelValueForDepth: 32.	self pixelAtX: xPos y: yPos put: pixel.	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 8/18/2005 10:54'!diffuse	| dim newV |	dim := form extent.	form bits class == ByteArray ifTrue: [form unhibernate].	newV := Bitmap new: form bits size.	self primDiffuseFrom: form bits		to: newV		width: dim x		height: dim y		delta: diffusionRate truncated.	form bits: newV.	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/3/2004 20:48'!diffusionRate: newRate	"Set the diffusion rate to an integer between 0 and 10. The diffusion rate gives the number of patches on one size of the area averaged to compute the next value of the variable for a given patch. Larger numbers cause faster diffusion. Zero means no diffusion."	diffusionRate := (newRate rounded max: 0) min: 10.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/16/2004 04:34'!displayMax: anInteger	displayMax := WordArray with: (anInteger asInteger min: 16rFFFFFFFF max: 0).	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/14/2004 16:20'!displayShiftAmount: anInteger	shiftAmount := anInteger min: 8 max: -32.	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 4/5/2005 10:11'!displayType: aSymbol	displayType := aSymbol asSymbol.	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/3/2004 20:50'!evaporationRate: newRate	"Set the evaporation rate. The useful range is 0 to 25 or so. Larger numbers cause faster evaporation. Zero means no evaporization."	scaledEvaporationRate := ((1024 - newRate truncated) max: 1) min: 1024.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 10/13/2004 01:06'!greenComponentFrom: another	| pix anotherPix |	0 to: self height - 1 do: [:y |		0 to: self width -1 do: [:x |			pix := self pixelAtX: x y: y.			anotherPix := (another pixelAtX: x y: y) bitAnd: 16rFF.			pix := (pix bitAnd: 16rFF00FF) bitOr: (anotherPix bitShift: 8).			self pixelAtX: x y: y put: pix.		].	].! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 8/18/2005 10:38'!pixelAtX: xPos y: yPos	| x y i |	x := xPos truncated.	y := yPos truncated.	((x < 0) or: [y < 0]) ifTrue: [^ 0].	((x >= form width) or: [y >= form height]) ifTrue: [^ 0].	i := ((y * form width) + x) + 1.	form bits class == ByteArray ifTrue: [form unhibernate].	^ form bits at: i.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 11/30/2005 12:07'!pixelAtX: xPos y: yPos put: value	| x y i v |	x := xPos truncated.	y := yPos truncated.	v := (value asInteger max: 0) bitAnd: 16rFFFFFFFF.	((x < 0) or: [y < 0]) ifTrue: [^ self].	((x >= form width) or: [y >= form height]) ifTrue: [^ self].	i := ((y * form width) + x) + 1.	form bits class == ByteArray ifTrue: [form unhibernate].	form bits at: i put: v.	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 10/13/2004 01:05'!redComponentFrom: another	| pix anotherPix |	0 to: self height - 1 do: [:y |		0 to: self width -1 do: [:x |			pix := self pixelAtX: x y: y.			anotherPix := (another pixelAtX: x y: y) bitAnd: 16rFF.			pix := (pix bitAnd: 16r00FFFF) bitOr: (anotherPix bitShift: 16).			self pixelAtX: x y: y put: pix.		].	].! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/4/2004 01:36'!sniffRange: aNumber	sniffRange := aNumber.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 8/18/2005 10:54'!uphillForTurtleX: tX turtleY: tY turtleHeading: tH	"Answer the heading the points in the direction of increasing value for the given patch variable. If there is no gradient, or if the turtle is outside the world bounds, answer the turtles current heading."	| ret |	form bits class == ByteArray ifTrue: [form unhibernate].	ret := self primUpHillX: tX y: tY heading: tH bits: form bits width: form width height: form height sniffRange: sniffRange.	ret ifNotNil: [^ ret].	^ self basicUphillForTurtleX: tX turtleY: tY turtleHeading: tH.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 3/7/2005 12:20'!useLogDisplay: aBoolean	displayType := aBoolean ifTrue: [#logScale] ifFalse: [#linear].	self formChanged.! !!KedamaPatchMorph methodsFor: 'private' stamp: 'yo 3/7/2005 12:19'!convertToCurrentVersion: varDict refStream: smartRefStrm		varDict at: 'useLogDisplay' ifPresent: [ :x | 		displayType := x ifTrue: [#logScale] ifFalse: [#linear].	].	displayType ifNil: [displayType := #logScale].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!KedamaPatchMorph methodsFor: 'drawing' stamp: 'yo 8/18/2005 11:42'!displayPatchVariableOn: aForm	| patchVar pixelValue |	form ifNil: [^self].	formChanged ifTrue: [		"displayForm fillColor: Color transparent."		pixelValue := (self color pixelValueForDepth: 32) bitAnd: 16rFFFFFF.		form bits class == ByteArray ifTrue: [form unhibernate].		patchVar := form bits.		displayForm bits class == ByteArray ifTrue: [displayForm unhibernate].		displayType = #linear ifTrue: [			self primMakeMaskOf: patchVar in: displayForm bits colorPixel: pixelValue shift: shiftAmount.		].		displayType = #logScale ifTrue: [			self primMakeMaskOf: patchVar in: displayForm bits colorPixel: pixelValue max: displayMax.		].		displayType = #color ifTrue: [			form displayOn: displayForm.			displayForm fixAlpha.		].	].	tmpForm fillColor: Color black.	displayForm displayOn: tmpForm at: 0@0 rule: 24.	aForm == tmpForm ifFalse: [		displayForm displayOn: aForm at: 0@0 rule: 24.	].	formChanged := false.! !!KedamaPatchMorph methodsFor: 'drawing' stamp: 'yo 6/6/2004 23:23'!formChanged	formChanged := true.! !!KedamaPatchMorph methodsFor: 'initialization' stamp: 'yo 3/7/2005 12:17'!initialize	super initialize.	self evaporationRate: 6.	self diffusionRate: 1.	self sniffRange: 1.	displayType := #logScale.	displayMax := WordArray with: 1024.	shiftAmount := -2.	autoChanged := true.	self formChanged.! !!KedamaPatchMorph methodsFor: 'initialization' stamp: 'yo 2/2/2005 17:37'!initializeForm: aForm 	form := aForm. 	form fillColor: Color transparent.	displayForm := (Form extent: aForm extent depth: 32).	tmpForm := (Form extent: aForm extent depth: 32).	tmpForm fillColor: Color black.	super extent: form extent.	self changed.	self formChanged.! !!KedamaPatchMorph methodsFor: 'primitives' stamp: 'yo 6/26/2004 20:07'!primMakeMaskOf: dataBits in: maskBits colorPixel: pixel max: max	| highMask alpha maxLog data |	<primitive: 'makeMaskLog' module: 'KedamaPlugin'>	"^ KedamaSqueakPlugin doPrimitive: #makeMaskLog."	highMask := 16rFF000000.	"maxLog := self cCode: 'log(max)' inSmalltalk: [max first ln]."	maxLog := max first ln.	maxLog := 255.0 / maxLog.	1 to: dataBits size do: [:i |		data := dataBits at: i.		data = 0 ifTrue: [alpha := 0] ifFalse: [			"alpha := ((255.0 / maxLog) * (self cCode: 'log(data)' inSmalltalk: [data ln])) asInteger."			alpha := (maxLog * (data ln)) asInteger.		].		(alpha > 255) ifTrue: [alpha := 255].		maskBits at: i put: (((alpha << 24) bitAnd: highMask) bitOr: pixel).	].	^ self.! !!KedamaPatchMorph methodsFor: 'primitives' stamp: 'yo 6/18/2004 15:18'!primMakeMaskOf: dataBits in: maskBits colorPixel: pixel shift: shift	| highMask data alpha |	<primitive: 'makeMask' module: 'KedamaPlugin'>	"^ KedamaSqueakPlugin doPrimitive: #makeMask."	highMask := 16rFF000000.	1 to: dataBits size do: [:i |		data := dataBits at: i.		alpha := data bitShift: shift.		(alpha > 255) ifTrue: [alpha := 255].		maskBits at: i put: (((alpha << 24) bitAnd: highMask) bitOr: pixel).	].	^ self.! !!KedamaPatchMorph methodsFor: 'primitives' stamp: 'yo 8/19/2005 12:24'!primPixelsAtXArray: xArray yArray: yArray bits: bits width: width height: height into: aWordArray	| x y formIndex val |	<primitive: 'primPixelsAtXY' module: 'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primPixelsAtXY."	1 to: aWordArray size do: [:i |		val := nil.		x := (xArray at: i) truncated.		y := (yArray at: i) truncated.		((x < 0) or: [y < 0]) ifTrue: [val := 0].		((x >= form width) or: [y >= form height]) ifTrue: [val := 0].		val ifNil: [			formIndex := ((y * form width) + x) + 1.			val := bits at: formIndex.		].		aWordArray at: i put: val.	].! !!KedamaPatchMorph methodsFor: 'primitives' stamp: 'yo 10/25/2004 16:56'!primSetPixelsAtXArray: xArray yArray: yArray bits: bits width: width height: height value: value	| v |	<primitive: 'primSetPixelsAtXY' module: 'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primSetPixelsAtXY."	value isNumber ifTrue: [v := value].	1 to: xArray size do: [:i |		value isNumber ifFalse: [			v := value at: i.		].				self pixelAtX: (xArray at: i) y: (yArray at: i) put: v.	].! !!KedamaPatchMorph class methodsFor: 'instance creation' stamp: 'yo 2/2/2005 17:45'!newExtent: aPoint	| inst |	inst := self new.	inst newExtent: aPoint.	^ inst.! !!KedamaPatchTile methodsFor: 'initialization' stamp: 'yo 6/7/2004 13:56'!initialize	super initialize.	type := #literal.	self extent: 16@16.! !!KedamaPatchTile methodsFor: 'tile protocol' stamp: 'yo 6/5/2004 16:11'!setLiteral: anObject	"Set the receiver's literal to be anObject. No readout morph here."	type := #literal.	self setLiteralInitially: anObject.! !!KedamaPatchTile methodsFor: 'initialization support' stamp: 'yo 6/18/2004 16:02'!usePatch: aPatch	| aTile displayer |	self removeAllMorphs.	literal := aPatch.	aTile := KedamaPatchType basicNew newReadoutTile.	displayer := UpdatingStringMorph new		getSelector: #externalName;		target: aPatch;		growable: true;		minimumWidth: 24;		putSelector: nil.	displayer stepTime: 1000.	"Note that when typeSymbol = #number, the #target: call above will have dealt with floatPrecision details"	displayer useStringFormat.	aTile addMorphBack: displayer.	aTile setLiteralInitially: (aPatch perform: #externalName).	self addMorphBack: aTile.! !!KedamaPatchType methodsFor: 'tile protocol' stamp: 'yo 10/13/2004 04:16'!defaultArgumentTile	"Answer a tile to represent the type"	| patch ks k p |	patch := KedamaPatchTile new typeColor: self typeColor.	ks := ActiveWorld allMorphs select: [:e | e isKindOf: KedamaMorph].	ks isEmpty ifFalse: [		k := ks first.		p := k player getPatch.	] ifTrue: [		k := KedamaPatchMorph new.		k assuredPlayer.		p := k player.	].	patch usePatch: p.	^ patch.! !!KedamaPatchType methodsFor: 'tile protocol' stamp: 'yo 10/13/2004 01:53'!defaultArgumentTileFor: aPlayer	"Answer a tile to represent the type"	| patch morph |	patch := KedamaPatchTile new typeColor: self typeColor.	morph := aPlayer costume renderedMorph.	(morph isKindOf: KedamaMorph) ifTrue: [		patch usePatch: aPlayer costume renderedMorph player getPatch.	].	(morph isKindOf: KedamaPatchMorph) ifTrue: [		patch usePatch: morph player.	].	^ patch.! !!KedamaPatchType methodsFor: 'tile protocol' stamp: 'yo 9/13/2005 21:23'!updatingTileForTarget: aTarget partName: partName getter: getter setter: setter	| aTile displayer actualSetter |	actualSetter := setter ifNotNil:		[(#(none nil unused) includes: setter) ifTrue: [nil] ifFalse: [setter]].	aTile := self newReadoutTile.	displayer := UpdatingStringMorph new		getSelector: #externalName;		target: (aTarget perform: getter) costume renderedMorph;		growable: true;		minimumWidth: 24;		putSelector: nil.	displayer stepTime: 1000.	"Note that when typeSymbol = #number, the #target: call above will have dealt with floatPrecision details"	self setFormatForDisplayer: displayer.	aTile addMorphBack: displayer.	(actualSetter notNil and: [self wantsArrowsOnTiles]) ifTrue: [aTile addArrows].		getter numArgs == 0 ifTrue:		[aTile setLiteralInitially: (aTarget perform: getter)].	displayer useStringFormat.	^ aTile! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 18:51'!basicGetAngleTo: player	| ret i |	i := self index.	ret := ((player getX - ((turtles arrays at: 2) at: i))@(player getY - ((turtles arrays at: 3) at: i))) theta radiansToDegrees + 90.0.	ret > 360.0 ifTrue: [^ ret - 360.0].	^ ret.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 18:07'!basicGetDistanceTo: aPlayer	| i |	i := self index.	^ ((aPlayer getX - ((turtles arrays at: 2) at: i)) squared + (aPlayer getY - ((turtles arrays at: 3) at: i)) squared) sqrt.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 23:47'!bounceOn: aPlayer	| aTurtle xy |	aPlayer = exampler ifTrue: [^ false].	xy := self getXAndY.	aTurtle := aPlayer turtles aTurtleAtX: xy x y: xy y.	aTurtle ifNil: [^ false].	self doBounceOn: aTurtle of: aPlayer.	^ true.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 23:48'!bounceOn: aPlayer color: c	| aTurtle xy |	aPlayer = exampler ifTrue: [^ false].	xy := self getXAndY.	aTurtle := aPlayer turtles aTurtleAtX: xy x y: xy y.	aTurtle ifNil: [^ false].	((aPlayer turtles arrays at: 5) at: aTurtle index) = c ifFalse: [^ false].	self doBounceOn: aTurtle of: aPlayer.	^ true.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 4/5/2005 11:04'!colorFromPatch: aPatch	| i |	i := self index.	(turtles arrays at: 5) at: i put: ((aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i)) bitAnd: 16rFFFFFF).! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/12/2004 22:01'!colorToPatch: aPatch	| i |	i := self index.	aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i) put: ((turtles arrays at: 5) at: i).! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 23:48'!doBounceOn: aTurtle of: aPlayer	| bounceDir myHeading neg newHeading xy |	aPlayer = exampler ifTrue: [^ false].	bounceDir := aTurtle getHeading.	myHeading := self getHeading.	neg := (myHeading + 180.0) \\ 360.0.	newHeading := (bounceDir - neg + bounceDir).	self setHeading: newHeading.	[xy := self getXAndY. (aPlayer turtles aTurtleAtX: xy x y: xy y) ~= nil] whileTrue: [		self forward: 0.5.	].! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 23:49'!getAngleTo: aPlayer	| i xy |	i := self index.	xy := aPlayer getXAndY.	^ self primGetAngleToX: xy x toY: xy y fromX: ((turtles arrays at: 2) at: i) fromY: ((turtles arrays at: 3) at: i).! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/12/2004 15:24'!getBlueComponentIn: aPatch	| i pix |	i := self index.	pix := aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).	^ pix bitAnd: 16rFF.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 23:49'!getDistanceTo: aPlayer	| i xy |	i := self index.	xy := aPlayer getXAndY.	^ self primGetDistanceToX: xy x toY: xy y fromX: ((turtles arrays at: 2) at: i) fromY: ((turtles arrays at: 3) at: i).! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/12/2004 15:24'!getGreenComponentIn: aPatch	| i pix |	i := self index.	pix := aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).	^ (pix bitShift: -8) bitAnd: 16rFF.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 9/29/2004 09:04'!getNormal	| headingRadians degrees |	headingRadians := (turtles arrays at: 7) at: self index.	degrees := 90.0 - headingRadians radiansToDegrees.	^ degrees >= 0.0 ifTrue: [degrees] ifFalse: [degrees + 360.0].! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 9/27/2004 18:16'!getPatchValueIn: aPatch	| i |	i := self index.	^ aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/12/2004 15:24'!getRedComponentIn: aPatch	| i pix |	i := self index.	pix := aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).	^ (pix bitShift: -16) bitAnd: 16rFF.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 9/27/2004 16:35'!getReplicated	| proto newWho n |	proto := (1 to: turtles arrays size) collect: [:i | (turtles arrays at: i) at: self index].	kedamaWorld makeReplicatedTurtles: 1 examplerPlayer: exampler color: nil ofPrototype: proto randomize: false.	exampler costume renderedMorph privateTurtleCount: (kedamaWorld turtlesCountOf: exampler).	newWho := (kedamaWorld lastWhoOf: exampler).	n := self clone.	n who: newWho.	^ n.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 23:50'!getTurtleAt: aPlayer	| ret xy |	xy := aPlayer getXAndY.	ret := exampler turtles aTurtleAtX: xy x y: xy y.	^ ret ifNil: [self].! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 3/7/2005 11:33'!getTurtleOf: aBreedPlayer	| ret xy |	xy := self getXAndY.	ret := aBreedPlayer turtles aTurtleAtX: xy x y: xy y.	^ ret ifNil: [self].! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 9/30/2004 11:42'!getUphillIn: aPatch	| i p |	i := self index.	p := aPatch costume renderedMorph.	^ p			uphillForTurtleX: ((turtles arrays at: 2) at: i)			turtleY: ((turtles arrays at: 3) at: i)			turtleHeading: ((turtles arrays at: 4) at: i).! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/13/2004 06:42'!setBlueComponentIn: aPatch to: value	| i pix |	i := self index.	pix := aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).	pix := (pix bitAnd: 16rFFFF00) bitOr: ((value asInteger bitAnd: 16rFF) bitShift: 16).	aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i) put: pix.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/13/2004 06:42'!setGreenComponentIn: aPatch to: value	| i pix |	i := self index.	pix := aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).	pix := (pix bitAnd: 16rFF00FF) bitOr: ((value asInteger bitAnd: 16rFF) bitShift: 8).	aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i) put: pix.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 9/29/2004 09:05'!setNormal: degrees	| headingRadians |	headingRadians := ((90.0 - degrees) \\ 360.0) degreesToRadians.	(turtles arrays at: 7) at: self index put: headingRadians.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 9/27/2004 18:19'!setPatchValueIn: aPatch to: value	| i |	i := self index.	aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i) put: value.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/13/2004 06:42'!setRedComponentIn: aPatch to: value	| i pix |	i := self index.	pix := aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).	pix := (pix bitAnd: 16rFFFF) bitOr: ((value asInteger bitAnd: 16rFF) bitShift: 16).	aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i) put: pix.! !!KedamaSequenceExecutionStub methodsFor: 'method management' stamp: 'yo 9/30/2004 13:13'!compileScalarInstVarAccessorsFor: varName	| nameString type setPhrase arrayIndex getPhrase |	nameString := varName asString capitalized.	arrayIndex := turtles info at: varName asSymbol.	type := turtles types at: arrayIndex.	type = #Number ifTrue: [		setPhrase := 'setNumberVarAt:'.		getPhrase := 'getNumberVarOf:'.	].	type = #Boolean ifTrue: [		setPhrase := 'setBooleanVarAt:'.		getPhrase := 'getBooleanVarOf:'	].	type = #Color ifTrue: [		setPhrase := 'setColorVarAt:'.		getPhrase := 'getColorVarOf:'	].	setPhrase ifNil: [setPhrase := 'setObjectVarAt:'].	getPhrase ifNil: [getPhrase := 'getObjectVarOf:'].	self class compileSilently: ('get', nameString, '	^ self ', getPhrase, '((turtles arrays at: ', arrayIndex printString, ') at: self index)')		classified: 'access'.	self class compileSilently: ('set', nameString, ': xxxArg		self ', setPhrase, arrayIndex printString, ' at: self index put: xxxArg' )		classified: 'access'! !!KedamaSequenceExecutionStub methodsFor: 'deleting' stamp: 'yo 10/8/2004 11:03'!delete	| anInstance |	arrays := nil.	exampler := nil.	self class removeFromSystem: false.	anInstance := UnscriptedPlayer new.	self become: anInstance.! !!KedamaSequenceExecutionStub methodsFor: 'command execution' stamp: 'yo 9/29/2004 09:02'!doDieCommand: aBlock	| ret |	ret := self doExamplerCommand: aBlock.	sequentialStub index: index.	aBlock value: sequentialStub.	^ ret.! !!KedamaSequenceExecutionStub methodsFor: 'player protocol' stamp: 'yo 9/17/2004 17:15'!examplerPlayer: e	exampler := e.! !!KedamaSequenceExecutionStub methodsFor: 'accessing - private' stamp: 'yo 10/23/2004 23:44'!getXAndY	| i |	i := self index.	^ ((turtles arrays at: 2) at: i)@((turtles arrays at: 3) at: i).! !!KedamaSequenceExecutionStub methodsFor: 'accessing - private' stamp: 'yo 9/27/2004 16:34'!setColorVarAt: arrayIndex at: i put: v	| val |	val := v isColor ifTrue: [v pixelValueForDepth: 32] ifFalse: [v].	(turtles arrays at: arrayIndex) at: i put: val.! !!KedamaSequenceExecutionStub methodsFor: 'accessing' stamp: 'yo 9/16/2004 10:41'!index: i	index := i.! !!KedamaSequenceExecutionStub methodsFor: 'accessing' stamp: 'yo 9/28/2004 11:15'!turtles: t	turtles := t.! !!KedamaSequenceExecutionStub methodsFor: 'accessing' stamp: 'yo 9/18/2004 15:34'!who: w	who := w.	index := nil.! !!KedamaSequenceExecutionStub methodsFor: 'primitives' stamp: 'yo 10/10/2004 09:14'!primForwardAt: i xArray: xArray yArray: yArray headingArray: headingArray value: value destWidth: destWidth destHeight: destHeight leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode	| dist newX newY |	<primitive: 'primScalarForward' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primScalarForward."	dist := value.	newX := (xArray at: i) + (dist asFloat * (headingArray at: i) cos).	newY := (yArray at: i) - (dist asFloat * (headingArray at: i) sin).	KedamaMorph scalarXAt: i xArray: xArray headingArray: headingArray value: newX destWidth: destWidth leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode.	KedamaMorph scalarYAt: i yArray: yArray headingArray: headingArray value: newY destHeight: destHeight topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode.! !!KedamaSequenceExecutionStub methodsFor: 'primitives' stamp: 'yo 10/23/2004 18:55'!primGetAngleToX: toX toY: toY fromX: fromX fromY: fromY	| ret |	<primitive: 'scalarGetAngleTo' module:'KedamaPlugin'>	ret := ((toX - fromX)@(toY - fromY)) theta radiansToDegrees + 90.0.	ret > 360.0 ifTrue: [^ ret - 360.0].	^ ret.! !!KedamaSequenceExecutionStub methodsFor: 'primitives' stamp: 'yo 10/11/2004 14:33'!primGetHeadingAt: i headingArray: headingArray	| heading |	<primitive: 'getScalarHeading' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #getScalarHeading."	heading := headingArray at: i.	^ heading := KedamaMorph radiansToDegrees: heading.! !!KedamaSequenceExecutionStub methodsFor: 'primitives' stamp: 'yo 10/11/2004 14:07'!primSetHeadingAt: i headingArray: headingArray value: heading	| rad |	<primitive: 'setScalarHeading' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #setScalarHeading."	rad := KedamaMorph degreesToRadians: heading.	headingArray at: index put: rad.! !!KedamaSetColorComponentTile methodsFor: 'initalization support' stamp: 'yo 1/30/2005 11:20'!addPatchTile	| m1 desiredW m2 label |	m1 := TilePadMorph new.	label := 	StringMorph contents: (operatorOrExpression asString upTo: $:) translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Patch.	m1 addMorph: m2.	desiredW := m1 width + 6.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	patchTile := m1.! !!KedamaSetColorComponentTile methodsFor: 'initalization support' stamp: 'yo 10/12/2004 22:38'!componentName: aSymbol	aSymbol = #blue ifTrue: [		operatorOrExpression := #setBlueComponentIn:to:.	].	aSymbol = #green ifTrue: [		operatorOrExpression := #setGreenComponentIn:to:.	].	aSymbol = #red ifTrue: [		operatorOrExpression := #setRedComponentIn:to:.	].	self addPatchTile.! !!KedamaSetColorComponentTile methodsFor: 'initialization' stamp: 'yo 10/12/2004 22:36'!initialize	super initialize.	type := #Patch.	operatorOrExpression := #setBlueComponentIn:to:.	self addPatchTile.	self line1: 'setBlueComponent:'.! !!KedamaSetColorComponentTile methodsFor: 'initialization' stamp: 'yo 1/30/2005 11:20'!line1: line1	| chopped label label2 tail headIndex |	(line1 select: [:e | e = $:]) size >= 2 ifTrue: [^ self].	self removeAllMorphs.	headIndex := line1 indexOf: $: ifAbsent: [line1 indexOf: Character space ifAbsent: [0]].	chopped := line1 copyFrom: 1 to: headIndex - 1.	tail := line1 copyFrom: chopped size + 2 to: line1 size.	label := 	StringMorph contents: (chopped) translated font: ScriptingSystem fontForTiles.	label2 := StringMorph contents: tail translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: patchTile.	self addMorphBack: label2.! !!KedamaSetColorComponentTile methodsFor: 'initialization' stamp: 'yo 10/12/2004 23:33'!storeCodeOn: aStream indent: tabCount 	"We have a hidden arg. Output two keywords with interspersed arguments."	| firstKeyword |	(#('redComponentIn:' 'setRedComponentIn:') includes: assignmentRoot) ifTrue: [		firstKeyword := 'setRedComponentIn'.	].	(#('greenComponentIn:' 'setGreenComponentIn:') includes: assignmentRoot) ifTrue: [		firstKeyword := 'setGreenComponentIn'	].	(#('blueComponentIn:' 'setBlueComponentIn:') includes: assignmentRoot) ifTrue: [		firstKeyword := 'setBlueComponentIn'	].	aStream nextPutAll: firstKeyword.	aStream nextPut: $:.			aStream space."Simple assignment, don't need existing value"	patchTile submorphs first storeCodeOn: aStream indent: tabCount.	aStream nextPutAll: ' to: '.	assignmentSuffix = ':' 		ifFalse: 			["Assignments that require that old values be retrieved"			aStream nextPutAll: '( '.			self assignmentReceiverTile storeCodeOn: aStream indent: tabCount.			aStream space.			aStream nextPutAll: 'getPatchValueIn:'.			patchTile submorphs first storeCodeOn: aStream indent: tabCount.			aStream nextPutAll: ')'.			aStream space.			aStream nextPutAll: (self operatorForAssignmentSuffix: assignmentSuffix).			aStream space]! !!KedamaSetColorComponentTile methodsFor: 'tile protocol' stamp: 'yo 10/12/2004 22:39'!setAssignmentSuffix: aString	assignmentSuffix := aString.	self computeOperatorOrExpression.	type := #operator. 	self addArrowsIfAppropriate; updateLiteralLabel.! !!KedamaSetPixelValueTile methodsFor: 'initialization-support' stamp: 'yo 10/9/2004 17:59'!addPatchTile	| m1 desiredW m2 label |	m1 := TilePadMorph new.	label := 	StringMorph contents: 'setValueIn' font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Patch.	m1 addMorph: m2.	desiredW := m1 width + 6.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	patchTile := m1.! !!KedamaSetPixelValueTile methodsFor: 'initialization' stamp: 'yo 10/8/2004 09:25'!initialize	super initialize.	type := #Patch.	operatorOrExpression := #setPatchValueIn:to:.	self addPatchTile.	self line1: 'setPatchValue:'.! !!KedamaSetPixelValueTile methodsFor: 'tile protocol' stamp: 'yo 10/8/2004 09:28'!line1: line1	| chopped label label2 tail headIndex |	(line1 select: [:e | e = $:]) size >= 2 ifTrue: [^ self].	self removeAllMorphs.	headIndex := line1 indexOf: $: ifAbsent: [line1 indexOf: Character space ifAbsent: [0]].	chopped := line1 copyFrom: 1 to: headIndex - 1.	tail := line1 copyFrom: chopped size + 2 to: line1 size.	label := 	StringMorph contents: (chopped) font: ScriptingSystem fontForTiles.	label2 := StringMorph contents: tail font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: patchTile.	self addMorphBack: label2.! !!KedamaSetPixelValueTile methodsFor: 'tile protocol' stamp: 'yo 6/7/2004 21:01'!setAssignmentSuffix: aString	assignmentSuffix := aString.	self computeOperatorOrExpression.	type := #operator. 	self addArrowsIfAppropriate; updateLiteralLabel! !!KedamaStandardViewer methodsFor: 'initialization' stamp: 'yo 4/4/2005 18:14'!initializeFor: aPlayer barHeight: anInteger includeDismissButton: aBoolean showCategories: categoryInfo	stub := aPlayer clonedSequentialStub.	stub who: 0.	restrictedWho := 0.	restrictedIndex := 0.	super initializeFor: aPlayer barHeight: anInteger includeDismissButton: aBoolean showCategories: categoryInfo.! !!KedamaStandardViewer methodsFor: 'turtle view' stamp: 'yo 4/4/2005 18:05'!providePossibleRestrictedView: anInteger	| who |	restrictedIndex := anInteger.	who := scriptedPlayer whoAt: anInteger.	restrictedWho = who ifTrue: [^ self].	restrictedWho := who.	stub who: who.	who = 0 ifTrue: [self replaceTargetsWithExampler] ifFalse: [self replaceTargetsWithStub].	self searchingViewerMorphs do: [:v | v updateWhoString].! !!KedamaTurtleAtTile methodsFor: 'initialization-support' stamp: 'yo 10/11/2004 15:49'!addTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'turtle at' font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Player.	m1 addMorph: m2.	desiredW := m1 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	turtleTile := m1.! !!KedamaTurtleAtTile methodsFor: 'initialization' stamp: 'yo 10/9/2004 10:35'!initialize	super initialize.	type := #Player.	operatorOrExpression := #getTurtleAt:.	self addTile.! !!KedamaTurtleAtTile methodsFor: 'tile protocol' stamp: 'yo 10/9/2004 10:35'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'turtleAt' font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: turtleTile.! !!KedamaTurtleMorph methodsFor: 'viewer access' stamp: 'yo 6/11/2004 11:18'!categoriesForViewer	"Answer a list of symbols representing the categories to offer in the viewer, in order"	"^ super categoriesForViewer."	| aList |	aList := OrderedCollection new.	aList addAllFirstUnlessAlreadyPresent: (self class additionsToViewerCategories collect:				[:categorySpec | categorySpec first]).	^ aList! !!KedamaTurtleMorph methodsFor: 'initialization' stamp: 'ar 7/8/2006 20:26'!initialize	super initialize.	turtleCount := 1.	self assuredPlayer assureUniClass.	self extent: 40@40.	isGroup := false.	self color: self saturatedRandomColor.! !!KedamaTurtleMorph methodsFor: 'initialization' stamp: 'yo 9/23/2004 18:38'!install	| t |	self player kedamaWorld: kedamaWorld.	t := self player createTurtles.	kedamaWorld makeTurtles: turtleCount examplerPlayer: self player color: ((self color pixelValueForDepth: 32) bitAnd: 16rFFFFFF) ofPrototype: nil turtles: t randomize: true.	self player createSequenceStub.! !!KedamaTurtleMorph methodsFor: 'group turtle creation' stamp: 'yo 10/11/2004 16:00'!createTurtlesAsIn: aForm originAt: origin	| c xArray yArray colorArray newX newY |	xArray := OrderedCollection new: aForm width * aForm height.	yArray := OrderedCollection new: aForm width * aForm height.	colorArray := OrderedCollection new: aForm width * aForm height.	0 to: aForm height do: [:y |		0 to: aForm width do: [:x |			c := aForm colorAt: (x@y).			c isTransparent ifFalse: [				newX := x + origin x.				newY := y + origin y.				((newX >= 0 and: [newX < kedamaWorld dimensions x]) and: [newY >= 0 and: [newY < kedamaWorld dimensions y]]) ifTrue: [					xArray add: newX.					yArray add: newY.					colorArray add: (c pixelValueForDepth: 32).				].			].		].	].	kedamaWorld makeTurtlesAtPositionsIn: {xArray asArray. yArray asArray. colorArray asArray} examplerPlayer: self player ofPrototype: nil.	self privateTurtleCount: (kedamaWorld turtlesCountOf: self player).! !!KedamaTurtleMorph methodsFor: 'accessing' stamp: 'yo 9/14/2004 15:46'!isGroup: aBoolean	isGroup := aBoolean.! !!KedamaTurtleMorph methodsFor: 'accessing' stamp: 'yo 9/16/2004 18:49'!kedamaWorld: k	kedamaWorld := k.! !!KedamaTurtleMorph methodsFor: 'accessing' stamp: 'yo 6/5/2004 19:38'!privateTurtleCount: c	turtleCount := c.! !!KedamaTurtleMorph methodsFor: 'accessing' stamp: 'yo 4/4/2005 17:47'!turtleCount: count	| c |	c := count asInteger max: 0.	kedamaWorld setTurtlesCount: c examplerPlayer: self player color: ((self color pixelValueForDepth: 32) bitAnd: 16rFFFFFF).	turtleCount := c.	"turtleCount <= 0 ifTrue: [self player allOpenViewers do: [:v | v providePossibleRestrictedView: 0]]."! !!KedamaTurtleOfTile methodsFor: 'initalization support' stamp: 'yo 3/7/2005 08:38'!addTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'turtle of' font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Player.	m1 addMorph: m2.	desiredW := m1 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	turtleTile := m1.! !!KedamaTurtleOfTile methodsFor: 'initialization' stamp: 'yo 3/7/2005 08:36'!initialize	super initialize.	type := #Player.	operatorOrExpression := #getTurtleOf:.	self addTile.! !!KedamaTurtleOfTile methodsFor: 'tile protocol' stamp: 'yo 3/7/2005 08:38'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'turtleOf' font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: turtleTile.! !!KedamaTurtlePlayer methodsFor: 'accessing' stamp: 'yo 6/2/2004 22:36'!who: anInteger	who := anInteger.! !!KedamaTurtlePlayer methodsFor: 'accessing' stamp: 'yo 6/2/2004 22:36'!x: aNumber	x := aNumber.! !!KedamaTurtlePlayer methodsFor: 'accessing' stamp: 'yo 6/2/2004 22:36'!y: aNumber	y := aNumber.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/17/2004 07:26'!color: aColor	color := aColor.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/17/2004 09:59'!getAngleTo: aPlayer	| ret |	ret := ((aPlayer x - self x)@(aPlayer y - self y)) theta radiansToDegrees + 90.0.	ret > 360.0 ifTrue: [^ ret - 360].	^ ret.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/14/2004 16:09'!getDistanceTo: aPlayer	| dist |	dist := ((aPlayer x - self x) squared + (aPlayer y - self y) squared) sqrt.	^ dist.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/6/2004 01:45'!getHeading	"Answer my heading in degrees."	| degrees |	degrees := 90.0 - headingRadians radiansToDegrees.	^ degrees >= 0.0 ifTrue: [degrees] ifFalse: [degrees + 360.0].! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 9/14/2004 19:56'!getReplicated	| newGuys theNewGuy |	newGuys := world makeTurtles: 1 turtlePlayerClass: self class color: self color ofPrototype: self.	theNewGuy := newGuys first.	theNewGuy x: self x.	theNewGuy y: self y.	theNewGuy heading: self heading.	(world prototypeOf: self class) privateTurtleCount: (world turtlesCountOf: self class).	^ theNewGuy! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/2/2004 22:36'!goto: aPoint	"Jump to the given location."	x := aPoint x.	y := aPoint y.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/2/2004 22:36'!heading	"Answer my heading in degrees."	| degrees |	degrees := 90.0 - headingRadians radiansToDegrees.	^ degrees >= 0.0 ifTrue: [degrees] ifFalse: [degrees + 360.0].! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/2/2004 22:36'!heading: angleInDegrees	"Set my heading in degrees. Like a compass, up or north is 0 degrees and right or east is 90 degrees."	headingRadians := ((90.0 - angleInDegrees) \\ 360.0) degreesToRadians.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 9/9/2004 14:45'!hide	visible := false! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 9/9/2004 15:09'!setX: val	| leftEdgeMode rightEdgeMode |	x := val.	x < 0.0 ifTrue: [		leftEdgeMode := world leftEdgeMode.		leftEdgeMode == #wrap ifTrue: [			x := x + world wrapX.		].		leftEdgeMode == #stick ifTrue: [			x := 0.0.		].		leftEdgeMode == #bounce ifTrue: [			x := val negated.			headingRadians < Float pi				ifTrue: [headingRadians := Float pi - headingRadians]				ifFalse: [headingRadians := Float threePi - headingRadians]		].	].	x >= world wrapX ifTrue: [		rightEdgeMode := world rightEdgeMode.		rightEdgeMode == #wrap ifTrue: [			x := x - world wrapX.		].		rightEdgeMode == #stick ifTrue: [			x := world wrapX - 0.0000001.		].		rightEdgeMode == #bounce ifTrue: [			x := world wrapX - 0.0000001 - (x - world wrapX).			headingRadians < Float pi				ifTrue: [headingRadians := Float pi - headingRadians]				ifFalse: [headingRadians := Float threePi - headingRadians]		].	].! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 9/9/2004 15:09'!setY: val	| topEdgeMode bottomEdgeMode |	y := val.	y < 0.0 ifTrue: [		topEdgeMode := world topEdgeMode.		topEdgeMode == #wrap ifTrue: [			y := y + world wrapY.		].		topEdgeMode == #stick ifTrue: [			y := 0.0.		].		topEdgeMode == #bounce ifTrue: [			y := val negated.			headingRadians := Float twoPi - headingRadians.		].	].	y >= world wrapY ifTrue: [		bottomEdgeMode := world bottomEdgeMode.		bottomEdgeMode == #wrap ifTrue: [			y := y - world wrapY.		].		bottomEdgeMode == #stick ifTrue: [			y := world wrapY - 0.0000001.		].		bottomEdgeMode == #bounce ifTrue: [			y := world wrapY - 0.0000001 - (y - world wrapY).			headingRadians := Float twoPi - headingRadians.		].	].! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 9/9/2004 14:44'!show	visible := true.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 9/9/2004 14:44'!visible: aBoolean	visible := aBoolean.! !!KedamaTurtlePlayer methodsFor: 'initialization' stamp: 'yo 9/16/2004 17:41'!initializeWorld: aStarSqueakWorld who: anInteger color: cPixel	| dims |	dims := aStarSqueakWorld dimensions.	world := aStarSqueakWorld.	who := anInteger.	x := world random: dims x - 1.	y := world random: dims y - 1.	headingRadians := ((self random: 36000) / 100.0) degreesToRadians.	color := cPixel.	self isGroup: false.	self show.! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 10/24/2004 18:45'!addInstanceVarNamed: aName withValue: aValue	| newArray |	(aValue isKindOf: Number) ifTrue: [		newArray := KedamaFloatArray new: self size.	].	(aValue isKindOf: Color) ifTrue: [		newArray := WordArray new: self size.	].	(aValue isKindOf: Player) ifTrue: [		newArray := Array new: self size.	].	arrays := arrays, newArray.	info at: aName asSymbol put: arrays size.! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 10/24/2004 18:45'!addInstanceVarVectorNamed: aName withValue: aValue	| newArray |	newArray := KedamaFloatArray new: self size.	arrays := arrays, (Array with: newArray).	newArray atAllPut: aValue.	info at: aName asSymbol put: arrays size.	types at: arrays size put: #Number.! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 9/20/2004 12:00'!compileVectorInstVarAccessorsFor: varName	| nameString index type setPhrase |	nameString := varName asString capitalized.	index := info at: varName asSymbol.	self class compileSilently: ('get', nameString, '	^ ', '(arrays at: ', index printString, ')')		classified: 'access'.	type := types at: index.	type = #Number ifTrue: [		setPhrase := 'setNumberVarAt:'.	].	type = #Boolean ifTrue: [		setPhrase := 'setBooleanVarAt:'.	].	type = #Color ifTrue: [		setPhrase := 'setColorVarAt:'.	].	setPhrase ifNil: [setPhrase := 'setObjectVarAt:'].	self class compileSilently: ('set', nameString, ': xxxArg	self ', setPhrase, index printString, ' put: xxxArg')		classified: 'access'! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 9/20/2004 12:20'!removeSlotNamed: aSlotName	| index newArrays |	self basicRemoveSlotNamed: aSlotName.	index := info at: aSlotName asSymbol ifAbsent: [^ self].	newArrays := (arrays copyFrom: 1 to: index - 1), (arrays copyFrom: index + 1 to: arrays size).	types replaceFrom: index to: types size with: types startingAt: index + 1.	info removeKey: aSlotName asSymbol.	arrays := newArrays.! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 9/20/2004 16:34'!removeVectorSlotNamed: aSlotName	| index newArrays |	index := info at: aSlotName asSymbol ifAbsent: [^ self].	newArrays := (arrays copyFrom: 1 to: index - 1), (arrays copyFrom: index + 1 to: arrays size).	types replaceFrom: index to: types size - 1 with: types startingAt: index + 1.	info removeKey: aSlotName asSymbol.	arrays := newArrays.	self compileAllAccessors.! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 10/27/2004 16:29'!renameVectorSlot: oldSlotName newSlotName: newSlotName	| index |	index := info at: oldSlotName asSymbol ifAbsent: [^ self].	info removeKey: oldSlotName asSymbol.	info at: newSlotName put: index.! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 9/20/2004 17:59'!setVectorSlotTypeFor: slotName typeChosen: typeChosen	| index initVar |	index := info at: slotName asSymbol.	index = 0 ifTrue: [^ self].	initVar := self initialValueForSlotOfType: typeChosen.	types at: index put: typeChosen.	self compileAllAccessors.	arrays at: index put: (self arrayForType: typeChosen).	self perform: ('set', slotName capitalized, ':') asSymbol with: initVar.! !!KedamaTurtleVectorPlayer methodsFor: 'add turtles' stamp: 'yo 10/30/2004 18:56'!addTurtlesCount: count ofPrototype: prototype for: aKedamaWorld positionAndColorArray: positionAndColorArray	| index array defaultValue newArray oldCount |	oldCount := self size.	info associationsDo: [:assoc |		index := info at: assoc key.		array := arrays at: (info at: assoc key).		defaultValue := prototype at: index.		newArray := array class new: count.		(#(who x y heading color normal) includes: assoc key) ifFalse: [			newArray atAllPut: defaultValue.		].		assoc key = #x ifTrue: [newArray replaceFrom: 1 to: newArray size with: positionAndColorArray first startingAt: 1].		assoc key = #y ifTrue: [newArray replaceFrom: 1 to: newArray size with: positionAndColorArray second startingAt: 1].		assoc key = #color ifTrue: [newArray replaceFrom: 1 to: newArray size with: positionAndColorArray third startingAt: 1].		assoc key = #heading ifTrue: [newArray atAllPut: 1.57079631 "Float pi / 2.0"].		assoc key = #normal ifTrue: [newArray atAllPut: 1.57079631 "Float pi / 2.0"].		arrays at: (assoc value) put: array, newArray.	].	#(who) do: [:name |		self setInitialValueOf: name from: oldCount + 1 to: self size for: aKedamaWorld.	].	whoTableValid := false.	turtleMapValid := false.	! !!KedamaTurtleVectorPlayer methodsFor: 'add turtles' stamp: 'yo 9/18/2004 15:27'!addTurtlesCount: count ofPrototype: prototype for: aKedamaWorld randomize: randomizeFlag	| index array defaultValue newArray oldCount |	oldCount := self size.	info associationsDo: [:assoc |		index := info at: assoc key.		array := arrays at: index.		defaultValue := prototype at: index.		newArray := array class new: count.		newArray atAllPut: defaultValue.		arrays at: index put: (array, newArray).	].	self setInitialValueOf: #who from: oldCount + 1 to: self size for: aKedamaWorld.	randomizeFlag ifTrue: [		#(x y heading) do: [:name |			self setInitialValueOf: name from: oldCount + 1 to: self size for: aKedamaWorld.		].	].	whoTableValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'add turtles' stamp: 'yo 9/27/2004 16:14'!setTurtlesCount: count prototype: prototype for: aKedamaWorld randomize: rondomizeFlag	| anInteger array |	anInteger := count.	count < 0 ifTrue: [anInteger := 0].	self size > anInteger ifTrue: [		info associationsDo: [:assoc |			array := (arrays at: assoc value).			array := array copyFrom: 1 to: anInteger.			arrays at: assoc value put: array.		].		turtleMapValid := false.		whoTableValid := false.	].	self size < anInteger ifTrue: [		self addTurtlesCount: (anInteger - self size) ofPrototype: prototype for: aKedamaWorld randomize: rondomizeFlag.		turtleMapValid := false.		whoTableValid := false.	].! !!KedamaTurtleVectorPlayer methodsFor: 'private' stamp: 'yo 10/24/2004 18:45'!arrayForType: typeName	| newArray |	(typeName = #Number) ifTrue: [		newArray := KedamaFloatArray new: self size.	].	(typeName = #Color) ifTrue: [		newArray := WordArray new: self size.	].	(typeName = #Boolean) ifTrue: [		newArray := ByteArray new: self size.	].	newArray ifNil: [		newArray := Array new: self size.	].	^ newArray.! !!KedamaTurtleVectorPlayer methodsFor: 'private' stamp: 'yo 9/28/2004 17:16'!groupForward: dist	| x y headingRadians |	self size = 0 ifTrue: [^ self].	x := (arrays at: 2) first.	y := (arrays at: 3) first.	headingRadians := (arrays at: 4) first.	self groupSetX: (x + (dist asFloat * headingRadians cos)).	self groupSetY: (y - (dist asFloat * headingRadians sin)).! !!KedamaTurtleVectorPlayer methodsFor: 'private' stamp: 'yo 9/29/2004 08:35'!groupSetX: val	| xArray headingArray origX origHeading leftEdgeMode rightEdgeMode newArray wrapX minX maxX |	self size = 0 ifTrue: [^ self].	xArray := arrays at: 2.	headingArray := arrays at: 4.		origX := xArray first.	origHeading := headingArray first.	leftEdgeMode := kedamaWorld leftEdgeModeMnemonic.	rightEdgeMode := kedamaWorld rightEdgeModeMnemonic.	newArray := xArray collect: [:e | e + val - origX].	wrapX := kedamaWorld wrapX.	minX := newArray min.	maxX := newArray max.	((minX < 0.0) not and: [(maxX >= wrapX) not]) ifTrue: [		arrays at: 2 put: newArray.		^ self.	].	minX < 0.0 ifTrue: [		leftEdgeMode = 1 ifTrue: [			newArray withIndexDo: [:e :i |				e < 0.0 ifTrue: [newArray at: i put: e + wrapX].			].		].		leftEdgeMode = 2 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e - minX.			].		].		leftEdgeMode = 3 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e + (minX * -2.0).			].		].			].	maxX >= wrapX ifTrue: [		rightEdgeMode = 1 ifTrue: [			newArray withIndexDo: [:e :i |				e >= wrapX ifTrue: [newArray at: i put: e - wrapX].			].		].		rightEdgeMode = 2 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e - (maxX - wrapX) - 2.35099e-038.			].		].		rightEdgeMode = 3 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e - ((maxX - wrapX) * 2.0) - 2.35099e-038.			].		].	].	arrays at: 2 put: newArray.! !!KedamaTurtleVectorPlayer methodsFor: 'private' stamp: 'yo 9/28/2004 17:58'!groupSetY: val	| yArray headingArray origY origHeading topEdgeMode bottomEdgeMode newArray wrapY minY maxY |	self size = 0 ifTrue: [^ self].	yArray := arrays at: 3.	headingArray := arrays at: 4.		origY := yArray first.	origHeading := headingArray first.	topEdgeMode := kedamaWorld topEdgeModeMnemonic.	bottomEdgeMode := kedamaWorld bottomEdgeModeMnemonic.	newArray := yArray collect: [:e | e + val - origY].	wrapY := kedamaWorld wrapY.	minY := newArray min.	maxY := newArray max.	((minY < 0.0) not and: [(maxY >= wrapY) not]) ifTrue: [		arrays at: 3 put: newArray.		^ self.	].	minY < 0.0 ifTrue: [		topEdgeMode = 1 ifTrue: [			newArray withIndexDo: [:e :i |				e < 0.0 ifTrue: [newArray at: i put: e + wrapY].			].		].		topEdgeMode = 2 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e - minY.			].		].		topEdgeMode = 3 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e + (minY * -2.0).			].		].			].	maxY >= wrapY ifTrue: [		bottomEdgeMode = 1 ifTrue: [			newArray withIndexDo: [:e :i |				e >= wrapY ifTrue: [newArray at: i put: e - wrapY].			].		].		bottomEdgeMode = 2 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e - (maxY - wrapY) - 2.35099e-038.			].		].		bottomEdgeMode = 3 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e - ((maxY - wrapY) * 2.0) - 2.35099e-038.			].		].	].	arrays at: 3 put: newArray.! !!KedamaTurtleVectorPlayer methodsFor: 'private' stamp: 'yo 10/25/2004 16:23'!useKedamaFloatArray	| newArray |	arrays withIndexDo: [:array :index |		(array isMemberOf: FloatArray) ifTrue: [			newArray := KedamaFloatArray new: array size.			newArray replaceFrom: 1 to: array size with: array startingAt: 1.			arrays at: index put: newArray.		].	].! !!KedamaTurtleVectorPlayer methodsFor: 'accessing' stamp: 'yo 9/28/2004 14:02'!exampler: e	exampler := e.! !!KedamaTurtleVectorPlayer methodsFor: 'turtle map' stamp: 'yo 10/22/2004 07:10'!aTurtleAtX: xPos y: yPos	| w x y index who stub |	turtleMapValid ifFalse: [		self makeTurtlesMap.	].	w := kedamaWorld dimensions x.	x := xPos truncated.	y := yPos truncated.	x < 0 ifTrue: [^ nil].	x >= w ifTrue: [^ nil].	y < 0 ifTrue: [^ nil].	y >= kedamaWorld dimensions y ifTrue: [^ nil].	index := (w * y) + x + 1.	who := turtlesMap at: index.	who = 0 ifTrue: [^ nil].	who = lastWho ifTrue: [^ lastWhoStub].	stub := exampler clonedSequentialStub.	stub who: who.	lastWho := who.	^ lastWhoStub := stub.! !!KedamaTurtleVectorPlayer methodsFor: 'turtle map' stamp: 'yo 9/29/2004 17:24'!basicMakeTurtlesMap	| x y xArray yArray width height mapIndex whoArray |	xArray := arrays at: 2.	yArray := arrays at: 3.	whoArray := arrays at: 1.	width := kedamaWorld dimensions x.	height := kedamaWorld dimensions y.	turtlesMap atAllPut: 0.	1 to: self size do: [:index |		x := (xArray at: index) truncated.		y := (yArray at: index) truncated.		mapIndex := (width * y) + x + 1.		(0 < mapIndex and: [mapIndex <= turtlesMap size]) ifTrue: [			turtlesMap at: mapIndex put: (whoArray at: index).		].	].	turtleMapValid := true.! !!KedamaTurtleVectorPlayer methodsFor: 'turtle map' stamp: 'yo 9/28/2004 10:21'!invalidateTurtleMap	turtleMapValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'turtle map' stamp: 'yo 9/29/2004 17:31'!makeTurtlesMap	| xArray yArray width height whoArray ret |	xArray := arrays at: 2.	yArray := arrays at: 3.	whoArray := arrays at: 1.	width := kedamaWorld dimensions x.	height := kedamaWorld dimensions y.	turtlesMap ifNil: [turtlesMap := WordArray new: width * height].	ret := self primMakeTurtlesMap: turtlesMap whoArray: whoArray xArray: xArray yArray: yArray width: width height: height.	ret ifNil: [self basicMakeTurtlesMap].	turtleMapValid := true.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:45'!basicGetAngleTo: players	| ret p xArray yArray result |	players isCollection ifFalse: [		p := players	].	xArray := arrays at: 2.	yArray := arrays at: 3.	result := KedamaFloatArray new: self size.	1 to: self size do: [:index |		players isCollection ifTrue: [			p := players at: index.		].		ret := ((p getX - (xArray at: index))@(p getY - (yArray at: index))) theta radiansToDegrees + 90.0.		ret > 360.0 ifTrue: [ret := ret - 360.0].		result at: index put: ret.	].	^ result.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:45'!basicGetDistanceTo: players	| p xArray yArray result |	players isCollection ifFalse: [		p := players	].	xArray := arrays at: 2.	yArray := arrays at: 3.	result := KedamaFloatArray new: self size.	1 to: self size do: [:index |		players isCollection ifTrue: [			p := players at: index.		].		result at: index put: ((p getX - (xArray at: index)) squared + (p getY - (yArray at: index)) squared) sqrt.	].	^ result.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 4/5/2005 11:04'!colorFromPatch: aPatch	| xArray yArray cArray patch |	xArray := arrays at: 2.	yArray := arrays at: 3.	cArray := arrays at: 5.	patch := aPatch costume renderedMorph.	1 to: self size do: [:i |		cArray at: i put: ((patch pixelAtX: (xArray at: i) y: (yArray at: i)) bitAnd: 16rFFFFFF).	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/12/2004 23:14'!colorToPatch: aPatch	| xArray yArray cArray patch |	xArray := arrays at: 2.	yArray := arrays at: 3.	cArray := arrays at: 5.	patch := aPatch costume renderedMorph.	1 to: self size do: [:i |		patch pixelAtX: (xArray at: i) y: (yArray at: i) put: (cArray at: i).	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/26/2004 11:34'!deleteTurtleID: who	| whoArray whoIndex newArray |	whoArray := arrays at: 1.	whoIndex := whoArray indexOf: who ifAbsent: [^ self].	deletingIndex := whoIndex - 1.	arrays withIndexDo: [:array :index |		newArray := (array copyFrom: 1 to: whoIndex - 1), (array copyFrom: whoIndex + 1 to: array size).		arrays at: index put: newArray.	].	whoTableValid := false.	turtleMapValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/30/2004 11:13'!forward: val	exampler getGrouped ifFalse: [		self primForwardXArray: (arrays at: 2) yArray: (arrays at: 3) headingArray: (arrays at: 4) value: (val isNumber ifTrue: [val asFloat] ifFalse: [val]) destWidth: kedamaWorld wrapX asFloat destHeight: kedamaWorld wrapY asFloat leftEdgeMode: kedamaWorld leftEdgeModeMnemonic rightEdgeMode: kedamaWorld rightEdgeModeMnemonic topEdgeMode: kedamaWorld topEdgeModeMnemonic bottomEdgeMode: kedamaWorld bottomEdgeModeMnemonic.	] ifTrue: [		self groupForward: val	].	turtleMapValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:45'!getAngleTo: players	| p xArray yArray result pX pY xy |	players isCollection ifFalse: [		p := players	].	xArray := arrays at: 2.	yArray := arrays at: 3.	result := KedamaFloatArray new: self size.	players isCollection ifTrue: [		pX := KedamaFloatArray new: players size.		pY := KedamaFloatArray new: players size.		1 to: players size do: [:i |			xy := (players at: i) getXAndY.			pX at: i put: xy x.			pY at: i put: xy y.		].	] ifFalse: [		xy := p getXAndY.		pX := xy x.		pY := xy y.	].	^ self primGetAngleToX: pX toY: pY xArray: xArray yArray: yArray resultInto: result.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/25/2004 11:34'!getBlueComponentIn: aPatch	| pix xArray yArray patch w |	xArray := arrays at: 2.	yArray := arrays at: 3.	patch := aPatch costume renderedMorph.	w := WordArray new: self size.	1 to: self size do: [:i |		pix := patch pixelAtX: (xArray at: i) y: (yArray at: i).		w at: i put: (pix bitAnd: 16rFF).	].	^ w.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:45'!getDistanceTo: players	| p xArray yArray result pX pY xy |	players isCollection ifFalse: [		p := players	].	xArray := arrays at: 2.	yArray := arrays at: 3.	result := KedamaFloatArray new: self size.	players isCollection ifTrue: [		pX := KedamaFloatArray new: players size.		pY := KedamaFloatArray new: players size.		1 to: players size do: [:i |			xy := (players at: i) getXAndY.			pX at: i put: xy x.			pY at: i put: xy y.		].	] ifFalse: [		xy := p getXAndY.		pX := xy x.		pY := xy y.	].	^ self primGetDistanceToX: pX toY: pY xArray: xArray yArray: yArray resultInto: result.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/25/2004 11:34'!getGreenComponentIn: aPatch	| pix xArray yArray patch w |	xArray := arrays at: 2.	yArray := arrays at: 3.	patch := aPatch costume renderedMorph.	w := WordArray new: self size.	1 to: self size do: [:i |		pix := patch pixelAtX: (xArray at: i) y: (yArray at: i).		w at: i put: ((pix bitShift: -8) bitAnd: 16rFF).	].	^ w.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:45'!getHeading	| heading result ret |	heading := (arrays at: 4).	result := KedamaFloatArray new: heading size.	ret := self primGetHeading: heading into: result.	ret ifNotNil: [^ result].	! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:46'!getNormal	| result ret normal |	normal := (arrays at: 7).	result := KedamaFloatArray new: normal size.	ret := self primGetHeading: normal into: result.	ret ifNotNil: [^ result].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/25/2004 16:44'!getPatchValueIn: aPatch	| w patch xArray yArray |	w := WordArray new: self size.	patch := aPatch costume renderedMorph.	xArray := arrays at: 2.	yArray := arrays at: 3.	patch pixelsAtXArray: xArray yArray: yArray into: w.	^ w.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/25/2004 11:35'!getRedComponentIn: aPatch	| pix xArray yArray patch w |	xArray := arrays at: 2.	yArray := arrays at: 3.	patch := aPatch costume renderedMorph.	w := WordArray new: self size.	1 to: self size do: [:i |		pix := patch pixelAtX: (xArray at: i) y: (yArray at: i).		w at: i put: ((pix bitShift: -16) bitAnd: 16rFF).	].	^ w.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 3/7/2005 08:22'!getTurtleAt: aPlayer	| xy |	aPlayer isCollection ifTrue: [		self error: 'should not happen'.	].	xy := aPlayer getXAndY.	^ (self aTurtleAtX: xy x y: xy y) ifNil: [^ aPlayer].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 3/7/2005 08:37'!getTurtleOf: aBreedPlayer	| xy |	aBreedPlayer isCollection ifTrue: [		"self error: 'should not happen'."		^ aBreedPlayer.	].	xy := aBreedPlayer getXAndY.	^ (self aTurtleAtX: xy x y: xy y) ifNil: [^ aBreedPlayer].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:46'!getUphillIn: aPatch	| xArray yArray headingArray result patch |	xArray := arrays at: 2.	yArray := arrays at: 3.	headingArray := arrays at: 4.	result := KedamaFloatArray new: self size.	patch := aPatch costume renderedMorph.	1 to: self size do: [:index |		result at: index put: (patch			uphillForTurtleX: (xArray at: index)			turtleY: (yArray at: index)			turtleHeading: (headingArray at: index)).	].	^ result.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/29/2004 14:21'!getX	| xArray |	exampler getGrouped ifFalse: [		^ arrays at: 2.	] ifTrue: [		xArray := arrays at: 2.		xArray size = 0 ifTrue: [^ exampler getX].		^ xArray first.	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/29/2004 14:22'!getY	| yArray |	exampler getGrouped ifFalse: [		^ arrays at: 3.	] ifTrue: [		yArray := arrays at: 3.		yArray size = 0 ifTrue: [^ exampler getY].		^ yArray first.	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/16/2004 23:02'!heading: degrees	| deg |	deg := degrees isNumber ifTrue: [degrees asFloat] ifFalse: [degrees].	self primSetHeading: (arrays at: 4) from: deg.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/29/2004 09:06'!normal: degrees	| deg |	deg := degrees isNumber ifTrue: [degrees asFloat] ifFalse: [degrees].	self primSetHeading: (arrays at: 7) from: deg.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/13/2004 06:41'!setBlueComponentIn: aPatch to: value	| pix xArray yArray patch component |	xArray := arrays at: 2.	yArray := arrays at: 3.	patch := aPatch costume renderedMorph.	value isCollection ifFalse: [		component := value asInteger bitAnd: 16rFF.	].	(1 to: self size) do: [:i |		value isCollection ifTrue: [			component := (value at: i) asInteger bitAnd: 16rFF.		].		pix := patch pixelAtX: (xArray at: i) y: (yArray at: i).		pix := (pix bitAnd: 16rFFFF00) bitOr: component.		patch pixelAtX: (xArray at: i) y: (yArray at: i) put: pix.	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/13/2004 06:40'!setGreenComponentIn: aPatch to: value	| pix xArray yArray patch component |	xArray := arrays at: 2.	yArray := arrays at: 3.	patch := aPatch costume renderedMorph.	value isCollection ifFalse: [		component := (value asInteger bitAnd: 16rFF) bitShift: 8.	].	(1 to: self size) do: [:i |		value isCollection ifTrue: [			component := ((value at: i) asInteger bitAnd: 16rFF) bitShift: 8.		].		pix := patch pixelAtX: (xArray at: i) y: (yArray at: i).		pix := (pix bitAnd: 16rFF00FF) bitOr: component.		patch pixelAtX: (xArray at: i) y: (yArray at: i) put: pix.	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 3/7/2005 13:41'!setInitialValueOf: name from: from to: to for: aKedamaWorld	| array max |	array := arrays at: (info at: name).	name = #who ifTrue: [		from to: to do: [:index |			array at: index put: (aKedamaWorld nextTurtleID).		].		^ self.	].	name = #x ifTrue: [		max := aKedamaWorld dimensions x * 100.		self primRandomRange: max from: from to: to intoFloatArray: array factor: 0.01.		^ self.	].	name = #y ifTrue: [		max := aKedamaWorld dimensions y * 100.		self primRandomRange: max from: from to: to intoFloatArray: array factor: 0.01.		^ self.	].	name = #heading ifTrue: [		self primRandomRange: 36000 from: from to: to intoFloatArray: array factor: (0.01 *  0.0174532925199433).		^ self.	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/25/2004 16:57'!setPatchValueIn: aPatch to: value	| xArray yArray patchMorph |	xArray := arrays at: 2.	yArray := arrays at: 3.	patchMorph := aPatch costume renderedMorph.	patchMorph setPixelsAtXArray: xArray yArray: yArray value: value.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/13/2004 06:40'!setRedComponentIn: aPatch to: value	| pix xArray yArray patch component |	xArray := arrays at: 2.	yArray := arrays at: 3.	patch := aPatch costume renderedMorph.	value isCollection ifFalse: [		component := (value asInteger bitAnd: 16rFF) bitShift: 16.	].	(1 to: self size) do: [:i |		value isCollection ifTrue: [			component := ((value at: i) asInteger bitAnd: 16rFF) bitShift: 16.		].		pix := patch pixelAtX: (xArray at: i) y: (yArray at: i).		pix := (pix bitAnd: 16r00FFFF) bitOr: component.		patch pixelAtX: (xArray at: i) y: (yArray at: i) put: pix.	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/29/2004 14:13'!setX: v	exampler getGrouped ifFalse: [		self			primSetX: (arrays at: 2)			headingArray: (arrays at: 4)			value: (v isNumber ifTrue: [v asFloat] ifFalse: [v])			destWidth: kedamaWorld wrapX			leftEdgeMode: kedamaWorld leftEdgeModeMnemonic			rightEdgeMode: kedamaWorld rightEdgeModeMnemonic.	] ifTrue: [		self groupSetX: v	].	turtleMapValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/29/2004 14:13'!setY: v	exampler getGrouped ifFalse: [		self			primSetY: (arrays at: 3)			headingArray: (arrays at: 4)			value: (v isNumber ifTrue: [v asFloat] ifFalse: [v])			destHeight: kedamaWorld wrapY			topEdgeMode: kedamaWorld topEdgeModeMnemonic			bottomEdgeMode: kedamaWorld bottomEdgeModeMnemonic.	] ifTrue: [		self groupSetY: v.	].	turtleMapValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'deleting' stamp: 'yo 10/8/2004 11:04'!delete	| anInstance |	exampler := nil.	arrays := nil.	whoTable := nil.	turtlesMap := nil.	self class removeFromSystem: false.	anInstance := UnscriptedPlayer new.	self become: anInstance.! !!KedamaTurtleVectorPlayer methodsFor: 'displaying' stamp: 'yo 9/16/2004 21:40'!drawOn: aForm	| xArray yArray colorArray visibleArray bits x y visible bitsIndex dimX dimY ret |	xArray := arrays at: 2.	yArray := arrays at: 3.	colorArray := arrays at: 5.	visibleArray := arrays at: 6.	bits := aForm bits.	dimX := aForm width.	dimY := aForm height.	ret := self primDrawOn: bits destWidth: dimX destHeight: dimY xArray: xArray yArray: yArray colorArray: colorArray visibleArray: visibleArray.	ret ifNotNil: [^ self].	1 to: self size do: [:index |		x := (xArray at: index) truncated.		y := (yArray at: index) truncated.		visible := (visibleArray at: index) ~= 0.		(visible and: [((x >= 0) and: [y >= 0]) and: [(x < dimX) and: [y < dimY]]]) ifTrue: [			bitsIndex := ((y * dimX) + x) + 1.			bits at: bitsIndex put: (colorArray at: index).		].	].! !!KedamaTurtleVectorPlayer methodsFor: 'enumeration' stamp: 'yo 9/27/2004 15:16'!indexOf: who	| whoArray |	whoTableValid ifTrue: [^ whoTable at: (who - whoTableBase)].	whoArray := arrays at: 1.	whoArray size = 0 ifTrue: [^ 0].	whoTableBase := whoArray first - 1.	whoTable := WordArray new: whoArray last - whoTableBase.	1 to: whoArray size do: [:w |		whoTable at: (whoArray at: w) - whoTableBase put: w.	].	whoTableValid := true.	^ whoTable at: (who - whoTableBase).! !!KedamaTurtleVectorPlayer methodsFor: 'enumeration' stamp: 'yo 9/18/2004 12:02'!initializeDeletingIndex	deletingIndex := 0.! !!KedamaTurtleVectorPlayer methodsFor: 'enumeration' stamp: 'yo 9/18/2004 12:02'!nextDeletingIndex	^ deletingIndex := deletingIndex + 1.! !!KedamaTurtleVectorPlayer methodsFor: 'initialization' stamp: 'yo 10/24/2004 18:46'!initialize	super initialize.	info := IdentityDictionary new.	info at: #who put: 1.	info at: #x put: 2.	info at: #y put: 3.	info at: #heading put: 4.	info at: #color put: 5.	info at: #visible put: 6.	info at: #normal put: 7.	arrays := Array new: 7.	arrays at: (info at: #who) put: (WordArray new: 0).	arrays at: (info at: #x) put: (KedamaFloatArray new: 0).	arrays at: (info at: #y) put: (KedamaFloatArray new: 0).	arrays at: (info at: #heading) put: (KedamaFloatArray new: 0).	arrays at: (info at: #color) put: (WordArray new: 0).	arrays at: (info at: #visible) put: (ByteArray new: 0).	arrays at: (info at: #normal) put: (KedamaFloatArray new: 0).	types := Array new: 64.	types at: 1 put: #Integer.	types at: 2 put: #Number.	types at: 3 put: #Number.	types at: 4 put: #Number.	types at: 5 put: #Color.	types at: 6 put: #Boolean.	types at: 7 put: #Number.	whoTableValid := false.	turtleMapValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/11/2004 11:49'!primDrawOn: destBits destWidth: destWidth destHeight: destHeight xArray: xArray yArray: yArray colorArray: colorArray visibleArray: visibleArray	| x y visible bitsIndex |	<primitive: 'drawTurtlesInArray' module: 'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #drawTurtlesInArray."	1 to: xArray size do: [:i |		x := (xArray at: i) asInteger.		y := (yArray at: i) asInteger.		visible := (visibleArray at: i).		(visible ~= 0 and: [((x >= 0) and: [y >= 0]) and: [(x < destWidth) and: [y < destHeight]]]) ifTrue: [			bitsIndex := ((y * destWidth) + x) + 1.			destBits at: bitsIndex put: (colorArray at: i).		]	].! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/11/2004 11:04'!primForwardXArray: xArray yArray: yArray headingArray: headingArray value: v destWidth: destWidth destHeight: destHeight leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode	| dist newX newY |	<primitive: 'primTurtlesForward' module: 'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primTurtlesForward."	1 to: xArray size do: [:i |		v isCollection ifTrue: [			dist := (v at: i) asFloat.		] ifFalse: [			dist := v asFloat.		].		newX := (xArray at: i) + (dist * (headingArray at: i) cos).		newY := (yArray at: i) - (dist * (headingArray at: i) sin).		KedamaMorph scalarXAt: i xArray: xArray headingArray: headingArray value: newX destWidth: destWidth leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode.		KedamaMorph scalarYAt: i yArray: yArray headingArray: headingArray value: newY destHeight: destHeight topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode.	].! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/23/2004 22:19'!primGetAngleToX: pX toY: pY xArray: xArray yArray: yArray resultInto: result	| ppx ppy x y ret |	<primitive: 'vectorGetAngleTo' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #vectorGetAngleTo."	ppx := pX.	ppy := pY.	1 to: result size do: [:index |		pX isCollection ifTrue: [			ppx := pX at: index.			ppy := pY at: index.		].		x := ppx - (xArray at: index).		y := ppy - (yArray at: index).		ret := (x@y) theta radiansToDegrees + 90.0.		ret > 360.0 ifTrue: [ret := ret - 360.0].		result at: index put: ret.	].	^ result.! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/23/2004 18:02'!primGetDistanceToX: pX toY: pY xArray: xArray yArray: yArray resultInto: result	| ppx ppy |	<primitive: 'vectorGetDistanceTo' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #vectorGetDistanceTo."	ppx := pX.	ppy := pY.	1 to: result size do: [:index |		pX isCollection ifTrue: [			ppx := pX at: index.			ppy := pY at: index.		].		result at: index put: ((ppx - (xArray at: index)) squared + (ppy - (yArray at: index)) squared) sqrt.	].	^ result.! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/9/2004 17:29'!primGetHeading: headingArray into: resultArray	| heading |	<primitive: 'getHeadingArrayInto' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #getHeadingArrayInto."	1 to: headingArray size do: [:i |		heading := headingArray at: i.		heading := heading / 0.0174532925199433.		heading := 90.0 - heading.		heading > 0.0 ifFalse: [heading := heading + 360.0].		resultArray at: i put: heading.	].! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/11/2004 11:40'!primSetHeading: headingArray from: val	| heading |	<primitive: 'setHeadingArrayFrom' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #setHeadingArrayFrom."	val isCollection ifFalse: [		heading := val asFloat.		heading := KedamaMorph degreesToRadians: heading.	].	1 to: headingArray size do: [:i |		val isCollection ifTrue: [			heading := val at: i.			heading := KedamaMorph degreesToRadians: heading.		].		headingArray at: i put: heading.	].! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/11/2004 11:19'!primSetX: xArray headingArray: headingArray value: v destWidth: destWidth leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode	| val newX |	<primitive: 'turtlesSetX' module: 'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #turtlesSetX."	v isCollection ifFalse: [		val := v asFloat.	].	1 to: xArray size do: [:i |		v isCollection ifTrue: [			newX := v at: i.		] ifFalse: [			newX := val.		].		KedamaMorph scalarXAt: i xArray: xArray headingArray: headingArray value: newX destWidth: destWidth leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode.	].! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/11/2004 11:21'!primSetY: yArray headingArray: headingArray value: v destHeight: destHeight topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode	| val newY |	<primitive: 'turtlesSetY' module: 'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #turtlesSetY."	v isCollection ifFalse: [		val := v asFloat.	].	1 to: yArray size do: [:i |		v isCollection ifTrue: [			newY := v at: i.		] ifFalse: [			newY := val.		].		KedamaMorph scalarYAt: i yArray: yArray headingArray: headingArray value: newY destHeight: destHeight topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode.	].! !!KedamaUpHillTile methodsFor: 'initialization-support' stamp: 'yo 4/5/2005 14:53'!addPatchTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'upHillIn' translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Patch.	m1 addMorph: m2.	desiredW := m1 width + 6.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	patchTile := m1.! !!KedamaUpHillTile methodsFor: 'initialization' stamp: 'yo 6/7/2004 18:34'!initialize	super initialize.	type := #Patch.	operatorOrExpression := #getUphillIn:.	self addPatchTile.! !!KedamaUpHillTile methodsFor: 'tile protocol' stamp: 'yo 4/5/2005 14:53'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'upHillIn' translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: patchTile.! !!KedamaVectorizer methodsFor: 'private' stamp: 'yo 9/24/2004 11:47'!checkFirstPairFor: stmt in: obj	^ self checkRequireVectorIn: stmt for: obj."	| receiver selector ret |	receiver := Compiler evaluate: (self getReceiverFromStatement: stmt) name for: obj logged: false.	selector := (self getSelectorFromStatement: stmt) key.	ret := self isVectorizationRequiredWithPlayer: receiver andSelector: selector.	attributes setAttribute: #firstTurtle of: stmt to: receiver.	attributes setAttribute: #requireVector of: stmt to: ret.	^ ret."! !!KedamaVectorizer methodsFor: 'private' stamp: 'yo 2/14/2005 15:33'!checkRequireVectorIn: aMessageNode for: obj	| players playersSet sel playerNodes |	"self halt."	playerNodes := self getAllPlayersIn: aMessageNode for: obj.	players := playerNodes collect: [:e | Compiler evaluate: e name for: obj logged: false.].	playersSet := players asSet.	(playersSet select: [:e | e isPrototypeTurtlePlayer]) size = 0 ifTrue: [		attributes setAttribute: #firstTurtle of: aMessageNode to: (Compiler evaluate: playerNodes first name for: obj logged: false).		attributes setAttribute: #requireVector of: aMessageNode to: false.		^ self.	].	(playersSet select: [:e | e isPrototypeTurtlePlayer]) size > 0 ifTrue: [			playerNodes with: players do: [:n :p |			p isPrototypeTurtlePlayer ifTrue: [				sel := self getSelectorRootFor: p fromMessageNode: aMessageNode for: obj ignoreSelectors: #(beNotZero: setTurtleCount: getTurtleCount setGrouped: getGrouped).				sel ifNotNil: [					(self isVectorizationRequiredWithPlayer: p andSelector: sel) ifTrue: [						attributes setAttribute: #requireVector of: aMessageNode to: true.						attributes setAttribute: #firstTurtle of: aMessageNode to: p.						attributes setAttribute: #firstNode of: aMessageNode to: n.						^ self.					].				].			].		].	].	attributes setAttribute: #firstTurtle of: aMessageNode to: players first.	attributes setAttribute: #requireVector of: aMessageNode to: false.! !!KedamaVectorizer methodsFor: 'private' stamp: 'yo 9/24/2004 12:11'!vectorizeAt: index inMethodNode: aMethodNode	| v encoder origReceiverName origReceiver aMessageNode |	aMessageNode := aMethodNode block statements at: index.	(attributes getAttribute: #requireVector of: aMessageNode) ifFalse: [^ self].	encoder := aMethodNode encoder.	encoder autoBind: 'xxxObj'.	v := encoder encodeVariable: 'xxxObj' sourceRange: nil ifUnknown: [].	origReceiver := attributes getAttribute: #firstNode of: aMessageNode.	(origReceiver isMemberOf: VariableNode) ifTrue: [		origReceiverName := origReceiver name.	] ifFalse: [		origReceiverName := 'self'.	].	self replaceRoot: origReceiverName with: v inMessageNode: aMessageNode.	"self changeSelectorAt: index inMethodNode: aMethodNode."	self insertTurtleCommandAt: index in: aMethodNode block statements variableNode: v from: encoder firstReceiverName: origReceiverName.! !!KedamaVectorizer methodsFor: 'player and selector look up' stamp: 'yo 10/8/2004 05:23'!getAllPlayersInMethodNode: aMethodNode for: obj	| aCollection |	aCollection := OrderedCollection new.	aMethodNode block statements do: [:stmt |		(stmt isMemberOf: MessageNode) ifTrue: [			self getPlayersMessage: stmt for: obj into: aCollection.		].		(stmt isMemberOf: BlockNode) ifTrue: [			self getPlayersBlock: stmt for: obj into: aCollection.		].	].	^ aCollection.! !!KedamaVectorizer methodsFor: 'player and selector look up' stamp: 'yo 9/24/2004 11:13'!getAllPlayersIn: aMessageNode for: obj	| aCollection |	aCollection := OrderedCollection new.	self getPlayersMessage: aMessageNode for: obj into: aCollection.	^ aCollection.! !!KedamaVectorizer methodsFor: 'player and selector look up' stamp: 'yo 9/24/2004 11:08'!getPlayersBlock: aBlockNode for: obj into: aCollection	| statements |	statements := aBlockNode statements.	statements do: [:stmt |		(stmt isMemberOf: MessageNode) ifTrue: [			self getPlayersMessage: stmt for: obj into: aCollection.		].		(stmt isMemberOf: BlockNode) ifTrue: [			self getPlayersBlock: stmt for: obj into: aCollection..		].	].! !!KedamaVectorizer methodsFor: 'player and selector look up' stamp: 'yo 9/24/2004 12:02'!getPlayersMessage: aMessageNode for: obj into: aCollection	| thisPlayer |	((Array with: aMessageNode receiver), aMessageNode arguments) do: [:stmt |		(stmt isMemberOf: MessageNode) ifTrue: [			self getPlayersMessage: stmt for: obj into: aCollection.		].		(stmt isMemberOf: BlockNode) ifTrue: [			self getPlayersBlock: stmt for: obj into: aCollection..		].		(stmt isMemberOf: VariableNode) ifTrue: [			thisPlayer := Compiler evaluate: stmt name for: obj logged: false.			(thisPlayer isKindOf: Player) ifTrue: [aCollection add: stmt].		].	].! !!KedamaVectorizer methodsFor: 'player and selector look up' stamp: 'yo 2/14/2005 15:34'!getSelectorFor: receiver fromMessageNode: aMessageNode for: obj ifFoundDo: aBlock ignoreSelectors: ignoreSelectors	| thisPlayer key |	root ifNotNil: [^ self].	(Array with: aMessageNode receiver), aMessageNode arguments do: [:stmt |		(stmt isMemberOf: VariableNode) ifTrue: [			thisPlayer := Compiler evaluate: stmt name for: obj logged: false.			thisPlayer == receiver ifTrue: [				key :=  aMessageNode selector key.				(ignoreSelectors includes: key) ifFalse: [aBlock value: key. ^ self]].		].		(stmt isMemberOf: MessageNode) ifTrue: [			self getSelectorFor: receiver fromMessageNode: stmt for: obj ifFoundDo: aBlock ignoreSelectors: ignoreSelectors		].		(stmt isMemberOf: BlockNode) ifTrue: [			self getSelectorFor: receiver fromBlockNode: stmt for: obj ifFoundDo: aBlock ignoreSelectors: ignoreSelectors		].	].! !!KedamaVectorizer methodsFor: 'player and selector look up' stamp: 'yo 2/14/2005 15:25'!getSelectorRootFor: receiver fromMessageNode: aMessageNode for: obj ignoreSelectors: ignoreSelectors	| val |	root := nil.	self getSelectorFor: receiver fromMessageNode: aMessageNode for: obj ifFoundDo: [:sel | root := sel] ignoreSelectors: ignoreSelectors.	val := root.	root := nil.	^ val.! !!KedamaVectorizer methodsFor: 'entry point' stamp: 'yo 10/8/2004 05:33'!includesTurtlePlayer: aMethodNode for: obj	| players p |	players := self getAllPlayersInMethodNode: aMethodNode for: obj.	players do: [:e |		p := Compiler evaluate: e name for: obj logged: false.		(p isKindOf: KedamaExamplerPlayer) ifTrue: [^ true].	].	^ false.! !!KedamaVectorizer methodsFor: 'initialization' stamp: 'yo 8/28/2004 00:47'!initialize	attributes := KedamaAttributeDictionary new initialize.! !!KedamaVectorizer methodsFor: 'insert block node' stamp: 'yo 9/18/2004 12:08'!insertTurtleCommandAt: index in: statements variableNode: varNode from: encoder firstReceiverName: origName	| messageNode blockNode newMessageNode selector |	messageNode := statements at: index.	(attributes getAttribute: #requireVector of: messageNode) ifFalse: [^ self].	blockNode := BlockNode new arguments: (Array with: varNode) statements: (Array with: messageNode) returns: false from: encoder.	selector := (attributes getAttribute: #dieMessage of: messageNode) ifNotNil: [#doDieCommand:].	selector ifNil: [		selector := (attributes getAttribute: #constant of: messageNode) ifTrue: [#doCommand:] ifFalse: [#doSequentialCommand:].	].			newMessageNode := MessageNode new				receiver: (encoder encodeVariable: origName)				selector: selector				arguments: (Array with: blockNode)				precedence: 3				from: encoder				sourceRange: nil.	statements at: index put: newMessageNode.! !!KedamaVectorizer methodsFor: 'replace receiver' stamp: 'yo 10/9/2004 15:56'!replace: varName with: newNode inMessageNode: aMessageNode	| receiver att |	aMessageNode arguments withIndexDo: [:e :index |		(e isMemberOf: MessageNode) ifTrue: [			self replace: varName with: newNode inMessageNode: e.		].		(e isMemberOf: BlockNode) ifTrue: [			self replace: varName with: newNode inBlockNode: e.		].		(e isMemberOf: VariableNode) ifTrue: [			att := attributes getAttribute: #isTurtle of: e.			((att notNil & att) and: [e name = varName]) ifTrue: [aMessageNode arguments at: index put: newNode].		].	].	receiver := aMessageNode receiver.	(receiver isMemberOf: MessageNode) ifTrue: [		self replace: varName with: newNode inMessageNode: receiver.	].	(receiver isMemberOf: VariableNode) ifTrue: [		att := attributes getAttribute: #isTurtle of: receiver.		((att notNil & att) and: [receiver name = varName]) ifTrue: [aMessageNode receiver: newNode].	].! !!KedamaVectorizer methodsFor: 'vectorization attribute calculation' stamp: 'yo 9/17/2004 11:20'!traverseBlock: aBlockNode in: obj firstPlayer: firstPlayer inCondition: inCondition	| value statements |	statements := aBlockNode statements.	statements do: [:stmt |		(stmt isMemberOf: MessageNode)	ifTrue: [			self traverseMessage: stmt in: obj firstPlayer: firstPlayer inCondition: inCondition.		].		(stmt isMemberOf: BlockNode) ifTrue: [			self traverseBlock: stmt in: obj firstPlayer: firstPlayer inCondition: inCondition.		].		(stmt isMemberOf: VariableNode) ifTrue: [			attributes setAttribute: #constant of: stmt to: false		].		(stmt isMemberOf: LiteralNode) ifTrue: [			attributes setAttribute: #constant of: stmt to: true		].	].	value := statements collect: [:stmt | attributes getAttribute: #constant of: stmt].	value := value inject: true into: [:s :t | s & t].	attributes setAttribute: #constant of: aBlockNode to: value.! !!KedamaVectorizer methodsFor: 'vectorization attribute calculation' stamp: 'yo 9/24/2004 09:20'!traverseMessageRoot: aMessageNode in: obj firstPlayer: firstPlayer	| inCondition |	inCondition := #(ifTrue: ifFalse: ifTrue:ifFalse:) includes: aMessageNode selector key.	root := aMessageNode.	self traverseMessage: aMessageNode in: obj firstPlayer: firstPlayer inCondition: inCondition.! !!KedamaVectorizer methodsFor: 'vectorization attribute calculation' stamp: 'yo 3/7/2005 08:36'!traverseMessage: aMessageNode in: obj firstPlayer: firstPlayer inCondition: inCondition	| receiver thisPlayer ret constant proto |	aMessageNode arguments do: [:argument |		(argument isMemberOf: MessageNode) ifTrue: [			self traverseMessage: argument in: obj firstPlayer: firstPlayer inCondition: inCondition.		].		(argument isMemberOf: BlockNode) ifTrue: [			self traverseBlock: argument in: obj firstPlayer: firstPlayer inCondition: inCondition.		].		(argument isMemberOf: LiteralNode) ifTrue: [			attributes setAttribute: #constant of: argument to: true.		].		(argument isMemberOf: VariableNode) ifTrue: [			thisPlayer := Compiler evaluate: argument name for: obj logged: false.			ret := (thisPlayer isKindOf: Player) and: [thisPlayer costume renderedMorph isKindOf: KedamaPatchMorph].			attributes setAttribute: #constant of: argument to: ret.		].	].	receiver := aMessageNode receiver.	(receiver isMemberOf: MessageNode) ifTrue: [		self traverseMessage: receiver in: obj firstPlayer: firstPlayer inCondition: inCondition.	].	(receiver isMemberOf: BlockNode) ifTrue: [		self traverseBlock: receiver in: obj firstPlayer: firstPlayer inCondition: inCondition.	].	(receiver isMemberOf: LiteralNode) ifTrue: [		attributes setAttribute: #constant of: receiver to: true.	].	(receiver isMemberOf: VariableNode) ifTrue: [		thisPlayer := Compiler evaluate: receiver name for: obj logged: false.		ret := thisPlayer == firstPlayer.		attributes setAttribute: #constant of: receiver to: ret.		proto := (thisPlayer isKindOf: Player) and: [thisPlayer isPrototypeTurtlePlayer].		attributes setAttribute: #isTurtle of: receiver to: proto.		attributes setAttribute: #scalar of: aMessageNode selector to:		(ret not and: [(proto and: [self isScalarizable: thisPlayer andSelector: aMessageNode selector key])]).	].	"special cases..."	(#(atRandom die getReplicated bounceOn: bounceOn:color: bounceOnColor: ifTrue: ifFalse: ifTrue:ifFalse: itFalse:ifTrue:	setPatchValueIn:to: getTurtleAt: getTurtleOf:) includes: aMessageNode selector key) ifTrue: [		attributes setAttribute: #constant of: aMessageNode to: false.		aMessageNode selector key = #die ifTrue: [			attributes setAttribute: #dieMessage of: root to: true.		].	] ifFalse: [		constant := (aMessageNode arguments copyWith: receiver) inject: true into: [:s :t | s := s and: [attributes getAttribute: #constant of: t]].		attributes setAttribute: #constant of: aMessageNode to: constant.	].! !!KedamaWhoSearchingViewer methodsFor: 'initialization' stamp: 'yo 4/4/2005 14:33'!addNamePaneTo: header	"Add the namePane, which may be a popup or a type-in depending on the type of CategoryViewer"	| plugTextMor searchButton |	namePane := AlignmentMorph newRow vResizing: #spaceFill; height: 14.	namePane hResizing: #spaceFill.	namePane listDirection: #leftToRight.	plugTextMor := PluggableTextMorph on: self					text: #searchString accept: #searchString:notifying:					readSelection: nil menu: nil.	plugTextMor setProperty: #alwaysAccept toValue: true.	plugTextMor askBeforeDiscardingEdits: false.	plugTextMor acceptOnCR: true.	plugTextMor setTextColor: Color brown.	plugTextMor setNameTo: 'Turtle' translated.	plugTextMor vResizing: #spaceFill; hResizing: #spaceFill.	plugTextMor hideScrollBarsIndefinitely.	plugTextMor setTextMorphToSelectAllOnMouseEnter.	searchButton := SimpleButtonMorph new 		target: self;		beTransparent;		label: 'Turtle' translated;		actionSelector: #doSearchFrom:;		arguments: {plugTextMor}.	searchButton setBalloonText: 'Type a number into the pane to specify the individual turtle.' translated.	namePane addMorphFront: searchButton.	namePane addTransparentSpacerOfSize: 6@0.	namePane addMorphBack: plugTextMor.	header addMorphBack: namePane! !!KedamaWhoSearchingViewer methodsFor: 'search' stamp: 'yo 4/4/2005 18:03'!doSearchFrom:  aSource interactive: isInteractive	"Perform the search operation.  If interactive is true, this actually happened because a search button was pressed; if false, it was triggered some other way for which an informer would be inappropriate."	| searchFor |	searchString := (aSource isKindOf: PluggableTextMorph)		ifFalse:			[aSource]		ifTrue:			[aSource text string].	searchFor := searchString asNumber asInteger.	(self outerViewer isMemberOf: KedamaStandardViewer) ifTrue: [		self outerViewer providePossibleRestrictedView: searchFor.		self updateWhoString.	].! !!KedamaWhoSearchingViewer methodsFor: 'search' stamp: 'yo 4/3/2005 09:16'!rawSearchString: aString	"Set the search string as indicated"	searchString := aString asString! !!KedamaWhoSearchingViewer methodsFor: 'search' stamp: 'yo 4/3/2005 09:16'!searchString	"Answer the search string"	^ searchString ifNil: [searchString := '']! !!KedamaWhoSearchingViewer methodsFor: 'search' stamp: 'yo 4/3/2005 09:16'!searchString: aString notifying: znak	"Set the search string as indicated and carry out a search"	searchString := aString asString.	self doSearchFrom: searchString! !!KeyedIdentitySet methodsFor: 'private' stamp: 'md 10/5/2005 15:43'!scanFor: anObject	"Same as super except change = to ==, and hash to identityHash"	| element start finish |	finish := array size.	start := (anObject identityHash \\ finish) + 1.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [(keyBlock value: element) == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [(keyBlock value: element) == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!KeyedSet methodsFor: 'accessing' stamp: 'ajh 10/6/2000 20:28'!at: key ifAbsent: aBlock 	"Answer the value associated with the key or, if key isn't found,	answer the result of evaluating aBlock."	| obj |	obj := array at: (self findElementOrNil: key).	obj ifNil: [^ aBlock value].	^ obj! !!KeyedSet methodsFor: 'accessing' stamp: 'ajh 9/5/2000 03:58'!at: key ifPresent: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| v |	v := self at: key ifAbsent: [^ nil].	^ aBlock value: v! !!KeyedSet methodsFor: 'accessing' stamp: 'ajh 7/3/2004 17:55'!keys	| keys |	keys := Set new.	self keysDo: [:key | keys add: key].	^ keys! !!KeyedSet methodsFor: 'accessing' stamp: 'ajh 5/11/2002 13:28'!keysSorted	| keys |	keys := SortedCollection new.	self do: [:item | keys add: (keyBlock value: item)].	^ keys! !!KeyedSet methodsFor: 'adding' stamp: 'md 3/14/2006 12:37'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject."	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self findElementOrNil: (keyBlock value: newObject).	(array at: index) ifNil: [self atNewIndex: index put: newObject].	^ newObject! !!KeyedSet methodsFor: 'adding' stamp: 'ajh 6/3/2002 10:11'!member: newObject	"Include newObject as one of the receiver's elements, if already exists just return it"	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self findElementOrNil: (keyBlock value: newObject).	(array at: index) ifNotNil: [^ array at: index].	self atNewIndex: index put: newObject.	^ newObject! !!KeyedSet methodsFor: 'copying' stamp: 'ajh 9/5/2000 03:56'!postCopyBlocks	keyBlock := keyBlock copy.	"Fix temps in case we're referring to outside stuff"	keyBlock fixTemps.! !!KeyedSet methodsFor: 'initialize' stamp: 'ajh 9/5/2000 03:36'!keyBlock: oneArgBlock	"When evaluated return the key of the argument which will be an element of the set"	keyBlock := oneArgBlock! !!KeyedSet methodsFor: 'removing' stamp: 'ajh 9/5/2000 03:47'!remove: oldObject ifAbsent: aBlock	| index |	index := self findElementOrNil: (keyBlock value: oldObject).	(array at: index) == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^ oldObject! !!KeyedSet methodsFor: 'removing' stamp: 'ajh 3/29/2001 19:03'!removeKey: key ifAbsent: aBlock	| index obj |	index := self findElementOrNil: key.	(obj := array at: index) == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^ obj! !!KeyedSet methodsFor: 'private' stamp: 'ajh 9/5/2000 03:44'!fixCollisionsFrom: index	"The element at index has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one"	| length oldIndex newIndex element |	oldIndex := index.	length := array size.	[oldIndex = length			ifTrue: [oldIndex :=  1]			ifFalse: [oldIndex :=  oldIndex + 1].	(element := self keyAt: oldIndex) == nil]		whileFalse: 			[newIndex := self findElementOrNil: (keyBlock value: element).			oldIndex = newIndex ifFalse: [self swap: oldIndex with: newIndex]]! !!KeyedSet methodsFor: 'private' stamp: 'nice 4/4/2006 22:09'!initialize: n	super initialize: n.	keyBlock := [:element | element key].! !!KeyedSet methodsFor: 'private' stamp: 'ajh 9/5/2000 03:46'!noCheckAdd: anObject	array at: (self findElementOrNil: (keyBlock value: anObject)) put: anObject.	tally := tally + 1! !!KeyedSet methodsFor: 'private' stamp: 'ajh 12/13/2001 00:17'!rehash	| newSelf |	newSelf := self species new: self size.	newSelf keyBlock: keyBlock.	self do: [:each | newSelf noCheckAdd: each].	array := newSelf array! !!KeyedSet methodsFor: 'private' stamp: 'md 10/5/2005 15:43'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [(keyBlock value: element) = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [(keyBlock value: element) = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!LangEnvBugs methodsFor: 'as yet unclassified' stamp: 'wiz 5/19/2008 14:17'!tearDownPreferences restoreDefaultFonts! !!LangEnvBugs methodsFor: 'as yet unclassified' stamp: 'wiz 10/27/2006 00:56'!testIsFontAvailable"self new testIsFontAvailable""self run: #testIsFontAvailable"| oldPref |oldPref := Preferences valueOfPreference: #tinyDisplay .Preferences enable: #tinyDisplay .self shouldnt: [ [ ( LanguageEnvironment localeID: 'en' ) isFontAvailable ] 					ensure: [Preferences setPreference: #tinyDisplay toValue: oldPref] ] 	raise: Error.^true! !!LanguageEnvironment methodsFor: 'fonts support' stamp: 'wiz 9/8/2007 00:19'!isFontAvailable	| encoding f |	encoding := self leadingChar + 1.	f _ TextStyle defaultFont.	f isFontSet ifTrue: [		f fontArray			at: encoding			ifAbsent: [^ false].		^ true	].	encoding = 1 ifTrue: [^ true].	f fallbackFont isFontSet ifFalse: [^false].	f fallbackFont fontArray		at: encoding		ifAbsent: [^ false].	^ true! !!LanguageEnvironment commentStamp: '<historical>' prior: 0!The name multilingualized Squeak suggests that you can use multiple language at one time.  This is true, of course, but the system still how to manage the primary language; that provides the interpretation of data going out or coming in from outside world. It also provides how to render strings, as there rendering rule could be different in one language to another, even if the code points in a string is the same.  Originally, LanguageEnvironment and its subclasses only has class side methods.  After merged with Diego's Babel work, it now has instance side methods.  Since this historical reason, the class side and instance side are not related well.  When we talk about the interface with the outside of the Squeak world, there are three different "channels"; the keyboard input, clipboard output and input, and filename.  On a not-to-uncommon system such as a Unix system localized to Japan, all of these three can have (and does have) different encodings.  S   o       w   e       n   e   e   d       t   o       m   a   n   a   g   e       t   h   e   m       s   e   p   a   r   a   t   e   l   y   .           N   o   t   e       t   h   a   t       t   h   e       e   n   c   o   d   i   n   g       i   n       a       f   i   l   e       c   a   n       b   e       a   n   y   t   h   i   n   g   .           W   h   i   l   e       i   t       i   s       n   i   c   e       t   o       p   r   o   v   i   d   e       a       s   u   g   g   e   s   t   e   d       g   u   e   s   s       f   o   r       t   h   i   s       '   d   e   f   a   u   l   t       s   y   s   t   e   m       f   i   l   e       c   o   n   t   e   n   t       e   n   c   o   d   i   n   g   '   ,       i   t       i   s       n   o   t       c   r   i   t   i   c   a   l   .                 R   e   n   d   e   r   i   n   g       s   u   p   p   o   r   t       i   s       l   i   m   i   t   e   d       b   a   s   i   c       L   -   t   o   -   R       r   e   n   d   e   r   i   n   g       s   o       f   a   r   .           B   u   t       y   o   u       c   a   n       p   r   o   v   i   d   e       d   i   f   f   e   r   e   n   t       l   i   n   e   -   w   r   a   p       r   u   l   e   ,       a   t       l   e   a   s   t   .      !!LanguageEnvironment class methodsFor: 'public query' stamp: 'ar 6/3/2007 18:48'!defaultClipboardInterpreter	SmalltalkImage current platformName = 'Win32' ifTrue:[^UTF8ClipboardInterpreter new].	ClipboardInterpreterClass ifNil: [ClipboardInterpreterClass := self currentPlatform class clipboardInterpreterClass].	^ ClipboardInterpreterClass new.! !!LanguageEnvironment class methodsFor: 'public query' stamp: 'ar 6/3/2007 18:49'!defaultFileNameConverter	SmalltalkImage current  platformName = 'Win32' ifTrue:[^UTF8TextConverter new].	FileNameConverterClass		ifNil: [FileNameConverterClass := self currentPlatform class fileNameConverterClass].	^ FileNameConverterClass new! !!Lexicon methodsFor: '*eToys-tiles' stamp: 'nb 6/17/2003 12:25'!acceptTiles	| pp pq methodNode cls sel |	"In complete violation of all the rules of pluggable panes, search dependents for my tiles, and tell them to accept."	pp := self dependents detect: [:pane | pane isKindOf: PluggableTileScriptorMorph] 			ifNone: [^ Beeper beep].	pq := pp findA: TransformMorph.	methodNode := pq findA: SyntaxMorph.	cls := methodNode parsedInClass.	sel := cls compile: methodNode decompile classified: self selectedCategoryName			notifying: nil.	self noteAcceptanceOfCodeFor: sel.	self reformulateListNoting: sel.! !!Lexicon methodsFor: '*eToys-tiles' stamp: 'nk 4/28/2004 10:15'!installTilesForSelection	"Install universal tiles into the code pane."	| source aSelector aClass tree syn tileScriptor aWindow codePane |	(aWindow := self containingWindow)		ifNil: [self error: 'hamna dirisha'].	aSelector := self selectedMessageName.	aClass := self selectedClassOrMetaClass				ifNil: [targetClass].	aClass		ifNotNil: [aSelector				ifNil: [source := SyntaxMorph sourceCodeTemplate]				ifNotNil: [aClass := self selectedClassOrMetaClass whichClassIncludesSelector: aSelector.					source := aClass sourceCodeAt: aSelector].			tree := Compiler new						parse: source						in: aClass						notifying: nil.			(syn := tree asMorphicSyntaxUsing: SyntaxMorph) parsedInClass: aClass.			tileScriptor := syn inAPluggableScrollPane].	codePane := aWindow				findDeepSubmorphThat: [:m | (m isKindOf: PluggableTextMorph)						and: [m getTextSelector == #contents]]				ifAbsent: [].	codePane		ifNotNil: [codePane hideScrollBars].	codePane		ifNil: [codePane := aWindow						findDeepSubmorphThat: [:m | m isKindOf: PluggableTileScriptorMorph]						ifAbsent: [self error: 'no code pane']].	tileScriptor color: aWindow paneColorToUse;		 setProperty: #hideUnneededScrollbars toValue: true.	aWindow replacePane: codePane with: tileScriptor.	currentCompiledMethod := aClass				ifNotNil: [aClass						compiledMethodAt: aSelector						ifAbsent: []].	tileScriptor owner clipSubmorphs: true.	tileScriptor extent: codePane extent! !!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'BG 3/13/2004 13:18'!nextPutAll: aCollection	| newEnd |	collection class == aCollection class ifFalse:		[^ super nextPutAll: aCollection ].	newEnd := position + aCollection size.	newEnd > limit ifTrue: [		super nextPutAll: (aCollection copyFrom: 1 to: (limit - position max: 0)).		^ limitBlock value.	].	newEnd > writeLimit ifTrue: [		self growTo: newEnd + 10	].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.	position := newEnd.! !!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'di 6/20/97 09:07'!setLimit: sizeLimit limitBlock: aBlock	"Limit the numer of elements this stream will write..."	limit := sizeLimit.	"Execute this (typically ^ contents) when that limit is exceded"	limitBlock := aBlock! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 19:16'!limitingBlock: aBlock	"The limitingBlock is evaluated with a line to check if this line terminates the stream"	limitingBlock := aBlock fixTemps.	self updatePosition! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 2/19/1999 11:45'!linesUpToEnd	| elements ln |	elements := OrderedCollection new.	[(ln := self nextLine) isNil] whileFalse: [ 		elements add: ln].	^elements! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 14:37'!next	"Provide character-based access"	position isNil ifTrue: [^nil].	position < line size ifTrue: [^line at: (position := position + 1)].	line := stream nextLine.	self updatePosition.	^ Character cr! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 14:09'!nextLine	| thisLine |	self atEnd ifTrue: [^nil].	thisLine := line.	line := stream nextLine.	^thisLine! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 16:53'!skipThisLine	line := stream nextLine.	self updatePosition.! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 2/19/1999 11:47'!upToEnd	| ln |	^String streamContents: [:strm |		[(ln := self nextLine) isNil] whileFalse: [ 			strm nextPutAll: ln; cr]]! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 14:37'!updatePosition	"Call this before doing character-based access"	position := self atEnd ifFalse: [0]! !!LimitingLineStreamWrapper methodsFor: 'private' stamp: 'bf 11/24/1998 14:30'!setStream: aStream delimiter: aString	stream := aStream.	line := stream nextLine.	self delimiter: aString.	"sets position"! !!LimitingLineStreamWrapper class methodsFor: 'examples' stamp: 'bf 2/19/1999 11:48'!example1	"LimitingLineStreamWrapper example1"	"Separate chunks of text delimited by a special string"	| inStream msgStream messages |	inStream := self exampleStream.	msgStream := LimitingLineStreamWrapper on: inStream delimiter: 'From '.	messages := OrderedCollection new.	[inStream atEnd] whileFalse: [		msgStream skipThisLine.		messages add: msgStream upToEnd].	^messages			! !!LimitingLineStreamWrapper class methodsFor: 'examples' stamp: 'bf 2/19/1999 12:46'!example2	"LimitingLineStreamWrapper example2"	"Demo nesting wrappers - get header lines from some messages"	| inStream msgStream headers headerStream |	inStream := self exampleStream.	msgStream := LimitingLineStreamWrapper on: inStream delimiter: 'From '.	headers := OrderedCollection new.	[inStream atEnd] whileFalse: [		msgStream skipThisLine. "Skip From"		headerStream := LimitingLineStreamWrapper on: msgStream delimiter: ''.		headers add: headerStream linesUpToEnd.		[msgStream nextLine isNil] whileFalse. "Skip Body"	].	^headers			! !!Line methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	| newPath newLine |	newPath := aTransformation applyTo: self.	newLine := Line new.	newLine beginPoint: newPath firstPoint.	newLine endPoint: newPath secondPoint.	newLine form: self form.	newLine		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Line class methodsFor: 'examples'!example	"Designate two places on the screen by clicking any mouse button. A	straight path with a square black form will be displayed connecting the	two selected points."	| aLine aForm |  	aForm := Form extent: 20@20.		"make a form one quarter of inch square"	aForm fillBlack.							"turn it black"	aLine := Line new.	aLine form: aForm.						"use the black form for display"	aLine beginPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aLine beginPoint.		aLine endPoint: Sensor waitButton.	aLine displayOn: Display.				"display the line"	"Line example"! !!Line class methodsFor: 'instance creation'!from: beginPoint to: endPoint withForm: aForm 	"Answer an instance of me with end points begingPoint and endPoint; 	the source form for displaying the line is aForm."	| newSelf | 	newSelf := super new: 2.	newSelf add: beginPoint.	newSelf add: endPoint.	newSelf form: aForm.	^newSelf! !!Line class methodsFor: 'instance creation'!new	| newSelf | 	newSelf := super new: 2.	newSelf add: 0@0.	newSelf add: 0@0.	^newSelf! !!LinearFit methodsFor: 'displaying' stamp: 'jrm 9/7/1999 22:16'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anIntegerfillColor: aForm 	| line |	line := Line new.	line form: self form.	1 to: self size - 1 do: 		[:i | 		line beginPoint: (self at: i).		line endPoint: (self at: i + 1).		line displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!LinearFit methodsFor: 'displaying' stamp: 'jrm 9/7/1999 23:00'!displayOn: aDisplayMedium transformation: aTransformation clippingBox:clipRect rule: anInteger fillColor: aForm 	| transformedPath |	"get the scaled and translated Path."	transformedPath := aTransformation applyTo: self.	transformedPath		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!LinearFit class methodsFor: 'examples'!example	"Select points on a Path using the red button. Terminate by selecting	any other button. Creates a Path from the points and displays it as a	piece-wise linear approximation." 	| aLinearFit aForm flag |	aLinearFit := LinearFit new.	aForm := Form extent: 1 @ 40.	aForm  fillBlack.	aLinearFit form: aForm.	flag := true.	[flag] whileTrue:		[Sensor waitButton.		 Sensor redButtonPressed			ifTrue: [aLinearFit add: Sensor waitButton. Sensor waitNoButton.					aForm displayOn: Display at: aLinearFit last]			ifFalse: [flag:=false]].	aLinearFit displayOn: Display	"LinearFit example"! !!LinedTTCFont class methodsFor: 'as yet unclassified' stamp: 'ar 11/14/2006 15:18'!fromTTCFont: aTTCFont emphasis: code	| inst |	inst := self new.	inst ttcDescription: aTTCFont ttcDescription.	inst pointSize: aTTCFont pointSize.	inst emphasis: (aTTCFont emphasis bitOr: code).	inst lineGlyph: (aTTCFont ttcDescription at: $_).	^ inst.! !!Link methodsFor: 'accessing'!nextLink: aLink 	"Store the argument, aLink, as the link to which the receiver refers. 	Answer aLink."	^nextLink := aLink! !!LinkedList methodsFor: 'accessing' stamp: 'ajh 8/6/2002 15:46'!at: index	| i |	i := 0.	self do: [:link |		(i := i + 1) = index ifTrue: [^ link]].	^ self errorSubscriptBounds: index! !!LinkedList methodsFor: 'adding' stamp: 'ajh 8/22/2002 14:17'!add: link before: otherLink	| aLink |	firstLink == otherLink ifTrue: [^ self addFirst: link].	aLink := firstLink.	[aLink == nil] whileFalse: [		aLink nextLink == otherLink ifTrue: [			link nextLink: aLink nextLink.			aLink nextLink: link.			^ link		].		 aLink := aLink nextLink.	].	^ self errorNotFound: otherLink! !!LinkedList methodsFor: 'adding'!addFirst: aLink 	"Add aLink to the beginning of the receiver's list. Answer aLink."	self isEmpty ifTrue: [lastLink := aLink].	aLink nextLink: firstLink.	firstLink := aLink.	^aLink! !!LinkedList methodsFor: 'adding'!addLast: aLink 	"Add aLink to the end of the receiver's list. Answer aLink."	self isEmpty		ifTrue: [firstLink := aLink]		ifFalse: [lastLink nextLink: aLink].	lastLink := aLink.	^aLink! !!LinkedList methodsFor: 'enumerating'!do: aBlock	| aLink |	aLink := firstLink.	[aLink == nil] whileFalse:		[aBlock value: aLink.		 aLink := aLink nextLink]! !!LinkedList methodsFor: 'removing'!remove: aLink ifAbsent: aBlock  	"Remove aLink from the receiver. If it is not there, answer the result of	evaluating aBlock."	| tempLink |	aLink == firstLink		ifTrue: [firstLink := aLink nextLink.				aLink == lastLink					ifTrue: [lastLink := nil]]		ifFalse: [tempLink := firstLink.				[tempLink == nil ifTrue: [^aBlock value].				 tempLink nextLink == aLink]					whileFalse: [tempLink := tempLink nextLink].				tempLink nextLink: aLink nextLink.				aLink == lastLink					ifTrue: [lastLink := tempLink]].	aLink nextLink: nil.	^aLink! !!LinkedList methodsFor: 'removing'!removeFirst	"Remove the first element and answer it. If the receiver is empty, create 	an error notification."	| oldLink |	self emptyCheck.	oldLink := firstLink.	firstLink == lastLink		ifTrue: [firstLink := nil. lastLink := nil]		ifFalse: [firstLink := oldLink nextLink].	oldLink nextLink: nil.	^oldLink! !!LinkedList methodsFor: 'removing'!removeLast	"Remove the receiver's last element and answer it. If the receiver is 	empty, create an error notification."	| oldLink aLink |	self emptyCheck.	oldLink := lastLink.	firstLink == lastLink		ifTrue: [firstLink := nil. lastLink := nil]		ifFalse: [aLink := firstLink.				[aLink nextLink == oldLink] whileFalse:					[aLink := aLink nextLink].				 aLink nextLink: nil.				 lastLink := aLink].	oldLink nextLink: nil.	^oldLink! !!ListController methodsFor: 'marker adjustment'!computeMarkerRegion 	"Refer to the comment in ScrollController|computeMarkerRegion."	| viewList |	viewList := view list.	viewList compositionRectangle height = 0		ifTrue: [^ 0@0 extent: Preferences scrollBarWidth@scrollBar inside height].	^ 0@0 extent: Preferences scrollBarWidth@			((viewList clippingRectangle height asFloat /						viewList compositionRectangle height *							scrollBar inside height)					rounded min: scrollBar inside height)! !!ListController methodsFor: 'marker adjustment'!markerDelta	| viewList |	viewList := view list.	viewList compositionRectangle height == 0 ifTrue: [		^ (marker top - scrollBar inside top) - scrollBar inside height	].	^ (marker top - scrollBar inside top) -		((viewList clippingRectangle top -				viewList compositionRectangle top) asFloat /			viewList compositionRectangle height asFloat *			scrollBar inside height asFloat) rounded! !!ListController methodsFor: 'menu messages' stamp: 'acg 9/18/1999 14:09'!processKeyboard	"Derived from a Martin Pammer submission, 02/98"     | keyEvent oldSelection nextSelection max min howMany |	sensor keyboardPressed ifFalse: [^ self].     keyEvent := sensor keyboard asciiValue.     oldSelection := view selection.     nextSelection := oldSelection.     max := view maximumSelection.     min := view minimumSelection.     howMany := view clippingBox height // view list lineGrid.     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection := 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection := max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection -howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany)min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[model okToChange			ifTrue:				[self changeModelSelection: nextSelection.				self moveMarker]]			! !!ListController methodsFor: 'scrolling'!scrollView: anInteger 	"Scroll the view and highlight the selection if it just came into view"	| wasClipped |	wasClipped := view isSelectionBoxClipped.	(view scrollBy: anInteger)		ifTrue: [view isSelectionBoxClipped ifFalse:					[wasClipped ifTrue:  "Selection came into view"						[view displaySelectionBox]].				^ true]		ifFalse: [^ false]! !!ListController methodsFor: 'scrolling'!viewDelta 	"Refer to the comment in ScrollController|viewDelta."	| viewList |	viewList := view list.	^(viewList clippingRectangle top -			viewList compositionRectangle top -			((marker top - scrollBar inside top) asFloat /				scrollBar inside height asFloat *				viewList compositionRectangle height asFloat))		roundTo: viewList lineGrid! !!ListController methodsFor: 'selecting' stamp: 'tk 4/1/98 10:33'!redButtonActivity	| noSelectionMovement oldSelection selection nextSelection pt scrollFlag firstTime |	noSelectionMovement := true.	scrollFlag := false.	oldSelection := view selection.	firstTime := true.	[sensor redButtonPressed | firstTime]		whileTrue: 			[selection := view findSelection: (pt := sensor cursorPoint).			firstTime := false.			selection == nil ifTrue:  "Maybe out of box - check for auto-scroll"					[pt y < view insetDisplayBox top ifTrue:						[self scrollView: view list lineGrid.						scrollFlag := true.						selection := view firstShown].					pt y > view insetDisplayBox bottom ifTrue:						[self scrollView: view list lineGrid negated.						scrollFlag := true.						selection := view lastShown]].			selection == nil ifFalse:					[view moveSelectionBox: (nextSelection := selection).					nextSelection ~= oldSelection						ifTrue: [noSelectionMovement := false]]].	nextSelection ~~ nil & (nextSelection = oldSelection			ifTrue: [noSelectionMovement]			ifFalse: [true]) ifTrue: [self changeModelSelection: nextSelection].	scrollFlag ifTrue: [self moveMarker]! !!ListParagraph methodsFor: 'composition'!composeAll	"No composition is necessary once the ListParagraph is created."		lastLine isNil ifTrue: [lastLine := 0].			"Because composeAll is called once in the process of creating the ListParagraph."	^compositionRectangle width! !!ListParagraph methodsFor: 'private'!trimLinesTo: lastLineInteger	"Since ListParagraphs are not designed to be changed, we can cut back the		lines field to lastLineInteger."	lastLine := lastLineInteger.	lines := lines copyFrom: 1 to: lastLine! !!ListParagraph methodsFor: 'private' stamp: 'di 7/13/97 16:56'!withArray: anArray 	"Modifies self to contain the list of strings in anArray"	| startOfLine endOfLine lineIndex aString |	lines := Array new: 20.	lastLine := 0.	startOfLine := 1.	endOfLine := 1.	lineIndex := 0.	anArray do: 		[:item | 		endOfLine := startOfLine + item size.		"this computation allows for a cr after each line..."												"...but later we will adjust for no cr after last line"		lineIndex := lineIndex + 1.		self lineAt: lineIndex put:			((TextLineInterval start: startOfLine stop: endOfLine				internalSpaces: 0 paddingWidth: 0)				lineHeight: textStyle lineGrid baseline: textStyle baseline).		startOfLine := endOfLine + 1].	endOfLine := endOfLine - 1.		"endOfLine is now the total size of the text"	self trimLinesTo: lineIndex.	aString := String new: endOfLine.	anArray with: lines do: 		[:item :interval | 		aString			replaceFrom: interval first			to: interval last - 1			with: item asString			startingAt: 1.		interval last <= endOfLine ifTrue: [aString at: interval last put: Character cr]].	lineIndex > 0 ifTrue: [(lines at: lineIndex) stop: endOfLine].	"adjust for no cr after last line"	self text: aString asText.	anArray with: lines do: 		[:item :interval |  item isText ifTrue:			[text replaceFrom: interval first to: interval last - 1 with: item]].	self updateCompositionHeight! !!ListParagraph class methodsFor: 'initialization' stamp: 'nk 9/1/2004 10:27'!initialize 	"ListParagraph initialize"	| aFont |	"Allow different line spacing for lists"	aFont := Preferences standardListFont.	ListStyle := TextStyle fontArray: { aFont }.	ListStyle gridForFont: 1 withLead: 1! !!ListView methodsFor: 'delimiters'!bottomDelimiter: aString 	"Set the string used to indicate the bottom of the list."	bottomDelimiter := aString! !!ListView methodsFor: 'delimiters'!noBottomDelimiter	"Set the string used to indicate the bottom of the list to be nothing."	bottomDelimiter := nil! !!ListView methodsFor: 'delimiters'!noTopDelimiter	"Set the string used to indicate the top of the list to be nothing."	topDelimiter := nil! !!ListView methodsFor: 'delimiters'!topDelimiter: aString 	"Set the string used to indicate the top of the list."	topDelimiter := aString! !!ListView methodsFor: 'displaying'!display 	"Refer to the comment in View.display."	(self isUnlocked and: [self clippingBox ~= list clippingRectangle])		ifTrue:  "Recompose the list if the window changed"			[selection isNil ifTrue: [selection := 0].			self positionList].	super display! !!ListView methodsFor: 'displaying'!scrollBy: anInteger 	"Scroll up by this amount adjusted by lineSpacing and list limits"	| maximumAmount minimumAmount amount wasClipped |	maximumAmount := 0 max:		list clippingRectangle top - list compositionRectangle top.	minimumAmount := 0 min:		list clippingRectangle bottom - list compositionRectangle bottom.	amount := (anInteger min: maximumAmount) max: minimumAmount.	amount ~= 0		ifTrue: [list scrollBy: amount negated.  ^ true]		ifFalse: [^ false]  "Return false if no scrolling took place"! !!ListView methodsFor: 'displaying'!scrollSelectionIntoView	"Selection is assumed to be on and clipped out of view.	Uses controller scrollView to keep selection right"	| delta |	(delta := self insetDisplayBox bottom - self selectionBox bottom) < 0		ifTrue: [^ self controller scrollView: delta - (list lineGrid-1)]. "up"	(delta := self insetDisplayBox top - self selectionBox top) > 0		ifTrue: [^ self controller scrollView: delta + 1] "down"! !!ListView methodsFor: 'font access' stamp: 'jm 9/20/1998 19:44'!font: aFontOrNil	aFontOrNil		ifNil: [textStyle := nil]		ifNotNil: [			textStyle := TextStyle fontArray: (Array with: aFontOrNil).			textStyle gridForFont: 1 withLead: 1].	self changed: #list.  "update display"! !!ListView methodsFor: 'initialize-release'!initialize 	"Refer to the comment in View|initialize."	super initialize.	topDelimiter := '------------'.	bottomDelimiter := '------------'.	isEmpty := true.	self list: Array new! !!ListView methodsFor: 'list access' stamp: 'sw 12/10/1999 10:43'!assuredTextStyle	^ textStyle ifNil:		[textStyle :=  ListParagraph standardListStyle]! !!ListView methodsFor: 'list access' stamp: 'sw 12/9/1999 18:06'!list: anArray 	"Set the list of items the receiver displays to be anArray."	| arrayCopy i |	isEmpty := anArray isEmpty.	arrayCopy := Array new: (anArray size + 2).	arrayCopy at: 1 put: topDelimiter.	arrayCopy at: arrayCopy size put: bottomDelimiter.	i := 2.	anArray do: [:el | arrayCopy at: i put: el. i := i+1].	arrayCopy := arrayCopy copyWithout: nil.	list := ListParagraph withArray: arrayCopy style: self assuredTextStyle.	selection := 0.	self positionList.! !!ListView methodsFor: 'list access'!reset	"Set the list of items displayed to be empty."	isEmpty := true.	self list: Array new! !!ListView methodsFor: 'list access'!selection: selIndex	selection := selIndex! !!ListView methodsFor: 'selecting'!findSelection: aPoint 	"Determine which selection is displayed in an area containing the point, 	aPoint. Answer the selection if one contains the point, answer nil 	otherwise."	| trialSelection |	(self clippingBox containsPoint: aPoint) ifFalse: [^nil].	trialSelection := aPoint y - list compositionRectangle top // list lineGrid + 1.	topDelimiter == nil ifFalse: [trialSelection := trialSelection - 1].	(trialSelection < 1) | (trialSelection > self maximumSelection)		ifTrue: [^ nil]		ifFalse: [^ trialSelection]! !!ListView methodsFor: 'selecting'!moveSelectionBox: anInteger 	"Presumably the selection has changed to be anInteger. Deselect the 	previous selection and display the new one, highlighted."	selection ~= anInteger		ifTrue: 			[self deselect.			selection := anInteger.			self displaySelectionBox].	self isSelectionBoxClipped		ifTrue: [self scrollSelectionIntoView]! !!ListView methodsFor: 'private'!firstShown	"Return the index of the top item currently visible"	| trial |	trial := self findSelection: self insetDisplayBox topLeft.	^ trial == nil		ifTrue: [1]		ifFalse: [trial]! !!ListView methodsFor: 'private'!lastShown	"Return the index of the bottom item currently visible"	| trial bottomMargin |	bottomMargin := self insetDisplayBox height \\ list lineGrid.	trial := self findSelection: self insetDisplayBox bottomLeft - (0@bottomMargin).	trial == nil		ifTrue: [trial := self findSelection: self insetDisplayBox bottomLeft					- (0@(list lineGrid+bottomMargin))].	^ trial == nil		ifTrue: [list numberOfLines - 2]		ifFalse: [trial]! !!ListView methodsFor: 'private'!wrappingBox	| aRectangle |	aRectangle := self insetDisplayBox. 	selection = 0		ifTrue: [^aRectangle topLeft + (4 @ 0) extent: list compositionRectangle extent]		ifFalse: [^aRectangle left + 4 @ 					(aRectangle top - 						(self selectionBoxOffset 							min: ((list height - aRectangle height 									+ list lineGrid truncateTo: list lineGrid)							max: 0))) 					extent: list compositionRectangle extent]! !!ListViewLine methodsFor: 'object represented' stamp: 'ar 11/1/2000 15:55'!objectRepresented: anObject	"Set the object represented by the receiver to be as requested"	objectRepresented := anObject.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self setNameTo: anObject name.	self removeAllMorphs.! !!LiteralNode methodsFor: '*eToys-tiles' stamp: 'tk 8/24/2001 15:43'!asMorphicSyntaxIn: parent	| row |	row := parent addRow: #literal on: self.	(key isVariableBinding) ifFalse: [		row layoutInset: 1.		^ row addMorphBack: (row addString: key storeString special: false)].	key key isNil ifTrue: [		^ row addTextRow: ('###',key value soleInstance name)	] ifFalse: [		^ row addTextRow: ('##', key key)	].	! !!LookupKey methodsFor: 'accessing'!key: anObject 	"Store the argument, anObject, as the lookup key of the receiver."	key := anObject! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:59'!beBindingOfType: aClass announcing: aBool	"Make the receiver a global binding of the given type"	| old new |	(Smalltalk associationAt: self key) == self		ifFalse:[^self error:'Not a global variable binding'].	self class == aClass ifTrue:[^self].	old := self.	new := aClass key: self key value: self value.	old become: new.	"NOTE: Now self == read-only (e.g., the new binding)"	^self recompileBindingsAnnouncing: aBool! !!MCDefinition methodsFor: 'installing' stamp: 'rej 2/26/2007 18:45'!addMethodAdditionTo: aCollection  Transcript show: self printString.  self load! !!MCFileRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'rej 2/21/2007 21:08'!refresh	| packageNames name latest av |	packageNames := Set new.	versions := repository readableFileNames collect: [ :each |		name := (each copyUpToLast: $.) copyUpTo: $(.		name last isDigit ifFalse: [Array with: name with: '' with: '' with: each]			ifTrue:				[Array					with: (packageNames add: (name copyUpToLast:  $-))		"pkg name"					with: ((name copyAfterLast: $-) copyUpTo: $.)				"user"					with: ((name copyAfterLast: $-) copyAfter: $.) asInteger	"version"					with: each]].	versions := versions select: [:each | (each at: 3) isNumber].	newer := Set new.	inherited := Set new.	loaded := Set new.	(MCWorkingCopy allManagers "		select: [ :each | packageNames includes: each packageName]")		do: [:each |			each ancestors do: [ :ancestor |				loaded add: ancestor name.				ancestor ancestorsDoWhileTrue: [:heir |					(inherited includes: heir name)						ifTrue: [false]						ifFalse: [inherited add: heir name. true]]].			latest := (versions select: [:v | v first = each package name])					detectMax: [:v | v third].			(latest notNil and: [				each ancestors allSatisfy: [:ancestor |					av := ((ancestor name copyAfterLast: $-) copyAfter: $.) asInteger.					av < latest third or: [						av = latest third and: [((ancestor name copyAfterLast: $-) copyUpTo: $.) ~= latest second]]]])				ifTrue: [newer add: each package name ]].	self changed: #packageList; changed: #versionList! !!MCMethodDefinition methodsFor: 'installing' stamp: 'rej 2/26/2007 10:42'!addMethodAdditionTo: aCollection	| methodAddition |	methodAddition := MethodAddition new		compile: source		classified: category		withStamp: timeStamp		notifying: (SyntaxError new category: category)		logSource: true		inClass: self actualClass.	"This might raise an exception and never return"	methodAddition createCompiledMethod.	aCollection add: methodAddition.! !!MCMethodDefinitionTest methodsFor: 'mocks' stamp: 'edc 3/8/2007 10:08'!override ^ 1! !!MCPackageLoader methodsFor: 'private' stamp: 'rej 2/26/2007 10:52'!basicLoad	errorDefinitions := OrderedCollection new.	[[additions do: [:ea | self tryToLoad: ea] displayingProgress: 'Loading...'.	removals do: [:ea | ea unload] displayingProgress: 'Cleaning up...'.	self shouldWarnAboutErrors ifTrue: [self warnAboutErrors].	errorDefinitions do: [:ea | ea addMethodAdditionTo: methodAdditions] displayingProgress: 'Reloading...'.	methodAdditions do: [:each | each installMethod].	methodAdditions do: [:each | each notifyObservers].	additions do: [:ea | ea postloadOver: (self obsoletionFor: ea)] displayingProgress: 'Initializing...']		on: InMidstOfFileinNotification 		do: [:n | n resume: true]]			ensure: [self flushChangesFile]! !!MCPackageLoader methodsFor: 'private' stamp: 'abc 2/26/2007 21:39'!initialize	additions := OrderedCollection new.	removals := OrderedCollection new.	obsoletions := Dictionary new.	methodAdditions := OrderedCollection new. ! !!MCPackageLoader methodsFor: 'private' stamp: 'rej 2/26/2007 10:41'!tryToLoad: aDefinition	[aDefinition addMethodAdditionTo: methodAdditions] on: Error do: [errorDefinitions add: aDefinition].! !!MCPackageLoader methodsFor: 'private' stamp: 'pk 10/17/2006 09:41'!useChangeSetNamed: baseName during: aBlock	"Use the named change set, or create one with the given name."	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := (ChangesOrganizer changeSetNamed: baseName) ifNil: [ ChangeSet new name: baseName ].	changeHolder newChanges: newChanges.	[aBlock value] ensure: [changeHolder newChanges: oldChanges].! !!MCPackageLoader commentStamp: 'rej 2/26/2007 07:35' prior: 0!A MCPackageLoader is responsible for loading packages.  It gets used by VersionLoader, so it is eventually responsible for loading everything.Instance Variables	additions:		<Definitions>  Definitions that need to be added	errorDefinitions:		<Object>	obsoletions:		<Object>	provisions:		<Object>	removals:		<Object>	requirements:		<Object>	unloadableDefinitions:		<Object>	methodAdditions  <MethodAdditions> MethodDefinitions corresponding to the Definitions in "additions" that have been added so far.additions	- xxxxxerrorDefinitions	- xxxxxobsoletions	- xxxxxprovisions	- xxxxxremovals	- xxxxxrequirements	- xxxxxunloadableDefinitions	- xxxxx!!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'klc 5/25/2008 20:20'!versionWithInfo: aVersionInfo	^self versionWithInfo: aVersionInfo ifNone: [ nil ]! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'md 7/23/2006 15:28'!methodWithStyle	^ '!!EventHandler methodsFor: ''copying'' stamp: ''tk 1/22/2001 17:39''!!veryDeepInner: deepCopier	"ALL fields are weakly copied.  Can''t duplicate an object by duplicating a button that activates it.  See DeepCopier."	super veryDeepInner: deepCopier.	"just keep old pointers to all fields"	clickRecipient := clickRecipient.!!]style[(25 108 10 111)f1b,f1,f1LDeepCopier Comment;,f1!! !!'! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'al 7/18/2006 15:49'!saveVersion	| repo |	self canSave ifFalse: [^self].	self checkForNewerVersions ifFalse: [^self].	repo := self repository.	workingCopy newVersion ifNotNilDo:		[:v |		(MCVersionInspector new version: v) show.		Cursor wait showWhile: [repo storeVersion: v].		MCCacheRepository default cacheAllFileNamesDuring: 			[repo cacheAllFileNamesDuring: 				[v allAvailableDependenciesDo:					[:dep |					(repo includesVersionNamed: dep info name)						ifFalse: [repo storeVersion: dep]]]]]! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:22'!testAddAction	"MVCToolBuilder does not implement #buildPluggableMenu:"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:22'!testAddTargetSelectorArgumentList	"MVCToolBuilder does not implement #buildPluggableMenu:"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:23'!testButtonFiresBlock	"MVC buttons only support action Symbols"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:23'!testButtonFiresMessage	"MVC buttons only support action Symbols, not MessageSends"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testButtonInitiallyDisabled	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testButtonInitiallyDisabledSelector	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testGetButtonColor	"MVC buttons do not have color"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testGetButtonEnabled	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:18'!testGetButtonSideEffectFree	"MVC button ask for their state on any change notification"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:19'!testGetInputFieldColor	"MVC input fields do not have color"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:20'!testGetPanelChildren	"MVC panels do not allow changing children"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetTextColor	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetWindowChildren	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetWindowLabel	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeExpandPath	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeExpandPathFirst	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeGetSelectionPath	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeRoots	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeWidgetID	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:25'!testWindowCloseAction	"This can only work if we're actually run in MVC"	World isNil ifTrue: [super testWindowCloseAction]! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/22/2002 12:41'!atColumn: column	|p|	p := (self indexForRow: 1 andColumn: column)-ncols.	^(1 to: nrows) collect: [:row | contents at: (p := p+ncols)]! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/28/2002 14:21'!atColumn: column put: aCollection	|p|	aCollection size = nrows ifFalse: [self error: 'wrong column size'].	p := (self indexForRow: 1 andColumn: column)-ncols.	aCollection do: [:each | contents at: (p := p+ncols) put: each].	^aCollection! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/22/2002 12:42'!atRow: row put: aCollection	|p|	aCollection size = ncols ifFalse: [self error: 'wrong row size'].	p := (self indexForRow: row andColumn: 1)-1.	aCollection do: [:each | contents at: (p := p+1) put: each].	^aCollection! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 10/23/2002 20:41'!diagonal	"Answer (1 to: (nrows min: ncols)) collect: [:i | self at: i at: i]"	|i|	i := ncols negated.	^(1 to: (nrows min: ncols)) collect: [:j | contents at: (i := i + ncols + 1)]! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/28/2002 14:21'!swapColumn: anIndex withColumn: anotherIndex	|a b|	a := self indexForRow: 1 andColumn: anIndex.	b := self indexForRow: 1 andColumn: anotherIndex.	nrows timesRepeat: [		contents swap: a with: b.		a := a + ncols.		b := b + ncols].! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/28/2002 14:22'!swapRow: anIndex withRow: anotherIndex	|a b|	a := self indexForRow: anIndex andColumn: 1.	b := self indexForRow: anotherIndex andColumn: 1.	ncols timesRepeat: [		contents swap: a with: b.		a := a + 1.		b := b + 1].! !!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 12:30'!atRows: r1 to: r2 columns: c1 to: c2	"Answer a submatrix [r1..r2][c1..c2] of the receiver."	|rd cd|	rd := r1 - 1.	cd := c1 - 1.	^self class rows: r2-rd columns: c2-cd tabulate: [:r :c| self at: r+rd at: c+cd]! !!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 13:05'!atRows: r1 to: r2 columns: c1 to: c2 ifInvalid: element	"Answer a submatrix [r1..r2][c1..c2] of the receiver.	 Portions of the result outside the bounds of the original matrix	 are filled in with element."	|rd cd|	rd := r1 - 1.	cd := c1 - 1.	^self class rows: r2-rd columns: c2-cd tabulate: [:r :c| self at: r+rd at: c+cd ifInvalid: element]! !!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 12:32'!atRows: r1 to: r2 columns: c1 to: c2 put: aMatrix	"Set the [r1..r2][c1..c2] submatrix of the receiver	 from the [1..r2-r1+1][1..c2-c1+1] submatrix of aMatrix.	 As long as aMatrix responds to at:at: and accepts arguments in the range shown,	 we don't care if it is bigger or even if it is a Matrix at all."	|rd cd|	rd := r1 - 1.	cd := c1 - 1.	r1 to: r2 do: [:r |		c1 to: c2 do: [:c |			self at: r at: c put: (aMatrix at: r-rd at: c-cd)]].	^aMatrix! !!Matrix methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:02'!preMultiplyByMatrix: m	"Answer m +* self where m is a Matrix."	|s|	nrows = m columnCount ifFalse: [self error: 'dimensions do not conform'].	^Matrix rows: m rowCount columns: ncols tabulate: [:row :col |		s := 0.		1 to: nrows do: [:k | s := (m at: row at: k) * (self at: k at: col) + s].		s]! !!Matrix methodsFor: 'copying' stamp: 'raok 11/22/2002 12:57'!, aMatrix	"Answer a new matrix having the same number of rows as the receiver and aMatrix,	 its columns being the columns of the receiver followed by the columns of aMatrix."	|newCont newCols anArray oldCols a b c|	self assert: [nrows = aMatrix rowCount].	newCont := Array new: self size + aMatrix size.	anArray := aMatrix privateContents.	oldCols := aMatrix columnCount.	newCols := ncols + oldCols.	a := b := c := 1.	1 to: nrows do: [:r |		newCont replaceFrom: a to: a+ncols-1 with: contents startingAt: b.		newCont replaceFrom: a+ncols to: a+newCols-1 with: anArray startingAt: c.		a := a + newCols.		b := b + ncols.		c := c + oldCols].	^self class rows: nrows columns: newCols contents: newCont		! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/23/2002 20:57'!indicesCollect: aBlock	|r i|	r := Array new: nrows * ncols.	i := 0.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			r at: (i := i+1) put: (aBlock value: row value: column)]].	^self class rows: nrows columns: ncols contents: r! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:51'!indicesInject: start into: aBlock	|current|	current := start.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			current := aBlock value: current value: row value: column]].	^current! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!withIndicesCollect: aBlock	|i r|	i := 0.	r := contents shallowCopy.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			i := i+1.			r at: i put: (aBlock value: (r at: i) value: row value: column)]].	^self class rows: nrows columns: ncols contents: r! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!withIndicesDo: aBlock	|i|	i := 0.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			aBlock value: (contents at: (i := i+1)) value: row value: column]].! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!withIndicesInject: start into: aBlock	|i current|	i := 0.	current := start.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			current := aBlock value: current value: (contents at: (i := i+1)) 							  value: row value: column]].	^current! !!Matrix methodsFor: 'private' stamp: 'raok 10/21/2002 22:47'!rowAndColumnForIndex: index	|t|	t := index - 1.	^(t // ncols + 1)@(t \\ ncols + 1)! !!Matrix methodsFor: 'private' stamp: 'raok 10/21/2002 23:05'!rows: rows columns: columns contents: anArray	self assert: [rows isInteger and: [rows >= 0]].	self assert: [columns isInteger and: [columns >= 0]].	self assert: [rows * columns = anArray size].	nrows := rows.	ncols := columns.	contents := anArray.	^self! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 00:09'!diagonal: aCollection	|r i|	r := self zeros: aCollection size.	i := 0.	aCollection do: [:each | i := i+1. r at: i at: i put: each].	^r! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/23/2002 20:59'!identity: n	|r|	r := self zeros: n.	1 to: n do: [:i | r at: i at: i put: 1].	^r! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 19:51'!rows: rows columns: columns tabulate: aBlock	"Answer a new Matrix of the given dimensions where	 result at: i at: j     is   aBlock value: i value: j"	|a i|	a := Array new: rows*columns.	i := 0.	1 to: rows do: [:row |		1 to: columns do: [:column |			a at: (i := i+1) put: (aBlock value: row value: column)]].	^self rows: rows columns: columns contents: a! !!MatrixTest methodsFor: 'testing' stamp: 'dc 3/3/2007 17:58'!setUp	matrix1 := Matrix new: 2.	matrix1 at:1 at:1 put: 1.	matrix1 at:1 at:2 put: 3.	matrix1 at:2 at:1 put: 2.	matrix1 at:2 at:2 put: 4.		matrix2 := Matrix new: 2.	matrix2 at:1 at:1 put: 3.	matrix2 at:1 at:2 put: 7.	matrix2 at:2 at:1 put: 4.	matrix2 at:2 at:2 put: 8.! !!MatrixTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:47'!testAtAt	self should:[matrix1 at: 2 at: 3] raise: Error.	self should:[matrix1 at: 3 at: 2] raise: Error.	self should:[matrix1 at: 3 at: 3] raise: Error.	self should:[matrix1 at: 0 at: 1] raise: Error.	self should:[matrix1 at: 1 at: 0] raise: Error.	self should:[matrix1 at: 0 at: 0] raise: Error.		self assert: (matrix1 at: 1 at: 1) = 1! !!MatrixTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:52'!testReplaceAll	matrix1 replaceAll: 1 with: 10.	self assert: (matrix1 at:1 at:1) = 10.	self assert: (matrix1 at:2 at:1) = 2.	self assert: (matrix1 at:1 at:2) = 3.	self assert: (matrix1 at:2 at:2) = 4.! !!MatrixTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:53'!testSwap	matrix1 swap: 1 at: 2 with: 1 at: 1.	self assert: (matrix1 at: 1 at: 1) = 3.	self assert: (matrix1 at: 1 at: 2) = 1.! !!MatrixTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:58'!testTransposed	| transposedMatrix |		transposedMatrix := matrix1 transposed.	self assert: [(transposedMatrix at:1 at:1) = 1].	self assert: [(transposedMatrix at:1 at:2) = 2].	self assert: [(transposedMatrix at:2 at:1) = 3].	self assert: [(transposedMatrix at:2 at:2) = 4].! !!MatrixTest methodsFor: 'tests - copying' stamp: 'dc 3/3/2007 17:48'!testCopy	| copyMatrix |		copyMatrix := matrix1 copy.	self assert: matrix1 = copyMatrix ! !!MatrixTest methodsFor: 'tests - testing' stamp: 'dc 3/3/2007 17:49'!testIncludes	self assert:			((1 to: 4)				allSatisfy: [:i | matrix1 includes: i])! !!MatrixTest methodsFor: 'tests - arithmetic' stamp: 'dc 3/3/2007 17:50'!testMultiply		| result |	self	should: [matrix1	preMultiplyByMatrix: (Matrix new: 3)]raise: Error.	result := matrix2 preMultiplyByMatrix: matrix1.	self assert: (result at: 1 at: 1) = 15.	self assert: (result at: 1 at: 2) = 31.	self assert: (result at: 2 at: 1) = 22.	self assert: (result at: 2 at: 2) = 46! !!MenuMorph methodsFor: 'construction' stamp: 'pf 11/15/2006 16:42'!addTitle: aString icon: aForm updatingSelector: aSelector updateTarget: aTarget 	"Add a title line at the top of this menu Make aString its initial  	contents.  	If aSelector is not nil, then periodically obtain fresh values for  	its  	contents by sending aSelector to aTarget.."	| title titleContainer |	title := AlignmentMorph newColumn.	self setTitleParametersFor: title.	""	aForm isNil		ifTrue: [titleContainer := title]		ifFalse: [| pair | 			pair := AlignmentMorph newRow.			pair color: Color transparent.			pair hResizing: #shrinkWrap.			pair layoutInset: 0.			""			pair addMorphBack: aForm asMorph.			""			titleContainer := AlignmentMorph newColumn.			titleContainer color: Color transparent.			titleContainer vResizing: #shrinkWrap.			titleContainer wrapCentering: #center.			titleContainer cellPositioning: #topCenter.			titleContainer layoutInset: 0.			pair addMorphBack: titleContainer.			""			title addMorphBack: pair].	""	aSelector		ifNil: [""			aString asString				linesDo: [:line | titleContainer						addMorphBack: (StringMorph contents: line font: Preferences standardMenuFont)]]		ifNotNil: [| usm | 			usm := UpdatingStringMorph on: aTarget selector: aSelector.			usm font: Preferences standardMenuFont.			usm useStringFormat.			usm lock.			titleContainer addMorphBack: usm].	""	title setProperty: #titleString toValue: aString.	self addMorphFront: title.	""	title useSquareCorners.	(self hasProperty: #needsTitlebarWidgets)		ifTrue: [self addStayUpIcons]! !!MenuTile methodsFor: 'arrows' stamp: 'sw 11/22/1999 11:54'!arrowAction: delta	| phrase aPlayer newItem |	(phrase := self ownerThatIsA: PhraseTileMorph) ifNil: [^ self].	aPlayer := phrase associatedPlayer.	newItem := delta > 0		ifTrue:			[aPlayer menuItemAfter: literal]		ifFalse:			[aPlayer menuItemBefore: literal].	self literal: newItem.	self layoutChanged! !!MenuTile methodsFor: 'event handling' stamp: 'sw 10/3/2002 21:16'!mouseDown: evt	| aPoint aMenu reply |	aPoint := evt cursorPoint.	nArrowTicks := 0.	((upArrow bounds containsPoint: aPoint) or: [downArrow bounds containsPoint: aPoint]) ifTrue: [^ self mouseStillDown: evt].	aMenu := SelectionMenu selections: (((self ownerThatIsA: PhraseTileMorph) associatedPlayer costume allMenuWordings) copyWithout: '').	reply := aMenu startUp.	reply ifNotNil: [self literal: reply; layoutChanged]! !!MessageSend methodsFor: '*eToys-tiles' stamp: 'tk 11/15/2000 15:19'!asTilesIn: playerClass	| code keywords num tree syn block phrase |	"Construct SyntaxMorph tiles for me."	"This is really cheating!!  Make a true parse tree later. -tk"	code := String streamContents: [:strm | 		strm nextPutAll: 'doIt'; cr; tab.		strm nextPutAll: (self stringFor: receiver).		keywords := selector keywords.		strm space; nextPutAll: keywords first.		(num := selector numArgs) > 0 ifTrue: [strm space. 					strm nextPutAll: (self stringFor: arguments first)].		2 to: num do: [:kk |			strm space; nextPutAll: (keywords at: kk).			strm space; nextPutAll: (self stringFor: (arguments at: kk))]].	"decompile to tiles"	tree := Compiler new 		parse: code 		in: playerClass		notifying: nil.	syn := tree asMorphicSyntaxUsing: SyntaxMorph.	block := syn submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == BlockNode] ifFalse: [false]].	phrase := block submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == MessageNode] ifFalse: [false]].	^ phrase! !!MessageSend methodsFor: '*eToys-tiles' stamp: 'tk 9/28/2001 13:41'!asTilesIn: playerClass globalNames: makeSelfGlobal	| code keywords num tree syn block phrase |	"Construct SyntaxMorph tiles for me.  If makeSelfGlobal is true, name the receiver and use that name, else use 'self'.  (Note that this smashes 'self' into the receiver, regardless of what it was.)"	"This is really cheating!!  Make a true parse tree later. -tk"	code := String streamContents: [:strm | 		strm nextPutAll: 'doIt'; cr; tab.		strm nextPutAll: 			(makeSelfGlobal ifTrue: [self stringFor: receiver] ifFalse: ['self']).		keywords := selector keywords.		strm space; nextPutAll: keywords first.		(num := selector numArgs) > 0 ifTrue: [strm space. 					strm nextPutAll: (self stringFor: arguments first)].		2 to: num do: [:kk |			strm space; nextPutAll: (keywords at: kk).			strm space; nextPutAll: (self stringFor: (arguments at: kk))]].	"decompile to tiles"	tree := Compiler new 		parse: code 		in: playerClass		notifying: nil.	syn := tree asMorphicSyntaxUsing: SyntaxMorph.	block := syn submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == BlockNode] ifFalse: [false]].	phrase := block submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == MessageNode] ifFalse: [false]].	^ phrase! !!MessageSend methodsFor: '*eToys-tiles' stamp: 'sw 6/20/2001 14:17'!stringFor: anObject	"Return a string suitable for compiling.  Literal or reference from global ref dictionary.  self is always named via the ref dictionary."	| generic aName |	anObject isLiteral ifTrue: [^ anObject printString].	anObject class == Color ifTrue: [^ anObject printString].	anObject class superclass == Boolean ifTrue: [^ anObject printString].	anObject class == BlockContext ifTrue: [^ '[''do nothing'']'].	"default block"		"Real blocks need to construct tiles in a different way"	anObject class isMeta ifTrue: ["a class" ^ anObject name].	generic := anObject knownName.	"may be nil or 'Ellipse' "	aName := anObject uniqueNameForReference.	generic ifNil:		[(anObject respondsTo: #renameTo:) 			ifTrue: [anObject renameTo: aName]			ifFalse: [aName := anObject storeString]].	"for Fraction, LargeInt, etc"	^ aName! !!MessageSet methodsFor: 'filtering' stamp: 'pk 10/17/2006 09:42'!filterToAnyChangeSet	"Filter down only to messages present in ANY change set"	self filterFrom:		[:aClass :aSelector |			ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector: aSelector]! !!MessageSet methodsFor: 'filtering' stamp: 'pk 10/17/2006 09:42'!filterToNotAnyChangeSet	"Filter down only to messages present in NO change set"	self filterFrom:		[:aClass :aSelector |			(ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector: aSelector) not]! !!MessageSet methodsFor: 'private' stamp: 'sd 11/20/2005 21:27'!initializeMessageList: anArray	"Initialize my messageList from the given list of MethodReference or string objects.  NB: special handling for uniclasses."	| s |	messageList := OrderedCollection new.	anArray do: [ :each |		MessageSet 			parse: each  			toClassAndSelector: [ :class :sel |				class ifNotNil:					[class isUniClass						ifTrue:							[s := class typicalInstanceName, ' ', sel]						ifFalse:							[s := class name , ' ' , sel , ' {' , 								((class organization categoryOfElement: sel) ifNil: ['']) , '}'].					messageList add: (						MethodReference new							setClass: class  							methodSymbol: sel 							stringVersion: s)]]].	messageListIndex := messageList isEmpty ifTrue: [0] ifFalse: [1].	contents := ''! !!Metaclass methodsFor: 'testing' stamp: 'wbk 7/26/2007 12:41'!isSelfEvaluating	^ true! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/26/2007 10:51'!compile    "This method is the how compiling a method used to work.  All these steps were done at once.     This method should not normally be used, because the whole point of MethodAddition is to let	you first create a compiled method and then install the method later."	self createCompiledMethod.	self installMethod.	self notifyObservers.	^selector! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/25/2007 20:36'!compile: aString classified: aString1 withStamp: aString2 notifying: aRequestor logSource: aBoolean inClass: aClass	text := aString.	category := aString1.	changeStamp := aString2.	requestor := aRequestor.	logSource := aBoolean.	myClass := aClass! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/26/2007 05:17'!createCompiledMethod	methodAndNode := myClass compile: text asString classified: category notifying: requestor							trailer: myClass defaultMethodTrailer ifFail: [^nil].	selector := methodAndNode selector.	compiledMethod := methodAndNode method.	self writeSourceToLog.	priorMethodOrNil := myClass compiledMethodAt: selector ifAbsent: [nil].! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/25/2007 22:09'!installMethod	myClass addSelectorSilently: selector withMethod: compiledMethod.! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/25/2007 22:12'!notifyObservers	SystemChangeNotifier uniqueInstance 		doSilently: [myClass organization classify: selector under: category].	priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: compiledMethod selector: selector inProtocol: category class: myClass requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil to: compiledMethod selector: selector inClass: myClass requestor: requestor].	"The following code doesn't seem to do anything."	myClass instanceSide noteCompilationOf: selector meta: myClass isClassSide.! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/25/2007 20:42'!writeSourceToLog	logSource ifTrue: [		myClass logMethodSource: text forMethodWithNode: methodAndNode 			inCategory: category withStamp: changeStamp notifying: requestor.	].! !!MethodAddition commentStamp: 'rej 2/25/2007 19:30' prior: 0!I represent the addition of a method to a class.  I can produce the CompiledMethod, install it, and then notify the system that the method has been added.  This allows Monticello to implement atomic addition.  A loader can compile all classes and methods first and then install all methods only after they have been all compiled, and in a way that executes little code.ß!!MethodContext methodsFor: 'closure support' stamp: 'mvl 3/13/2007 11:42'!isExecutingBlock	"Is this executing a block versus a method"	^ self method notNil and: [self method isBlockMethod]! !!MethodContext methodsFor: 'printing' stamp: 'mvl 3/13/2007 11:40'!printString	"Answer an emphasized string in case of a breakpoint method"	^(self method notNil and: [self method hasBreakpoint])		ifTrue:[(super printString , ' [break]') asText allBold]		ifFalse:[super printString]! !!MethodMorph methodsFor: 'as yet unclassified' stamp: 'tk 9/7/2000 22:07'!installRollBackButtons: target	| mine |	"If I don't already have such a button, put one in at the upper right.  Set its target to the furtherest enclosing book.  Send chooseAndRevertToVersion when clicked.  Stay in place via scrollBar install."	mine := self submorphNamed: #chooseAndRevertToVersion ifNone: [nil].	mine ifNil: [mine := SimpleButtonMorph new.		"mine height: mine height - 2."		mine label: 'Roll Back'; cornerStyle: #square.		mine color: Color white; borderColor: Color black.		mine actionSelector: #chooseAndRevertToVersion.		mine align: mine topRight with: (self findA: ScrollBar) topLeft +(1@1).		self addMorphFront: mine.		mine height: mine height - 5 "14"].	mine target: target.! !!MethodMorph methodsFor: 'scrolling' stamp: 'nk 4/28/2004 10:23'!showScrollBar	"Copied down and modified to get rid of the ruinous comeToFront of the inherited version."	| scriptor |	(submorphs includes: scrollBar)		ifTrue: [^ self].	self vResizeScrollBar.	self privateAddMorph: scrollBar atIndex: 1.	retractableScrollBar		ifTrue:			["Bring the pane to the front so that it is fully visible"			"self comeToFront. -- thanks but no thanks"			(scriptor := self ownerThatIsA: ScriptEditorMorph)				ifNotNil:					[scriptor comeToFront]]		ifFalse: [self resetExtent]! !!MethodNode methodsFor: 'initialize-release' stamp: 'md 2/5/2007 15:40'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim 		self 		selector: selOrFalse		arguments: args		precedence: p		temporaries: temps		block: blk encoder:		anEncoder 		primitive: prim 		properties: MethodProperties new.! !!MethodNode methodsFor: 'printing' stamp: 'md 2/3/2007 11:53'!printOn: aStream 	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				aStream withStyleFor: #methodArgument					do: [aStream nextPutAll: arg key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '|'.			aStream withStyleFor: #temporaryVariable				do: [temporaries do: 						[:temp | aStream space; nextPutAll: temp key]].				aStream nextPutAll: ' |'].	properties ifNotNil: [ 		properties pragmas do: [ :each |			"Don't decompile basic primitives that return self, i-vars, etc."			each keyword = #primitive:				ifFalse: [ aStream crtab: 1. each printOn: aStream ]				ifTrue: [					( (each argumentAt: 1) isNumber and: [(each argumentAt: 1) between: 255 and: 519])						ifFalse: [ aStream crtab: 1. self printPrimitiveOn: aStream ] ] ] ].	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 8/19/2006 20:44'!testCompileBinary	self assertPragma: ' = 1' givesKeyword: #= arguments: #( 1 ).	self assertPragma: ' , 3' givesKeyword: #, arguments: #( 3 ).	self assertPragma: ' > 4' givesKeyword: #> arguments: #( 4 ).	self assertPragma: ' < 5' givesKeyword: #< arguments: #( 5 ).	self assertPragma: ' == 1' givesKeyword: #== arguments: #( 1 ).	self assertPragma: ' <> 3' givesKeyword: #<> arguments: #( 3 ).	self assertPragma: ' >< 4' givesKeyword: #>< arguments: #( 4 ).	self assertPragma: ' ** 5' givesKeyword: #** arguments: #( 5 )! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 10:15'!testCompileInvalid	"Invalid pragmas should properly raise an error."	self should: [ self compile: '<>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<#123>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo bar>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo 1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar zork>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar 1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: bar:>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: #bar: zork:>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<<1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<=2>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 = >' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 =2 >' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: String>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: Pragma>' selector: #zork ] raise: SyntaxErrorNotification! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 09:49'!testCompileValue	self assertPragma: 'foo: true' givesKeyword: #foo: arguments: #( true ).	self assertPragma: 'foo: false' givesKeyword: #foo: arguments: #( false ).	self assertPragma: 'foo: nil' givesKeyword: #foo: arguments: #( nil )! !!MethodPragmaTest methodsFor: 'testing-printing-reformating' stamp: 'md 2/3/2007 11:55'!testReformat	self assert: (DisplayScreen class compiledMethodAt: #actualScreenDepth) getSource string = 'actualScreenDepth	<primitive: ''primitiveScreenDepth''>	^ Display depth'.		self shouldnt: [ DisplayScreen class reformatMethodAt: #actualScreenDepth] raise: Error.	self assert: (DisplayScreen class compiledMethodAt: #actualScreenDepth) getSource string = 'actualScreenDepth	<primitive: ''primitiveScreenDepth''>	^ Display depth'.	! !!MethodReference methodsFor: 'comparisons' stamp: 'kph 12/16/2006 10:11'!asStringOrText	^stringVersion ifNil: [ self stringVersionDefault ]! !!MethodReference methodsFor: 'comparisons' stamp: 'kph 12/16/2006 10:11'!stringVersionDefault	^classSymbol, (classIsMeta ifTrue: [ ' class ' ] ifFalse: [' ']), methodSymbol  ! !!MethodReference methodsFor: 'setting' stamp: 'kph 12/16/2006 10:06'!setStandardClass: aClass methodSymbol: methodSym	classSymbol _ aClass theNonMetaClass name.	classIsMeta _ aClass isMeta.	methodSymbol _ methodSym.	stringVersion _ nil.! !!MethodWithInterface methodsFor: 'access' stamp: 'sw 3/28/2001 16:25'!playerClass	"Answer the playerClass associated with the receiver.  Note: fixes up cases where the playerClass slot was a Playerxxx object because of an earlier bug"	^ (playerClass isKindOf: Class)		ifTrue:			[playerClass]		ifFalse:			[playerClass := playerClass class]! !!MethodWithInterface methodsFor: 'initialization' stamp: 'sw 1/30/2001 11:37'!convertFromUserScript: aUserScript	"The argument represents an old UserScript object.  convert it over"	defaultStatus := aUserScript status.! !!MethodWithInterface methodsFor: 'initialization' stamp: 'sw 1/26/2001 16:44'!initialize	"Initialize the receiver by setting its inst vars to default values"	super initialize.	defaultStatus := #normal! !!MethodWithInterface methodsFor: 'initialization' stamp: 'sw 9/12/2001 11:59'!playerClass: aPlayerClass selector: aSelector	"Set the playerClass and selector of the receiver"	playerClass := aPlayerClass.	selector := aSelector.! !!MethodWithInterface methodsFor: 'rename' stamp: 'sw 3/11/2003 00:01'!renameScript: newSelector fromPlayer: aPlayer	"The receiver's selector has changed to the new selector.  Get various things right, including the physical appearance of any Scriptor open on this method"	self allScriptEditors do:		[:aScriptEditor | aScriptEditor renameScriptTo: newSelector].	(selector numArgs = 0 and: [newSelector numArgs = 1])		ifTrue:			[self argumentVariables: (OrderedCollection with:				(Variable new name: #parameter type: #Number))].	(selector numArgs = 1 and: [newSelector numArgs = 0])		ifTrue:			[self argumentVariables: OrderedCollection new].	selector := newSelector asSymbol.	self bringUpToDate.	self playerClass atSelector: selector putScript: self.	self allScriptActivationButtons do:		[:aButton | aButton bringUpToDate].! !!MethodWithInterface methodsFor: 'script editor' stamp: 'sw 3/28/2001 16:26'!instantiatedScriptEditorForPlayer: aPlayer	"Return a new script editor for the player and selector"	| aScriptEditor |	aScriptEditor := (self playerClass includesSelector: selector) 			ifTrue: [ScriptEditorMorph new 				fromExistingMethod: selector 				forPlayer: aPlayer]			ifFalse: [ScriptEditorMorph new				setMorph: aPlayer costume				scriptName: selector].		defaultStatus == #ticking ifTrue:			[aPlayer costume arrangeToStartStepping].		^ aScriptEditor! !!MimeConverter methodsFor: 'accessing' stamp: 'tk 12/9/97 13:51'!dataStream: anObject	dataStream := anObject! !!MimeConverter methodsFor: 'accessing' stamp: 'tk 12/9/97 13:51'!mimeStream: anObject	mimeStream := anObject! !!ModalController methodsFor: 'as yet unclassified' stamp: 'jm 5/1/1998 07:05'!close	"This is how we leave the mode." 	modeActive := false.! !!ModalController methodsFor: 'as yet unclassified' stamp: 'jm 5/1/1998 07:02'!controlInitialize	modeActive := true.	^ super controlInitialize! !!Morph methodsFor: 'geometry' stamp: 'nk 4/27/2003 16:16'!intersects: aRectangle	"Answer whether aRectangle, which is in World coordinates, intersects me."	^self fullBoundsInWorld intersects: aRectangle! !!Morph methodsFor: 'halos and balloon help' stamp: 'zz 9/28/2006 18:53'!balloonHelpTextForHandle: aHandle 	"Answer a string providing balloon help for the	given halo handle"	| itsSelector |	itsSelector := aHandle eventHandler firstMouseSelector.	itsSelector == #doRecolor:with:		ifTrue: [^ Preferences propertySheetFromHalo				ifTrue: ['Open a property sheet.']				ifFalse: ['Change color']].	itsSelector == #mouseDownInDimissHandle:with:		ifTrue: [^ Preferences preserveTrash				ifTrue: ['Move to trash']				ifFalse: ['Remove from screen']].	#(#(#addFullHandles 'More halo handles') #(#addSimpleHandles 'Fewer halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#dismiss 'Remove') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMakeSibling:with: 'Make a sibling') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#editButtonsScript 'See the script for this button') #(#editDrawing 'Repaint') #(#doDupOrMakeSibling:with: 'Duplicate (press shift to make a sibling)') #(#doMakeSiblingOrDup:with: 'Make a sibling (press shift to make simple duplicate)') #(#makeNascentScript 'Make a scratch script') #(#makeNewDrawingWithin 'Paint new object') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#openViewerForArgument 'Open a Viewer for me. Press shift for a snapshot.') #(#openViewerForTarget:with: 'Open a Viewer for me. Press shift for a snapshot.') #(#paintBackground 'Paint background') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#presentViewMenu 'Present the Viewing menu') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#tearOffTile 'Make a tile representing this object') #(#tearOffTileForTarget:with: 'Make a tile representing this object') #(#trackCenterOfRotation:with: 'Set center of rotation') )		do: [:pair | itsSelector == pair first				ifTrue: [^ pair last]].	^ 'unknown halo handle'translated! !!Morph methodsFor: 'menus' stamp: 'wiz 12/4/2006 00:24'!addPaintingItemsTo: aMenu hand: aHandMorph 	| subMenu movies |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'repaint' translated action: #editDrawing.	subMenu add: 'set rotation center' translated action: #setRotationCenter.	subMenu add: 'reset forward-direction' translated		action: #resetForwardDirection.	subMenu add: 'set rotation style' translated action: #setRotationStyle.	subMenu add: 'erase pixels of color' translated		action: #erasePixelsOfColor:.	subMenu add: 'recolor pixels of color' translated		action: #recolorPixelsOfColor:.	subMenu add: 'reduce color palette' translated action: #reduceColorPalette:.	subMenu add: 'add a border around this shape...' translated		action: #addBorderToShape:.	movies := (self world rootMorphsAt: aHandMorph targetPoint) 				select: [:m | (m isKindOf: MovieMorph) or: [m isSketchMorph]].	movies size > 1 		ifTrue: 			[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aMenu add: 'painting...' translated subMenu: subMenu! !!Morph methodsFor: 'menus' stamp: 'wiz 10/19/2006 00:35'!adhereToEdge: edgeSymbol 	| edgeMessage |	(owner isNil or: [owner isHandMorph]) ifTrue: [^self].	(owner class canUnderstand:  edgeSymbol) ifFalse:  [^self].	(self class canUnderstand: ( edgeMessage := (edgeSymbol , ':') asSymbol ))		 ifFalse:  [^self].		self perform: edgeMessage		withArguments: (Array with: (owner perform: edgeSymbol))! !!Morph methodsFor: 'meta-actions' stamp: 'wiz 11/9/2006 23:04'!potentialTargetsAt: aPoint 	"Return the potential targets for the receiver.  	This is derived from Morph>>potentialEmbeddingTargets."	| realOwner |	realOwner := self topRendererOrSelf	owner		ifNil: [^ #()].	^ realOwner		morphsAt: aPoint		! !!Morph methodsFor: 'structure' stamp: 'wiz 12/7/2006 15:12'!renderedMorph	"This now  gets overridden by rendering morphs."	^self! !!Morph methodsFor: '*eToys-customevents-scripting' stamp: 'nk 9/25/2003 11:36'!removeAllEventTriggers	"Remove all the event registrations for my Player.	User custom events are triggered at the World,	while system custom events are triggered on individual Morphs."	| player |	(player := self player) ifNil: [ ^self ].	self removeAllEventTriggersFor: player.	self currentWorld removeAllEventTriggersFor: player.! !!Morph methodsFor: '*eToys-customevents-scripting' stamp: 'nk 9/25/2003 11:37'!removeEventTrigger: aSymbol	"Remove all the event registrations for my Player that are triggered by aSymbol.	User custom events are triggered at the World,	while system custom events are triggered on individual Morphs."	| player |	(player := self player) ifNil: [ ^self ].	self removeEventTrigger: aSymbol for: player.	self currentWorld removeEventTrigger: aSymbol for: player.! !!Morph class methodsFor: '*eToys-new-morph participation' stamp: 'sw 10/24/2001 15:51'!partName: aName categories: aList documentation: aDoc sampleImageForm: aForm	"Answer a DescriptionForPartsBin which will represent a launch of a new instance of my class via the #newStandAlone protocol sent to my class. Use the category-list and documentation provided.  This variant allows an overriding image form to be provided, useful in cases where we don't want to launch a sample instance just to get the form"	| descr |	descr := DescriptionForPartsBin new		formalName: aName		categoryList: aList		documentation: aDoc		globalReceiverSymbol: self name		nativitySelector: #newStandAlone.	descr sampleImageForm: aForm.	^ descr! !!MorphBugs methodsFor: 'as yet unclassified' stamp: 'wiz 10/19/2006 00:32'!adhereToEdgeTest"self new adhereToEdgeTest""self run: #adhereToEdgeTest"| r |r := RectangleMorph new openInWorld .self shouldnt: [ [ r adhereToEdge: #eternity ] ensure: [ r delete ] ] raise: Error . r delete .^true ! !!MorphExtension methodsFor: '*eToys-accessing' stamp: 'dgd 2/16/2003 21:53'!actorState: anActorState "change the receiver's actorState"	actorState := anActorState! !!MorphExtension methodsFor: '*eToys-accessing' stamp: 'dgd 2/16/2003 21:53'!player: anObject 	"change the receiver's player"	player := anObject ! !!MorphicModel class methodsFor: '*eToys-queries' stamp: 'sw 2/27/2002 14:58'!baseUniclass	"Answer the uniclass that new instances should be instances of.  This protocol is primarily intended for the Player lineage, but can get sent to a MorphicModel subclass when the project-loading mechanism is scrambling to fix up projects that have naming conflicts with the project being loaded."	| curr |	curr := self.	[curr theNonMetaClass superclass name endsWithDigit]		whileTrue:			[curr := curr superclass].	^ curr"PlayWithMe1 baseUniclass"! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'wiz 1/3/2007 12:16'!findWindowInWorldLabeled: aLabel^ World submorphs detect: [ :each |	each class == SystemWindow		and: [ each label = aLabel ] ] ifNone: [ nil ] .! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'wiz 6/11/2007 20:34'!setUp"default. tests will add morphs to list. Teardown will delete."cases := #() .! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'wiz 1/3/2007 11:25'!tearDown"default. tests will add morphs to list. Teardown will delete."cases do: [ :each | each delete ] .! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'wiz 4/18/2007 00:58'!testOpenWorkspace"self new testOpenWorkspace""MorphicUIBugTest run: #testOpenWorkspace"| window myLabel foundWindow myModel |self assert: ( Smalltalk isMorphic ) .myLabel := 'Workspace from ', 'SUnit test' .foundWindow := self findWindowInWorldLabeled: myLabel .self assert: ( foundWindow isNil ) .window := UIManager default edit: '"MorphicUIBugTest run: #openWorkspaceTest"'  label: myLabel .window = window. foundWindow := self findWindowInWorldLabeled: myLabel .cases := Array with: foundWindow . "For teardown."myModel := (foundWindow submorphs detect: [ :each |	each isMorphicModel ] )  .self assert: ( myModel model class == Workspace ) .self assert: ( foundWindow model class == Workspace ) .foundWindow delete .! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'wiz 4/18/2007 00:57'!testOpenWorkspaceAns"Test if method opening a workspace answers the window opened""MorphicUIBugTest run: #testOpenWorkspaceAns"| window myLabel foundWindow |self assert: ( Smalltalk isMorphic ) .myLabel := 'Workspace from ', 'SUnit test' .foundWindow := self findWindowInWorldLabeled: myLabel .self assert: ( foundWindow isNil ) .window := UIManager default edit: '"MorphicUIBugTest run: #openWorkspaceTest"'  label: myLabel .foundWindow := self findWindowInWorldLabeled: myLabel .cases := Array with: foundWindow . "For teardown."self assert: ( window == foundWindow ) .foundWindow delete .! !!MorphicUIBugTest commentStamp: 'wiz 1/3/2007 13:57' prior: 0!A MorphicUIBugTest is a class for testing the shortcomings and repairs of the MorphicUI manager..Instance Variables	cases:		<aCollection>cases	- a list of morphs that may need to be deleted during teardown.	the tests are expected to fill this list it starts out empty by default.		!!MorphicUIManager methodsFor: 'ui requests' stamp: 'wiz 1/3/2007 13:50'!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window holder text |	holder := Workspace  new.	holder contents: aText.	text := PluggableTextMorphPlus 		on: holder 		text: #contents 		accept: #acceptContents: 		readSelection: nil 		menu: nil.	text acceptAction: anAction.	window := SystemWindow new.	labelString ifNotNil:[window setLabel: labelString].	window model: holder .	window addMorph: text frame: (0@0 extent: 1@1).	window paneColor: Color gray.	window openInWorld.^ window ! !!MouseMenuController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:28'!controlActivity	"Refer to the comment in Controller|controlActivity."	| cursorPoint |	cursorPoint := sensor cursorPoint.	super controlActivity.	(cursorPoint = sensor cursorPoint and: [self viewHasCursor])		ifTrue: 			[sensor redButtonPressed ifTrue: [^ self redButtonActivity].			sensor yellowButtonPressed ifTrue: [^ self yellowButtonActivity].			sensor blueButtonPressed ifTrue: [^ self blueButtonActivity]]! !!MouseMenuController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 15:54'!reset	"Eliminate references to all mouse button menus."	redButtonMenu := nil.	redButtonMessages := nil! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 14:56'!redButtonActivity	"Determine which item in the red button pop-up menu is selected. If one 	is selected, then send the corresponding message to the object designated 	as the menu message receiver."	| index |	redButtonMenu ~~ nil		ifTrue: 			[index := redButtonMenu startUp.			index ~= 0 				ifTrue: [self perform: (redButtonMessages at: index)]]		ifFalse: [super controlActivity]! !!MouseMenuController methodsFor: 'menu setup'!redButtonMenu: aSystemMenu redButtonMessages: anArray 	"Initialize the pop-up menu that should appear when the user presses the 	red mouse button to be aSystemMenu. The corresponding messages that 	should be sent are listed in the array, anArray."	redButtonMenu release.	redButtonMenu := aSystemMenu.	redButtonMessages := anArray! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sw 2/17/2002 04:35'!pluggableYellowButtonActivity: shiftKeyState	"Invoke the model's popup menu."	| menu |	(menu := self getPluggableYellowButtonMenu: shiftKeyState)		ifNil:			[sensor waitNoButton]		ifNotNil:			[self terminateAndInitializeAround:				[menu invokeOn: model orSendTo: self]]! !!MovieMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:25'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| movies subMenu |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	subMenu _ MenuMorph new defaultTarget: self.	frameList size > 1 ifTrue: [		subMenu add: 'repaint' translated action: #editDrawing.		subMenu add: 'set rotation center' translated action: #setRotationCenter.		subMenu add: 'play once' translated action: #playOnce.		subMenu add: 'play loop' translated action: #playLoop.		subMenu add: 'stop playing' translated action: #stopPlaying.		currentFrameIndex > 1 ifTrue: [			subMenu add: 'previous frame' translated action: #previousFrame].		currentFrameIndex < frameList size ifTrue: [			subMenu add: 'next frame' translated action: #nextFrame]].	subMenu add: 'extract this frame' translated action: #extractFrame:.	movies _		(self world rootMorphsAt: aHandMorph targetPoint)			select: [:m | (m isKindOf: MovieMorph) or:						[m isSketchMorph]].	(movies size > 1) ifTrue:		[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aCustomMenu add: 'movie...' translated subMenu: subMenu! !!MovieMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:25'!insertIntoMovie: evt	| movies aTarget |	movies _		(self world rootMorphsAt: evt hand targetPoint)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isSketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget _ movies first.	(aTarget isSketchMorph) ifTrue:		[aTarget _ aTarget replaceSelfWithMovie].	movies first insertFrames: frameList.	self delete.! !!MultiByteFileStream class methodsFor: 'class initialization' stamp: 'apb 2/19/2007 13:31'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the	path name delimiter from FileDirectory."	FileDirectory pathNameDelimiter = $:		ifTrue: [^ self defaultToCR].	FileDirectory pathNameDelimiter = $/		ifTrue: [((SmalltalkImage current getSystemAttribute: 1002)					beginsWith: 'darwin')				ifTrue: [^ self defaultToCR]				ifFalse: [^ self defaultToLF]].	FileDirectory pathNameDelimiter = $\		ifTrue: [^ self defaultToCRLF].	"in case we don't know"	^ self defaultToCR! !!Number methodsFor: 'printing' stamp: 'fcs 12/13/2006 19:47'!printShowingDecimalPlaces: placesDesired	"Print the receiver showing precisely the given number of places desired.  If placesDesired is positive, a decimal point and that many digits after the decimal point will always be shown.  If placesDesired is zero, a whole number will be shown, without a decimal point.  It now handles negative numbers between 0 and -1 and rounds correctly in more cases.  This method probably could be optimized -- improvements welcomed.  Category was/is 'converting' but should be 'printing' "	| precision rounded frac sign integerString fractionString result |	placesDesired <= 0 ifTrue: [^ self rounded printString].	precision _ Utilities floatPrecisionForDecimalPlaces: placesDesired.	rounded _ self roundTo: precision.	sign := rounded negative ifTrue: ['-'] ifFalse: [''].	integerString := rounded abs integerPart asInteger printString.	frac := ((rounded abs fractionPart roundTo: precision) * (10 raisedToInteger: placesDesired)) asInteger.	fractionString := frac printString padded: #right to: placesDesired with: $0.	result := sign , integerString , '.' , fractionString.	^result"23 printShowingDecimalPlaces: 223.5698 printShowingDecimalPlaces: 2-234.567 printShowingDecimalPlaces: 523.4567 printShowingDecimalPlaces: 023.5567 printShowingDecimalPlaces: 0-23.4567 printShowingDecimalPlaces: 0-23.5567 printShowingDecimalPlaces: 0100000000 printShowingDecimalPlaces: 10.98 printShowingDecimalPlaces: 2-0.98 printShowingDecimalPlaces: 22.567 printShowingDecimalPlaces: 2-2.567 printShowingDecimalPlaces: 20 printShowingDecimalPlaces: 2Number categoryForSelector: #printShowingDecimalPlaces:"! !!NumberTest methodsFor: 'tests' stamp: 'fcs 12/13/2006 17:26'!testPrintShowingDecimalPlaces	self assert: (111.2 printShowingDecimalPlaces: 2) = '111.20'.	self assert: (111.2 printShowingDecimalPlaces: 0) = '111'.	self assert: (111 printShowingDecimalPlaces: 0) = '111'.	self assert: (111111111111111 printShowingDecimalPlaces: 2) = '111111111111111.00'.	self assert: (10 printShowingDecimalPlaces: 20) ='10.00000000000000000000'.	self assert: (0.98 printShowingDecimalPlaces: 2) = '0.98'.	self assert: (-0.98 printShowingDecimalPlaces: 2) = '-0.98'.	self assert: (2.567 printShowingDecimalPlaces: 2) = '2.57'.	self assert: (-2.567 printShowingDecimalPlaces: 2) = '-2.57'.	"self assert: (Number categoryForSelector: #printShowingDecimalPlaces:) = 'printing'."! !!NumericReadoutTile methodsFor: 'accessing' stamp: 'ar 9/15/2000 23:27'!abandonLabelFocus	| aLabel |	"If the receiver's label has editing focus, abandon it"	self flag: #arNote. "Probably unnecessary"	(aLabel := self labelMorph) ifNotNil:		[aLabel hasFocus ifTrue:			[aLabel contents: aLabel readFromTarget.			aLabel handsWithMeForKeyboardFocus do:				[:aHand | aHand releaseKeyboardFocus]]]! !!NumericReadoutTile methodsFor: 'accessing' stamp: 'tak 12/6/2004 01:53'!literalFromContents	| label |	label := self labelMorph				ifNil: [^ super literal].	label step.	^ literal := label valueFromContents! !!NumericReadoutTile methodsFor: 'literal' stamp: 'sw 9/15/1999 15:14'!setLiteralTo: anObject width: w	"like literal:width: but does not inform the target"	literal := anObject.	self updateLiteralLabel.	submorphs last setWidth: w.	self updateLiteralLabel! !!NumericReadoutTile methodsFor: 'parts bin' stamp: 'sw 11/15/2001 20:22'!initializeToStandAlone	"Enclose my prototype in a SyntaxMorph.  For the ObjectTool"	| aWatcher aTile aLine aColor ms slotMsg |	super initializeToStandAlone.	aColor := Color r: 0.387 g: 0.581 b: 1.0.	aTile := self typeColor: aColor.	aWatcher := UpdatingStringMorph new.	aWatcher growable: true;		getSelector: nil;		putSelector: nil;		setToAllowTextEdit.	aWatcher target: nil.	aTile addMorphBack: aWatcher.	aTile addArrows.	aTile setLiteralTo: 5 width: 30.	ms := MessageSend receiver: nil selector: #aNumber arguments: #().	slotMsg := ms asTilesIn: Player globalNames: false.		"For CardPlayers, use 'aPlayer'.  For others, name it, and use its name."	ms := MessageSend receiver: 3 selector: #= asSymbol arguments: #(5).	aLine := ms asTilesIn: Player globalNames: false.	aLine firstSubmorph delete.		"A little over-complicated?  Yes?"	aLine addMorphFront: (slotMsg submorphs second) firstSubmorph.	aLine addMorphFront: (Morph new transparentSpacerOfSize: 3@3).	aLine lastSubmorph delete.	aLine lastSubmorph delete.	aLine color: aColor.	aLine addMorphBack: (Morph new transparentSpacerOfSize: 3@3).	aLine addMorphBack: aTile.	aLine cellPositioning: #leftCenter.	aWatcher step; fitContents.	^ aLine markAsPartsDonor.! !!NumericReadoutTile class methodsFor: 'instance creation' stamp: 'tk 12/14/2001 19:32'!borderedPrototype	"Just number and up/down arrows"	| aWatcher aTile |	aTile := self new typeColor: (Color r: 0.387 g: 0.581 b: 1.0).	aWatcher := UpdatingStringMorph new.	aWatcher growable: true; setNameTo: 'value'.	aTile addMorphBack: aWatcher.	aTile addArrows; setNameTo: 'Number (mid)'.	aTile setLiteralTo: 5 width: 30.	aWatcher step; fitContents; setToAllowTextEdit.	^ aTile extent: 30@24; markAsPartsDonor! !!NumericReadoutTile class methodsFor: 'scripting' stamp: 'tk 12/14/2001 19:30'!authoringPrototype	"Enclose my prototype in a SyntaxMorph."	| aWatcher aTile aLine aColor ms slotMsg |	aColor := Color r: 0.387 g: 0.581 b: 1.0.	aTile := self new typeColor: aColor.	aWatcher := UpdatingStringMorph new.	aWatcher growable: true;		setToAllowTextEdit;		getSelector: nil;		putSelector: nil.	aWatcher target: nil.	aTile addMorphBack: aWatcher.	aTile addArrows.	aTile setLiteralTo: 5 width: 30.	"This is the long way around to do this..."	ms := MessageSend receiver: nil selector: #aNumber arguments: #().	slotMsg := ms asTilesIn: Player globalNames: false.		"For CardPlayers, use 'aPlayer'.  For others, name it, and use its name."	ms := MessageSend receiver: 3 selector: #= asSymbol arguments: #(5).	aLine := ms asTilesIn: Player globalNames: false.	aLine firstSubmorph delete.		aLine addMorphFront: (slotMsg submorphs second) firstSubmorph.	aLine firstSubmorph setNameTo: 'label'.	aLine addMorphFront: (Morph new transparentSpacerOfSize: 3@3).	aLine lastSubmorph delete.	aLine lastSubmorph delete.	aLine color: aColor; setNameTo: 'Number (fancy)'.	aLine addMorphBack: (Morph new transparentSpacerOfSize: 3@3).	aLine addMorphBack: aTile.	aLine readOut setNameTo: 'value'.	aLine cellPositioning: #leftCenter.	aWatcher step; fitContents.	^ aLine markAsPartsDonor.! !!Object methodsFor: 'message handling' stamp: 'st 11/5/2004 16:19'!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Object methodsFor: '*universes' stamp: 'ls 11/26/2006 12:33'!isUPackage	^false! !!Object methodsFor: '*universes' stamp: 'ls 11/26/2006 12:33'!isUPackageCategory	^false! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:04'!adjustTargetBorderWidth: aFractionalPoint	| n |	myTarget borderWidth: (n := (aFractionalPoint x * 10) rounded max: 0).	self showSliderFeedback: n.! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:02'!adjustTargetGradientDirection: aFractionalPoint	| fs p |	(fs := myTarget fillStyle) isGradientFill ifFalse: [^self].	fs direction: (p := (aFractionalPoint * myTarget extent) rounded).	self showSliderFeedback: p.	myTarget changed.! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:05'!adjustTargetGradientOrigin: aFractionalPoint	| fs p |	(fs := myTarget fillStyle) isGradientFill ifFalse: [^self].	fs origin: (p := myTarget topLeft + (aFractionalPoint * myTarget extent) rounded).	self showSliderFeedback: p.	myTarget changed.! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:03'!adjustTargetShadowOffset: aFractionalPoint	| n |	myTarget changed; layoutChanged.	myTarget shadowOffset: (n := (aFractionalPoint * 4) rounded).	self showSliderFeedback: n.	myTarget changed; layoutChanged.! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:03'!doEnables	| itsName fs |	fs := myTarget fillStyle.	self allMorphsDo: [ :each |		itsName := each knownName.		itsName == #pickerForColor ifTrue: [			self enable: each when: fs isSolidFill | fs isGradientFill		].		itsName == #pickerForBorderColor ifTrue: [			self enable: each when: (myTarget respondsTo: #borderColor:)		].		itsName == #pickerForShadowColor ifTrue: [			self enable: each when: myTarget hasDropShadow		].		itsName == #pickerFor2ndGradientColor ifTrue: [			self enable: each when: fs isGradientFill		].	].! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'dgd 10/8/2003 19:35'!rebuild	self removeAllMorphs.	self addARow: {		self lockedString: ('Properties for {1}' translated format: {myTarget name}).	}.	self addARow: {		self inAColumn: {			self paneForCornerRoundingToggle.			self paneForStickinessToggle.			self paneForLockedToggle.		}.	}.	self addARow: {		self paneForMainColorPicker.		self paneFor2ndGradientColorPicker.	}.	self addARow: {		self paneForBorderColorPicker.		self paneForShadowColorPicker.	}.	self addARow: {		self 			buttonNamed: 'Accept' translated action: #doAccept color: color lighter 			help: 'keep changes made and close panel' translated.		self 			buttonNamed: 'Cancel' translated action: #doCancel color: color lighter 			help: 'cancel changes made and close panel' translated.	}, self rebuildOptionalButtons.	thingsToRevert := Dictionary new.	"thingsToRevert at: #fillStyle: put: myTarget fillStyle."	myTarget isSystemWindow ifTrue: [		thingsToRevert at: #setWindowColor: put: myTarget paneColorToUse	].	thingsToRevert at: #hasDropShadow: put: myTarget hasDropShadow.	thingsToRevert at: #shadowColor: put: myTarget shadowColor.	(myTarget respondsTo: #borderColor:) ifTrue: [		thingsToRevert at: #borderColor: put: myTarget borderColor.	].	thingsToRevert at: #borderWidth: put: myTarget borderWidth.	thingsToRevert at: #cornerStyle: put: myTarget cornerStyle.	thingsToRevert at: #sticky: put: myTarget isSticky.	thingsToRevert at: #lock: put: myTarget isLocked.! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'wiz 9/21/2005 22:42'!rebuildOptionalButtons	| answer |	answer := #() .		myTarget isTextMorph ifTrue: [		answer := answer, {			self 				buttonNamed: 'Text' translated action: #doTextProperties color: color lighter 				help: 'open a text properties panel for the morph' translated.		}.	].	^answer! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:02'!toggleTargetRadial	| fs |	(fs := myTarget fillStyle) isGradientFill ifFalse: [^self].	fs radial: fs radial not.	myTarget changed.	self doEnables.! !!ObjectPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:44'!initialize"initialize the state of the receiver"	super initialize.""	myTarget		ifNil: [myTarget := RectangleMorph new openInWorld].	self rebuild! !!ObjectPropertiesMorph methodsFor: 'panes' stamp: 'sd 11/13/2003 21:03'!borderPrototype: aBorderStyle help: helpString	| selector proto |	selector := BorderedMorph new.	selector borderWidth: 0.	selector color: Color transparent.	proto := Morph new extent: 16@16.	proto color:  Color transparent.	proto borderStyle: aBorderStyle.	selector extent: proto extent + 4.	selector addMorphCentered: proto.	(myTarget canDrawBorder: aBorderStyle) ifTrue:[		selector setBalloonText: helpString.		selector on: #mouseDown send: #toggleBorderStyle:with:from: to: self withValue: proto.		(myTarget borderStyle species == aBorderStyle species and:[			myTarget borderStyle style == aBorderStyle style]) ifTrue:[selector borderWidth: 1].	] ifFalse:[		selector setBalloonText: 'This border style cannot be used here' translated.		selector on: #mouseDown send: #beep to: Beeper.		selector addMorphCentered: ((Morph new) color: (Color black alpha: 0.5); extent: selector extent).	].	^selector! !!ObjectPropertiesMorph methodsFor: 'panes' stamp: 'ar 8/25/2001 18:35'!toggleBorderStyle: provider with: arg1 from: arg2	| oldStyle newStyle |	oldStyle := myTarget borderStyle.	newStyle := provider borderStyle copy.	oldStyle width = 0 		ifTrue:[newStyle width: 2]		ifFalse:[newStyle width: oldStyle width].	newStyle baseColor: oldStyle baseColor.	myTarget borderStyle: newStyle.	provider owner owner submorphsDo:[:m| m borderWidth: 0].	provider owner borderWidth: 1.! !!ObjectRepresentativeMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2000 15:55'!objectRepresented: anObject	"Set the receiver's representee.  This clears out any preexisting state in the receiver"	objectRepresented := anObject.	self removeAllMorphs.	self hResizing: #shrinkWrap.  	self vResizing: #shrinkWrap.	self addMorphBack: (StringMorph new contents: anObject name asString).	self setNameTo: anObject name	! !!ObjectRepresentativeMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2000 15:55'!objectRepresented: anObject labelString: aLabel	"Set the receiver's representee as indicated, and use the given label to tag it"	objectRepresented := anObject.	self removeAllMorphs.	self hResizing: #shrinkWrap.  	self vResizing: #shrinkWrap.	self addMorphBack: (StringMorph new contents: aLabel asString).	self setNameTo: aLabel asString	! !!ObjectsTool methodsFor: 'categories' stamp: 'edc 12/4/2007 15:34'!showCategory: aCategoryName fromButton: aButton 	"Project items from the given category into my lower pane"	| quads |	"self partsBin removeAllMorphs. IMHO is redundant, "		Cursor wait		showWhile: [quads := OrderedCollection new.			Morph withAllSubclasses				do: [:aClass | aClass theNonMetaClass						addPartsDescriptorQuadsTo: quads						if: [:aDescription | aDescription translatedCategories includes: aCategoryName]].			quads := quads						asSortedCollection: [:q1 :q2 | q1 third <= q2 third].			self installQuads: quads fromButton: aButton]! !!OneOnSwitch methodsFor: 'connection'!connection: anObject 	"Set anObject to be the connection among two or more Switches. Make the 	receiver a dependent of the argument, anObject."	connection := anObject.	connection addDependent: self! !!OneOnSwitch methodsFor: 'state'!turnOn	"Does nothing if it is already on. If it is not, it is set to 'on', its	dependents are 	notified of the change, its connection is notified, and	its action is executed."	self isOff		ifTrue: 			[on := true.			self changed.			self notifyConnection.			self doAction: onAction]! !!OrderedCollection methodsFor: 'accessing'!at: anInteger put: anObject 	"Put anObject at element index anInteger. at:put: cannot be used to	append, front or back, to an ordered collection; it is used by a	knowledgeable client to replace an element."	| index |	index := anInteger asInteger.	(index < 1 or: [index + firstIndex - 1 > lastIndex])		ifTrue: [self errorNoSuchElement]		ifFalse: [^array at: index + firstIndex - 1 put: anObject]! !!OrderedCollection methodsFor: 'adding'!add: newObject after: oldObject 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just succeeding oldObject. Answer newObject."		| index |	index := self find: oldObject.	self insert: newObject before: index + 1.	^newObject! !!OrderedCollection methodsFor: 'adding'!add: newObject before: oldObject 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just preceding oldObject. Answer newObject."		| index |	index := self find: oldObject.	self insert: newObject before: index.	^newObject! !!OrderedCollection methodsFor: 'adding'!addFirst: newObject 	"Add newObject to the beginning of the receiver. Answer newObject."	firstIndex = 1 ifTrue: [self makeRoomAtFirst].	firstIndex := firstIndex - 1.	array at: firstIndex put: newObject.	^ newObject! !!OrderedCollection methodsFor: 'adding'!addLast: newObject 	"Add newObject to the end of the receiver. Answer newObject."	lastIndex = array size ifTrue: [self makeRoomAtLast].	lastIndex := lastIndex + 1.	array at: lastIndex put: newObject.	^ newObject! !!OrderedCollection methodsFor: 'adding' stamp: 'ajh 5/22/2003 12:03'!at: index ifAbsentPut: block	"Return value at index, however, if value does not exist (nil or out of bounds) then add block's value at index (growing self if necessary)"	| v |	index <= self size ifTrue: [		^ (v := self at: index)			ifNotNil: [v]			ifNil: [self at: index put: block value]	].	[self size < index] whileTrue: [self add: nil].	^ self at: index put: block value! !!OrderedCollection methodsFor: 'adding'!grow	"Become larger. Typically, a subclass has to override this if the subclass	adds instance variables."	| newArray |	newArray := Array new: self size + self growSize.	newArray replaceFrom: 1 to: array size with: array startingAt: 1.	array := newArray! !!OrderedCollection methodsFor: 'copying' stamp: 'di 12/12/2000 10:15'!copyFrom: startIndex to: endIndex 	"Answer a copy of the receiver that contains elements from position	startIndex to endIndex."	| targetCollection |	endIndex < startIndex ifTrue: [^self species new: 0].	targetCollection := self species new: endIndex + 1 - startIndex.	startIndex to: endIndex do: [:index | targetCollection addLast: (self at: index)].	^ targetCollection! !!OrderedCollection methodsFor: 'copying'!copyReplaceFrom: start to: stop with: replacementCollection 	"Answer a copy of the receiver with replacementCollection's elements in	place of the receiver's start'th to stop'th elements. This does not expect	a 1-1 map from replacementCollection to the start to stop elements, so it	will do an insert or append."	| newOrderedCollection delta startIndex stopIndex |	"if start is less than 1, ignore stop and assume this is inserting at the front. 	if start greater than self size, ignore stop and assume this is appending. 	otherwise, it is replacing part of me and start and stop have to be within my 	bounds. "	delta := 0.	startIndex := start.	stopIndex := stop.	start < 1		ifTrue: [startIndex := stopIndex := 0]		ifFalse: [startIndex > self size				ifTrue: [startIndex := stopIndex := self size + 1]				ifFalse: 					[(stopIndex < (startIndex - 1) or: [stopIndex > self size])						ifTrue: [self errorOutOfBounds].					delta := stopIndex - startIndex + 1]].	newOrderedCollection := 		self species new: self size + replacementCollection size - delta.	1 to: startIndex - 1 do: [:index | newOrderedCollection add: (self at: index)].	1 to: replacementCollection size do: 		[:index | newOrderedCollection add: (replacementCollection at: index)].	stopIndex + 1 to: self size do: [:index | newOrderedCollection add: (self at: index)].	^newOrderedCollection! !!OrderedCollection methodsFor: 'copying'!copyWith: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver and 	includes the argument, newElement, at the end."	| newCollection |	newCollection := self copy.	newCollection add: newElement.	^newCollection! !!OrderedCollection methodsFor: 'copying' stamp: 'sw 1/26/96'!reversed	"Answer a copy of the receiver with element order reversed.  "	| newCol |	newCol := self species new.	self reverseDo:		[:elem | newCol addLast: elem].	^ newCol"#(2 3 4 'fred') reversed"! !!OrderedCollection methodsFor: 'enumerating' stamp: 'sma 2/5/2000 15:22'!collect: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect the 	resulting values into a collection that is like me. Answer the new 	collection. Override superclass in order to use addLast:, not at:put:."	| newCollection |	newCollection := self species new: self size.	firstIndex to: lastIndex do:		[:index |		newCollection addLast: (aBlock value: (array at: index))].	^ newCollection! !!OrderedCollection methodsFor: 'enumerating' stamp: 'bf 5/18/2000 17:34'!collect: aBlock from: fromIndex to: toIndex	"Override superclass in order to use addLast:, not at:put:."	| result |	(fromIndex < 1 or:[toIndex + firstIndex - 1 > lastIndex])		ifTrue: [^self errorNoSuchElement].	result := self species new: toIndex - fromIndex + 1.	firstIndex + fromIndex - 1 to: firstIndex + toIndex - 1 do:		[:index | result addLast: (aBlock value: (array at: index))].	^ result! !!OrderedCollection methodsFor: 'enumerating'!do: aBlock 	"Override the superclass for performance reasons."	| index |	index := firstIndex.	[index <= lastIndex]		whileTrue: 			[aBlock value: (array at: index).			index := index + 1]! !!OrderedCollection methodsFor: 'enumerating'!reverseDo: aBlock 	"Override the superclass for performance reasons."	| index |	index := lastIndex.	[index >= firstIndex]		whileTrue: 			[aBlock value: (array at: index).			index := index - 1]! !!OrderedCollection methodsFor: 'enumerating' stamp: 'sma 2/5/2000 15:13'!select: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect into	a new collection like the receiver, only those elements for which aBlock	evaluates to true."	| newCollection element |	newCollection := self copyEmpty.	firstIndex to: lastIndex do:		[:index |		(aBlock value: (element := array at: index))			ifTrue: [newCollection addLast: element]].	^ newCollection! !!OrderedCollection methodsFor: 'enumerating' stamp: 'di 8/31/1999 13:13'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with 	corresponding elements from this collection and otherCollection."	| result |	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	result := self species new: self size.	1 to: self size do:		[:index | result addLast: (twoArgBlock value: (self at: index)									value: (otherCollection at: index))].	^ result! !!OrderedCollection methodsFor: 'enumerating' stamp: 'bf 5/16/2000 16:30'!withIndexCollect: elementAndIndexBlock 	"Just like with:collect: except that the iteration index supplies the second argument to the block. Override superclass in order to use addLast:, not at:put:."	| newCollection |	newCollection := self species new: self size.	firstIndex to: lastIndex do:		[:index |		newCollection addLast: (elementAndIndexBlock			value: (array at: index)			value: index - firstIndex + 1)].	^ newCollection! !!OrderedCollection methodsFor: 'removing'!remove: oldObject ifAbsent: absentBlock	| index |	index := firstIndex.	[index <= lastIndex]		whileTrue: 			[oldObject = (array at: index)				ifTrue: 					[self removeIndex: index.					^ oldObject]				ifFalse: [index := index + 1]].	^ absentBlock value! !!OrderedCollection methodsFor: 'removing' stamp: 'raok 4/27/2001 15:35'!removeAllSuchThat: aBlock 	"Remove each element of the receiver for which aBlock evaluates to true.	The method in Collection is O(N^2), this is O(N)."	| n |	n := firstIndex.	firstIndex to: lastIndex do: [:index |	    (aBlock value: (array at: index)) ifFalse: [			array at: n put: (array at: index).			n := n + 1]].	n to: lastIndex do: [:index | array at: index put: nil].	lastIndex := n - 1! !!OrderedCollection methodsFor: 'removing' stamp: 'ar 5/22/2000 12:19'!removeAt: index	| removed |	removed := self at: index.	self removeIndex: index + firstIndex - 1.	^removed! !!OrderedCollection methodsFor: 'removing'!removeFirst	"Remove the first element of the receiver and answer it. If the receiver is 	empty, create an error notification."	| firstObject |	self emptyCheck.	firstObject := array at: firstIndex.	array at: firstIndex put: nil.	firstIndex := firstIndex + 1.	^ firstObject! !!OrderedCollection methodsFor: 'removing' stamp: 'ajh 6/22/2003 14:37'!removeFirst: n	"Remove first n object into an array"	| list |	list := Array new: n.	1 to: n do: [:i |		list at: i put: self removeFirst].	^ list! !!OrderedCollection methodsFor: 'removing'!removeLast	"Remove the last element of the receiver and answer it. If the receiver is 	empty, create an error notification."	| lastObject |	self emptyCheck.	lastObject := array at: lastIndex.	array at: lastIndex put: nil.	lastIndex := lastIndex - 1.	^ lastObject! !!OrderedCollection methodsFor: 'removing' stamp: 'ajh 6/22/2003 14:36'!removeLast: n	"Remove last n object into an array with last in last position"	| list |	list := Array new: n.	n to: 1 by: -1 do: [:i |		list at: i put: self removeLast].	^ list! !!OrderedCollection methodsFor: 'private' stamp: 'BG 1/9/2004 12:26'!find: oldObject  "  This method answers an index in the range firstIndex .. lastIndex, which is meant for internal use only.     Never use this method in your code, the methods for public use are:        #indexOf:        #indexOf:ifAbsent: "	| index |	index := firstIndex.	[index <= lastIndex]		whileTrue:			[(array at: index) = oldObject ifTrue: [^ index].			index := index + 1].	self errorNotFound: oldObject! !!OrderedCollection methodsFor: 'private' stamp: 'BG 1/9/2004 12:29'!insert: anObject before: spot  "  spot is an index in the range firstIndex .. lastIndex, such an index is not known from outside the collection.      Never use this method in your code, it is meant for private use by OrderedCollection only.     The methods for use are:        #add:before:   to insert an object before another object        #add:beforeIndex:   to insert an object before a given position. "	| "index" delta spotIndex|	spotIndex := spot.	delta := spotIndex - firstIndex.	firstIndex = 1		ifTrue: 			[self makeRoomAtFirst.			spotIndex := firstIndex + delta].	firstIndex := firstIndex - 1.	array		replaceFrom: firstIndex		to: spotIndex - 2		with: array		startingAt: firstIndex + 1.	array at: spotIndex - 1 put: anObject."	index := firstIndex := firstIndex - 1.	[index < (spotIndex - 1)]		whileTrue: 			[array at: index put: (array at: index + 1).			index := index + 1].	array at: index put: anObject."	^ anObject! !!OrderedCollection methodsFor: 'private'!makeRoomAtFirst	| delta index |	delta := array size - self size.	delta = 0 ifTrue: 			[self grow.			delta := array size - self size].	lastIndex = array size ifTrue: [^ self]. "just in case we got lucky"	index := array size.	[index > delta]		whileTrue: 			[array at: index put: (array at: index - delta + firstIndex - 1).			array at: index - delta + firstIndex - 1 put: nil.			index := index - 1].	firstIndex := delta + 1.	lastIndex := array size! !!OrderedCollection methodsFor: 'private'!makeRoomAtLast	| newLast delta |	newLast := self size.	array size - self size = 0 ifTrue: [self grow].	(delta := firstIndex - 1) = 0 ifTrue: [^ self].	"we might be here under false premises or grow did the job for us"	1 to: newLast do:		[:index |		array at: index put: (array at: index + delta).		array at: index + delta put: nil].	firstIndex := 1.	lastIndex := newLast! !!OrderedCollection methodsFor: 'private' stamp: 'BG 1/9/2004 12:28'!removeIndex: removedIndex  "  removedIndex is an index in the range firstIndex .. lastIndex, such an index is not known from outside the collection.    Never use this method in your code, it is meant for private use by OrderedCollection only.     The method for public use is:        #removeAt: "	array 		replaceFrom: removedIndex 		to: lastIndex - 1 		with: array 		startingAt: removedIndex+1.	array at: lastIndex put: nil.	lastIndex := lastIndex - 1.! !!OrderedCollection methodsFor: 'private' stamp: 'di 11/14/97 12:54'!reset	firstIndex := array size // 3 max: 1.	lastIndex := firstIndex - 1! !!OrderedCollection methodsFor: 'private' stamp: 'ar 4/16/1999 07:59'!resetTo: index	firstIndex := index.	lastIndex := firstIndex - 1! !!OrderedCollection methodsFor: 'private' stamp: 'di 11/14/97 12:54'!setCollection: anArray	array := anArray.	self reset! !!OrderedCollection methodsFor: 'private' stamp: 'apb 10/15/2000 18:10'!setContents: anArray	array := anArray.	firstIndex := 1.	lastIndex := array size.! !!OrderedCollection class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection := self new: aCollection size.	newCollection addAll: aCollection.	^newCollection"	OrderedCollection newFrom: {1. 2. 3}	{1. 2. 3} as: OrderedCollection	{4. 2. 7} as: SortedCollection"! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'apb 10/15/2000 22:02'!ofSize: n	"Create a new collection of size n with nil as its elements.	This method exists because OrderedCollection new: n creates an	empty collection,  not one of size n."	| collection |	collection := self new: n.	collection setContents: (collection collector).	^ collection! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'rej 11/26/2006 21:22'!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'rej 11/26/2006 21:22'!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'rej 11/26/2006 21:22'!cFailedCall	<primitive: 'primGetModuleName' module:'CFailModule'>	^ 'failed call'! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'rej 11/26/2006 21:22'!cRealExternalCallOrPrimitiveFailed	<primitive: 'primGetModuleName' module:'LargeIntegers'>	self primitiveFailed! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'rej 11/24/2006 18:24'!tearDown	World changed.	fileName notNil ifTrue: [FileDirectory default deleteFileNamed: fileName]! !!Paragraph methodsFor: 'accessing' stamp: 'di 10/5/97 15:33'!clippingRectangle: clipRect 	clippingRectangle := clipRect! !!Paragraph methodsFor: 'accessing'!compositionRectangle: compRectangle 	"Set the rectangle whose width is the dimension, modified by indents and 	tabsLevels, against which line wraparound is measured."	compositionRectangle := compRectangle.	self composeAll! !!Paragraph methodsFor: 'accessing'!fillColor: maskForm 	"Set the argument, maskForm, to be the form with which each character 	is combined by the scanner before applying the rule for display."	mask := maskForm! !!Paragraph methodsFor: 'accessing'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last reader leadingTabs lastSeparator cr tab ch |	cr := Character cr.	tab := Character tab.	arrayIndex := lineIndex.	[first := (lines at: arrayIndex) first.	 first > 1 and: [(text string at: first - 1) ~~ cr]] whileTrue: "word wrap"		[arrayIndex := arrayIndex - 1].	last := (lines at: lastLine) last.	reader := ReadStream on: text string from: first to: last.	leadingTabs := 0.	[reader atEnd not and: [(ch := reader next) == tab]]		whileTrue: [leadingTabs := leadingTabs + 1].	lastSeparator := first - 1 + leadingTabs.	[reader atEnd not and: [ch isSeparator and: [ch ~~ cr]]]		whileTrue: [lastSeparator := lastSeparator + 1. ch := reader next].	lastSeparator = last | (ch == cr)		ifTrue: [^aBlock value: leadingTabs].	^leadingTabs! !!Paragraph methodsFor: 'accessing' stamp: 'ar 5/18/2000 18:34'!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines := lines copy.	obsoleteLastLine := lastLine.	"find the starting and stopping lines"	firstLineIndex := startLine := self lineIndexOfCharacterIndex: start.	stopLine := self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange := aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle := compositionRectangle withHeight: (textStyle lineGrid * 9999).	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle := (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner := CompositionScanner new forParagraph: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex := (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine := compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine := startLine - 1.							self lineAt: startLine put: newLine.							startIndex := newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			displayBoolean ifTrue: [destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor].			self updateCompositionHeight.			^self]].	"Now we really get to it."	done := false.	lastLineIndex := stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine := compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop := (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY := self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY := self topAtLineIndex: firstLineIndex + 1.						stopLine := firstLineIndex.						done := true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex := lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex := firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex := lastLineIndex + 1]].		startIndex := newLine last + 1.		firstLineIndex := firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine := firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle :=				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'accessing'!rule: ruleInteger 	"Set the rule according to which character display behaves."	rule := ruleInteger! !!Paragraph methodsFor: 'accessing'!text: aText 	"Set the argument, aText, to be the text for the receiver."	text := aText.	self composeAll! !!Paragraph methodsFor: 'composition' stamp: 'yo 1/23/2003 22:47'!composeAll	"Compose a collection of characters into a collection of lines."	| startIndex stopIndex lineIndex maximumRightX compositionScanner |	lines := Array new: 32.	lastLine := 0.	maximumRightX := 0.	text size = 0		ifTrue:			[compositionRectangle := compositionRectangle withHeight: 0.			^maximumRightX].	startIndex := lineIndex := 1.	stopIndex := text size.	compositionScanner := MultiCompositionScanner new forParagraph: self.	[startIndex > stopIndex] whileFalse: 		[self lineAt: lineIndex 				put: (compositionScanner composeLine: lineIndex 										fromCharacterIndex: startIndex 										inParagraph: self).		 maximumRightX := compositionScanner rightX max: maximumRightX.		 startIndex := (lines at: lineIndex) last + 1.		 lineIndex := lineIndex + 1].	self updateCompositionHeight.	self trimLinesTo: lineIndex - 1.	^ maximumRightX! !!Paragraph methodsFor: 'composition'!wrappingBox: compositionRect clippingBox: clippingRect 	"Set the composition rectangle for the receiver so that the lines wrap 	within the rectangle, compositionRect, and the display of the text is 	clipped by the rectangle, clippingRect."	self compositionRectangle: compositionRect copy				text: text				style: textStyle				offset: offset.	clippingRectangle := clippingRect copy! !!Paragraph methodsFor: 'converting' stamp: 'yo 6/23/2003 19:05'!asForm	"Answer a Form made up of the bits that represent the receiver's displayable text."	| theForm oldBackColor oldForeColor |	textStyle isTTCStyle ifTrue: [		theForm :=  (Form extent: compositionRectangle extent depth: 32)		offset: offset.	] ifFalse: [		theForm := (ColorForm extent: compositionRectangle extent)			offset: offset;			colors: (Array				with: (backColor == nil ifTrue: [Color transparent] ifFalse: [backColor])				with: (foreColor == nil ifTrue: [Color black] ifFalse: [foreColor])).	].	oldBackColor := backColor.	oldForeColor := foreColor.	backColor := Color white.	foreColor := Color black.	self displayOn: theForm		at: 0@0		clippingBox: theForm boundingBox		rule: Form over		fillColor: nil.	backColor := oldBackColor.	foreColor := oldForeColor.	^ theForm"Example:| p |p := 'Abc' asParagraph.p foregroundColor: Color red backgroundColor: Color black.p asForm displayOn: Display at: 30@30 rule: Form over"! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"Default display message when aDisplayPoint is in absolute screen	coordinates."	rule := ruleInteger.	mask := aForm.	clippingRectangle := clipRectangle.	compositionRectangle := aDisplayPoint extent: compositionRectangle extent.	(lastLine == nil or: [lastLine < 1]) ifTrue: [self composeAll].	self displayOn: aDisplayMedium lines: (1 to: lastLine)! !!Paragraph methodsFor: 'scrolling' stamp: 'hmm 9/16/2000 21:30'!scrollBy: heightToMove withSelectionFrom: startBlock to: stopBlock 	"Translate the composition rectangle up (dy<0) by heightToMove.	Repainting text as necessary, and selection if blocks not nil.	Return true unless scrolling limits have been reached."	| max min amount |	max := 0 max: "cant scroll up more than dist to (top of) bottom line"		compositionRectangle bottom - textStyle lineGrid - clippingRectangle top.	min := 0 min: "cant scroll down more than top is above clipRect"		compositionRectangle top - clippingRectangle top.	amount := ((heightToMove truncateTo: textStyle lineGrid) min: max) max: min.	amount ~= 0		ifTrue: [destinationForm deferUpdatesIn: clippingRectangle while: [					self scrollUncheckedBy: amount						withSelectionFrom: startBlock to: stopBlock].				^ true]		ifFalse: [^ false]! !!Paragraph methodsFor: 'scrolling'!scrollUncheckedBy: heightToMove withSelectionFrom: startBlock to: stopBlock 	"Scroll by the given amount.  Copy bits where possible, display the rest.	If selection blocks are not nil, then select the newly visible text as well."	| savedClippingRectangle delta |	delta := 0 @ (0 - heightToMove).	compositionRectangle := compositionRectangle translateBy: delta.	startBlock == nil ifFalse:		[startBlock moveBy: delta.		stopBlock moveBy: delta].	savedClippingRectangle := clippingRectangle.	clippingRectangle := clippingRectangle intersect: Display boundingBox.	heightToMove abs >= clippingRectangle height	  ifTrue: 		["Entire visible region must be repainted"		self displayLines: (1 to: lastLine) affectedRectangle: clippingRectangle]	  ifFalse:		["Copy bits where possible / display the rest"		destinationForm			copyBits: clippingRectangle from: destinationForm			at: clippingRectangle topLeft + delta			clippingBox: clippingRectangle			rule: Form over fillColor: nil.		"Set clippingRectangle to 'vacated' area for lines 'pulled' into view."		clippingRectangle := heightToMove < 0			ifTrue:  "On the top"				[clippingRectangle topLeft corner: clippingRectangle topRight + delta]			ifFalse:  "At the bottom"				[clippingRectangle bottomLeft + delta corner: clippingRectangle bottomRight].		self displayLines: (1 to: lastLine)   "Refresh vacated region"			affectedRectangle: clippingRectangle].	startBlock == nil ifFalse:		[self reverseFrom: startBlock to: stopBlock].	"And restore the clippingRectangle to its original value. "	clippingRectangle := savedClippingRectangle! !!Paragraph methodsFor: 'selecting' stamp: 'ar 5/28/2000 12:10'!caretFormForDepth: depth	"Return a caret form for the given depth."	"(Paragraph new caretFormForDepth: Display depth) displayOn: Display at: 0@0 rule: Form reverse"	| box f bb map |	box := CaretForm boundingBox.	f := Form extent: box extent depth: depth.	map := (Color cachedColormapFrom: CaretForm depth to: depth) copy.	map at: 1 put: (Color transparent pixelValueForDepth: depth).	map at: 2 put: (Color quickHighLight: depth) first.  "pixel value for reversing"	bb := BitBlt current toForm: f.	bb		sourceForm: CaretForm;		sourceRect: box;		destOrigin: 0@0;		colorMap: map; 		combinationRule: Form over;		copyBits.	^ f! !!Paragraph methodsFor: 'selecting' stamp: 'dvf 10/1/2003 13:28'!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range box boxes |	action := false.	startBlock := self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex forStyle: textStyle) 		do: [:att | att mayActOnClick ifTrue:				[range := text rangeOf: att startingAt: startBlock stringIndex.				boxes := self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box := boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: box repeating: []					ifSucceed: [aController terminateAndInitializeAround:								[(att actOnClickFor: model in: self at: clickPoint editor: aController) ifTrue: [action := true]]]]].	^ action! !!Paragraph methodsFor: 'selecting' stamp: 'th 9/19/2002 17:27'!extendSelectionMark: markBlock pointBlock: pointBlock 	"Answer with an Array of two CharacterBlocks that represent the text 	selection that the user makes."	true 		ifTrue:[^self mouseMovedFrom: pointBlock					pivotBlock: markBlock					showingCaret:(pointBlock = markBlock)]		ifFalse:		[	| beginBlock endBlock |			beginBlock := markBlock min: pointBlock.			endBlock := markBlock max: endBlock.				(self characterBlockAtPoint: Sensor cursorPoint) <= beginBlock				ifTrue: [^self mouseMovedFrom: beginBlock 							pivotBlock: endBlock							showingCaret: (beginBlock = endBlock)]				ifFalse: [^self mouseMovedFrom: endBlock 							pivotBlock: beginBlock							showingCaret: (beginBlock = endBlock)]		]! !!Paragraph methodsFor: 'selecting' stamp: 'jm 7/1/1999 12:31'!hiliteRect: rect	| highlightColor |	highlightColor := Color quickHighLight: destinationForm depth.	rect ifNotNil: [		destinationForm			fill: rect			rule: Form reverse			fillColor: highlightColor.		"destinationForm			fill: (rect translateBy: 1@1)			rule: Form reverse			fillColor: highlightColor" ].! !!Paragraph methodsFor: 'selecting' stamp: 'jm 7/8/97 12:25'!mouseMovedFrom: beginBlock pivotBlock: pivotBlock showingCaret: caretOn 	| startBlock stopBlock showingCaret |	stopBlock := startBlock := beginBlock.	showingCaret := caretOn.	[Sensor redButtonPressed]		whileTrue: 			[stopBlock := self characterBlockAtPoint: Sensor cursorPoint.			stopBlock = startBlock				ifFalse: 					[showingCaret						ifTrue: 							[showingCaret := false.							self reverseFrom: pivotBlock to: pivotBlock].			((startBlock >= pivotBlock and: [stopBlock >= pivotBlock])				or: [startBlock <= pivotBlock and: [stopBlock <= pivotBlock]])				ifTrue: 					[self reverseFrom: startBlock to: stopBlock.					startBlock := stopBlock]				ifFalse: 					[self reverseFrom: startBlock to: pivotBlock.					self reverseFrom: pivotBlock to: stopBlock.					startBlock := stopBlock].			(clippingRectangle containsRect: stopBlock) ifFalse:				[stopBlock top < clippingRectangle top				ifTrue: [self scrollBy: stopBlock top - clippingRectangle top						withSelectionFrom: pivotBlock to: stopBlock]				ifFalse: [self scrollBy: stopBlock bottom + textStyle lineGrid - clippingRectangle bottom						withSelectionFrom: pivotBlock to: stopBlock]]]].	pivotBlock = stopBlock ifTrue:		[showingCaret ifFalse:  "restore caret"			[self reverseFrom: pivotBlock to: pivotBlock]].	^ Array with: pivotBlock with: stopBlock! !!Paragraph methodsFor: 'selecting'!mouseSelect	"Answer with an Array of two CharacterBlocks that represent the text 	selection that the user makes.  Return quickly if the button is noticed up	to make double-click more responsive."	| pivotBlock startBlock stopBlock origPoint stillDown |	stillDown := Sensor redButtonPressed.	pivotBlock := startBlock := stopBlock :=		self characterBlockAtPoint: (origPoint := Sensor cursorPoint).	stillDown := stillDown and: [Sensor redButtonPressed].	self reverseFrom: startBlock to: startBlock.	[stillDown and: [Sensor cursorPoint = origPoint]] whileTrue:		[stillDown := Sensor redButtonPressed].	(stillDown and: [clippingRectangle containsPoint: Sensor cursorPoint])		ifFalse: [^Array with: pivotBlock with: stopBlock].	^ self mouseMovedFrom: startBlock 		pivotBlock: pivotBlock		showingCaret: true! !!Paragraph methodsFor: 'selecting'!mouseSelect: clickPoint 	"Track text selection and answer with an Array of two CharacterBlocks."	| startBlock |	startBlock := self characterBlockAtPoint: clickPoint.	self reverseFrom: startBlock to: startBlock.	^ self mouseMovedFrom: startBlock 		pivotBlock: startBlock		showingCaret: true! !!Paragraph methodsFor: 'selecting'!reverseFrom: characterBlock1 to: characterBlock2 	"Reverse area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline caret |	characterBlock1 = characterBlock2 ifTrue:		[lineNo := self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline := lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		caret := self caretFormForDepth: Display depth.		^ caret  "Use a caret to indicate null selection"				displayOn: destinationForm				at: characterBlock1 topLeft + (-3 @ baseline)				clippingBox: clippingRectangle				rule: (false "Display depth>8" ifTrue: [9 "not-reverse"]									ifFalse: [Form reverse])				fillColor: nil].	visibleRectangle := 		(clippingRectangle intersect: compositionRectangle)			"intersect: destinationForm boundingBox" "not necessary".	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle := 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle := 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle := 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle := 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle := 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle := 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle := 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle := 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle := 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle := 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	self hiliteRect: initialRectangle.	self hiliteRect: interiorRectangle.	self hiliteRect: finalRectangle.! !!Paragraph methodsFor: 'selecting' stamp: 'di 12/1/97 04:43'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline |	characterBlock1 = characterBlock2 ifTrue:		[lineNo := self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline := lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		^ Array with: (characterBlock1 topLeft extent: 1 @ baseline)].	visibleRectangle := clippingRectangle intersect: compositionRectangle.	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle := 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle := 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle := 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle := 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle := 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle := 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle := 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle := 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle := 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle := 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	^ (Array with: initialRectangle with: interiorRectangle with: finalRectangle)			select: [:rect | rect notNil]! !!Paragraph methodsFor: 'utilities'!deepCopy	"Don't want to copy the destForm (Display) or fonts in the TextStyle.  9/13/96 tk"	| new |	new := self copy.	new textStyle: textStyle copy.	new destinationForm: destinationForm.	new lines: lines copy.	new text: text deepCopy.	^ new! !!Paragraph methodsFor: 'utilities'!destinationForm: destForm	destinationForm := destForm! !!Paragraph methodsFor: 'utilities'!fit	"Make the bounding rectangle of the receiver contain all the text without 	changing the width of the receiver's composition rectangle."	[(self lineIndexOfTop: clippingRectangle top) = 1]		whileFalse: [self scrollBy: (0-1)*textStyle lineGrid].	self updateCompositionHeight.	clippingRectangle := clippingRectangle withBottom: compositionRectangle bottom! !!Paragraph methodsFor: 'utilities'!lines: lineArray	lines := lineArray! !!Paragraph methodsFor: 'private'!bottomAtLineIndex: lineIndex 	"Answer the bottom y of given line."	| y |	y := compositionRectangle top.	lastLine = 0 ifTrue: [^ y + textStyle lineGrid].	1 to: (lineIndex min: lastLine) do:		[:i | y := y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private' stamp: 'tk 9/30/96'!compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint	compositionRectangle := compositionRect copy.	text := aText.	textStyle := aTextStyle.	rule := DefaultRule.	mask := nil.		"was DefaultMask "	marginTabsLevel := 0.	destinationForm := Display.	offset := aPoint.	^self composeAll! !!Paragraph methodsFor: 'private' stamp: 'yo 1/23/2003 22:48'!displayLines: linesInterval affectedRectangle: affectedRectangle	"This is the first level workhorse in the display portion of the TextForm routines.	It checks to see which lines in the interval are actually visible, has the	CharacterScanner display only those, clears out the areas in which display will	occur, and clears any space remaining in the visibleRectangle following the space	occupied by lastLine."	| lineGrid topY firstLineIndex lastLineIndex lastLineIndexBottom |	"Save some time by only displaying visible lines"	firstLineIndex := self lineIndexOfTop: affectedRectangle top.	firstLineIndex < linesInterval first ifTrue: [firstLineIndex := linesInterval first].	lastLineIndex := self lineIndexOfTop: affectedRectangle bottom - 1.	lastLineIndex > linesInterval last ifTrue:			[linesInterval last > lastLine		 		ifTrue: [lastLineIndex := lastLine]		  		ifFalse: [lastLineIndex := linesInterval last]].	lastLineIndexBottom := (self bottomAtLineIndex: lastLineIndex).	((Rectangle 		origin: affectedRectangle left @ (topY := self topAtLineIndex: firstLineIndex) 		corner: affectedRectangle right @ lastLineIndexBottom)	  intersects: affectedRectangle)		ifTrue: [ " . . . (skip to clear-below if no lines displayed)"				MultiDisplayScanner new					displayLines: (firstLineIndex to: lastLineIndex)					in: self clippedBy: affectedRectangle].	lastLineIndex = lastLine ifTrue: 		 [destinationForm  "Clear out white space below last line"		 	fill: (affectedRectangle left @ (lastLineIndexBottom max: affectedRectangle top)				corner: affectedRectangle bottomRight)		 	rule: rule fillColor: self backgroundColor]! !!Paragraph methodsFor: 'private'!displayOn: aDisplayMedium lines: lineInterval	| saveDestinationForm |	saveDestinationForm := destinationForm.	destinationForm := aDisplayMedium.	self displayLines: lineInterval.	destinationForm := saveDestinationForm! !!Paragraph methodsFor: 'private'!leftMarginForCompositionForLine: lineIndex 	"Build the left margin for composition of a line. Depends upon	marginTabsLevel and the indent."	| indent |	lineIndex = 1		ifTrue: [indent := textStyle firstIndent]		ifFalse: [indent := textStyle restIndent].	^indent + (textStyle leftMarginTabAt: marginTabsLevel)! !!Paragraph methodsFor: 'private' stamp: 'ar 12/15/2001 23:29'!leftMarginForDisplayForLine: lineIndex alignment: alignment	"Build the left margin for display of a line. Depends upon	leftMarginForComposition, compositionRectangle left and the alignment."	| pad |	(alignment = LeftFlush or: [alignment = Justified])		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex)].	"When called from character location code and entire string has been cut,	there are no valid lines, hence following nil check."	(lineIndex <= lines size and: [(lines at: lineIndex) notNil])		ifTrue: 			[pad := (lines at: lineIndex) paddingWidth]		ifFalse: 			[pad := 				compositionRectangle width - textStyle firstIndent - textStyle rightIndent].	alignment = Centered 		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + (pad // 2)].	alignment = RightFlush 		ifTrue:			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + pad].	self error: ['no such alignment']! !!Paragraph methodsFor: 'private'!lineAt: indexInteger put: aTextLineInterval 	"Store a line, track last, and grow lines if necessary."	indexInteger > lastLine ifTrue: [lastLine := indexInteger].	lastLine > lines size ifTrue: [lines := lines , (Array new: lines size)].	^lines at: indexInteger put: aTextLineInterval! !!Paragraph methodsFor: 'private'!lineIndexOfTop: top 	"Answer the line index at a given top y."	| y line |	lastLine = 0 ifTrue: [^ 1].	y := compositionRectangle top.	1 to: lastLine do:		[:i | line := lines at: i.		(y := y + line lineHeight) > top ifTrue: [^ i]].	^ lastLine! !!Paragraph methodsFor: 'private'!moveBy: delta	compositionRectangle := compositionRectangle translateBy: delta.	clippingRectangle := clippingRectangle translateBy: delta.! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle 	"Set text and adjust bounding rectangles to fit."	| shrink compositionWidth unbounded |	unbounded := Rectangle origin: 0 @ 0 extent: 9999@9999.	compositionWidth := self		setWithText: aText style: aTextStyle compositionRectangle: unbounded clippingRectangle: unbounded.	compositionRectangle := compositionRectangle withWidth: compositionWidth.	clippingRectangle := compositionRectangle copy.	shrink := unbounded width - compositionWidth.	"Shrink padding widths accordingly"	1 to: lastLine do:		[:i | (lines at: i) paddingWidth: (lines at: i) paddingWidth - shrink]! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect 	"Set text and using supplied parameters. Answer max composition width."	clippingRectangle := clipRect copy.	^self		compositionRectangle: compRect		text: aText		style: aTextStyle		offset: 0 @ 0! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect foreColor: cf backColor: cb	"Set text and using supplied parameters. Answer max composition width."	clippingRectangle := clipRect copy.	self foregroundColor: cf backgroundColor: cb.	^ self		compositionRectangle: compRect		text: aText		style: aTextStyle		offset: 0 @ 0! !!Paragraph methodsFor: 'private'!topAtLineIndex: lineIndex 	"Answer the top y of given line."	| y |	y := compositionRectangle top.	lastLine = 0 ifTrue: [lineIndex > 0 ifTrue: [^ y + textStyle lineGrid]. ^ y].	1 to: (lineIndex-1 min: lastLine) do:		[:i | y := y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private'!topAtLineIndex: lineIndex using: otherLines and: otherLastLine	"Answer the top y of given line."	| y |	y := compositionRectangle top.	otherLastLine = 0 ifTrue: [^ y].	1 to: (lineIndex-1 min: otherLastLine) do:		[:i | y := y + (otherLines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private'!trimLinesTo: lastLineInteger	(lastLineInteger + 1 to: lastLine) do: [:i | lines at: i put: nil].	(lastLine := lastLineInteger) < (lines size // 2) 		ifTrue: [lines := lines copyFrom: 1 to: lines size - (lines size // 2)]! !!Paragraph methodsFor: 'private'!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work." 	compositionRectangle := compositionRectangle withHeight:		(self bottomAtLineIndex: lastLine) - compositionRectangle top.	(text size ~= 0 and: [(text at: text size) = CR])		ifTrue: [compositionRectangle := compositionRectangle withHeight:					compositionRectangle height + (lines at: lastLine) lineHeight]! !!Paragraph methodsFor: 'private' stamp: 'di 8/30/97 11:14'!withClippingRectangle: clipRect do: aBlock	| saveClip |	saveClip := clippingRectangle.	clippingRectangle := clipRect.		aBlock value.	clippingRectangle := saveClip! !!Paragraph class methodsFor: 'examples' stamp: 'tk 9/30/96'!example	"This simple example illustrates how to display a few lines of text on the screen at the current cursor point.  	Fixed. "	| para point |	point := Sensor waitButton.	para := 'This is the first line of charactersand this is the second line.' asParagraph.	para displayOn: Display at: point.	"Paragraph example"! !!Paragraph class methodsFor: 'instance creation'!withText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect foreColor: c1 backColor: c2	"Answer an instance of me with text set to aText and style set to 	aTextStyle, composition rectangle is compRect and the clipping rectangle 	is clipRect."	| para |	para := super new.	para setWithText: aText		style: aTextStyle		compositionRectangle: compRect		clippingRectangle: clipRect		foreColor: c1 backColor: c2.	^para! !!ParagraphEditor methodsFor: 'do-its' stamp: 'ab 5/22/2007 11:28'!tallyIt	^ self tallySelection! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'ktt 11/28/2005 12:16'!backspace: characterStream 	"Backspace over the last character."	| startIndex |	sensor leftShiftDown ifTrue: [^ self backWord: characterStream].	startIndex := self markIndex + (self hasCaret ifTrue: [0] ifFalse: [1]).	[sensor keyboardPressed and:			 [sensor keyboardPeek asciiValue = 8]] whileTrue: [				"process multiple backspaces"				sensor keyboard.				startIndex := 1 max: startIndex - 1.			].	self backTo: startIndex.			^false! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'edc 4/13/2007 16:42'!yellowButtonExpertMenu	^ MenuMorph fromArray: {			{'set font... (k)' translated.				#offerFontMenu}.			{'set style... (K)' translated.				#changeStyle}.			{'set alignment... (u)' translated.		#chooseAlignment}.			#-.			{'make project link (P)' translated.	#makeProjectLink}.			#-.			{'find...(f)' translated.					#find}.			{'find again (g)' translated.				#findAgain}.			{'set search string (h)' translated.		#setSearchString}.			#-.			{'do again (j)' translated.				#again}.			{'undo (z)' translated.					#undo}.			#-.			{'copy (c)' translated.					#copySelection}.			{'cut (x)' translated.						#cut}.			{'paste (v)' translated.					#paste}.			{'paste...' translated.					#pasteRecent}.			#-.			{'do it (d)' translated.		#doIt}.			     		{'print it (p)' translated.		#printIt}.		     		{'inspect it (i)' translated.		#inspectIt}.		     		{'explore it (I)' translated.		#exploreIt}.		     		{'debug it' translated.			#debugIt}.		     		{'tally it' translated.			#tallyIt}.			#-.			{'accept (s)' translated.					#accept}.			{'cancel (l)' translated.					#cancel}.			#-.			{'show bytecodes' translated.			#showBytecodes}.			#-.			{'copy html' translated.					#copyHtml}.			#-.			{'more...' translated.					#shiftedTextPaneMenuRequest}.		}.! !!ParameterTile methodsFor: 'access' stamp: 'sw 3/15/2005 22:36'!rowOfRightTypeFor: aLayoutMorph forActor: aPlayer	"Answer a phrase of the right type for the putative container"	| aTemporaryViewer aPhrase |	aLayoutMorph demandsBoolean ifTrue:		[aTemporaryViewer := CategoryViewer new invisiblySetPlayer: aPlayer.		aPhrase := aTemporaryViewer booleanPhraseFromPhrase: self.		aPhrase justGrabbedFromViewer: false.		^ aPhrase].	^ self! !!ParameterTile methodsFor: 'access' stamp: 'sw 1/18/2004 22:12'!scriptEditor	"Answer the receiver's script editor.  The slightly strange code here is in order to contend with the unusual situation where a parameter tile obtained from one script editor is later dropped into a different script editor.  As long as the parameter tile is *in* a script editor, that containing scriptEditor is the one; if it is *not*, then we use the last known one"	| aScriptEditor |	^ (aScriptEditor := self outermostMorphThat: [:m | m isKindOf: ScriptEditorMorph])		ifNotNil:			[scriptEditor := aScriptEditor]		ifNil:			[scriptEditor]! !!ParameterTile methodsFor: 'code generation' stamp: 'yo 12/20/2003 02:49'!storeCodeOn: aStream indent: tabCount	"Store code on the stream" 	| myTypeString |	myTypeString := self resultType.	(self scriptEditor hasParameter and: [self scriptEditor typeForParameter = myTypeString])		ifTrue:			[aStream nextPutAll: 'parameter']		ifFalse:			["This script no longer bears a parameter, yet there's an orphaned Parameter tile in it"			aStream nextPutAll: '(self defaultValueOfType: #', myTypeString, ')']! !!ParameterTile methodsFor: 'initialization' stamp: 'yo 3/14/2005 08:01'!forScriptEditor: aScriptEditor	"Make the receiver be associated with the given script editor"	scriptEditor := aScriptEditor.	self line1: aScriptEditor typeForParameter translated.! !!ParameterTile methodsFor: 'miscellaneous' stamp: 'sw 3/15/2005 22:37'!booleanComparatorPhrase	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase rel retrieverType |	retrieverType := self resultType.	rel := (Vocabulary vocabularyForType: retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	outerPhrase firstSubmorph addMorph: self.	outerPhrase submorphs last addMorph: (ScriptingSystem tileForArgType: retrieverType).	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!ParseNode methodsFor: '*eToys-tiles' stamp: 'ab 7/13/2004 13:47'!addCommentToMorph: aMorph	| row |	(self comment isNil or: [self comment isEmpty]) ifTrue: [^ self].	row := aMorph addTextRow:		(String streamContents: [:strm | self printCommentOn: strm indent: 1]).	row firstSubmorph color: (SyntaxMorph translateColor: #comment).	row parseNode: (self as: CommentNode).! !!ParseNode methodsFor: '*eToys-tiles' stamp: 'RAA 8/24/1999 12:24'!asMorphicSyntaxIn: parent	| morph |	"Default for missing implementations"	morph := parent addColumn: #error on: self.	morph addTextRow: self class printString.	^morph	! !!Parser methodsFor: 'error correction' stamp: 'rr 10/3/2007 09:58'!removeUnusedTemps	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| str end start madeChanges | 	madeChanges _ false.	str _ requestor text string.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp |		(encoder encodeVariable: temp) isUndefTemp			ifTrue:			[(UIManager default 				confirm: (temp , ' appears to be\unused in this method.\OK to remove it?') withCRs)				ifTrue: [end _ tempsMark.						["Beginning at right temp marker..."						start _ end - temp size + 1.						end < temp size or: [temp = (str copyFrom: start to: end)							and: [(str at: start-1) isAlphaNumeric not & (str at: end+1) isAlphaNumeric not]]]						whileFalse: ["Search left for the unused temp"									end _ requestor nextTokenFrom: end direction: -1].						end < temp size ifFalse:						[(str at: start-1) = $  ifTrue: [start _ start-1].						requestor correctFrom: start to: end with: ''.						str _ str copyReplaceFrom: start to: end with: ''. 						madeChanges _ true.						tempsMark _ tempsMark - (end-start+1)]]]].	madeChanges ifTrue: [ParserRemovedUnusedTemps signal]! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:48'!addPragma: aPragma	self properties addPragma: aPragma! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47'!pragmaLiteral	"Read a pragma literal."	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])		ifTrue: [ ^ self advance ].	(here == $# and: [ tokenType == #word ])		ifTrue: [ ^ self advance ].	(here == #- and: [ tokenType == #number ])		ifTrue: [ ^ (self advance; advance) negated ].	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])		ifTrue: [ ^ Compiler evaluate: self advance ].	^ self expected: 'Literal constant'! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 10:04'!pragmaPrimitives	| pragmas primitives |	self properties pragmas isEmpty		ifTrue: [ ^ 0 ].	pragmas := Pragma allNamed: #primitive from: self class to: Parser.	primitives := self properties pragmas select: [ :prim |		pragmas anySatisfy: [ :prag | 			prag selector = prim keyword ] ].	primitives isEmpty 		ifTrue: [ ^ 0 ].	primitives size = 1 		ifFalse: [ ^ self notify: 'Ambigous primitives' ].	^ primitives first message sendTo: self! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47'!pragmaSequence	"Parse a sequence of method pragmas."		[ true ] whileTrue: [		(self matchToken: #<)			ifFalse: [ ^ self ].		self pragmaStatement.		(self matchToken: #>)			ifFalse: [ ^ self expected: '>' ] ]! !!Parser methodsFor: 'pragmas' stamp: 'lr 8/19/2006 20:39'!pragmaStatement	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."		| selector arguments words index keyword |	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])		ifFalse: [  ^ self expected: 'pragma declaration' ].	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "	(here = #apicall: or: [ here = #cdecl: ])		ifTrue: [ ^ self externalFunctionDeclaration ].	selector := String new.	arguments := OrderedCollection new.	words := OrderedCollection new.	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [		index := self startOfNextToken + requestorOffset.		selector := selector , self advance.		words add: (index to: self endOfLastToken + requestorOffset).		(selector last = $: or: [ selector first isLetter not ])			ifTrue: [ arguments add: self pragmaLiteral ] ].	selector numArgs ~= arguments size		ifTrue: [ ^ self expected: 'pragma argument' ].	(Symbol hasInterned: selector 		ifTrue: [ :value | keyword := value]) 		ifFalse: [ 			keyword := self 				correctSelector: selector wordIntervals: words				exprInterval: (words first first to: words last last)				ifAbort: [ ^ self fail ] ].	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).	^ true! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47'!properties	^ properties ifNil: [ properties := MethodProperties new ]! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:50'!primitive: anIntegerOrString	"Create indexed primitive."		<primitive>	^ anIntegerOrString isInteger		ifTrue: [ anIntegerOrString ]		ifFalse: [ 			anIntegerOrString isString				ifTrue: [ self primitive: anIntegerOrString module: nil ]				ifFalse: [ self expected: 'Indexed primitive' ] ]! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:51'!primitive: aNameString module: aModuleStringOrNil	"Create named primitive."		<primitive>	(aNameString isString and: [ aModuleStringOrNil isNil or: [ aModuleStringOrNil isString ] ])		ifFalse: [ ^ self expected: 'Named primitive' ].	self allocateLiteral: (Array 		with: (aModuleStringOrNil isNil 			ifFalse: [ aModuleStringOrNil asSymbol ])		with: aNameString asSymbol		with: 0 with: 0).	^ 117! !!PartsBin methodsFor: '*BabySRE-connectors-initialization' stamp: 'edc 12/4/2007 16:01'!listDirection: aListDirection quadList: quadList buttonClass: buttonClass	"Initialize the receiver to run horizontally or vertically, obtaining its elements from the list of tuples of the form:		(<receiver> <selector> <label> <balloonHelp>)"	| aButton aClass |	self layoutPolicy: TableLayout new.	self listDirection: aListDirection.	self wrapCentering: #topLeft.	self layoutInset: 2.	self cellPositioning: #bottomCenter.	aListDirection == #leftToRight		ifTrue:			[self vResizing: #rigid.			self hResizing: #spaceFill.			self wrapDirection: #topToBottom]		ifFalse:			[self hResizing: #rigid.			self vResizing: #spaceFill.			self wrapDirection: #leftToRight].	quadList do:		[:tuple |			aClass _ Smalltalk at: tuple first.			aButton _ buttonClass new .			aButton color: self color;		initializeToShow: (self class thumbnailForQuad: tuple) withLabel:  tuple third andSend: tuple second to: aClass.			(tuple size > 3 and: [tuple fourth isEmptyOrNil not]) ifTrue:				[aButton setBalloonText: tuple fourth]. 			self addMorphBack: aButton].! !!PasteUpMorph methodsFor: 'world state' stamp: 'wiz 12/4/2006 00:32'!paintArea	"What rectangle should the user be allowed to create a new painting in??	An area beside the paintBox. Allow playArea to override with its own	bounds!! "	| playfield paintBoxBounds |	playfield := self				submorphNamed: 'playfield'				ifNone: [].	playfield		ifNotNil: [^ playfield bounds].	paintBoxBounds := self paintBox bounds.	self firstHand targetPoint x < paintBoxBounds center x		ifTrue: [^ bounds topLeft corner: paintBoxBounds left @ bounds bottom"paint on left side"]		ifFalse: [^ paintBoxBounds right @ bounds top corner: bounds bottomRight]! !!PasteUpMorph methodsFor: '*eToys-customevents-scripting' stamp: 'nk 9/26/2003 23:20'!userCustomEventNames	| reg |	reg := self valueOfProperty: #userCustomEventsRegistry ifAbsent: [ ^#() ].	^reg keys asArray sort! !!PasteUpMorphTest methodsFor: 'tests' stamp: 'wiz 7/19/2007 10:56'!testPlayWithMe1Romoval	"A trivial test for checking that PlayWithMe classes are all removed"	self deny: ( Smalltalk hasClassNamed: 'PlayWithMe1' ) .! !!Path methodsFor: 'accessing'!form	"Answer the receiver's form, or, if form is nil, then answer a 1 x 1 black 	form (a black dot)."	| aForm |	form == nil		ifTrue: 			[aForm := Form extent: 1 @ 1.			aForm fillBlack.			^aForm]		ifFalse: 			[^form]! !!Path methodsFor: 'accessing'!form: aForm 	"Make the argument, aForm, be the receiver's form."	form := aForm! !!Path methodsFor: 'display box access'!computeBoundingBox 	"Refer to the comment in DisplayObject|computeBoundingBox."	| box |	box := Rectangle origin: (self at: 1) extent: 0 @ 0.	collectionOfPoints do: 		[:aPoint | box := box merge: (Rectangle origin: aPoint extent: 0 @ 0)].	^box! !!Path methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle rule: ruleInteger fillColor: aForm 	"Displays this path, translated and scaled by aTransformation. Get the	scaled and translated Path."	| newPath transformedPath |	transformedPath := displayTransformation applyTo: self.	newPath := Path new.	transformedPath do: [:point | newPath add: point].	newPath form: self form.	newPath		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRectangle		rule: ruleInteger		fillColor: aForm! !!Path methodsFor: 'enumerating'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect the resulting values into a path that is like the receiver. Answer 	the new path."	| newCollection |	newCollection := collectionOfPoints collect: aBlock.	newCollection form: self form.	^newCollection! !!Path methodsFor: 'enumerating'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new path like the receiver only those elements for which 	aBlock evaluates to true. Answer the new path."	| newCollection |	newCollection := collectionOfPoints select: aBlock.	newCollection form: self form.	^newCollection! !!Path methodsFor: 'transforming' stamp: 'jrm 9/1/1999 21:26'!scaleBy: aPoint 	"Answers a new Path scaled by aPoint. Does not affect the current data in 	this Path."	| newPath | 	newPath := self species new: self size. 	newPath form: self form.	collectionOfPoints do: [:element | newPath add: (element scaleBy: aPoint)].	^newPath! !!Path methodsFor: 'transforming' stamp: 'jrm 9/1/1999 21:28'!translateBy: aPoint 	"Answers a new Path whose elements are translated by aPoint. Does not	affect the elements of this Path."	| newPath |	newPath := self species new: self size.	newPath form: self form.	collectionOfPoints do: [:element | newPath add: (element translateBy: aPoint)].	^newPath! !!Path methodsFor: 'private'!initializeCollectionOfPoints	collectionOfPoints := OrderedCollection new! !!Path methodsFor: 'private'!initializeCollectionOfPoints: anInteger	collectionOfPoints := OrderedCollection new: anInteger! !!Path class methodsFor: 'examples'!example	"Creates a Path from mousePoints and displays it several ways on the display screen. Messes up the display. For learning about class Path, just select the code below and execute it to create a path and see it redisplayed in another place on the screen. Each path displays using a different form. A path is indicated by pressing the red mouse button in a sequence; press any other mouse button to terminate. "	| aPath aForm pl fl flag |	aForm := Form extent: 2 @ 40.		"creates a form one inch long"	aForm fillBlack.							"turns it black"	aPath := Path new.	aPath form: aForm.						"use the long black form for displaying"	flag := true.	[flag]		whileTrue: 			[Sensor waitButton.			Sensor redButtonPressed				ifTrue: 					[aPath add: Sensor waitButton.					Sensor waitNoButton.					aForm displayOn: Display at: aPath last]				ifFalse: [flag := false]].	Display fillWhite.	aPath displayOn: Display.			"the original path"	pl := aPath translateBy: 0 @ 100.	fl := Form extent: 40 @ 40.	fl fillGray.	pl form: fl.	pl displayOn: Display.				"the translated path"	Sensor waitNoButton	"Path example"! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 12/13/2001 17:41'!rowOfRightTypeFor: aLayoutMorph forActor: aPlayer	"Answer a phrase of the right type for the putative container"	| aTemporaryViewer aPhrase |	aLayoutMorph demandsBoolean ifTrue:		[self isBoolean ifTrue: [^ self].		aTemporaryViewer := CategoryViewer new invisiblySetPlayer: aPlayer.		aPhrase := aTemporaryViewer booleanPhraseFromPhrase: self.		aPhrase justGrabbedFromViewer: false.		^ aPhrase].	^ self! !!PhraseTileMorph methodsFor: 'dropping/grabbing' stamp: 'sw 2/9/2001 00:15'!justDroppedInto: newOwner event: evt	"Phrase tiles only auto-expand if they originate from viewers.  Any phrase tile, once dropped, loses its auto-phrase-expansion thing"	justGrabbedFromViewer := false.	super justDroppedInto: newOwner event: evt! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'sw 8/28/2004 14:23'!initialize	"Initialize a nascent instance"	super initialize.	resultType := #unknown.	brightenedOnEnter := false.	self wrapCentering: #center; cellPositioning: #leftCenter.	self hResizing: #shrinkWrap.	borderWidth := 0.	self layoutInset: 0.	self extent: 5@5.  "will grow to fit"	self minCellSize: (0 @ (Preferences standardEToysFont height rounded + 10)).	justGrabbedFromViewer := true.  "All new PhraseTileMorphs that go through the initialize process (rather than being copied) are placed in viewers; the clones dragged out from them will thus have this set the right way; the drop code resets this to false"! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 6/18/2004 16:01'!setAngleToOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaAngleToTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'sw 10/29/1998 16:01'!setAssignmentRoot: opSymbol type: opType rcvrType: rcvrType argType: argType	resultType := opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	self addMorphBack: ((AssignmentTileMorph new setRoot: opSymbol asString dataType: argType) typeColor: color).	self addMorphBack: (TilePadMorph new setType: argType)! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'sw 8/12/2004 18:58'!setAssignmentRoot: opSymbol type: opType rcvrType: rcvrType argType: argType vocabulary: aVocabulary	"Add submorphs to make me constitute a setter of the given symbol"	| anAssignmentTile |	resultType := opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	anAssignmentTile := AssignmentTileMorph new rawVocabulary: aVocabulary.	self addMorphBack: (anAssignmentTile typeColor: color).	anAssignmentTile setRoot: opSymbol asString dataType: argType.	anAssignmentTile setAssignmentSuffix: #:.	self addMorphBack: (TilePadMorph new setType: argType)! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 9/28/2004 18:24'!setBounceOnColorOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaBounceOnColorTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 9/27/2004 14:58'!setBounceOnOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaBounceOnTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 10/12/2004 22:43'!setColorComponentRoot: opSymbol componentName: componentName type: opType rcvrType: rcvrType argType: argType vocabulary: aVocabulary	"Add submorphs to make me constitute a setter of the given symbol"	| anAssignmentTile |	resultType := opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	anAssignmentTile := KedamaSetColorComponentTile new rawVocabulary: aVocabulary.	anAssignmentTile componentName: componentName.	self addMorphBack: (anAssignmentTile typeColor: color).	anAssignmentTile setRoot: opSymbol asString dataType: argType.	self addMorphBack: (TilePadMorph new setType: argType)! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 6/18/2004 16:01'!setDistanceToOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaDistanceToTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 1/30/2005 11:02'!setGetColorComponentOperator: opSymbol componentName: componentName type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaGetColorComponentTile new adoptVocabulary: self currentVocabulary.	aTileMorph componentName: componentName.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 6/18/2004 16:50'!setGetPixelOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaGetPixelValueTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'sw 9/26/2001 11:58'!setOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := TileMorph new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 6/18/2004 16:02'!setPixelValueRoot: opSymbol type: opType rcvrType: rcvrType argType: argType vocabulary: aVocabulary	"Add submorphs to make me constitute a setter of the given symbol"	| anAssignmentTile |	resultType := opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	anAssignmentTile := KedamaSetPixelValueTile new rawVocabulary: aVocabulary.	self addMorphBack: (anAssignmentTile typeColor: color).	anAssignmentTile setRoot: opSymbol asString dataType: argType.	self addMorphBack: (TilePadMorph new setType: argType)! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'sw 9/27/2001 17:41'!setSlotRefOperator: opSymbol type: opType	"Set the given symbol as the receiver's slot-reference operator, adding tiles to the receiver appropriately"	resultType := opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: #Player).	self addMorphBack: ((TileMorph new setSlotRefOperator: opSymbol asString) typeColor: color)! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 10/9/2004 15:38'!setTurtleAtOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaTurtleAtTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 3/7/2005 08:39'!setTurtleOfOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaTurtleOfTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 6/18/2004 16:02'!setUpHillOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaUpHillTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'macpal' stamp: 'sw 6/4/2001 19:35'!currentVocabulary	"Answer the current vocabulary"	vocabulary "fix up old strutures"		ifNotNil: 			[vocabularySymbol := vocabulary vocabularyName.			vocabulary := nil].	^ vocabularySymbol		ifNotNil:			[Vocabulary vocabularyNamed: vocabularySymbol]		ifNil:			[super currentVocabulary]! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'tk 8/6/1999 13:59'!associatedPlayer	"Answer the player that's the object of my attention"	| pp |	pp := self firstSubmorph.	[pp isKindOf: PhraseTileMorph] whileTrue: [pp := pp firstSubmorph].	^ pp firstSubmorph actualObject! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'sw 12/22/2004 01:34'!dismissViaHalo	"The user has clicked in the delete halo-handle.."	| ed |	ed := self topEditor.	super dismissViaHalo.	ed ifNotNil: [ed scriptEdited]! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'sw 1/19/2001 15:06'!justGrabbedFromViewer	"Answer whether the receiver originated in a Viewer.  Only tiles that originated in a viewer will ever do that infernal sprouting of a new script around them.  The nil branch is only for backward compatibility."	^ justGrabbedFromViewer ifNil: [justGrabbedFromViewer := true]! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'sw 1/19/2001 14:25'!justGrabbedFromViewer: aBoolean	"Set the receiver's justGrabbedFromViewer instance variable"	justGrabbedFromViewer := aBoolean! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'tk 2/14/2001 14:07'!sproutNewScriptor	"The receiver, operating as a naked phrase tile, wishes to get iself placed in a nascent script"	| newScriptor |	self actualObject assureUniClass.	newScriptor := self actualObject newScriptorAround:		((self ownerThatIsA: Viewer orA: ScriptEditorMorph)			ifNotNil:				[self veryDeepCopy]			ifNil:				[self]).	self currentHand attachMorph: newScriptor! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'yo 4/4/2005 17:15'!try	"Evaluate the given phrase once"	| aPlayer |	(userScriptSelector notNil and: [userScriptSelector numArgs = 0])		ifTrue:			[aPlayer := self objectViewed player.			aPlayer triggerScript: userScriptSelector]		ifFalse:			[Compiler evaluate:				self codeString				for: self associatedPlayer				logged: false]! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'sw 1/29/98 01:49'!userScriptSelector: s	userScriptSelector := s! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'tak 3/15/2005 11:40'!catchDivideByZero: aStream indent: tabCount 	"See if I am have divide as my operator. If so, insert a test in the argument to divide."	| exp |	submorphs second type = #operator ifFalse: [^false].	"not me"	exp := submorphs second operatorOrExpression.	(#(/ // \\) includes: exp) ifFalse: [^false].	"not me"	aStream space.	aStream nextPutAll: '(self beNotZero: '.	(submorphs third) storeCodeOn: aStream indent: tabCount.	aStream nextPut: $).	^true! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'tak 4/6/2005 14:20'!morphToDropInPasteUp: aPasteUp	"Answer the morph to drop in aPasteUp, given that the receiver is the putative droppee"	| actualObject itsSelector aScriptor pos aWatcher op |	((actualObject := self actualObject) isNil or: [actualObject costume isInWorld not]) ifTrue: [^ self].	self isCommand ifFalse:  "Can't expand to a scriptor, but maybe launch a watcher..."		[^ (Preferences dropProducesWatcher and: [(#(unknown command) includes: self resultType) not] and:			[(op := self operatorTile operatorOrExpression) notNil] and: [op numArgs = 0] and: [(Vocabulary gettersForbiddenFromWatchers includes: op) not])			ifTrue:				[aWatcher := WatcherWrapper new fancyForPlayer: self associatedPlayer getter: op.				aWatcher position: self position]			ifFalse:				[self]].	self justGrabbedFromViewer ifFalse: [^ self].	actualObject assureUniClass.	itsSelector := self userScriptSelector.	pos := self position.	aScriptor := itsSelector isEmptyOrNil		ifFalse:			[actualObject scriptEditorFor: itsSelector]		ifTrue:			["It's a system-defined selector; construct an anonymous scriptor around it"			actualObject newScriptorAround: self].	aScriptor ifNil:[^self].	(self hasOwner: aScriptor) ifTrue:[		aScriptor fullBounds. "force layout"		aScriptor position: pos - self position.	] ifFalse:[		aScriptor position: self position.	].	^ aScriptor! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'sw 6/17/2003 16:03'!mouseDown: evt 	"Handle a mouse-down on the receiver"	| ed guyToTake dup enclosingPhrase |	self isPartsDonor ifTrue:		[dup := self duplicate.		dup eventHandler: nil.   "Remove viewer-related evt mouseover feedback"		evt hand attachMorph: dup.		dup position: evt position.		"So that the drag vs. click logic works"		dup formerPosition: evt position.		^ self].	submorphs isEmpty		ifTrue: [^ self].	guyToTake := self.	[(enclosingPhrase := guyToTake ownerThatIsA: PhraseTileMorph) notNil] whileTrue:		[guyToTake := enclosingPhrase].  "This logic always grabs the outermost phrase, for now anyway"		"the below had comment: 'picking me out of another phrase'"	"owner class == TilePadMorph		ifTrue:			[(ss := submorphs first) class == TilePadMorph				ifTrue: [ss := ss submorphs first].			guyToTake :=  ss veryDeepCopy]."	(ed := self enclosingEditor) ifNil: [^ evt hand grabMorph: guyToTake].	evt hand grabMorph: guyToTake.	ed startStepping.	ed mouseEnterDragging: evt.	ed setProperty: #justPickedUpPhrase toValue: true.! !!PhraseTileMorph methodsFor: 'queries' stamp: 'nk 7/8/2000 13:35'!isCommand	"Answer whether the receiver is a true line of phrase-command. If not,  	it is a fragment that will not be able to serve as a line of script on its  	own"	| rcvrTile pad |	submorphs isEmpty		ifTrue: [^ false].	pad := submorphs first.	(pad isKindOf: TilePadMorph)		ifTrue: [(submorphs second isKindOf: AssignmentTileMorph)				ifTrue: [^ true].			(((rcvrTile := pad submorphs first) isKindOf: TileMorph)					and: [rcvrTile isPossessive])				ifTrue: [^ false]].	^ true! !!PhraseTileMorph methodsFor: 'kedama' stamp: 'sw 10/24/2005 02:48'!duplicate	"Make and return a duplicate of the receiver."	| newMorph |	newMorph := super duplicate.	(self ownerThatIsA: Viewer) ifNotNilDo:		[:aViewer | newMorph replacePlayerInReadoutWith: aViewer scriptedPlayer].	^ newMorph! !!PhraseTileMorph methodsFor: 'kedama' stamp: 'yo 4/3/2005 17:36'!morphsBearingPlayers	| c |	c := OrderedCollection new.	self allMorphsWithPlayersDo: [:e :p | c add: e].	^ c asArray.! !!PhraseTileMorph methodsFor: 'kedama' stamp: 'yo 4/6/2005 14:59'!replacePlayerInReadoutWith: aPlayer 	| tile |	tile := self firstMorphBearingKedamaPlayer.	tile ifNil: [^ self].	(tile isMemberOf: TileMorph) ifFalse: [^ self].	tile type = #objRef ifFalse: [^ self].	tile referToSimilarObject: aPlayer.	self allMorphsDo: [:e |		((e isMemberOf: UpdatingStringMorph) or: [e isMemberOf: UpdatingRectangleMorph]) ifTrue: [			e target isPlayerLike ifTrue: [				e target: aPlayer			].		].	].! !!PhraseTileMorph class methodsFor: 'backward compatibility' stamp: 'sw 1/19/2001 22:25'!markViewerOrigination	"For bringing old content forward"	| hadIt gotIt didntWantIt |	hadIt := 0.	gotIt := 0.	didntWantIt := 0.	self allSubInstancesDo:		[:m | (m ownerThatIsA: CategoryViewer)			ifNil:				[m justGrabbedFromViewer: false.				didntWantIt := didntWantIt + 1]			ifNotNil:				[(m justGrabbedFromViewerOrNil == true)					ifTrue:						[hadIt := hadIt + 1]					ifFalse:						[m justGrabbedFromViewer: true.						gotIt := gotIt + 1]]].	Transcript cr; show: 'updating phrase tiles -- already ok: '; show: hadIt; show: '  marked as in-viewer: '; show: gotIt; show: '  marked as not-in-viewer: '; show: didntWantIt.	"PhraseTileMorph markViewerOrigination"! !!Player methodsFor: 'copying' stamp: 'tk 1/8/2001 10:38'!copyUniClassWith: deepCopier	"my class is a subclass of Player.  Return another class just like my class.  Share the costume list."	| newCls |	newCls := self class officialClass 		newUniqueClassInstVars: self class instanceVariablesString 		classInstVars: self class class instanceVariablesString.	newCls copyMethodDictionaryFrom: self class.	newCls class copyMethodDictionaryFrom: self class class.	newCls scripts: self class privateScripts.	"duplicate this in mapUniClasses"	newCls slotInfo: (self class privateSlotInfo veryDeepCopyWith: deepCopier).	newCls copyAddedStateFrom: self class.  "All class inst vars for inter Player refs"	^ newCls! !!Player methodsFor: 'copying' stamp: 'sw 9/15/1998 13:12'!initializeCostumesFrom: aPlayer	"Used to copy costume info over from an UnscriptedPlayer to a Player UniClass"	costume := aPlayer costume.	costumes := aPlayer costumes! !!Player methodsFor: 'copying' stamp: 'tk 9/4/2001 11:10'!veryDeepFixupWith: deepCopier	| old |	"Any uniClass inst var may have been weakly copied.  If they were in the tree being copied, fix them up, otherwise point to the originals."super veryDeepFixupWith: deepCopier.Player instSize + 1 to: self class instSize do:	[:ii | old := self instVarAt: ii.	self instVarAt: ii put: (deepCopier references at: old ifAbsent: [old])].! !!Player methodsFor: 'copying' stamp: 'tk 9/5/2001 09:43'!veryDeepInner: deepCopier	"Special code that handles user-added instance variables of a uniClass.	Copy all of my instance variables.  Some need to be not copied at all, but shared.  This is special code for the dictionary.  See DeepCopier."	| instVar weak subAss |	super veryDeepInner: deepCopier.	"my own instance variables are completely normal"	costume := costume veryDeepCopyWith: deepCopier.	costumes := costumes veryDeepCopyWith: deepCopier.	Player instSize + 1 to: self class instSize do: [:index |		instVar := self instVarAt: index.		weak := instVar isMorph | instVar isPlayerLike. 		(subAss := deepCopier references associationAt: instVar ifAbsent: [nil])				"use association, not value, so nil is an exceptional value"			ifNil: [weak ifFalse: [					self instVarAt: index put: (instVar veryDeepCopyWith: deepCopier)]]			ifNotNil: [self instVarAt: index put: subAss value].		].! !!Player methodsFor: 'costume' stamp: 'sw 9/30/2004 04:29'!ceaseHavingAParameterFor: aSelector	"Make the script represented by aSelector cease bearing a parameter"	| newSel |	self renameScript: aSelector newSelector: (newSel := (aSelector copyWithout: $:) asSymbol).	(self scriptEditorFor: newSel) assureParameterTilesValid; install! !!Player methodsFor: 'costume' stamp: 'sw 7/18/2002 11:26'!changeParameterTypeFor: aSelector	"Change the parameter type for the given selector.  Not currently sent, since types are now set by direct manipulation in the Scriptor header.  If this were reinstated someday, there would probably be an issue about getting correct-looking Parameter tile(s) into the Scriptor header(s)"	| current typeChoices typeChosen |	current := self typeforParameterFor: aSelector.	typeChoices := Vocabulary typeChoices.	typeChosen := (SelectionMenu selections: typeChoices lines: #()) startUpWithCaption: 		('Choose the TYPEfor the parameter (currently ', current, ')').	self setParameterFor: aSelector toType: typeChosen! !!Player methodsFor: 'costume' stamp: 'sw 4/7/1999 21:20'!costumeRespondingTo: aSelector	"Answer a costume that responds to the given selector, or nil if none"	| aMorph |	((aMorph := self costume renderedMorph) respondsTo: aSelector) ifTrue: [^ aMorph].	costumes isEmptyOrNil ifFalse:		[costumes do: [:aCostume | (aCostume respondsTo: aSelector) ifTrue: [^ aCostume]]].	^ nil "usually an error will result"! !!Player methodsFor: 'costume' stamp: 'sw 8/17/1998 15:39'!getValueFromCostume: aSelector	| aCostume |	(aCostume := self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 10/24/1998 21:48'!newCostume	| aMenu reply |	aMenu := SelectionMenu selections: self availableCostumeNames.	(reply := aMenu startUpWithCaption: 'choose a costume') ifNil: [^ self].	self wearCostumeOfName: reply.	self updateAllViewers! !!Player methodsFor: 'costume' stamp: 'sw 8/20/1998 17:35'!rawCostume: aMorph	costume := aMorph! !!Player methodsFor: 'costume' stamp: 'nk 6/12/2004 10:02'!rememberCostume: aCostume	"Put aCostume in my remembered-costumes list, as the final element"	| costumeToRemember existing |	costumeToRemember := aCostume renderedMorph.		"Remember real morphs, not their transformations"	costumes ifNil: [costumes := OrderedCollection new].	existing := (costumeToRemember isSketchMorph)		ifTrue:			[self knownSketchCostumeWithSameFormAs: costumeToRemember]		ifFalse:			[costumes detect: [:c | c == costumeToRemember] ifNone: [nil]].	costumes := costumes copyWithout: existing.	costumes addLast: costumeToRemember! !!Player methodsFor: 'costume' stamp: 'sw 12/12/2001 14:13'!renderedCostume: aMorph remember: rememberCostume	"Make aMorph be the receiver's rendered costume; if flexing is currently in effect, make the new morph be flexed correspondingly"	| renderedMorph known anEventHandler w baseGraphic |	renderedMorph := costume renderedMorph.	renderedMorph == aMorph ifTrue: [^ self].	baseGraphic := costume renderedMorph valueOfProperty: #baseGraphic.	rememberCostume		ifTrue: [self rememberCostume: renderedMorph].	renderedMorph changed.	w := renderedMorph world.	"Copy 'player state' (e.g., state which should be associated with the player but is stored in the morph itself these days) from the old rendered morph the new morph."	aMorph rotationStyle: renderedMorph rotationStyle.	aMorph forwardDirection: renderedMorph forwardDirection.	"Note: referencePosition is *not* state but #moveTo: behavior"	aMorph referencePosition: renderedMorph referencePosition.	anEventHandler := renderedMorph eventHandler.	costume isFlexMorph		ifTrue:			[costume adjustAfter:				[costume replaceSubmorph: renderedMorph by: aMorph]]		ifFalse:			[costume owner ifNotNil: [costume owner replaceSubmorph: costume by: aMorph].			aMorph player: self.			aMorph actorState: costume actorState.			(known := costume knownName) ifNotNil:				[aMorph setNameTo: known].			costume := aMorph.			w ifNotNil:				[w stopStepping: renderedMorph.				w startStepping: aMorph]].	baseGraphic ifNotNil: [self setBaseGraphic: baseGraphic].	aMorph eventHandler: anEventHandler.	aMorph changed! !!Player methodsFor: 'costume' stamp: 'sw 8/3/2000 10:16'!resetCostumeList	costumes := nil! !!Player methodsFor: 'costume' stamp: 'nk 6/12/2004 10:02'!restoreBaseGraphic	"Restore my base graphic"	| cos |	((cos := self costume renderedMorph) isSketchMorph)		ifTrue:			[cos restoreBaseGraphic]! !!Player methodsFor: 'costume' stamp: 'sw 10/26/1998 15:55'!sendMessageToCostume: aSelector	| aCostume |	(aCostume := self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 10/26/1998 15:54'!sendMessageToCostume: aSelector with: arg	| aCostume |	(aCostume := self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector with: arg].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 8/17/1998 15:45'!setCostumeSlot: setterSelector toValue: aValue	| aCostume |	(aCostume := self costumeRespondingTo: setterSelector) ifNotNil:		[aCostume perform: setterSelector with: aValue]! !!Player methodsFor: 'costume' stamp: 'sw 7/22/2002 17:44'!setParameterFor: aSelector toType: aTypeSymbol	"Set the parameter type for the given selector"	| aUniclassScript |	aTypeSymbol isEmptyOrNil ifTrue: [^ self].	(self typeforParameterFor: aSelector) = aTypeSymbol ifTrue: [^ self].	aUniclassScript := self class scripts at: aSelector.	aUniclassScript argumentVariables first variableType: aTypeSymbol.	aUniclassScript currentScriptEditorDo:		[:aScriptEditor | aScriptEditor assureParameterTilesValid].	self updateAllViewersAndForceToShow: #scripts	! !!Player methodsFor: 'costume' stamp: 'sw 9/30/2004 04:49'!startHavingParameterFor: aSelector	"Start having a parameter for the given selector.  After this change, the script name will change by the addition of a colon."	| newSelector |	self renameScript: aSelector newSelector: (newSelector := (aSelector, ':') asSymbol).	(self scriptEditorFor: newSelector) install! !!Player methodsFor: 'costume' stamp: 'sw 3/11/2003 00:32'!tearOffButtonToFireScriptForSelector: aSelector	"Tear off a button to fire the script for the given selector"	| aButton props |	Preferences useButtonProprtiesToFire ifFalse:		[aButton := ScriptActivationButton new.		aButton initializeForPlayer: self uniclassScript:  (self class scripts at: aSelector).		^ aButton openInHand].	(aButton := RectangleMorph new) useRoundedCorners; color: Color yellow.	props := aButton ensuredButtonProperties.	props		target: self;		actionSelector: #runScript:;		arguments: {aSelector};		delayBetweenFirings: 80;		actWhen: #mouseUp;		mouseDownHaloWidth: 8;		wantsRolloverIndicator: true;		mouseOverHaloWidth: 5;		establishEtoyLabelWording.	aButton width: aButton submorphs first width + 20; height: 20.	self currentHand attachMorph: aButton.! !!Player methodsFor: 'costume' stamp: 'sw 12/3/1998 10:05'!wearCostumeOfClass: aClass	"Assume that the costume in the library has player = nil"	| newCostume |	(costume renderedMorph isKindOf: aClass) ifTrue: [^ self].	costumes ifNotNil:		[costumes do:			[:aCostume | (aCostume class  == aClass)				ifTrue:					[^ self renderedCostume: aCostume]]].	newCostume := aClass new.	self renderedCostume: newCostume! !!Player methodsFor: 'costume' stamp: 'sw 2/20/98 00:32'!wearCostumeOfName: aName	| classToUse |	classToUse := Smalltalk at: (aName, 'Morph') asSymbol ifAbsent: 		[Smalltalk at: aName asSymbol].	self wearCostumeOfClass: classToUse! !!Player methodsFor: 'customevents-costume' stamp: 'nk 9/24/2003 17:33'!costume: aMorph	"Make aMorph be the receiver's current costume"	| itsBounds |	costume == aMorph ifTrue: [^ self].	costume ifNotNil:		[self rememberCostume: costume renderedMorph.		itsBounds := costume bounds.		(costume ownerThatIsA: HandMorph orA: PasteUpMorph) replaceSubmorph: costume topRendererOrSelf by: aMorph.		aMorph position: itsBounds origin.		aMorph actorState: costume actorStateOrNil.		aMorph setNameTo: costume externalName].	aMorph player: self.	costume := aMorph.	aMorph arrangeToStartStepping! !!Player methodsFor: 'customevents-misc' stamp: 'nk 9/24/2003 18:26'!noteDeletionOf: aMorph fromWorld: aWorld	"aMorph, while pointing to me as its costumee, has been deleted"	"This may be too aggressive because deletion of a morph may not really mean deletion of its associated player -- in light of hoped-for multiple viewing"	| viewers scriptors viewerFlaps |	viewers := OrderedCollection new.	viewerFlaps := OrderedCollection new.	scriptors := OrderedCollection new.	aWorld allMorphs do:		[:m | m isAViewer ifTrue: [viewers add: m].			((m isKindOf: ViewerFlapTab) and: [m scriptedPlayer == self])				ifTrue:					[viewerFlaps add: m].			((m isKindOf: ScriptEditorMorph) and: [m myMorph == aMorph])				ifTrue: [scriptors add: m]].	aMorph  removeAllEventTriggersFor: self.	aWorld removeAllEventTriggersFor: self.	viewers do: [:v |  v noteDeletionOf: aMorph].	viewerFlaps do: [:v  | v dismissViaHalo].	scriptors do: [:s | s privateDelete] ! !!Player methodsFor: 'customevents-scripts-kernel' stamp: 'nk 9/24/2003 17:36'!instantiatedUserScriptsDo: aBlock	"Evaluate aBlock on behalf of all the instantiated user scripts in the receiver"	| aState aCostume |	((aCostume := self costume) notNil and: [(aState := aCostume actorStateOrNil) notNil]) ifTrue:		[aState instantiatedUserScriptsDictionary do: aBlock]! !!Player methodsFor: 'customevents-scripts-kernel' stamp: 'nk 8/18/2004 17:40'!pacifyScript: aSymbol	"Make sure the script represented by the symbol doesn't do damage by lingering in related structures on the morph side"	| aHandler aUserScript |	aUserScript := self class userScriptForPlayer: self selector: aSymbol.	aUserScript ifNil: [self flag: #deferred.  ^ Beeper beep].  	"Maddeningly, without this line here the thing IS nil and the debugger is in a bad state	(the above note dates from 1/12/99 ?!!"	self class allInstancesDo:		[:aPlayer | | itsCostume |		aPlayer actorState instantiatedUserScriptsDictionary removeKey: aSymbol ifAbsent: [].		itsCostume := aPlayer costume renderedMorph.		(aHandler := itsCostume eventHandler) ifNotNil:			[aHandler forgetDispatchesTo: aSymbol].		itsCostume removeEventTrigger: aSymbol ]! !!Player methodsFor: 'error handling' stamp: 'tk 11/21/2000 16:17'!doesNotUnderstand: aMessage 	 | ours |"See it the message is a special setter that has not been defined.  Define it and try again."	ours := false.	(aMessage selector endsWith: 'IncreaseBy:') ifTrue: [ours := true].	(aMessage selector endsWith: 'DecreaseBy:') ifTrue: [ours := true].	(aMessage selector endsWith: 'MultiplyBy:') ifTrue: [ours := true].	ours ifFalse: [^ super doesNotUnderstand: aMessage].	(self addSpecialSetter: aMessage selector) ifFalse: ["not our inst var"		^ super doesNotUnderstand: aMessage].	^ aMessage sentTo: self! !!Player methodsFor: 'heading' stamp: 'jm 4/24/1998 22:30'!headDown	| radians |	radians := (self getHeadingUnrounded - 90.0) degreesToRadians.	self setHeading:		((radians cos @ radians sin abs) theta radiansToDegrees			roundTo: 0.001) + 90.0.! !!Player methodsFor: 'heading' stamp: 'jm 4/24/1998 22:30'!headLeft	| radians |	radians := (self getHeadingUnrounded - 90.0) degreesToRadians.	self setHeading:		((radians cos abs negated @ radians sin) theta radiansToDegrees			roundTo: 0.001) + 90.0.! !!Player methodsFor: 'heading' stamp: 'jm 4/24/1998 22:30'!headRight	| radians |	radians := (self getHeadingUnrounded - 90.0) degreesToRadians.	self setHeading:		((radians cos abs @ radians sin) theta radiansToDegrees			roundTo: 0.001) + 90.0.! !!Player methodsFor: 'heading' stamp: 'jm 4/24/1998 22:30'!headUp	| radians |	radians := (self getHeadingUnrounded - 90.0) degreesToRadians.	self setHeading:		((radians cos @ radians sin abs negated) theta radiansToDegrees			roundTo: 0.001) + 90.0.! !!Player methodsFor: 'misc' stamp: 'nk 8/18/2004 16:43'!adoptScriptsFrom	"Let the user click on another object form which the receiver should obtain scripts and code"	| aMorph |	Sensor waitNoButton.	aMorph := ActiveWorld chooseClickTarget.	aMorph ifNil: [^ Beeper beep].	(((aMorph isSketchMorph) and: [aMorph player belongsToUniClass]) and: [self belongsToUniClass not])		ifTrue:			[costume acquirePlayerSimilarTo: aMorph player]		ifFalse:			[Beeper beep]! !!Player methodsFor: 'misc' stamp: 'sw 7/4/2004 00:20'!arrowDeltaFor: aGetSelector	"Answer the arrowDelta to use in conjunction with a readout for aGetSelector, which will be of the form 'getXXX'"	costume ifNotNil:		[^ costume renderedMorph arrowDeltaFor: aGetSelector].	^ 1		"For the future, possibly:  If we want the SlotInformation for a user-defined slot to be able to specify a standard arrowDelta for that slot, we'd include something like the following... 	| aSlotName slotInfo |	aSlotName := Utilities inherentSelectorForGetter: aGetSelector.	(slotInfo := self slotInfoAt: aSlotName ifAbsent: [nil]) ifNotNil:		[^ slotInfo arrowDelta]."! !!Player methodsFor: 'misc' stamp: 'sw 3/17/2005 00:47'!beNotZero: aNumber	"This is a runtime check if the arg to divide in a script is zero.  If it is, put up a warning message.  Return 0.001 instead of 0.  Note the time.  If fails again within 1 min., don't tell the user again."	aNumber = 0 ifFalse: [^ aNumber].	"normal case"	"We have a problem"	TimeOfError 		ifNil: [TimeOfError := Time totalSeconds]		ifNotNil: [(Time totalSeconds - TimeOfError) > 45 ifTrue: [			TimeOfError := Time totalSeconds.	"in case user interrupt and reenter"			self inform: 'Dividing by zero makes a number toolarge for even a Sorcerer to handle.Please change your script.' translated.			TimeOfError := Time totalSeconds]].	^ 0.001! !!Player methodsFor: 'misc' stamp: 'sw 3/20/2001 12:21'!browseEToyVocabulary	"Open a protocol browser on the receiver, showing its etoy vocabulary"	| littleMe | 	littleMe := self assureUniClass.	(InstanceBrowser new useVocabulary: Vocabulary eToyVocabulary) openOnObject: littleMe  inWorld: ActiveWorld showingSelector: nil! !!Player methodsFor: 'misc' stamp: 'sw 7/4/2004 00:29'!defaultFloatPrecisionFor: aGetSelector	"Answer the float position to use in conjunction with a readout for aGetSelector, which will be of the form 'getXXX'"	| aSlotName slotInfo |	aSlotName := Utilities inherentSelectorForGetter: aGetSelector.	(slotInfo := self slotInfoAt: aSlotName ifAbsent: [nil]) ifNotNil:		[^ slotInfo floatPrecision].	self costume ifNotNil:		[^ self costume renderedMorph defaultFloatPrecisionFor: aGetSelector].	^ 1! !!Player methodsFor: 'misc' stamp: 'ka 3/25/2004 05:25'!grabPlayerIn: aWorld	"Invoked from a Viewer: rip my morph out of its container, wherever that may be, and place it in the hand, being careful to set things up so that if the subsequent drop is rejected, the morph will end up in a visible location on the screen"	| aMorph newPosition |	self costume == aWorld ifTrue: [^ self].	ActiveHand releaseMouseFocus.	(aMorph := self costume) visible: true.	newPosition := ActiveHand position - (aMorph extent // 2).	aMorph isInWorld		ifTrue:			[aMorph goHome.			aMorph formerPosition: aMorph positionInWorld]		ifFalse:			[aMorph formerPosition: aWorld center].	aMorph formerOwner: ActiveWorld.	aMorph position: newPosition.	ActiveHand targetOffset: aMorph position - ActiveHand position.	ActiveHand addMorphBack: aMorph.! !!Player methodsFor: 'misc' stamp: 'nk 6/12/2004 10:01'!impartSketchScripts	"Let the user designate another object to which my scripts and code should be imparted"	| aMorph |	Sensor waitNoButton.	aMorph := ActiveWorld chooseClickTarget.	aMorph ifNil: [^ self].	(aMorph renderedMorph isSketchMorph) ifTrue:		[aMorph acquirePlayerSimilarTo: self]! !!Player methodsFor: 'misc' stamp: 'sw 7/28/2001 01:03'!indicateLocationOnScreen	"Give momentary feedback on screen until mouse button is clicked"	| bds |	bds := self costume boundsInWorld.	5 timesRepeat:		[Display reverse: bds.		(Delay forMilliseconds: 80) wait.		Display reverse: bds.		(Delay forMilliseconds: 200) wait.].	costume changed! !!Player methodsFor: 'misc' stamp: 'sw 10/6/2004 11:17'!offerAlternateViewerMenuFor: aViewer event: evt	"Put up an alternate Viewer menu on behalf of the receiver."	| aMenu aWorld  |	aWorld := aViewer world.	aMenu := MenuMorph new defaultTarget: self.	costumes ifNotNil:		[(costumes size > 1 or: [costumes size == 1 and: [costumes first ~~ costume renderedMorph]])			ifTrue:				[aMenu add: 'forget other costumes' translated target: self selector: #forgetOtherCostumes]].	aMenu add: 'expunge empty scripts' translated target: self action: #expungeEmptyScripts.	aMenu addLine.	aMenu add: 'choose vocabulary...' translated target: aViewer action: #chooseVocabulary.	aMenu balloonTextForLastItem: 'Choose a different vocabulary for this Viewer.' translated.	aMenu add: 'choose limit class...' translated target: aViewer action: #chooseLimitClass.	aMenu balloonTextForLastItem: 'Specify what the limitClass should be for this Viewer -- i.e., the most generic class whose methods and categories should be considered here.' translated.	aMenu add: 'open standard lexicon' translated target: aViewer action: #openLexicon.	aMenu balloonTextForLastItem: 'open a window that shows the code for this object in traditional programmer format' translated.	aMenu add: 'open lexicon with search pane' translated target: aViewer action: #openSearchingProtocolBrowser.	aMenu balloonTextForLastItem: 'open a lexicon that has a type-in pane for search (not recommended!!)' translated.	aMenu addLine.	aMenu add: 'inspect morph' translated target: costume selector: #inspect.	aMenu add: 'inspect player' translated target: self selector: #inspect.	self belongsToUniClass ifTrue:		[aMenu add: 'browse class' translated target: self action: #browsePlayerClass.		aMenu add: 'inspect class' translated target: self class action: #inspect].	aMenu add: 'inspect this Viewer' translated target: aViewer selector: #inspect.	aMenu add: 'inspect this Vocabulary' translated target: aViewer currentVocabulary selector: #inspect.	aMenu addLine.	aMenu add: 'relaunch this Viewer' translated target: aViewer action: #relaunchViewer.	aMenu add: 'attempt repairs' translated target: ActiveWorld action: #attemptCleanup.	aMenu add: 'view morph directly' translated target: aViewer action: #viewMorphDirectly.	aMenu balloonTextForLastItem: 'opens a Viewer directly on the rendered morph.' translated.	(costume renderedMorph isSketchMorph) ifTrue:		[aMenu addLine.		aMenu add: 'impart scripts to...' translated target: self action: #impartSketchScripts].	aMenu popUpEvent: evt in: aWorld! !!Player methodsFor: 'misc' stamp: 'dgd 4/4/2006 16:25'!offerViewerMenuFor: aViewer event: evt	"Put up the Viewer menu on behalf of the receiver.  If the shift key is held down, put up the alternate menu. The menu omits the 'add a new variable' item when in eToyFriendly mode, as per request from teachers using Squeakland in 2003 once the button for adding a new variable was added to the viewer"	| aMenu aWorld  |	(evt notNil and: [evt shiftPressed] and: [Preferences eToyFriendly not]) ifTrue:[		^ self offerAlternateViewerMenuFor: aViewer event: evt	].	aWorld := aViewer world.	aMenu := MenuMorph new defaultTarget: self.	aMenu title: self externalName.	aMenu addStayUpItem.	self costume renderedMorph offerCostumeViewerMenu: aMenu.	Preferences eToyFriendly ifFalse: "exclude this from squeakland-like UI "		[aMenu add: 'add a new variable' translated target: self action: #addInstanceVariable.		aMenu balloonTextForLastItem: 'Add a new variable to this object and all of its siblings.  You will be asked to supply a name for it.' translated].	aMenu add: 'add a new script' translated target: aViewer action: #newPermanentScript.	aMenu balloonTextForLastItem: 'Add a new script that will work for this object and all of its siblings' translated.	aMenu addLine.	self hasCostumeThatIsAWorld ifFalse:[		aMenu add: 'grab me' translated target: self selector: #grabPlayerIn: argument: aWorld.		aMenu balloonTextForLastItem: 'This will actually pick up the object this Viewer is looking at, and hand it to you.  Click the (left) button to drop it' translated.	].	aMenu add: 'reveal me' translated target: self selector: #revealPlayerIn: argument: aWorld.	aMenu balloonTextForLastItem: 'If you have misplaced the object that this Viewer is looking at, use this item to (try to) make it visible' translated.	aMenu addLine.	aMenu add: 'tile representing me' translated action: #tearOffTileForSelf.	aMenu add: 'add search pane' translated target: aViewer action: #addSearchPane.	Preferences eToyFriendly ifFalse:[		aMenu addLine.		aMenu add: 'more...' translated target: self selector: #offerAlternateViewerMenuFor:event: argumentList: {aViewer. evt}.	].	aMenu popUpEvent: evt in: aWorld! !!Player methodsFor: 'misc' stamp: 'sw 10/27/2000 06:38'!ordinalNumber	"Answer a number indicating the relative position of the receiver in its stack, if any, else 1"	| aStack |	^ (aStack := self stack) ifNotNil: [aStack cardIndexOf: self] ifNil: [nil]! !!Player methodsFor: 'misc' stamp: 'sw 7/28/2001 01:05'!revealPlayerIn: aWorld	"Reveal the receiver if at all possible in the world; once it's visible, flash its image for a bit, and leave it with its halo showing"	| aMorph |	(aMorph := self costume) isInWorld ifTrue:		[aMorph goHome.		self indicateLocationOnScreen.		aMorph addHalo.		^ self].	"It's hidden somewhere; search for it"	aWorld submorphs do:		[:m | (m succeededInRevealing: self) ifTrue:  "will have obtained halo already"			[aWorld doOneCycle.			self indicateLocationOnScreen.			^ self]].	"The morph is truly unreachable in this world at present.  So extract it from hyperspace, and place it at center of screen, wearing a halo."	aMorph isWorldMorph ifFalse:		[aWorld addMorphFront: aMorph.		aMorph position: aWorld bounds center.		aMorph addHalo]		! !!Player methodsFor: 'misc' stamp: 'yo 8/15/2005 18:08'!tileReferringToSelf	"answer a tile that refers to the receiver"	| aTile  nn tile |	Preferences universalTiles ifTrue:		[nn := self externalName. 	"name it, if necessary, and put in References"		(References includesKey: nn asSymbol) ifFalse: [			 References at: nn asSymbol put: self].		tile := SyntaxMorph new parseNode: 			(VariableNode new name: nn key: nn code: nil).		tile layoutInset: 1; addMorph: (tile addString: nn special: false).		tile color: (SyntaxMorph translateColor: #variable).		tile extent: tile firstSubmorph extent + (2@2).		^ tile].	aTile := TileMorph new setToReferTo: self.	aTile updateWordingToMatchVocabulary.	^ aTile! !!Player methodsFor: 'misc' stamp: 'sw 9/6/2002 13:11'!touchesA: aPrototypicalPlayer	"Answer whether the receiver overlaps any player who wears a Sketch costume and who is of the same class as the prototypicalPlayer and who is wearing the same bitmap, but who is *not that player itself*!!  This is an extreme case of a function highly customized (by Bob Arning) to suit a single, idiosycratic, and narrow demo need of Alan's.  Consult:http://groups.yahoo.com/group/squeak/message/40560"	| envelope trueNeighbor trueGoal trueSelf itsPlayer |	aPrototypicalPlayer ifNil: [^ false].	envelope := costume owner ifNil: [^ false].	trueSelf := costume renderedMorph.	trueGoal := aPrototypicalPlayer costume renderedMorph.	envelope submorphs do: [:each |		trueNeighbor := each renderedMorph.		(trueNeighbor == trueGoal or: [trueNeighbor == trueSelf]) ifFalse:			[(itsPlayer := each player) ifNotNil:				[(itsPlayer overlaps: self) ifTrue:					[(trueGoal appearsToBeSameCostumeAs: trueNeighbor) ifTrue: [^ true]]]]].	^ false! !!Player methodsFor: 'misc' stamp: 'dgd 9/1/2003 14:17'!unusedScriptName	"answer a name of the form 'scriptN', where N is one higher than the highest-numbered similarly-named script"	| highestThus aPair |	highestThus := 0.	self class tileScriptNames do:		[:aName |			aPair := (aName copyWithout: $:) stemAndNumericSuffix.			aPair first = 'script' translated ifTrue: [highestThus := highestThus max: aPair last]].	^ ('script' translated, (highestThus + 1) printString) asSymbol! !!Player methodsFor: 'misc' stamp: 'sw 1/19/2001 15:35'!updateAllViewers	"The receiver's structure has changed, so viewers on it and its siblings need to be reconstituted."	| aPresenter |	(aPresenter := self costume presenter) ifNil: [^ self].	self allOpenViewersOnReceiverAndSiblings do:		[:aViewer | aPresenter updateViewer: aViewer]! !!Player methodsFor: 'misc' stamp: 'sw 1/19/2001 15:36'!updateAllViewersAndForceToShow: aCategory	"The receiver's structure has changed, so viewers on it and all its siblings need to be reconstituted."	| aPresenter |	(aPresenter := self costume presenter) ifNil: [^ self].	self allOpenViewersOnReceiverAndSiblings do:		[:aViewer | aPresenter updateViewer: aViewer forceToShow: aCategory]! !!Player methodsFor: 'pen' stamp: 'nk 6/12/2004 10:00'!addPlayerMenuItemsTo: aMenu hand: aHandMorph	"Note that these items are primarily available in another way in an object's Viewer"	| subMenu |	subMenu := MenuMorph new defaultTarget: self.	self getPenDown		ifTrue: [subMenu add: 'lift pen' action: #liftPen]		ifFalse: [subMenu add: 'lower pen' action: #lowerPen].	subMenu add: 'choose pen size...' action: #choosePenSize.	subMenu add: 'choose pen color...' action: #choosePenColor:.	aMenu add: 'pen...' subMenu: subMenu.	(costume renderedMorph isSketchMorph) ifTrue:		[self belongsToUniClass			ifFalse: 				[aMenu add: 'adopt scripts from...' target: self action: #adoptScriptsFrom]			ifTrue:				[aMenu add: 'impart scripts to...' target: self action: #impartSketchScripts]]! !!Player methodsFor: 'pen' stamp: 'sw 11/28/2000 09:03'!setPenDown: penDown	"Set the penDown state as indicated, to true or false"	| morph trailMorph tfm |	self actorState setPenDown: penDown.	((morph := self costume) notNil and: [(trailMorph := morph trailMorph) notNil])		ifTrue:		[tfm := morph owner transformFrom: trailMorph.		trailMorph notePenDown: penDown forPlayer: self					at: (tfm localPointToGlobal: morph referencePosition)]! !!Player methodsFor: 'scripting' stamp: 'tk 8/13/2001 09:27'!methodInterfacesForScriptsCategoryIn: aVocabulary	"Answer a list of method interfaces for the category #scripts, as seen in a viewer or other tool.  The vocabulary argument is not presently used."	| myScripts |	myScripts := self class scripts values collect: [:us |		(us isKindOf: UserScript)			ifTrue: [us as: MethodWithInterface]			ifFalse: [us]].	^ {self methodInterfaceForEmptyScript}, myScripts! !!Player methodsFor: 'scripts-execution' stamp: 'sw 7/3/1998 20:22'!runAllClosingScripts	"Run all the receiver's scripts marked as #closing.  Return a boolean indicating whether any such scripts were encountered and run"	| any |	any := false.	self instantiatedUserScriptsDo:		[:aScriptInstantiation | aScriptInstantiation runIfClosing ifTrue: [any := true]].	^ any! !!Player methodsFor: 'scripts-execution' stamp: 'sw 7/3/1998 20:21'!runAllOpeningScripts	"Run all the receiver's scripts marked as #opening.  Return a boolean indicating whether any such scripts were encountered and run"	| any |	any := false.	self instantiatedUserScriptsDo:		[:aScriptInstantiation | aScriptInstantiation runIfOpening ifTrue: [any := true]].	^ any! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/4/2005 02:18'!acceptableScriptNameFrom: originalString forScriptCurrentlyNamed: currentName	"Produce an acceptable script name, derived from the current name, for the receiver.  This method will always return a valid script name that will be suitable for use in the given situation, though you might not like its beauty sometimes."	| aString stemAndSuffix proscribed stem suffix withoutColon currentNumArgs withColon |	withoutColon := originalString copyWithoutAll: {$:. $ }.	(currentName notNil and: [(currentName copyWithout: $:) = withoutColon])		ifTrue:			[^ currentName].  "viz. no change; otherwise, the #respondsTo: check gets in the way"	currentNumArgs := currentName ifNil: [0] ifNotNil: [currentName numArgs].	aString := withoutColon asIdentifier: false.  "get an identifier starting with a lowercase letter"	stemAndSuffix := aString stemAndNumericSuffix.	proscribed := #(self super thisContext costume costumes dependents #true #false size).	stem := stemAndSuffix first.	suffix := stemAndSuffix last.	withoutColon := aString asSymbol.	withColon := (withoutColon, ':') asSymbol.	[(proscribed includes: withoutColon)		or: [self respondsTo: withoutColon]		or: [self respondsTo: withColon]		or:	[Smalltalk includesKey: withoutColon]		or: [Smalltalk includesKey: withColon]]	whileTrue:		[suffix := suffix + 1.		withoutColon := (stem, suffix printString) asSymbol.		withColon := (withoutColon, ':') asSymbol].	^ currentNumArgs = 0		ifTrue:			[withoutColon]		ifFalse:			[withColon]! !!Player methodsFor: 'scripts-kernel' stamp: 'NS 1/28/2004 14:41'!acceptScript: aScriptEditorMorph for: aSelector	"Accept the tile code in the script editor as the code for the given selector.  This branch is only for the classic-tile system, 1997-2001"	| aUniclassScript |	self class compileSilently: aScriptEditorMorph methodString		classified: 'scripts'.	aUniclassScript := self class assuredMethodInterfaceFor: aSelector asSymbol.	aUniclassScript currentScriptEditor: aScriptEditorMorph! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 9/8/2000 17:03'!expungeEmptyScripts	"Track down and destroy -- and destroy screen artifacts relating to -- all scripts belonging to the receiver that have no lines of code in them"	| any |	any := false.	self class namedTileScriptSelectors do:		[:aSel |			(self isEmptyTileScript: aSel)				ifTrue:					[any := true.					self removeScriptWithoutUpdatingViewers: aSel]].	any ifTrue: [self updateAllViewersAndForceToShow: #scripts]			! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 9/8/2000 17:04'!expungeEmptyUnRenamedScripts	"Track down and destroy -- and destroy screen artifacts relating to -- all scripts belonging to the receiver that have not been named and that have no lines of code in them"	| any |	any := false.	self class namedTileScriptSelectors do:		[:aSel |			(self isExpendableScript: aSel)				ifTrue:					[any := true.					self removeScriptWithoutUpdatingViewers: aSel]].	any ifTrue:		[self updateAllViewersAndForceToShow: #scripts]			! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 2/20/2001 02:28'!isEmptyTileScript: aScriptName	"Answer whether the script of the given name is an empty classic tile script.  Presently disused -- formerly it was all too easy to propagate many empty tile scripts but this difficulty has receded considerably with recent changes, so this has no senders other than from an unusual menu item, and will perhaps die soon"	| aUserScript |	Preferences universalTiles ifTrue: [^ false].	aUserScript := self class userScriptForPlayer: self selector: aScriptName.	^ (aUserScript instantiatedScriptEditorForPlayer: self) isEmpty! !!Player methodsFor: 'scripts-kernel' stamp: 'mir 7/12/2004 19:41'!methodInterfaceForEmptyScript	"Answer a MethodInterface representing Andreas's 'emptyScript' feature"	| anInterface |	anInterface := MethodInterface new.	anInterface receiverType: #Player.	anInterface flagAttribute: #scripts.	anInterface		wording: (ScriptingSystem wordingForOperator: #emptyScript);		helpMessage: 'an empty script; drop on desktop to get a new empty script for this object'.	anInterface selector: #emptyScript type: nil setter: nil.	^ anInterface! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 7/17/2002 16:41'!newTextualScriptorFor: aSelector	"Sprout a scriptor for aSelector, opening up in textual mode.  Rather special-purpose, consult my lone sender"	| aMethodWithInterface aScriptEditor |	(self class selectors includes: aSelector) ifTrue: [self error: 'selector already exists'].	aMethodWithInterface := self class permanentUserScriptFor: aSelector player: self.	aScriptEditor := aMethodWithInterface instantiatedScriptEditorForPlayer: self.	aScriptEditor install.	aScriptEditor showSourceInScriptor.	aMethodWithInterface selector numArgs == 0 ifTrue:		[self class allSubInstancesDo: [:anInst | anInst scriptInstantiationForSelector: aMethodWithInterface selector]].		"The above assures the presence of a ScriptInstantiation for the new selector in all siblings"	self updateAllViewersAndForceToShow: #scripts.	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'yo 5/6/2005 09:49'!renameScript: oldSelector newSelector: newSelector	"Rename the given script to have the new selector"	|  aUserScript anInstantiation aDict |	oldSelector = newSelector ifTrue: [^ self].	oldSelector numArgs == 0		ifTrue:			[self class allSubInstancesDo:				[:aPlayer | | itsCostume |					anInstantiation := aPlayer scriptInstantiationForSelector: oldSelector.					anInstantiation ifNotNil: [						newSelector numArgs == 0							ifTrue:								[anInstantiation changeSelectorTo: newSelector].						aDict := aPlayer costume actorState instantiatedUserScriptsDictionary.						itsCostume := aPlayer costume renderedMorph.						itsCostume renameScriptActionsFor: aPlayer from: oldSelector to: newSelector.						self currentWorld renameScriptActionsFor: aPlayer from: oldSelector to: newSelector.						aDict removeKey: oldSelector.						newSelector numArgs  == 0 ifTrue:							[aDict at: newSelector put: anInstantiation.							anInstantiation assureEventHandlerRepresentsStatus]]]]		ifFalse:			[newSelector numArgs == 0 ifTrue:				[self class allSubInstancesDo:					[:aPlayer |						anInstantiation := aPlayer scriptInstantiationForSelector: newSelector.						anInstantiation ifNotNil: [anInstantiation assureEventHandlerRepresentsStatus]]]].	aUserScript := self class userScriptForPlayer: self selector: oldSelector.	aUserScript renameScript: newSelector fromPlayer: self.		"updates all script editors, and inserts the new script in my scripts directory"	self class removeScriptNamed: oldSelector.	((self existingScriptInstantiationForSelector: newSelector) notNil and:		[newSelector numArgs > 0]) ifTrue: [self error: 'ouch'].			self updateAllViewersAndForceToShow: 'scripts'! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 2/17/2001 01:05'!scriptEditorFor: aSelector	"Answer the receiver's script editor for aSelector"	| aScriptEditor |	aScriptEditor := (self class userScriptForPlayer: self selector: aSelector) instantiatedScriptEditorForPlayer: self.	aScriptEditor updateToPlayer: self.	aScriptEditor bringUpToDate.	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'yo 5/6/2005 09:47'!scriptInstantiationForSelector: aSelector	"Answer a script instantiation for the given selector, creating it at this time if necessary"	|  entry scriptDict classEntry actorState |	actorState := self actorState.	actorState ifNil: [^ nil].	scriptDict := actorState instantiatedUserScriptsDictionary.	entry := scriptDict at: aSelector ifAbsent: [nil].	entry ifNil:		[classEntry := self class userScriptForPlayer: self selector: aSelector.		entry := ScriptInstantiation new player: self selector: aSelector status: classEntry defaultStatus.		scriptDict at: aSelector put: entry].	^ entry! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/19/2001 15:15'!scriptorsForSelector: aSelector inWorld: aWorld	"Answer, for the purpose of deletion, a list of all scriptor objects for the given selector that are associated with any member of the receiver's uniclass"	| scriptors |	aWorld ifNil: [^ OrderedCollection new].	scriptors := (aWorld allMorphs select:		[:m | (((m isKindOf: ScriptEditorMorph) and: [m playerScripted class == self class]) and: [m scriptName == aSelector])] thenCollect: [:m | m topEditor]) asSet.	^ scriptors asArray! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/3/2005 14:48'!slotInfoButtonHitFor: aGetterSymbol inViewer: aViewer	"The user made a gesture asking for slot menu for the given getter symbol in a viewer; put up the menu."	| aMenu slotSym aType typeVocab interface selector |	 (#(+ - * /) includes: aGetterSymbol)		ifTrue:			 [^ self inform: aGetterSymbol, ' is used for vector operations'].	slotSym := Utilities inherentSelectorForGetter: aGetterSymbol.	aType := self typeForSlotWithGetter: aGetterSymbol asSymbol.	aMenu := MenuMorph new defaultTarget: self.	interface := aViewer currentVocabulary methodInterfaceAt: aGetterSymbol ifAbsent: [nil].	selector := interface isNil		ifTrue: [slotSym asString]		ifFalse: [interface selector].	aMenu addTitle: (selector, ' (', (aType asString translated), ')').	aType = #Patch ifTrue: [		aMenu add: 'grab morph' translated			target: (self perform: aGetterSymbol)			selector: #grabPatchMorph			argument: #().			aMenu addLine.	].	(typeVocab := Vocabulary vocabularyForType: aType) addWatcherItemsToMenu: aMenu forGetter: aGetterSymbol.	(self slotInfo includesKey: slotSym)		ifTrue:			[aMenu add: 'change value type' translated selector: #chooseSlotTypeFor: argument: aGetterSymbol.			typeVocab addUserSlotItemsTo: aMenu slotSymbol: slotSym.			aMenu add: ('remove "{1}"' translated format: {slotSym}) selector: #removeSlotNamed: argument: slotSym.			aMenu add: ('rename "{1}"' translated format: {slotSym}) selector: #renameSlot: argument: slotSym.			aMenu addLine].	typeVocab addExtraItemsToMenu: aMenu forSlotSymbol: slotSym.  "e.g. Player type adds hand-me-tiles"	aMenu add: 'show categories....' translated target: aViewer selector: #showCategoriesFor: argument: aGetterSymbol.	self addIdiosyncraticMenuItemsTo: aMenu forSlotSymol: slotSym.	aMenu items isEmpty ifTrue:		[aMenu add: 'ok' translated action: #yourself].	aMenu popUpForHand: aViewer primaryHand in: aViewer world! !!Player methodsFor: 'scripts-kernel' stamp: 'mir 7/12/2004 19:36'!tilesToCall: aMethodInterface	"Answer a phrase for the non-typed command represented by aMethodInterface."	| resultType cmd argType argTile selfTile aPhrase balloonTextSelector aDocString universal |	self class namedTileScriptSelectors.	resultType := aMethodInterface resultType.	cmd := aMethodInterface selector.	(universal := self isUniversalTiles)		ifTrue:			[aPhrase := self universalTilesForInterface: aMethodInterface]		ifFalse: [cmd numArgs == 0			ifTrue:				[aPhrase := PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #Player]			ifFalse:				["only one arg supported in classic tiles, so if this is fed				with a selector with > 1 arg, results will be very strange"				argType := aMethodInterface typeForArgumentNumber: 1.				aPhrase := PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #Player					argType: argType.				argTile := ScriptingSystem tileForArgType: argType.				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(self slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector := #userSlot].	(self belongsToUniClass and: [self class includesSelector: cmd])		ifTrue:			[aDocString := (self class userScriptForPlayer: self selector: cmd) documentation.			aDocString				ifNotNil: [aPhrase submorphs second setBalloonText: aDocString]				ifNil: [balloonTextSelector := #userScript]].	(universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]) balloonTextSelector: 			(balloonTextSelector ifNil: [cmd]).	universal ifFalse:		[selfTile := self tileToRefer.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile.		aPhrase makeAllTilesGreen.		aPhrase justGrabbedFromViewer: false].	^ aPhrase! !!Player methodsFor: 'scripts-kernel' stamp: 'tk 9/29/2001 22:20'!universalTilesForInterface: aMethodInterface	"Return universal tiles for the given method interface.  Record who self is."	| ms argTile itsSelector aType argList makeSelfGlobal phrase |	itsSelector := aMethodInterface selector.	argList := OrderedCollection new.	aMethodInterface argumentVariables doWithIndex:		[:anArgumentVariable :anIndex | 			argTile := ScriptingSystem tileForArgType: (aType := aMethodInterface typeForArgumentNumber: anIndex).			argList add: (aType == #Player 				ifTrue: [argTile actualObject]				ifFalse: [argTile literal]).	"default value for each type"].	ms := MessageSend receiver: self selector: itsSelector arguments: argList asArray.	"For CardPlayers, use 'self'.  For others, name me, and use my global name."	makeSelfGlobal := self class officialClass ~~ CardPlayer.	phrase := ms asTilesIn: self class globalNames: makeSelfGlobal.	makeSelfGlobal ifFalse: [phrase setProperty: #scriptedPlayer toValue: self].	^ phrase! !!Player methodsFor: 'scripts-standard' stamp: 'sw 9/4/2001 07:42'!assignStatus: newStatus toAllFor: scriptName	"Change the status of my script of the given name to be as specified in me and all of my siblings."	| aWorld |	(self existingScriptInstantiationForSelector: scriptName) ifNotNilDo:		[:scriptInstantiation |				scriptInstantiation status: newStatus.				scriptInstantiation assignStatusToAllSiblings.				^ (aWorld := self costume world) ifNotNil:					[aWorld updateStatusForAllScriptEditors]]! !!Player methodsFor: 'scripts-standard' stamp: 'mir 6/7/2002 17:08'!forward: dist 	"Move forward (viz. in the direction of my heading) by the given amount"	| rho radians delta didStray p aCostume aPlayfield |	(aCostume := self costume) isInWorld ifFalse: [^ self].	aCostume isWorldOrHandMorph ifTrue: [^ self].	aCostume owner isHandMorph ifTrue: [^ self].	rho := (aCostume asNumber: dist) asFloat.	radians := (self getHeadingUnrounded asFloat - 90.0) degreesToRadians.	delta := (radians cos @ radians sin) * rho.	(aPlayfield := aCostume pasteUpMorph) fenceEnabled ifTrue:		[(aPlayfield bounds containsRect: aCostume bounds) ifFalse:			["If I stray out of the bounds of my playfield, pull me back, but			 without changing my heading as bounce would. Do nothing if			 bounce has already corrected the direction."			didStray := false.			((aCostume left < aPlayfield left and: [delta x < 0]) or:			 [aCostume right > aPlayfield right and: [delta x > 0]]) ifTrue:				[delta := delta x negated @ delta y.				didStray := true].			((aCostume top < aPlayfield top and: [delta y < 0]) or:			 [aCostume bottom > aPlayfield bottom and: [delta y > 0]]) ifTrue:				[delta := delta x @ delta y negated.				didStray := true].			(didStray and: [Preferences fenceSoundEnabled]) ifTrue: [aCostume makeFenceSound]]].	"use and record the fractional position"	p := aCostume referencePosition + delta.	aCostume referencePosition: p! !!Player methodsFor: 'scripts-standard' stamp: 'sw 9/7/2000 12:52'!getObtrudes	"Answer whether the receiver's costume obtrudes beyond the bounds of its container"	| aCostume |	(aCostume := self costume) ifNil: [^ false].	^ aCostume obtrudesBeyondContainer! !!Player methodsFor: 'scripts-standard' stamp: 'gk 2/23/2004 20:51'!loadSound: soundName	| snd |	snd := SoundService default soundNamed: soundName.	snd ifNotNil: [self sendMessageToCostume: #loadSound: with: snd].! !!Player methodsFor: 'scripts-standard' stamp: 'sw 7/29/2005 17:32'!moveToward: aPlayer	"Move a standard amount in the direction of the given player.  If the object has an instance variable named 'speed', the speed of the motion will be governed by that value"	| myPosition itsPosition |	((aPlayer ~~ self) and: [(self overlaps: aPlayer) not]) ifTrue:		[((myPosition := self costume referencePosition) = (itsPosition := aPlayer costume referencePosition))			ifFalse:				[self setHeading: (myPosition bearingToPoint: itsPosition).				self forward: self getSpeed]]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 7/29/2005 17:25'!turnToward: aPlayer	"Turn to face the given player, unless our positions coincide."	|  aCostume myPosition itsPosition |	(aPlayer == nil or: [aPlayer == self]) ifTrue: [^ self].	aCostume := self costume.	aCostume isWorldMorph ifTrue: [^ self].	(self overlaps: aPlayer) ifFalse:		[((myPosition := aCostume referencePosition) = (itsPosition := aPlayer costume referencePosition))			ifFalse: "avoid division by zero ;-("				[self setHeading: (myPosition bearingToPoint: itsPosition)]]! !!Player methodsFor: 'scripts-vector' stamp: 'nk 9/25/2003 11:46'!* aNumber	"Treating Players like vectors, return a new Player that is myself scaled by the number"	| new |	new := costume usableSiblingInstance player.	new setX: self getX * aNumber asPoint x.	new setY: self getY * aNumber asPoint y.	^ new! !!Player methodsFor: 'scripts-vector' stamp: 'nk 9/25/2003 11:46'!+ aPlayer	"Treating Players like vectors, add aPlayer to me and return a new Player"	| new |	new := costume usableSiblingInstance player.	new setX: self getX + aPlayer asPoint x.	new setY: self getY + aPlayer asPoint y.	^ new! !!Player methodsFor: 'scripts-vector' stamp: 'nk 9/25/2003 11:46'!- aPlayer	"Treating Players like vectors, subtract aPlayer from me and return a new Player"	| new |	new := costume usableSiblingInstance player.	new setX: self getX - aPlayer asPoint x.	new setY: self getY - aPlayer asPoint y.	^ new! !!Player methodsFor: 'scripts-vector' stamp: 'nk 9/25/2003 11:45'!/ aNumber	"Treating Players like vectors, return a new Player that is myself divided by the number"	| new |	new := costume usableSiblingInstance player.	new setX: self getX / aNumber asPoint x.	new setY: self getY / aNumber asPoint y.	^ new! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/7/2002 13:18'!bookEmbodied	"Answer the book embodied by the receiver's costume; usually this is directly the receiver's costume, but in case it is not, we look up the owner chain for one.  This allows page-number messages to be sent to a *page* of the stack, as Alan is wont to do, and have them still find their way to the right place"	| aMorph |	^ ((aMorph := self costume renderedMorph) isKindOf: BookMorph)		ifTrue:			[aMorph]		ifFalse:			[aMorph ownerThatIsA: BookMorph]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getBaseGraphic	"Answer a form representing the receiver's base graphic"	| aMorph |	^ ((aMorph := costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph baseGraphic]		ifFalse:			[aMorph imageForm]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/4/2002 19:31'!getCardNumber	"Answer the current card number"	| aStack |	^ (aStack := self stackEmbodied) cardNumberOf: aStack currentCard! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 2/17/2003 18:09'!getCharacterAtCursor	"Answer the value of the text cursor"	| aLoc aTextMorph aString |	aLoc := (aTextMorph := self costume renderedMorph) cursor.	aString := aTextMorph text string.	^ (aString at: aLoc ifAbsent: ['·']) asString! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 12/10/2001 00:34'!getColor	"Answer the color of my costume.  If it uses a gradient fill, answer the first color."	| aFillStyle aMorph |	^ (aFillStyle := (aMorph := self costume renderedMorph) fillStyle) isGradientFill		ifTrue:			[aFillStyle colorRamp first value]		ifFalse:			[aMorph color]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getCostume	"Answer a form representing the receiver's primary graphic.  An earlier wording, disused but may persist in preexisting scripts."	| aMorph |	^ ((aMorph := costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph form]		ifFalse:			[aMorph imageForm]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getCostumeAtCursor	"Answer the form representing the object at the current cursor.  An earlier wording, disused but may persist in preexisting scripts"	| anObject aMorph |		anObject := self getValueFromCostume: #valueAtCursor.	^ anObject == 0  "weird return from GraphMorph"		ifTrue:			[ScriptingSystem formAtKey: #Paint]		ifFalse:			[((aMorph := anObject renderedMorph) isSketchMorph)				ifTrue:					[aMorph form]				ifFalse:					[anObject imageForm]]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getGraphic	"Answer a form representing the receiver's primary graphic"	| aMorph |	^ ((aMorph := costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph form]		ifFalse:			[aMorph isPlayfieldLike				ifTrue:					[aMorph backgroundForm]				ifFalse:					[aMorph imageForm]]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getGraphicAtCursor	"Answer the form representing the object at the current cursor"	| anObject aMorph |		anObject := self getValueFromCostume: #valueAtCursor.	^ anObject == 0  "weird return from GraphMorph"		ifTrue:			[ScriptingSystem formAtKey: #Paint]		ifFalse:			[((aMorph := anObject renderedMorph) isSketchMorph)				ifTrue:					[aMorph form]				ifFalse:					[aMorph isPlayfieldLike						ifTrue:							[aMorph backgroundForm]						ifFalse:							[aMorph imageForm]]]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/17/2002 10:50'!getHeadingTheta	"Answer the angle, in degrees, between the positive x-axis and the receiver's heading vector"	| aHeading excess normalized |	aHeading := self getHeadingUnrounded.	excess := aHeading - (aHeading rounded).	normalized := (450 - aHeading) \\ 360.	^ normalized + excess! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 3/10/2004 12:15'!getLength	"Answer the length of the object"	| aLength cost |	((cost  := self costume) isLineMorph) "annoying special case"		ifTrue:			[^ cost unrotatedLength].	aLength := cost renderedMorph height.  "facing upward when unrotated"	cost isRenderer		ifTrue:			[aLength := aLength * cost scaleFactor].	^ aLength! !!Player methodsFor: 'slot getters/setters' stamp: 'tak 1/26/2005 14:58'!getNewClone	"Answer a new player of the same class as the receiver, with a costume much like mine"	| clone |	clone :=  costume usableSiblingInstance.	costume pasteUpMorph ifNotNilDo: [:parent | parent addMorph: clone].	^ clone player! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/1/2000 10:36'!getNumberAtCursor	"Answer the number borne by the object at my costume's current cursor position"	| renderedMorph aCostume |	aCostume := self costume.	((renderedMorph := aCostume renderedMorph) respondsTo: #valueAtCursor:) ifTrue: [^ renderedMorph valueAtCursor getNumericValue]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/7/2002 13:31'!getPageNumber	"Answer the current page number of my book"	| aBook |	^ (aBook := self bookEmbodied) pageNumberOf: aBook currentPage! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/16/2001 08:32'!getRadialGradientFill	"Geter for costume's useGradientFill"	| aStyle |	^ (aStyle := costume renderedMorph fillStyle) isGradientFill and:		[aStyle isRadialFill]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 12/10/2001 00:12'!getSecondColor	"Getter for costume's second color, if it's using gradient fill; sonst answers white."	| aFillStyle |	^ (aFillStyle := costume renderedMorph fillStyle) isGradientFill		ifTrue:			[aFillStyle  colorRamp last value]		ifFalse:			[Color white]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 8/17/1998 15:43'!getValueAtCursor	| anObject |	anObject := self getValueFromCostume: #valueAtCursor.	^ anObject == 0  "weird return from GraphMorph"		ifTrue:			[nil]		ifFalse:			[anObject assuredPlayer]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 3/10/2004 12:15'!getWidth	"Answer the width of the object"	| aWidth cost |	((cost := self costume) isLineMorph) "annoying special case"		ifTrue:			[^ cost unrotatedWidth].	aWidth := cost renderedMorph width.  "facing upward when unrotated"	cost isRenderer		ifTrue:			[aWidth := aWidth * cost scaleFactor].	^ aWidth! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 8/17/1998 17:23'!getX		"emergency patch; unclear why not needed in getY; in any case, have		 removed the getX/getY retrievals from the viewer in 2.0-final anyway"	| aCostume |	(aCostume := self costume) isInWorld ifFalse: [^ 100].	^ aCostume x! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 7/19/2005 01:49'!setAlpha: alpha	"Set the alpha of the color of my costume."	| adjusted |	adjusted := (alpha max: 0.0) min: 1.0.	^ self setColor: (self getColor alpha: adjusted)! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:02'!setBaseGraphic: aGraphic	"Set the base graphic"	| aMorph |	^ ((aMorph := costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph baseGraphic: aGraphic]! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:32'!setBottom: w	"Set the bottom coordinate (cartesian sense) of the object as requested"	| topLeftNow cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	topLeftNow := cost cartesianBoundsTopLeft.	^ cost bottom: cost top + topLeftNow y - w! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 2/17/2003 17:35'!setCharacterAtCursor: aCharOrString	"Insert the given character at my cursor position"	| aLoc aTextMorph aString charToUse |	aLoc := (aTextMorph := self costume renderedMorph) cursor.	charToUse := (aString := aCharOrString asString) size > 0		ifTrue:			[aString first]		ifFalse:			['·'].	aTextMorph paragraph replaceFrom: aLoc to: aLoc with: charToUse asString asText displaying: true.	aTextMorph updateFromParagraph  ! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 12/10/2001 00:27'!setColor: aColor	"Set the color of the graphic as requested"	| aFillStyle aMorph |	(aFillStyle := (aMorph := self costume renderedMorph) fillStyle) isGradientFill		ifTrue:			[aFillStyle firstColor: aColor forMorph: aMorph hand: nil]		ifFalse:			[aMorph color: aColor]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:02'!setCostume: aForm	"Set the receiver's graphic as indicated.  An earlier wording, disused but may persist in preexisting scripts."	| aMorph |	^ ((aMorph := costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph form: aForm]		ifFalse:			["what to do?"]! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:35'!setDistance: aDistance	"Set the object's distance from the origin to be as indicated, preserving its angle."	| cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	cost cartesianXY: (Point r: aDistance degrees:  self getTheta)! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 3/15/2005 18:23'!setDropShadow: aValue	"Setter for costume's dropShadow"	| aMorph |	(aMorph := costume renderedMorph) hasDropShadow ~~ aValue ifTrue: [aMorph toggleDropShadow]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:02'!setGraphic: aForm	"Set the receiver's graphic as indicated"	| aMorph |	^ ((aMorph := costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph form: aForm]		ifFalse:			[aMorph isPlayfieldLike				ifTrue: 					[aMorph backgroundForm: aForm]				ifFalse:					["what to do?"]]! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:34'!setHeading: newHeading	"Set the heading as indicated"	| aCostume |	aCostume := self costume.	aCostume isWorldMorph ifTrue: [^ self].	(newHeading closeTo: aCostume heading) ifTrue: [^ self].	aCostume heading: newHeading.	aCostume := self costume. "in case we just got flexed for no apparent reason"	(aCostume isFlexMorph and:[aCostume hasNoScaleOrRotation]) 		ifTrue:	[aCostume removeFlexShell]! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:32'!setLeft: w	"Set the object's left coordinate as indicated"	| topLeftNow cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	topLeftNow := cost cartesianBoundsTopLeft.	^ cost left: cost left - topLeftNow x + w! !!Player methodsFor: 'slot getters/setters' stamp: 'dgd 10/23/2004 14:44'!setLength: aLength	"Set the length of the receiver."	| cost lengthToUse |	self hasCostumeThatIsAWorld ifTrue:[^ self].	((cost := self costume) isLineMorph)		ifTrue:			[^ cost unrotatedLength: aLength].	lengthToUse := cost isRenderer		ifTrue:			[aLength / cost scaleFactor]		ifFalse:			[aLength].	cost renderedMorph height: lengthToUse! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/1/2000 10:37'!setNumberAtCursor: aNumber	"Place the given number into the morph residing at my costume's current cursor position"	| renderedMorph aCostume |	aCostume := self costume.	((renderedMorph := aCostume renderedMorph) respondsTo: #valueAtCursor:) ifTrue: [^ renderedMorph valueAtCursor setNumericValue: aNumber]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/16/2001 08:51'!setRadialGradientFill: aBoolean	"Setter for costume's radialGradientFill"	| aStyle |	(aStyle := costume renderedMorph fillStyle) isGradientFill		ifTrue:			[aStyle isRadialFill ~~ aBoolean ifTrue:				[aStyle radial: aBoolean.				costume renderedMorph changed]]! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:32'!setRight: w	"Set the right coordinate to the given value"	| topLeftNow cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	topLeftNow := cost cartesianBoundsTopLeft.	^ cost right: cost left - topLeftNow x + w! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:33'!setScaleFactor: aNumber	"Set the scale factor to be the given value"	| cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	cost scaleFactor: ((aNumber asFloat max: 0.1) min: 10.0)! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 12/9/2001 23:55'!setSecondColor: aColor	"Setter for costume's second color, if it's using gradient fill; if not, does nothing"	| aFillStyle aMorph |	^ (aFillStyle := (aMorph := costume renderedMorph) fillStyle) isGradientFill		ifTrue:			[aFillStyle lastColor: aColor forMorph: aMorph hand: ActiveHand]! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:35'!setTheta: aTheta	"Set the object's position such that its rho is unchanged but the angle between the positive x-axis and the vector connecting the origin and the object's position is as given."	| cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	cost cartesianXY: (Point r: self getDistance degrees: aTheta)! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:32'!setTop: w	"Set the top coordinate as indicated, using cartesian sense"	| topLeftNow cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	topLeftNow := cost cartesianBoundsTopLeft.	^ cost top: cost top + topLeftNow y - w! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 8/17/1998 17:15'!setValueAtCursor: aPlayer	| renderedMorph aCostume |	aCostume := self costume.	((renderedMorph := aCostume renderedMorph) respondsTo: #valueAtCursor:) ifTrue: [^ renderedMorph valueAtCursor: aPlayer costume].	(aCostume respondsTo: #valueAtCursor:) ifTrue: [aCostume valueAtCursor: aPlayer costume]! !!Player methodsFor: 'slot getters/setters' stamp: 'di 9/12/2001 20:49'!setX: val	"Set the x coordinate as indicated"	| aCostume |	(aCostume := self costume) isInWorld ifFalse: [^ self].	aCostume isWorldOrHandMorph ifTrue: [^ self].	aCostume owner isHandMorph ifTrue: [^ self].	^ aCostume x: val! !!Player methodsFor: 'slot getters/setters' stamp: 'di 9/12/2001 20:51'!setY: val	"Set the y coordinate as indicated"	| aCostume |	(aCostume := self costume) isInWorld ifFalse: [^ self].	aCostume isWorldOrHandMorph ifTrue: [^ self].	aCostume owner isHandMorph ifTrue: [^ self].	^ aCostume y: val! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/4/2002 19:31'!stackEmbodied	"Answer the stack embodied by the receiver's costume; usually this is directly the receiver's costume, but in case it is not, we look up the owner chain for one.  This allows card-number messages to be sent to a *page* of the stack, as Alan is wont to do, and have them still find their way to the right place"	| aMorph |	^ ((aMorph := self costume renderedMorph) isKindOf: StackMorph)		ifTrue:			[aMorph]		ifFalse:			[aMorph ownerThatIsA: StackMorph]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 3/3/2004 23:58'!categories	"Answer a list of categories appropriate to the the receiver and its costumes"	| aList |	(self hasCostumeThatIsAWorld)		ifTrue:	[^ self categoriesForWorld].	aList := OrderedCollection new.	self slotNames notEmpty ifTrue:		[aList add: ScriptingSystem nameForInstanceVariablesCategory].	aList addAll: costume categoriesForViewer.	aList remove: ScriptingSystem nameForScriptsCategory ifAbsent: [].	aList add: ScriptingSystem nameForScriptsCategory after: aList first.	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'sw 3/3/2004 00:00'!categoriesForVocabulary: aVocabulary	"Answer a list of categories appropriate to the receiver and its costumes, in the given Vocabulary"	| aList |	self hasCostumeThatIsAWorld		ifTrue:			[aList := self categoriesForWorld]		ifFalse:			[aList := OrderedCollection new.			self slotNames ifNotEmpty:				[aList add: ScriptingSystem nameForInstanceVariablesCategory].			aList addAll: costume categoriesForViewer].	aVocabulary addCustomCategoriesTo: aList.	aList remove: ScriptingSystem nameForScriptsCategory ifAbsent: [].	aList add: ScriptingSystem nameForScriptsCategory after: aList first.	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'dgd 4/4/2006 16:21'!categoriesForWorld	"Answer the list of categories given that the receiver is the Player representing a World"	| aList |	aList := #(#'color & border' #geometry #'pen trails' playfield collections #'stack navigation') asOrderedCollection.	aList addFirst: ScriptingSystem nameForScriptsCategory.	aList addFirst: ScriptingSystem nameForInstanceVariablesCategory.	aList add: #input.	Preferences eToyFriendly ifFalse:		[aList add: #preferences].	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'yo 8/1/2004 02:04'!methodInterfacesForInstanceVariablesCategoryIn: aVocabulary	"Return a collection of methodInterfaces for the instance-variables category.  The vocabulary parameter, at present anyway, is not used."	| aList anInterface itsSlotName |	aList := OrderedCollection new.	self slotInfo associationsDo:		[:assoc |			anInterface := MethodInterface new.			itsSlotName := assoc key.			anInterface				wording: itsSlotName;				helpMessage: 'a variable defined by this object' translated.			anInterface selector: (Utilities getterSelectorFor: itsSlotName) type: assoc value type setter: (Utilities setterSelectorFor: itsSlotName).			anInterface setToRefetch.			aList add: anInterface].	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'sw 8/3/2005 14:21'!typeForSlotWithGetter: aGetter	"Answer the data type for values of the instance variable of the given name"	| getter inherentSelector |	(#(color:sees: seesColor: touchesA: overlaps: overlapsAny:) includes: aGetter) ifTrue: [^ #Boolean].	(#(+ * - /) includes: aGetter) ifTrue: [^ #Player].  "weird vector stuff"  	"Annoying special cases"	inherentSelector := Utilities inherentSelectorForGetter: aGetter.	(self slotInfo includesKey: inherentSelector) ifTrue: [^ (self slotInfoAt: inherentSelector) type].	getter := (aGetter beginsWith: 'get')		ifTrue:			[aGetter]		ifFalse:			[Utilities getterSelectorFor: aGetter].	^ (Vocabulary eToyVocabulary methodInterfaceAt: getter ifAbsent: [self error: 'Unknown slot name: ', aGetter]) resultType! !!Player methodsFor: 'slots-kernel' stamp: 'sw 5/29/2001 13:57'!typeForSlot: aSlotName	"Answer the data type for values of the instance variable of the given name"	| getter |	(self slotInfo includesKey: aSlotName) ifTrue: [^ (self slotInfoAt: aSlotName) type].	getter := (aSlotName beginsWith: 'get')		ifTrue:			[aSlotName]		ifFalse:			[Utilities getterSelectorFor: aSlotName].	^ (self currentVocabulary methodInterfaceAt: getter ifAbsent: [self error: 'Unknown slot name: ', aSlotName]) resultType! !!Player methodsFor: 'slots-kernel' stamp: 'sw 5/24/2001 14:29'!typeForSlot: aSlotName vocabulary: aVocabulary	"Answer the data type for values of the instance variable of the given name.  Presently has no senders but retained for a while..."	| getter inherentSelector |	inherentSelector := Utilities inherentSelectorForGetter: aSlotName.	(self slotInfo includesKey: inherentSelector) ifTrue: [^ (self slotInfoAt: inherentSelector) type].	getter := (aSlotName beginsWith: 'get')		ifTrue:			[aSlotName]		ifFalse:			[Utilities getterSelectorFor: aSlotName].	^ (aVocabulary methodInterfaceAt: getter ifAbsent: [self error: 'Unknown slot name: ', aSlotName]) resultType! !!Player methodsFor: 'slots-user' stamp: 'yo 9/24/2004 09:09'!addInstanceVariable	"Offer the user the opportunity to add an instance variable, and if he goes through with it, actually add it."	| itsName initialValue typeChosen usedNames initialAnswer setterSelector originalString |	usedNames := self class instVarNames.	initialAnswer := Utilities keyLike: ('var' translated, (usedNames size + 1) asString)  satisfying: [:aKey | (usedNames includes: aKey) not].	originalString := FillInTheBlank request: 'name for new variable: ' translated initialAnswer: initialAnswer.	originalString isEmptyOrNil ifTrue: [^ self].	itsName := ScriptingSystem acceptableSlotNameFrom: originalString forSlotCurrentlyNamed: nil asSlotNameIn: self world: self costume world. 	itsName size == 0 ifTrue: [^ self].		self assureUniClass.	typeChosen := self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: (SlotInformation new initialize type: typeChosen).	initialValue := self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self compileInstVarAccessorsFor: itsName.	setterSelector := Utilities setterSelectorFor: itsName.	((self class allSubInstances copyWithout: self) reject: [:e | e isSequentialStub]) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewersAndForceToShow: ScriptingSystem nameForInstanceVariablesCategory! !!Player methodsFor: 'slots-user' stamp: 'yo 6/5/2004 18:49'!addInstanceVariable2Named: nameSymbol type: typeChosen value: aValue	"Add an instance variable of the given name and type, and initialize it to have the given value"	| initialValue setterSelector |	self assureUniClass.	self slotInfo at: nameSymbol put: (SlotInformation new initialize type: typeChosen).	initialValue := aValue.	self addInstanceVarNamed: nameSymbol withValue: aValue.	self class compileAccessorsFor: nameSymbol.	setterSelector := Utilities setterSelectorFor: nameSymbol.	(self class allSubInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewersAndForceToShow: #'instance variables'! !!Player methodsFor: 'slots-user' stamp: 'md 3/1/2006 09:15'!addInstanceVariableNamed: nameSymbol type: typeChosen value: aValue	"Add an instance variable of the given name and type, and initialize it to have the given value"	| initialValue setterSelector |	self assureUniClass.	self slotInfo at: nameSymbol put: (SlotInformation new type: typeChosen).	initialValue := self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: nameSymbol withValue: aValue.	self class compileAccessorsFor: nameSymbol.	setterSelector := Utilities setterSelectorFor: nameSymbol.	(self class allSubInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewersAndForceToShow: ScriptingSystem nameForInstanceVariablesCategory! !!Player methodsFor: 'slots-user' stamp: 'NS 1/28/2004 14:47'!addSpecialSetter: selector	| instVar code |	"For the special setters, fooIncreaseBy:, fooDecreaseBy:, fooMultiplyBy:, add a method that does them." 	self assureUniClass.	instVar := (selector allButLast: 11) asLowercase.  "all three are 11 long!!"	(self respondsTo: ('set', instVar capitalized, ':') asSymbol) ifFalse: [^ false].	code := String streamContents: [:strm |		strm nextPutAll: selector, ' amount'; crtab.		strm nextPutAll: 'self set', instVar capitalized, ': (self get', instVar capitalized; space.		(selector endsWith: 'IncreaseBy:') ifTrue: [strm nextPut: $+].		(selector endsWith: 'DecreaseBy:') ifTrue: [strm nextPut: $-].		(selector endsWith: 'MultiplyBy:') ifTrue: [strm nextPut: $*].		strm nextPutAll: ' amount)'].	self class compileSilently: code classified: 'access' notifying: nil.	^ true! !!Player methodsFor: 'slots-user' stamp: 'sw 1/6/2005 01:32'!allPossibleWatchersFromWorld	"Answer a list of all UpdatingStringMorphs, PlayerReferenceReadouts, ThumbnailMorphs, and  UpdatingReferenceMorphs in the Active world and its hidden book pages, etc., which have me or any of my siblings as targets"	| a |	a := IdentitySet new: 400.	ActiveWorld allMorphsAndBookPagesInto: a.	^ a select: [:e | e isEtoyReadout and: [e target class == self class]]! !!Player methodsFor: 'slots-user' stamp: 'yo 9/20/2004 12:13'!basicRemoveSlotNamed: aSlotName	"The user has requested that an instance variable be removed..."	| aSetter aGetter |	(self okayToRemoveSlotNamed: aSlotName) ifFalse:		[^ self inform: 'Sorry, ', aSlotName, ' is inuse in a script.'].	aSetter := Utilities setterSelectorFor: aSlotName.	aGetter := Utilities getterSelectorFor: aSlotName.	((self systemNavigation allCallsOn: aSetter) size > 0 or: [(self systemNavigation allCallsOn: aGetter) size > 0]) ifTrue:		[self inform: 'Caution!!  There may be scripts belonging toother objects that may rely on the presence ofthis variable.  If there are, they may now be broken.You may need to fix them up manually.'].	self class removeInstVarName: aSlotName asString.	self updateAllViewers! !!Player methodsFor: 'slots-user' stamp: 'sw 3/24/2005 01:33'!chooseSlotTypeFor: aGetter	"Let the user designate a type for the slot associated with the given getter"	| typeChoices typeChosen slotName |	slotName := Utilities inherentSelectorForGetter: aGetter.	typeChoices := Vocabulary typeChoices.	typeChosen := (SelectionMenu labelList: (typeChoices collect: [:t | t translated]) lines: #() selections: typeChoices) startUpWithCaption: 		('Choose the TYPEfor ' translated, slotName, '(currently ' translated, (self slotInfoAt: slotName) type translated, ')').	typeChosen isEmptyOrNil ifTrue: [^ self].	(self typeForSlot: slotName) capitalized = typeChosen ifTrue: [^ self].	(self slotInfoAt: slotName) type: typeChosen.	self class allInstancesDo:   "allSubInstancesDo:"		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName))].	self updateAllViewers.	"does siblings too"	self changeTypesInWatchersOf: slotName  "does siblings too"! !!Player methodsFor: 'slots-user' stamp: 'sw 4/5/1999 13:55'!chooseUserSlot	| names aMenu result |	(names := self slotNames) size == 1		ifTrue: [^ names first].	aMenu := SelectionMenu selections: names.	result := aMenu startUpWithCaption: 'Please choose a variable'.	result isEmptyOrNil ifTrue: [^ nil].	^ result! !!Player methodsFor: 'slots-user' stamp: 'yo 2/12/2005 18:58'!fancyWatcherFor: aGetter	"Anser a labeled readout for viewing a value textuallyi"	| aWatcher aColor aLine itsName aSelector aLabel |	aWatcher := self unlabeledWatcherFor: aGetter.	aColor := Color r: 0.387 g: 0.581 b: 1.0.	aLine := WatcherWrapper newRow.	aLine player: self variableName: (aSelector := Utilities inherentSelectorForGetter: aGetter).	itsName := aWatcher externalName.	aWatcher setNameTo: 'readout'.	aLine addMorphFront: (self tileReferringToSelf				borderWidth: 0; layoutInset: 4@0;				typeColor: aColor; 				color: aColor; bePossessive).	aLabel := StringMorph contents: aSelector translated, ' = ' font: ScriptingSystem fontForTiles.	aLabel setProperty: #watcherLabel toValue: true.	aLine addMorphBack: aLabel.	aLine addMorphBack: aWatcher.	aLine setNameTo: itsName.	^ aLine! !!Player methodsFor: 'slots-user' stamp: 'yo 2/12/2005 20:09'!offerGetterTiles: slotName 	"For a player-type slot, offer to build convenient compound tiles that otherwise would be hard to get"	| typeChoices typeChosen thePlayerThereNow slotChoices slotChosen getterTiles aCategoryViewer playerGetter |	typeChoices := Vocabulary typeChoices.	typeChosen := (SelectionMenu labelList: (typeChoices collect: [:t | t translated]) lines: #() selections: typeChoices) 				startUpWithCaption: ('Choose the TYPEof data to get from{1}''s {2}' translated format: {self externalName. slotName translated}).	typeChosen isEmptyOrNil ifTrue: [^self].	thePlayerThereNow := self perform: (Utilities getterSelectorFor: slotName).	thePlayerThereNow 		ifNil: [thePlayerThereNow := self presenter standardPlayer].	slotChoices := thePlayerThereNow slotNamesOfType: typeChosen.	slotChoices isEmpty 		ifTrue: [^self inform: 'sorry -- no slots of that type' translated].	slotChoices := slotChoices asSortedArray.	slotChosen := (SelectionMenu labelList: (slotChoices collect: [:t | t translated]) selections: slotChoices) 				startUpWithCaption: ('Choose the datumyou want to extract from {1}''s {2}' translated format: {self externalName. slotName translated}).	slotChosen isEmptyOrNil ifTrue: [^self].	"Now we want to tear off tiles of the form		holder's valueAtCursor's foo"	getterTiles := nil.	aCategoryViewer := CategoryViewer new initializeFor: thePlayerThereNow				categoryChoice: 'basic'.	getterTiles := aCategoryViewer 				getterTilesFor: (Utilities getterSelectorFor: slotChosen)				type: typeChosen.	aCategoryViewer := CategoryViewer new initializeFor: self				categoryChoice: 'basic'.	playerGetter := aCategoryViewer 				getterTilesFor: (Utilities getterSelectorFor: slotName)				type: #Player.	getterTiles submorphs first acceptDroppingMorph: playerGetter event: nil.	"the pad"	"simulate a drop"	getterTiles makeAllTilesGreen.	getterTiles justGrabbedFromViewer: false.	(getterTiles firstSubmorph)		changeTableLayout;		hResizing: #shrinkWrap;		vResizing: #spaceFill.	ActiveHand attachMorph: getterTiles! !!Player methodsFor: 'slots-user' stamp: 'yo 2/11/2005 15:44'!removeSlotNamed: aSlotName	"The user has requested that an instance variable be removed..."	| aSetter aGetter |	(self okayToRemoveSlotNamed: aSlotName) ifFalse:		[^ self inform: ('Sorry, {1} is inuse in a script.' translated format: {aSlotName})].	aSetter := Utilities setterSelectorFor: aSlotName.	aGetter := Utilities getterSelectorFor: aSlotName.	((self systemNavigation allCallsOn: aSetter) size > 0 or: [(self systemNavigation allCallsOn: aGetter) size > 0]) ifTrue:		[self inform: 'Caution!!  There may be scripts belonging toother objects that may rely on the presence ofthis variable.  If there are, they may now be broken.You may need to fix them up manually.' translated].	self class removeInstVarName: aSlotName asString.	self updateAllViewers! !!Player methodsFor: 'slots-user' stamp: 'sw 7/4/2004 00:26'!setFloatPrecisionFor: aReadout	"If appropriate, set the floatPrecision for the given watcher readout (an UpdatingStringMorph), whose getter is assumed already to be established."		| precision  |	(precision := self defaultFloatPrecisionFor: aReadout getSelector) ~= 1 ifTrue: [aReadout floatPrecision: precision]! !!Player methodsFor: 'slots-user' stamp: 'sw 7/26/2001 12:01'!slotInfoAt: slotName ifAbsent: aBlock	"If the receiver has a slot of the given name, answer its slot info, else answer nil"	| info |	info := self slotInfo at: slotName ifAbsent: [^ aBlock value].	^ info! !!Player methodsFor: 'slots-user' stamp: 'sw 5/16/2001 18:29'!slotNamesOfType: aType	"Answer a list of potential slot names of the given type in the receiver"	| fullList forViewer gettersToOffer |	fullList := (ScriptingSystem systemSlotNamesOfType: aType),		(self class slotGettersOfType: aType).	forViewer := costume renderedMorph selectorsForViewer select:		[:aSel | aSel beginsWith: 'get'].	gettersToOffer := fullList select: [:anItem | forViewer includes: anItem].	^ gettersToOffer collect:		[:aSel | Utilities inherentSelectorForGetter: aSel]! !!Player methodsFor: 'slots-user' stamp: 'sw 8/12/2004 02:27'!tearOffWatcherFor: aSlotGetter	"Tear off a simple textual watcher for the slot whose getter is provided"	| aWatcher anInterface info isNumeric |	info := self slotInfoForGetter: aSlotGetter.	info		ifNotNil:			[isNumeric := info type == #Number]		ifNil:			[anInterface := Vocabulary eToyVocabulary methodInterfaceAt: aSlotGetter ifAbsent: [nil].			isNumeric := anInterface notNil and: [anInterface resultType == #Number]].	aWatcher := UpdatingStringMorph new.		aWatcher		growable: true;		getSelector: aSlotGetter;		putSelector: (info notNil			ifTrue:				[ScriptingSystem setterSelectorForGetter: aSlotGetter]			ifFalse:				[anInterface companionSetterSelector]);		setNameTo: (info notNil			ifTrue:				[Utilities inherentSelectorForGetter: aSlotGetter]			ifFalse:				[anInterface wording]); 		target: self.	isNumeric		ifFalse:			[aWatcher useStringFormat]		ifTrue:			[self setFloatPrecisionFor: aWatcher].	aWatcher		step;		fitContents;		openInHand! !!Player methodsFor: 'slots-user' stamp: 'sw 1/5/2005 22:17'!unlabeledWatcherFor: aGetter	"Answer an unnlabeled readout for viewing a numeric-valued slot of mine"	| aWatcher info anInterface watcherWording itsType vocab aSetter |	info := self slotInfoForGetter: aGetter.	info ifNotNil:			[itsType := info type.			watcherWording := Utilities inherentSelectorForGetter: aGetter.			aSetter := Utilities setterSelectorFor: watcherWording]		ifNil:			[anInterface :=Vocabulary eToyVocabulary methodInterfaceAt: aGetter ifAbsent: [nil].			anInterface				ifNotNil:					[itsType := anInterface resultType.					aSetter := anInterface companionSetterSelector]				ifNil:					[itsType := #Unknown.					aSetter := nil].			watcherWording := anInterface ifNotNil: [anInterface wording] ifNil: ['*']].	vocab := Vocabulary vocabularyForType: itsType.	aWatcher := vocab updatingTileForTarget: self partName: watcherWording getter: aGetter setter: aSetter.	aWatcher setNameTo: (self externalName, '''s ', watcherWording).	aWatcher minHeight: (vocab wantsArrowsOnTiles ifTrue: [22] ifFalse: [14]).	^ aWatcher! !!Player methodsFor: 'translation' stamp: 'sw 7/25/2005 05:04'!changeTypesInWatchersOf: slotName	"The type of a variable has changed; adjust watchers to that fact."	| aGetter newWatcher |	aGetter := Utilities getterSelectorFor: slotName.	self allPossibleWatchersFromWorld do: [:aWatcher |		(aWatcher getSelector = aGetter) ifTrue:			[(aWatcher ownerThatIsA: WatcherWrapper) ifNotNilDo:				[:aWrapper |					newWatcher := (aWrapper submorphs size = 1)						ifTrue:							[WatcherWrapper new unlabeledForPlayer: self getter: aGetter]						ifFalse:							[WatcherWrapper new fancyForPlayer: self getter: aGetter].					newWatcher position: aWatcher position.					aWrapper owner replaceSubmorph: aWrapper by: newWatcher]]]! !!Player methodsFor: 'translation' stamp: 'sw 1/6/2005 16:34'!renameSlotInWatchersOld: oldName new: newName	"A variable has been renamed; get all relevant extant watchers updated.  All this assumed to be happening in the ActiveWorld"	| wasStepping oldGetter |	oldGetter := Utilities getterSelectorFor: oldName.	self allPossibleWatchersFromWorld do: [:aWatcher |		(aWatcher getSelector = oldGetter) ifTrue:			[(wasStepping := aWatcher isStepping) ifTrue: [aWatcher stopStepping].			aWatcher getSelector: (Utilities getterSelectorFor: newName).			aWatcher putSelector ifNotNil:				[aWatcher putSelector: (Utilities setterSelectorFor: newName)].			((aWatcher isKindOf: UpdatingStringMorph) and: [aWatcher hasStructureOfComplexWatcher]) ifTrue:  "Old style fancy watcher"				[aWatcher owner owner traverseRowTranslateSlotOld: oldName to: newName.				(aWatcher target labelFromWatcher: aWatcher) contents: newName, ' = '].			(aWatcher ownerThatIsA: WatcherWrapper) ifNotNilDo:				[:wrapper | wrapper player: self variableName: newName].			wasStepping ifTrue: [aWatcher startStepping]]]! !!Player methodsFor: 'viewer' stamp: 'sw 5/22/2001 14:56'!elementTypeFor: aStringOrSymbol vocabulary: aVocabulary	"Answer whether aStringOrSymbol is best characterized as a #systemSlot, #systemScript, #userSlot, or #userScript.  This is ancient and odious but too tedious to rip out at this point."	| aSymbol anInterface aSlotName |	aSymbol := aStringOrSymbol asSymbol.	aSlotName := Utilities inherentSelectorForGetter: aSymbol.	(self slotInfo includesKey: aSlotName) ifTrue: [^ #userSlot].	(self class isUniClass and: [self class scripts includesKey: aSymbol]) ifTrue: [^ #userScript].		anInterface := aVocabulary methodInterfaceAt: aSymbol ifAbsent: [nil].	^ anInterface		ifNotNil:			[(anInterface resultType == #unknown)				ifTrue:					[#systemScript]				ifFalse:					[#systemSlot]]		ifNil:			[#systemScript]! !!Player methodsFor: 'viewer' stamp: 'sw 1/28/2001 20:17'!externalName	"Answer an external name for the receiver.  If it has none, supply a backstop name"	| aCostume |	^ (aCostume := self costume) ifNotNil: [aCostume externalName] ifNil: ['an orphaned Player']! !!Player methodsFor: 'viewer' stamp: 'tk 8/3/2001 11:08'!newScriptorAround: aPhrase	"Sprout a scriptor around aPhrase, thus making a new script.  aPhrase may either be a PhraseTileMorph (classic tiles 1997-2001) or a SyntaxMorph (2001 onward)"	| aScriptEditor aUniclassScript tw blk |	aUniclassScript := self class permanentUserScriptFor: self unusedScriptName player: self.	aScriptEditor := aUniclassScript instantiatedScriptEditorForPlayer: self.	Preferences universalTiles ifTrue: [		aScriptEditor install.		"aScriptEditor hResizing: #shrinkWrap;			vResizing: #shrinkWrap;			cellPositioning: #topLeft;			setProperty: #autoFitContents toValue: true."		aScriptEditor insertUniversalTiles.  "Gets an empty SyntaxMorph for a MethodNode"		tw := aScriptEditor findA: TwoWayScrollPane.		aPhrase ifNotNil:			[blk := (tw scroller findA: SyntaxMorph "MethodNode") findA: BlockNode.			blk addMorphFront: aPhrase.			aPhrase accept.		].		SyntaxMorph setSize: nil andMakeResizable: aScriptEditor.	] ifFalse: [		aPhrase 				ifNotNil: [aScriptEditor phrase: aPhrase]	"does an install"				ifNil: [aScriptEditor install]	].	self class allSubInstancesDo: [:anInst | anInst scriptInstantiationForSelector: aUniclassScript selector].		"The above assures the presence of a ScriptInstantiation for the new selector in all siblings"	self updateAllViewersAndForceToShow: #scripts.	^ aScriptEditor! !!Player methodsFor: 'viewer' stamp: 'sw 10/30/2000 17:13'!uniqueNameForReference	"Answer a unique name for referring to the receiver"	| itsReferent |	self flag: #deferred.  "The once-and-maybe-future ObjectRepresentativeMorph scheme is for the moment disenfranchised"	"(costume isKindOf: ObjectRepresentativeMorph) ifTrue:		[((itsReferent := costume objectRepresented) isKindOf: Class)			ifTrue:				[^ itsReferent name].		itsReferent == Smalltalk ifTrue: [^ #Smalltalk].		itsReferent == ScriptingSystem ifTrue: [^ #ScriptingSystem]]."	^  super uniqueNameForReference! !!Player methodsFor: 'slot-kedama' stamp: 'yo 2/2/2005 17:47'!addPatchVarNamed: nameSymbol	| f |	f := KedamaPatchMorph newExtent: self costume dimensions.	f assuredPlayer assureUniClass.	f setNameTo: (ActiveWorld unusedMorphNameLike: f innocuousName).	self addInstanceVariable2Named: nameSymbol type: #Patch value: f player.	^ f.! !!Player methodsFor: 'slot-kedama' stamp: 'KR 4/14/2006 15:40'!createSlotForPatch: aPatchMorph	"anEmbeddedMorph has just been added to my costume because of explicit user action.  	Create an instance variable and accessors for it as a Player-valued slot."	| itsName openViewers |	self costume isInWorld ifFalse: [ ^self ].	itsName := aPatchMorph externalName asSymbol.	self slotInfo		at: itsName		put: (SlotInformation new initialize type: #Patch).	self addInstanceVarNamed: itsName withValue: (aPatchMorph assuredPlayer).	self class compileAccessorsFor: itsName.	openViewers := self allOpenViewersOnReceiverAndSiblings.	openViewers isEmpty		ifTrue: [^ self]		ifFalse: [| aPresenter | 			(aPresenter := self costume presenter)				ifNil: [^ self].			openViewers				do: [:aViewer | aPresenter updateViewer: aViewer forceToShow: ScriptingSystem nameForInstanceVariablesCategory]]! !!Player methodsFor: 'slot-kedama' stamp: 'yo 9/13/2005 22:03'!newPatch	| f |	f := KedamaPatchMorph newExtent: self costume renderedMorph dimensions.	f assuredPlayer assureUniClass.	f setNameTo: (ActiveWorld unusedMorphNameLike: f innocuousName).	self createSlotForPatch: f.	self addToPatchDisplayList: f assuredPlayer.	self costume world primaryHand attachMorph: f.	^ f.! !!Player methodsFor: 'slot-kedama' stamp: 'yo 8/18/2005 15:33'!newTurtle	| m |	m := KedamaTurtleMorph new openInWorld.	self costume hasNoTurtleBreed ifTrue: [m color: Color red].	self useTurtle: m player.	m setNameTo: (ActiveWorld unusedMorphNameLike: m innocuousName).	self costume world primaryHand attachMorph: m.	^ m.! !!Player methodsFor: 'slot-kedama' stamp: 'yo 8/10/2004 12:37'!newTurtleSilently	| m |	m := KedamaTurtleMorph new openInWorld.	self useTurtle: m player.	m turtleCount: 0.	m setNameTo: (ActiveWorld unusedMorphNameLike: m innocuousName).	^ m.! !!Player class methodsFor: 'housekeeping' stamp: 'ls 10/10/1999 13:42'!abandonUnnecessaryUniclasses	"Player abandonUnnecessaryUniclasses"	| oldCount oldFree newFree newCount report |	oldCount := self subclasses size - 1.	oldFree := Smalltalk garbageCollect.	self allSubInstances do:		[:aPlayer | aPlayer revertToUnscriptedPlayerIfAppropriate.  		"encourage last one to get garbage-collected"		aPlayer := nil ].	ScriptingSystem spaceReclaimed.	newFree := Smalltalk garbageCollect.	newCount := self subclasses size - 1.	report := 'Before: ', oldCount printString, ' uniclasses, ', oldFreeprintString, ' bytes freeAfter:  ', newCount printString, ' uniclasses, ', newFree printString, 'bytes free'.	Transcript cr; show: 'abandonUnnecessaryUniclasses:'; cr; show: report.	^ report	! !!Player class methodsFor: 'housekeeping' stamp: 'sw 12/15/2004 20:43'!cleanseScripts	"Fix up various known structure errors in the uniclass relating to the scripts dctionary.  Answer the number of fixes made."	| errs ed |	scripts ifNil: [scripts := IdentityDictionary new].	errs := 0.	(scripts includesKey: nil) ifTrue: [errs := errs + 1.  scripts removeKey: nil].	scripts keysAndValuesDo: 		[:sel :uniclassScript |			uniclassScript				ifNil:					[errs := errs + 1.					Transcript cr; show: ' fix type 1, nil scripts key'.					scripts removeKey: sel]				ifNotNil:					[(ed := uniclassScript currentScriptEditor)						ifNil:							[errs := errs + 1.							Transcript cr; show: ' fix type 2, sel = ', sel.							self someInstance removeScriptWithSelector: uniclassScript selector.]						ifNotNil:							[uniclassScript playerClassPerSe								ifNil:									[errs := errs + 1.									Transcript cr; show: ' fix type 3, sel = ', sel.									uniclassScript playerClass: self selector:  sel]								ifNotNil:									[(ed scriptName ~= uniclassScript selector) ifTrue:										[errs := errs + 1.										ed restoreScriptName: sel.										Transcript cr; show: ' fix type 4, sel = ', sel.]]]]].	^ errs! !!Player class methodsFor: 'housekeeping' stamp: 'sw 5/19/2000 16:26'!cleanseSlotInfo	| newInfo |	slotInfo ifNotNil:		[newInfo := IdentityDictionary new.		slotInfo associationsDo:			[:assoc | newInfo at: assoc key asSymbol put: assoc value].		slotInfo := newInfo]! !!Player class methodsFor: 'housekeeping' stamp: 'ar 4/25/2005 13:36'!freeUnreferencedSubclasses	"Player classes may hold in their class instance variables referencesto instances of themselves that are housekeepingwise unreachable. Thismethod allows such loops to be garbage collected. This is done in threesteps:	1. Remove user-created subclasses from the 'subclasses' set and fromSmalltalk. Only remove classes whose name begins with 'Player' and whichhave no references.	2. Do a full garbage collection.	3. Enumerate all Metaclasses and find those whose soleInstance'ssuperclass is this class. Reset the subclasses set to this set ofclasses, and add back to Smalltalk."	"Player freeUnreferencedSubclasses"	| oldFree candidatesForRemoval class |	oldFree := Smalltalk garbageCollect.	candidatesForRemoval := self subclasses asOrderedCollection select:		[:aClass | (aClass name beginsWith: 'Player') and: [aClass nameendsWithDigit]].	"Break all system links and then perform garbage collection."	candidatesForRemoval do:		[:c | self removeSubclass: c.  "Break downward subclass pointers."		Smalltalk removeKey: c name ifAbsent: [].  "Break binding of globalname"].	candidatesForRemoval := nil.	Smalltalk garbageCollect.  "Now this should reclaim all unusedsubclasses"	"Now reconstruct system links to subclasses with valid references."	"First restore any global references via associations"	(Association allSubInstances select:			[:assn | (assn key isSymbol)					and: [(assn key beginsWith: 'Player')					and: [assn key endsWithDigit]]])		do: [:assn | class := assn value.			(class isKindOf: self class) ifTrue:				[self addSubclass: class.				Smalltalk add: assn]].	"Then restore any further direct references, creating newassociations."	(Metaclass allInstances select:			[:m | (m soleInstance name beginsWith: 'Player')					and: [m soleInstance name endsWithDigit]])		do: [:m | class := m soleInstance.			((class isKindOf: self class) and: [(Smalltalk includesKey: classname) not]) ifTrue:				[self addSubclass: class.				Smalltalk at: class name put: class]].	SystemOrganization removeMissingClasses.	^ Smalltalk garbageCollect - oldFree! !!Player class methodsFor: 'housekeeping' stamp: 'yo 6/3/2004 13:36'!removeUninstantiatedSubclassesSilently	"Remove the classes of any subclasses that have neither instances nor subclasses.  Answer the number of bytes reclaimed"	"Player removeUninstantiatedSubclassesSilently"	| candidatesForRemoval  oldFree |	oldFree := Smalltalk garbageCollect.	candidatesForRemoval := OrderedCollection new.	self allSubclassesWithLevelDo: [:e :l | candidatesForRemoval add: e] startingLevel: 2.	candidatesForRemoval := candidatesForRemoval reverse.	candidatesForRemoval :=		candidatesForRemoval select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval := candidatesForRemoval select:		[:aClass | aClass isSystemDefined not].	candidatesForRemoval do: [:c | c removeFromSystemUnlogged].	^ Smalltalk garbageCollect - oldFree! !!Player class methodsFor: 'namespace' stamp: 'sw 4/27/1998 23:42'!makeReferenceFor: anObject	| stem otherNames i partName |	stem := anObject class name.	(stem size > 5 and: [stem endsWith: 'Morph'])		ifTrue: [stem := stem copyFrom: 1 to: stem size - 5].	stem := stem first asLowercase asString, stem allButFirst.	otherNames := self class allInstVarNames.	i := 1.	[otherNames includes: (partName := stem, i printString)]		whileTrue: [i := i + 1].	self class addInstVarName: partName.	self instVarAt: self class instSize put: anObject.  "assumes added as last field"	self compileReferenceAccessorFor: partName.	^ self referenceAccessorSelectorFor: partName! !!Player class methodsFor: 'other' stamp: 'tk 6/26/1998 18:21'!chooseUniqueClassName	| ii className |	ii := BiggestSubclassNumber ifNil: [1] ifNotNil: [BiggestSubclassNumber+1].	[className := (self name , ii printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [ii := ii + 1].	BiggestSubclassNumber := ii.	^ className	! !!Player class methodsFor: 'other' stamp: 'yo 6/2/2004 23:34'!chooseUniqueTurtleClassName	| ii className |	className := self name.	[className last isDigit] whileTrue: [className := className copyFrom: 1 to: className size - 1].	ii := BiggestSubclassNumber ifNil: [1] ifNotNil: [BiggestSubclassNumber+1].	[className := (className , ii printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [ii := ii + 1].	BiggestSubclassNumber := ii.	^ className	! !!Player class methodsFor: 'other' stamp: 'sw 6/4/2004 13:56'!typicalInstanceName	"For the purpose of documentation, answer the name of a named instance of the receiver, if possible, else answer the class name"	| known |	known := (self allInstances collect: [:i | i knownName]) detect: [:n | n isEmptyOrNil not] ifNone: [nil].	^ known ifNil: [self name]! !!Player class methodsFor: 'scripts' stamp: 'sw 2/17/2001 03:44'!assuredMethodInterfaceFor: aSelector	"Answer the method interface object for aSelector, creating it if it does not already exist."	| selSym  aMethodInterface |	selSym := aSelector asSymbol.	aMethodInterface := self scripts at: selSym ifAbsent: 		[scripts at: selSym put: (self nascentUserScriptInstance playerClass: self selector: selSym)].		^ aMethodInterface! !!Player class methodsFor: 'scripts' stamp: 'sw 4/9/98 21:55'!jettisonScripts	scripts := IdentityDictionary new! !!Player class methodsFor: 'scripts' stamp: 'sw 12/19/2003 23:28'!namedUnaryTileScriptSelectors	"Answer a list of all the selectors of named unary tile scripts"	| sel |	scripts ifNil: [^ OrderedCollection new].	^ scripts select: [:aScript | ((sel := aScript selector) ~~ nil) and: [sel numArgs == 0]] 		thenCollect: [:aScript | aScript selector]! !!Player class methodsFor: 'scripts' stamp: 'sw 2/18/2001 18:42'!nascentUserScriptInstance	"Answer a new script object of the appropriate class"	| classToUse |	classToUse := Preferences universalTiles		ifTrue:	[MethodWithInterface]		ifFalse:	[UniclassScript].	^ classToUse new! !!Player class methodsFor: 'scripts' stamp: 'sw 2/17/2001 00:59'!permanentUserScriptFor: aSelector player: aPlayer	"Create and answer a suitable script  object for the given player (who will be an instance of the receiver) and selector.  Save that script-interface object in my (i.e. the class's) directory of scripts"	|  entry |	scripts ifNil: [scripts := IdentityDictionary new].	entry := self nascentUserScriptInstance playerClass: aPlayer class selector: aSelector.	scripts at: aSelector put: entry.	^ entry! !!Player class methodsFor: 'scripts' stamp: 'sw 4/20/2001 20:11'!scripts	"Answer the receiver's scripts -- an IdentityDictionary"	scripts		ifNil:			[scripts := IdentityDictionary new]		ifNotNil:			[self cleanseScriptsOfNilKeys].	^ scripts! !!Player class methodsFor: 'scripts' stamp: 'tk 8/31/1998 15:41'!scripts: aDict	"for copying"	scripts := aDict! !!Player class methodsFor: 'scripts' stamp: 'tk 1/22/2001 14:54'!tilesFrom: aString	| code tree syn block phrase |	"Construct SyntaxMorph tiles for the String."	"This is really cheating!!  Make a true parse tree later. -tk"	code := String streamContents: [:strm | 		strm nextPutAll: 'doIt'; cr; tab.		strm nextPutAll: aString].	"decompile to tiles"	tree := Compiler new 		parse: code 		in: self		notifying: nil.	syn := tree asMorphicSyntaxUsing: SyntaxMorph.	block := syn submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == BlockNode] ifFalse: [false]].	phrase := block submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == MessageNode] ifFalse: [false]].	^ phrase! !!Player class methodsFor: 'scripts' stamp: 'sw 3/28/2001 16:18'!userScriptForPlayer: aPlayer selector: aSelector	"Answer the user script for the player (one copy for all instances of the uniclass) and selector"	|  newEntry existingEntry |	scripts ifNil: [scripts := IdentityDictionary new].	existingEntry := scripts at: aSelector ifAbsent: [nil].	"Sorry for all the distasteful isKindOf: and isMemberOf: stuff here, folks; it arises out of concern for preexisting content saved on disk from earlier stages of this architecture.  Someday much of it could be cut loose"	Preferences universalTiles		ifTrue:			[(existingEntry isMemberOf: MethodWithInterface) ifTrue: [^ existingEntry].			newEntry := (existingEntry isKindOf: UniclassScript)				ifTrue:					[existingEntry as: MethodWithInterface] "let go of extra stuff if it was UniclassScript"				ifFalse:					[MethodWithInterface new playerClass: aPlayer class selector: aSelector].			scripts at: aSelector put: newEntry.			^ newEntry]		ifFalse:			[(existingEntry isKindOf: UniclassScript)				ifTrue:					[^ existingEntry]				ifFalse:					[newEntry := UniclassScript new playerClass: self selector: aSelector.					scripts at: aSelector put: newEntry.					existingEntry ifNotNil: "means it is a grandfathered UserScript that needs conversion"						[newEntry convertFromUserScript: existingEntry].					^ newEntry]]! !!Player class methodsFor: 'slots' stamp: 'md 7/23/2006 15:13'!compileInstVarAccessorsFor: varName	"Compile getters and setteres for the given instance variable name"	| nameString |	nameString := varName asString capitalized.	self compileSilently: ('get', nameString, '	^ ', varName)		classified: 'access'.	self compileSilently: ('set', nameString, ': val	', varName, ' := val')		classified: 'access'! !!Player class methodsFor: 'slots' stamp: 'sw 12/17/1998 20:31'!removeInstVarAccessorsFor: varName	| nameString |	nameString := varName asString capitalized.	self removeSelector: ('get', nameString) asSymbol.	self removeSelector: ('set', nameString, ':') asSymbol! !!Player class methodsFor: 'slots' stamp: 'sw 5/25/2001 10:26'!slotGettersOfType: aType	"Answer a list of gettter selectors for slots of mine of the given type"	| aList |	aList := OrderedCollection new.	self slotInfo associationsDo:		[:assoc |			(assoc value type = aType) ifTrue:				[aList add: (Utilities getterSelectorFor: assoc key)]].	^ aList! !!Player class methodsFor: 'slots' stamp: 'sw 4/8/98 11:58'!slotInfo	slotInfo ifNil: [slotInfo := IdentityDictionary new].	^ slotInfo! !!Player class methodsFor: 'slots' stamp: 'tk 8/31/1998 15:44'!slotInfo: aDict	"for copying"	slotInfo := aDict! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'sw 6/4/2004 15:04'!addMethodReferencesTo: aCollection	"For each extant script in the receiver, add a MethodReference object"	| sel |	self scripts do:		[:aScript |			(sel := aScript selector) ifNotNil:				[aCollection add: (MethodReference new setStandardClass: self methodSymbol: sel)]]! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'sw 10/30/2000 07:04'!baseUniclass	"Answer the uniclass that new instances should be instances of; this protocol allows for individual cards of a background to have their own class"	| curr |	curr := self.	[curr theNonMetaClass superclass name endsWithDigit]		whileTrue:			[curr := curr superclass].	^ curr"CardPlayer100 baseUniclass CardPlayer100X baseUniclass"! !!Player class methodsFor: 'turtles' stamp: 'yo 9/17/2004 08:06'!createSequencialStubSubclass	| instVarString classInstVarString aName aClass |	instVarString := KedamaSequenceExecutionStub instVarNames.	classInstVarString := ''.	aName := self chooseUniqueTurtleClassName.	aClass := self subclass: aName instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	classInstVarString size > 0 ifTrue:		[aClass class instanceVariableNames: classInstVarString].	aClass copyAllCategoriesUnobtrusivelyFrom: KedamaSequenceExecutionStub.	^ aClass! !!Player class methodsFor: 'turtles' stamp: 'yo 9/14/2004 21:36'!createTurtleSubclass	| instVarString classInstVarString aName aClass |	instVarString := KedamaTurtleVectorPlayer instVarNames.	classInstVarString := ''.	aName := self chooseUniqueTurtleClassName.	aClass := self subclass: aName instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	classInstVarString size > 0 ifTrue:		[aClass class instanceVariableNames: classInstVarString].	aClass copyAllCategoriesUnobtrusivelyFrom: KedamaTurtleVectorPlayer.	^ aClass! !!PlayerReferenceReadout methodsFor: 'initialization' stamp: 'sw 4/26/1998 02:07'!objectToView: objectOrNil viewSelector: aSelector putSelector: aPutSelector	self objectToView: objectOrNil viewSelector: aSelector.	putSelector := aPutSelector! !!PlayerSurrogate methodsFor: 'accessing' stamp: 'sw 7/28/2004 21:16'!playerRepresented: anObject	"Set the value of playerRepresented"	playerRepresented := anObject.	self rebuildRow.	self setNameTo: anObject costume topRendererOrSelf externalName! !!PlayerSurrogate methodsFor: 'accessing' stamp: 'sw 7/28/2004 22:19'!rebuildRow	"Rebuild the row"	| aThumbnail aTileButton aViewerButton |	self removeAllMorphs.	self layoutInset: 2; cellInset: 3.	self beTransparent.	aThumbnail := ThumbnailForAllPlayersTool new objectToView: playerRepresented viewSelector: #graphicForViewerTab.	aThumbnail setBalloonText: 'Click here to reveal this object' translated.	self addMorphBack: aThumbnail.	aThumbnail on: #mouseUp send: #beRevealedInActiveWorld to: playerRepresented.		"aMenuButton := IconicButton new labelGraphic: Cursor menu.	aMenuButton target: self;		actionSelector: #playerButtonHit;		color: Color transparent;		borderWidth: 0;		shedSelvedge;		actWhen: #buttonDown.	aMenuButton setBalloonText: 'Press here to get a menu'.	self addMorphBack: aMenuButton."	aViewerButton := IconicButton new labelGraphic: (ScriptingSystem formAtKey: #Viewer).	aViewerButton color: Color transparent; 			actWhen: #buttonUp;			actionSelector: #beViewed; target: playerRepresented;			setBalloonText: 'click here to obtain this object''s Viewer' translated;			color: Color transparent;			borderWidth: 0;			shedSelvedge.	self addMorphBack: aViewerButton.	aTileButton := IconicButton  new borderWidth: 0.	aTileButton labelGraphic: (TileMorph new setToReferTo: playerRepresented) imageForm.	aTileButton color: Color transparent; 			actWhen: #buttonDown;			actionSelector: #tearOffTileForSelf; target: playerRepresented;			setBalloonText: 'click here to obtain a tile that refers to this player.' translated.	self addMorphBack: aTileButton."	aNameMorph := UpdatingStringMorph new		useStringFormat;		target:  playerRepresented;		getSelector: #nameForViewer;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aNameMorph putSelector: #setName:.		aNameMorph setProperty: #okToTextEdit toValue: true.	aNameMorph step.	self addMorphBack: aNameMorph.	aNameMorph setBalloonText: 'Click here to edit the player''s name.'.	"	! !!PluggableButtonController methodsFor: 'basic control sequence' stamp: 'acg 3/13/2000 08:49'!controlInitialize 	"Provide feedback indicating that button has been entered with the mouse down. If triggerOnMouseDown is true, then do the button action on mouse down--and don't bother with the feedback since the action happens immediately."	sensor anyButtonPressed ifFalse: [^ self].	view triggerOnMouseDown		ifTrue: [sensor yellowButtonPressed 			ifTrue: [self yellowButtonActivity]			ifFalse: [view performAction]]		ifFalse: [view toggleMouseOverFeedback.				 shownAsComplemented := true]! !!PluggableButtonController methodsFor: 'button activity' stamp: 'di 9/7/1999 08:44'!yellowButtonActivity	"Invoke the model's menu.  This is option-click, NOT the normal button press."	| menu |	menu := view getMenu: false.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [self terminateAndInitializeAround: [menu invokeOn: model]].! !!PluggableButtonController methodsFor: 'control defaults' stamp: 'sma 5/28/2000 16:29'!controlActivity 	shownAsComplemented ifNil: [^ self].	shownAsComplemented = self viewHasCursor		ifFalse:			[view ifNotNil: [view toggleMouseOverFeedback]. 			shownAsComplemented := shownAsComplemented not]! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jrm 6/1/1998 21:53'!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector := aSymbol! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/7/98 19:17'!askBeforeChanging: aBoolean	"If this preference is turned on, then give the model an opportunity to ask the user before accepting a change that might cause unaccepted edits to be lost."	askBeforeChanging := aBoolean.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'nk 4/17/2004 19:49'!label: aStringOrDisplayObject 	"Label this button with the given String or DisplayObject."	((aStringOrDisplayObject isKindOf: Paragraph)	or: [aStringOrDisplayObject isForm])		ifTrue: [label := aStringOrDisplayObject]		ifFalse: [label := aStringOrDisplayObject asParagraph].	self centerLabel.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 17:43'!shortcutCharacter: aCharacter 	"Set the character to be used as a keyboard shortcut for turning on this switch."	shortcutCharacter := aCharacter.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/7/98 19:16'!triggerOnMouseDown: aBoolean	"If this preference is turned on, then trigger my action immediately when the mouse goes down."	triggerOnMouseDown := aBoolean.! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/4/98 20:49'!displayComplemented	"Complement the receiver if it isn't already."	complemented ifFalse: [		complemented := true.		Display reverse: self insetDisplayBox].! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/2/98 18:43'!displayNormal	"Complement the receiver if its mode is 'complemented'."	complemented ifTrue: [		complemented := false.		Display reverse: self insetDisplayBox].! !!PluggableButtonView methodsFor: 'displaying' stamp: 'acg 2/23/2000 00:18'!displayView	"Displays this switch and its label, if any."	self clearInside.	label ifNotNil: [		(label isKindOf: Paragraph) ifTrue: [			label foregroundColor: self foregroundColor				 backgroundColor: self backgroundColor].		label displayOn: Display				at: label boundingBox topLeft				clippingBox: self insetDisplayBox].	complemented := false.! !!PluggableButtonView methodsFor: 'initialize-release' stamp: 'jm 5/2/1998 15:20'!initialize 	super initialize.	label := nil.	getStateSelector := nil.	actionSelector := nil.	getLabelSelector := nil.	getMenuSelector := nil.	shortcutCharacter := nil.	askBeforeChanging := false.	triggerOnMouseDown := false.	complemented := false.! !!PluggableButtonView methodsFor: 'initialize-release' stamp: 'sw 2/17/2002 05:32'!on: anObject getState: getStateSel action: actionSel getArguments: getArgumentsSel from: argsProvidor label: labelSel menu: menuSel	self initialize.	self model: anObject.	getStateSelector := getStateSel.	actionSelector := actionSel.	argumentsSelector := getArgumentsSel.	argumentsProvider := argsProvidor.	getLabelSelector := labelSel.	getMenuSelector := menuSel! !!PluggableButtonView methodsFor: 'initialize-release' stamp: 'tk 4/29/1998 11:18'!on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel	self initialize.	self model: anObject.	getStateSelector := getStateSel.	actionSelector := actionSel.	getLabelSelector := labelSel.	getMenuSelector := menuSel.! !!PluggableButtonView methodsFor: 'private' stamp: 'nk 4/17/2004 19:49'!centerAlignLabelWith: aPoint	"Align the center of the label with aPoint."	| alignPt |	alignPt := label boundingBox center.	(label isKindOf: Paragraph) ifTrue: 		[alignPt := alignPt + (0@(label textStyle leading))]. 	(label isForm)	  ifTrue: [label offset: 0 @ 0].	label align: alignPt with: aPoint! !!PluggableButtonView methodsFor: 'private' stamp: 'di 6/26/1998 11:04'!getMenu: shiftKeyDown	"Answer the menu for this view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu := CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonView methodsFor: 'private' stamp: 'acg 2/23/2000 00:09'!insetDisplayBox	"Answer the receiver's inset display box. The inset display box is the 	intersection of the receiver's window, tranformed to display coordinates, 	and the inset display box of the superView, inset by the border width. 	The inset display box represents the region of the display screen in 	which the inside of the receiver (all except the border) is displayed. If 	the receiver is totally clipped by the display screen and its superView, 	the resulting Rectangle will be invalid."	insetDisplayBox ifNil: 		[insetDisplayBox := self computeInsetDisplayBox.		 self centerLabel].	^insetDisplayBox! !!PluggableButtonView class methodsFor: 'example' stamp: 'jm 4/7/98 19:55'!example	"PluggableButtonView example"	| s1 s2 s3 b1 b2 b3 topView |	s1 := Switch new.	s2 := Switch new turnOn.	s3 := Switch new.	s2 onAction: [s3 turnOff].	s3 onAction: [s2 turnOff].	b1 := (PluggableButtonView on: s1 getState: #isOn action: #switch) label: 'S1'.	b2 := (PluggableButtonView on: s2 getState: #isOn action: #turnOn) label: 'S2'.	b3 := (PluggableButtonView on: s3 getState: #isOn action: #turnOn) label: 'S3'.	b1 borderWidth: 1.	b2 borderWidth: 1.	b3 borderWidth: 1.	topView := StandardSystemView new		label: 'Switch Test';		addSubView: b1;		addSubView: b2 toRightOf: b1;		addSubView: b3 toRightOf: b2.	topView controller open.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/27/1998 23:55'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered to be equal, false otherwise"	equalBlock := aBlock.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and must return the hash value of the given argument."	hashBlock := aBlock.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'dvf 6/10/200019:34'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet := PluggableSet new: self size.	self equalBlock ifNotNil: [aSet equalBlock: self equalBlock fixTemps].	self hashBlock ifNotNil: [aSet hashBlock: self hashBlock fixTemps].	self keysDo: [:key | aSet add: key].	^ aSet! !!PluggableDictionary methodsFor: 'copying' stamp: 'dvf 6/10/2000 19:35'!postCopyBlocks	hashBlock := hashBlock copy.	equalBlock := equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock ifNotNil: [hashBlock fixTemps].	equalBlock ifNotNil: [equalBlock fixTemps]! !!PluggableDictionary methodsFor: 'private' stamp: 'dvf 6/11/2000 01:33'!scanFor: anObject 	"Scan the key array for the first slot containing either a nil(indicating 	  an empty slot) or an element that matches anObject. Answer the index 	  	of that slot or zero if no slot is found. This  method will beoverridden   	in various subclasses that have different interpretations for matching  	elements."	| element start finish |	start := (hashBlock ifNil: [anObject hash]				ifNotNil: [hashBlock value: anObject])				\\ array size + 1.	finish := array size.	"Search from (hash mod size) to the end."	start to: finish do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element key = anObject]				ifNotNil: [equalBlock value: element key value: anObject]])			ifTrue: [^ index]].	"Search from 1 to where we started."	1 to: start - 1 do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element key = anObject]				ifNotNil: [equalBlock value: element key value: anObject]])			ifTrue: [^ index]].	^ 0"No match AND no empty slot"! !!PluggableListController methodsFor: 'private' stamp: 'di 5/25/1998 10:14'!terminateDuringSelect: trueOrFalse	terminateDuringSelect := trueOrFalse! !!PluggableListControllerOfMany methodsFor: 'control defaults' stamp: 'tpr 10/4/2001 22:19'!redButtonActivity	| selection firstHit turningOn lastSelection pt scrollFlag |	model okToChange ifFalse: [^ self].		"Don't change selection if model refuses to unlock"	firstHit := true.	scrollFlag := false.	lastSelection := 0.	[sensor redButtonPressed] whileTrue: 		[selection := view findSelection: (pt := sensor cursorPoint).		selection == nil ifTrue:  "Maybe out of box - check for auto-scroll"			[pt y < view insetDisplayBox top ifTrue:				[self scrollView: view list lineGrid.				scrollFlag := true.				selection := view firstShown].			pt y > view insetDisplayBox bottom ifTrue:				[self scrollView: view list lineGrid negated.				scrollFlag := true.				selection := view lastShown]].		(selection == nil or: [selection = lastSelection]) ifFalse: 			[firstHit ifTrue:				[firstHit := false.				turningOn := (view listSelectionAt: selection) not].			view selection: selection.			(view listSelectionAt: selection) == turningOn ifFalse:				[view displaySelectionBox.				view listSelectionAt: selection put: turningOn].			lastSelection := selection]].	selection notNil ifTrue:		["Normal protocol delivers change, so unchange first (ugh)"		view listSelectionAt: selection put: (view listSelectionAt: selection) not.		self changeModelSelection: selection].	scrollFlag ifTrue: [self moveMarker]! !!PluggableListControllerOfMany methodsFor: 'scrolling' stamp: 'tk 4/8/98 11:09'!scrollView: anInteger 	"Need to minimize the selections which get recomputed"	| oldLimit |	oldLimit := anInteger > 0		ifTrue: [view firstShown]		ifFalse: [view lastShown].	(view scrollBy: anInteger)		ifTrue: [anInteger > 0  "Highlight selections brought into view"					ifTrue: [view highlightFrom: view firstShown								to: (oldLimit-1 min: view lastShown)]					ifFalse: [view highlightFrom: (oldLimit+1 max: view firstShown)								to: view lastShown].				^ true]		ifFalse: [^ false]! !!PluggableListMorph methodsFor: 'model access' stamp: 'apb 5/23/2007 14:16'!basicKeyPressed: aChar 	| oldSelection nextSelection max milliSeconds slowKeyStroke nextSelectionList nextSelectionText |	nextSelection := oldSelection := self getCurrentSelectionIndex.	max := self maximumSelection.	milliSeconds := Time millisecondClockValue.	slowKeyStroke := milliSeconds - lastKeystrokeTime > 300.	lastKeystrokeTime := milliSeconds.	nextSelectionList := OrderedCollection newFrom: (self getList copyFrom: oldSelection + 1 to: max).	nextSelectionList addAll: (self getList copyFrom: 1 to: ((oldSelection - 1) max: 0)).	slowKeyStroke		ifTrue: ["forget previous keystrokes and search in following elements"			lastKeystrokes := aChar asLowercase asString.			oldSelection > 0 ifTrue: [nextSelectionList addLast: (self getList at: oldSelection)]]		ifFalse: ["append quick keystrokes but don't move selection if it still matches"			lastKeystrokes := lastKeystrokes , aChar asLowercase asString.			oldSelection > 0 ifTrue: [nextSelectionList addFirst: (self getList at: oldSelection)]].	"Get rid of blanks and style used in some lists"	nextSelectionText := nextSelectionList		detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]		ifNone: [^ self flash "match not found"].	"No change if model is locked"	model okToChange ifFalse: [^ self].	nextSelection := self getList findFirst: [:a | a = nextSelectionText].	oldSelection == nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: nextSelection! !!PluggableListMorph methodsFor: 'scrolling' stamp: 'ge 9/6/2006 19:02'!numSelectionsInView	"Answer the scroller's height based on the average number of submorphs."		(scroller submorphCount > 0) ifFalse:[ ^0 ].		"ugly hack, due to code smell.	PluggableListMorph added another level of indirection, 	There is always only one submorph - a LazyListMorph which holds the actual list,	but TransformMorph doesn't know that and we are left with a breach of interface.		see vUnadjustedScrollRange for another bad example."			^scroller numberOfItemsPotentiallyInViewWith: (scroller 												submorphs last getListSize).! !!PluggableListView methodsFor: 'initialization' stamp: 'di 4/10/98 09:56'!autoDeselect: trueOrFalse	"Enable/disable autoDeselect (see class comment)"	autoDeselect := trueOrFalse.! !!PluggableListView methodsFor: 'initialization' stamp: 'di 6/20/2001 09:58'!list: arrayOfStrings	"Set the receivers items to be the given list of strings	The instance variable 'items' holds the original list. The instance variable 'list' is a paragraph constructed from this list."	((items == arrayOfStrings) "fastest" or: [items = arrayOfStrings]) ifTrue: [^ self].	items := arrayOfStrings.	isEmpty := arrayOfStrings isEmpty.	"add top and bottom delimiters"	list := ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do:					[:item | item == nil ifFalse:						[(item isMemberOf: MethodReference)  "A very specific fix for MVC"							ifTrue: [s nextPut: item asStringOrText]							ifFalse: [s nextPut: item]]].				s nextPut: bottomDelimiter])		 style: self assuredTextStyle.	selection := self getCurrentSelectionIndex.	self positionList.! !!PluggableListView methodsFor: 'initialization' stamp: 'tk 4/12/1998 08:25'!menu: getMenuSel	getMenuSelector := getMenuSel! !!PluggableListView methodsFor: 'initialization' stamp: 'sw 8/18/1998 12:04'!menuTitleSelector: getMenuTitleSel	getMenuTitleSelector := getMenuTitleSel! !!PluggableListView methodsFor: 'initialization' stamp: 'di 4/10/98 09:55'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self model: anObject.	getListSelector := getListSel.	getSelectionSelector := getSelectionSel.	setSelectionSelector := setSelectionSel.	getMenuSelector := getMenuSel.	keystrokeActionSelector := keyActionSel.	autoDeselect := true.	self borderWidth: 1.	self list: self getList.! !!PluggableListView methodsFor: 'model access' stamp: 'di 5/6/1998 20:52'!changeModelSelection: anInteger	"Change the model's selected item index to be anInteger."	| newIndex |	newIndex := anInteger.	(autoDeselect == nil or: [autoDeselect]) ifTrue:		[getSelectionSelector ifNotNil:			[(model perform: getSelectionSelector) = anInteger ifTrue:				["Click on existing selection deselects"				newIndex := 0]]].	setSelectionSelector ifNotNil:		[model perform: setSelectionSelector with: newIndex].! !!PluggableListView methodsFor: 'model access'!getList 	"Answer the list to be displayed."	| lst |	getListSelector == nil ifTrue: [^ #()].	lst := model perform: getListSelector.	lst == nil ifTrue: [^ #()].	^ lst! !!PluggableListView methodsFor: 'model access' stamp: 'sw 8/18/1998 12:07'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu |	getMenuSelector == nil ifTrue: [^ nil].	menu := CustomMenu new.	getMenuSelector numArgs = 1		ifTrue:			[aMenu := model perform: getMenuSelector with: menu.			getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].			^ aMenu].	getMenuSelector numArgs = 2		ifTrue: [aMenu := model perform: getMenuSelector with: menu with: shiftKeyDown.				getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].				^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'model access' stamp: 'nk 6/29/2004 14:45'!handleKeystroke: aChar	"Answer the menu for this list view."	| args aSpecialKey |	aSpecialKey := aChar asciiValue.	aSpecialKey < 32 ifTrue: [ self specialKeyPressed: aSpecialKey. ^nil ].	keystrokeActionSelector ifNil: [^ nil].	controller controlTerminate.	(args := keystrokeActionSelector numArgs) = 1		ifTrue: [model perform: keystrokeActionSelector with: aChar.				^ controller controlInitialize].	args = 2		ifTrue: [model perform: keystrokeActionSelector with: aChar with: self.				^ controller controlInitialize].	^ self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'model access' stamp: 'nk 6/29/2004 14:42'!specialKeyPressed: keyEvent	"Process the up and down arrows in a list pane."     | oldSelection nextSelection max min howMany |	(#(1 4 11 12 30 31) includes: keyEvent) ifFalse: [ ^ false ].     oldSelection := self getCurrentSelectionIndex.     nextSelection := oldSelection.     max := self maximumSelection.     min := self minimumSelection.     howMany := self numSelectionsInView.	"get this exactly??"     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection := 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection := max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection - howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany) min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[model okToChange			ifTrue:				[self changeModelSelection: nextSelection.				"self controller moveMarker"]].		^true			! !!PluggableListView methodsFor: 'updating' stamp: 'BG 1/22/2004 13:15'!verifyContents	| newItems existingSelection anIndex |	"Called on window reactivation to react to possible structural changes.  Update contents if necessary."	newItems := self getList.	((items == newItems) "fastest" or: [items = newItems]) ifTrue: [^ self].	self flash.  "list has changed beneath us; could get annoying, but hell"	existingSelection := list stringAtLineNumber: (selection + (topDelimiter ifNil: [0] ifNotNil: [1])).  "account for cursed ------ row"	self list: newItems.	(newItems size > 0 and: [newItems first isKindOf: Symbol]) ifTrue:		[existingSelection := existingSelection asSymbol].	(anIndex := newItems indexOf: existingSelection ifAbsent: [nil])		ifNotNil:			[model noteSelectionIndex: anIndex for: getListSelector.]		ifNil:			[self changeModelSelection: 0].	selection := 0. " to display the list without selection "	self displayView.	self update: getSelectionSelector.! !!PluggableListViewByItem methodsFor: 'as yet unclassified' stamp: 'di 5/6/1998 16:28'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setSelectionSelector ifNotNil: [		item := (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).		model perform: setSelectionSelector with: item].! !!PluggableListViewByItem methodsFor: 'as yet unclassified' stamp: 'di 5/6/1998 16:27'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getSelectionSelector == nil ifTrue: [^ 0].	item := model perform: getSelectionSelector.	^ itemList findFirst: [ :x | x = item]! !!PluggableListViewByItem methodsFor: 'as yet unclassified' stamp: 'sw 12/9/1999 18:07'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	itemList := arrayOfStrings.	isEmpty := arrayOfStrings isEmpty.	"add top and bottom delimiters"	list := ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].				s nextPut: bottomDelimiter])		 style: self assuredTextStyle.	selection := self getCurrentSelectionIndex.	self positionList.! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tpr 10/4/2001 21:34'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	selection := 0.	1 to: self maximumSelection do:		[:i | selection := i.		(self listSelectionAt: i) ifTrue: [self deEmphasizeSelectionBox]].	selection := 0! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tpr 10/4/2001 21:34'!highlightFrom: start to: stop	(start == nil or: [stop == nil]) ifTrue: [^ self displayView].	start to: stop do:		[:i | selection := i.		(self listSelectionAt: selection) ifTrue: [self displaySelectionBox]].	selection := 0! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tk 4/6/98 20:42'!scrollBy: anInteger	"This is a possible way to intercept what ListOfManyController did to get multiple selections to show.  Feel to replace this."	| ans |	ans := super scrollBy: anInteger."	self displaySelectionBox."	^ ans! !!PluggableListViewOfMany methodsFor: 'initialization' stamp: 'tpr 10/8/2001 20:53'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel	"setup a whole load of pluggability options"	getSelectionListSelector := getListSel.	setSelectionListSelector := setListSel.	super on: anObject list: listSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tk 4/6/98 15:43'!moveSelectionBox: anInteger 	"Presumably the selection has changed to be anInteger. Deselect the 	previous selection and display the new one, highlighted."	selection ~= anInteger		ifTrue: 			[selection := anInteger.			self displaySelectionBox]! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/27/1998 23:55'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered equal, false otherwise"	equalBlock := aBlock.! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 19:02'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and return the hash value of the given argument."	hashBlock := aBlock.! !!PluggableSet methodsFor: 'copying' stamp: 'dvf 6/10/2000 19:34'!postCopyBlocks	hashBlock := hashBlock copy.	equalBlock := equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock ifNotNil: [hashBlock fixTemps].	equalBlock ifNotNil: [equalBlock fixTemps]! !!PluggableSet methodsFor: 'private' stamp: 'dvf 6/11/2000 00:54'!scanFor: anObject 	"Scan the key array for the first slot containing either a nil(indicating 	  an empty slot) or an element that matches anObject. Answer the index 	  	of that slot or zero if no slot is found. This  method will beoverridden   	in various subclasses that have different interpretations for matching  	elements."	| element start finish |	start := (hashBlock ifNil: [anObject hash]				ifNotNil: [hashBlock value: anObject])				\\ array size + 1.	finish := array size.	"Search from (hash mod size) to the end."	start to: finish do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element = anObject]				ifNotNil: [equalBlock value: element value: anObject]])			ifTrue: [^ index]].	"Search from 1 to where we started."	1 to: start - 1 do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element = anObject]				ifNotNil: [equalBlock value: element value: anObject]])			ifTrue: [^ index]].	^ 0"No match AND no empty slot"! !!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:20'!artist: anInteger	artistIndex := anInteger.	self changed: #artist.! !!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:20'!artistName	"Answer the name of the currently selected artist, or nil if no artist is selected."	| artistsForCurrentType |	artistsForCurrentType := self artistList.	(artistIndex between: 1 and: artistsForCurrentType size)		ifTrue: [^ artistsForCurrentType at: artistIndex]		ifFalse: [^ nil].! !!PluggableTest methodsFor: 'initialization' stamp: 'jm 5/3/1998 16:20'!initialize	musicTypeList := #('reggae' 'classical' 'early').	artistList := #(		('alpha blondy' 'black uhuru' 'bob marley' 'burning spear')		('bach' 'beethoven' 'josquin' 'morley' 'mozart' 'telemann')		('josquin' 'morley' 'telemann')).	musicTypeIndex := 0.	artistIndex := 0.! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/3/1998 16:21'!musicType: anInteger	| oldArtist |	oldArtist := self artistName.	musicTypeIndex := anInteger.  "this changes artists list"	artistIndex := self artistList indexOf: oldArtist.	self changed: #musicType.	self changed: #artistList.! !!PluggableTextController methodsFor: 'as yet unclassified' stamp: 'dgd 9/21/2003 17:47'!accept 	view hasUnacceptedEdits ifFalse: [^ view flash].	view hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' translated) ifFalse: [^ self flash]].	(view setText: paragraph text from: self) ifTrue:		[initialText := paragraph text copy.		view ifNotNil: [view hasUnacceptedEdits: false]]    .! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:42'!doOccluded: actionBlock	| paneRect rectSet bottomStrip |	paneRect := paragraph clippingRectangle.	paragraph withClippingRectangle: (paneRect withHeight: 0)		do: [actionBlock value.			self scrollIn: paneRect].	view topView isCollapsed ifTrue: [^ self].	rectSet := self visibleAreas.	bottomStrip := paneRect withTop: paragraph compositionRectangle bottom + 1.	rectSet do:		[:rect |		(bottomStrip intersects: rect) ifTrue:			["The subsequent displayOn should clear this strip but it doesnt"			Display fill: (bottomStrip intersect: rect)					fillColor: paragraph backgroundColor].		paragraph withClippingRectangle: rect				do: [paragraph displayOn: Display]]! !!PluggableTextController methodsFor: 'transcript' stamp: 'th 9/20/2002 11:26'!scrollIn: scrollRect	"Altered from selectAndScroll so can use with null clipRect"	"Scroll until the selection is in the view and then highlight it."	| deltaY |	deltaY := self stopBlock top - scrollRect top.	deltaY >= 0 		ifTrue: [deltaY := self stopBlock bottom - scrollRect bottom max: 0].						"check if stopIndex below bottom of scrollRect"	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + paragraph lineGrid - 1) * deltaY sign]! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 5/7/1998 22:23'!visibleAreas	"Transcript dependents last controller visibleAreas"	| visibleAreas rect remnants myTopController |	myTopController := self view topView controller.	visibleAreas := Array with: view insetDisplayBox.	myTopController view uncacheBits.	ScheduledControllers scheduledWindowControllers do:		[:c | c == myTopController ifTrue: [^ visibleAreas].		rect := c view windowBox.		remnants := OrderedCollection new.		visibleAreas do: [:a | remnants addAll: (a areasOutside: rect)].		visibleAreas := remnants].	^ visibleAreas! !!PluggableTextView methodsFor: 'initialization' stamp: 'sw 10/29/1999 21:02'!initialize 	super initialize.	hasEditingConflicts := false! !!PluggableTextView methodsFor: 'initialization' stamp: 'tk 4/6/98 10:51'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	self model: anObject.	getTextSelector := getTextSel.	setTextSelector := setTextSel.	getSelectionSelector := getSelectionSel.	getMenuSelector := getMenuSel.	self borderWidth: 1.	self editString: self getText.	self setSelection: self getSelection.! !!PluggableTextView methodsFor: 'model access' stamp: 'di 6/26/1998 11:06'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu := CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableTextView methodsFor: 'model access' stamp: 'tk 4/1/98 08:32'!getText 	"Answer the list to be displayed."	| txt |	getTextSelector == nil ifTrue: [^ Text new].	txt := model perform: getTextSelector.	txt == nil ifTrue: [^ Text new].	self hasUnacceptedEdits: false.	"clean now"	^ txt! !!PluggableTextView methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:48'!convertToCurrentVersion: varDict refStream: smartRefStrm		hasEditingConflicts ifNil: [hasEditingConflicts := false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!PluggableTextView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:04'!hasEditingConflicts: aBoolean	hasEditingConflicts := aBoolean! !!PluggableTextView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:04'!hasUnacceptedEdits: aBoolean	super hasUnacceptedEdits: aBoolean.	aBoolean ifFalse: [hasEditingConflicts := false]! !!PluggableTileScriptorMorph methodsFor: 'as yet unclassified' stamp: 'tk 9/23/2001 02:27'!syntaxMorph	"Return the SyntaxMorph(MethodNode) that is inside me."	| tm |	^ (tm := self findA: TransformMorph) ifNotNil: [tm findA: SyntaxMorph]! !!PluggableTileScriptorMorph methodsFor: 'event handling' stamp: 'tk 9/23/2001 02:28'!keyStroke: evt	"A keystroke was hit while the receiver had keyboard focus.  Pass the keystroke on to my syntaxMorph, and also, if I have an event handler, pass it on to that handler"	| sm |	(sm := self syntaxMorph) ifNotNil: [sm keyStroke: evt].	super keyStroke: evt! !!PopUpMenu methodsFor: 'accessing' stamp: 'di 4/20/1999 14:33'!frameHeight	"Designed to avoid the entire frame computation (includes MVC form),	since the menu may well end up being displayed in Morphic anyway."	| nItems |	frame ifNotNil: [^ frame height].	nItems := 1 + (labelString occurrencesOf: Character cr).	^ (nItems * MenuStyle lineGrid) + 4 "border width"! !!PopUpMenu methodsFor: 'accessing' stamp: 'sw 3/12/2002 21:37'!startUpLeftFlush	"Build and invoke this menu with no initial selection.  By Jerry Archibald, 4/01.	If in MVC, align menus items with the left margin.	Answer the selection associated with the menu item chosen by the user or nil if none is chosen.  	The mechanism for getting left-flush appearance in mvc leaves a tiny possibility for misadventure: if the user, in mvc, puts up the jump-to-project menu, then hits cmd period while it is up, then puts up a second jump-to-project menu before dismissing or proceeding through the debugger, it's possible for mvc popup-menus thereafter to appear left-aligned rather than centered; this very unlikely condition can be cleared by evaluating 'PopUpMenu alignment: 2'"	| saveAlignment result |	Smalltalk isMorphic ifFalse:		[saveAlignment := PopUpMenu alignment.		PopUpMenu leftFlush].	[result := self startUp] ensure:		[Smalltalk isMorphic ifFalse:			[PopUpMenu alignment: saveAlignment]].	^ result! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 6/1/2000 13:04'!controlActivity	"Do whatever a menu must do - now with keyboard support."	| didNotMove downPos |	didNotMove := true.	Sensor anyButtonPressed		ifFalse:			[didNotMove := false.			Sensor waitButtonOrKeyboard]. 		Sensor keyboardPressed ifFalse: [self manageMarker].	(didNotMove and: [selection = 0])		ifTrue:			[downPos := Sensor cursorPoint.			[didNotMove and: [Sensor anyButtonPressed]]				whileTrue:					[(downPos dist: Sensor cursorPoint) < 2 ifFalse: [didNotMove := false]].			didNotMove ifTrue: [Sensor waitButtonOrKeyboard]].	[Sensor keyboardPressed] whileTrue:		[self readKeyboard ifTrue: [^ self].		Sensor waitButtonOrKeyboard].	[Sensor anyButtonPressed] whileTrue: [self manageMarker]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 6/1/2000 10:55'!readKeyboard	"Keyboard support for menus. ESC will abort the menu, Space or CR	will select an item. Cursor up and cursor down will change the	selection. Any other key will either select an item whose label starts	with that character or select the next matching label.	Answer true if the menu should be closed and false otherwise."	| ch labels occurences |	ch := Sensor keyboard asciiValue.	(ch = 13 or: [ch = 32]) ifTrue: [^ true].	ch = 27 ifTrue: [self setSelection: 0. ^ true].	ch = 30		ifTrue:			[self setSelection: (selection <= 1				ifTrue: [self nItems]				ifFalse: [selection - 1])].	ch = 31 ifTrue: [self setSelection: selection \\ self nItems + 1].	ch := ch asCharacter asLowercase.	labels := labelString findTokens: Character cr asString.	occurences := 0.	1 + selection to: selection + labels size do:		[:index |		| i | i := index - 1 \\ labels size + 1.		(labels at: i) withBlanksTrimmed first asLowercase = ch			ifTrue: [(occurences := occurences + 1) = 1 ifTrue: [self setSelection: i]]].	^ occurences = 1! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'yo 3/15/2005 12:55'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString findTokens: Character cr asString.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])			before: subset first.		subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines := (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'yo 3/15/2005 12:55'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString findTokens: Character cr asString.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])			before: subset first.		subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines := (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'tlk 5/2/2006 22:22'!startUpWithCaption: captionOrNil icon: aForm at: location allowKeyboard: aBoolean	"Display the menu, with caption if supplied. Wait for the mouse button to go down, then track the selection as long as the button is pressed. When the button is released,	Answer the index of the current selection, or zero if the mouse is not released over  any menu item. Location specifies the desired topLeft of the menu body rectangle. The final argument indicates whether the menu should seize the keyboard focus in order to allow the user to navigate it via the keyboard."	| maxHeight |	(ProvideAnswerNotification signal: captionOrNil) ifNotNilDo:		[:answer | ^ selection := answer ifTrue: [1] ifFalse: [2]].		 	maxHeight := Display height*3//4.	self frameHeight > maxHeight ifTrue:		[^ self			startUpSegmented: maxHeight			withCaption: captionOrNil			at: location			allowKeyboard: aBoolean].	Smalltalk isMorphic		ifTrue:[			selection := Cursor normal showWhile:				[| menuMorph | 				menuMorph := MVCMenuMorph from: self title: nil.				(captionOrNil notNil or:[aForm notNil])					ifTrue:[menuMorph addTitle: captionOrNil icon: aForm].				MenuIcons decorateMenu: menuMorph.				menuMorph					invokeAt: location 					in: ActiveWorld					allowKeyboard: aBoolean].			^ selection].	frame ifNil: [self computeForm].	Cursor normal showWhile:		[self			displayAt: location			withCaption: captionOrNil			during: [self controlActivity]].	^ selection! !!PopUpMenu methodsFor: 'displaying' stamp: 'sw 12/10/1999 09:55'!displayAt: aPoint withCaption: captionOrNil during: aBlock	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."	| delta savedArea captionForm captionSave outerFrame captionText tFrame frameSaveLoc captionBox |	marker ifNil: [self computeForm].	frame := frame align: marker leftCenter with: aPoint + (2@0).	outerFrame := frame.	captionOrNil notNil ifTrue:		[captionText := (DisplayText				text: captionOrNil asText				textStyle: MenuStyle copy centered)					foregroundColor: Color black					backgroundColor: Color white.		tFrame := captionText boundingBox insetBy: -2.		outerFrame := frame merge: (tFrame align: tFrame bottomCenter					with: frame topCenter + (0@2))].	delta := outerFrame amountToTranslateWithin: Display boundingBox.	frame right > Display boundingBox right		ifTrue: [delta := 0 - frame width @ delta y].	frame := frame translateBy: delta.	captionOrNil notNil ifTrue:		[captionForm := captionText form.		captionBox := captionForm boundingBox expandBy: 4.		captionBox := captionBox align: captionBox bottomCenter								with: frame topCenter + (0@2).		captionSave := Form fromDisplay: captionBox.		Display border: captionBox width: 4 fillColor: Color white.		Display border: captionBox width: 2 fillColor: Color black.		captionForm displayAt: captionBox topLeft + 4].	marker := marker align: marker leftCenter with: aPoint + delta +  (2@0).	savedArea := Form fromDisplay: frame.	self menuForm displayOn: Display at: (frameSaveLoc := frame topLeft).	selection ~= 0 ifTrue: [Display reverse: marker].	Cursor normal showWhile: [aBlock value].	savedArea displayOn: Display at: frameSaveLoc.	captionOrNil notNil ifTrue:		[captionSave displayOn: Display at: captionBox topLeft]! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'di 4/13/1999 17:42'!manageMarker	"If the cursor is inside the receiver's frame, then highlight the marked 	item. Otherwise no item is to be marked."	| pt |	"Don't let pt get far from display box, so scrolling will go all the way"	pt := Sensor cursorPoint adhereTo: (Display boundingBox expandBy: 1).	(frame inside containsPoint: pt)		ifTrue: ["Need to cache the form for reasonable scrolling performance"				((Display boundingBox insetBy: 0@3) containsPoint: pt)					ifFalse: [pt := pt - (self scrollIntoView: pt)].				self markerOn: pt]		ifFalse: [self markerOff]! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'sma 6/1/2000 13:01'!markerOn: aPoint 	"The item whose bounding area contains aPoint should be marked as 	selected. Highlight its area and set the selection to its index."	selection = 0 | (marker containsPoint: aPoint) not 		ifTrue: [selection = 0 & (marker containsPoint: aPoint)					ifTrue: [Display reverse: marker]					ifFalse: 						[selection > 0 ifTrue: [Display reverse: marker].						marker := 							marker 								align: marker topLeft 								with: marker left @ (self markerTop: aPoint).						Display reverse: marker]].	selection := marker top - frame top // marker height + 1! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'di 3/9/98 19:46'!scrollIntoView: cursorLoc	| dy |	dy := 0.	cursorLoc y < 2 ifTrue: [dy := font height].	cursorLoc y > (Display height-3) ifTrue: [dy := font height negated].	dy = 0 ifTrue: [^ 0@0].	self markerOff.	frame := frame translateBy: 0@dy.	marker := marker translateBy: 0@dy.	self menuForm displayOn: Display at: frame topLeft.	^ 0@dy! !!PopUpMenu methodsFor: 'selecting' stamp: 'sma 6/1/2000 11:01'!setSelection: index	| newSelection |	selection = index ifTrue: [^ self].	newSelection := (0 max: index) min: frame height // marker height.	selection > 0 ifTrue: [Display reverse: marker].	marker := marker translateBy: 0 @ (newSelection - selection * marker height).	selection := newSelection.	selection > 0 ifTrue: [Display reverse: marker]! !!PopUpMenu methodsFor: 'private' stamp: 'BG 8/6/2003 12:34'!computeForm	"Compute and answer a Form to be displayed for this menu."	| borderInset paraForm menuForm inside |	borderInset := 4@4.	paraForm := (DisplayText text: labelString asText textStyle: MenuStyle) form.	menuForm := Form extent: paraForm extent + (borderInset * 2) depth: paraForm depth.      menuForm fill: (0 @ 0 extent: menuForm  extent)                        rule: Form over                        fillColor: Color white.	menuForm borderWidth: 2.	paraForm displayOn: menuForm at: borderInset.	lineArray == nil ifFalse:		[lineArray do:			[ :line |			menuForm fillBlack: (4 @ ((line * font height) + borderInset y)				extent: (menuForm width - 8 @ 1))]].	frame := Quadrangle new.	frame region: menuForm boundingBox.	frame borderWidth: 4.	inside := frame inside.	marker := inside topLeft extent: (inside width @ MenuStyle lineGrid).	selection := 1.	^ form := menuForm! !!PopUpMenu methodsFor: 'private' stamp: 'di 4/13/1999 16:21'!labels: aString font: aFont lines: anArray	labelString := aString.	font := aFont.	lineArray := anArray.! !!PopUpMenu methodsFor: 'private' stamp: 'sma 2/5/2000 11:56'!rescan	"Cause my form to be recomputed after a font change."	labelString == nil ifTrue: [labelString := 'NoText!!'].	self labels: labelString font: (MenuStyle fontAt: 1) lines: lineArray.	frame := marker := form := nil.	"PopUpMenu allSubInstancesDo: [:m | m rescan]"! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'sw 12/6/1999 13:08'!initialize  "PopUpMenu initialize"	(MenuStyle := TextStyle default copy)		gridForFont: TextStyle default defaultFontIndex withLead: 0;		centered.	PopUpMenu allSubInstancesDo: [:m | m rescan]! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'nk 9/1/2004 10:27'!setMenuFontTo: aFont	"Set the menu font as indicated"	MenuStyle := TextStyle fontArray: { aFont }.	MenuStyle 		gridForFont: 1 withLead: 0;		centered.	self allSubInstancesDo: [:m | m rescan]! !!PositionableStream methodsFor: 'accessing' stamp: 'dc 8/1/2007 16:21'!back	"Go back one element and return it."	self position = 0 ifTrue: [self errorCantGoBack].	self skip: -1.	^ self peek! !!PositionableStream methodsFor: 'accessing' stamp: 'tk 3/27/98 08:44'!nextDelimited: terminator	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character.  For example: 'this '' was a quote'. Start postioned before the initial terminator."	| out ch |	out := WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	self next == terminator ifFalse: [self skip: -1].	"absorb initial terminator"	[(ch := self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents! !!PositionableStream methodsFor: 'accessing' stamp: 'sw 3/10/98 13:55'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override 	because default uses self contents species, which might involve a large 	collection."	| newArray |	newArray := collection species new: anInteger.	1 to: anInteger do: [:index | newArray at: index put: self next].	^newArray! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 14:54'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| obj |	0 to: n-1 do:[:i|		(obj := self next) == nil ifTrue:[^aCollection copyFrom: 1 to: startIndex+i-1].		aCollection at: startIndex+i put: obj].	^aCollection! !!PositionableStream methodsFor: 'accessing' stamp: 'dc 8/1/2007 16:20'!oldBack	"Go back one element and return it.  Use indirect messages in case I am a StandardFileStream"	"The method is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. This method considers that the pointer is *on* an element. Please consider unit tests which verifies #back and #oldBack behavior. (Damien Cassou - 1 August 2007)"	self position = 0 ifTrue: [self errorCantGoBack].	self position = 1 ifTrue: [self position: 0.  ^ nil].	self skip: -2.	^ self next! !!PositionableStream methodsFor: 'accessing'!peek	"Answer what would be returned if the message next were sent to the 	receiver. If the receiver is at the end, answer nil."	| nextObject |	self atEnd ifTrue: [^nil].	nextObject := self next.	position := position - 1.	^nextObject! !!PositionableStream methodsFor: 'accessing' stamp: 'dc 8/1/2007 16:02'!peekBack	"Return the element at the previous position, without changing position.  Use indirect messages in case self is a StandardFileStream."	| element |	element := self oldBack.	self skip: 1.	^ element! !!PositionableStream methodsFor: 'accessing'!peekFor: anObject 	"Answer false and do not move over the next element if it is not equal to 	the argument, anObject, or if the receiver is at the end. Answer true 	and increment the position for accessing elements, if the next element is 	equal to anObject."	| nextObject |	self atEnd ifTrue: [^false].	nextObject := self next.	"peek for matching element"	anObject = nextObject ifTrue: [^true].	"gobble it if found"	position := position - 1.	^false! !!PositionableStream methodsFor: 'accessing' stamp: 'tk 7/18/1999 17:10'!upToAll: aCollection	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."	| startPos endMatch result |	startPos := self position.	(self match: aCollection) 		ifTrue: [endMatch := self position.			self position: startPos.			result := self next: endMatch - startPos - aCollection size.			self position: endMatch.			^ result]		ifFalse: [self position: startPos.			^ self upToEnd]! !!PositionableStream methodsFor: 'accessing' stamp: 'BG 2/19/2004 14:06'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| newStream |	newStream := WriteStream on: (collection species new: 100).	[self atEnd] whileFalse: [ newStream nextPut: self next ].	^ newStream contents! !!PositionableStream methodsFor: 'accessing'!upTo: anObject 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of anObject in the receiver. If 	anObject is not in the collection, answer the entire rest of the receiver."	| newStream element |	newStream := WriteStream on: (collection species new: 100).	[self atEnd or: [(element := self next) = anObject]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 7/16/2001 14:43'!int16	"Answer the next signed, 16-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + (self next).	n >= 16r8000 ifTrue: [n := n - 16r10000].	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 7/16/2001 14:44'!int16: anInteger	"Store the given signed, 16-bit integer on this (binary) stream."	| n |	(anInteger < -16r8000) | (anInteger >= 16r8000)		ifTrue: [self error: 'outside 16-bit integer range'].	anInteger < 0		ifTrue: [n := 16r10000 + anInteger]		ifFalse: [n := anInteger].	self nextPut: (n digitAt: 2).	self nextPut: (n digitAt: 1).! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 7/16/2001 15:15'!int32	"Answer the next signed, 32-bit integer from this (binary) stream."	"Details: As a fast check for negative number, check the high bit of the first digit"	| n firstDigit |	n := firstDigit := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	firstDigit >= 128 ifTrue: [n := -16r100000000 + n].  "decode negative 32-bit integer"	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 7/16/2001 14:46'!int32: anInteger	"Store the given signed, 32-bit integer on this (binary) stream."	| n |	(anInteger < -16r80000000) | (anInteger >= 16r80000000)		ifTrue: [self error: 'outside 32-bit integer range'].	anInteger < 0		ifTrue: [n := 16r100000000 + anInteger]		ifFalse: [n := anInteger].	self nextPut: (n digitAt: 4).	self nextPut: (n digitAt: 3).	self nextPut: (n digitAt: 2).	self nextPut: (n digitAt: 1).! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 9/5/2001 07:35'!string	"Answer the next string from this (binary) stream."	| size |	size := self uint16.	^ (self next: size) asString! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 07:53'!uint16	"Answer the next unsigned, 16-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + (self next).	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 08:07'!uint24	"Answer the next unsigned, 24-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 07:53'!uint32	"Answer the next unsigned, 32-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	^ n! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'dc 8/1/2007 16:02'!backChunk	"Answer the contents of the receiver back to the previous terminator character.  Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator := $!!.	out := WriteStream on: (String new: 1000).	[(ch := self oldBack) == nil] whileFalse: 			[ch == terminator 				ifTrue: 					[self peekBack == terminator 						ifTrue: [self oldBack	"skip doubled terminator"]						ifFalse: [^ out contents reversed]].			out nextPut: ch].	^ out contents reversed! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'yo 8/7/2003 13:04'!basicNextChunk	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator := $!!.	out := WriteStream on: (String new: 1000).	self skipSeparators.	[(ch := self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 2/3/98 14:44'!copyMethodChunkFrom: aStream	"Copy the next chunk from aStream (must be different from the receiver)."	| chunk |	chunk := aStream nextChunkText.	chunk runs values size = 1 "Optimize for unembellished text"		ifTrue: [self nextChunkPut: chunk asString]		ifFalse: [self nextChunkPutWithStyle: chunk]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'yo 10/15/2003 19:02'!copyMethodChunkFrom: aStream at: pos	"Copy the next chunk from aStream (must be different from the receiver)."	| chunk |	aStream position: pos.	chunk := aStream nextChunkText.	chunk runs values size = 1 "Optimize for unembellished text"		ifTrue: [self nextChunkPut: chunk asString]		ifFalse: [self nextChunkPutWithStyle: chunk]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'ar 4/12/2005 17:34'!decodeString: string andRuns: runsRaw	| strm runLength runValues newString index |	strm := ReadStream on: runsRaw from: 1 to: runsRaw size.	(strm peekFor: $( ) ifFalse: [^ nil].	runLength := OrderedCollection new.	[strm skipSeparators.	 strm peekFor: $)] whileFalse: 		[runLength add: (Number readFrom: strm)].	runValues := OrderedCollection new.	[strm atEnd not] whileTrue: 		[runValues add: (Number readFrom: strm).		strm next.].	newString := WideString new: string size.	index := 1.	runLength with: runValues do: [:length :leadingChar |		index to: index + length - 1 do: [:pos |			newString at: pos put: (Character leadingChar: leadingChar code: (string at: pos) charCode).		].		index := index + length.	].	^ newString.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'tk 12/13/97 13:36'!decodeStyle: runsObjData version: styleVersion	"Decode the runs array from the ReferenceStream it is stored in."	"Verify that the class mentioned have the same inst vars as we have now"	| structureInfo |	styleVersion = RemoteString currentTextAttVersion ifTrue: [		"Matches our classes, no need for checking"		^ (ReferenceStream on: runsObjData) next].	structureInfo := RemoteString structureAt: styleVersion.	"or nil"		"See SmartRefStream instVarInfo: for dfn"	^ SmartRefStream read: runsObjData withClasses: structureInfo! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'NS 1/28/2004 11:21'!fileInFor: client announcing: announcement	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title.	Does NOT handle preambles or postscripts specially."	| val chunk |	announcement displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:		[:bar |		[self atEnd]			whileFalse: 				[bar value: self position.				self skipSeparators.				[ val := (self peekFor: $!!) ifTrue: [						(Compiler evaluate: self nextChunk for: client logged: false) scanFrom: self					] ifFalse: [						chunk := self nextChunk.						self checkForPreamble: chunk.						Compiler evaluate: chunk for: client logged: true ].				] on: InMidstOfFileinNotification				  do: [ :ex | ex resume: true].				self atEnd ifFalse: [ self skipStyleChunk ]].		self close].	"Note:  The main purpose of this banner is to flush the changes file."	SmalltalkImage current logChange: '----End fileIn of ' , self name , '----'.	Smalltalk forgetDoIts.	^ val! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'yo 8/13/2003 11:59'!nextChunk	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator := $!!.	out := WriteStream on: (String new: 1000).	self skipSeparators.	[(ch := self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ self parseLangTagFor: out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ self parseLangTagFor: out contents.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'sumim 11/20/2003 18:13'!nextChunkText	"Deliver the next chunk as a Text.  Decode the following ]style[ chunk if present.  Position at start of next real chunk."	| string runsRaw strm runs peek pos |	"Read the plain text"	string := self nextChunk.		"Test for ]style[ tag"	pos := self position.	peek := self skipSeparatorsAndPeekNext.	peek = $] ifFalse: [self position: pos. ^ string asText].  "no tag"	(self upTo: $[) = ']style' ifFalse: [self position: pos. ^ string asText].  "different tag"	"Read and decode the style chunk"	runsRaw := self basicNextChunk.	"style encoding"	strm := ReadStream on: runsRaw from: 1 to: runsRaw size.	runs := RunArray scanFrom: strm.	^ Text basicNew setString: string setRunsChecking: runs.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'sumim 11/20/2003 18:11'!parseLangTagFor: aString	| string peek runsRaw pos |	string := aString.	"Test for ]lang[ tag"	pos := self position.	peek := self skipSeparatorsAndPeekNext.	peek = $] ifFalse: [self position: pos. ^ string].  "no tag"	(self upTo: $[) = ']lang' ifTrue: [		runsRaw := self basicNextChunk.		string := self decodeString: aString andRuns: runsRaw	] ifFalse: [		self position: pos	].	^ string.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 1/13/98 16:08'!skipSeparatorsAndPeekNext	"A special function to make nextChunk fast"	| peek |	[self atEnd]		whileFalse:		[(peek := self next) isSeparator			ifFalse: [self position: self position-1. ^ peek]]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'tk 12/29/97 12:37'!skipStyleChunk	"Get to the start of the next chunk that is not a style for the previous chunk"	| pos |	pos := self position.	self skipSeparators.	self peek == $] 		ifTrue: [(self upTo: $[) = ']text' 	"old -- no longer needed"				"now positioned past the open bracket"			ifFalse: [self nextChunk]]	"absorb ]style[ and its whole chunk"						ifFalse: [self position: pos]	"leave untouched"! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextInt32	"Read a 32-bit signed integer from the next 4 bytes"	| s |	s := 0.	1 to: 4 do: [:i | s := (s bitShift: 8) + self next].	(s bitAnd: 16r80000000) = 0		ifTrue: [^ s]		ifFalse: [^ -1 - s bitInvert32]! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextInt32Put: int32	"Write a signed integer to the next 4 bytes"	| pos |	pos := int32 < 0		ifTrue: [(0-int32) bitInvert32 + 1]		ifFalse: [int32].	1 to: 4 do: [:i | self nextPut: (pos digitAt: 5-i)].	^ int32! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'jm 4/9/98 21:36'!nextLittleEndianNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."	| bytes s |	bytes := self next: n.	s := 0.	n to: 1 by: -1 do: [:i | s := (s bitShift: 8) bitOr: (bytes at: i)].	^ s! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'di 12/6/1999 10:13'!nextLittleEndianNumber: n put: value	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."	| bytes |	bytes := ByteArray new: n.	1 to: n do: [: i | bytes at: i put: (value digitAt: i)].	self nextPutAll: bytes! !!PositionableStream methodsFor: 'nonhomogeneous accessing'!nextNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger."	| s |	s := 0.	1 to: n do: 		[:i | s := (s bitShift: 8) bitOr: self next asInteger].	^ s normalize! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'yo 3/1/2005 06:03'!nextString	"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length.  I expect to be in ascii mode when called (caller puts back to binary)."	| length aByteArray |	"read the length in binary mode"	self binary.	length := self next.		"first byte."	length >= 192 ifTrue: [length := length - 192.		1 to: 3 do: [:ii | length := length * 256 + self next]].	aByteArray := ByteArray new: length.	self nextInto: aByteArray.	^aByteArray asString.! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'tk 6/8/1998 21:01'!nextStringOld	"Read a string from the receiver. The first byte is the length of the 	string, unless it is greater than 192, in which case the first *two* bytes 	encode the length.  Max size 16K. "	| aString length |	length := self next.		"first byte."	length >= 192 ifTrue: [length := (length - 192) * 256 + self next].	aString := String new: length.	1 to: length do: [:ii | aString at: ii put: self next asCharacter].	^aString! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'yo 4/16/2001 17:56'!nextStringPut: s 	"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256."	| length |	(length := s size) < 192		ifTrue: [self nextPut: length]		ifFalse: 			[self nextPut: (length digitAt: 4)+192.			self nextPut: (length digitAt: 3).			self nextPut: (length digitAt: 2).			self nextPut: (length digitAt: 1)].	self nextPutAll: s asByteArray.	^s! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextWord	"Answer the next two bytes from the receiver as an Integer."	| high low |	high := self next.		high==nil ifTrue: [^false].	low := self next.		low==nil ifTrue: [^false].	^(high asInteger bitShift: 8) + low asInteger! !!PositionableStream methodsFor: 'positioning' stamp: 'tk 3/22/2002 19:33'!backUpTo: subCollection	"Back up the position to he subCollection.  Position must be somewhere within the stream initially.  Leave it just after it.  Return true if succeeded.  No wildcards, and case does matter.""Example:	| strm | strm := ReadStream on: 'zabc abdc'.	strm setToEnd; backUpTo: 'abc'; position "	| pattern startMatch |	pattern := ReadStream on: subCollection reversed.	startMatch := nil.	[pattern atEnd] whileFalse: 		[self position = 0 ifTrue: [^ false].		self skip: -1.		(self next) = (pattern next) 			ifTrue: [pattern position = 1 ifTrue: [startMatch := self position]]			ifFalse: [pattern position: 0.					startMatch ifNotNil: [						self position: startMatch-1.						startMatch := nil]].		self skip: -1].	self position: startMatch.	^ true! !!PositionableStream methodsFor: 'positioning' stamp: 'hmm 10/22/1999 21:18'!match: subCollection	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."	| pattern startMatch |	pattern := ReadStream on: subCollection.	startMatch := nil.	[pattern atEnd] whileFalse: 		[self atEnd ifTrue: [^ false].		(self next) = (pattern next) 			ifTrue: [pattern position = 1 ifTrue: [startMatch := self position]]			ifFalse: [pattern position: 0.					startMatch ifNotNil: [						self position: startMatch.						startMatch := nil]]].	^ true! !!PositionableStream methodsFor: 'positioning' stamp: 'di 2/15/98 14:41'!padTo: nBytes put: aCharacter 	"Pad using the argument, aCharacter, to the next boundary of nBytes characters."	| rem |	rem := nBytes - (self position \\ nBytes).	rem = nBytes ifTrue: [^ 0].	self next: rem put: aCharacter.! !!PositionableStream methodsFor: 'positioning' stamp: 'mir 7/5/2005 08:32'!positionOfSubCollection: subCollection ifAbsent: exceptionBlock	"Return a position such that that element at the new position equals the first element of sub, and the next elements equal the rest of the elements of sub. Begin the search at the current position.	If no such match is found, answer the result of evaluating argument, exceptionBlock."	| pattern startPosition currentPosition |	pattern := ReadStream on: subCollection.	startPosition := self position.	[pattern atEnd] whileFalse: 		[self atEnd ifTrue: [^exceptionBlock value].		self next = pattern next			ifFalse: [				self position: self position-pattern position+1.				pattern reset]].	currentPosition := self position.	self position: startPosition.	^pattern atEnd		ifTrue: [currentPosition + 1 - subCollection size]		ifFalse: [exceptionBlock value]! !!PositionableStream methodsFor: 'positioning' stamp: 'nice 3/10/2008 22:29'!position: anInteger 	"Set the current position for accessing the objects to be anInteger, as long 	as anInteger is within the bounds of the receiver's contents. If it is not, 	create an error notification."	(anInteger >= 0 and: [anInteger <= readLimit])		ifTrue: [position := anInteger]		ifFalse: [self positionError]! !!PositionableStream methodsFor: 'positioning'!reset	"Set the receiver's position to the beginning of the sequence of objects."	position := 0! !!PositionableStream methodsFor: 'positioning' stamp: 'sw 3/10/98 13:55'!resetContents	"Set the position and limits to 0."	position := 0.	readLimit := 0! !!PositionableStream methodsFor: 'positioning'!setToEnd	"Set the position of the receiver to the end of the sequence of objects."	position := readLimit! !!PositionableStream methodsFor: 'testing' stamp: 'dc 2/27/2007 16:16'!isEmpty	"Answer whether the receiver's contents has no elements."	"Returns true if both the set of past and future sequence values ofthe receiver are empty. Otherwise returns false"	^ self atEnd and: [position = 0]! !!PositionableStream methodsFor: 'private'!on: aCollection	collection := aCollection.	readLimit := aCollection size.	position := 0.	self reset! !!PositionableStream methodsFor: 'private'!setFrom: newStart to: newStop	position := newStart - 1.	readLimit := newStop! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:12'!setWindowColorFor: modelSymbol to: incomingColor	| aColor aPrefSymbol aColorSpec |	aColorSpec := WindowColorRegistry registeredWindowColorSpecFor: modelSymbol.	aColorSpec ifNil: [^self].	aColor := incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor or: [aColor = Color black]) 		ifTrue: [^ self].		aPrefSymbol :=  self windowColorPreferenceForClassNamed: aColorSpec classSymbol.	self 		addPreference: aPrefSymbol  		categories:  { #'window colors' }		default:  aColor 		balloonHelp: aColorSpec helpMessage translated		projectLocal: false		changeInformee: nil		changeSelector: nil		viewRegistry: (PreferenceViewRegistry registryOf: #windowColorPreferences)! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:13'!windowColorFor: aModelClassName	| classToCheck prefSymbol |	self checkForWindowColors.	classToCheck := Smalltalk at: aModelClassName.	prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name.	[(classToCheck ~~ Object) and: [(self preferenceAt: prefSymbol) isNil]]		whileTrue: 				[classToCheck := classToCheck superclass.				prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name].	^self valueOfPreference: prefSymbol ifAbsent: [Color white].! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:14'!windowSpecificationPanel	"Put up a panel for specifying window colors"	"Preferences windowSpecificationPanel"	| aPanel buttonRow aButton aRow aSwatch aColor aWindow aMiniWorld aStringMorph |	aPanel := AlignmentMorph newColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap;		layoutInset: 0.	aPanel addMorph: (buttonRow := AlignmentMorph newRow color: (aColor := Color tan lighter)).		buttonRow addTransparentSpacerOfSize: 2@0.	buttonRow addMorphBack: (SimpleButtonMorph new label: '?'; target: self; actionSelector: #windowColorHelp; setBalloonText: 'Click for an explanation of this panel'; color: Color veryVeryLightGray; yourself).	buttonRow addTransparentSpacerOfSize: 8@0.	#(	('Bright' 	installBrightWindowColors	yellow					'Use standard bright colors for all windows.')		('Pastel'		installPastelWindowColors	paleMagenta					'Use standard pastel colors for all windows.')		('White'	installUniformWindowColors		white					'Use white backgrounds for all standard windows.')) do:		[:quad |			aButton := (SimpleButtonMorph new target: self)				label: quad first;				actionSelector: quad second;				color: (Color colorFrom: quad third);				setBalloonText: quad fourth;				yourself.			buttonRow addMorphBack: aButton.			buttonRow addTransparentSpacerOfSize: 10@0].	self windowColorTable do:		[:colorSpec | 			aRow _ AlignmentMorph newRow color: aColor.			aSwatch _ ColorSwatch new				target: self;				getSelector: #windowColorFor:;				putSelector: #setWindowColorFor:to:;				argument: colorSpec classSymbol;				extent: (40 @ 20);				setBalloonText: 'Click here to change the standard color to be used for ', colorSpec wording, ' windows.';				yourself.			aRow addMorphFront: aSwatch.			aRow addTransparentSpacerOfSize: (12 @ 1).			aRow addMorphBack: (aStringMorph := StringMorph contents: colorSpec wording font: TextStyle defaultFont).			aStringMorph setBalloonText: colorSpec helpMessage.			aPanel addMorphBack: aRow].	 Smalltalk isMorphic                ifTrue:                        [aWindow := aPanel wrappedInWindowWithTitle: 'Window Colors'.					" don't allow the window to be picked up by clicking inside "					aPanel on: #mouseDown send: #yourself to: aPanel.					self currentWorld addMorphCentered: aWindow.					aWindow activateAndForceLabelToShow ]                ifFalse:                        [(aMiniWorld := MVCWiWPasteUpMorph newWorldForProject: nil)						addMorph: aPanel.                           aMiniWorld startSteppingSubmorphsOf: aPanel.                        MorphWorldView openOn: aMiniWorld                                label: 'Window Colors'                                extent: aMiniWorld fullBounds extent]! !!Presenter methodsFor: 'access' stamp: 'sw 4/17/1998 20:07'!associatedMorph: aMorph	associatedMorph := aMorph! !!Presenter methodsFor: 'button creation' stamp: 'sw 3/7/1999 00:52'!addTrashCan	| aPosition aCan |	(aCan := associatedMorph findA: TrashCanMorph) ifNotNil: [^ aCan].	aCan := TrashCanMorph newSticky.	aPosition := associatedMorph positionNear: (associatedMorph bottomRight - aCan extent) forExtent: aCan extent adjustmentSuggestion:  (-10 @ 0).	aCan position: aPosition.	associatedMorph addMorph: aCan.	aCan startStepping.	aCan setToAdhereToEdge: #bottomRight.	^ aCan! !!Presenter methodsFor: 'intialize' stamp: 'sw 12/13/2004 16:58'!allExtantPlayers	"The initial intent here was to produce a list of Player objects associated with any Morph in the tree beneath the receiver's associatedMorph.  whether it is the submorph tree or perhaps off on unseen bookPages.  We have for the moment moved away from that initial intent, and in the current version we only deliver up players associated with the submorph tree only.  <-- this note dates from 4/21/99Call #flushPlayerListCache; to force recomputation."	| fullList objectsReferredToByTiles |	playerList ifNotNil:		[^ playerList].	fullList := associatedMorph allMorphs select: 		[:m | m player ~~ nil] thenCollect: [:m | m player].	fullList copy do:		[:aPlayer |			aPlayer class scripts do:				[:aScript |  aScript isTextuallyCoded ifFalse:					[aScript currentScriptEditor ifNotNilDo: [:ed |						objectsReferredToByTiles := ed allMorphs							select:								[:aMorph | (aMorph isKindOf: TileMorph) and: [aMorph type == #objRef]]							thenCollect:								[:aMorph | aMorph actualObject].						fullList addAll: objectsReferredToByTiles]]]].	^ playerList := (fullList asSet asSortedCollection:			[:a :b | a externalName < b externalName]) asArray! !!Presenter methodsFor: 'misc' stamp: 'sw 8/28/2002 23:07'!drawingJustCompleted: aSketchMorph	"The user just finished drawing.  Now maybe put up a viewer"	| aWorld |	self flushPlayerListCache.  "Because a new drawing already created one, thus obviating #assuredPlayer kicking in with its invalidation"	aWorld := associatedMorph world.	(aWorld hasProperty: #automaticFlapViewing)		ifTrue:			[^ aWorld presenter viewMorph: aSketchMorph].	(aSketchMorph pasteUpMorph hasProperty: #automaticViewing)		ifTrue:			[self viewMorph: aSketchMorph]! !!Presenter methodsFor: 'misc' stamp: 'sw 6/17/1998 10:16'!standardPlayfield: aPlayfield	standardPlayfield := aPlayfield! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/16/1998 16:17'!standardPalette: aPalette	standardPalette := aPalette! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 2/12/2001 22:02'!systemQueryPhraseWithActionString: anActionString labelled: aLabel	"Answer a SystemQueryPhrase with the given action string and label"	| aTile aPhrase |		aPhrase := SystemQueryPhrase new.	aTile := BooleanTile new.	aTile setExpression: anActionString label: aLabel.	aPhrase addMorph: aTile.	aPhrase enforceTileColorPolicy.	^ aPhrase! !!Presenter methodsFor: 'playerList' stamp: 'yo 7/2/2004 19:45'!allKnownScriptSelectors	"Answer a list of all the selectors implemented by any user-scripted objected within the scope of the receiver"	| aSet allUniclasses |	aSet := Set with: ('script' translated , '1') asSymbol.	allUniclasses := (self presenter allPlayersWithUniclasses collect:		[:aPlayer | aPlayer class]) asSet.	allUniclasses do:		[:aUniclass | aSet addAll: aUniclass namedTileScriptSelectors].	^ aSet asSortedArray"ActiveWorld presenter allKnownScriptSelectors"! !!Presenter methodsFor: 'playerList' stamp: 'sw 12/19/2003 23:39'!allKnownUnaryScriptSelectors	"Answer a list of all the unary selectors implemented by any user-scripted objected within the scope of the receiver; include #emptyScript as a bail-out"	| aSet allUniclasses |	aSet := Set with: #emptyScript.	allUniclasses := (self allPlayersWithUniclasses collect:		[:aPlayer | aPlayer class]) asSet.	allUniclasses do:		[:aUniclass | aSet addAll: aUniclass namedUnaryTileScriptSelectors].	^ aSet asSortedArray"ActiveWorld presenter allKnownUnaryScriptSelectors"! !!Presenter methodsFor: 'playerList' stamp: 'sw 8/2/2004 17:24'!browseAllScriptsTextually	"Open a method-list browser on all the scripts in the project"	| aList aMethodList |	(aList := self uniclassesAndCounts) size == 0 ifTrue: [^ self inform: 'there are no scripted players'].	aMethodList := OrderedCollection new.	aList do:		[:aPair | aPair first addMethodReferencesTo: aMethodList].	aMethodList size > 0 ifFalse: [^ self inform: 'there are no scripts in this project!!'].		SystemNavigation new 		browseMessageList: aMethodList 		name: 'All scripts in this project' 		autoSelect: nil"ActiveWorld presenter browseAllScriptsTextually"! !!Presenter methodsFor: 'playerList' stamp: 'sw 6/29/1998 17:17'!flushPlayerListCache	playerList := nil! !!Presenter methodsFor: 'playerList' stamp: 'sw 11/14/2001 00:31'!reinvigorateAllScriptsTool: anAllScriptsTool 	"Rebuild the contents of an All Scripts tool"	| showingOnlyActiveScripts candidateList firstTwo oldList allExtantPlayers newList morphList |	showingOnlyActiveScripts := anAllScriptsTool showingOnlyActiveScripts.	self flushPlayerListCache.	"needed? Probably to pick up on programmatical script-status control only"	firstTwo := {anAllScriptsTool submorphs first.  anAllScriptsTool submorphs second}.	oldList := (anAllScriptsTool submorphs copyFrom: 3 to: anAllScriptsTool submorphs size) collect:		[:aRow |			(aRow findA: UpdatingSimpleButtonMorph) target].	allExtantPlayers := self allExtantPlayers.	anAllScriptsTool showingAllInstances "take all instances of all classes"		ifTrue:			[candidateList := allExtantPlayers]  		ifFalse:  "include only one exemplar per uniclass.  Try to get one that has some qualifying scripts"			[candidateList := Set new.			allExtantPlayers do:				[:aPlayer |					(candidateList detect: [:plyr | plyr isMemberOf:  aPlayer class] ifNone: [nil]) ifNil:						[aPlayer instantiatedUserScriptsDo: [:aScriptInstantiation |							(showingOnlyActiveScripts not or: [aScriptInstantiation pausedOrTicking]) 								ifTrue:									[candidateList add: aPlayer]]]]].	newList := OrderedCollection new.	candidateList do:		[:aPlayer | aPlayer instantiatedUserScriptsDo:			[:aScriptInstantiation |				(showingOnlyActiveScripts not or: [aScriptInstantiation pausedOrTicking]) ifTrue:					[newList add: aScriptInstantiation]]].	oldList asSet = newList asSet		ifFalse:			[anAllScriptsTool removeAllMorphs; addAllMorphs: firstTwo.			morphList := newList collect:				[:aScriptInstantiation |  aScriptInstantiation statusControlRowIn: anAllScriptsTool].			anAllScriptsTool addAllMorphs: morphList.			newList do:				[:aScriptInstantiation | aScriptInstantiation updateAllStatusMorphs]]! !!Presenter methodsFor: 'playerList' stamp: 'sw 7/28/2004 21:00'!reinvigoratePlayersTool: aPlayersTool 	"Rebuild the contents of the Players tool"	| firstTwo oldList newList rowsForPlayers |	firstTwo := {aPlayersTool submorphs first.  aPlayersTool submorphs second}.	oldList := (aPlayersTool submorphs copyFrom: 3 to: aPlayersTool submorphs size) collect:		[:aRow |			aRow playerRepresented].	self flushPlayerListCache.	newList := self allExtantPlayers.	oldList asSet = newList asSet		ifFalse:			[aPlayersTool removeAllMorphs; addAllMorphs: firstTwo.			rowsForPlayers := newList collect:				[:aPlayer |  aPlayer entryForPlayersTool: aPlayersTool].			aPlayersTool addAllMorphs: rowsForPlayers ]! !!Presenter methodsFor: 'playerList' stamp: 'yo 2/10/2005 17:07'!reportPlayersAndScripts	"Open a window which contains a report on players and their scripts"	| aList aString |	(aList := self uniclassesAndCounts) ifEmpty:  [^ self inform: 'there are no scripted players' translated].	aString := String streamContents:		[:aStream |			aList do:				[:aPair |					aStream nextPutAll: aPair first name, ' -- ', aPair second printString.					aStream nextPutAll: ' ', (aPair second > 1 ifTrue: ['instances'] ifFalse: ['instance']) translated, ', '.					aStream nextPutAll: 'named' translated.					aPair first allInstancesDo: [:inst | aStream space; nextPutAll: inst externalName].					aStream cr].			aStream cr.			aList do:				[:aPair |					aStream cr.					aStream nextPutAll: '--------------------------------------------------------------------------------------------'.					aStream cr; nextPutAll: aPair first typicalInstanceName.					aStream nextPutAll: '''s' translated.					aStream nextPutAll: ' scripts:' translated.					aPair first addDocumentationForScriptsTo: aStream]].	(StringHolder new contents: aString)		openLabel: 'All scripts in this project' translated"self currentWorld presenter reportPlayersAndScripts"! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'tk 7/28/2005 04:54'!createStandardPlayer	| aMorph |	aMorph := ImageMorph new image: (ScriptingSystem formAtKey: 'standardPlayer').	associatedMorph addMorphFront: aMorph.	(standardPlayer := aMorph assuredPlayer) renameTo: 'dot' translated.	aMorph setBalloonText: '...'.	self positionStandardPlayer.	^ standardPlayer! !!Presenter methodsFor: 'tile support' stamp: 'sw 9/27/2001 17:43'!valueTiles	"Answer some constant-valued tiles.  This dates back to very early etoy work in 1997, and presently has no senders"	| tiles |	tiles := OrderedCollection new.	tiles add: (5 newTileMorphRepresentative typeColor: (ScriptingSystem colorForType: #Number)).	tiles add: (ColorTileMorph new typeColor: (ScriptingSystem colorForType: #Color)).	tiles add: (TileMorph new typeColor: (ScriptingSystem colorForType: #Number);			setExpression: '(180 atRandom)'			label: 'random').	tiles add: RandomNumberTile new.	^ tiles! !!Presenter methodsFor: 'viewer' stamp: 'yo 3/30/2005 11:21'!nascentPartsViewerFor: aViewee	"Create a new, naked Viewer object for viewing aViewee.  Give it a vocabulary if either the viewee insists on one or if the project insists on one."	| aViewer aVocab |	(aViewee isKindOf: KedamaExamplerPlayer) ifTrue: [^ KedamaStandardViewer new].	aViewer := StandardViewer new.	(aVocab := aViewee vocabularyDemanded)		ifNotNil:			[aViewer useVocabulary: aVocab]		ifNil:			[(aVocab := associatedMorph currentVocabularyFor: aViewee) ifNotNil:				[aViewer useVocabulary: aVocab]].		"If the viewee does not *demand* a special kind of Viewer, and if the project has not specified a preferred vocabulary, then the system defaults will kick in later"	^ aViewer! !!Presenter methodsFor: 'viewer' stamp: 'yo 4/4/2005 18:22'!updateViewer: aViewer forceToShow: aCategorySymbol	"Update the given viewer to make sure it is in step with various possible changes in the outside world, and when reshowing it be sure it shows the given category"	| aPlayer aPosition newViewer oldOwner wasSticky barHeight itsVocabulary aCategory categoryInfo restrictedIndex |	aCategory := aCategorySymbol ifNotNil: [aViewer currentVocabulary translatedWordingFor: aCategorySymbol].	categoryInfo := aViewer categoryMorphs  asOrderedCollection collect:		[:aMorph | aMorph categoryRestorationInfo].	itsVocabulary := aViewer currentVocabulary.	aCategory ifNotNil: [(categoryInfo includes: aCategorySymbol) ifFalse: [categoryInfo addFirst: aCategorySymbol]].	aPlayer := aViewer scriptedPlayer.	aPosition := aViewer position.	wasSticky := aViewer isSticky.	newViewer := aViewer species new visible: false.	(aViewer isMemberOf: KedamaStandardViewer)		ifTrue: [restrictedIndex := aViewer restrictedIndex].	barHeight := aViewer submorphs first listDirection == #topToBottom		ifTrue:			[aViewer submorphs first submorphs first height]		ifFalse:			[0].	Preferences viewersInFlaps ifTrue:		[newViewer setProperty: #noInteriorThumbnail toValue: true].	newViewer rawVocabulary: itsVocabulary.	newViewer limitClass: aViewer limitClass.	newViewer initializeFor: aPlayer barHeight: barHeight includeDismissButton: aViewer hasDismissButton showCategories: categoryInfo.	(newViewer isMemberOf: KedamaStandardViewer)		ifTrue: [			newViewer providePossibleRestrictedView: 0.			newViewer providePossibleRestrictedView: restrictedIndex].	wasSticky ifTrue: [newViewer beSticky].	oldOwner := aViewer owner.	oldOwner ifNotNil:		[oldOwner replaceSubmorph: aViewer by: newViewer].		"It has happened that old readouts are still on steplist.  We may see again!!"	newViewer position: aPosition.	newViewer enforceTileColorPolicy.	newViewer visible: true.	newViewer world ifNotNilDo: [:aWorld | aWorld startSteppingSubmorphsOf: newViewer].	newViewer layoutChanged! !!Presenter methodsFor: 'viewer' stamp: 'nk 9/21/2003 12:53'!viewMorph: aMorph 	| aPlayer openViewers aViewer aPalette aRect aPoint nominalHeight aFlapTab topItem flapLoc |	Sensor leftShiftDown 		ifFalse: 			[((aPalette := aMorph standardPalette) notNil and: [aPalette isInWorld]) 				ifTrue: [^aPalette viewMorph: aMorph]].	aPlayer := (topItem := aMorph topRendererOrSelf) assuredPlayer.	openViewers := aPlayer allOpenViewers.	aViewer := openViewers isEmpty ifFalse: [ openViewers first ] ifTrue: [ self nascentPartsViewer ].	self cacheSpecs: topItem.	"redo the spec cache once in a while"	"19 sept 2000 - allow flaps in any paste up"	flapLoc := associatedMorph.	"world"	Preferences viewersInFlaps  ifTrue:  [		aViewer owner ifNotNilDo: [ :f | ^f flapTab showFlap; yourself ].		aViewer setProperty: #noInteriorThumbnail toValue: true.			aViewer initializeFor: aPlayer barHeight: 0.			aViewer enforceTileColorPolicy.			aViewer fullBounds.	"force layout"			"associatedMorph addMorph: aViewer."	"why???"			flapLoc hideViewerFlapsOtherThanFor: aPlayer.			aFlapTab := flapLoc viewerFlapTabFor: topItem.			aFlapTab referent submorphs 				do: [:m | (m isKindOf: Viewer) ifTrue: [m delete]].			aViewer visible: true.			aFlapTab applyThickness: aViewer width + 25.			aFlapTab spanWorld.			aFlapTab showFlap.			aViewer position: aFlapTab referent position.			aFlapTab referent addMorph: aViewer beSticky.	"moved"			flapLoc startSteppingSubmorphsOf: aFlapTab.			flapLoc startSteppingSubmorphsOf: aViewer.			^aFlapTab].	aViewer initializeFor: aPlayer barHeight: 6.	aViewer enforceTileColorPolicy.	aViewer fullBounds.	"force layout"	Preferences automaticViewerPlacement 		ifTrue: 			[aPoint := aMorph bounds right 						@ (aMorph center y - ((nominalHeight := aViewer initialHeightToAllow) // 2)).			aRect := (aPoint extent: aViewer width @ nominalHeight) 						translatedToBeWithin: flapLoc bounds.			aViewer position: aRect topLeft.			aViewer visible: true.			associatedMorph addMorph: aViewer.			flapLoc startSteppingSubmorphsOf: aViewer.			"it's already in the world, somewhat coincidentally"			^aViewer].	aMorph primaryHand attachMorph: (aViewer visible: true).	^aViewer! !!Presenter methodsFor: 'viewer' stamp: 'sw 6/20/2001 13:12'!viewObjectDirectly: anObject	"Open up and return a viewer on the given object"	|  aViewer aRect aPoint nominalHeight aFlapTab flapLoc |	associatedMorph addMorph: (aViewer := self nascentPartsViewerFor: anObject).	flapLoc := associatedMorph "world".	Preferences viewersInFlaps ifTrue:		[aViewer setProperty: #noInteriorThumbnail toValue: true.		aViewer initializeFor: anObject barHeight: 0.		aViewer enforceTileColorPolicy.		flapLoc hideViewerFlapsOtherThanFor: anObject.		aFlapTab := flapLoc viewerFlapTabFor: anObject.		aFlapTab referent submorphs do: 			[:m | (m isKindOf: Viewer) ifTrue: [m delete]].		aFlapTab referent addMorph: aViewer beSticky.		aViewer visible: true.		aFlapTab applyThickness: aViewer width + 25.		aFlapTab spanWorld.		aFlapTab showFlap. 		aViewer position: aFlapTab referent position.		flapLoc startSteppingSubmorphsOf: aFlapTab.		flapLoc startSteppingSubmorphsOf: aViewer.		^ aFlapTab].		"Caution: the branch below is historical and has not been used for a long time, though if you set the #viewersInFlaps preference to false you'd hit it.  Not at all recently maintained."	aViewer initializeFor: anObject barHeight: 6.	aViewer enforceTileColorPolicy.	Preferences automaticViewerPlacement ifTrue:		[aPoint := anObject bounds right @ 			(anObject center y - ((nominalHeight := aViewer initialHeightToAllow) // 2)).		aRect := (aPoint extent: (aViewer width @ nominalHeight)) translatedToBeWithin: flapLoc bounds.		aViewer position: aRect topLeft.		aViewer visible: true.		flapLoc startSteppingSubmorphsOf: aViewer.		"it's already in the world, somewhat coincidentally"		^ aViewer].	anObject primaryHand attachMorph: (aViewer visible: true).	^aViewer! !!Process methodsFor: 'changing process state' stamp: 'ar 10/5/2007 18:01'!terminate 	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."	| ctxt unwindBlock inSema |	self isActiveProcess ifTrue: [		ctxt := thisContext.		[	ctxt := ctxt findNextUnwindContextUpTo: nil.			ctxt isNil		] whileFalse: [			unwindBlock := ctxt tempAt: 1.			unwindBlock ifNotNil: [				ctxt tempAt: 1 put: nil.				thisContext terminateTo: ctxt.				unwindBlock value].		].		thisContext terminateTo: nil.		myList := nil.		self primitiveSuspend.	] ifFalse: [		"Since the receiver is not the active process, drop its priority to rock-bottom so that		it doesn't accidentally preempt the process that is trying to terminate it."		priority := 10.		myList ifNotNil: [			myList remove: self ifAbsent: [].			"Figure out if the receiver was terminated while waiting on a Semaphore"			inSema := myList class == Semaphore.			myList := nil].		suspendedContext ifNotNil: [			"Figure out if we are terminating the process while waiting in Semaphore>>critical:			In this case, pop the suspendedContext so that we leave the ensure: block inside			Semaphore>>critical: without signaling the semaphore."			(inSema == true and:[				suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue:[					suspendedContext := suspendedContext home.			].			ctxt := self popTo: suspendedContext bottomContext.			ctxt == suspendedContext bottomContext ifFalse: [				self debug: ctxt title: 'Unwind error during termination']].	].! !!ProjectController methodsFor: 'control activity' stamp: 'rbb 2/16/2005 16:24'!redButtonActivity	| index |	view isCollapsed ifTrue: [^ super redButtonActivity].	(view insetDisplayBox containsPoint: Sensor cursorPoint)		ifFalse: [^ super redButtonActivity].	index := (UIManager default chooseFrom: #('enter' 'jump to project...') lines: #()).	index = 0 ifTrue: [^ self].	"save size on enter for thumbnail on exit"	model setViewSize: view insetDisplayBox extent.	index = 1 ifTrue: [^ model enter: false revert: false saveForRevert: false].	index = 2 ifTrue: [Project jumpToProject. ^ self].! !!ProjectView methodsFor: 'displaying' stamp: 'tk 4/19/2000 17:15'!armsLengthCommand: aCommand	"Set up a save to be done after the subproject exits to here.  displayOn: checks it."	ArmsLengthCmd := aCommand.! !!ProjectView methodsFor: 'displaying' stamp: 'tk 6/21/2000 16:22'!displayDeEmphasized	| cmd |	"Display this view with emphasis off.  Check for a command thatcould not be executed in my subproject.  Once it is done, remove thetrigger."	super displayDeEmphasized.	ArmsLengthCmd ifNil: [^ self].	ArmsLengthCmd first == model ifFalse: [^ self].	"not ours"	cmd := ArmsLengthCmd second.	ArmsLengthCmd := nil.	model "project" perform: cmd.	model "project" enter.! !!ProjectView class methodsFor: 'as yet unclassified'!open: aProject 	"Answer an instance of me for the argument, aProject. It is created on the	display screen."	| topView |	topView := self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView controller open! !!ProjectView class methodsFor: 'as yet unclassified' stamp: 'RAA 7/25/2000 10:35'!openAndEnter: aProject 	"Answer an instance of me for the argument, aProject. It is created on 	the display screen."	| topView |	topView := self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView window: (RealEstateAgent initialFrameFor: topView world: nil).	ScheduledControllers schedulePassive: topView controller.	aProject		enter: false		revert: false		saveForRevert: false! !!ProjectViewMorph methodsFor: '*eToys-user interface' stamp: 'RAA 7/10/2000 23:30'!eToyStreamedRepresentationNotifying: aWidget	| safeVariant outData |	self flag: #bob.		"probably irrelevant"	safeVariant := self copy.	[ outData := SmartRefStream streamedRepresentationOf: safeVariant ] 		on: ProgressInitiationException		do: [ :ex | 			ex sendNotificationsTo: [ :min :max :curr |				aWidget ifNotNil: [aWidget flashIndicator: #working].			].		].	^outData! !!QuotedPrintableMimeConverter methodsFor: 'conversion' stamp: 'bf 11/24/1998 20:33'!mimeDecode	"Do conversion reading from mimeStream writing to dataStream"	| line s c1 v1 c2 v2 |	[(line := mimeStream nextLine) isNil] whileFalse: [		line := line withoutTrailingBlanks.		line size = 0			ifTrue: [dataStream cr]			ifFalse: [				s := ReadStream on: line.				[dataStream nextPutAll: (s upTo: $=).				s atEnd] whileFalse: [					c1 := s next. v1 := c1 digitValue.					((v1 between: 0 and: 15) and: [s atEnd not])						ifFalse: [dataStream nextPut: $=; nextPut: c1]						ifTrue: [c2 := s next. v2 := c2 digitValue.							(v2 between: 0 and: 15)								ifFalse: [dataStream nextPut: $=; nextPut: c1; nextPut: c2]								ifTrue: [dataStream nextPut: (Character value: v1 * 16 + v2)]]].				line last = $= ifFalse: [dataStream cr]]].	^ dataStream! !!RFC2047MimeConverter methodsFor: 'conversion' stamp: 'bf 3/10/2000 16:06'!mimeEncode	"Do conversion reading from dataStream writing to mimeStream. Break long lines and escape non-7bit chars."	| word pos wasGood isGood max |	true ifTrue: [mimeStream nextPutAll: dataStream upToEnd].	pos := 0.	max := 72.	wasGood := true.	[dataStream atEnd] whileFalse: [		word := self readWord.		isGood := word allSatisfy: [:c | c asciiValue < 128].		wasGood & isGood ifTrue: [			pos + word size < max				ifTrue: [dataStream nextPutAll: word.					pos := pos + word size]				ifFalse: []		]	].	^ mimeStream! !!RFC2047MimeConverter methodsFor: 'private-encoding' stamp: 'bf 3/12/2000 14:36'!isStructuredField: aString	| fName |	fName := aString copyUpTo: $:.	('Resent' sameAs: (fName copyUpTo: $-))		ifTrue: [fName := fName copyFrom: 8 to: fName size].	^#('Sender' 'From' 'Reply-To' 'To' 'cc' 'bcc') anySatisfy: [:each | fName sameAs: each]! !!RFC2047MimeConverter methodsFor: 'private-encoding' stamp: 'bf 3/11/2000 22:30'!readWord	| strm |	strm := WriteStream on: (String new: 20)	dataStream skipSeparators.	[dataStream atEnd] whileFalse: 		[ | c |		c := dataStream next.		strm nextPut: c.		c isSeparator ifTrue: [^ strm contents]].	^ strm contents! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/25/97 13:22'!ascii	isBinary := false! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/20/97 19:46'!binary	isBinary := true! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/21/97 12:49'!contents	"Answer with a copy of my collection from 1 to readLimit."	| newArray |	isBinary ifFalse: [^ super contents].	"String"	readLimit := readLimit max: position.	newArray := ByteArray new: readLimit.	^ newArray replaceFrom: 1		to: readLimit		with: collection		startingAt: 1.! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 12/13/97 13:07'!next	| byte |	^ isBinary 			ifTrue: [byte := super next.				 byte ifNil: [nil] ifNotNil: [byte asciiValue]]			ifFalse: [super next].! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 19:26'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override to get class right."	| newArray |	newArray := (isBinary ifTrue: [ByteArray] ifFalse: [ByteString]) new: anInteger.	^ self nextInto: newArray! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'ls 3/27/2000 22:24'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than n elements have been read."	"Overriden for efficiency"	| max |	max := (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position := position + max.	max = n		ifTrue:[^aCollection]		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/21/97 13:04'!reset	"Set the receiver's position to the beginning of the sequence of objects."	super reset.	isBinary ifNil: [isBinary := false].	collection class == ByteArray ifTrue: ["Store as String and convert as needed."		collection := collection asString.		isBinary := true].! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/20/97 19:47'!text	isBinary := false! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 19:27'!upToEnd	"Must override to get class right."	| newArray |	newArray := (isBinary ifTrue: [ByteArray] ifFalse: [ByteString]) new: self size - self position.	^ self nextInto: newArray! !!RandomNumberTile methodsFor: 'accessing' stamp: 'yo 9/16/2004 18:50'!storeCodeOn: aStream indent: tabCount	| phrase player costume |	phrase := self outermostMorphThat: [:m| m isKindOf: PhraseTileMorph].	phrase ifNil: [^ self basicStoreCodeOn: aStream indent: tabCount].	player := phrase associatedPlayer.	player ifNil: [^ self basicStoreCodeOn: aStream indent: tabCount].	costume := player costume.	costume ifNil: [^ self basicStoreCodeOn: aStream indent: tabCount].	(player isKindOf: KedamaExamplerPlayer) ifTrue: [		^ self kedamaStoreCodeOn: aStream indent: tabCount actualObject: player costume renderedMorph kedamaWorld].	(costume renderedMorph isMemberOf: KedamaMorph) ifTrue: [		^ self kedamaStoreCodeOn: aStream indent: tabCount actualObject: costume renderedMorph].	^ self basicStoreCodeOn: aStream indent: tabCount.! !!RandomNumberTile methodsFor: 'event handling' stamp: 'RAA 7/31/2001 12:02'!handlesMouseDown: evt	| aPoint |	self inPartsBin ifTrue: [^false].	aPoint := evt cursorPoint.	"This might actually be a suitable test for the superclass, but I'll do it here to minimize the downside"	{upArrow. downArrow. suffixArrow. retractArrow} do: [ :each |		(each notNil and: [each bounds containsPoint: aPoint]) ifTrue: [			^true		]	].	^false		"super handlesMouseDown: evt"! !!RandomNumberTile methodsFor: 'initialization' stamp: 'dgd 9/20/2003 19:11'!initialize	"Initialize the receiver fully, including adding all its relevant submorphs"	| m1 m2 |	super initialize.	self vResizing: #shrinkWrap.	self typeColor: (ScriptingSystem colorForType: #Number).	self addArrows.	m1 := StringMorph contents: 'random' translated font: ScriptingSystem fontForTiles.	self addMorph: m1.	m2 := UpdatingStringMorph contents: '180' font: ScriptingSystem fontForTiles.	m2 target: self; getSelector: #literal; putSelector: #literal:.	m2 position: m1 topRight.	self addMorphBack: m2.	literal := 180.	self updateLiteralLabel.	self makeAllTilesGreen! !!RandomNumberTile methodsFor: 'initialization' stamp: 'yo 7/2/2004 20:59'!updateWordingToMatchVocabulary	| stringMorph |	stringMorph := submorphs				detect: [:morph | morph class == StringMorph]				ifNone: [^ self].	stringMorph contents: 'random' translated.! !!RandomNumberTile methodsFor: 'player viewer' stamp: 'tk 8/14/2000 23:23'!updateLiteralLabel	| myReadout |	(myReadout := self labelMorph) ifNil: [^ self].	myReadout contents: literal stringForReadout.! !!ReadOnlyTextController methodsFor: 'as yet unclassified' stamp: 'di 5/7/1998 13:41'!accept 	"Overridden to allow accept of clean text"	(view setText: paragraph text from: self) ifTrue:		[initialText := paragraph text copy.		view ifNotNil: [view hasUnacceptedEdits: false]].! !!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'ar 8/17/2001 18:03'!value: aValue	(AttemptToWriteReadOnlyGlobal signal: 'Cannot store into read-only bindings') == true ifTrue:[		value := aValue.	].! !!ReadOnlyVariableBinding methodsFor: 'private' stamp: 'ar 8/14/2001 23:11'!privateSetKey: aKey value: aValue	key := aKey.	value := aValue! !!ReadStream methodsFor: 'accessing'!next	"Primitive. Answer the next object in the Stream represented by the	receiver. Fail if the collection of this stream is not an Array or a String.	Fail if the stream is positioned at its end, or if the position is out of	bounds in the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 65>	position >= readLimit		ifTrue: [^nil]		ifFalse: [^collection at: (position := position + 1)]! !!ReadStream methodsFor: 'accessing' stamp: 'ls 8/16/1998 00:46'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	endPosition := position + anInteger  min:  readLimit.	ans := collection copyFrom: position+1 to: endPosition.	position := endPosition.	^ans! !!ReadStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 15:01'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| max |	max := (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position := position + max.	max = n		ifTrue:[^aCollection]		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !!ReadStream methodsFor: 'accessing' stamp: 'ar 3/18/2007 03:16'!nextFloat	"Read a floating point value from the receiver. This method is highly optimized for cases	where many floating point values need to be read subsequently. And if this needs to go	even faster, look at the inner loops fetching the characters - moving those into a plugin	would speed things up even more."	| buffer count sign index cc value digit fraction exp startIndex anyDigit digitNeeded |	buffer := collection.	count := readLimit.	index := position+1.	"Skip separators"	index := ByteString findFirstInString: buffer inSet: String noSeparatorMap startingAt: index.	index = 0 ifTrue:[self setToEnd. ^nil].	"check for sign"	digitNeeded := false.	sign := 1. cc := buffer byteAt: index.	cc = 45 "$- asciiValue"		ifTrue:[sign := -1. index := index+1. digitNeeded := true]		ifFalse:[cc =  43 "$+ asciiValue" ifTrue:[index := index+1. digitNeeded := true]].	"Read integer part"	startIndex := index.	value := 0.	[index <= count and:[		digit := (buffer byteAt: index) - 48. "$0 asciiValue"		digit >= 0 and:[digit <= 9]]] whileTrue:[			value := value * 10 + digit.			index := index + 1.	].	anyDigit := index > startIndex.	index > count ifTrue:[		(digitNeeded and:[anyDigit not]) ifTrue:[^self error: 'At least one digit expected'].		self setToEnd. ^value asFloat * sign].	(buffer byteAt: index) = 46 "$. asciiValue" ifTrue:["<integer>.<fraction>"		index := index+1.		startIndex := index.		"NOTE: fraction and exp below can overflow into LargeInteger range. If they do, then things slow down horribly due to the relatively slow LargeInt -> Float conversion. This can be avoided by changing fraction and exp to use floats to begin with (0.0 and 1.0 respectively), however, this will give different results to Float>>readFrom: and it is not clear if that is acceptable here."		fraction := 0. exp := 1.		[index <= count and:[			digit := (buffer byteAt: index) - 48. "$0 asciiValue"			digit >= 0 and:[digit <= 9]]] whileTrue:[				fraction := fraction * 10 + digit.				exp := exp * 10.				index := index + 1.		].		value := value + (fraction asFloat / exp asFloat).		anyDigit := anyDigit or:[index > startIndex].	].	value := value asFloat * sign.	"At this point we require at least one digit to avoid allowing:		- . ('0.0' without leading digits)		- e32 ('0e32' without leading digits) 		- .e32 ('0.0e32' without leading digits)	but these are currently allowed:		- .5 (0.5)		- 1. ('1.0')		- 1e32 ('1.0e32')		- 1.e32 ('1.0e32')		- .5e32 ('0.5e32')	"	anyDigit ifFalse:["Check for NaN/Infinity first"		(count - index >= 2 and:[(buffer copyFrom: index to: index+2) = 'NaN'])			ifTrue:[position := index+2. ^Float nan * sign].		(count - index >= 7 and:[(buffer copyFrom: index to: index+7) = 'Infinity'])			ifTrue:[position := index+7. ^Float infinity * sign].		^self error: 'At least one digit expected'	].	index > count ifTrue:[self setToEnd. ^value asFloat].	(buffer byteAt: index) = 101 "$e asciiValue" ifTrue:["<number>e[+|-]<exponent>"		index := index+1. "skip e"		sign := 1. cc := buffer byteAt: index.		cc = 45 "$- asciiValue"			ifTrue:[sign := -1. index := index+1]			ifFalse:[cc = 43 "$+ asciiValue" ifTrue:[index := index+1]].		startIndex := index.		exp := 0. anyDigit := false.		[index <= count and:[			digit := (buffer byteAt: index) - 48. "$0 asciiValue"			digit >= 0 and:[digit <= 9]]] whileTrue:[				exp := exp * 10 + digit.				index := index + 1.		].		index> startIndex ifFalse:[^self error: 'Exponent expected'].		value := value * (10.0 raisedToInteger: exp * sign).	].	position := index-1.	^value! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upTo: anObject	"fast version using indexOf:"	| start end |	start := position+1.	end := collection indexOf: anObject startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"		end = 0 ifTrue: [ ^self upToEnd ].	"skip to the end and return the data passed over"	position := end.	^collection copyFrom: start to: (end-1)! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upToEnd	| start |	start := position+1.	position := collection size.	^collection copyFrom: start to: position! !!ReadStream methodsFor: 'private'!on: aCollection from: firstIndex to: lastIndex	| len |	collection := aCollection.	readLimit :=  lastIndex > (len := collection size)						ifTrue: [len]						ifFalse: [lastIndex].	position := firstIndex <= 1				ifTrue: [0]				ifFalse: [firstIndex - 1]! !!ReadStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/27/2007 16:58'!testIsEmpty	| stream |	self assert: self emptyStream isEmpty.		stream := self streamOnArray.	self deny: stream isEmpty.	stream skip: 3.	self deny: stream isEmpty.		stream := self streamOnString.	self deny: stream isEmpty.	stream next;next;next.	self deny: stream isEmpty.	stream setToEnd.	self deny: stream isEmpty.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 14:14'!testUpToAll	self assert: (self streamOn: 'abcdefgh' upToAll: 'cd') = 'ab'.	self assert: (self streamOn: 'abcdefgh' upToAll: 'cd' upToAll: 'gh') = 'ef'.	self assert: (self streamOn: '' upToAll: '') = ''.	self assert: (self streamOn: 'a' upToAll: '') = ''.	self assert: (self streamOn: 'a' upToAll: 'a') = ''.	self assert: (self streamOn: 'a' upToAll: 'b') = 'a'.	self assert: (self streamOn: 'ab' upToAll: '') = ''.	self assert: (self streamOn: 'ab' upToAll: 'a') = ''.	self assert: (self streamOn: 'ab' upToAll: 'b') = 'a'.	self assert: (self streamOn: 'ab' upToAll: 'c') = 'ab'.	self assert: (self streamOn: 'ab' upToAll: 'ab') = ''.	self assert: (self streamOn: 'abc' upToAll: '') = ''.	self assert: (self streamOn: 'abc' upToAll: 'a') = ''.	self assert: (self streamOn: 'abc' upToAll: 'b') = 'a'.	self assert: (self streamOn: 'abc' upToAll: 'c') = 'ab'.	self assert: (self streamOn: 'abc' upToAll: 'd') = 'abc'.	self assert: (self streamOn: 'abc' upToAll: 'ab') = ''.	self assert: (self streamOn: 'abc' upToAll: 'bc') = 'a'.	self assert: (self streamOn: 'abc' upToAll: 'cd') = 'abc'.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/28/2007 14:14'!testPositionOfSubCollection		self assert: ((self streamOn: 'xyz') positionOfSubCollection: 'q' ) = 0.	self assert: ((self streamOn: 'xyz')  positionOfSubCollection: 'x' ) = 1.	self assert: ((self streamOn: 'xyz') positionOfSubCollection: 'y' ) = 2.	self assert: ((self streamOn: 'xyz') positionOfSubCollection: 'z' ) = 3.! !!ReadStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/27/2007 16:58'!emptyStream	^ ReadStream on: String new.! !!ReadStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/27/2007 16:58'!streamOnArray	^ ReadStream on: (Array with: 1 with: #(a b c) with: false).! !!ReadStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/27/2007 16:58'!streamOnString	^ ReadStream on: 'abcde'.! !!ReadStreamTest methodsFor: 'helpers' stamp: 'dc 3/7/2007 13:58'!streamOn: collection upToAll: subcollection	^ (self streamOn: collection) upToAll: subcollection! !!ReadStreamTest methodsFor: 'helpers' stamp: 'dc 2/28/2007 14:14'!streamOn: collection upToAll: subcollection1 upToAll: subcollection2	^(self streamOn: collection)		upToAll: subcollection1;		upToAll: subcollection2! !!ReadStreamTest methodsFor: 'accessing' stamp: 'dc 3/7/2007 13:48'!classUnderTest	^ ReadStream! !!ReadStreamTest commentStamp: 'tlk 12/5/2004 14:36' prior: 0!I am an SUnit test for ReadStream.I have no test fixtures.!!ReadWriteStream methodsFor: 'accessing'!contents	"Answer with a copy of my collection from 1 to readLimit."	readLimit := readLimit max: position.	^collection copyFrom: 1 to: readLimit! !!ReadWriteStream methodsFor: 'accessing'!next	"Primitive. Return the next object in the Stream represented by the	receiver. Fail if the collection of this stream is not an Array or a String.	Fail if the stream is positioned at its end, or if the position is out of	bounds in the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 65>	"treat me as a FIFO"	position >= readLimit		ifTrue: [^nil]		ifFalse: [^collection at: (position := position + 1)]! !!ReadWriteStream methodsFor: 'accessing' stamp: 'ar 8/5/2003 02:23'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	readLimit := readLimit max: position.	endPosition := position + anInteger  min:  readLimit.	ans := collection copyFrom: position+1 to: endPosition.	position := endPosition.	^ans! !!ReadWriteStream methodsFor: 'converting' stamp: 'yo 7/16/2003 14:59'!asUnZippedStream	| isGZip outputStream first strm archive which |	"Decompress this file if needed, and return a stream.  No file is written.  File extension may be .gz or anything else.  Also works on archives (.zip, .gZip)."	strm := self binary.	strm isZipArchive ifTrue: [		archive := ZipArchive new readFrom: strm.		which := archive members detect: [:any | any fileName asLowercase endsWith: '.ttf'] 								ifNone: [nil].		which ifNil: [archive close.					^ self error: 'Can''t find .ttf file in archive'].		strm := which contentStream.		archive close].	first := strm next.	isGZip := (strm next * 256 + first) = (GZipConstants gzipMagic).	strm skip: -2.	isGZip 		ifTrue: [outputStream := (MultiByteBinaryOrTextStream with:									(GZipReadStream on: strm) upToEnd) reset.				strm close]		ifFalse: [outputStream := strm].	^ outputStream! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 7/17/97 16:12'!fileInObjectAndCode	"This file may contain:1) a fileIn of code  2) just an object in SmartReferenceStream format 3) both code and an object.	File it in and return the object.  Note that self must be a FileStream or RWBinaryOrTextStream.  Maybe ReadWriteStream incorporate RWBinaryOrTextStream?"	| refStream object |	self text.	self peek asciiValue = 4		ifTrue: [  "pure object file"			refStream := SmartRefStream on: self.			object := refStream nextAndClose]		ifFalse: [  "objects mixed with a fileIn"			self fileIn.  "reads code and objects, then closes the file"			object := SmartRefStream scannedObject].	"set by side effect of one of the chunks"	SmartRefStream scannedObject: nil.  "clear scannedObject"	^ object! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'yo 8/16/2004 13:45'!fileOutClass: extraClass andObject: theObject	"Write a file that has both the source code for the named class and an object as bits.  Any instance-specific object will get its class written automatically."	| class srefStream |	self setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	self text.	self header; timeStamp.	extraClass ifNotNil: [		class := extraClass.	"A specific class the user wants written"		class sharedPools size > 0 ifTrue:			[class shouldFileOutPools				ifTrue: [class fileOutSharedPoolsOn: self]].		class fileOutOn: self moveSource: false toFile: 0].	self trailer.	"Does nothing for normal files.  HTML streams will have trouble with object data"	self binary.	"Append the object's raw data"	srefStream := SmartRefStream on: self.	srefStream nextPut: theObject.  "and all subobjects"	srefStream close.		"also closes me"! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'tk 3/13/98 22:25'!fileOutClass: extraClass andObject: theObject blocking: anIdentDict	"Write a file that has both the source code for the named class and an object as bits.  Any instance-specific object will get its class written automatically.  Accept a list of objects to map to nil or some other object (blockers).  In addition to teh choices in each class's objectToStoreOnDataStream"	| class srefStream |	self setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	self header; timeStamp.	extraClass ifNotNil: [		class := extraClass.	"A specific class the user wants written"		class sharedPools size > 0 ifTrue:			[class shouldFileOutPools				ifTrue: [class fileOutSharedPoolsOn: self]].		class fileOutOn: self moveSource: false toFile: 0].	self trailer.	"Does nothing for normal files.  HTML streams will have trouble with object data"	"Append the object's raw data"	srefStream := SmartRefStream on: self.	srefStream blockers: anIdentDict.	srefStream nextPut: theObject.  "and all subobjects"	srefStream close.		"also closes me"! !!ReadWriteStream methodsFor: 'testing' stamp: 'nk 8/21/2004 15:47'!isZipArchive	"Determine if this appears to be a valid Zip archive"	| sig |	self binary.	sig := self next: 4.	self position: self position - 4. "rewind"	^ZipArchive validSignatures includes: sig! !!ReadWriteStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/27/2007 16:06'!testIsEmpty	| stream |	stream := ReadWriteStream on: String new.	self assert: stream isEmpty.	stream nextPut: $a.	self deny: stream isEmpty.	stream reset.	self deny: stream isEmpty.	stream next.	self deny: stream isEmpty.! !!ReleaseTest methodsFor: 'testing' stamp: 'wiz 5/30/2008 23:29'!testClassesSystemCategory"Find cases where classes have nil system categories.This test will tell you the classes.This is inspired by the proposed fix of a bug in release of 3.10.1 see Mantis #7070" | rejectClasses | rejectClasses :=  nil systemNavigation allClasses reject: [ :each |	each category notNil ] .self assert: rejectClasses isEmpty .! !!ReleaseTest methodsFor: 'testing' stamp: 'wiz 5/30/2008 23:30'!testSystemCategoryClasses"Find cases where system categories name absent classes.This test will tell you the classes.This is inspired by a bug in release of 3.10.1 see Mantis #7070" |  rejectCats rejectClasses | rejectCats := SystemOrganization categories reject: [ :catName |	(SystemOrganization listAtCategoryNamed: catName) 		allSatisfy: [ :className | 			( Smalltalk includesKey: className ) ] ] ."self assert: rejectCats isEmpty ."rejectCats isEmpty ifTrue: [ ^ true ] . rejectClasses :=rejectCats collect: [ :each |	each ->	( (SystemOrganization listAtCategoryNamed: each) 		reject: [ :eachOne | 			( Smalltalk includesKey: eachOne )  ] ) ] .self assert: rejectCats isEmpty .! !!RemoteString methodsFor: 'accessing' stamp: 'ls 9/4/2003 12:37'!text 	"Answer the receiver's string asText if remote files are enabled."	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].	theFile := SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	theFile position > theFile size ifTrue: [		self error: 'RemoteString past end of file' ].	^ theFile nextChunkText! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:36'!testForward"If the bug exist there will be an infinte recursion.""self new testForward""self run: #testForward"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self shouldntTakeLong: [self assert: ( t forwardDirection = 0.0 ) ]  .^true  ! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:34'!testHeading"If the bug exist there will be an infinte recursion.""self new testHeading""self run: #testHeading"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self shouldntTakeLong: [ [self assert: ( t heading = 0.0 ) ] 				ensure: [ t delete ] ]  .^true  ! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:35'!testSetForward"If the bug exist there will be an infinte reccursion.""self new testSetForward""self run: #testSetForward"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self 	shouldntTakeLong: [ t forwardDirection: 180.0 . 					self assert: ( t forwardDirection = 0.0 )  ]  ."and without a rendee it should not change things."^true  ! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:35'!testSetHeading"If the bug exist there will be an infinte recursion.""self new testSetHeading""self run: #testSetHeading"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self shouldntTakeLong: [ t heading:  180 .					 self assert: ( t heading = 0.0 ) .]  .^true  ! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:33'!testTestTime"This is a control case. Should always pass. If it does not something external to the tests are slowing things down past the 1 millisecond mark.""self new testTestTime""self run: #testTestTime"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self shouldntTakeLong: [ self assert: ( true )  ]  .^true  ! !!RenderBugz methodsFor: 'utility' stamp: 'wiz 5/15/2008 22:44'!long"return time limit in milliseconds for tests"^4! !!RenderBugz methodsFor: 'utility' stamp: 'wiz 5/14/2008 23:25'!shouldntTakeLong: aBlock"Check for infinite recursion. Test should finish in a reasonable time."^self should:  aBlock  		notTakeMoreThanMilliseconds: self long .! !!RenderBugz commentStamp: 'wiz 5/15/2008 22:58' prior: 0!A RenderBugz is an infinite recursion bug test for TransformationMorphs.In 3.9 (7067) and before, when TransformationMorph has no rendee there are several methods that will infinitely recurse until manually stopped or the image runs out of memory.So far the ones I've caught are the getters and setters for heading and forwardDirection.So there  are tests for them here.Ideally there would be a way to run a test against a stopwatch to catch endless recursion.Found it. Now incorperated. And the tests should be both save to run and cleanup after themselves even when they fail. So far we have not tested the normal cases of rendering working. I will leave that as a separate task for another time. So this is an automatic test when the bugs are fixed and interactive (crash) tests when the bugs are present.Instance VariablesRevision notes. wiz 5/15/2008 22:58When running tests from the TestRunner browser the test would sporadically fail.When they failed a transfomation morph would be left on the screen and not removed by the ensureBlock. So I changed things to fall under MorphicUIBugTests because that had a cleanup mechansizm for left over morphs.I also added one routine to test for time and one parameter to determine the time limit.To my surprise doubling or tripling the time limit still produced sporadic errors when the test is run repeatedly enough ( I am using a 400mz iMac. )  So now the parameter is set to 4. Things will probably fail there if tried long enough. At that point try 5 etc. I am reluctant to make the number larger than necessary. The tighter the test the more you know what is working.I also added a dummy test to check specifically for the timing bug. It fails on the same sporadic basis as the other test went the time parameter is short enough. This lends confidence to the theory that the timing difficulty is coming from outside the test. The sunit runner puts up a progress morph for each test. So the morphic display stuff is busy and probably also the GC.!!RequiredSelectors methodsFor: 'access to cache' stamp: 'dvf 9/18/2006 22:04'!calculateForClass: aClass 	| rscc |	self clearOut: aClass.	rscc := RequiredSelectorsChangesCalculator onModificationOf: { aClass }				withTargets: { aClass }.	rscc doWork! !!RunArray methodsFor: 'accessing' stamp: 'nice 2/14/2007 21:59'!at: index put: aValue 	"Set an element of the RunArray"	| runIndex offsetInRun lastValue runLength runReplacement valueReplacement iStart iStop |	index isInteger		ifFalse: [self errorNonIntegerIndex].	(index >= 1			and: [index <= self size])		ifFalse: [self errorSubscriptBounds: index].	self		at: index		setRunOffsetAndValue: [:run :offset :value | 			runIndex := run.			offsetInRun := offset.			lastValue := value].	aValue = lastValue		ifTrue: [^ aValue].	runLength := runs at: runIndex.	runReplacement := Array				with: offsetInRun				with: 1				with: runLength - offsetInRun - 1.	valueReplacement := Array				with: lastValue				with: aValue				with: lastValue.	iStart := offsetInRun = 0				ifTrue: [2]				ifFalse: [1].	iStop := offsetInRun = (runLength - 1)				ifTrue: [2]				ifFalse: [3].	self		setRuns: (runs copyReplaceFrom: runIndex to: runIndex with: (runReplacement copyFrom: iStart to: iStop))		setValues: (values copyReplaceFrom: runIndex to: runIndex with: (valueReplacement copyFrom: iStart to: iStop)).	self coalesce.	^ aValue! !!RunArray methodsFor: 'accessing'!size	| size |	size := 0.	1 to: runs size do: [:i | size := size + (runs at: i)].	^size! !!RunArray methodsFor: 'accessing' stamp: 'di 11/10/97 13:34'!withStartStopAndValueDo: aBlock	| start stop |	start := 1.	runs with: values do:		[:len : val | stop := start + len - 1.		aBlock value: start value: stop value: val.		start := stop + 1]		! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 18:47'!addFirst: value	"Add value as the first element of the receiver."	lastIndex := nil.  "flush access cache"	(runs size=0 or: [values first ~= value])	  ifTrue:		[runs := {1}, runs.		values := {value}, values]	  ifFalse:		[runs at: 1 put: runs first+1]! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 20:25'!addLast: value	"Add value as the last element of the receiver."	lastIndex := nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs := runs copyWith: 1.		values := values copyWith: value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 18:47'!addLast: value  times: times	"Add value as the last element of the receiver, the given number of times"	times = 0 ifTrue: [ ^self ].	lastIndex := nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs := runs copyWith: times.		values := values copyWith: value]	  ifFalse:		[runs at: runs size put: runs last+times]! !!RunArray methodsFor: 'adding' stamp: 'tk 1/28/98 09:28'!coalesce	"Try to combine adjacent runs"	| ind |	ind := 2.	[ind > values size] whileFalse: [		(values at: ind-1) = (values at: ind) 			ifFalse: [ind := ind + 1]			ifTrue: ["two are the same, combine them"				values := values copyReplaceFrom: ind to: ind with: #().				runs at: ind-1 put: (runs at: ind-1) + (runs at: ind).				runs := runs copyReplaceFrom: ind to: ind with: #().				"self error: 'needed to combine runs' "]].			! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 18:48'!repeatLast: times  ifEmpty: defaultBlock	"add the last value back again, the given number of times.  If we are empty, add (defaultBlock value)"	times = 0 ifTrue: [^self ].	lastIndex := nil.  "flush access cache"	(runs size=0)	  ifTrue:		[runs := runs copyWith: times.		values := values copyWith: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+times] ! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 18:48'!repeatLastIfEmpty: defaultBlock	"add the last value back again.  If we are empty, add (defaultBlock value)"	lastIndex := nil.  "flush access cache"	(runs size=0)	  ifTrue:[		 runs := runs copyWith: 1.		values := values copyWith: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'copying' stamp: 'ar 10/16/2001 18:57'!, aRunArray 	"Answer a new RunArray that is a concatenation of the receiver and	aRunArray."	| new newRuns |	(aRunArray isMemberOf: RunArray)		ifFalse: 			[new := self copy.			"attempt to be sociable"			aRunArray do: [:each | new addLast: each].			^new].	runs size = 0 ifTrue: [^aRunArray copy].	aRunArray runs size = 0 ifTrue: [^self copy].	(values at: values size) ~= (aRunArray values at: 1)		ifTrue: [^RunArray					runs: runs , aRunArray runs					values: values , aRunArray values].	newRuns := runs					copyReplaceFrom: runs size					to: runs size					with: aRunArray runs.	newRuns at: runs size put: (runs at: runs size) + (aRunArray runs at: 1).	^RunArray		runs: newRuns		values: 			(values				copyReplaceFrom: values size				to: values size				with: aRunArray values)! !!RunArray methodsFor: 'copying' stamp: 'ls 10/10/1999 13:15'!copyFrom: start to: stop	| newRuns run1 run2 offset1 offset2 | 	stop < start ifTrue: [^RunArray new].	self at: start setRunOffsetAndValue: [:r :o :value1 | run1 := r. offset1:= o.  value1].	self at: stop setRunOffsetAndValue: [:r :o :value2 | run2 := r. offset2:= o. value2].	run1 = run2		ifTrue: 			[newRuns := Array with: offset2 - offset1 + 1]		ifFalse: 			[newRuns := runs copyFrom: run1 to: run2.			newRuns at: 1 put: (newRuns at: 1) - offset1.			newRuns at: newRuns size put: offset2 + 1].	^RunArray runs: newRuns values: (values copyFrom: run1 to: run2)! !!RunArray methodsFor: 'enumerating' stamp: 'ar 12/17/2001 00:00'!runsFrom: start to: stop do: aBlock	"Evaluate aBlock with all existing runs in the range from start to stop"	| run value index |	start > stop ifTrue:[^self].	self at: start setRunOffsetAndValue:[:firstRun :offset :firstValue|		run := firstRun.		value := firstValue.		index := start + (runs at: run) - offset.		[aBlock value: value.		index <= stop] whileTrue:[			run := run + 1.			value := values at: run.			index := index + (runs at: run)]].! !!RunArray methodsFor: 'private'!at: index setRunOffsetAndValue: aBlock 	"Supply all run information to aBlock."	"Tolerates index=0 and index=size+1 for copyReplace: "	| run limit offset |	limit := runs size.	(lastIndex == nil or: [index < lastIndex])		ifTrue:  "cache not loaded, or beyond index - start over"			[run := 1.			offset := index-1]		ifFalse:  "cache loaded and before index - start at cache"			[run := lastRun.			offset := lastOffset + (index-lastIndex)].	[run <= limit and: [offset >= (runs at: run)]]		whileTrue: 			[offset := offset - (runs at: run).			run := run + 1].	lastIndex := index.  "Load cache for next access"	lastRun := run.	lastOffset := offset.	run > limit		ifTrue: 			["adjustment for size+1"			run := run - 1.			offset := offset + (runs at: run)].	^aBlock		value: run	"an index into runs and values"		value: offset	"zero-based offset from beginning of this run"		value: (values at: run)	"value for this run"! !!RunArray methodsFor: 'private'!mapValues: mapBlock	"NOTE: only meaningful to an entire set of runs"	values := values collect: [:val | mapBlock value: val]! !!RunArray methodsFor: 'private' stamp: 'ar 10/16/2001 18:47'!setRuns: newRuns setValues: newValues	lastIndex := nil.  "flush access cache"	runs := newRuns asArray.	values := newValues asArray.! !!RunArray class methodsFor: 'instance creation' stamp: 'dc 5/24/2007 10:53'!new: aSize	^ self new: aSize withAll: nil! !!RunArray class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection := self new.	aCollection do: [:x | newCollection addLast: x].	^newCollection"	RunArray newFrom: {1. 2. 2. 3}	{1. $a. $a. 3} as: RunArray	({1. $a. $a. 3} as: RunArray) values"! !!RunArray class methodsFor: 'instance creation'!readFrom: aStream	"Answer an instance of me as described on the stream, aStream."	| size runs values |	size := aStream nextWord.	runs := Array new: size.	values := Array new: size.	1 to: size do:		[:x |		runs at: x put: aStream nextWord.		values at: x put: aStream nextWord].	^ self runs: runs values: values! !!RunArray class methodsFor: 'instance creation'!runs: newRuns values: newValues 	"Answer an instance of me with runs and values specified by the 	arguments."	| instance |	instance := self basicNew.	instance setRuns: newRuns setValues: newValues.	^instance! !!RunArray class methodsFor: 'instance creation' stamp: 'nk 9/3/2004 15:12'!scanFrom: strm	"Read the style section of a fileOut or sources file.  nextChunk has already been done.  We need to return a RunArray of TextAttributes of various kinds.  These are written by the implementors of writeScanOn:"	| rr vv aa this |	(strm peekFor: $( ) ifFalse: [^ nil].	rr := OrderedCollection new.	[strm skipSeparators.	 strm peekFor: $)] whileFalse: 		[rr add: (Number readFrom: strm)].	vv := OrderedCollection new.	"Value array"	aa := OrderedCollection new.	"Attributes list"	[(this := strm next) == nil] whileFalse: [		this == $, ifTrue: [vv add: aa asArray.  aa := OrderedCollection new].		this == $a ifTrue: [aa add: 			(TextAlignment new alignment: (Integer readFrom: strm))].		this == $f ifTrue: [aa add: 			(TextFontChange new fontNumber: (Integer readFrom: strm))].		this == $F ifTrue: [aa add: (TextFontReference toFont: 			(StrikeFont familyName: (strm upTo: $#) size: (Integer readFrom: strm)))].		this == $b ifTrue: [aa add: (TextEmphasis bold)].		this == $i ifTrue: [aa add: (TextEmphasis italic)].		this == $u ifTrue: [aa add: (TextEmphasis underlined)].		this == $= ifTrue: [aa add: (TextEmphasis struckOut)].		this == $n ifTrue: [aa add: (TextEmphasis normal)].		this == $- ifTrue: [aa add: (TextKern kern: -1)].		this == $+ ifTrue: [aa add: (TextKern kern: 1)].		this == $c ifTrue: [aa add: (TextColor scanFrom: strm)]. "color"		this == $L ifTrue: [aa add: (TextLink scanFrom: strm)].	"L not look like 1"		this == $R ifTrue: [aa add: (TextURL scanFrom: strm)].				"R capitalized so it can follow a number"		this == $q ifTrue: [aa add: (TextSqkPageLink scanFrom: strm)].		this == $p ifTrue: [aa add: (TextSqkProjectLink scanFrom: strm)].		this == $P ifTrue: [aa add: (TextPrintIt scanFrom: strm)].		this == $d ifTrue: [aa add: (TextDoIt scanFrom: strm)].		"space, cr do nothing"		].	aa size > 0 ifTrue: [vv add: aa asArray].	^ self runs: rr asArray values: vv asArray"RunArray scanFrom: (ReadStream on: '(14 50 312)f1,f1b,f1LInteger +;i')"! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 2/12/2007 09:22'!testNew	"self debug: #testNew"	| array |	array := RunArray new.	self assert: array size = 0.! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 2/12/2007 09:24'!testNewFrom	"self debug: #testNewFrom"	| array |	array := RunArray newFrom: #($a $b $b $b $b $c $c $a).	self assert: array size = 8.	self assert: array = #($a $b $b $b $b $c $c $a).! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 2/12/2007 09:15'!testNewWithAll	"self debug: #testNewWithAll"	| array |	array := RunArray new: 5 withAll: 2.	self assert: array size = 5.	self assert: array = #(2 2 2 2 2)! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 5/24/2007 10:56'!testNewWithSize	|array|	array := RunArray new: 5.	self assert: array size = 5.	1 to: 5 do: [:index | self assert: (array at: index) isNil]! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 2/12/2007 09:30'!testRunsValues	"self debug: #testRunsValues"	| array |	array := RunArray runs: #(1 4 2 1) values: #($a $b $c $a).	self assert: array size = 8.	self assert: array = #($a $b $b $b $b $c $c $a).! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/15/2007 10:25'!testAt	"self debug: #testAt"	| array |	array := RunArray new: 5 withAll: 2.	self assert: (array at: 3) = 2.		array at: 3 put: 5.	self assert: (array at: 3) = 5! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/15/2007 10:26'!testAtPut	"self debug: #testAtPut"	| array |	array := RunArray new: 5 withAll: 2.		array at: 3 put: 5.	self assert: array = #(2 2 5 2 2).		array at: 1 put: 1.	self assert: array = #(1 2 5 2 2).! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/15/2007 10:29'!testAtPut2	"self debug: #testAtPut2"	| array |	array := RunArray new: 5 withAll: 2.		self should: [array at: 0 put: 5] raise: Error.	self should: [array at: 6 put: 5] raise: Error.	self should: [array at: $b put: 5] raise: Error.! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/12/2007 09:49'!testFirst	"self debug: #testFirst"	| array |	array := RunArray new: 5 withAll: 2.	self assert: array first = 2.		array := #($a $b $c $d) as: RunArray.	self assert: array first = $a.! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/12/2007 09:49'!testLast	"self debug: #testLast"	| array |	array := RunArray new: 5 withAll: 2.	self assert: array last = 2.		array := #($a $b $c $d) as: RunArray.	self assert: array last = $d.! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/12/2007 09:58'!testRunLengthAt	"self debug: #testRunLengthAt"	| array |	array := #($a $b $b $c $c $c $d $d) as: RunArray.	self assert: (array runLengthAt: 1) = 1.	self assert: (array runLengthAt: 2) = 2.	self assert: (array runLengthAt: 3) = 1.	self assert: (array runLengthAt: 4) = 3.	self assert: (array runLengthAt: 5) = 2.	self assert: (array runLengthAt: 6) = 1.	self assert: (array runLengthAt: 7) = 2.	self assert: (array runLengthAt: 8) = 1.! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/12/2007 10:12'!testWithStartStopAndValueDo	"self debug: #testWithStartStopAndValueDo"	| array elements startStops |	array := #($a $b $b $c $c $c $d $d) as: RunArray.	elements := OrderedCollection new.	startStops := OrderedCollection new.	array withStartStopAndValueDo: [:start :stop :value | elements add: value. startStops add: start->stop].		self assert: elements asArray = #($a $b  $c  $d).	self assert: startStops asArray = {1->1 . 2->3 . 4->6 . 7->8}! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'pk 10/17/2006 09:42'!basicNewChangeSet: newName	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs basicNewChangeSet: newName ].	(self changeSetNamed: newName) ifNotNil: [ self inform: 'Sorry that name is already used'. ^nil ].	^ChangeSet basicNewNamed: newName.! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'pk 10/17/2006 09:42'!changeSetNamed: newName	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs changeSetNamed: newName ].	^ChangeSet allInstances detect: [ :cs | cs name = newName ] ifNone: [ nil ].! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/16/2002 00:33'!handleCData: aString	self saxHandler		checkEOD; 		characters: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'cwp 6/17/2003 18:26'!handleComment: aString	self saxHandler		checkEOD; 		comment: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/8/2002 18:38'!handleEndDocument	self saxHandler endDocument! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 6/24/2003 13:36'!handleEndTag: elementName	| namespace localName namespaceURI qualifiedName |	self usesNamespaces		ifTrue: [			self splitName: elementName into: [:ns :ln |				namespace _ ns.				localName _ ln].			"ensure our namespace is defined"			namespace				ifNil: [					namespace := self scope defaultNamespace.					qualifiedName := namespace , ':' , elementName]				ifNotNil: [					namespaceURI := self scope namespaceURIOf: namespace.					namespaceURI						ifNil: [self parseError: 'Start tag ' , elementName , ' refers to undefined namespace ' , namespace asString].					qualifiedName := elementName].			"call the handler"			self saxHandler				checkEOD; 				endElement: localName namespace: namespace namespaceURI: namespaceURI qualifiedName: qualifiedName.			self scope leaveScope]		ifFalse: [			"call the handler"			self saxHandler				checkEOD; 				endElement: elementName namespace: nil namespaceURI: nil qualifiedName: elementName]! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/8/2002 18:24'!handlePCData: aString	self saxHandler		checkEOD; 		characters: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/8/2002 18:24'!handlePI: piTarget data: piData	self saxHandler		checkEOD; 		processingInstruction: piTarget data: piData! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 18:29'!handleStartDocument	self saxHandler startDocument! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 6/24/2003 13:35'!handleStartTag: elementName attributes: attributeList namespaces: namespaces	| localName namespace namespaceURI |	self usesNamespaces		ifTrue: [			self scope enterScope.				"declare any namespaces"					namespaces keysAndValuesDo: [:ns :uri |					self scope declareNamespace: ns uri: uri].			self splitName: elementName into: [:ns :ln |				namespace _ ns.				localName _ ln].			"ensure our namespace is defined"			namespace				ifNil: [namespace := self scope defaultNamespace]				ifNotNil: [					namespaceURI := self scope namespaceURIOf: namespace.					namespaceURI						ifNil: [self parseError: 'Start tag ' , elementName , ' refers to undefined namespace ' , namespace asString]].			self validatesAttributes				ifTrue: [self scope validateAttributes: attributeList].			"call the handler"			self saxHandler				checkEOD; 				startElement: localName namespaceURI: namespaceURI namespace: namespace attributeList: attributeList]		ifFalse: [			"call the handler"			self saxHandler				checkEOD; 				startElement: elementName namespaceURI: nil namespace: nil attributeList: attributeList]! !!SAXDriver methodsFor: 'handling tokens' stamp: 'cwp 6/18/2003 01:00'!handleWhitespace: aString	self saxHandler		checkEOD; 		ignorableWhitespace: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 6/24/2003 13:39'!handleXMLDecl: attributes namespaces: namespaces	self saxHandler		checkEOD; 		documentAttributes: attributes.	self usesNamespaces		ifTrue: [			namespaces keysAndValuesDo: [:ns :uri |				self scope declareNamespace: ns uri: uri]]! !!SAXDriver methodsFor: 'initialization' stamp: 'mir 6/5/2003 16:29'!initialize	super initialize.	useNamespaces := false.	validateAttributes := false! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 8/11/2000 17:51'!saxHandler	^saxHandler! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 8/11/2000 17:52'!saxHandler: aHandler	saxHandler _ aHandler! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 6/24/2003 14:51'!useNamespaces: aBoolean	useNamespaces := aBoolean! !!SAXDriver methodsFor: 'namespaces' stamp: 'mir 6/24/2003 13:40'!scope	scope ifNil: [scope := XMLNamespaceScope new].	^scope! !!SAXDriver methodsFor: 'namespaces' stamp: 'mir 6/16/2003 13:09'!splitName: aName into: twoArgsBlock	"Split the name into namespace and local name (the block arguments).	Handle both qualified and unqualified names using the default name space"	| i ns ln |	i _ aName lastIndexOf: $:.	i = 0		ifTrue: [			ns := nil.			ln := aName]		ifFalse: [			ns := aName copyFrom: 1 to: (i - 1).			ln := aName copyFrom: i+1 to: aName size].	twoArgsBlock value: ns value: ln! !!SAXDriver methodsFor: 'testing' stamp: 'mir 6/5/2003 16:30'!usesNamespaces	^useNamespaces! !!SAXDriver methodsFor: 'testing' stamp: 'mir 6/5/2003 17:06'!validatesAttributes	^validateAttributes! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:27'!characters: aString	"This call corresponds to the Java SAX call	characters(char[] ch, int start, int length)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:24'!checkEOD	"Check if the document shouldn't be ended already"	self eod		ifTrue: [self driver errorExpected: 'No more data expected,']! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/17/2002 13:12'!documentAttributes: attributeList! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:26'!endDocument	"This call corresponds to the Java SAX call	endDocument()."	eod _ true! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/14/2000 18:07'!endElement: elementName! !!SAXHandler methodsFor: 'content' stamp: 'mir 6/5/2003 19:05'!endElement: elementName namespace: namespace namespaceURI: namespaceURI qualifiedName: qualifiedName	"This call corresponds to the Java SAX call	endElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName).	By default this call is mapped to the following more convenient call:"	self endElement: elementName! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:25'!endPrefixMapping: prefix	"This call corresonds to the Java SAX call	endPrefixMapping(java.lang.String prefix)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:25'!ignorableWhitespace: aString	"This call corresonds to the Java SAX call	ignorableWhitespace(char[] ch, int start, int length)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:26'!processingInstruction: piName data: dataString	"This call corresonds to the Java SAX call	processingInstruction(java.lang.String target, java.lang.String data)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:45'!skippedEntity: aString	"This call corresonds to the Java SAX call	skippedEntity(java.lang.String name)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:45'!startDocument	"This call corresonds to the Java SAX call	startDocument()."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/14/2000 18:07'!startElement: elementName attributeList: attributeList! !!SAXHandler methodsFor: 'content' stamp: 'mir 6/5/2003 16:50'!startElement: localName namespaceURI: namespaceUri namespace: namespace attributeList: attributeList	"This call corresonds to the Java SAX call	startElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName, Attributes atts).	By default this call is mapped to the following more convenient call:"	self startElement: localName attributeList: attributeList! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:47'!startPrefixMapping: prefix uri: uri	"This call corresonds to the Java SAX call	startPrefixMapping(java.lang.String prefix, java.lang.String uri)."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:52'!comment: commentString	"This call corresponds to the Java SAX ext call	comment(char[] ch, int start, int length)."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:53'!endEntity: entityName	"This call corresponds to the Java SAX ext call	endEntity(java.lang.String name)."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:53'!startCData	"This call corresponds to the Java SAX ext call	startCData()."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:54'!startDTD: declName publicID: publicID systemID: systemID	"This call corresponds to the Java SAX ext call	startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:54'!startEntity: entityName	"This call corresponds to the Java SAX ext call	startEntity(java.lang.String name)."! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 11/30/2000 18:12'!document	^document! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 11/30/2000 18:12'!document: aDocument	document _ aDocument! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:34'!driver	^driver! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:34'!driver: aDriver	driver _ aDriver.	driver saxHandler: self! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 1/8/2002 18:18'!eod	^eod! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 6/5/2003 19:28'!useNamespaces: aBoolean	self driver useNamespaces: aBoolean! !!SAXHandler methodsFor: 'initialize' stamp: 'mir 1/8/2002 18:18'!initialize	eod _ false! !!SAXHandler methodsFor: 'parsing' stamp: 'mir 1/8/2002 18:18'!parseDocument	[self driver nextEntity isNil or: [self eod]] whileFalse! !!SAXHandler methodsFor: 'entity' stamp: 'mir 8/11/2000 17:33'!resolveEntity: publicID systemID: systemID	"This call corresonds to the Java SAX call	resolveEntity(java.lang.String publicId, java.lang.String systemId)."! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 8/14/2000 18:29'!new	^super new initialize! !!SAXHandler class methodsFor: 'instance creation' stamp: 'sd 5/23/2003 15:19'!on: aStream	| driver parser |	driver _ SAXDriver on: aStream.	driver validating: true.	parser _ self new driver: driver.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'cwp 5/28/2003 02:08'!parseDTDFrom: aStream	| driver parser |	driver _ SAXDriver on: aStream.	driver validating: true.	driver startParsingMarkup.	parser _ self new driver: driver.	parser startDocument.	parser parseDocument.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 19:13'!parseDocumentFrom: aStream	|  parser |	parser _ self on: aStream.	parser startDocument.	parser parseDocument.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 1/8/2002 15:55'!parseDocumentFromFileNamed: fileName	^self parseDocumentFromFileNamed: fileName readIntoMemory: false! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 1/8/2002 15:55'!parseDocumentFromFileNamed: fileName readIntoMemory: readIntoMemory	| stream xmlDoc |	stream _ FileDirectory default readOnlyFileNamed: fileName.	readIntoMemory		ifTrue: [stream _ stream contentsOfEntireFile readStream].	[xmlDoc _ self parseDocumentFrom: stream]		ensure: [stream close].	^xmlDoc! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 19:15'!parserOnFileNamed: fileName	^self parserOnFileNamed: fileName readIntoMemory: false! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 19:14'!parserOnFileNamed: fileName readIntoMemory: readIntoMemory	| stream  |	stream _ FileDirectory default readOnlyFileNamed: fileName.	readIntoMemory		ifTrue: [stream _ stream contentsOfEntireFile readStream].	^self on: stream! !!SMInstaller class methodsFor: 'changeset utilities' stamp: 'pk 10/17/2006 09:43'!basicNewChangeSet: newName 	"This method copied here to ensure SqueakMap is independent of 	ChangesOrganizer. "	Smalltalk		at: #ChangesOrganizer		ifPresentAndInMemory: [:cs | ^ cs basicNewChangeSet: newName].	(self changeSetNamed: newName)		ifNotNil: [self error: 'The name ' , newName , ' is already used'].	^ ChangeSet basicNewNamed: newName! !!SMInstaller class methodsFor: 'changeset utilities' stamp: 'pk 10/17/2006 09:43'!changeSetNamed: newName	"This method copied here to ensure SqueakMap is independent of ChangesOrganizer."	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs changeSetNamed: newName ].	^ChangeSet allInstances detect: [ :cs | cs name = newName ] ifNone: [ nil ].! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:14'!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := model isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(model directory directoryEntryFor: model lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:12'!loadUpdates	[Cursor wait showWhile: [		model loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/26/2006 00:40'!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 9/25/2006 23:13'!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (model object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'gui building' stamp: 'gk 9/25/2006 23:13'!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'initialization' stamp: 'gk 9/25/2006 23:12'!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:12'!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((model categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13'!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13'!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', model packages size printString, ')'! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:25'!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:41'!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 01:02'!noteChanged	filters ifNil: [^self reOpen].	model ifNotNil: [		packagesList := nil.		selectedCategoryWrapper := nil.		self changed: #categoryWrapperList.		self changed: #packageWrapperList.		self changed: #packagesListIndex.	"update my selection"		self contentsChanged]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/25/2006 23:12'!packages	"We request the packages as sorted by name by default."	^model packagesByName asArray! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:40'!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader commentStamp: '<historical>' prior: 0!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!ScreenController methodsFor: 'file in/out' stamp: 'tk 9/28/2000 15:47'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."	dp := DiskProxy global: #ScheduledControllers selector: #screenController args: #().	refStrm replace: self with: dp.	^ dp! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:13'!closeUnchangedWindows	"Close any window that doesn't have unaccepted input."	| clean |	(SelectionMenu confirm:'Do you really want to close all windowsexcept those with unaccepted edits?')		ifFalse: [^ self].	clean := ScheduledControllers scheduledControllers select:		[:c | c model canDiscardEdits and: [(c isKindOf: ScreenController) not]].	clean do: [:c | c closeAndUnscheduleNoTerminate].	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:01'!durableHelpMenu 	| aMenu selectionList labelList targetList i wordingList colorPattern |	aMenu := self helpMenu.	selectionList := aMenu selections.	labelList := (1 to: selectionList size) collect:		[:ind | aMenu labelString lineNumber: ind].	targetList :=  (1 to: selectionList size) collect: [:ind | self].	(i := labelList indexOf: 'keep this menu up') > 0 ifTrue:		[selectionList := selectionList copyReplaceFrom: i to: i with: Array new.		labelList := labelList copyReplaceFrom: i to: i with: Array new.		targetList := targetList copyReplaceFrom: i to: i with: Array new].	colorPattern := #(lightRed lightGreen lightBlue lightYellow lightGray lightCyan lightMagenta lightOrange).	wordingList := selectionList collect:		[:aSelection |			(aSelection == #soundOnOrOff) ifTrue: [#soundEnablingString] ifFalse: [nil]].	^ Utilities windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList wordingSelectors: wordingList title: 'Help'! !!ScreenController methodsFor: 'menu messages' stamp: 'di 11/25/1998 12:21'!durableOpenMenu 	| colorPattern |	colorPattern := #(blue lightGreen lightYellow lightMagenta  lightOrange lightCyan) asOrderedCollection.	colorPattern add: Project someInstance backgroundColorForMvcProject.	colorPattern add: Project someInstance backgroundColorForMorphicProject.	colorPattern add: #orange.	Utilities windowFromMenu: self openMenu target: self title: 'Openers'		colorPattern: colorPattern! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:28'!durableWindowMenu 	| aMenu selectionList labelList targetList i wordingList colorPattern |	aMenu := self windowMenu.	selectionList := aMenu selections.	labelList := (1 to: selectionList size) collect:		[:ind | aMenu labelString lineNumber: ind].	targetList :=  (1 to: selectionList size) collect: [:ind | self].	(i := labelList indexOf: 'keep this menu up') > 0 ifTrue:		[selectionList := selectionList copyReplaceFrom: i to: i with: Array new.		labelList := labelList copyReplaceFrom: i to: i with: Array new.		targetList := targetList copyReplaceFrom: i to: i with: Array new].	colorPattern := #(lightRed lightGreen lightBlue lightYellow lightGray lightCyan lightMagenta lightOrange).	wordingList := selectionList collect:		[:aSelection |			(#(fastWindows changeWindowPolicy) includes: aSelection)				ifFalse:					[nil]				ifTrue:					[aSelection == #fastWindows						ifFalse:							[#staggerPolicyString]						ifTrue:							[#bitCachingString]]].	^ Utilities windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList wordingSelectors: wordingList title: 'windows'! !!ScreenController methodsFor: 'menu messages'!emergencyCollapse	"Emergency collapse of a selected window"	| controller |	(controller := ScheduledControllers windowFromUser) notNil		ifTrue:			[controller collapse.			controller view deEmphasize]! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 6/7/2003 19:49'!fullScreenOff	Display fullScreenMode: (LastScreenModeSelected := false).	DisplayScreen checkForNewScreenSize.	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 6/7/2003 19:49'!fullScreenOn	Display fullScreenMode: (LastScreenModeSelected := true).	DisplayScreen checkForNewScreenSize.	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 4/24/2001 12:00'!openProject 	"Create and schedule a Project."	| proj |	Smalltalk at: #ProjectView ifPresent:		[:c | proj := Project new.		c open: proj].! !!ScreenController methodsFor: 'menu messages' stamp: 'bf 9/18/1999 20:01'!setDisplayDepth	"Let the user choose a new depth for the display. "	| result |	(result := (SelectionMenu selections: Display supportedDisplayDepths) startUpWithCaption: 'Choose a display depth(it is currently ' , Display depth printString , ')') == nil ifFalse:		[Display newDepth: result]! !!ScriptActivationButton methodsFor: 'access' stamp: 'sw 3/10/2003 23:57'!uniclassScript	"Answer the receiver's uniclassScript.  For old buttons, this might initially be nil but will get set, when possible herein."	^ uniclassScript ifNil:		[uniclassScript := target class scripts at: arguments first ifAbsent: [nil]]! !!ScriptActivationButton methodsFor: 'initialization' stamp: 'sw 3/11/2003 00:31'!initializeForPlayer: aPlayer uniclassScript: aUniclassScript	"Initialize the receiver for the given player and uniclass script"	target := aPlayer.	uniclassScript := aUniclassScript.	actionSelector := #runScript:.	arguments := Array with: uniclassScript selector.	self establishLabelWording	! !!ScriptActivationButton methodsFor: 'label' stamp: 'yo 11/30/2005 14:14'!establishLabelWording	"Set the label wording, unless it has already been manually edited"	| itsName |	itsName := target externalName.	(self hasProperty: #labelManuallyEdited)		ifFalse:			[self label: (itsName, ' ', arguments first)].	self setBalloonText: 		('click to run the script "{1}" in player named "{2}"' translated format: {arguments first. itsName}).! !!ScriptActivationButton methodsFor: 'miscellaneous' stamp: 'sw 3/11/2003 00:35'!bringUpToDate	"The object's name, or the script name, or both, may have changed.  Make sure I continue to look and act right"	uniclassScript ifNotNil:		[arguments := Array with: uniclassScript selector].	self establishLabelWording! !!ScriptActivationButton methodsFor: 'miscellaneous' stamp: 'sw 2/28/2001 21:42'!setLabel	"Allow the user to enter a new label for this button"	| newLabel existing |	existing := self label.	newLabel := FillInTheBlank		request: 'Please enter a new label for this button'		initialAnswer: existing.	(newLabel isEmptyOrNil not and: [newLabel ~= existing]) ifTrue:		[self setProperty: #labelManuallyEdited toValue: true.		self label: newLabel].! !!ScriptInstantiation methodsFor: 'anonymity' stamp: 'sw 10/30/2000 11:08'!initializePermanentScriptFor: aPlayer selector: aSelector	"Initialize the receiver on behalf of the player, setting its status to #normal and giving it the given selector"	player := aPlayer.	status := #normal.	selector := aSelector! !!ScriptInstantiation methodsFor: 'customevents-status control' stamp: 'nk 7/21/2003 20:07'!defineNewEvent	| newEventName newEventHelp |	"Prompt the user for the name of a new event and install it into the custom event table"	newEventName := FillInTheBlankMorph request: 'What is the name of your new event?'.	newEventName isEmpty ifTrue: [ ^self ].	newEventName := newEventName asSymbol.	(ScriptingSystem customEventStati includes: newEventName) ifTrue: [		self inform: 'That event is already defined.'. ^self ].	newEventHelp := FillInTheBlankMorph request: 'Please describe this event:'.	ScriptingSystem addUserCustomEventNamed: newEventName help: newEventHelp.! !!ScriptInstantiation methodsFor: 'customevents-status control' stamp: 'nk 7/21/2003 20:32'!deleteCustomEvent	| userEvents eventName |	userEvents :=  ScriptingSystem userCustomEventNames.	eventName := (SelectionMenu selections: userEvents) startUpWithCaption: 'Remove which event?' at: ActiveHand position allowKeyboard: true.	eventName ifNotNil: [ ScriptingSystem removeUserCustomEventNamed: eventName ].	self class allSubInstancesDo: [ :ea | ea status = eventName ifTrue: [ ea status: #normal ]]! !!ScriptInstantiation methodsFor: 'customevents-status control' stamp: 'nk 11/1/2004 07:53'!presentScriptStatusPopUp	"Put up a menu of status alternatives and carry out the request"	| reply  m menu submenu |	menu := MenuMorph new.	self addStatusChoices: #( normal " -- run when called" ) toMenu: menu.	self addStatusChoices: 		#(	paused 		"ready to run all the time"			ticking			"run all the time" )		toMenu: menu.	self addStatusChoices: (ScriptingSystem standardEventStati copyFrom: 1 to: 3) toMenu: menu.	self addStatusChoices: (ScriptingSystem standardEventStati allButFirst: 3) toMenu: menu.	self addStatusChoices: 		#(opening			"when I am being opened"			closing			"when I am being closed" )		toMenu: menu.		submenu := MenuMorph new.	self addStatusChoices: (ScriptingSystem globalCustomEventNamesFor: player) toSubMenu: submenu forMenu: menu.	menu add: 'more... ' translated subMenu: submenu.	(Preferences allowEtoyUserCustomEvents) ifTrue: [		submenu addLine.		self addStatusChoices: ScriptingSystem userCustomEventNames toSubMenu: submenu forMenu: menu.		submenu addLine.		self addStatusChoices:			(Array streamContents: [ :s | s nextPut: { 'define a new custom event'. #defineNewEvent }.			ScriptingSystem userCustomEventNames isEmpty				ifFalse: [ s nextPut: { 'delete a custom event'. #deleteCustomEvent } ]])			toSubMenu: submenu forMenu: menu ].		menu addLine.	self addStatusChoices: #(		('what do these mean?'explainStatusAlternatives)		('apply my status to all siblings' assignStatusToAllSiblings) ) toMenu: menu.	menu addTitle: 'When should this script run?' translated.	menu submorphs last delete.	menu invokeModal.		reply := menu modalSelection.	reply == #explainStatusAlternatives ifTrue: [^ self explainStatusAlternatives].	reply == #assignStatusToAllSiblings ifTrue: [^ self assignStatusToAllSiblings].	reply == #defineNewEvent ifTrue: [ ^self defineNewEvent ].	reply == #deleteCustomEvent ifTrue: [ ^self deleteCustomEvent ].	reply ifNotNil: 		[self status: reply.  "Gets event handlers fixed up"		reply == #paused ifTrue:			[m := player costume.			(m isKindOf: SpeakerMorph) ifTrue: [m stopSound]].		self updateAllStatusMorphs]! !!ScriptInstantiation methodsFor: 'frequency' stamp: 'sw 4/21/1999 09:13'!frequency: aNumber	frequency := aNumber! !!ScriptInstantiation methodsFor: 'frequency' stamp: 'ar 2/12/2001 18:26'!tickingRate: aNumber	"See the comment in #tickingRate"	tickingRate := aNumber.	self updateAllStatusMorphs.! !!ScriptInstantiation methodsFor: 'misc' stamp: 'sw 10/24/2004 17:05'!assignStatusToAllSiblings	"Let all sibling instances of my player have the same status that I do.  The stati affected are both the event stati and the tickingStati"	| aScriptInstantiation |	(player class allInstances copyWithout: player) do:		[:aPlayer |			aScriptInstantiation := aPlayer scriptInstantiationForSelector: selector.			aScriptInstantiation status: status.			aScriptInstantiation frequency: self frequency.			aScriptInstantiation tickingRate: self tickingRate.			aScriptInstantiation updateAllStatusMorphs]! !!ScriptInstantiation methodsFor: 'misc' stamp: 'dgd 12/15/2003 10:11'!offerMenuIn: aStatusViewer	"Put up a menu."	| aMenu |	ActiveHand showTemporaryCursor: nil.	aMenu := MenuMorph new defaultTarget: self.	aMenu title: player knownName, ' ', selector.	aMenu addStayUpItem.	(player class instanceCount > 1) ifTrue:		[aMenu add: 'propagate status to siblings' translated selector: #assignStatusToAllSiblingsIn: argument: aStatusViewer.		aMenu balloonTextForLastItem: 'Make the status of this script in all of my sibling instances be the same as the status you see here' translated].	aMenu add: 'reveal this object' translated target: player selector: #revealPlayerIn: argument: ActiveWorld.	aMenu balloonTextForLastItem: 'Make certain this object is visible on the screen; flash its image for a little while, and give it the halo.' translated.	aMenu add: 'open this script''s Scriptor' translated target: player selector: #grabScriptorForSelector:in: argumentList: {selector. aStatusViewer world}.	aMenu balloonTextForLastItem: 'Open up the Scriptor for this script' translated.	aMenu add: 'open this object''s Viewer' translated target: player selector: #beViewed.	aMenu balloonTextForLastItem: 'Open up a Viewer for this object' translated.	aMenu addLine.	aMenu add: 'more...' translated target: self selector: #offerShiftedMenuIn: argument: aStatusViewer.	aMenu balloonTextForLastItem: 'The "more..." branch offers you menu items that are less frequently used.' translated.	aMenu popUpInWorld: ActiveWorld! !!ScriptInstantiation methodsFor: 'misc' stamp: 'dgd 12/15/2003 10:12'!offerShiftedMenuIn: aStatusViewer	"Put up the shifted menu"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu title: player knownName, ' ', selector.	aMenu add: 'grab this object' translated target: player selector: #grabPlayerIn: argument: self currentWorld.	aMenu balloonTextForLastItem: 'Wherever this object currently is, the "grab" command will rip it out, and place it in your "hand".  This is a very drastic step, that can disassemble things that may be very hard to put back together!!' translated.	aMenu add: 'destroy this script' translated target: player selector: #removeScriptWithSelector: argument: selector.	aMenu balloonTextForLastItem: 'Caution!!  This is irreversibly destructive -- it removes the script from the system.' translated.	aMenu addLine.	aMenu add: 'inspect morph' translated target: player costume selector: #inspect.	aMenu add: 'inspect player' translated target: player selector: #inspect.	aMenu popUpInWorld: ActiveWorld! !!ScriptInstantiation methodsFor: 'misc' stamp: 'ar 2/12/2001 18:58'!prepareToBeRunning	lastTick := nil.! !!ScriptInstantiation methodsFor: 'misc' stamp: 'dgd 12/15/2003 10:09'!statusControlRowIn: aStatusViewer	"Answer an object that reports my status and lets the user change it"	| aRow aMorph buttonWithPlayerName |	aRow := ScriptStatusLine newRow beTransparent.	buttonWithPlayerName := UpdatingSimpleButtonMorph new.	buttonWithPlayerName		on: #mouseEnter send: #menuButtonMouseEnter: to: buttonWithPlayerName;		 on: #mouseLeave send: #menuButtonMouseLeave: to: buttonWithPlayerName.	buttonWithPlayerName target: self; wordingSelector: #playersExternalName; actionSelector: #offerMenuIn:; arguments: {aStatusViewer}; beTransparent; actWhen: #buttonDown.	buttonWithPlayerName setBalloonText: 'This is the name of the player to which this script belongs; if you click here, you will get a menu of interesting options pertaining to this player and script' translated.	buttonWithPlayerName borderWidth: 1; borderColor: Color blue.	aRow addMorphBack: buttonWithPlayerName.	aRow addTransparentSpacerOfSize: 10@0.	aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.	aMorph := UpdatingStringMorph on: self selector: #selector.	aMorph color: Color brown lighter; useStringFormat.	aMorph setBalloonText: 'This is the name of the script to which this entry pertains.' translated.	aRow addMorphBack: aMorph.	aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.	aRow addTransparentSpacerOfSize: 10@0.	aRow addMorphBack: self statusControlMorph.	aRow submorphsDo: [:m | m wantsSteps ifTrue: [m step]].	^ aRow! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 1/28/2001 16:06'!changeSelectorTo: aNewSelector	"Change the selector associated with the receiver to the new one provided"	selector := aNewSelector! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 5/13/1998 10:43'!player: p	"Needed for making duplicate players, otherwise private"	player := p! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 5/1/1998 21:33'!player: p selector: s status: st	frequency := 0.	status := st.	player := p.	selector := s! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 4/30/1998 14:07'!selector: sel	selector := sel! !!ScriptInstantiation methodsFor: 'running' stamp: 'nk 8/21/2004 12:08'!runIfClosing	| result |	(result := status == #closing) ifTrue:		[player triggerScript: selector].	^ result! !!ScriptInstantiation methodsFor: 'running' stamp: 'nk 8/21/2004 12:08'!runIfOpening	| result |	(result := status == #opening) ifTrue:		[player triggerScript: selector].	^ result! !!ScriptInstantiation methodsFor: 'status control' stamp: 'dgd 9/6/2003 18:15'!presentTickingMenu	"Put up a menu of status alternatives and carry out the request"	| aMenu ticks item any |	ticks := self tickingRate.	ticks = ticks asInteger ifTrue:[ticks := ticks asInteger].	aMenu := MenuMorph new defaultTarget: self.	any := false.	#(1 2 5 8 10 25 50 100) do:[:i | 		item := aMenu addUpdating: nil target: self selector: #tickingRate: argumentList: {i}.		item contents:			((ticks = i) ifTrue:[ any := true. '<on>', i printString]					ifFalse:['<off>', i printString])].	item := aMenu addUpdating: nil target: self selector: #typeInTickingRate argumentList: #().	item contents: (any ifTrue:['<off>'] ifFalse:['<on>']), 'other...' translated.	aMenu addTitle: ('Ticks (now: {1}/sec)' translated format:{ticks}).	aMenu  popUpEvent: self currentEvent in: self currentWorld! !!ScriptInstantiation methodsFor: 'status control' stamp: 'sw 6/13/2002 15:14'!resetToNormalIfCurrently: aStatus	"If my status *had been* aStatus, quietly reset it to normal, without tampering with event handlers.  But get the physical display of all affected status morphs right"	status == aStatus ifTrue:		[status := #normal.		self updateAllStatusMorphs]! !!ScriptInstantiation methodsFor: 'status control' stamp: 'sw 4/30/1998 14:10'!status	status ifNil: [status := #normal].	^ status! !!ScriptInstantiation methodsFor: 'status control' stamp: 'em 3/24/2005 14:49'!typeInTickingRate	| reply aNumber |	reply := FillInTheBlank request: 'Number of ticks per second: ' translated initialAnswer: self tickingRate printString.	reply ifNotNil:		[aNumber := reply asNumber.		aNumber > 0 ifTrue:			[self tickingRate: aNumber]]! !!ScriptInstantiation methodsFor: 'status control' stamp: 'dgd 9/21/2003 16:04'!updateStatusMorph: statusControlMorph	"the status control may need to reflect an externally-induced change in status"	| colorSelector statusReadoutButton |	statusControlMorph ifNil: [^ self].	self pausedOrTicking		ifTrue:			[statusControlMorph assurePauseTickControlsShow]		ifFalse:			[statusControlMorph maybeRemovePauseTickControls].	statusReadoutButton := statusControlMorph submorphs last.	colorSelector := ScriptingSystem statusColorSymbolFor: self status.	statusReadoutButton color: (Color perform: colorSelector) muchLighter.	statusReadoutButton label: self translatedStatus asString font: Preferences standardButtonFont! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 21:06'!script84	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.96.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 20:55'!script84Log	"adding way to reset current CS"! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/14/2006 20:33'!script85	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.97.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87Log	"Name: KernelTests-lr.49Author: lrTime: 5 October 2006, 10:16:34 amUUID: 762d5c23-0364-4c26-ba13-129327ea7f39Ancestors: KernelTests-lr.48- merged code to fix unknown pragma selectors and binary selectors in pragmas- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmas- added some testsName: Compiler-lr.56Author: lrTime: 5 October 2006, 10:14:04 amUUID: f429f722-c39f-4acf-9d8c-c8a38320eaa8Ancestors: Compiler-lr.55- merged code to fix unknown pragma selectors- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmasMorphic fix duplicateChange Set:		ToggleBreakFix39Date:			26 September 2006Author:			tim@rowledge.orgPutative fix for Mantis http://bugs.impara.de/view.php?id=5123Fix Squeakmap"! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/15/2006 11:11'!script88	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/18/2006 11:37'!script89	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.114.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/20/2006 21:30'!script90	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.149.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.114.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 11/6/2006 20:38'!script91	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.150.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.115.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/8/2006 20:53'!updateFrom7056	"self new updateFrom7056"			self script84.	"include changeset extension"	self cleaningCS.		self flushCaches.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/14/2006 21:10'!updateFrom7057	"self new updateFrom7057"			self script85.	"fix windowColorRegistry"	ServicePreferences wipe.	ServiceRegistry rebuild.	WindowColorRegistry refresh.	self cleaningCS.		self flushCaches.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46'!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/13/2006 19:19'!updateFrom7061	"self new updateFrom7061"	self script87.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/15/2006 11:11'!updateFrom7063	"self new updateFrom7063"		self script88.	SMSqueakMap default noteInstalledPackageNamed: 'SqueakMap2 loader'autoVersion: '10'.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/18/2006 11:37'!updateFrom7064	"self new updateFrom7064"		self script89.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/20/2006 21:31'!updateFrom7065	"self new updateFrom7065"		self script90.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 11/7/2006 11:50'!updateFrom7066	"self new updateFrom7066"		self script91.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	SystemVersion newVersion: 'Squeak3.9'.	self flushCaches.	! !!ScriptLoader methodsFor: 'private helpers' stamp: 'pk 5/13/2007 14:16'!cleaningCS	"self new cleaningCS" 	 	ChangesOrganizer removeChangeSetsNamedSuchThat: [:each | true].	ChangeSet resetCurrentToNewUnnamedChangeSet ! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/8/2006 20:59'!currentPackages	"ScriptLoader new currentPackages" 			| copies |	copies := MCWorkingCopy allManagers asSortedCollection:		[ :a :b | a package name <= b package name ].	^ copies select: [:each | '*Plus*' match: each package name ].! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/14/2006 20:33'!generateCS: extensionAndNumber fromUpdate: updateNumber on: st		st nextPutAll:'"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: ''http://source.squeakfoundation.org/39a''                user: ''''                password: ''''.(repository loadVersionFromFileNamed:' .	st nextPut: $' ; nextPutAll: 'ScriptLoader', extensionAndNumber, '.mcz'') load.'; cr.	st nextPutAll: 'ScriptLoader new updateFrom', (updateNumber-1) asString; nextPutAll: '.' ; cr.	st nextPutAll: '!!'.	^ st contents! !!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:12'!cleanOldRepositories	"self new cleanOldRepositories"	"does not work since the interface of the repository group is not made for removing a repository only based on name"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			removeRepository: (MCHttpRepository new location: 'http://kilana.unibe.ch:8888/Monticello');			removeRepository: (MCHttpRepository new location: 'http://modules.squeakfoundation.org/People/gk/')].	! !!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:08'!installInBoxAnd39	"self new installInBoxAnd39"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/39a' ; user: ''; password: '');			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/inbox' ; user: '' ; password: '')].		! !!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:07'!installRepository: aString for: packageName	(MCWorkingCopy allManagers select: [:each | each package name = packageName])		first repositoryGroup		addRepository: (MCHttpRepository new location: aString ; user: 'squeak' ; password: 'squeak')		! !!ScriptNameTile methodsFor: 'initialization' stamp: 'sw 12/19/2003 23:09'!dataType: aDataType	"Initialize the receiver with the given data type"	dataType := aDataType.	literal := #emptyScript! !!ScriptNameType methodsFor: 'tiles' stamp: 'sw 12/19/2003 23:11'!defaultArgumentTile	"Answer a tile to represent the type"	| aTile  |	aTile := ScriptNameTile new dataType: self vocabularyName.	aTile addArrows.	aTile setLiteral: #emptyScript.	^ aTile! !!ScriptStatusControl methodsFor: 'initialization' stamp: 'dgd 9/21/2003 15:54'!assurePauseTickControlsShow	"Add two little buttons that allow the user quickly to toggle between paused and ticking state"	| colorSelector status |	self beTransparent.	(tickPauseWrapper isKindOf: TickIndicatorMorph) ifFalse:[		"this was an old guy"		tickPauseWrapper ifNotNil:[tickPauseWrapper delete].		tickPauseWrapper := TickIndicatorMorph new.		tickPauseWrapper on: #mouseDown send: #mouseDownTick:onItem: to: self.		tickPauseWrapper on: #mouseUp send: #mouseUpTick:onItem: to: self.		tickPauseWrapper setBalloonText:'Press to toggle ticking state. Hold down to set tick rate.' translated.		self addMorphFront: tickPauseWrapper.	].	status := scriptInstantiation status.	colorSelector := ScriptingSystem statusColorSymbolFor: status.	tickPauseWrapper color: (Color perform: colorSelector) muchLighter.	tickPauseWrapper stepTime: (1000 // scriptInstantiation tickingRate max: 0).	tickPauseWrapper isTicking: status == #ticking.	tickPauseButtonsShowing := true.! !!ScriptStatusControl methodsFor: 'initialization' stamp: 'dgd 11/26/2003 15:02'!initializeFor: aScriptInstantiation	"Answer a control that will serve to reflect and allow the user to change the status of the receiver"	|  statusReadout |	self hResizing: #shrinkWrap.	self cellInset: 2@0.	scriptInstantiation := aScriptInstantiation.	tickPauseButtonsShowing := false.	self addMorphBack: (statusReadout := UpdatingSimpleButtonMorph new).	statusReadout label: aScriptInstantiation status asString font: Preferences standardButtonFont.	statusReadout setNameTo: 'trigger'.	statusReadout target: aScriptInstantiation; wordingSelector: #translatedStatus; actionSelector: #presentScriptStatusPopUp.	statusReadout setBalloonText: 'when this script should run' translated.	statusReadout actWhen: #buttonDown.	self assurePauseTickControlsShow.	aScriptInstantiation updateStatusMorph: self! !!ScriptStatusControl methodsFor: 'initialization' stamp: 'ar 2/12/2001 18:24'!maybeRemovePauseTickControls	"If we're in the business of removing pauseTick controls when we're neither paused nor ticking, then do it now.  The present take is not to remove these controls, which explains why the body of this method is currently commented out."	tickPauseButtonsShowing := false.	"note: the following is to change color of the tick control appropriately"	self assurePauseTickControlsShow.! !!ScriptableButton methodsFor: 'accessing' stamp: 'sw 10/30/2000 11:02'!label	"Answer a string representing the label of the receiver, returning an empty string if necessary"	| aStringMorph |	^ (aStringMorph := self findA: StringMorph)		ifNil:		['']		ifNotNil:	[aStringMorph contents]! !!ScriptableButton methodsFor: 'accessing' stamp: 'sw 10/30/2000 10:59'!label: aString	"Set the receiver's label as indicated"	| aLabel |	(aLabel := self findA: StringMorph)		ifNotNil:			[aLabel contents: aString]		ifNil:			[aLabel := StringMorph contents: aString font: TextStyle defaultFont.			self addMorph: aLabel].	self extent: aLabel extent + (borderWidth + 6).	aLabel position: self center - (aLabel extent // 2).	aLabel lock! !!ScriptableButton methodsFor: 'accessing' stamp: 'tk 9/28/2001 21:09'!scriptSelector: aSymbol	scriptSelector := aSymbol! !!ScriptableButton methodsFor: 'label' stamp: 'yo 11/4/2002 22:13'!label: aString font: aFontOrNil	"Set the receiver's label and font as indicated"	| oldLabel m aFont |	(oldLabel := self findA: StringMorph)		ifNotNil: [oldLabel delete].	aFont := aFontOrNil ifNil: [TextStyle defaultFont].	m := StringMorph contents: aString font: aFont.	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!ScriptableButton methodsFor: 'menu' stamp: 'sw 10/30/2000 11:02'!setLabel	"Invoked from a menu, let the user change the label of the button"	| newLabel |	newLabel := FillInTheBlank		request:'Enter a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel font: nil].! !!ScrollBar methodsFor: 'initialize' stamp: 'wiz 12/22/2007 23:01'!initializeMenuButton"initialize the receiver's menuButton"	"Preferences disable: #scrollBarsWithoutMenuButton"	"Preferences enable: #scrollBarsWithoutMenuButton"	(Preferences valueOfFlag: #scrollBarsWithoutMenuButton)		ifTrue: [menuButton := nil .^ self].	menuButton _ self roundedScrollbarLook		ifTrue: [RectangleMorph					newBounds: ((bounds isWide							ifTrue: [upButton bounds topRight]							ifFalse: [upButton bounds bottomLeft])							extent: self buttonExtent)]		ifFalse: [RectangleMorph					newBounds: (self innerBounds topLeft extent: self buttonExtent)					color: self thumbColor].	menuButton		on: #mouseEnter		send: #menuButtonMouseEnter:		to: self.	menuButton		on: #mouseDown		send: #menuButtonMouseDown:		to: self.	menuButton		on: #mouseLeave		send: #menuButtonMouseLeave:		to: self.	"menuButton 	addMorphCentered: (RectangleMorph 	newBounds: (0 @ 0 extent: 4 @ 2) 	color: Color black)."	self updateMenuButtonImage.	self roundedScrollbarLook		ifTrue: [menuButton color: Color veryLightGray.			menuButton				borderStyle: (BorderStyle complexRaised width: 3)]		ifFalse: [menuButton setBorderWidth: 1 borderColor: Color lightGray].	self addMorph: menuButton! !!ScrollController methodsFor: 'basic control sequence'!controlInitialize	"Recompute scroll bars.  Save underlying image unless it is already saved."	| |	super controlInitialize.	scrollBar region: (0 @ 0 extent: 24 @ view apparentDisplayBox height).	scrollBar insideColor: view backgroundColor.	marker region: self computeMarkerRegion.	scrollBar := scrollBar align: scrollBar topRight with: view apparentDisplayBox topLeft.	marker := marker align: marker topCenter with: self upDownLine @ (scrollBar top + 2).	savedArea isNil ifTrue: [savedArea := Form fromDisplay: scrollBar].	scrollBar displayOn: Display.	"Show a border around yellow-button (menu) region""	yellowBar := Rectangle left: self yellowLine right: scrollBar right + 1		top: scrollBar top bottom: scrollBar bottom.	Display border: yellowBar width: 1 mask: Form veryLightGray."	self moveMarker! !!ScrollController methodsFor: 'basic control sequence'!controlTerminate	super controlTerminate.	savedArea notNil 			ifTrue: 			[savedArea displayOn: Display at: scrollBar topLeft.			savedArea := nil].! !!ScrollController methodsFor: 'initialize-release'!initialize	super initialize.	scrollBar := Quadrangle new.	scrollBar borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	marker := Quadrangle new.	marker insideColor: Preferences scrollBarColor.	menuBar := Quadrangle new.	menuBar borderWidthLeft:  2 right: 0 top: 2 bottom: 2.! !!ScrollController methodsFor: 'marker adjustment'!markerRegion: aRectangle 	"Set the area defined by aRectangle as the marker. Fill it with gray tone."	Display fill: marker fillColor: scrollBar insideColor.	marker region: aRectangle.	marker := marker align: marker topCenter 			with: self upDownLine @ (scrollBar top + 2) ! !!ScrollController methodsFor: 'marker adjustment'!moveMarker: anInteger anchorMarker: anchorMarker	"Update the marker so that is is translated by an amount corresponding to 	a distance of anInteger, constrained within the boundaries of the scroll 	bar.  If anchorMarker ~= nil, display the border around the area where the	marker first went down."	Display fill: marker fillColor: scrollBar insideColor.	anchorMarker = nil		ifFalse: [Display border: anchorMarker width: 1 fillColor: Color gray].	marker := marker translateBy: 0 @				((anInteger min: scrollBar inside bottom - marker bottom) max:					scrollBar inside top - marker top).	marker displayOn: Display! !!ScrollController methodsFor: 'scrolling' stamp: 'ls 7/11/1998 06:33'!scroll	"Check to see whether the user wishes to jump, scroll up, or scroll down."	| savedCursor |	savedCursor := sensor currentCursor.			[self scrollBarContainsCursor]				whileTrue: 					[self interActivityPause.					sensor cursorPoint x <= self downLine								ifTrue: [self scrollDown]								ifFalse: [sensor cursorPoint x <= self upLine										ifTrue: [self scrollAbsolute]										ifFalse: [sensor cursorPoint x <= self yellowLine												ifTrue: [self scrollUp]												ifFalse: [sensor cursorPoint x <= scrollBar right														ifTrue: "Might not be, with touch pen"														[self changeCursor: Cursor menu.														sensor anyButtonPressed 														ifTrue: [self changeCursor: savedCursor. 																self anyButtonActivity]]]]]].	savedCursor show! !!ScrollController methodsFor: 'scrolling' stamp: 'th 12/11/1999 16:57'!scrollByKeyboard	| keyEvent |	keyEvent := sensor keyboardPeek.	keyEvent ifNil: [^ false].	(sensor controlKeyPressed or:[sensor commandKeyPressed]) ifFalse: [^ false].	keyEvent asciiValue = 30		ifTrue: 			[sensor keyboard.			self scrollViewDown ifTrue: [self moveMarker].			^ true].	keyEvent asciiValue = 31		ifTrue: 			[sensor keyboard.			self scrollViewUp ifTrue: [self moveMarker].			^ true].	^ false! !!ScrollController methodsFor: 'private'!scrollAbsolute	| markerOutline oldY markerForm |	self changeCursor: Cursor rightArrow.	oldY := -1.	sensor anyButtonPressed ifTrue: 	  [markerOutline := marker deepCopy.	  markerForm := Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  Display border: markerOutline width: 1 fillColor: Color gray.	  markerForm 		follow: 			[oldY ~= sensor cursorPoint y				ifTrue: 					[oldY := sensor cursorPoint y.					marker := marker translateBy: 					  0 @ ((oldY - marker center y 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).					self scrollView].				marker origin] 		while: [sensor anyButtonPressed].	  Display fill: markerOutline fillColor: scrollBar insideColor.	  self moveMarker]! !!ScrollController methodsFor: 'private'!scrollDown	| markerForm firstTime |	self changeCursor: Cursor down.	sensor anyButtonPressed ifTrue:	  [markerForm := Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  firstTime := true.	  markerForm 		follow: 			[self scrollViewDown ifTrue:				[marker := marker translateBy: 0 @					((self markerDelta negated 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).				firstTime					ifTrue: [						"pause before scrolling repeatedly"						(Delay forMilliseconds: 250) wait.						firstTime := false.					] ifFalse: [						(Delay forMilliseconds: 50) wait.					].				].			marker origin] 		while: [sensor anyButtonPressed].	  self moveMarker.]! !!ScrollController methodsFor: 'private'!scrollUp	| markerForm firstTime |	self changeCursor: Cursor up.	sensor anyButtonPressed ifTrue:	  [markerForm := Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  firstTime := true.	  markerForm 		follow: 			[self scrollViewUp ifTrue:				[marker := marker translateBy: 0 @					((self markerDelta negated 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).				firstTime					ifTrue: [						"pause before scrolling repeatedly"						(Delay forMilliseconds: 250) wait.						firstTime := false.					] ifFalse: [						(Delay forMilliseconds: 50) wait.					].				].			marker origin] 		while: [sensor anyButtonPressed].	  self moveMarker.]! !!SearchingViewer methodsFor: 'initialization' stamp: 'tak 8/8/2005 11:31'!addNamePaneTo: header	"Add the namePane, which may be a popup or a type-in depending on the type of CategoryViewer"	| plugTextMor searchButton |	namePane := AlignmentMorph newRow vResizing: #spaceFill; height: 14.	namePane hResizing: #spaceFill.	namePane listDirection: #leftToRight.	plugTextMor := PluggableTextMorph on: self					text: #searchString accept: #searchString:notifying:					readSelection: nil menu: nil.	plugTextMor setProperty: #alwaysAccept toValue: true.	plugTextMor askBeforeDiscardingEdits: false.	plugTextMor acceptOnCR: true.	plugTextMor setTextColor: Color brown.	plugTextMor setNameTo: 'Search' translated.	plugTextMor vResizing: #spaceFill; hResizing: #spaceFill.	plugTextMor hideScrollBarsIndefinitely.	plugTextMor setTextMorphToSelectAllOnMouseEnter.	searchButton := SimpleButtonMorph new 		target: self;		beTransparent;		actionSelector: #doSearchFrom:;		arguments: {plugTextMor}.	namePane addMorphFront: searchButton.	namePane addTransparentSpacerOfSize: 6@0.	namePane addMorphBack: plugTextMor.	header addMorphBack: namePane.	self updateSearchButtonLabel.! !!SearchingViewer methodsFor: 'search' stamp: 'nk 8/29/2004 17:21'!doSearchFrom:  aSource interactive: isInteractive	"Perform the search operation.  If interactive is true, this actually happened because a search button was pressed; if false, it was triggered some other way for which an informer would be inappropriate."	| searchFor aVocab aList all anInterface useTranslations scriptNames addedMorphs |	searchString := (aSource isKindOf: PluggableTextMorph)		ifFalse:			[aSource]		ifTrue:			[aSource text string].	searchFor := searchString asString asLowercase withBlanksTrimmed.	aVocab := self outerViewer currentVocabulary.	(useTranslations := (scriptedPlayer isPlayerLike) and: [aVocab isEToyVocabulary])		ifTrue:			[all := scriptedPlayer costume selectorsForViewer.			all addAll: (scriptNames := scriptedPlayer class namedTileScriptSelectors)]		ifFalse:			[all := scriptNames := scriptedPlayer class allSelectors].	aList := all select:		[:aSelector | (aVocab includesSelector: aSelector forInstance: scriptedPlayer ofClass: scriptedPlayer class limitClass: ProtoObject) and:			[(useTranslations and: [(anInterface := aVocab methodInterfaceAt: aSelector ifAbsent: [nil]) notNil and: [anInterface wording includesSubstring: searchFor caseSensitive: false]])				or:					[((scriptNames includes: aSelector) or: [useTranslations not]) and:						[aSelector includesSubstring: searchFor caseSensitive: false]]]].	aList := aList asSortedArray.	self removeAllButFirstSubmorph. "that being the header"	self addAllMorphs:		((addedMorphs := scriptedPlayer tilePhrasesForSelectorList: aList inViewer: self)).	self enforceTileColorPolicy.	self secreteCategorySymbol.	self world ifNotNil: [self world startSteppingSubmorphsOf: self].	self adjustColorsAndBordersWithin.	owner ifNotNil: [owner isStandardViewer ifTrue: [owner fitFlap].	(isInteractive and: [addedMorphs isEmpty]) ifTrue:		[self inform: ('No matches found for "' translated), searchFor, '"']]! !!SearchingViewer methodsFor: 'search' stamp: 'sw 8/22/2002 15:14'!rawSearchString: aString	"Set the search string as indicated"	searchString := aString asString! !!SearchingViewer methodsFor: 'search' stamp: 'sw 8/11/2002 02:14'!searchString	"Answer the search string"	^ searchString ifNil: [searchString := '']! !!SearchingViewer methodsFor: 'search' stamp: 'sw 8/22/2002 20:30'!searchString: aString notifying: znak	"Set the search string as indicated and carry out a search"	searchString := aString asString.	self doSearchFrom: searchString! !!SelectionMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:38'!selections: selectionArray	selections := selectionArray! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'sma 5/28/2000 15:28'!invokeOn: targetObject	"Pop up this menu and return the result of sending to the target object 	the selector corresponding to the menu item selected by the user. Return 	nil if no item is selected."	| sel |	sel := self startUp.	sel = nil ifFalse: [^ targetObject perform: sel].	^ nil"Example:	(SelectionMenu labels: 'sincosneg' lines: #() selections: #(sin cos negated)) invokeOn: 0.7"! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'sw 12/17/2001 17:26'!startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean	"Overridden to return value returned by manageMarker.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"	| index |	index := super startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.	(selections = nil or: [(index between: 1 and: selections size) not])		ifTrue: [^ nil].	^ selections at: index! !!SelectionMenu methodsFor: 'invocation' stamp: 'sw 11/18/2002 16:24'!invokeOn: targetObject orSendTo: anObject	"Pop up the receiver, obtaining a selector; return the result of having the target object perform the selector.  If it dos not understand the selector, give the alternate object a chance"	| aSelector |	^ (aSelector := self startUp) ifNotNil:		[(targetObject respondsTo: aSelector)			ifTrue:				[targetObject perform: aSelector]			ifFalse:				[anObject perform: aSelector]]! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sw 11/8/1999 17:52'!fromArray: anArray	"Construct a menu from anArray.  The elements of anArray must be either:	*  A pair of the form: <label> <selector>or	*  The 'dash' (or 'minus sign') symbol	Refer to the example at the bottom of the method"	| labelList lines selections anIndex |	labelList := OrderedCollection new.	lines := OrderedCollection new.	selections := OrderedCollection new.	anIndex := 0.	anArray do:		[:anElement |			anElement size == 1				ifTrue:					[(anElement == #-) ifFalse: [self error: 'badly-formed menu constructor'].					lines add: anIndex]				ifFalse:					[anElement size == 2 ifFalse: [self error: 'badly-formed menu constructor'].					anIndex := anIndex + 1.					labelList add: anElement first.					selections add: anElement second]].	^ self labelList: labelList lines: lines selections: selections"(SelectionMenu fromArray:	#(	('first label'		moja)		('second label'	mbili)		-		('third label' 	tatu)		-		('fourth label'	nne)		('fifth label'	tano))) startUp"! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'yo 8/30/2002 17:02'!labels: labels lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in labels, with lines drawn  	after each item indexed by linesArray. Labels can be either a string  	with embedded CRs, or a collection of strings. Record the given array of 	selections corresponding to the items in labels."	| labelString |	(labels isString)		ifTrue: [labelString := labels]		ifFalse: [labelString := String streamContents:					[:s |					labels do: [:l | s nextPutAll: l; cr].					s skip: -1]].	^ (self labels: labelString lines: linesArray) selections: selectionsArray! !!Semaphore methodsFor: 'communication' stamp: 'ar 8/30/2007 16:15'!waitTimeoutMSecs: anInteger	"Wait on this semaphore for up to the given number of milliseconds, then timeout. It is up to the sender to determine the difference between the expected event and a timeout."	| d |	d := Delay timeoutSemaphore: self afterMSecs: (anInteger max: 0).	[self wait] ensure:[d unschedule].! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 17:59'!critical: mutuallyExcludedBlock				"Evaluate mutuallyExcludedBlock only if the receiver is not currently in	the process of running the critical: message. If the receiver is, evaluate	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue caught |	caught := false.	[		caught := true.		self wait.		blockValue := mutuallyExcludedBlock value	] ensure: [caught ifTrue: [self signal]].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 18:33'!critical: mutuallyExcludedBlock ifCurtailed: terminationBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	^self critical:[[mutuallyExcludedBlock value] ifCurtailed: terminationBlock]! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 17:59'!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr |	hasError := false.	self critical:[		blockValue := [mutuallyExcludedBlock value] ifError:[:msg :rcvr|			hasError := true.			errMsg := msg.			errRcvr := rcvr		].	].	hasError ifTrue:[ ^errorBlock value: errMsg value: errRcvr].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 18:34'!critical: mutuallyExcludedBlock ifLocked: alternativeBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	excessSignals == 0 ifTrue:[		"If we come here, then the semaphore was locked when the test executed. 		Evaluate the alternative block and answer its result."		^alternativeBlock value 	].	^self critical: mutuallyExcludedBlock! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ac 7/5/2004 22:35'!after: target ifAbsent: exceptionBlock	"Answer the element after target.  Answer the result of evaluation	the exceptionBlock if target is not in the receiver, or if there are 	no elements after it."	| index |	index := self indexOf: target.	^ (index == 0 or: [index = self size])		ifTrue: [exceptionBlock value]		ifFalse: [self at: index + 1]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 4/22/2000 17:45'!atAllPut: anObject 	"Put anObject at every one of the receiver's indices."	| size |	(size := self size) > 26 "first method faster from 27 accesses and on"		ifTrue: [self from: 1 to: size put: anObject]		ifFalse: [1 to: size do: [:index | self at: index put: anObject]]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'apb 11/4/2000 22:51'!atAll: indexArray	"Answer a new collection like the receiver which contains all elements	of the receiver at the indices of indexArray."	"#('one' 'two' 'three' 'four') atAll: #(3 2 4)"	| newCollection |	newCollection := self species ofSize: indexArray size.	1 to: indexArray size do:		[:index |		newCollection at: index put: (self at: (indexArray at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ac 7/5/2004 22:36'!before: target ifAbsent: exceptionBlock	"Answer the receiver's element immediately before target. Answer	the result of evaluating the exceptionBlock if target is not an element	of the receiver, or if there are no elements before it."	| index |	index := self indexOf: target.	^ (index == 0 or: [index == 1])		ifTrue: [exceptionBlock value]		ifFalse: [self at: index - 1]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'SqR 10/30/2000 22:06'!from: startIndex to: endIndex put: anObject	"Put anObject in all indexes between startIndex 	and endIndex. Very fast. Faster than to:do: for	more than 26 positions. Answer anObject"	| written toWrite thisWrite |	startIndex > endIndex ifTrue: [^self].	self at: startIndex put: anObject.	written := 1.	toWrite := endIndex - startIndex + 1.	[written < toWrite] whileTrue:		[			thisWrite := written min: toWrite - written.			self 				replaceFrom: startIndex + written				to: startIndex + written + thisWrite - 1				with: self startingAt: startIndex.			written := written + thisWrite		].	^anObject! !!SequenceableCollection methodsFor: 'accessing'!indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock	"Answer the index of the receiver's first element, such that that element 	equals the first element of sub, and the next elements equal 	the rest of the elements of sub. Begin the search at element 	start of the receiver. If no such match is found, answer the result of 	evaluating argument, exceptionBlock."	| first index |	sub isEmpty ifTrue: [^ exceptionBlock value].	first := sub first.	start to: self size - sub size + 1 do:		[:startIndex |		(self at: startIndex) = first ifTrue:			[index := 1.			[(self at: startIndex+index-1) = (sub at: index)]				whileTrue:				[index = sub size ifTrue: [^startIndex].				index := index+1]]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:30'!last: n	"Answer the last n elements of the receiver.  	Raise an error if there are not enough elements."	| size |	size := self size.	^ self copyFrom: size - n + 1 to: size! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 1/20/98 16:22'!replaceAll: oldObject with: newObject 	"Replace all occurences of oldObject with newObject"	| index |	index := self				indexOf: oldObject				startingAt: 1				ifAbsent: [0].	[index = 0]		whileFalse: 			[self at: index put: newObject.			index := self						indexOf: oldObject						startingAt: index + 1						ifAbsent: [0]]! !!SequenceableCollection methodsFor: 'accessing'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the receiver 	starting at index, repStart, in the sequenceable collection, 	replacementCollection. Answer the receiver. No range checks are 	performed."	| index repOff |	repOff := repStart - start.	index := start - 1.	[(index := index + 1) <= stop]		whileTrue: [self at: index put: (replacement at: repOff + index)]! !!SequenceableCollection methodsFor: 'accessing'!swap: oneIndex with: anotherIndex 	"Move the element at oneIndex to anotherIndex, and vice-versa."	| element |	element := self at: oneIndex.	self at: oneIndex put: (self at: anotherIndex).	self at: anotherIndex put: element! !!SequenceableCollection methodsFor: 'comparing' stamp: 'tk 12/6/2000 11:39'!hasEqualElements: otherCollection	"Answer whether the receiver's size is the same as otherCollection's	size, and each of the receiver's elements equal the corresponding 	element of otherCollection.	This should probably replace the current definition of #= ."	| size |	(otherCollection isKindOf: SequenceableCollection) ifFalse: [^ false].	(size := self size) = otherCollection size ifFalse: [^ false].	1 to: size do:		[:index |		(self at: index) = (otherCollection at: index) ifFalse: [^ false]].	^ true! !!SequenceableCollection methodsFor: 'comparing' stamp: 'SqR 8/3/2000 13:39'!hash	| hash |	hash := self species hash.	1 to: self size do: [:i | hash := (hash + (self at: i) hash) hashMultiply].	^hash! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 9/14/1998 23:47'!asFloatArray	"Answer a FloatArray whose elements are the elements of the receiver, in 	the same order."	| floatArray |	floatArray := FloatArray new: self size.	1 to: self size do:[:i| floatArray at: i put: (self at: i) asFloat ].	^floatArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:19'!asIntegerArray	"Answer an IntegerArray whose elements are the elements of the receiver, in 	the same order."	| intArray |	intArray := IntegerArray new: self size.	1 to: self size do:[:i| intArray at: i put: (self at: i)].	^intArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'NS 5/30/2001 20:56'!asPointArray	"Answer an PointArray whose elements are the elements of the receiver, in 	the same order."	| pointArray |	pointArray := PointArray new: self size.	1 to: self size do:[:i| pointArray at: i put: (self at: i)].	^pointArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 4/10/2005 18:02'!asStringWithCr	"Convert to a string with returns between items.  Elements areusually strings.	 Useful for labels for PopUpMenus."	| labelStream |	labelStream := WriteStream on: (String new: 200).	self do: [:each |		each isString			ifTrue: [labelStream nextPutAll: each; cr]			ifFalse: [each printOn: labelStream. labelStream cr]].	self size > 0 ifTrue: [labelStream skip: -1].	^ labelStream contents! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:20'!asWordArray	"Answer a WordArray whose elements are the elements of the receiver, in 	the same order."	| wordArray |	wordArray := WordArray new: self size.	1 to: self size do:[:i| wordArray at: i put: (self at: i)].	^wordArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'raok 6/23/2003 12:51'!concatenation	|result index|	result := Array new: (self inject: 0 into: [:sum :each | sum + each size]).	index := 0.	self do: [:each | each do: [:item | result at: (index := index+1) put: item]].	^result! !!SequenceableCollection methodsFor: 'converting' stamp: 'jm 4/27/98 04:09'!reversed	"Answer a copy of the receiver with element order reversed."	"Example: 'frog' reversed"	| n result src |	n := self size.	result := self species new: n.	src := n + 1.	1 to: n do: [:i | result at: i put: (self at: (src := src - 1))].	^ result! !!SequenceableCollection methodsFor: 'copying'!copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| newSize |	newSize := stop - start + 1.	^(self species new: newSize)		replaceFrom: 1		to: newSize		with: self		startingAt: start! !!SequenceableCollection methodsFor: 'copying' stamp: 'ar 10/16/2001 19:03'!copyReplaceFrom: start to: stop with: replacementCollection 	"Answer a copy of the receiver satisfying the following conditions: If 	stop is less than start, then this is an insertion; stop should be exactly 	start-1, start = 1 means insert before the first character, start = size+1 	means append after last character. Otherwise, this is a replacement; start 	and stop have to be within the receiver's bounds."	| newSequenceableCollection newSize endReplacement |	newSize := self size - (stop - start + 1) + replacementCollection size.	endReplacement := start - 1 + replacementCollection size.	newSequenceableCollection := self species new: newSize.	start > 1 ifTrue:[		newSequenceableCollection			replaceFrom: 1			to: start - 1			with: self			startingAt: 1].	start <= endReplacement ifTrue:[		newSequenceableCollection			replaceFrom: start			to: endReplacement			with: replacementCollection			startingAt: 1].	endReplacement < newSize ifTrue:[		newSequenceableCollection			replaceFrom: endReplacement + 1			to: newSize			with: self			startingAt: stop + 1].	^newSequenceableCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'ajh 9/27/2002 12:09'!copyWithFirst: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver with newElement as the first element."	| newIC |	newIC := self species ofSize: self size + 1.	newIC 		replaceFrom: 2		to: self size + 1		with: self		startingAt: 1.	newIC at: 1 put: newElement.	^ newIC! !!SequenceableCollection methodsFor: 'copying'!copyWith: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver and has 	newElement at the last element."	| newIC |	newIC := self species new: self size + 1.	newIC 		replaceFrom: 1		to: self size		with: self		startingAt: 1.	newIC at: newIC size put: newElement.	^newIC! !!SequenceableCollection methodsFor: 'copying' stamp: 'fcs 1/20/2002 16:03'!forceTo: length paddingStartWith: elem 	"Force the length of the collection to length, padding  	the beginning of the result if necessary with elem.  	Note that this makes a copy."	| newCollection padLen |	newCollection := self species new: length.	padLen := length - self size max: 0.	newCollection		from: 1		to: padLen		put: elem.	newCollection		replaceFrom: padLen + 1		to: ((padLen + self size) min: length)		with: self		startingAt:  1.	^ newCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 4/22/2000 18:01'!forceTo: length paddingWith: elem	"Force the length of the collection to length, padding	if necessary with elem.  Note that this makes a copy."	| newCollection copyLen |	newCollection := self species new: length.	copyLen := self size min: length.	newCollection replaceFrom: 1 to: copyLen with: self startingAt: 1.	newCollection from: copyLen + 1 to: length put: elem.	^ newCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'djp 10/23/1999 22:12'!shuffledBy: aRandom	| copy | 	copy := self shallowCopy.	copy size to: 1 by: -1 do: 		[:i | copy swap: i with: ((1 to: i) atRandom: aRandom)].	^ copy! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 7/30/97 12:41'!asDigitsToPower: anInteger do: aBlock	"Repeatedly value aBlock with a single Array.  Adjust the collection	so that aBlock is presented all (self size raisedTo: anInteger) possible 	combinations of the receiver's elements taken as digits of an anInteger long number."	"(0 to: 1) asDigitsToPower: 4 do: [:each | Transcript cr; show: each printString]"	| aCollection |	aCollection := Array new: anInteger.	self asDigitsAt: 1 in: aCollection do: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:46'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection := self species new: self size.	1 to: self size do:		[:index |		newCollection at: index put: (aBlock value: (self at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 6/1/2000 11:47'!collect: aBlock from: firstIndex to: lastIndex	"Refer to the comment in Collection|collect:."	| size result j |	size := lastIndex - firstIndex + 1.	result := self species new: size.	j := firstIndex.	1 to: size do: [:i | result at: i put: (aBlock value: (self at: j)). j := j + 1].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 7/30/97 12:52'!combinations: kk atATimeDo: aBlock	"Take the items in the receiver, kk at a time, and evaluate the block for each combination.  Hand in an array of elements of self as the block argument.  Each combination only occurs once, and order of the elements does not matter.  There are (self size take: kk) combinations."	" 'abcde' combinations: 3 atATimeDo: [:each | Transcript cr; show: each printString]"	| aCollection |	aCollection := Array new: kk.	self combinationsAt: 1 in: aCollection after: 0 do: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ar 6/3/2000 15:54'!findBinaryIndex: aBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, evaluate exceptionBlock."	| index low high test |	low := 1.	high := self size.	[index := high + low // 2.	low > high] whileFalse:[		test := aBlock value: (self at: index).		test = 0 			ifTrue:[^index]			ifFalse:[test > 0				ifTrue: [low := index + 1]				ifFalse: [high := index - 1]]].	^exceptionBlock value! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ar 6/3/2000 15:52'!findBinary: aBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, evaluate exceptionBlock."	| index low high test item |	low := 1.	high := self size.	[index := high + low // 2.	low > high] whileFalse:[		test := aBlock value: (item := self at: index).		test = 0 			ifTrue:[^item]			ifFalse:[test > 0				ifTrue: [low := index + 1]				ifFalse: [high := index - 1]]].	^exceptionBlock value! !!SequenceableCollection methodsFor: 'enumerating'!findFirst: aBlock	"Return the index of my first element for which aBlock evaluates as true."	| index |	index := 0.	[(index := index + 1) <= self size] whileTrue:		[(aBlock value: (self at: index)) ifTrue: [^index]].	^ 0! !!SequenceableCollection methodsFor: 'enumerating'!findLast: aBlock	"Return the index of my last element for which aBlock evaluates as true."	| index |	index := self size + 1.	[(index := index - 1) >= 1] whileTrue:		[(aBlock value: (self at: index)) ifTrue: [^index]].	^ 0! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'nk 7/17/2003 17:55'!overlappingPairsCollect: aBlock 	"Answer the result of evaluating aBlock with all of the overlapping pairs of my elements."	| retval |	retval := self species new: self size - 1.	1 to: self size - 1		do: [:i | retval at: i put: (aBlock value: (self at: i) value: (self at: i + 1)) ].	^retval! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 12/27/2000 09:53'!polynomialEval: thisX	| sum valToPower |	"Treat myself as the coeficients of a polynomial in X.  Evaluate it with thisX.  First element is the constant and last is the coeficient for the highest power."	"  #(1 2 3) polynomialEval: 2   "   "is 3*X^2 + 2*X + 1 with X = 2"	sum := self first.	valToPower := thisX.	2 to: self size do: [:ind | 		sum := sum + ((self at: ind) * valToPower).		valToPower := valToPower * thisX].	^ sum! !!SequenceableCollection methodsFor: 'enumerating'!select: aBlock 	"Refer to the comment in Collection|select:."	| aStream |	aStream := WriteStream on: (self species new: self size).	1 to: self size do: 		[:index |		(aBlock value: (self at: index))			ifTrue: [aStream nextPut: (self at: index)]].	^ aStream contents! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 5/17/1998 13:34'!withIndexCollect: elementAndIndexBlock 	"Just like with:collect: except that the iteration index supplies the second argument to the block."	| result |	result := self species new: self size.	1 to: self size do:		[:index | result at: index put:		(elementAndIndexBlock			value: (self at: index)			value: index)].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 8/31/1999 13:13'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."	| result |	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	result := self species new: self size.	1 to: self size do:		[:index | result at: index put:		(twoArgBlock			value: (self at: index)			value: (otherCollection at: index))].	^ result! !!SequenceableCollection methodsFor: 'testing' stamp: 'bp 2/23/2004 21:48'!endsWith: aSequenceableCollection	| start |	(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].	start := self size - aSequenceableCollection size.	aSequenceableCollection withIndexDo: [:each :index | (self at: start + index) ~= each ifTrue: [^false]].	^true! !!SequenceableCollection methodsFor: 'private' stamp: 'yo 9/2/2002 18:22'!copyReplaceAll: oldSubstring with: newSubstring asTokens: ifTokens	"Answer a copy of the receiver in which all occurrences of	oldSubstring have been replaced by newSubstring.	ifTokens (valid for Strings only) specifies that the characters	surrounding the recplacement must not be alphanumeric.		Bruce Simth,  must be incremented by 1 and not 	newSubstring if ifTokens is true.  See example below. "	| aString startSearch currentIndex endIndex |	(ifTokens and: [(self isString) not])		ifTrue: [(self isKindOf: Text) ifFalse: [			self error: 'Token replacement only valid for Strings']].	aString := self.	startSearch := 1.	[(currentIndex := aString indexOfSubCollection: oldSubstring startingAt: startSearch)			 > 0]		whileTrue: 		[endIndex := currentIndex + oldSubstring size - 1.		(ifTokens not			or: [(currentIndex = 1					or: [(aString at: currentIndex-1) isAlphaNumeric not])				and: [endIndex = aString size					or: [(aString at: endIndex+1) isAlphaNumeric not]]])			ifTrue: [aString := aString					copyReplaceFrom: currentIndex					to: endIndex					with: newSubstring.				startSearch := currentIndex + newSubstring size]			ifFalse: [				ifTokens 					ifTrue: [startSearch := currentIndex + 1]					ifFalse: [startSearch := currentIndex + newSubstring size]]].	^ aString"Test case:	'test te string' copyReplaceAll: 'te' with: 'longone' asTokens: true   "! !!SequenceableCollection class methodsFor: 'stream creation'!streamContents: blockWithArg	| stream |	stream := WriteStream on: (self new: 100).	blockWithArg value: stream.	^stream contents! !!SequenceableCollection class methodsFor: 'stream creation' stamp: 'di 6/20/97 09:07'!streamContents: blockWithArg limitedTo: sizeLimit	| stream |	stream := LimitedWriteStream on: (self new: (100 min: sizeLimit)).	stream setLimit: sizeLimit limitBlock: [^ stream contents].	blockWithArg value: stream.	^ stream contents"String streamContents: [:s | 1000 timesRepeat: [s nextPutAll: 'Junk']] limitedTo: 25 'JunkJunkJunkJunkJunkJunkJ'"! !!SequenceableCollectionTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:12'!testAtAllPut	|table|.	table := Array new: 5.	table atAllPut: $a.	self assert: (table allSatisfy: [:elem | elem = $a])! !!SequenceableCollectionTest methodsFor: 'tests - copying' stamp: 'dc 3/3/2007 17:13'!testCopyWith	| table |	table := Array new: 4 withAll: 3.	self assert: table = #(3 3 3 3).	table := table copyWith: 4.	self assert: table = #(3 3 3 3 4).! !!SequenceableCollectionTest methodsFor: 'tests - converting' stamp: 'dc 3/3/2007 17:16'!testEvalStrings	| table |	table := #('String new' 'Array with: 3 with: $a' '15+4').	table := table evalStrings.	self assert: table first isString.	self assert: table first isEmpty.		self assert: table second isArray.	self assert: table second first = 3.	self assert: table second second = $a.		self assert: table third = 19.! !!SequenceableCollectionTest methodsFor: 'tests - arithmetic' stamp: 'dc 3/3/2007 17:19'!testPreMultiplyByArray	| array|.	array := #(3).	self assert:(array preMultiplyByArray: 2)=6.		array := Array new: 4.	self should:[array preMultiplyByArray: 2] raise:Error.! !!SequenceableCollectionTest methodsFor: 'tests - arithmetic' stamp: 'dc 3/3/2007 17:26'!testPreMultiplyByMatrix	| array matrix result|.	array := #(1 2 3 4 5).		"( 1  2  3  4  5	  10 20 30 40 50)"	matrix := Matrix				rows:2 columns:5 tabulate: [:row :column | row = 1 											ifTrue: column											ifFalse: column * 10].	result := array preMultiplyByMatrix: matrix.	self assert: result isArray.	self assert: result size = 2.	self assert: result first = 55.	self assert: result second = 550.! !!SequenceableCollectionTest methodsFor: 'tests - arithmetic' stamp: 'dc 3/3/2007 17:28'!testPreMultiplyByMatrix2	| array matrix|.		array := #(1 2 3 4 5).	matrix := Matrix rows:1 columns:4 tabulate: [:row :column | column].		"Not compatible size"	self should:[array preMultiplyByMatrix: matrix] raise: Error.! !!SequenceableCollectionTest methodsFor: 'testing' stamp: 'dc 3/5/2007 15:57'!testReplaceFromToWithStartingAt	| string |	string := 'abcd' copy.	string replaceFrom: 1 to: 3 with: 'lmnop' startingAt: 1.	self assert: string = 'lmnd'.		string := 'abcd' copy.	string replaceFrom: 1 to: 3 with: 'lmnop' startingAt: 2.	self assert: string = 'mnod'.		string := 'abcd' copy.	string replaceFrom: 2 to: 3 with: 'lmnop' startingAt: 1.	self assert: string = 'almd'.! !!ServerDirectory methodsFor: '*eToys-school support' stamp: 'ar 9/5/2001 15:45'!eToyUserList	"Return a list of all known users for eToy login support"	| urlString |	eToyUserList ifNotNil:[^eToyUserList].	urlString := self eToyUserListUrl.	urlString ifNil:[^nil].	eToyUserList := self class parseEToyUserListFrom: urlString.	^eToyUserList! !!ServerDirectory methodsFor: '*eToys-school support' stamp: 'ar 8/24/2001 14:31'!eToyUserListUrl: aString	eToyUserListUrl := aString.	eToyUserList := nil.! !!ServerDirectory methodsFor: '*eToys-school support' stamp: 'ar 8/24/2001 14:31'!eToyUserList: aCollectionOrNil	"Set a list of all known users for eToy login support"	eToyUserList := aCollectionOrNil.! !!ServerDirectory class methodsFor: '*eToys-school support' stamp: 'ar 9/5/2001 16:38'!eToyUserListForFileDirectory: aFileDirectory	| urlString |	urlString := self eToyUserListUrlForFileDirectory: aFileDirectory.	urlString ifNil:[^nil].	^self parseEToyUserListFrom: urlString! !!ServerDirectory class methodsFor: '*eToys-school support' stamp: 'ar 9/5/2001 16:11'!localEToyBaseFolderSpecs	^LocalEToyBaseFolderSpecs ifNil:[LocalEToyBaseFolderSpecs := IdentityDictionary new]! !!ServerDirectory class methodsFor: '*eToys-school support' stamp: 'ar 9/5/2001 15:47'!localEToyUserListUrls	^LocalEToyUserListUrls ifNil:[LocalEToyUserListUrls := IdentityDictionary new].! !!ServerDirectory class methodsFor: '*eToys-school support' stamp: 'fbs 2/2/2005 13:24'!parseEToyUserListFrom: urlString	| url userString userList |	urlString ifNil:[^nil].	url := urlString asUrl.	["Note: We need to prevent going through the plugin API 	when retrieving a local (file) URL, since the plugin API	(correctly) rejects file:// downloads."		Cursor wait showWhile:[			(url hasRemoteContents) ifTrue:[				"Go through the browser (if present)"				userString := (HTTPClient httpGet: url asString) contents.			] ifFalse:[				"Go grab it directly"				userString := url retrieveContents contents.			].		].	] on: Error do:[:ex| userString := nil. ex return].	userString ifNil:[^nil].	"Get rid of any line ending problems"	userString := userString copyReplaceAll: String crlf with: String cr.	userString := userString copyReplaceAll: String lf with: String cr.	userList := (userString findTokens: Character cr) collect:[:each| each withBlanksTrimmed].	userList := userList reject:[:any| any isEmpty].	(userList first = '##user list##') ifFalse:[^nil].	userList := userList copyFrom: 2 to: userList size.	^userList! !!Set methodsFor: 'accessing' stamp: 'md 7/31/2005 08:56'!atRandom: aGenerator	"Answer a random element of the receiver. Uses aGenerator which    should be kept by the user in a variable and used every time. Use    this instead of #atRandom for better uniformity of random numbers because 	only you use the generator. Causes an error if self has no elements."	| rand |	self emptyCheck.	rand := aGenerator nextInt: self size.	self doWithIndex:[:each :ind |		ind == rand ifTrue:[^each]].	^ self errorEmptyCollection! !!Set methodsFor: 'accessing' stamp: 'SqR 8/23/2000 13:51'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	| index |	^(index := self scanFor: anObject) = 0		ifFalse: [array at: index]! !!Set methodsFor: 'adding' stamp: 'sma 5/12/2000 17:28'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject."	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self findElementOrNil: newObject.	(array at: index) ifNil: [self atNewIndex: index put: newObject].	^ newObject! !!Set methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:49'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newSet |	newSet := Set new: self size.	array do: [:each | each ifNotNil: [newSet add: (aBlock value: each)]].	^ newSet! !!Set methodsFor: 'enumerating' stamp: 'sma 5/12/2000 14:36'!do: aBlock 	tally = 0 ifTrue: [^ self].	1 to: array size do:		[:index |		| each |		(each := array at: index) ifNotNil: [aBlock value: each]]! !!Set methodsFor: 'enumerating'!doWithIndex: aBlock2	"Support Set enumeration with a counter, even though not ordered"	| index |	index := 0.	self do: [:item | aBlock2 value: item value: (index := index+1)]! !!Set methodsFor: 'removing'!remove: oldObject ifAbsent: aBlock	| index |	index := self findElementOrNil: oldObject.	(array at: index) == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^ oldObject! !!Set methodsFor: 'private'!atNewIndex: index put: anObject	array at: index put: anObject.	tally := tally + 1.	self fullCheck! !!Set methodsFor: 'private' stamp: 'SqR 8/23/2000 14:39'!findElementOrNil: anObject	"Answer the index of a first slot containing either a nil (indicating an empty slot) or an element that matches the given object. Answer the index of that slot or zero. Fail if neither a match nor an empty slot is found."	| index |	index := self scanFor: anObject.	index > 0 ifTrue: [^index].	"Bad scene.  Neither have we found a matching element	nor even an empty slot.  No hashed set is ever supposed to get	completely full."	self error: 'There is no free space in this set!!'.! !!Set methodsFor: 'private' stamp: 'SqR 8/23/2000 14:28'!fixCollisionsFrom: index	"The element at index has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one"	| length oldIndex newIndex element |	oldIndex := index.	length := array size.	[oldIndex = length			ifTrue: [oldIndex := 1]			ifFalse: [oldIndex := oldIndex + 1].	(element := self keyAt: oldIndex) == nil]		whileFalse: 			[newIndex := self findElementOrNil: element.			oldIndex = newIndex ifFalse: [self swap: oldIndex with: newIndex]]! !!Set methodsFor: 'private'!grow	"Grow the elements array and reinsert the old elements"	| oldElements |	oldElements := array.	array := Array new: array size + self growSize.	tally := 0.	oldElements do:		[:each | each == nil ifFalse: [self noCheckAdd: each]]! !!Set methodsFor: 'private' stamp: 'nice 4/4/2006 22:09'!initialize: n	"Initialize array to an array size of n"	array := Array new: n.	tally := 0! !!Set methodsFor: 'private'!noCheckAdd: anObject	array at: (self findElementOrNil: anObject) put: anObject.	tally := tally + 1! !!Set methodsFor: 'private'!rehash	| newSelf |	newSelf := self species new: self size.	self do: [:each | newSelf noCheckAdd: each].	array := newSelf array! !!Set methodsFor: 'private' stamp: 'md 10/5/2005 15:44'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Set methodsFor: 'private'!withArray: anArray	"private -- for use only in copy"	array := anArray! !!Set class methodsFor: 'initialization' stamp: 'SqR 8/3/2000 13:19'!quickRehashAllSets  "Set rehashAllSets"	| insts |	self withAllSubclassesDo:		[:c |			insts := c allInstances.			(insts isEmpty or: [c = MethodDictionary]) ifFalse:			['Rehashing instances of ' , c name				displayProgressAt: Sensor cursorPoint				from: 1 to: insts size				during: [:bar | 1 to: insts size do: [:x | bar value: x. (insts at: x) rehash]]			]		]! !!Set class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection := self new: aCollection size.	newCollection addAll: aCollection.	^ newCollection"	Set newFrom: {1. 2. 3}	{1. 2. 3} as: Set"! !!SharedQueue methodsFor: 'accessing' stamp: 'bf 2/11/2006 15:17'!flush	"Throw out all pending contents"	accessProtect critical: [		"nil out flushed slots --bf 02/11/2006"		contentsArray from: readPosition to: writePosition-1 put: nil.		readPosition := 1.		writePosition := 1.		"Reset the read synchronization semaphore"		readSynch initSignals].! !!SharedQueue methodsFor: 'accessing' stamp: 'NS 6/18/2002 11:15'!flushAllSuchThat: aBlock	"Remove from the queue all objects that satisfy aBlock."	| value newReadPos |	accessProtect critical: [		newReadPos := writePosition.		writePosition-1 to: readPosition by: -1 do:			[:i | value := contentsArray at: i.			contentsArray at: i put: nil.			(aBlock value: value) ifTrue: [				"We take an element out of the queue, and therefore, we need to decrement 				the readSynch signals"				readSynch wait.			] ifFalse: [				newReadPos := newReadPos - 1.				contentsArray at: newReadPos put: value]].		readPosition := newReadPos].	^value! !!SharedQueue methodsFor: 'accessing'!next	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, suspend the 	requesting process until one is."	| value |	readSynch wait.	accessProtect		critical: [readPosition = writePosition					ifTrue: 						[self error: 'Error in SharedQueue synchronization'.						 value := nil]					ifFalse: 						[value := contentsArray at: readPosition.						 contentsArray at: readPosition put: nil.						 readPosition := readPosition + 1]].	^value! !!SharedQueue methodsFor: 'accessing' stamp: 'RAA 12/14/2000 10:25'!nextOrNil	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, answer <nil>."	| value |	accessProtect critical: [		readPosition >= writePosition ifTrue: [			value := nil		] ifFalse: [			value := contentsArray at: readPosition.			contentsArray at: readPosition put: nil.			readPosition := readPosition + 1		].		readPosition >= writePosition ifTrue: [readSynch initSignals].	].	^value! !!SharedQueue methodsFor: 'accessing' stamp: 'di 10/1/2001 20:58'!nextOrNilSuchThat: aBlock	"Answer the next object that satisfies aBlock, skipping any intermediate objects.	If no object has been sent, answer <nil> and leave me intact.	NOTA BENE:  aBlock MUST NOT contain a non-local return (^)."	| value readPos |	accessProtect critical: [		value := nil.		readPos := readPosition.		[readPos < writePosition and: [value isNil]] whileTrue: [			value := contentsArray at: readPos.			readPos := readPos + 1.			(aBlock value: value) ifTrue: [				readPosition to: readPos - 1 do: [ :j |					contentsArray at: j put: nil.				].				readPosition := readPos.			] ifFalse: [				value := nil.			].		].		readPosition >= writePosition ifTrue: [readSynch initSignals].	].	^value"===q := SharedQueue new.1 to: 10 do: [ :i | q nextPut: i].c := OrderedCollection new.[	v := q nextOrNilSuchThat: [ :e | e odd].	v notNil] whileTrue: [	c add: {v. q size}].{c. q} explore==="! !!SharedQueue methodsFor: 'accessing'!nextPut: value 	"Send value through the receiver. If a Process has been suspended 	waiting to receive a value through the receiver, allow it to proceed."	accessProtect		critical: [writePosition > contentsArray size						ifTrue: [self makeRoomAtEnd].				 contentsArray at: writePosition put: value.				 writePosition := writePosition + 1].	readSynch signal.	^value! !!SharedQueue methodsFor: 'accessing' stamp: 'tpr 1/5/2005 18:22'!peek	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone but do not remove it from the receiver. If 	no object has been sent, return nil"	| value |	accessProtect		critical: [readPosition >= writePosition					ifTrue: [readPosition := 1.							writePosition := 1.							value := nil]					ifFalse: [value := contentsArray at: readPosition]].	^value! !!SharedQueue methodsFor: 'private' stamp: 'nice 4/4/2006 22:09'!initialize: size	contentsArray := Array new: size.	readPosition := 1.	writePosition := 1.	accessProtect := Semaphore forMutualExclusion.	readSynch := Semaphore new! !!SharedQueue methodsFor: 'private' stamp: 'bf 10/25/2005 15:33'!makeRoomAtEnd	| contentsSize |	readPosition = 1		ifTrue: [contentsArray := contentsArray , (Array new: 10)]		ifFalse: 			[contentsSize := writePosition - readPosition.			"BLT direction ok for this. Lots faster!!!!!!!!!!!! SqR!!!! 4/10/2000 10:47"			contentsArray				replaceFrom: 1				to: contentsSize				with: contentsArray				startingAt: readPosition.			"nil out remainder --bf 10/25/2005"			contentsArray				from: contentsSize+1				to: contentsArray size				put: nil.			readPosition := 1.			writePosition := contentsSize + 1]! !!SharedQueue2 methodsFor: 'accessing' stamp: 'ls 6/25/2005 14:16'!nextOrNilSuchThat: aBlock	"Answer the next object that satisfies aBlock, skipping any intermediate objects.	If no such object has been queued, answer <nil> and leave me intact."	| index |	^monitor critical: [		index := items findFirst: aBlock.		index = 0 ifTrue: [			nil ]		ifFalse: [			items removeAt: index ] ].! !!SharedQueue2 methodsFor: 'initializing' stamp: 'ls 6/25/2005 13:48'!initialize	monitor := Monitor new.	items := OrderedCollection new.! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:32'!setTarget: evt 	| rootMorphs |	rootMorphs := self world rootMorphsAt: evt hand targetPoint.	target := rootMorphs size > 1				ifTrue: [rootMorphs second]! !!SimplerTextContainer methodsFor: 'container protocol' stamp: 'RAA 7/30/2000 14:46'!rectanglesAt: lineY height: lineHeight	"Return a list of rectangles that are at least minWidth wide	in the specified horizontal strip of the shadowForm.	Cache the results for later retrieval if the owner does not change."	| rects |	lineY > textMorph owner bottom ifTrue: [^#()].	rects := Array with: (self left@lineY extent: textMorph width@lineHeight).	"rects := rects collect: [:r | r insetBy: OuterMargin@0]."	^ rects! !!SketchMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:32'!insertIntoMovie: evt	| movies aTarget |	movies _		(self world rootMorphsAt: evt hand targetPoint)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isSketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget _ movies first.	(aTarget isSketchMorph) ifTrue: [		aTarget _ aTarget replaceSelfWithMovie].	aTarget insertFrames: (Array with: self).	self delete.! !!SketchMorph methodsFor: '*eToys-e-toy support' stamp: 'nk 6/12/2004 10:04'!acquirePlayerSimilarTo: aSketchMorphsPlayer	"Retrofit into the receiver a player derived from the existing scripted player of a different morph.  Works only between SketchMorphs. Maddeningly complicated by potential for transformations or native sketch-morph scaling in donor or receiver or both"	| myName myTop itsTop newTop newSketch |	myTop := self topRendererOrSelf.	aSketchMorphsPlayer belongsToUniClass ifFalse: [^ Beeper beep].	itsTop := aSketchMorphsPlayer costume.	(itsTop renderedMorph isSketchMorph)		ifFalse:	[^ Beeper beep].	newTop := itsTop veryDeepCopy.  "May be a sketch or a tranformation"	myName := myTop externalName.  "Snag before the replacement is added to the world, because otherwise that could affect this"	newSketch := newTop renderedMorph.	newSketch form: self form.	newSketch scalePoint: self scalePoint.	newSketch bounds: self bounds.	myTop owner addMorph: newTop after: myTop.	newTop heading ~= myTop heading ifTrue:		"avoids annoying round-off error in what follows"			[newTop player setHeading: myTop heading]. 	(newTop isFlexMorph and: [myTop == self])		ifTrue:			[newTop removeFlexShell].	newTop := newSketch topRendererOrSelf.	newTop bounds: self bounds.	(newTop isFlexMorph and:[myTop isFlexMorph]) ifTrue:[		"Note: This completely dumps the above #bounds: information.		We need to recompute the bounds based on the transform."		newTop transform: myTop transform copy.		newTop computeBounds].	newTop setNameTo: myName.	newTop player class bringScriptsUpToDate.	myTop delete! !!SketchMorph class methodsFor: '*eToys-instance creation' stamp: 'sw 6/13/2001 22:50'!exampleBackgroundSketch	"Answer an instance suitable for serving as a prototype for a background-field incarnation of a sketch"	| aSketch |	aSketch := self newSticky form: (ScriptingSystem formAtKey: #squeakyMouse).	aSketch setProperty: #shared toValue: true.	aSketch setProperty: #holdsSeparateDataForEachInstance toValue: true.	^ aSketch! !!SkipList methodsFor: 'accessing' stamp: 'sac 1/22/2002 18:18'!at: element ifAbsent: aBlock        "Get the key if it exists, or if it doesn't exist, get the key just after it."        | node forward |        node := self.        level to: 1 by: -1 do: [:i |                        [forward := node forward: i.                        self is: forward before: element] whileTrue: [node := forward]].        node := node next.        (self is: node theNodeFor: element) ifFalse: [^aBlock value].        ^node value! !!SkipList methodsFor: 'accessing' stamp: 'LC 6/18/2001 20:18'!maxLevel: n	| newLevel oldPointers |	newLevel := n max: level.	oldPointers := pointers.	pointers := Array new: newLevel.	splice := Array new: newLevel.	1 to: level do: [:i | pointers at: i put: (oldPointers at: i)]! !!SkipList methodsFor: 'accessing' stamp: 'sac 1/22/2002 18:33'!search: element         "Get the key if it exists, or if it doesn't exist, get the key just after it. If no key after it, return nil."        | node forward |        node := self.        level to: 1 by: -1 do: [:i |                        [forward := node forward: i.                        self is: forward before: element] whileTrue: [node := forward]].        node := node next.        ^node! !!SkipList methodsFor: 'accessing' stamp: 'LC 6/18/2001 17:30'!sortBlock: aBlock	sortBlock := aBlock! !!SkipList methodsFor: 'adding' stamp: 'sac 1/22/2002 18:23'!at: key put: value ifPresent: aBlock        | node lvl s |        node := self search: key updating: splice.        node ifNotNil: [^ aBlock value].        lvl := self randomLevel.        node := SkipListNode key: key value: value level: lvl.        level + 1 to: lvl do: [:i | splice at: i put: self].        1 to: lvl do: [:i |                                s := splice at: i.                                node atForward: i put: (s forward: i).                                s atForward: i put: node].        numElements := numElements + 1.        splice atAllPut: nil.        ^ node! !!SkipList methodsFor: 'initialization' stamp: 'LC 6/18/2001 20:08'!initialize: maxLevel	pointers := Array new: maxLevel.	splice := Array new: maxLevel.	numElements := 0.	level := 0.	Rand ifNil: [Rand := Random new]! !!SkipList methodsFor: 'node enumeration' stamp: 'LC 6/18/2001 19:30'!nodesDo: aBlock	| node |	node := pointers first.	[node notNil]		whileTrue:			[aBlock value: node.			node := node next]! !!SkipList methodsFor: 'removing' stamp: 'sac 1/22/2002 16:58'!remove: key ifAbsent: aBlock        | node i s |        "Remove and return th association containing key."        node := self search: key updating: splice.        node ifNil: [^ aBlock value].        i := 1.        [s := splice at: i.        i <= level and: [(s forward: i) == node]]                                whileTrue:                                        [s atForward: i put: (node forward: i).                                        i := i + 1].        numElements := numElements - 1.        splice atAllPut: nil.        ^ node.! !!SkipList methodsFor: 'removing' stamp: 'LC 6/18/2001 20:25'!removeAll	pointers atAllPut: nil.	splice atAllPut: nil.	numElements := 0.	level := 0.! !!SkipList methodsFor: 'private' stamp: 'LC 6/18/2001 19:26'!atForward: i put: node	level := node		ifNil: [pointers findLast: [:n | n notNil]]		ifNotNil: [level max: i].	^ pointers at: i put: node! !!SkipList methodsFor: 'private' stamp: 'sac 1/22/2002 17:50'!is: node before: element         | key |        node ifNil: [^ false].        key := node key.        ^ sortBlock                ifNil: [key < element]                ifNotNil: [(self is: key equalTo: element) ifTrue: [^ false].                        sortBlock value: key value: element]! !!SkipList methodsFor: 'private' stamp: 'LC 6/18/2001 15:37'!randomLevel	| p answer max |	p := 0.5.	answer := 1.	max := self maxLevel.	[Rand next < p and: [answer < max]]		whileTrue: [answer := answer + 1].	^ answer! !!SkipList methodsFor: 'private' stamp: 'sac 1/22/2002 18:01'!search: element updating: array        | node forward |        node := self.        level to: 1 by: -1 do: [:i |                        [forward := node forward: i.                        self is: forward before: element] whileTrue: [node := forward].                        "At this point: node < element <= forward"                        array ifNotNil: [array at: i put: node]].        node := node next.        ^ (self is: node theNodeFor: element) ifTrue: [node]! !!SkipList class methodsFor: 'instance creation' stamp: 'LC 6/18/2001 18:48'!newFrom: aCollection 	| skipList |	skipList := self new: aCollection size.	skipList addAll: aCollection.	^ skipList! !!SkipListNode methodsFor: 'accessing' stamp: 'sac 1/22/2002 17:22'!printOn: aStream        | first |        aStream                nextPut: $[.        super printOn: aStream.        aStream                nextPutAll: ']-->('.        first := true.        pointers do: [:node |                first ifTrue: [first := false] ifFalse: [aStream space].                node ifNil: [aStream nextPutAll: '*']                 ifNotNil: [node printOn: aStream]].        aStream nextPut: $)! !!SkipListNode methodsFor: 'initialization' stamp: 'LC 6/17/2001 11:54'!initialize: maxLevel	pointers := Array new: maxLevel! !!SlotInformation methodsFor: 'access' stamp: 'yo 8/1/2004 02:05'!documentation	"Answer the receiver's documentation"	documentation ifNil: [documentation := 'This is a variable defined by you.  Please edit this into your own meaningful documentation.' translated].	^ documentation! !!SlotInformation methodsFor: 'access' stamp: 'sw 11/6/1998 10:33'!documentation: d	documentation := d! !!SlotInformation methodsFor: 'access' stamp: 'sw 7/27/2001 18:19'!floatPrecision	"Answer the floatPrecision for the slot:		1.0 ->	show whole number		0.1	->	show one digit of precision		.01 ->	show two digits of precision		etc.	Initialize the precision to 1 if it is not present"	^ floatPrecision isNumber ifTrue: [floatPrecision] ifFalse: [floatPrecision := 1]! !!SlotInformation methodsFor: 'access' stamp: 'sw 9/8/1999 18:31'!floatPrecision: prec	floatPrecision := prec! !!SlotInformation methodsFor: 'access' stamp: 'sw 4/22/2002 15:10'!type	"Answer the type of the receiver, initializing it to Number if it is nil"	type isEmptyOrNil ifTrue: [^ type := #Number].	type first isUppercase ifFalse: [^ type := type capitalized].		"because of lingering, annoying issue of projects created in a plug-in image"	^ type! !!SlotInformation methodsFor: 'access' stamp: 'sw 11/6/1998 10:31'!type: aType	type := aType! !!SlotInformation methodsFor: 'access' stamp: 'sw 10/30/2000 10:16'!variableDock: vd	"Set the receiver's variableDock as indicated"	variableDock := vd! !!SlotInformation methodsFor: 'initialization' stamp: 'sw 9/27/2001 17:44'!initialize	"Initialize the receiver's instance variables to default values"	documentation := 'as yet undocumented'.	type := #Number.	floatPrecision := 0.1.! !!SmallInteger methodsFor: 'printing' stamp: 'gk 5/25/2007 15:10'!decimalDigitLength	"Answer the number of digits printed out in base 10.	Note that this only works for positive SmallIntegers."		^ self < 10000		ifTrue: [self < 100				ifTrue: [self < 10						ifTrue: [1]						ifFalse: [2]]				ifFalse: [self < 1000						ifTrue: [3]						ifFalse: [4]]]		ifFalse: [self < 1000000				ifTrue: [self < 100000						ifTrue: [5]						ifFalse: [6]]				ifFalse: [self < 100000000						ifTrue: [self < 10000000								ifTrue: [7]								ifFalse: [8]]						ifFalse: [self < 1000000000								ifTrue: [9]								ifFalse: [10]]]]! !!SmallInteger methodsFor: 'printing' stamp: 'gk 5/25/2007 15:08'!printString	"Highly optimized version for base 10	and that we know it is a SmallInteger."		| integer next result len |	self = 0 ifTrue: [^'0'].	self < 0 ifTrue: [^'-', self negated printString].	len := self decimalDigitLength.	result := String new: len.	integer := self.	len to: 1 by: -1 do: [:i |		next := integer // 10.		result byteAt: i put: 48 + (integer - (next * 10)).		integer := next].	^result! !!SmallIntegerTest methodsFor: 'testing - printing' stamp: 'gk 5/25/2007 15:35'!testPrintStringself assert: 1 printString  = '1'.self assert: -1 printString  = '-1'.self assert: SmallInteger minVal printString  = '-1073741824'.self assert: SmallInteger maxVal printString  = '1073741823'.self assert: 12345 printString  = '12345'.self assert: -54321 printString  = '-54321'.self assert: 0 decimalDigitLength = 1.self assert: 4 decimalDigitLength = 1.self assert: 12 decimalDigitLength = 2.self assert: 123 decimalDigitLength = 3.self assert: 1234 decimalDigitLength = 4.self assert: 56789 decimalDigitLength = 5.self assert: 657483 decimalDigitLength = 6.self assert: 6571483 decimalDigitLength = 7.self assert: 65174383 decimalDigitLength = 8.self assert: 625744831 decimalDigitLength = 9.self assert: 1000001111 decimalDigitLength = 10.self assert: SmallInteger maxVal decimalDigitLength = 10.! !!SortedCollection methodsFor: 'converting' stamp: 'nice 2/26/2008 22:48'!reverseInPlace	"Change this colleciton into its reversed.	Do not make a copy like reversed do, but change self in place."		| newFirstIndex oldSortBlock |	newFirstIndex := 1 + array size - lastIndex.	lastIndex := 1 + array size - firstIndex.	firstIndex := newFirstIndex.	array := array reversed.	oldSortBlock := (sortBlock ifNil: [[:a :b | a <= b]]) copy.	sortBlock := [:a :b | oldSortBlock value: b value: a] fixTemps! !!SortedCollection methodsFor: 'converting' stamp: 'nice 2/26/2008 22:28'!reversed	"Answer a collection that Sort elements in reverse order"		^self shallowCopy reverseInPlace! !!SortedCollection methodsFor: 'copying'!copy	| newCollection |	newCollection := self species sortBlock: sortBlock.	newCollection addAll: self.	^newCollection! !!SortedCollection methodsFor: 'enumerating' stamp: 'sma 2/5/2000 15:22'!collect: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect the 	resulting values into an OrderedCollection. Answer the new collection. 	Override the superclass in order to produce an OrderedCollection instead	of a SortedCollection."	| newCollection | 	newCollection := OrderedCollection new: self size.	self do: [:each | newCollection addLast: (aBlock value: each)].	^ newCollection! !!SortedCollection methodsFor: 'topological sort' stamp: 'hg 1/2/2002 13:34'!sortTopologically	"Plenty of room for increased efficiency in this one."	| remaining result pick |	remaining := self asOrderedCollection.	result := OrderedCollection new.	[remaining isEmpty] whileFalse: [		pick := remaining select: [:item |			remaining allSatisfy: [:anotherItem |				item == anotherItem or: [self should: item precede: anotherItem]]].		pick isEmpty ifTrue: [self error: 'bad topological ordering'].		result addAll: pick.		remaining removeAll: pick].	^self copySameFrom: result! !!SortedCollection methodsFor: 'private' stamp: 'stp 04/23/1999 05:36'!indexForInserting: newObject	| index low high |	low := firstIndex.	high := lastIndex.	sortBlock isNil		ifTrue: [[index := high + low // 2.  low > high]			whileFalse: 				[((array at: index) <= newObject)					ifTrue: [low := index + 1]					ifFalse: [high := index - 1]]]		ifFalse: [[index := high + low // 2.  low > high]			whileFalse: 				[(sortBlock value: (array at: index) value: newObject)					ifTrue: [low := index + 1]					ifFalse: [high := index - 1]]].	^low! !!SortedCollection methodsFor: 'private' stamp: 'hg 12/17/2001 20:22'!sort: i to: j 	"Sort elements i through j of self to be nondescending according to	sortBlock."	| di dij dj tt ij k l n |	"The prefix d means the data at that index."	(n := j + 1  - i) <= 1 ifTrue: [^self].	"Nothing to sort." 	 "Sort di,dj."	di := array at: i.	dj := array at: j.	(self should: di precede: dj)		ifFalse: 			[array swap: i with: j.			 tt := di.			 di := dj.			 dj := tt].	n > 2		ifTrue:  "More than two elements."			[ij := (i + j) // 2.  "ij is the midpoint of i and j."			 dij := array at: ij.  "Sort di,dij,dj.  Make dij be their median."			 (self should: di precede: dij)			   ifTrue: 				[(self should: dij precede: dj)				  ifFalse: 					[array swap: j with: ij.					 dij := dj]]			   ifFalse:				[array swap: i with: ij.				 dij := di].			n > 3			  ifTrue:  "More than three elements."				["Find k>i and l<j such that dk,dij,dl are in reverse order.				Swap k and l.  Repeat this procedure until k and l pass each other."				 k := i.				 l := j.				 [[l := l - 1.  k <= l and: [self should: dij precede: (array at: l)]]				   whileTrue.  "i.e. while dl succeeds dij"				  [k := k + 1.  k <= l and: [self should: (array at: k) precede: dij]]				   whileTrue.  "i.e. while dij succeeds dk"				  k <= l]				   whileTrue:					[array swap: k with: l]. 	"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk	through dj.  Sort those two segments."				self sort: i to: l.				self sort: k to: j]]! !!SortedCollectionTest methodsFor: 'basic' stamp: 'nice 2/26/2008 22:52'!testReversed		| sc1 sc2 sc3 |	sc1 := #(1 2 3 4) asSortedCollection.	self assert: sc1 reversed asArray = sc1 asArray reversed.		self		assert: sc1 reversed class = SortedCollection		description: 'reversing a SortedCollection should answer a SortedCollection'.		sc1 removeFirst; removeLast.	sc2 := sc1 reversed.	self assert: sc2 reversed asArray = sc1 asArray.		sc2 add: 3/2; add: 1/2; add: 7/2.	self assert: sc2 asArray = {7/2. 3. 2. 3/2. 1/2}.			sc3 := #(1 2 3 3.0 4) asSortedCollection.	self assert: sc3 reversed asArray = #(4 3.0 3 2 1).	self assert: (sc3 reversed at: 2) class = Float.	! !!SoundReadoutTile methodsFor: 'arrows' stamp: 'sw 1/28/2005 00:57'!arrowAction: delta	"Do what is appropriate when an arrow on the tile is pressed; delta will be +1 or -1"	| soundChoices index |	soundChoices := self soundChoices.	index := soundChoices indexOf: literal.	self literal: (soundChoices atWrap: (index + delta)).	self playSoundNamed: literal! !!SoundReadoutTile methodsFor: 'arrows' stamp: 'sw 1/28/2005 00:56'!mouseDown: evt	"Handle a mouse down event"	| aPoint index isUp soundChoices adjustment |	upArrow ifNotNil: [((isUp := upArrow containsPoint: (aPoint := evt cursorPoint)) or:  [downArrow containsPoint: aPoint])		ifTrue:			[soundChoices := self soundChoices.			index := soundChoices indexOf: literal ifAbsent: [1].			index > 0 ifTrue:				[adjustment := isUp ifTrue: [1] ifFalse: [-1].				self literal: (soundChoices atWrap: (index + adjustment))].			self playSoundNamed: literal.			^ self]].	self soundNameFromUser ifNotNilDo:		[:aSoundName |			self literal: aSoundName.			self playSoundNamed: literal]! !!SoundReadoutTile methodsFor: 'arrows' stamp: 'yo 2/11/2005 16:08'!soundNameFromUser	"Obtain a sound from the user.  Exclude the items designated as being discouraged, except that if the current selection is one of those, show it anyway"	| choices |	choices := self soundChoices.	^ (SelectionMenu labels: (choices collect: [:t | t translated]) selections: self soundChoices) startUpWithCaption: 'Sounds' translated! !!SoundReadoutTile methodsFor: 'literal' stamp: 'sw 1/28/2005 00:57'!setLiteralTo: anObject width: w	"Set the literal and width of the tile as indicated"	| soundChoices index |	soundChoices := self soundChoices.	index := soundChoices indexOf: anObject.	self setLiteral: (soundChoices atWrap: index)! !!SoundTile methodsFor: 'event handling' stamp: 'sw 1/28/2005 01:49'!options	"Answer the options of the tile for an arrow"	| soundChoices |	soundChoices := self soundChoices.	^ {soundChoices. soundChoices}! !!SoundTile methodsFor: 'initialization' stamp: 'yo 7/22/2005 15:51'!initialize	"Initialize the state of the receiver. Pick the croak sound	if available, otherwise any sound."		| soundChoices startingSoundName |	super initialize.	soundChoices := self soundChoices.	startingSoundName := (soundChoices includes: 'croak')							ifTrue: ['croak']							ifFalse: [[soundChoices anyOne] ifError: ['silence']].	self addArrows; setLiteral: startingSoundName.	self labelMorph useSymbolFormat! !!SparseLargeTable methodsFor: 'accessing' stamp: 'tak 12/21/2004 16:59'!noCheckAt: index	| chunkIndex t |	chunkIndex := index - base // chunkSize + 1.	(chunkIndex > self basicSize or: [chunkIndex < 1]) ifTrue: [^ defaultValue].	t := self basicAt: chunkIndex.	t ifNil: [^ defaultValue].	^ t at: (index - base + 1 - (chunkIndex - 1 * chunkSize))! !!SparseLargeTable methodsFor: 'accessing' stamp: 'yo 12/1/2003 19:18'!noCheckAt: index put: value	| chunkIndex t |	chunkIndex := index - base // chunkSize + 1.	chunkIndex > self basicSize ifTrue: [^ value].	t :=  self basicAt: chunkIndex.	t ifNil: [^ value].	^ t at: (index - base + 1 - (chunkIndex - 1 * chunkSize)) put: value! !!SparseLargeTable methodsFor: 'accessing' stamp: 'kwl 6/30/2006 03:02'!zapDefaultOnlyEntries	| lastIndex newInst |	1 to: self basicSize do: [:i |		(self allDefaultValueSubtableAt: i) ifTrue: [self basicAt: i put: nil].	].	lastIndex _ self findLastNonNilSubTable.	lastIndex = 0 ifTrue: [^ self].		newInst _ self class new: lastIndex*chunkSize chunkSize: chunkSize arrayClass: (self basicAt: lastIndex) class base: base defaultValue: defaultValue.	newInst privateSize: self size.	base to: newInst size do: [:i | newInst at: i put: (self at: i)].	1 to: newInst basicSize do: [:i |		(newInst allDefaultValueSubtableAt: i) ifTrue: [newInst basicAt: i put: nil].	].	" this is not allowed in production: self becomeForward: newInst. "	^ newInst.! !!SparseLargeTable methodsFor: 'initialization' stamp: 'yo 12/1/2003 16:58'!initChunkSize: aChunkSize size: aSize arrayClass: aClass base: b defaultValue: d	| lastChunkSize |	chunkSize := aChunkSize.	size := aSize.	base := b.	defaultValue := d.	1 to: (self basicSize - 1) do: [ :in | self basicAt: in put: (aClass new: chunkSize withAll: defaultValue) ].	lastChunkSize := size \\ chunkSize.	lastChunkSize = 0 ifTrue: [lastChunkSize := chunkSize].	size = 0 		ifTrue: [self basicAt: 1 put: (aClass new: 0)]		ifFalse: [self basicAt: self basicSize put: (aClass new: lastChunkSize withAll: defaultValue)].! !!SparseLargeTable methodsFor: 'printing' stamp: 'yo 12/1/2003 17:06'!printElementsOn: aStream	| element |	aStream nextPut: $(.	base to: size do: [:index | element := self at: index. aStream print: element; space].	self isEmpty ifFalse: [aStream skip: -1].	aStream nextPut: $)! !!SparseLargeTable methodsFor: 'printing' stamp: 'yo 12/1/2003 15:59'!storeOn: aStream	| x |	(#(String) includes: self arrayClass name) ifTrue: 		[aStream nextPut: $'.		1 to: self size do:			[:i |			aStream nextPut: (x := self at: i).			x == $' ifTrue: [aStream nextPut: x]].		aStream nextPutAll: ''' asLargeArrayChunkSize: '.		aStream nextPutAll: self chunkSize asString.		^self].	^super storeOn: aStream! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 18:58'!allDefaultValueSubtableAt: index	| t |	t := self basicAt: index.	t ifNil: [^ true].	t do: [:e |		e ~= defaultValue ifTrue: [^ false].	].	^ true.! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 17:10'!analyzeSpaceSaving	| total elems tablesTotal nonNilTables |	total := size - base + 1.	elems := 0.	base to: size do: [:i | (self at: i) ~= defaultValue ifTrue: [elems := elems + 1]].	tablesTotal := self basicSize.	nonNilTables := 0.	1 to: self basicSize do: [:i | (self basicAt: i) ifNotNil: [nonNilTables := nonNilTables + 1]].	^ String streamContents: [:strm |		strm nextPutAll: 'total: '.		strm nextPutAll: total printString.		strm nextPutAll: ' elements: '.		strm nextPutAll: elems printString.		strm nextPutAll: ' tables: '.		strm nextPutAll: tablesTotal printString.		strm nextPutAll: ' non-nil: '.		strm nextPutAll: nonNilTables printString.	].! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 19:19'!privateSize: s	size := s.! !!Spline methodsFor: 'displaying'!computeCurve	"Compute an array for the coefficients."	| length extras |	length := self size.	extras := 0.	coefficients := Array new: 8.	1 to: 8 do: [:i | coefficients at: i put: (Array new: length + extras)].	1 to: 5 by: 4 do: 		[:k | 		1 to: length do:			[:i | (coefficients at: k)					at: i put: (k = 1						ifTrue: [(self at: i) x asFloat]						ifFalse: [(self at: i) y asFloat])].			1 to: extras do: [:i | (coefficients at: k)					at: length + i put: ((coefficients at: k)						at: i + 1)].			self derivs: (coefficients at: k)				first: (coefficients at: k + 1)				second: (coefficients at: k + 2)				third: (coefficients at: k + 3)].	extras > 0 		ifTrue: [1 to: 8 do: 					[:i | 					coefficients at: i put: ((coefficients at: i)											copyFrom: 2 to: length + 1)]]! !!Spline methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm 	"Display the receiver, a spline curve, approximated by straight line	segments."	| n line t x y x1 x2 x3 y1 y2 y3 |	collectionOfPoints size < 1 ifTrue: [self error: 'a spline must have at least one point'].	line := Line new.	line form: self form.	line beginPoint: 		(x := (coefficients at: 1) at: 1) rounded @ (y := (coefficients at: 5) at: 1) rounded.	1 to: (coefficients at: 1) size - 1 do: 		[:i | 		"taylor series coefficients"		x1 := (coefficients at: 2) at: i.		y1 := (coefficients at: 6) at: i.		x2 := ((coefficients at: 3) at: i) / 2.0.		y2 := ((coefficients at: 7) at: i) / 2.0.		x3 := ((coefficients at: 4) at: i) / 6.0.		y3 := ((coefficients at: 8) at: i) / 6.0.		"guess n"		n := 5 max: (x2 abs + y2 abs * 2.0 + ((coefficients at: 3)							at: i + 1) abs + ((coefficients at: 7)							at: i + 1) abs / 100.0) rounded.		1 to: n - 1 do: 			[:j | 			t := j asFloat / n.			line endPoint: 				(x3 * t + x2 * t + x1 * t + x) rounded 							@ (y3 * t + y2 * t + y1 * t + y) rounded.			line				displayOn: aDisplayMedium				at: aPoint				clippingBox: clipRect				rule: anInteger				fillColor: aForm.			line beginPoint: line endPoint].		line beginPoint: 				(x := (coefficients at: 1) at: i + 1) rounded 					@ (y := (coefficients at: 5) at: i + 1) rounded.		line			displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!Spline methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm 	"Get the scaled and translated path of newKnots."	| newKnots newSpline |	newKnots := aTransformation applyTo: self.	newSpline := Spline new.	newKnots do: [:knot | newSpline add: knot].	newSpline form: self form.	newSpline		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Spline methodsFor: 'private'!derivs: a first: point1 second: point2 third: point3	"Compute the first, second and third derivitives (in coefficients) from	the Points in this Path (coefficients at: 1 and coefficients at: 5)."	| l v anArray |	l := a size.	l < 2 ifTrue: [^self].	l > 2	  ifTrue:		[v := Array new: l.		 v  at:  1 put: 4.0.		 anArray := Array new: l.		 anArray  at:  1 put: (6.0 * ((a  at:  1) - ((a  at:  2) * 2.0) + (a  at:  3))).		 2 to: l - 2 do:			[:i | 			v  at:  i put: (4.0 - (1.0 / (v  at:  (i - 1)))).			anArray				at:  i 				put: (6.0 * ((a  at:  i) - ((a  at:  (i + 1)) * 2.0) + (a  at:  (i + 2)))						- ((anArray  at:  (i - 1)) / (v  at:  (i - 1))))].		 point2  at: (l - 1) put: ((anArray  at:  (l - 2)) / (v  at:  (l - 2))).		 l - 2 to: 2 by: 0-1 do: 			[:i | 			point2 				at: i 				put: ((anArray  at:  (i - 1)) - (point2  at:  (i + 1)) / (v  at:  (i - 1)))]].	point2 at: 1 put: (point2  at:  l put: 0.0).	1 to: l - 1 do:		[:i | point1 				at: i 				put: ((a at: (i + 1)) - (a  at:  i) - 						((point2  at:  i) * 2.0 + (point2  at:  (i + 1)) / 6.0)).		      point3 at: i put: ((point2  at:  (i + 1)) - (point2  at:  i))]! !!Spline class methodsFor: 'examples' stamp: '6/8/97 13:55 di'!example	"Designate points on the Path by clicking the red button. Terminate by	pressing any other button. A curve will be displayed, through the	selected points, using a long black form."	| splineCurve aForm flag|	aForm := Form extent: 2@2.	aForm  fillBlack.	splineCurve := Spline new.	splineCurve form: aForm.	flag := true.	[flag] whileTrue:		[Sensor waitButton.		 Sensor redButtonPressed			ifTrue: 				[splineCurve add: Sensor waitButton. 				 Sensor waitNoButton.				 aForm displayOn: Display at: splineCurve last]			ifFalse: [flag:=false]].	splineCurve computeCurve.	splineCurve isEmpty 		ifFalse: [splineCurve displayOn: Display.				Sensor waitNoButton]. 	"Spline example"! !!SqNumberParser methodsFor: 'parsing-private' stamp: 'nice 3/10/2008 23:13'!makeFloatFromMantissa: m exponent: k base: aRadix 	"Convert infinite precision arithmetic into Floating point.	This alogrithm rely on correct IEEE rounding mode	being implemented in Integer>>asFloat and Fraction>>asFloat"	| p |	p := aRadix lowBit - 1.	^k positive		ifTrue: [(m * (((aRadix bitShift: p negated) raisedToInteger: k))) asFloat timesTwoPower: p*k]		ifFalse: [(Fraction numerator: m denominator: (((aRadix bitShift: p negated) raisedToInteger: k negated) bitShift: p*k negated)) asFloat]! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 3/10/2008 22:50'!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart numberOfNonZeroFractionDigits mantissa decimalMultiplier decimalFraction value numberOfTrailingZeroInFractionPart |	neg := sourceStream peekFor: $-.	integerPart := self nextUnsignedIntegerBase: base ifFail: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		neg ifFalse: [(sourceStream nextMatchAll: 'NaN')			ifTrue: [^ Float nan]].		(sourceStream nextMatchAll: 'Infinity')			ifTrue: [^ neg					ifTrue: [Float infinity negated]					ifFalse: [Float infinity]].		^self expected: ['a digit between 0 and 9']].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			(base := integerPart) < 2				ifTrue: [^ self expected: 'an integer greater than 1 as valid radix'].			(sourceStream peekFor: $-)				ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerBase: base.			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	^ (sourceStream peekFor: $.)		ifTrue: [fractionPart := self						nextUnsignedIntegerBase: base						ifFail: [sourceStream skip: -1.							^ neg								ifTrue: [integerPart negated]								ifFalse: [integerPart]].			numberOfNonZeroFractionDigits := lastNonZero.			numberOfTrailingZeroInFractionPart := nDigits - lastNonZero.			self readExponent				ifFalse: [self readScale						ifTrue: [decimalMultiplier := base raisedTo: numberOfNonZeroFractionDigits.							decimalFraction := integerPart * decimalMultiplier + fractionPart / decimalMultiplier.							neg								ifTrue: [decimalFraction := decimalFraction negated].							^ ScaledDecimal newFromNumber: decimalFraction scale: scale]].			fractionPart isZero				ifTrue: [mantissa := integerPart								// (base raisedTo: numberOfTrailingZeroInIntegerPart).					exponent := exponent + numberOfTrailingZeroInIntegerPart]				ifFalse: [mantissa := integerPart								* (base raisedTo: numberOfNonZeroFractionDigits) + (fractionPart // (base raisedTo: numberOfTrailingZeroInFractionPart)).					exponent := exponent - numberOfNonZeroFractionDigits].			"very naive algorithm"			value := self makeFloatFromMantissa: mantissa exponent: exponent base: base.			^ neg				ifTrue: [value isZero						ifTrue: [Float negativeZero]						ifFalse: [value negated]]				ifFalse: [value]]		ifFalse: [self makeIntegerOrScaledInteger]! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 3/10/2008 22:44'!nextUnsignedIntegerBase: aRadix 	"Form an unsigned integer with incoming digits from sourceStream.	Count the number of digits and the lastNonZero digit and store int in	instVar "		^ self		nextUnsignedIntegerBase: aRadix		ifFail: [self expected: ('a digit between 0 and ' copyWith: (Character digitValue: aRadix - 1))]! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 3/10/2008 22:27'!nextUnsignedIntegerBase: aRadix ifFail: errorBlock	"Form an unsigned integer with incoming digits from sourceStream.	Count the number of digits and the lastNonZero digit and store int in instVar"		| value digit |	value := 0.	nDigits := 0.	lastNonZero := 0.	aRadix <= 10		ifTrue: ["Avoid using digitValue which is awfully slow"			[sourceStream atEnd				or: [digit := sourceStream next charCode - 48.					(digit < 0							or: [digit >= aRadix])						and: [sourceStream skip: -1.							true]]]				whileFalse: [nDigits := nDigits + 1.					digit isZero						ifFalse: [lastNonZero := nDigits].					value := value * aRadix + digit]]		ifFalse: [			[sourceStream atEnd				or: [digit := sourceStream next digitValue.					(digit < 0							or: [digit >= aRadix])						and: [sourceStream skip: -1.							true]]]				whileFalse: [nDigits := nDigits + 1.					digit isZero						ifFalse: [lastNonZero := nDigits].					value := value * aRadix + digit]].	nDigits = 0		ifTrue: [errorBlock value].	^value! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'em 3/31/2005 10:56'!insertCardOfBackground	"Prompt the user for choice of a background, and insert a new card of that background"	| bgs aMenu aBackground |	(bgs := self backgrounds) size == 1 ifTrue:		[self inform: 'At this time, there IS only one kind ofbackground in this stack, so that''swhat you''ll get' translated.		^ self insertCard].	aMenu := SelectionMenu		labels: 		(bgs collect: [:bg | bg externalName])		selections: 	bgs.	(aBackground := aMenu startUp) ifNotNil:		[self insertCardOfBackground: aBackground]! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/18/2002 02:02'!insertCardOfBackground: aBackground	"Insert a new card of the given background and have it become the current card"	| newCard |	newCard :=  aBackground newCard.	self privateCards add: newCard after: self currentCard.	self goToCard: newCard! !!StackMorph methodsFor: 'background' stamp: 'nb 6/17/2003 12:25'!addCardsFromAFile	"Using the current background, create new cards by reading in data from a fileThe data are in each record are expected to be tab-delimited, and to occur in the same order as the instance variables of the current-background's cards "	| aFileStream |	(aFileStream := FileList2 modalFileSelector) ifNil: [^ Beeper beep].	self addCardsFromString: aFileStream contentsOfEntireFile.	aFileStream close! !!StackMorph methodsFor: 'background' stamp: 'nb 6/17/2003 12:25'!addCardsFromClipboardData	"Using the current background, paste data from the (textual) clipboard to create new records.  The data are in each record are expected to be tab-delimited, and to occur in the same order as the instance variables of the current-background's cards "	| clip |	(clip := Clipboard clipboardText) isEmptyOrNil ifTrue: [^ Beeper beep].	self addCardsFromString: clip! !!StackMorph methodsFor: 'background' stamp: 'nb 6/17/2003 12:25'!addCardsFromClipboardDataForInstanceVariables: slotNames	"Using the current background, paste data from the (textual) clipboard to create new records.  No senders, but can be usefully called manually for selectively bringing in data in oddball format."	| clip |	(clip := Clipboard clipboardText) isEmptyOrNil ifTrue: [^ Beeper beep].	self addCardsFromString: clip slotNames: slotNames! !!StackMorph methodsFor: 'background' stamp: 'nb 6/17/2003 12:25'!addCardsFromFile: fileStream	"Using the current background, take tab delimited data from the file to create new records."	| aString |	(aString := fileStream contentsOfEntireFile) isEmptyOrNil ifTrue: [^ Beeper beep].	self addCardsFromString: aString! !!StackMorph methodsFor: 'background' stamp: 'sw 11/2/2002 17:56'!changeInstVarOrder	"Change the order of the receiver's instance variables"	| reply |	reply := FillInTheBlank request: 'rearrange, then accept; or cancel' initialAnswer:		((self currentPage player class instVarNames asArray collect: [:v | v asSymbol]) storeString copyWithoutAll: #($# $( $))) asString.	reply isEmptyOrNil ifTrue: [^ self].	self flag: #deferred.  "Error checking and graceful escape wanted"	self currentPage player class resortInstanceVariables: (Compiler evaluate:		('#(', reply, ')'))! !!StackMorph methodsFor: 'background' stamp: 'em 3/30/2005 14:47'!insertAsBackground: newPage resize: doResize	"Make a new background for the stack.  Obtain a name for it from the user.  It starts out life empty"	| aName |	aName := FillInTheBlank request: 'What should we call this new background?' translated initialAnswer: 'alternateBackground' translated.	aName isEmptyOrNil ifTrue: [^ self].	newPage beSticky.	doResize ifTrue: [newPage extent: currentPage extent].	newPage beAStackBackground.	newPage setNameTo: aName.	newPage vResizeToFit: false.	pages isEmpty		ifTrue: [pages add: newPage]		ifFalse: [pages add: newPage after: currentPage].	self privateCards add: newPage currentDataInstance after: currentPage currentDataInstance.	self nextPage.! !!StackMorph methodsFor: 'background' stamp: 'tk 10/30/2001 19:01'!makeNewBackground	"Make a new background for the stack.  Obtain a name for it from the user.  It starts out life empty"	| newPage |	(newPage := PasteUpMorph newSticky) color: self color muchLighter.	newPage borderWidth: currentPage borderWidth; borderColor: currentPage borderColor.	self insertAsBackground: newPage resize: true. ! !!StackMorph methodsFor: 'background' stamp: 'sw 3/18/2002 02:14'!sortByField: varName	"Perform a simple reordering of my cards, sorting by the given field name.  If there are multiple backgrounds, then sort the current one, placing all its cards first, followed by all others in unchanged order"	| holdCards thisClassesInstances sortedList |	holdCards := self privateCards copy.	thisClassesInstances := self privateCards select: [:c | c isKindOf: self currentCard class].	sortedList := thisClassesInstances asSortedCollection:		[:a :b | (a instVarNamed: varName) asString <= (b instVarNamed: varName) asString].	sortedList := sortedList asOrderedCollection.	holdCards removeAllFoundIn: sortedList.	self privateCards:  (sortedList asOrderedCollection, holdCards).	self goToFirstCardOfStack! !!StackMorph methodsFor: 'background' stamp: 'sw 12/6/2001 22:08'!sortCards	"Let the user provide an inst var on which to sort the cards of a background."	| names aMenu |	names := self currentPage player class instVarNames.	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'Choose field by which to sort:'.	names do: [:n | aMenu add: n selector: #sortByField: argument: n].	aMenu popUpInWorld! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 16:24'!browseCardClass	"Browse the class of the current card"	| suffix |	suffix := self currentCard class name numericSuffix.	HierarchyBrowser newFor: self currentCard class labeled: 'Background ', suffix asString! !!StackMorph methodsFor: 'card access' stamp: 'sd 11/13/2003 21:03'!deleteCard	"Delete the current card from the stack"	| aCard |	aCard := self currentCard.	self privateCards size = 1 ifTrue: [^ Beeper beep].	(self confirm: 'Really delete this card and all of its data?' translated) ifTrue:		[self goToNextCardInStack.		self privateCards remove: aCard].! !!StackMorph methodsFor: 'card access' stamp: 'em 3/31/2005 10:23'!goToCard	"prompt the user for an ordinal number, and use that as a basis for choosing a new card to install in the receiver"	| reply index |	reply := FillInTheBlank request: 'Which card number? ' translated initialAnswer: '1'.	reply isEmptyOrNil ifTrue: [^ self].	((index := reply asNumber) > 0 and: [index <= self privateCards size])		ifFalse: [^ self inform: 'no such card'].	self goToCard: (self privateCards at: index)! !!StackMorph methodsFor: 'card access' stamp: 'sw 11/8/2002 15:15'!goToCard: destinationCard	"Install the indicated destinationCard as the current card in the receiver.  Any viewer currently open on the current card will get retargeted to look at the new one."	| aBackground existingCard oldViewers |	destinationCard == self currentCard ifTrue: [^ self].	self currentPlayerDo:		[:aPlayer | aPlayer runAllClosingScripts].   "Like HyperCard 'on closeCard'"	aBackground := self backgroundWithCard: destinationCard.	existingCard := aBackground currentDataInstance.	oldViewers := existingCard ifNil: [#()] ifNotNil: [existingCard allOpenViewers].	aBackground installAsCurrent: destinationCard.	aBackground setProperty: #myStack toValue: self.	"pointer cardMorph -> stack"	aBackground ~~ currentPage ifTrue:		[self goToPageMorph: aBackground runTransitionScripts: false].	self currentPlayerDo:		[:aPlayer | aPlayer runAllOpeningScripts] .  "Like HyperCard 'on opencard'"	oldViewers do: [:aViewer | aViewer retargetFrom: existingCard to: destinationCard]! !!StackMorph methodsFor: 'card access' stamp: 'nb 6/17/2003 12:25'!goToFirstCardInBackground	"Install the initial card in the current background as the current card in the stack"	| kind |	kind := currentPage player class baseUniclass.	self goToCard: (self privateCards detect: [:aCard | aCard isKindOf: kind] ifNone: [^ Beeper beep])! !!StackMorph methodsFor: 'card access' stamp: 'nb 6/17/2003 12:25'!goToLastCardInBackground	"Install the final card in the current background as the current card"	| kind |	kind := currentPage player class baseUniclass.	self goToCard: (self privateCards reversed detect: [:aCard | aCard isKindOf: kind] ifNone: [^ Beeper beep])! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:03'!insertCardOfBackground: aBackground withDataFrom: aLine forInstanceVariables: slotNames	"Insert a new card of the given background and have it become the current card. "	| newCard |	newCard :=  aBackground newCard.	self privateCards add: newCard after: self currentCard.	newCard absorbBackgroundDataFrom: aLine forInstanceVariables: slotNames.	self goToCard: newCard! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 01:57'!makeCurrentCardFirstInStack	"Move the current card such that it becomes the first card in the stack"	| aCard |	aCard := self currentCard.	self privateCards remove: aCard ifAbsent: [];		addFirst: aCard.	self currentPage flash! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:03'!makeCurrentCardLastInStack	"Move the current card such that it becomes the last card in the stack"	| aCard |	aCard := self currentCard.	self privateCards remove: aCard ifAbsent: [];		addLast: aCard.	self currentPage flash! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:08'!moveCardOnePositionEarlier	"Move the current card such that its ordinal position is one fewer than it formerly was.  If the current card is already the first one one in the stack, then do nothing"	| aCard aPosition |	aCard := self currentCard.	aCard == self privateCards first ifTrue: [^ self].	aPosition := self privateCards indexOf: aCard.	self privateCards remove: aCard;		add: aCard afterIndex: (aPosition - 2).	self currentPage flash! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:05'!moveCardOnePositionLater	"Move the current card such that its ordinal position is one greater than it formerly was.  If the current card is already the last one one in the stack, then do nothing"	| aCard aPosition privateCards |	aCard := self currentCard.	privateCards := self privateCards.	aCard == privateCards last ifTrue: [^ self].	aPosition := privateCards indexOf: aCard.	privateCards remove: aCard.	privateCards add: aCard afterIndex: aPosition.	self currentPage flash! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:51'!privateCards: aCollection	"Private - Make my cards be te given colllection"	cards := aCollection! !!StackMorph methodsFor: 'card in a stack' stamp: 'sw 3/18/2002 02:03'!goToNextCardInStack	"Make the card *after* the current card become the current card"	| anIndex newCard |	anIndex := self privateCards indexOf: currentPage currentDataInstance.	newCard := self privateCards atWrap: anIndex + 1.	self goToCard: newCard! !!StackMorph methodsFor: 'card in a stack' stamp: 'sw 3/18/2002 02:01'!goToPreviousCardInStack	"Install the previous card as my current one"	| anIndex newCard |	anIndex := self privateCards indexOf: currentPage currentDataInstance.	newCard := self privateCards atWrap: anIndex - 1.	self goToCard: newCard! !!StackMorph methodsFor: 'controls' stamp: 'sw 10/30/2000 16:31'!pageControlsMorphFrom: controlSpecs	"Answer a controls morph derived from the spec supplied"	| controls |	controls := super pageControlsMorphFrom: controlSpecs.	controls eventHandler: nil.  "not grabbable"	^ controls! !!StackMorph methodsFor: 'initialization' stamp: 'sw 6/5/2003 04:04'!addPane: aPane paneType: aType	| anIndex |	anIndex := self insertionIndexForPaneOfType: aType.	self privateAddMorph: aPane atIndex: anIndex! !!StackMorph methodsFor: 'initialization' stamp: 'sw 3/18/2002 02:12'!initialize	"Initialize the stack"	| initialBackground |	super initialize.	initialBackground := pages first.	initialBackground extent: (640@480); beSticky.	initialBackground beAStackBackground.	self beUnsticky.	self setProperty: #controlsAtBottom toValue: true.	self privateCards: (OrderedCollection with: initialBackground currentDataInstance)."self currentHand attachMorph: StackMorph authoringPrototype"! !!StackMorph methodsFor: 'initialization' stamp: 'sw 3/18/2002 02:13'!initializeWith: aCardMorph	"Install the card inside a new stack.  Make no border or controls, so I the card's look is unchanged.  Card already has a CardPlayer."		| wld |	wld := aCardMorph world.	self initialize.	self pageSize: aCardMorph extent.	self borderWidth: 0; layoutInset: 0; color: Color transparent.	pages := Array with: aCardMorph.	currentPage := aCardMorph.	self privateCards: (OrderedCollection with: currentPage currentDataInstance).	currentPage beAStackBackground.	self position: aCardMorph position.	submorphs last delete.	self addMorph: currentPage.		self showPageControls: self fullControlSpecs.	wld addMorph: self.! !!StackMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 21:14'!addBookMenuItemsTo: aMenu hand: aHandMorph	"Add book-related items to the given menu"	| controlsShowing subMenu |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'previous card' translated action: #goToPreviousCardInStack.	subMenu add: 'next card' translated action: #goToNextCardInStack.	subMenu add: 'go to card...' translated action: #goToCard.	subMenu add: 'insert a card' translated action: #insertCard.	subMenu add: 'delete this card' translated action: #deleteCard.	controlsShowing := self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue:			[subMenu add: 'hide card controls' translated action: #hidePageControls.			subMenu add: 'fewer card controls' translated action: #fewerPageControls]		ifFalse:			[subMenu add: 'show card controls' translated action: #showPageControls].	subMenu addLine.	subMenu add: 'sound effect for all backgrounds' translated action: #menuPageSoundForAll:.	subMenu add: 'sound effect this background only' translated action: #menuPageSoundForThisPage:.	subMenu add: 'visual effect for all backgrounds' translated action: #menuPageVisualForAll:.	subMenu add: 'visual effect this background only' translated action: #menuPageVisualForThisPage:.	subMenu addLine.	subMenu add: 'sort pages' translated action: #sortPages:.	subMenu add: 'uncache page sorter' translated action: #uncachePageSorter.	(self hasProperty: #dontWrapAtEnd)		ifTrue: [subMenu add: 'wrap after last page' translated selector: #setWrapPages: argument: true]		ifFalse: [subMenu add: 'stop at last page' translated selector: #setWrapPages: argument: false].	subMenu  addUpdating: #showingFullScreenString action: #toggleFullScreen.	subMenu addLine.	subMenu add: 'search for text' translated action: #textSearch.	(self primaryHand pasteBuffer class isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page' translated action: #pasteBookPage].	subMenu add: 'send all pages to server' translated action: #savePagesOnURL.	subMenu add: 'send this page to server' translated action: #saveOneOnURL.	subMenu add: 'reload all from server' translated action: #reload.	subMenu add: 'copy page url to clipboard' translated action: #copyUrl.	subMenu add: 'keep in one file' translated action: #keepTogether.	subMenu add: 'save as new-page prototype' translated action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' translated action: #clearNewPagePrototype].	aMenu add: 'book...' translated subMenu: subMenu! !!StackMorph methodsFor: 'menu' stamp: 'sw 3/18/2002 02:06'!findText: wants	"Turn to the next card that has all of the strings mentioned on it.  Highlight where it is found.  allText and allTextUrls have been set.  Case insensitive search.	Resuming a search.  If container's text is still in the list and secondary keys are still in the page, (1) search rest of that container.  (2) search rest of containers on that page (3) pages till end of book, (4) from page 1 to this page again."	"Later sort wants so longest key is first"	| allText good thisWord here fromHereOn startToHere oldContainer oldIndex otherKeys strings |	allText := self valueOfProperty: #allText ifAbsent: [#()].	here := self privateCards identityIndexOf: self currentCard ifAbsent: [1].	fromHereOn := here+1 to: self privateCards size.	startToHere := 1 to: here.		"repeat this page"	(self valueOfProperty: #searchKey ifAbsent: [#()]) = wants ifTrue: [		"does page have all the other keys?  No highlight if found!!"		otherKeys := wants allButFirst.		strings := allText at: here.		good := true.		otherKeys do: [:searchString | "each key"			good ifTrue: [thisWord := false.				strings do: [:longString |					(longString findWordStart: searchString startingAt: 1) > 0 ifTrue: [							thisWord := true]].				good := thisWord]].		good ifTrue: ["all are on this page.  Look in rest for string again."			oldContainer := self valueOfProperty: #searchContainer.			oldIndex := self valueOfProperty: #searchOffset.			(self findText: (OrderedCollection with: wants first) inStrings: strings					startAt: oldIndex+1 container: oldContainer 				cardNum: here) ifTrue: [					self setProperty: #searchKey toValue: wants.					^ true]]]		ifFalse: [fromHereOn := here to: self privateCards size].	"do search this page"	"other pages"	fromHereOn do: [:cardNum |		(self findText: wants inStrings: (allText at: cardNum) startAt: 1 container: nil 				cardNum: cardNum) 					ifTrue: [^ true]].	startToHere do: [:cardNum |		(self findText: wants inStrings: (allText at: cardNum) startAt: 1 container: nil 				cardNum: cardNum) 					ifTrue: [^ true]].	"if fail"	self setProperty: #searchContainer toValue: nil.	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	^ false! !!StackMorph methodsFor: 'menu' stamp: 'gm 2/22/2003 13:13'!findText: keys inStrings: rawStrings startAt: startIndex container: oldContainer cardNum: cardNum 	"Call once to search a card of the stack.  Return true if found and highlight the text.  oldContainer should be NIL.  	(oldContainer is only non-nil when (1) doing a 'search again' and (2) the page is in memory and (3) keys has just one element.  oldContainer is a TextMorph.)"	| good thisWord index insideOf place container start strings old |	good := true.	start := startIndex.	strings := oldContainer ifNil: 					["normal case"					rawStrings]				ifNotNil: [self currentPage allStringsAfter: oldContainer text].	keys do: 			[:searchString | 			"each key"			good 				ifTrue: 					[thisWord := false.					strings do: 							[:longString | 							(index := longString findWordStart: searchString startingAt: start) > 0 								ifTrue: 									[thisWord not & (searchString == keys first) 										ifTrue: 											[insideOf := longString.											place := index].									thisWord := true].							start := 1].	"only first key on first container"					good := thisWord]].	good 		ifTrue: 			["all are on this page"			"wasIn := (pages at: pageNum) isInMemory."			self goToCardNumber: cardNum			"wasIn ifFalse: ['search again, on the real current text.  Know page is in.'.			^ self findText: keys 				inStrings: ((pages at: pageNum) allStringsAfter: nil)         recompute it					startAt: startIndex container: oldContainer 				pageNum: pageNum]"].	(old := self valueOfProperty: #searchContainer) ifNotNil: 			[(old respondsTo: #editor) 				ifTrue: 					[old editor selectFrom: 1 to: 0.	"trying to remove the previous selection!!"					old changed]].	good 		ifTrue: 			["have the exact string object"			(container := oldContainer) ifNil: 					[container := self 								highlightText: keys first								at: place								in: insideOf]				ifNotNil: 					[container userString == insideOf 						ifFalse: 							[container := self 										highlightText: keys first										at: place										in: insideOf]						ifTrue: 							[(container isTextMorph) 								ifTrue: 									[container editor selectFrom: place to: keys first size - 1 + place.									container changed]]].			self setProperty: #searchContainer toValue: container.			self setProperty: #searchOffset toValue: place.			self setProperty: #searchKey toValue: keys.	"override later"			ActiveHand newKeyboardFocus: container.			^true].	^false! !!StackMorph methodsFor: 'menu' stamp: 'em 3/31/2005 10:20'!findViaTemplate	| list pl cardInst |	"Current card is the template.  Only search cards in this background. Look at cards directly (not allText). Key must be found in the same field as in the template.  HyperCard style (multiple starts of words).  	Put results in a list, outside the stack."	list := self templateMatches.	list isEmpty ifTrue: [^ self inform: 'No matches were found.Be sure the current card is mostly blankand only has text you want to match.' translated]. 	"put up a PluggableListMorph"	cardInst := self currentCard.	cardInst matchIndex: 0.	"establish entries"	cardInst results at: 1 put: list.	self currentPage setProperty: #myStack toValue: self.	"way to get back"	pl := PluggableListMorph new			on: cardInst list: #matchNames			selected: #matchIndex changeSelected: #matchIndex:			menu: nil "#matchMenu:shifted:" keystroke: nil.	ActiveHand attachMorph: (self formatList: pl).! !!StackMorph methodsFor: 'menu' stamp: 'tk 6/2/2001 11:40'!formatList: pl	| rr ff |	"Turn this plugglable list into a good looking morph."	pl color: Color transparent; borderWidth: 0.	pl font: ((TextStyle named: #Palatino) fontOfSize: 14).	pl toggleCornerRounding; width: 252; retractableOrNot; hResizing: #spaceFill.	rr := (RectangleMorph new) toggleCornerRounding; extent: pl extent + (30@30).	rr color: self currentPage color; fillStyle: (ff := self currentPage fillStyle copy).	ff isGradientFill ifTrue: [		rr fillStyle direction: (ff direction * self currentPage extent / rr extent) rounded.		rr fillStyle origin: rr bounds origin].	rr addMorph: pl.	rr layoutPolicy: TableLayout new.	rr layoutInset: 10@15; cellInset: 10@15; wrapDirection: #leftToRight.	rr listCentering: #center; borderWidth: 5; borderColor: #raised.	"Up and down buttons on left with arrows in a holder."	"lb := (RectangleMorph new) color: transparent; borderWidth: 0."	^ rr! !!StackMorph methodsFor: 'menu' stamp: 'sw 3/18/2002 02:07'!getAllText	"Collect the text for each card.  Just point at strings so don't have to recopy them.  (Parallel array of urls for ID of cards.  Remote cards not working yet.)	allText = Array (cards size) of arrays (fields in it) of strings of text.	allTextUrls = Array (cards size) of urls or card numbers."	| oldUrls oldStringLists allText allTextUrls aUrl which |	self writeSingletonData.	oldUrls := self valueOfProperty: #allTextUrls ifAbsent: [#()].	oldStringLists := self valueOfProperty: #allText ifAbsent: [#()].	allText := self privateCards collect: [:pg | OrderedCollection new].	allTextUrls := Array new: self privateCards size.	self privateCards doWithIndex: [:aCard :ind | aUrl := aCard url.  aCard isInMemory 		ifTrue: [(allText at: ind) addAll: (aCard allStringsAfter: nil).			aUrl ifNil: [aUrl := ind].			allTextUrls at: ind put: aUrl]		ifFalse: ["Order of cards on server may be different.  (later keep up to date?)"			"*** bug in this algorithm if delete a page?"			which := oldUrls indexOf: aUrl.			allTextUrls at: ind put: aUrl.			which = 0 ifFalse: [allText at: ind put: (oldStringLists at: which)]]].	self setProperty: #allText toValue: allText.	self setProperty: #allTextUrls toValue: allTextUrls.	^ allText! !!StackMorph methodsFor: 'menu' stamp: 'dgd 9/29/2004 20:47'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'Stack' translated.	Preferences noviceMode		ifFalse: [aMenu addStayUpItem].	aMenu addList: {		{'find...' translated.					#textSearch}.		{'find via this template' translated.			#findViaTemplate}.		{'show designations' translated. 			#showDesignationsOfObjects}.		{'explain designations' translated.			#explainDesignations}.		#-.		{'previous card' translated. 				#goToPreviousCardInStack}.		{'next card' translated. 				#goToNextCardInStack}.		{'first card' translated. 				#goToFirstCardOfStack}.		{'last card' translated. 				#goToLastCardOfStack}.		{'go to card...' translated. 				#goToCard}.		#-.		{'add a card of this background' translated. 		#insertCard}.		{'add a card of background...' translated.		#insertCardOfBackground}.		{'make a new background...' translated. 		#makeNewBackground}.		#-.		{'insert cards from clipboard data' translated.		#addCardsFromClipboardData.	'Create new cards from a formatted string on the clipboard' translated}.		{'insert cards from a file...' translated.		#addCardsFromAFile.		'Create new cards from data in a file' translated}.		#-.		{'instance variable order...' translated.		#changeInstVarOrder.		'Caution -- DANGER. Change the order of the variables on the cards' translated}.		{'be defaults for new cards' translated. 		#beDefaultsForNewCards.		'Make these current field values be the defaults for their respective fields on new cards' translated}.		    {'sort cards by...' translated.			#sortCards.			'Sort all the cards of the current background using some field as the sort key' translated}.		#-.		{'delete this card' translated. 			#deleteCard}.		{'delete all cards *except* this one' translated.	#deleteAllCardsExceptThisOne}.		#-.		{'move card to front of stack' translated.		#makeCurrentCardFirstInStack}.		{'move card to back of stack' translated.		#makeCurrentCardLastInStack}.		{'move card one position earlier' translated.		#moveCardOnePositionEarlier}.		{'move card one position later' translated.		#moveCardOnePositionLater}.		#-.		{'scripts for this background' translated.		#browseCardClass}.		#-.		{'debug...' translated.					#offerStackDebugMenu}.		{'bookish items...' translated. 			#offerBookishMenu}}.	aMenu addUpdating: #showingPageControlsString action: #toggleShowingOfPageControls.	aMenu addUpdating: #showingFullScreenString action: #toggleFullScreen.	aMenu popUpEvent: self world activeHand lastEvent in: self world! !!StackMorph methodsFor: 'menu' stamp: 'dgd 9/29/2004 20:47'!offerStackDebugMenu	"Put up a menu offering debugging items for the stack"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'Stack debugging'.	Preferences noviceMode		ifFalse: [aMenu addStayUpItem].	aMenu addList: #(		('reassess'								reassessBackgroundShape)		('relax grip on variable names'			relaxGripOnVariableNames)		('commit card data'						commitCardData)		-		('browse card uniclass'					browseCardClass)		('inspect card'							inspectCurrentCard)		('inspect background'					inspectCurrentBackground)		('inspect stack'							inspectCurrentStack)).	aMenu popUpInWorld: (self world ifNil: [self currentWorld])! !!StackMorph methodsFor: 'menu' stamp: 'sw 3/18/2002 01:58'!templateMatches	| template docks keys bkg |	"Current card is the template.  Only search cards in this background. Look at cards directly (not allText). Key must be found in the same field as in the template.  HyperCard style (multiple starts of words).  	Put results in a list, outside the stack."	template := self currentCard.	template commitCardPlayerData.	docks := template class variableDocks.	(keys := template asKeys) ifNil: [^ #()]. "nothing to match against"	bkg := self currentPage.	^ self privateCards select: [:cardPlayer | 		(((cardPlayer == template) not) and: [cardPlayer costume == bkg]) 			and: [cardPlayer match: keys fields: docks]].! !!StackMorph methodsFor: 'menu' stamp: 'sw 3/18/2002 02:00'!writeSingletonData	"Backgrounds that have just one card, may never get their data written into a CardPlayer. Make sure we do it."	| sieve |	sieve := IdentityDictionary new.	pages do: [:pp | sieve at: pp put: 0].	self privateCards do: [:cc | sieve at: cc costume put: (sieve at: cc costume) + 1].	sieve associationsDo: [:ass | 		ass value = 1 ifTrue:			[ass key player commitCardPlayerDataFrom: ass key]].			"If currently showing card, may be some trouble... <- tk note 5/01"! !!StackMorph methodsFor: 'submorphs-accessing' stamp: 'sw 3/18/2002 02:20'!allNonSubmorphMorphs	"Return a collection containing all morphs in this morph which are not currently in the submorph containment hierarchy.  Especially the non-showing pages in BookMorphs."	| coll |	coll := OrderedCollection new.	self privateCards do: [:cd | 		cd privateMorphs ifNotNil: [coll addAll: cd privateMorphs]].	^ coll! !!StackMorph methodsFor: 'submorphs-accessing' stamp: 'sw 6/5/2003 04:01'!insertionIndexForPaneOfType: aType	| naturalIndex insertionIndex |	naturalIndex := self naturalPaneOrder indexOf: aType.	insertionIndex := 1.	(self naturalPaneOrder copyFrom: 1 to: (naturalIndex - 1)) do: "guys that would precede"		[:sym | (self hasSubmorphWithProperty: sym)			ifTrue:				[insertionIndex := insertionIndex + 1]].	^ insertionIndex! !!StackMorph class methodsFor: 'authoring prototype' stamp: 'nk 7/12/2003 08:59'!designationsExplainer	"Answer a morph that contains designation explanation"	| aMorph aSwatch aTextMorph |	aMorph := AlignmentMorph newColumn color: Color black; layoutInset: 1.	#((green		'Shared items onBackground.Exact same itemshared by every card')	(orange'Data items onBackgroundEach card has itsown data')	(red'Instance-specificitemsuniqueto this card')) do:	[:aPair |		aSwatch := AlignmentMorph new extent: 132 @80; color: (Color perform: aPair first); lock.		aSwatch hResizing: #rigid; vResizing: #rigid; layoutInset: 0.		aSwatch borderColor: Color black.		aTextMorph := TextMorph new string: aPair second fontName: Preferences standardEToysFont familyName size: 18.		aTextMorph width: 130.		aTextMorph centered.		aSwatch addMorphBack: aTextMorph.		aMorph addMorphBack: aSwatch].	aMorph hResizing: #shrinkWrap; vResizing: #shrinkWrap.	^ aMorph	"StackMorph designationsExplainer openInHand"! !!StackMorph class methodsFor: 'misc' stamp: 'tk 12/14/2001 19:23'!discoverSlots: aMorph	"Examine the parts of the morph for ones that couldHoldSeparateData.  Return a pair of lists: Named morphs, and unnamed morphs (which may be labels, and non-data).  Examine all submorphs."	| named unnamed got sn generic |	named := OrderedCollection new.	unnamed := OrderedCollection new.	aMorph submorphsDo: [:direct | 		got := false.		direct allMorphsDo: [:sub |			sub couldHoldSeparateDataForEachInstance ifTrue: [				(sn := sub knownName) ifNotNil: [					generic := (#('Number (fancy)' 'Number (mid)' 'Number (bare)')									includes: sn).					(sn beginsWith: 'shared' "label") | generic ifFalse: [						named add: sub.						got := true]]]].		got ifFalse: [unnamed add: direct]].	^ Array with: named with: unnamed		! !!StackMorph class methodsFor: 'navigation buttons' stamp: 'sw 10/27/2000 10:53'!nextCardButton	"Answer a button that advances the user to the next card in the stack"	| aButton |	aButton := SimpleButtonMorph new.	aButton target: aButton; actionSelector: #goToNextCardInStack; label: '>'; color: Color yellow; borderWidth: 0.	aButton setNameTo: 'next'.	^ aButton! !!StackMorph class methodsFor: 'navigation buttons' stamp: 'sw 10/27/2000 10:53'!previousCardButton	"Answer a button that will take the user to the preceding card in the stack"	| aButton |	aButton := SimpleButtonMorph new.	aButton target: aButton; actionSelector: #goToPreviousCardInStack; label: '<'; color: Color yellow ; borderWidth: 0.	aButton setNameTo: 'previous'.	^ aButton! !!StackMorph class methodsFor: 'scripting' stamp: 'sw 10/9/2000 07:43'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book := self new markAsPartsDonor.	book pageSize: (480 @ 320); color: (Color gray: 0.7).	book borderWidth: 1; borderColor: Color black.	book currentPage extent: book pageSize.	book showPageControls: book fullControlSpecs.	^ book"self currentHand attachMorph: StackMorph authoringPrototype"! !!StandardFileStream methodsFor: 'dnd requests' stamp: 'ar 6/3/2007 21:47'!requestDropStream: dropIndex	"Return a read-only stream for some file the user has just dropped onto Squeak."	| rawName |	rawName := self primDropRequestFileName: dropIndex.	name :=  (FilePath pathName: rawName isEncoded: true) asSqueakPathName.	fileID := self primDropRequestFileHandle: dropIndex.	fileID == nil ifTrue:[^nil].	self register.	rwmode := false.	buffer1 := String new: 1.! !!StandardScriptingSystem methodsFor: '*eToys-customevents-custom events' stamp: 'nk 11/1/2004 07:47'!addCustomEventFor: registrantClass named: aSymbol help: helpString targetMorphClass: targetClass	| registration |	registration := self customEventsRegistry at: aSymbol ifAbsentPut: [ IdentityDictionary new ].	registration at: registrantClass put: { helpString. targetClass }.! !!StandardScriptingSystem methodsFor: '*eToys-customevents-custom events' stamp: 'nk 7/20/2003 12:37'!removeCustomEventNamed: aSymbol for: registrant	| registration helpString |	registration := self customEventsRegistry at: aSymbol ifAbsent: [ ^nil ].	helpString := registration removeKey: registrant ifAbsent: [].	registration isEmpty ifTrue: [ self customEventsRegistry removeKey: aSymbol ].	^helpString! !!StandardScriptingSystem methodsFor: '*eToys-customevents-custom events' stamp: 'nk 9/26/2003 23:26'!removeUserCustomEventNamed: eventName	| retval |	retval := self currentWorld removeUserCustomEventNamed: eventName.	"Vocabulary addStandardVocabulary: UserCustomEventNameType new."	Vocabulary customEventsVocabulary.	SymbolListTile updateAllTilesForVocabularyNamed: #CustomEvents.	^retval! !!StandardScriptingSystem methodsFor: '*eToys-form dictionary' stamp: 'sw 5/2/1998 14:01'!readFormsFromFileNamed: aFileName	"Read the entire FormDictionary in from a designated file on disk"	| aReferenceStream |	aReferenceStream := ReferenceStream fileNamed: aFileName.	FormDictionary := aReferenceStream next.	aReferenceStream close	"ScriptingSystem readFormsFromFileNamed: 'EToyForms22Apr'"! !!StandardScriptingSystem methodsFor: '*eToys-form dictionary' stamp: 'sw 9/14/2000 21:29'!readFormsFromFileNamed: aFileName andStoreIntoGlobal: globalName	"Read the a FormDictionary in from a designated file on disk and save it in the designated global"	| aReferenceStream |	aReferenceStream := ReferenceStream fileNamed: aFileName.	Smalltalk at: globalName put: aReferenceStream next.	aReferenceStream close	"ScriptingSystem readFormsFromFileNamed: 'SystemFormsFromFwdF.forms' andStoreIntoGlobal: #FormsTemp"	"ScriptingSystem saveForm:  (FormsTemp at: #StackElementDesignationHelp) atKey: #StackElementDesignationHelp"! !!StandardScriptingSystem methodsFor: '*eToys-form dictionary' stamp: 'sw 4/23/1999 11:24'!restorePrivateGraphics	"ScriptingSystem restorePrivateGraphics"	| aReferenceStream |	aReferenceStream := ReferenceStream fileNamed: 'disGraphics'.	self mergeGraphicsFrom: aReferenceStream next.	aReferenceStream close.! !!StandardScriptingSystem methodsFor: '*eToys-parts bin' stamp: 'sw 5/3/1999 22:40'!prototypicalHolder	| aHolder |	aHolder := PasteUpMorph authoringPrototype color: Color orange muchLighter; borderColor: Color orange lighter.	aHolder setNameTo: 'holder'; extent: 160 @ 110.	^ aHolder behaveLikeHolder.! !!StandardScriptingSystem methodsFor: '*eToys-parts bin' stamp: 'sw 10/27/1998 13:35'!resetStandardPartsBin	"ScriptingSystem resetStandardPartsBin"	StandardPartsBin := nil! !!StandardScriptingSystem methodsFor: '*eToys-parts bin' stamp: 'sw 7/3/2001 08:01'!tilesForQuery: expressionString label: aLabel	"Answer scripting tiles that represent the query,"	| aPhrase aTile |	aPhrase := SystemQueryPhrase new.	aTile := BooleanTile new.	aTile setExpression: expressionString  label: aLabel.	aPhrase addMorph: aTile.	^ aPhrase! !!StandardScriptingSystem methodsFor: '*eToys-script-control' stamp: 'dgd 9/19/2003 14:40'!goButton	| aButton |	aButton :=  ThreePhaseButtonMorph new.	aButton image:  (ScriptingSystem formAtKey: 'GoPicOn');			offImage: (ScriptingSystem formAtKey: 'GoPic');			pressedImage: (ScriptingSystem formAtKey: 'GoPicOn');			actionSelector: #goUp:with:; 			arguments: (Array with: nil with: aButton);			actWhen: #buttonUp;			target: self;			setNameTo: 'Go Button';			setBalloonText:'Resume running all paused scripts' translated.	^ aButton! !!StandardScriptingSystem methodsFor: '*eToys-script-control' stamp: 'sw 1/23/2001 11:39'!scriptControlButtons	"Answer a composite object that serves to control the stop/stop/go status of a Presenter"	| wrapper |	wrapper := AlignmentMorph newRow setNameTo: 'script controls'.	wrapper vResizing: #shrinkWrap.	wrapper hResizing: #shrinkWrap.	wrapper addMorph: self stopButton.	wrapper addMorphBack: self stepButton.	wrapper addMorphBack: self goButton.	wrapper beTransparent.	^ wrapper! !!StandardScriptingSystem methodsFor: '*eToys-script-control' stamp: 'dgd 9/19/2003 14:41'!stepButton	| aButton |	self flag: #deferred.  "ambiguity about recipients"	aButton := ThreePhaseButtonMorph new.		aButton			image:  (ScriptingSystem formAtKey: 'StepPicOn');			offImage: (ScriptingSystem formAtKey: 'StepPic');			pressedImage:  (ScriptingSystem formAtKey: 'StepPicOn');			arguments: (Array with: nil with: aButton);		 	actionSelector: #stepStillDown:with:; 			target: self;			setNameTo: 'Step Button'; 			actWhen: #whilePressed;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Run every paused script exactly once.  Keep the mouse button down over "Step" and everything will keep running until you release it' translated.	^ aButton! !!StandardScriptingSystem methodsFor: '*eToys-script-control' stamp: 'dgd 9/19/2003 14:41'!stopButton	"Answer a new button that can serve as a stop button"	| aButton |	aButton := ThreePhaseButtonMorph new.	aButton		image:  (ScriptingSystem formAtKey: 'StopPic');		offImage: (ScriptingSystem formAtKey: 'StopPic');		pressedImage:  (ScriptingSystem formAtKey: 'StopPicOn').		aButton actionSelector: #stopUp:with:; 		arguments: (Array with: nil with: aButton);		actWhen: #buttonUp;		target: self;		setNameTo: 'Stop Button'; 		setBalloonText: 'Pause all ticking scripts.' translated.	^ aButton! !!StandardScriptingSystem methodsFor: '*eToys-script-control' stamp: 'sw 11/11/1998 15:16'!stopUp: dummy with: theButton	| aPresenter |	(aPresenter := theButton presenter) flushPlayerListCache.  "catch guys not in cache but who're running"	aPresenter stopRunningScriptsFrom: theButton! !!StandardScriptingSystem methodsFor: '*eToys-universal slots & scripts' stamp: 'sw 1/4/2005 02:20'!acceptableSlotNameFrom: originalString forSlotCurrentlyNamed: currentName asSlotNameIn: aPlayer world: aWorld	"Produce an acceptable slot name, derived from the current name, for aPlayer.  This method will always return a valid slot name that will be suitable for use in the given situation, though you might not like its beauty sometimes."	| aString stemAndSuffix proscribed stem suffix putative |	aString := originalString asIdentifier: false.  "get an identifier not lowercase"	stemAndSuffix := aString stemAndNumericSuffix.	proscribed := #(self super thisContext costume costumes dependents #true #false size), aPlayer class allInstVarNames.	stem := stemAndSuffix first.	suffix := stemAndSuffix last.	putative := aString asSymbol.		[(putative ~~ currentName) and: [(proscribed includes: putative)		or:	[(aPlayer respondsTo: putative)		or:	[Smalltalk includesKey: putative]]]]	whileTrue:		[suffix := suffix + 1.		putative := (stem, suffix printString) asSymbol].	^ putative! !!StandardScriptingSystem methodsFor: '*eToys-universal slots & scripts' stamp: 'sw 9/27/2001 04:08'!systemSlotNamesOfType: aType	"Answer the type of the slot name, or nil if not found."		| aList |	self flag: #deferred.  "Hard-coded etoyVocabulary needed here to make this work."	aList := OrderedCollection new.	Vocabulary eToyVocabulary methodInterfacesDo:		 [:anInterface |			anInterface resultType = aType ifTrue:				[aList add: anInterface selector]].	^ aList! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'sw 10/30/2000 16:37'!allKnownClassVariableNames	"Answer a set of all the knwon class variable names in the system.  This normally retrieves them from a cache, and at present there is no organized mechanism for invalidating the cache.  The idea is to avoid, in the References scheme, names that may create a conflict"	^ ClassVarNamesInUse ifNil: [ClassVarNamesInUse := self allClassVarNamesInSystem]	"ClassVarNamesInUse := nil.	Time millisecondsToRun: [ScriptingSystem allKnownClassVariableNames]"! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'sw 6/27/2004 11:11'!helpStringOrNilForOperator: anOperator	"Answer the help string associated with the given operator, nil if none found."	| anIndex opsAndHelp |	(anIndex := (opsAndHelp := self arithmeticalOperatorsAndHelpStrings) first indexOf: anOperator) > 0		ifTrue:	[^ (opsAndHelp second at: anIndex) translated].	(anIndex := (opsAndHelp := self numericComparitorsAndHelpStrings) first indexOf: anOperator) > 0		ifTrue:	[^ (opsAndHelp second at: anIndex) translated].	anOperator = #, ifTrue:		[^ 'Concatenate two Strings' translated].	^ nil! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'nk 7/12/2003 08:59'!holderWithAlphabet	"Answer a fully instantiated Holder that has submorphs that represent the letters of the uppercase alphabet, with each one having an 'index' slot which bears the letter's index in the alphabet -- 1 for A, 2 for B, etc.   A few special characters are provided as per ack request 10/00; for these the index provided is rather arbitrarily assigned"	| aMorph aPlayer newMorph oneCharString aContainer aWrapper |	"ScriptingSystem holderWithAlphabet openInHand"	aContainer := self prototypicalHolder useRoundedCorners.	aContainer borderColor: Color blue lighter.	aWrapper := AlignmentMorph new hResizing: #shrinkWrap; vResizing: #shrinkWrap; layoutInset: 0.	aWrapper addMorphBack: (aMorph := TextMorph new contents: 'A').	aMorph beAllFont: ((TextStyle named: Preferences standardEToysFont familyName) fontOfSize: 24).	aMorph width: 14; lock.	aWrapper beTransparent; setNameTo: 'A'.	aPlayer := aWrapper assuredPlayer.	aPlayer addInstanceVariableNamed: #index type: #Number value: 1.	aContainer addMorphBack: aWrapper.	2 to: 26 do:		[:anIndex |			newMorph := aWrapper usableSiblingInstance.			newMorph player perform: #setIndex: with: anIndex.			newMorph firstSubmorph contents: (oneCharString := ($A asciiValue + anIndex - 1) asCharacter asString).			newMorph setNameTo: oneCharString.			aContainer addMorphBack: newMorph].	#(' ' '.' '#') with: #(27 28 29) do:		[:aString :anIndex |			newMorph := aWrapper usableSiblingInstance.			newMorph player perform: #setIndex: with: anIndex.			newMorph firstSubmorph contents: aString.			aString = ' '				ifTrue:					[newMorph setNameTo: 'space'.					newMorph color: (Color gray alpha: 0.2)]				ifFalse:					[newMorph setNameTo: aString].			aContainer addMorphBack: newMorph].	aContainer setNameTo: 'alphabet'.	aContainer isPartsBin: true.	aContainer enableDrop: false.	aContainer indicateCursor: false; width: 162.	aContainer color: (Color r: 0.839 g: 1.0 b: 1.0).  "Color fromUser"	^ aContainer! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'sw 11/13/2001 14:41'!newScriptingSpace2	"Answer a complete scripting space"	| aTemplate  aPlayfield aControl |		(aTemplate := PasteUpMorph new)		setNameTo: 'etoy';		extent: 638 @ 470;		color: Color white;		impartPrivatePresenter;		setProperty: #automaticPhraseExpansion toValue: true;		beSticky.	aTemplate useRoundedCorners; borderWidth: 2. 	aControl :=  ScriptingSystem scriptControlButtons setToAdhereToEdge: #bottomLeft.	aControl beSticky; borderWidth: 0; beTransparent.	aTemplate addMorphBack: aControl.	aTemplate presenter addTrashCan.	aTemplate addMorph: (aPlayfield := PasteUpMorph new).	aPlayfield		setNameTo: 'playfield';		useRoundedCorners;		setToAdhereToEdge: #topLeft;		extent: 340@300;		position: aTemplate topRight - (400@0);		beSticky;		automaticViewing: true;		wantsMouseOverHalos: true.	aTemplate presenter standardPlayfield: aPlayfield.		^ aTemplate! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'sw 5/2/1998 14:17'!reclaimSpace	"Reclaim space from the scripting system, and report the result in an informer"	"ScriptingSystem reclaimSpace"	| reclaimed |	(reclaimed := self spaceReclaimed)  > 0		ifTrue:	[self inform: reclaimed printString, ' bytes reclaimed']		ifFalse:	[self inform: 'Hmm...  Nothing gained this time.']! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'sw 6/9/2000 18:44'!reinvigorateThumbnailsInViewerFlapTabs	"It has happened that the thumbnail in a viewer flap tab will go solid gray because it got associated with some passing and disused player temporarily created during the initial painting process.  This method takes a sledge hammer to repair such thumbnails.   At its genesis, this method is called only from the postscript of its defining fileout."	| vwr thumbnail |	ViewerFlapTab allInstancesDo:		[:aTab | 			vwr := aTab referent findA: StandardViewer.			thumbnail := aTab findA: ThumbnailMorph.			(vwr notNil and: [thumbnail notNil]) ifTrue:				[thumbnail objectToView: vwr scriptedPlayer]]	"ScriptingSystem reinvigorateThumbnailsInViewerFlapTabs"! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'sw 7/25/2004 17:27'!restoreClassicEToyLook	"Restore classic EToy look, as closely as possible.  If ComicBold is present, restore it as the standard etoy and button font.  Substitute ComicSansMS and Accuny as respective alternatives if the classic fonts are absent.  If those also aren't available, do nothing."	| aTextStyle aFont | 	(aTextStyle := TextStyle named: #ComicBold)		ifNotNil:			[aFont := aTextStyle fontOfSize: 16.			Preferences setEToysFontTo: aFont.			Preferences setButtonFontTo: aFont]		ifNil:			[(aTextStyle := TextStyle named: #ComicSansMS) ifNotNil:				[Preferences setEToysFontTo: (aTextStyle fontOfSize: 18)].			(aTextStyle := TextStyle named: #Accuny) ifNotNil:				[Preferences setButtonFontTo: (aTextStyle fontOfSize: 12)]].	(aTextStyle := TextStyle named: #NewYork)		ifNotNil:			[Preferences setSystemFontTo: (aTextStyle fontOfSize: 12)]! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'di 3/3/2001 08:47'!spaceReclaimed	"Reclaim space from the EToy system, and return the number of bytes reclaimed"	"ScriptingSystem spaceReclaimed"	| oldFree  |	oldFree := Smalltalk garbageCollect.	ThumbnailMorph recursionReset.	Player removeUninstantiatedSubclassesSilently.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	^ Smalltalk garbageCollect - oldFree.! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'nk 10/14/2004 11:19'!wordingForOperator: aString	"Answer the wording to be seen by the user for the given operator symbol/string"	| toTest |	toTest := aString asString.	#(	(append:				'include at end')		(arrowheadsOnAllPens	'arrowheads on all pens')		(beep:					'make sound')		(bounce:				'bounce')		(clearTurtleTrails		'clear pen trails')		(clearOwnersPenTrails	'clear all pen trails')		(colorSees				'color  sees')		(color:sees:				'color sees')		(doMenuItem:			'do menu item')		(doScript:				'do')		(forward:				'forward by')		(goToRightOf:			'align after')		(includeAtCursor:		'include at cursor')		(isDivisibleBy:			'is divisible by')		(liftAllPens				'lift all pens')		(lowerAllPens			'lower all pens')		(makeNewDrawingIn:	'start painting in')		(max:					'max')		(min:					'min')		(moveToward:			'move toward')		(noArrowheadsOnAllPens	'no arrowheads on pens')		(overlapsAny			'overlaps any')		(pauseAll:				'pause all')		(pauseScript:			'pause script')		(prepend:				'include at beginning')		(seesColor:				'is over color')		(startAll:				'start all')		(startScript:				'start script')		(stopProgramatically	'stop')		(stopAll:					'stop all')		(stopScript:				'stop script')		(tellAllSiblings:			'tell all siblings')		(tellSelfAndAllSiblings:	'send to all')		(turn:					'turn by')		(turnToward:				'turn toward')		(wearCostumeOf:		'look like'))	do:		[:pair | toTest = pair first ifTrue: [^ pair second]].	^ toTest	"StandardScriptingSystem initialize"! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'sw 10/20/1999 09:52'!controlInitialize	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	model windowActiveOnFirstClick ifFalse: [sensor waitNoButton].	status := #active.	view isCollapsed ifFalse: [model modelWakeUpIn: view]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:45'!adjustPaneBorders 	| side sub newRect outerFrame |	outerFrame := view displayBox.	side := #none.	VBorderCursor showWhile:		[ [sub := view subviewWithLongestSide: [:s | side := s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[newRect := sub stretchFrame:						[:f | (f withLeft: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				side = #right ifTrue:					[newRect := sub stretchFrame:						[:f | (f withRight: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]].	HBorderCursor showWhile:		[ [sub := view subviewWithLongestSide: [:s | side := s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[newRect := sub stretchFrame:						[:f | (f withTop: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				side = #bottom ifTrue:					[newRect := sub stretchFrame:						[:f | (f withBottom: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]]! !!StandardSystemController methodsFor: 'borders' stamp: 'di 11/16/2001 22:22'!adjustWindowBorders 	| side noClickYet |	noClickYet := true.	VBorderCursor showWhile:		[ [side := view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder			and: [(side = #left) | (side = #right)			and: [noClickYet or: [sensor redButtonPressed]]]]			whileTrue:			[sensor redButtonPressed ifTrue:				[noClickYet := false.				side = #left ifTrue:					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].				side = #right ifTrue:					[view newFrame: [:f | f withRight: sensor cursorPoint x]]].			self interActivityPause]].	HBorderCursor showWhile:		[ [side := view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder			and: [(side = #top) | (side = #bottom)			and: [noClickYet or: [sensor redButtonPressed]]]]			whileTrue:			[sensor redButtonPressed ifTrue:				[noClickYet := false.				side = #top ifTrue:					[view newFrame: [:f | f withTop: sensor cursorPoint y]].				side = #bottom ifTrue:					[view newFrame: [:f | f withBottom: sensor cursorPoint y]]].		  self interActivityPause]]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:38'!adjustWindowCorners 	| box cornerBox p clicked f2 |	box := view windowBox.	clicked := false.	#(topLeft topRight bottomRight bottomLeft)		do: [:readCorner |			cornerBox := ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (p := sensor cursorPoint))						and: [(clicked := sensor anyButtonPressed) not]]						whileTrue: [ self interActivityPause ].				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | p := sensor cursorPoint.						readCorner = #topLeft ifTrue:							[f2 := p corner: f bottomRight].						readCorner = #bottomLeft ifTrue:							[f2 := (f withBottom: p y) withLeft: p x].						readCorner = #bottomRight ifTrue:							[f2 := f topLeft corner: p].						readCorner = #topRight ifTrue:							[f2 := (f withTop: p y) withRight: p x].						f2]]]]].	^ clicked! !!StandardSystemController methodsFor: 'borders' stamp: 'di 11/16/2001 22:30'!checkForReframe	| cp |	view isCollapsed ifTrue: [^ self].	cp := sensor cursorPoint.	((view closeBoxFrame expandBy: 2) containsPoint: cp)		| ((view growBoxFrame expandBy: 2) containsPoint: cp)		ifTrue: [^ self].  "Dont let reframe interfere with close/grow"	self adjustWindowCorners.	self cursorOnBorder ifFalse: [^ self].	((view insetDisplayBox insetBy: 2@2) containsPoint: cp)		ifFalse: [^ self adjustWindowBorders].	view subViews size <= 1 ifTrue: [^ self].	(view subviewWithLongestSide: [:s | ] near: cp) == nil		ifFalse: [^ self adjustPaneBorders].! !!StandardSystemController methodsFor: 'borders'!cursorOnBorder 	| cp i box |	view isCollapsed ifTrue: [^ false].	cp := sensor cursorPoint.	((view labelDisplayBox insetBy: (0@2 corner: 0@-2)) containsPoint: cp)		ifTrue: [^ false].	(i := view subViews findFirst: [:v | v displayBox containsPoint: cp]) = 0		ifTrue: [box := view windowBox]		ifFalse: [box := (view subViews at: i) insetDisplayBox].	^ ((box insetBy: 3) containsPoint: cp) not		and: [(box expandBy: 4) containsPoint: cp]! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/15/2000 22:19'!redButtonActivity	"If cursor is in label of a window when red button is pushed,	check for closeBox or growBox, else drag the window frame	or edit the label."	| box p |	p := sensor cursorPoint.	self labelHasCursor ifFalse: [super redButtonActivity. ^ self].	((box := view closeBoxFrame) containsPoint: p)		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed: [self close. ^ self].			^ self].	((box := view growBoxFrame) containsPoint: p)		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed:					[Sensor controlKeyPressed ifTrue: [^ self expand; fullScreen].					^ view isCollapsed						ifTrue: [self expand]						ifFalse: [self collapse]].			^ self].	(((box := view labelTextRegion expandBy: 1) containsPoint: p)			and: [Preferences clickOnLabelToEdit or: [sensor leftShiftDown]])		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed: [^ self label].			^ self].	self move! !!StandardSystemController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 11:48'!initialize	super initialize.	status := #inactive! !!StandardSystemController methodsFor: 'menu messages'!close	"The receiver's view should be removed from the screen and from the 	collection of scheduled views."	model okToChange ifFalse: [^self].	status := #closed.	view erase! !!StandardSystemController methodsFor: 'menu messages'!move	"Ask the user to designate a new origin position for the receiver's view.	6/10/96 sw: tell the view that it has moved"	| oldBox | 	oldBox := view windowBox.	view uncacheBits.	view align: view windowBox topLeft		with: view chooseMoveRectangle topLeft.	view displayEmphasized.	view moved.  "In case its model wishes to take note."	(oldBox areasOutside: view windowBox) do:		[:rect | ScheduledControllers restore: rect]! !!StandardSystemController methodsFor: 'menu messages'!under	"Deactive the receiver's scheduled view and pass control to any view that 	might be positioned directly underneath it and the cursor."	status := #inactive! !!StandardSystemController methodsFor: 'scheduling' stamp: 'sw 9/30/97 22:04'!closeAndUnschedule	"Erase the receiver's view and remove it from the collection of scheduled 	views."	status := #closed.	view erase.	view release.	ScheduledControllers unschedule: self; searchForActiveController! !!StandardSystemController methodsFor: 'scheduling'!closeAndUnscheduleNoErase	"Remove the scheduled view from the collection of scheduled views. Set 	its status to closed but do not erase."	status := #closed.	view release.	ScheduledControllers unschedule: self! !!StandardSystemController methodsFor: 'scheduling' stamp: 'jm 3/18/98 19:21'!closeAndUnscheduleNoTerminate	"Erase the receiver's view and remove it from the collection of scheduled views, but do not terminate the current process."	status := #closed.	view erase.	view release.	ScheduledControllers unschedule: self.! !!StandardSystemController methodsFor: 'scheduling'!open	"Create an area on the screen in which the receiver's scheduled view can 	be displayed. Make it the active view."	view resizeInitially.	status := #open.	ScheduledControllers scheduleActive: self! !!StandardSystemController methodsFor: 'scheduling'!openDisplayAt: aPoint 	"Create an area with origin aPoint in which the receiver's scheduled 	view can be displayed. Make it the active view."	view align: view viewport center with: aPoint.	view translateBy:		(view displayBox amountToTranslateWithin: Display boundingBox).	status := #open.	ScheduledControllers scheduleActive: self! !!StandardSystemController methodsFor: 'scheduling' stamp: 'jm 10/22/97 08:16'!openNoTerminate	"Create an area in which the receiver's scheduled view can be displayed. 	Make it the active view. Do not terminate the currently active process."	view resizeInitially.	status := #open.	ScheduledControllers scheduleActiveNoTerminate: self! !!StandardSystemController methodsFor: 'scheduling'!openNoTerminateDisplayAt: aPoint 	"Create an area with origin aPoint in which the receiver's scheduled 	view can be displayed. Make it the active view. Do not terminate the 	currently active process."	view resizeMinimumCenteredAt: aPoint.	status := #open.	ScheduledControllers scheduleActiveNoTerminate: self! !!StandardSystemController methodsFor: 'scheduling'!status: aSymbol	status := aSymbol! !!StandardSystemController class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 11:57'!initialize	"StandardSystemController initialize"	ScheduledBlueButtonMenu := SelectionMenu		labels:'edit labelchoose color...two-tone/full colormoveframefull screencollapseclose'	lines: #(3 7)	selections: #(label chooseColor toggleTwoTone move reframe fullScreen collapse close).	VBorderCursor := Cursor extent: 16@16 fromArray: #(		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010010000100000		2r1010110000110000		2r1011111111111000		2r1010110000110000		2r1010010000100000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000)			offset: 0@0.	HBorderCursor := Cursor extent: 16@16 fromArray: #(		2r1111111111111111		2r0000000000000000		2r1111111111111111		2r0000000100000000		2r0000001110000000		2r0000011111000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000011111000000		2r0000001110000000		2r0000000100000000		2r0000000000000000		2r0000000000000000		2r0000000000000000)			offset: 0@0.! !!StandardSystemView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	isLabelComplemented ifTrue:		[self deEmphasizeLabel.		isLabelComplemented := false]! !!StandardSystemView methodsFor: 'displaying'!cacheBits	| oldLabelState |	CacheBits ifFalse: [^ self uncacheBits].	(oldLabelState := isLabelComplemented) ifTrue: [ self deEmphasize ].	self cacheBitsAsIs.	(isLabelComplemented := oldLabelState) ifTrue: [ self emphasize ].! !!StandardSystemView methodsFor: 'displaying'!cacheBitsAsIs	CacheBits ifFalse: [^ self uncacheBits].	windowBits := (self cacheBitsAsTwoTone and: [Display depth > 1])		ifTrue: [ColorForm					twoToneFromDisplay: self windowBox					using: windowBits					backgroundColor: self backgroundColor]		ifFalse: [Form fromDisplay: self windowBox using: windowBits].	bitsValid := true.! !!StandardSystemView methodsFor: 'displaying'!displayEmphasized	"Display with label highlighted to indicate that it is active."	self displayDeEmphasized; emphasize.	isLabelComplemented := true! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 5/15/1998 21:55'!displayLabelBackground: emphasized	"Clear or emphasize the inner region of the label"	| r1 r2 r3 c3 c2 c1 |	emphasized ifFalse:		["Just clear the label if not emphasized"		^ Display fill: (self labelDisplayBox insetBy: 2) fillColor: self labelColor].	r1 := self labelDisplayBox insetBy: 2.	r2 := r1 insetBy: 0@2.	r3 := r2 insetBy: 0@3.	c3 := self labelColor.	c2 := c3 dansDarker.	c1 := c2 dansDarker.	Display fill: r1 fillColor: c1.	Display fill: r2 fillColor: c2.	Display fill: r3 fillColor: c3. "	Here is the Mac racing stripe code	stripes := Bitmap with: (self labelColor pixelWordForDepth: Display depth)					with: (Form black pixelWordForDepth: Display depth).	self windowOrigin y even ifTrue: [stripes swap: 1 with: 2].	Display fill: (self labelDisplayBox insetBy: 3) fillColor: stripes."! !!StandardSystemView methodsFor: 'displaying'!displayLabelBoxes	"closeBox, growBox."	| aRect smallRect backColor |	aRect := self closeBoxFrame.	backColor := self labelColor.	Display fill: (aRect insetBy: -2) fillColor: backColor.	Display fillBlack: aRect.	Display fill: (aRect insetBy: 1) fillColor: backColor.	aRect := self growBoxFrame.	smallRect := aRect origin extent: 7@7.	Display fill: (aRect insetBy: -2) fillColor: backColor.	aRect := aRect insetOriginBy: 2@2 cornerBy: 0@0.	Display fillBlack: aRect.	Display fill: (aRect insetBy: 1) fillColor: backColor.	Display fillBlack: smallRect.	Display fill: (smallRect insetBy: 1) fillColor: backColor! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 9/10/1998 09:43'!displayLabelText	"The label goes in the center of the window"	| labelRect |	labelText foregroundColor: self foregroundColor			backgroundColor: self labelColor.	labelRect := self labelTextRegion.	Display fill: (labelRect expandBy: 3@0) fillColor: self labelColor.	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect			rule: labelText rule fillColor: labelText fillColor.	labelText destinationForm: nil! !!StandardSystemView methodsFor: 'displaying' stamp: 'ar 5/14/2001 23:40'!displayRacingStripes	"Display Racing Stripes in the label"	| labelDisplayBox stripes top bottom left box right |	labelDisplayBox := self labelDisplayBox.	top := labelDisplayBox top + 3.	bottom := labelDisplayBox bottom - 3.	stripes := Bitmap with: (Display pixelWordFor: self labelColor)			with: (Display pixelWordFor: Color black).	top even ifFalse: [stripes swap: 1 with: 2].	left := labelDisplayBox left + 3.	box := self closeBoxFrame.	right := box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left := box right + 2.	box := self labelTextRegion.	right := box left - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left := box right + 2.	box := self growBoxFrame.	right := box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left := box right + 2.	right := labelDisplayBox right - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 8/30/97 11:07'!erase	"Clear the display box of the receiver to be gray, as the screen background."	| oldValid |	CacheBits		ifTrue:			[oldValid := bitsValid.			bitsValid := false.			ScheduledControllers restore: self windowBox without: self.			bitsValid := oldValid]		ifFalse:			[ScheduledControllers restore: self windowBox without: self]! !!StandardSystemView methodsFor: 'displaying' stamp: 'RAA 6/14/2000 17:27'!makeMeVisible        | newLoc portRect |        ((Display boundingBox insetBy: (0@0 corner: self labelHeight asPoint))                containsPoint: self displayBox topLeft) ifTrue: [^ self "OK -- my top left is visible"].        "window not on screen (probably due to reframe) -- move it now"        newLoc := self isCollapsed                ifTrue: [RealEstateAgent assignCollapsePointFor: self]                ifFalse: [(RealEstateAgent initialFrameFor: self world: nil) topLeft].        portRect := newLoc + self labelOffset                                extent: self windowBox extent - self labelOffset.        self resizeTo: portRect.        self setLabelRegion.! !!StandardSystemView methodsFor: 'displaying'!uncacheBits	windowBits := nil.	bitsValid := false.! !!StandardSystemView methodsFor: 'framing' stamp: 'sr 3/26/2000 03:47'!chooseCollapsePoint	"Answer the point at which to place the collapsed window."	| pt labelForm beenDown offset |	labelForm := Form fromDisplay: self labelDisplayBox.	self uncacheBits.	self erase.	beenDown := Sensor anyButtonPressed.	self isCollapsed ifTrue:		[offset := self labelDisplayBox topLeft - self growBoxFrame topLeft.		labelForm follow: [pt := (Sensor cursorPoint + offset max: 0@0) truncateTo: 8]				while: [Sensor anyButtonPressed							ifTrue: [beenDown := true]							ifFalse: [beenDown not]].		^ pt].	^ (RealEstateAgent assignCollapseFrameFor: self) origin.! !!StandardSystemView methodsFor: 'framing'!chooseFrame	"Answer a new frame, depending on whether the view is currently 	collapsed or not."	| labelForm f |	self isCollapsed & expandedViewport notNil		ifTrue:			[labelForm := bitsValid				ifTrue: [windowBits]				ifFalse: [Form fromDisplay: self labelDisplayBox].			bitsValid := false.			self erase.			labelForm slideFrom: self labelDisplayBox origin					to: expandedViewport origin-self labelOffset					nSteps: 10.			^ expandedViewport]		ifFalse:			[f := self getFrame.			bitsValid := false.			self erase.			^ f topLeft + self labelOffset extent: f extent]! !!StandardSystemView methodsFor: 'framing'!chooseMoveRectangle	"Ask the user to designate a new window rectangle."	| offset p |	offset := Sensor anyButtonPressed "Offset if draggin, eg, label"		ifTrue: [self windowBox topLeft - Sensor cursorPoint]		ifFalse: [0@0].	self isCollapsed		ifTrue: [^ self labelDisplayBox newRectFrom:					[:f | p := Sensor cursorPoint + offset.					p := (p max: 0@0) truncateTo: 8.					p extent: f extent]]		ifFalse: [^ self windowBox newRectFrom:					[:f | p := Sensor cursorPoint + offset.					self constrainFrame: (p extent: f extent)]]! !!StandardSystemView methodsFor: 'framing' stamp: 'di 5/11/1999 22:09'!collapse	"If the receiver is not already collapsed, change its view to be that of its 	label only."	self isCollapsed ifFalse:			[model modelSleep.			(subViews ~~ nil and: [subViews size = 1 and: [subViews first isKindOf: MorphWorldView]])				ifTrue: [subViews first deEmphasizeView].			expandedViewport := self viewport.			savedSubViews := subViews.			self resetSubViews.			labelText isNil ifTrue: [self label: nil.  bitsValid := false.].			self window: (self inverseDisplayTransform:					((self labelDisplayBox topLeft extent: (labelText extent x + 70) @ self labelHeight)						 intersect: self labelDisplayBox))]! !!StandardSystemView methodsFor: 'framing'!collapseToPoint: collapsePoint	self collapse.	self align: self displayBox topLeft with: collapsePoint.	collapsedViewport := self viewport.	self displayEmphasized! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 10/20/1999 09:46'!expand	"If the receiver is collapsed, change its view to be that of all of its subviews, not its label alone."	| newFrame |	self isCollapsed		ifTrue:			[newFrame := self chooseFrame expandBy: borderWidth.			collapsedViewport := self viewport.			subViews := savedSubViews.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews := nil.			self setWindow: nil.			self resizeTo: newFrame.			self displayDeEmphasized.			model modelWakeUpIn: self]! !!StandardSystemView methodsFor: 'framing'!getFrame	"Ask the user to designate a rectangular area in which	the receiver should be displayed."	| minFrame |	minFrame := Cursor origin showWhile: 		[(Sensor cursorPoint extent: self minimumSize) newRectFrom:			[:f | Sensor cursorPoint extent: self minimumSize]].	self maximumSize <= self minimumSize ifTrue: [^ minFrame].	^ Cursor corner showWhile:		[minFrame newRectFrom:			[:f | self constrainFrame: (f origin corner: Sensor cursorPoint)]]! !!StandardSystemView methodsFor: 'framing' stamp: 'di 10/22/1998 16:15'!reframePanesAdjoining: subView along: side to: aDisplayBox 	| newBox delta newRect minDim theMin |	newRect := aDisplayBox.	theMin := 16.	"First check that this won't make any pane smaller than theMin screen dots"	minDim := ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])		collect: [:sub | sub displayBox adjustTo: newRect along: side])			inject: 999 into: [:was :rect | (was min: rect width) min: rect height].	"If so, amend newRect as required"	minDim < theMin ifTrue:		[delta := minDim - theMin.		newRect := newRect withSide: side setTo: 				((newRect perform: side) > (subView displayBox perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	subViews do:		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:			[newBox := sub displayBox adjustTo: newRect along: side.			sub window: sub window viewport:				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].	"And adjust the growing pane itself"	subView window: subView window viewport:			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.	"Finally force a recomposition of the whole window"	viewport := nil.	self resizeTo: self viewport.	self uncacheBits; displayEmphasized! !!StandardSystemView methodsFor: 'framing' stamp: 'BG 12/4/2003 13:14'!reframeTo: newFrame	"Reframe the receiver to the given screen rectangle.  	Repaint difference after the change.  "	| oldBox newBox portRect |	self uncacheBits.	oldBox := self windowBox.	portRect := newFrame topLeft + self labelOffset				corner: newFrame corner.	self setWindow: nil.	self resizeTo: portRect.	self setLabelRegion.	newBox := self windowBox.	(oldBox areasOutside: newBox) do:		[:rect | ScheduledControllers restore: rect].	self displayEmphasized! !!StandardSystemView methodsFor: 'framing'!resize	"Determine the rectangular area for the receiver, adjusted to the 	minimum and maximum sizes."	| f |	f := self getFrame.	self resizeTo: (f topLeft + self labelOffset extent: f extent)! !!StandardSystemView methodsFor: 'framing' stamp: 'di 4/6/98 15:12'!resizeMinimumCenteredAt: aPoint 	"Determine the rectangular area for the receiver, adjusted so that it is 	centered a position, aPoint."	| aRectangle |	aRectangle := 0 @ 0 extent: self minimumSize.	aRectangle := aRectangle align: aRectangle center with: aPoint.	self resizeTo: aRectangle! !!StandardSystemView methodsFor: 'framing' stamp: 'di 4/6/98 15:29'!resizeTo: aRectangle	"Resize this view to aRectangle"	"First get scaling right inside borders"	self window: (self window insetBy: borderWidth)		viewport: (aRectangle insetBy: borderWidth).	"Then ensure window maps to aRectangle"	window := transformation applyInverseTo: aRectangle! !!StandardSystemView methodsFor: 'initialize-release' stamp: 'sw 10/29/1999 12:58'!initialize 	"Refer to the comment in View|initialize."	super initialize.	labelFrame := Quadrangle new.	labelFrame region: (Rectangle origin: 0 @ 0 extent: 50 @ self labelHeight).	labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	self label: nil.	isLabelComplemented := false.	minimumSize := 50 @ 50.	maximumSize := Display extent.	collapsedViewport := nil.	expandedViewport := nil.	bitsValid := false.	updatablePanes := #()! !!StandardSystemView methodsFor: 'label access' stamp: 'sw 12/9/1999 17:44'!label: aString 	"Set aString to be the receiver's label."	labelText := Paragraph			withText: (Text string: ((aString == nil or: [aString isEmpty])								ifTrue: ['Untitled' copy]								ifFalse: [aString])							attributes: (Array with: TextEmphasis bold))			style: LabelStyle.	insetDisplayBox == nil ifTrue: [^ self].  "wait for further initialization"	self setLabelRegion! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/10/1998 13:18'!relabel: aString 	"A new string for the label.  Window is assumed to be active.	Window will redisplay only if label bar has to grow."	| oldRegion oldWidth |	(model windowReqNewLabel: aString) ifFalse: [^ self].	oldRegion := self labelTextRegion.	oldWidth := self insetDisplayBox width.	self label: aString.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized].! !!StandardSystemView methodsFor: 'label access' stamp: 'sumim 2/8/2002 14:36'!setLabelTo: aString 	"Force aString to be the new label of the receiver, bypassing any logic about whether it is acceptable and about propagating information about the change."	| oldRegion oldWidth |	self label: aString.	self controller isControlActive ifFalse: [^ self].	oldRegion := self labelTextRegion.	oldWidth := self insetDisplayBox width.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized]! !!StandardSystemView methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:49'!convertToCurrentVersion: varDict refStream: smartRefStrm		updatablePanes ifNil: [updatablePanes := #()].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!StandardSystemView methodsFor: 'size'!maximumSize: aPoint 	"Set the argument, aPoint, to be the maximum width and height of the 	receiver."	maximumSize := aPoint! !!StandardSystemView methodsFor: 'size'!minimumSize: aPoint 	"Set the argument, aPoint, to be the minimum width and height of the 	receiver."	minimumSize := aPoint! !!StandardSystemView methodsFor: 'updating' stamp: 'sw 10/29/1999 12:57'!setUpdatablePanesFrom: getSelectors	| aList aPane |	"Set my updatablePanes inst var to the list of panes which are list panes with the given get-list selectors.  Order is important here!!  Note that the method is robust in the face of panes not found, but a warning is printed in the transcript in each such case"	aList := OrderedCollection new.	getSelectors do:		[:sel | aPane := self subViewSatisfying:				[:pane | (pane isKindOf: PluggableListView) and: [pane getListSelector == sel]].			aPane				ifNotNil:					[aList add: aPane]				ifNil:					[Transcript cr; show: 'Warning: view ', sel, ' not found.']].	updatablePanes := aList asArray! !!StandardSystemView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:20'!updatablePanes	"Answer the list of panes, in order, which might be sent the #verifyContents message upon window activation or expansion."	^ updatablePanes ifNil: [updatablePanes := #()]! !!StandardSystemView methodsFor: 'private' stamp: 'di 10/21/1998 16:12'!subviewWithLongestSide: sideBlock near: aPoint 	| theSub theSide theLen box |	theLen := 0.	subViews do:		[:sub | box := sub insetDisplayBox.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[theSub := sub.				theSide := side.				theLen := len]]].	sideBlock value: theSide.	^ theSub! !!StandardSystemView class methodsFor: 'class initialization'!doCacheBits	"StandardSystemView doCacheBits - Enable fast window repaint feature"	CacheBits := true.	ScheduledControllers unCacheWindows.	ScheduledControllers restore! !!StandardSystemView class methodsFor: 'class initialization'!dontCacheBits	"StandardSystemView dontCacheBits - Disable fast window repaint feature.	Return true iff bits were cached, ie if space was been recovered"	CacheBits ifFalse: [^ false].	CacheBits := false.	ScheduledControllers unCacheWindows.	^ true! !!StandardSystemView class methodsFor: 'class initialization' stamp: 'nk 9/1/2004 10:26'!setLabelStyle	| aFont |	"StandardSystemView setLabelStyle"	aFont := Preferences windowTitleFont.	LabelStyle := TextStyle fontArray: { aFont }.	LabelStyle gridForFont: 1 withLead: 0! !!StandardViewer methodsFor: 'categories' stamp: 'sw 8/23/2002 14:56'!addCategoryViewerFor: categoryInfo atEnd: atEnd	"Add a category viewer for the given category info.  If atEnd is true, add it at the end, else add it just after the header morph"	| aViewer |	aViewer := self categoryViewerFor: categoryInfo.	atEnd		ifTrue:			[self addMorphBack: aViewer]		ifFalse:			[self addMorph: aViewer after: submorphs first].	aViewer establishContents.	self world ifNotNil: [self world startSteppingSubmorphsOf: aViewer].	self fitFlap! !!StandardViewer methodsFor: 'categories' stamp: 'sw 8/3/2001 18:22'!chooseLimitClass	"Put up a menu allowing the user to choose the most generic class to show"	| aMenu limitClass |	aMenu := MenuMorph new defaultTarget: self.	limitClass := self limitClass.	scriptedPlayer class withAllSuperclasses do:		[:aClass | 			aClass == ProtoObject				ifTrue:					[aMenu addLine].			aMenu add: aClass name selector: #setLimitClass: argument: aClass.			aClass == limitClass ifTrue:				[aMenu lastItem color: Color red].			aClass == limitClass ifTrue: [aMenu addLine]].	aMenu addTitle: 'Show only methodsimplemented at or above...'.  "heh heh -- somebody please find nice wording here!!"	aMenu popUpInWorld: self currentWorld! !!StandardViewer methodsFor: 'categories' stamp: 'ka 11/29/2005 20:53'!likelyCategoryToShow	"Choose a category to show based on what's already showing and on some predefined heuristics"	| possible all aCat currVocab |	all := (scriptedPlayer categoriesForViewer: self) asOrderedCollection.	possible := all copy.	currVocab := self currentVocabulary.	self categoryMorphs do: 			[:m | 			aCat := currVocab categoryWhoseTranslatedWordingIs: m currentCategory.			aCat ifNotNil: [possible remove: aCat wording ifAbsent: []]].	(possible includes: ScriptingSystem nameForInstanceVariablesCategory translated) ifTrue:		[^ ScriptingSystem nameForInstanceVariablesCategory].	(currVocab isEToyVocabulary) 		ifTrue: 			[(possible includes: ScriptingSystem nameForScriptsCategory translated) 				ifTrue: [^ ScriptingSystem nameForScriptsCategory]].	{'kedama' translated. #basic translated} 		do: [:preferred | (possible includes: preferred) ifTrue: [^ preferred]].	((scriptedPlayer isPlayerLike) 		and: [scriptedPlayer hasOnlySketchCostumes]) 			ifTrue: [(possible includes: #tests translated) ifTrue: [^#tests translated]].	{#'color & border' translated. #tests translated. #color translated. #flagging translated. #comparing translated.} 		do: [:preferred | (possible includes: preferred) ifTrue: [^ preferred]].	^ possible isEmpty ifFalse: [possible first] ifTrue: [all first]! !!StandardViewer methodsFor: 'categories' stamp: 'sw 8/3/2001 18:17'!limitClass	"Answer the limit class to use in this viewer"	| aClass |	(aClass := self valueOfProperty: #limitClass)  ifNotNil:		[^ aClass].	aClass := scriptedPlayer defaultLimitClassForVocabulary: self currentVocabulary.	self setProperty: #limitClass toValue: aClass.	^ aClass! !!StandardViewer methodsFor: 'categories' stamp: 'di 2/19/2001 10:39'!recreateCategories	"To change from old to new tiles"	| cats |	cats := self categoriesCurrentlyShowing.	self removeAllMorphsIn: self categoryMorphs.	cats do: [:cat | self addCategoryViewerFor: cat]! !!StandardViewer methodsFor: 'initialization' stamp: 'nk 9/2/2004 11:30'!addHeaderMorphWithBarHeight: anInteger includeDismissButton: aBoolean	"Add the header morph to the receiver, using anInteger as a guide for its height, and if aBoolean is true, include a dismiss buton for it"	| header aFont aButton aTextMorph nail wrpr costs headWrapper |	header := AlignmentMorph newRow color: self color muchLighter; wrapCentering: #center; cellPositioning: #leftCenter.	aFont := Preferences standardButtonFont.	aBoolean ifTrue:		[aButton := self tanOButton.		header addMorph: aButton.		aButton target: self;				actionSelector: #dismiss;				setBalloonText: 'remove this entire Viewer from the screendon''t worry -- nothing will be lost!!.' translated.		header addTransparentSpacerOfSize: 4@1].	aButton := IconicButton new borderWidth: 0;			labelGraphic: (ScriptingSystem formAtKey: #AddCategoryViewer); color: Color transparent; 			actWhen: #buttonDown;			target: self;			actionSelector: #addCategoryViewer;			setBalloonText: 'click here to addanother category pane' translated;			shedSelvedge.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 4@1.	costs := scriptedPlayer costumes.	costs ifNotNil:	[(costs size > 1 or: [costs size = 1 and: [costs first ~~ scriptedPlayer costume]]) ifTrue:		[header addUpDownArrowsFor: self.		(wrpr := header submorphs last) submorphs second setBalloonText: 'switch to previous costume' translated.			wrpr submorphs first  setBalloonText: 'switch to next costume' translated]].		nail := (self hasProperty: #noInteriorThumbnail)		ifFalse:			[ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume]		ifTrue:			[ImageMorph new image: Cursor menu].	nail on: #mouseDown send: #offerViewerMenuForEvt:morph: to: scriptedPlayer.	header addMorphBack: nail.	nail setBalloonText: 'click here to get a menuthat will allow you toadd a variable,tear off a tile, etc..' translated.	(self hasProperty: #noInteriorThumbnail)		ifFalse:			[nail borderWidth: 3; borderColor: #raised].	header addTransparentSpacerOfSize: 5@5."	aButton := SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'S' translated font: (aFont := StrikeFont familyName: #ComicBold size: 16);  color: Color transparent; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object' translated.		header addMorphBack: aButton.	header addTransparentSpacerOfSize: 8@5."		aButton := SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'v' translated font: (aFont emphasized: 1);  color: Color transparent; borderWidth: 1; actWhen: #buttonUp.	"aButton firstSubmorph color: Color gray."	aButton setBalloonText: 'click here to add a variableto this object.' translated.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 5@5.	self viewsMorph ifTrue: [scriptedPlayer costume assureExternalName].	aTextMorph := UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #nameForViewer;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	self viewsMorph ifTrue:		[aTextMorph putSelector: #setName:.		aTextMorph setProperty: #okToTextEdit toValue: true].	aTextMorph step.	header  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s name.' translated.		header beSticky.	anInteger > 0		ifTrue:			[headWrapper := AlignmentMorph newColumn color: self color.			headWrapper addTransparentSpacerOfSize: (0 @ anInteger).			headWrapper addMorphBack: header.			self addMorph: headWrapper]		ifFalse:			[self addMorph: header]! !!StandardViewer methodsFor: 'initialization' stamp: 'yo 8/18/2005 13:43'!initializeFor: aPlayer barHeight: anInteger includeDismissButton: aBoolean showCategories: categoryInfo	"Initialize the receiver to be a look inside the given Player.  The categoryInfo, if present, describes which categories should be present in it, in which order"	scriptedPlayer := aPlayer.	self listDirection: #topToBottom;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 1.	self color: self standardViewerColor.	self addHeaderMorphWithBarHeight: anInteger includeDismissButton: aBoolean.	categoryInfo isEmptyOrNil		ifFalse:  "Reincarnating an pre-existing list"			[categoryInfo do:				[:aCat | self addCategoryViewerFor: aCat]]		ifTrue:  "starting fresh"			[self addSearchPane. 			self addCategoryViewer.			self addCategoryViewer.			(scriptedPlayer costume isMemberOf: KedamaMorph) ifTrue: [self addCategoryViewer].		].! !!StandardViewer methodsFor: 'initialization' stamp: 'sw 6/4/2001 19:40'!useVocabulary: aVocabulary	"Make the receiver show categories and methods as dictated by aVocabulary"	| itsName |	((self valueOfProperty: #currentVocabularySymbol ifAbsent: [nil]) == (itsName := aVocabulary vocabularyName)) ifFalse:		[self setProperty: #currentVocabularySymbol toValue: itsName.		self removeProperty: #currentVocabulary.  "grandfathered"		(self submorphs select: [:m | m isKindOf: CategoryViewer]) do: [:m | m delete]]! !!StandardViewer methodsFor: 'macpal' stamp: 'sw 6/4/2001 18:05'!currentVocabulary	"Answer the vocabulary currently associated with the receiver"	| aSym aVocab |	aSym := self valueOfProperty: #currentVocabularySymbol ifAbsent: [nil].	aSym ifNil:		[aVocab := self valueOfProperty: #currentVocabulary ifAbsent: [nil].		aVocab ifNotNil:			[aSym := aVocab vocabularyName.			self removeProperty: #currentVocabulary.			self setProperty: #currentVocabularySymbol toValue: aSym]].	^ aSym		ifNotNil:			[Vocabulary vocabularyNamed: aSym]		ifNil:			[(self world ifNil: [ActiveWorld]) currentVocabularyFor: scriptedPlayer]! !!StandardViewer methodsFor: 'user interface' stamp: 'sw 10/25/1999 22:08'!dismiss	| aFlapTab |	"User hit the dismiss button."	(owner isKindOf: TabbedPalette)		ifTrue:			[^ owner showNoPalette].	(aFlapTab := self pasteUpMorph correspondingFlapTab) ifNotNil:		[^ aFlapTab dismissViaHalo].	self topRendererOrSelf delete! !!StandardViewer methodsFor: 'user interface' stamp: 'sw 5/18/2001 10:46'!openLexicon	"Open a lexicon browser on the receiver, showing its current vocabulary"	| littleHim | 	littleHim := scriptedPlayer assureUniClass.	(InstanceBrowser new useVocabulary: self currentVocabulary) openOnObject: littleHim  inWorld: ActiveWorld showingSelector: nil! !!StickynessBugz methodsFor: 'as yet unclassified' stamp: 'wiz 7/28/2007 18:54'!testForTiltedStickyness"self new testForTiltedStickyness""self run: #testForTiltedStickyness"| m |m := RectangleMorph new openCenteredInWorld .cases := Array with: m . "save for tear down."self assert: ( m topRendererOrSelf isSticky not ) .m beSticky .self assert: ( m topRendererOrSelf isSticky ) .m addFlexShell .cases := Array with: m topRendererOrSelf .m topRendererOrSelf rotationDegrees: 45.0 .self assert: ( m topRendererOrSelf isSticky ) .m beUnsticky .self assert: ( m topRendererOrSelf isSticky not ) .m topRendererOrSelf delete.^true ! !!StickynessBugz commentStamp: 'wiz 11/24/2006 00:24' prior: 0!A StickynessBugz is for mantis #5500 rectangles and ellipses don't act sticky when rotated even when they are..Instance Variables!!Stream methodsFor: 'accessing'!next: anInteger 	"Answer the next anInteger number of objects accessible by the receiver."	| aCollection |	aCollection := OrderedCollection new.	anInteger timesRepeat: [aCollection addLast: self next].	^aCollection! !!Stream methodsFor: 'accessing'!nextMatchAll: aColl    "Answer true if next N objects are the ones in aColl,     else false.  Advance stream of true, leave as was if false."    | save |    save := self position.    aColl do: [:each |       (self next) = each ifFalse: [            self position: save.            ^ false]        ].    ^ true! !!Stream methodsFor: 'accessing' stamp: 'ls 9/12/1998 20:55'!upToEnd	"answer the remaining elements in the string"	| elements |	elements := OrderedCollection new.	[ self atEnd ] whileFalse: [ 		elements add: self next ].	^elements! !!StretchyImageMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 16:20'!form: aForm	form := aForm! !!StretchyImageMorph methodsFor: 'drawing' stamp: 'nk 1/3/2004 17:40'!drawOn: aCanvas| t |"Smalltalk at: #Q4 put: OrderedCollection new."	form ifNil: [form := (Form extent: 32@32 depth: 8) fillColor: Color green].	(cache isNil or: [cache extent ~= bounds extent]) ifTrue: [		t := [cache := Form extent: bounds extent depth: form depth.		form displayInterpolatedIn: cache boundingBox on: cache.		cache := cache asFormOfDepth: aCanvas depth] timeToRun.		"Q4 add: {t. form. cache}."	].	aCanvas paintImage: cache at: bounds origin.! !!StrikeFont methodsFor: 'emphasis' stamp: 'rej 9/29/2007 09:02'!setupDefaultFallbackFont	"This used to be the default textstyle, but it needs to be a StrikeFont and not a TTCFont and sometimes the default textstyle is a TTCFont.  So, we use a typical StrikeFont as the default fallback font."	self fallbackFont: (StrikeFont defaultSized: self height).	self reset.! !!StrikeFont class methodsFor: 'accessing' stamp: 'rej 9/29/2007 08:50'!defaultSized: aNumber	| fonts f |	"This used to be the default textstyle, but it needs to be a StrikeFont and not a TTCFont and sometimes the default textstyle is a TTCFont.  So, we use a typical StrikeFont as the default fallback font."	fonts := (TextConstants at: #Accuny) fontArray.	f := fonts first.	1 to: fonts size do: [:i |		aNumber > (fonts at: i) height ifTrue: [f _ fonts at: i].	].	^f! !!StrikeFontSet methodsFor: 'testing' stamp: 'yo 2/12/2007 19:34'!isFontSet	^ true.! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!do: aBlock toFieldNumber: aNumber	"Considering the receiver as a holder of tab-delimited fields, evaluate aBlock on behalf of a field in this string"	| start end index |	start := 1.	index := 1.	[start <= self size] whileTrue: 		[end := self indexOf: Character tab startingAt: start ifAbsent: [self size + 1].		end := end - 1.		aNumber = index ifTrue:			[aBlock value: (self copyFrom: start  to: end).			^ self].		index := index + 1.		start := end + 2]"1 to: 6 do:	[:aNumber |		'fred	charlie	elmo		wimpy	friml' do:			[:aField | Transcript cr; show: aField] toFieldNumber: aNumber]"! !!String methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:12'!findAnySubStr: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."	| min ind |	min := self size + 1.	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"		delim isCharacter 			ifTrue: [ind := self indexOfSubCollection: (String with: delim) 						startingAt: start ifAbsent: [min]]			ifFalse: [ind := self indexOfSubCollection: delim 						startingAt: start ifAbsent: [min]].			min := min min: ind].	^ min! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findBetweenSubStrs: delimiters	"Answer the collection of String tokens that result from parsing self.  Tokens are separated by 'delimiters', which can be a collection of Strings, or a collection of Characters.  Several delimiters in a row are considered as just one separation."	| tokens keyStart keyStop |	tokens := OrderedCollection new.	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self skipAnySubStr: delimiters startingAt: keyStop.		keyStop := self findAnySubStr: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'yo 10/15/2003 15:32'!findLastOccuranceOfString: subString startingAt: start 	"Answer the index of the last occurance of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	| last now |	last := self findSubstring: subString in: self startingAt: start matchTable: CaseSensitiveOrder.	last = 0 ifTrue: [^ 0].	[last > 0] whileTrue: [		now := last.		last := self findSubstring: subString in: self startingAt: last + subString size matchTable: CaseSensitiveOrder.	].	^ now.! !!String methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:13'!findTokens: delimiters	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."	| tokens keyStart keyStop separators |	tokens := OrderedCollection new.	separators := delimiters isCharacter 		ifTrue: [Array with: delimiters]		ifFalse: [delimiters].	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self skipDelimiters: separators startingAt: keyStop.		keyStop := self findDelimiters: separators startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'dtl 8/14/2004 11:27'!findTokens: delimiters escapedBy: quoteDelimiters 	"Answer a collection of Strings separated by the delimiters, where  	delimiters is a Character or collection of characters. Two delimiters in a  	row produce an empty string (compare this to #findTokens, which  	treats sequential delimiters as one).  	 	The characters in quoteDelimiters are treated as quote characters, such  	that any delimiter within a pair of matching quoteDelimiter characters  	is treated literally, rather than as a delimiter.  	 	The quoteDelimiter characters may be escaped within a quoted string.  	Two sequential quote characters within a quoted string are treated as  	a single character.  	 	This method is useful for parsing comma separated variable strings for  	spreadsheet import and export."	| tokens rs activeEscapeCharacter ts char token delimiterChars quoteChars |	delimiterChars := (delimiters isNil				ifTrue: ['']				ifFalse: [delimiters]) asString.	quoteChars := (quoteDelimiters isNil				ifTrue: ['']				ifFalse: [quoteDelimiters]) asString.	tokens := OrderedCollection new.	rs := ReadStream on: self.	activeEscapeCharacter := nil.	ts := WriteStream on: ''.	[rs atEnd]		whileFalse: [char := rs next.			activeEscapeCharacter isNil				ifTrue: [(quoteChars includes: char)						ifTrue: [activeEscapeCharacter := char]						ifFalse: [(delimiterChars includes: char)								ifTrue: [token := ts contents.									tokens add: token.									ts := WriteStream on: '']								ifFalse: [ts nextPut: char]]]				ifFalse: [char == activeEscapeCharacter						ifTrue: [rs peek == activeEscapeCharacter								ifTrue: [ts nextPut: rs next]								ifFalse: [activeEscapeCharacter := nil]]						ifFalse: [ts nextPut: char]]].	token := ts contents.	(tokens isEmpty and: [token isEmpty])		ifFalse: [tokens add: token].	^ tokens! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findTokens: delimiters keep: keepers	"Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)"	| tokens keyStart keyStop |	tokens := OrderedCollection new.	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self skipDelimiters: delimiters startingAt: keyStop.		keyStop to: keyStart-1 do: [:ii | 			(keepers includes: (self at: ii)) ifTrue: [				tokens add: (self copyFrom: ii to: ii)]].	"Make this keeper be a token"		keyStop := self findDelimiters: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findWordStart: key startingAt: start	| ind |	"HyperCard style searching.  Answer the index in self of the substring key, when that key is preceeded by a separator character.  Must occur at or beyond start.  The match is case-insensitive.  If no match is found, zero will be returned."	ind := start.	[ind := self findSubstring: key in: self startingAt: ind matchTable: CaseInsensitiveOrder.	ind = 0 ifTrue: [^ 0].	"not found"	ind = 1 ifTrue: [^ 1].	"First char is the start of a word"	(self at: ind-1) isSeparator] whileFalse: [ind := ind + 1].	^ ind	"is a word start"! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:31'!indexOf: aCharacter  startingAt: start  ifAbsent: aBlock	| ans |	(aCharacter isCharacter) ifFalse: [ ^ aBlock value ].	ans := self class indexOfAscii: aCharacter asciiValue inString: self  startingAt: start.	ans = 0		ifTrue: [ ^ aBlock value ]		ifFalse: [ ^ ans ]! !!String methodsFor: 'accessing' stamp: 'nice 3/15/2007 21:03'!indexOfAnyOf: aCharacterSet startingAt: start ifAbsent: aBlock 	"returns the index of the first character in the given set, starting from start "		| ans |	ans := self isWideString				ifTrue: ["Fallback to naive implementation"					self class						findFirstInString: self						inCharacterSet: aCharacterSet						startingAt: start]				ifFalse: ["We know we contain only byte characters						So use a byteArrayMap opimized for primitive call"					self class						findFirstInString: self						inSet: aCharacterSet byteArrayMap						startingAt: start].	ans = 0		ifTrue: [^ aBlock value]		ifFalse: [^ ans]! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock	| index |	index := self findSubstring: sub in: self startingAt: start matchTable: CaseSensitiveOrder.	index = 0 ifTrue: [^ exceptionBlock value].	^ index! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!lastIndexOfPKSignature: aSignature	"Answer the last index in me where aSignature (4 bytes long) occurs, or 0 if not found"	| a b c d |	a := aSignature first.	b := aSignature second.	c := aSignature third.	d := aSignature fourth.	(self size - 3) to: 1 by: -1 do: [ :i |		(((self at: i) = a)			and: [ ((self at: i + 1) = b)				and: [ ((self at: i + 2) = c)					and: [ ((self at: i + 3) = d) ]]])						ifTrue: [ ^i ]	].	^0! !!String methodsFor: 'accessing' stamp: 'yo 12/17/2002 16:56'!leadingCharRunLengthAt: index	| leadingChar |	leadingChar := (self at: index) leadingChar.	index to: self size do: [:i |		(self at: i) leadingChar ~= leadingChar ifTrue: [^ i - index].	].	^ self size - index + 1.! !!String methodsFor: 'accessing' stamp: 'yo 8/27/2002 14:33'!lineCorrespondingToIndex: anIndex	"Answer a string containing the line at the given character position.  1/15/96 sw:  Inefficient first stab at this"	| cr aChar answer |	cr := Character cr.	answer := ''.	1 to: self size do:		[:i | 			aChar := self at: i.			aChar = cr				ifTrue:					[i > anIndex						ifTrue:							[^ answer]						ifFalse:							[answer := '']]				ifFalse:					[answer := answer copyWith: aChar]].	^ answer! !!String methodsFor: 'accessing' stamp: 'yo 8/27/2002 14:34'!lineCount	"Answer the number of lines represented by the receiver, where every cr adds one line.  5/10/96 sw"	| cr count |	cr := Character cr.	count := 1  min: self size..	1 to: self size do:		[:i | (self at: i) = cr ifTrue: [count := count + 1]].	^ count"'FredtheBear' lineCount"! !!String methodsFor: 'accessing' stamp: 'yo 8/27/2002 14:34'!lineNumber: anIndex	"Answer a string containing the characters in the given line number.  5/10/96 sw"	| crString pos finalPos |	crString := String with: Character cr.	pos := 0.	1 to: anIndex - 1 do:		[:i | pos := self findString: crString startingAt: pos + 1.			pos = 0 ifTrue: [^ nil]].	finalPos := self findString: crString startingAt: pos + 1.	finalPos = 0 ifTrue: [finalPos := self size + 1].	^ self copyFrom: pos + 1 to: finalPos - 1"'FredtheBear' lineNumber: 3"! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!linesDo: aBlock	"execute aBlock with each line in this string.  The terminating CR's are not included in what is passed to aBlock"	| start end |	start := 1.	[ start <= self size ] whileTrue: [		end := self indexOf: Character cr  startingAt: start  ifAbsent: [ self size + 1 ].		end := end - 1.		aBlock value: (self copyFrom: start  to: end).		start := end + 2. ].! !!String methodsFor: 'accessing' stamp: 'yo 8/28/2002 14:28'!skipAnySubStr: delimiters startingAt: start 	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."	| any this ind ii |	ii := start-1.	[(ii := ii + 1) <= self size] whileTrue: [ "look for char that does not match"		any := false.		delimiters do: [:delim |			delim isCharacter 				ifTrue: [(self at: ii) == delim ifTrue: [any := true]]				ifFalse: ["a substring"					delim size > (self size - ii + 1) ifFalse: "Here's where the one-off error was."						[ind := 0.						this := true.						delim do: [:dd | 							dd == (self at: ii+ind) ifFalse: [this := false].							ind := ind + 1].						this ifTrue: [ii := ii + delim size - 1.  any := true]]							ifTrue: [any := false] "if the delim is too big, it can't match"]].		any ifFalse: [^ ii]].	^ self size + 1! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!tabDelimitedFieldsDo: aBlock	"Considering the receiver as a holder of tab-delimited fields, evaluate execute aBlock with each field in this string.  The separatilng tabs are not included in what is passed to aBlock"	| start end |	"No senders but was useful enough in earlier work that it's retained for the moment."	start := 1.	[start <= self size] whileTrue: 		[end := self indexOf: Character tab startingAt: start ifAbsent: [self size + 1].		end := end - 1.		aBlock value: (self copyFrom: start  to: end).		start := end + 2]"'fred	charlie	elmo		2' tabDelimitedFieldsDo: [:aField | Transcript cr; show: aField]"! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!alike: aString 	"Answer some indication of how alike the receiver is to the argument,  0 is no match, twice aString size is best score.  Case is ignored."	| i j k minSize bonus |	minSize := (j := self size) min: (k := aString size).	bonus := (j - k) abs < 2 ifTrue: [ 1 ] ifFalse: [ 0 ].	i := 1.	[(i <= minSize) and: [((super at: i) bitAnd: 16rDF)  = ((aString at: i) asciiValue bitAnd: 16rDF)]]		whileTrue: [ i := i + 1 ].	[(j > 0) and: [(k > 0) and:		[((super at: j) bitAnd: 16rDF) = ((aString at: k) asciiValue bitAnd: 16rDF)]]]			whileTrue: [ j := j - 1.  k := k - 1. ].	^ i - 1 + self size - j + bonus. ! !!String methodsFor: 'comparing' stamp: 'yo 8/27/2002 14:15'!charactersExactlyMatching: aString	"Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly."	| count |	count := self size min: aString size.	1 to: count do: [:i | 		(self at: i) = (aString at: i) ifFalse: [			^ i - 1]].	^ count! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!endsWith: suffix	"Answer whether the tail end of the receiver is the same as suffix.	The comparison is case-sensitive."	| extra |	(extra := self size - suffix size) < 0 ifTrue: [^ false].	^ (self findSubstring: suffix in: self startingAt: extra + 1			matchTable: CaseSensitiveOrder) > 0"  'Elvis' endsWith: 'vis'"! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!howManyMatch: string 	"Count the number of characters that match up in self and aString."	| count shorterLength |		count  :=  0 .	shorterLength  :=  ((self size ) min: (string size ) ) .	(1 to: shorterLength  do: [:index |		 (((self at: index ) = (string at: index )  ) ifTrue: [count  :=  (count + 1 ) .			]   ).		]   ).	^  count 		! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!startingAt: keyStart match: text startingAt: textStart	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	| anyMatch matchStart matchEnd i matchStr j ii jj |	i := keyStart.	j := textStart.	"Check for any #'s"	[i > self size ifTrue: [^ j > text size "Empty key matches only empty string"].	(self at: i) = $#] whileTrue:		["# consumes one char of key and one char of text"		j > text size ifTrue: [^ false "no more text"].		i := i+1.  j := j+1].	"Then check for *"	(self at: i) = $*		ifTrue: [i = self size ifTrue:					[^ true "Terminal * matches all"].				"* means next match string can occur anywhere"				anyMatch := true.				matchStart := i + 1]		ifFalse: ["Otherwise match string must occur immediately"				anyMatch := false.				matchStart := i].	"Now determine the match string"	matchEnd := self size.	(ii := self indexOf: $* startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '** not valid -- use * instead'].		matchEnd := ii-1].	(ii := self indexOf: $# startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '*# not valid -- use #* instead'].		matchEnd := matchEnd min: ii-1].	matchStr := self copyFrom: matchStart to: matchEnd.	"Now look for the match string"	[jj := text findString: matchStr startingAt: j caseSensitive: false.	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]		whileTrue:		["Found matchStr at jj.  See if the rest matches..."		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:			[^ true "the rest matches -- success"].		"The rest did not match."		anyMatch ifFalse: [^ false].		"Preceded by * -- try for a later match"		j := j+1].	^ false "Failed to find the match string"! !!String methodsFor: 'converting' stamp: 'ar 4/10/2005 17:18'!asByteArray	"Convert to a ByteArray with the ascii values of the string."	| b |	b := ByteArray new: self byteSize.	1 to: self size * 4 do: [:i |		b at: i put: (self byteAt: i).	].	^ b.! !!String methodsFor: 'converting' stamp: 'ar 4/12/2005 13:55'!asFileName	"Answer a String made up from the receiver that is an acceptable file 	name."	| string checkedString |	string := FileDirectory checkName: self fixErrors: true.	checkedString := (FilePath pathName: string) asVmPathName.	^ (FilePath pathName: checkedString isEncoded: true) asSqueakPathName.! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 14:38'!asFourCode	| result |	self size = 4 ifFalse: [^self error: 'must be exactly four characters'].	result := self inject: 0 into: [:val :each | 256 * val + each asciiValue].	(result bitAnd: 16r80000000) = 0 		ifFalse: [self error: 'cannot resolve fourcode'].	(result bitAnd: 16r40000000) = 0 ifFalse: [^result - 16r80000000].	^ result! !!String methodsFor: 'converting' stamp: 'yo 8/26/2002 23:06'!asHex	| stream |	stream := WriteStream on: (String new: self size * 4).	self do: [ :ch | stream nextPutAll: ch hex ].	^stream contents! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asHtml	"Do the basic character conversion for HTML.  Leave all original return 	and tabs in place, so can conver back by simply removing bracked 	things. 4/4/96 tk"	| temp |	temp := self copyReplaceAll: '&' with: '&amp;'.	HtmlEntities keysAndValuesDo:		[:entity :char |		char = $& ifFalse:			[temp := temp copyReplaceAll: char asString with: '&' , entity , ';']].	temp := temp copyReplaceAll: '	' with: '	<IMG SRC="tab.gif" ALT="    ">'.	temp := temp copyReplaceAll: '' with: '<BR>'.	^ temp"	'A<&>B' asHtml"! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asIdentifier: shouldBeCapitalized	"Return a legal identifier, with first character in upper case if shouldBeCapitalized is true, else lower case.  This will always return a legal identifier, even for an empty string"	| aString firstChar firstLetterPosition |	aString := self select: [:el | el isAlphaNumeric].	firstLetterPosition := aString findFirst: [:ch | ch isLetter].	aString := firstLetterPosition == 0		ifFalse:			[aString copyFrom: firstLetterPosition to: aString size]		ifTrue:			['a', aString].	firstChar := shouldBeCapitalized ifTrue: [aString first asUppercase] ifFalse: [aString first asLowercase].	^ firstChar asString, (aString copyFrom: 2 to: aString size)"'234Fred987' asIdentifier: false'235Fred987' asIdentifier: true'' asIdentifier: true'()87234' asIdentifier: false'())z>=PPve889  U >' asIdentifier: false"! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asLegalSelector	| toUse |	toUse := ''.	self do:		[:char | char isAlphaNumeric ifTrue: [toUse := toUse copyWith: char]].	(self size == 0 or: [self first isLetter not])		ifTrue:		[toUse := 'v', toUse].	^ toUse withFirstCharacterDownshifted"'234znak 43 ) 2' asLegalSelector"! !!String methodsFor: 'converting' stamp: 'ar 4/10/2005 20:55'!asOctetString	"Convert the receiver into an octet string"	| string |	string := String new: self size.	1 to: self size do: [:i | string at: i put: (self at: i)].	^string! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 14:39'!asPacked	"Convert to a longinteger that describes the string"	^ self inject: 0 into: [ :pack :next | pack := pack * 256 + next asInteger ].! !!String methodsFor: 'converting' stamp: 'dc 8/1/2007 16:02'!asSignedInteger	"Returns the first signed integer it can find or nil."	| start stream |	start := self findFirst: [:char | char isDigit].	start isZero ifTrue: [^ nil].	stream := (ReadStream on: self) position: start.	stream oldBack = $- ifTrue: [stream oldBack].	^ Integer readFrom: stream! !!String methodsFor: 'converting' stamp: 'edc 4/23/2007 09:38'!asUnHtml	"Strip out all Html stuff (commands in angle brackets <>) and convertthe characters &<> back to their real value.  Leave actual cr and tab asthey were in text."	| in out char rest did |	in := ReadStream on: self.	out := WriteStream on: (String new: self size).	[in atEnd] whileFalse:		[in peek = $<			ifTrue: [in unCommand] 	"Absorb <...><...>"			ifFalse: [(char := in next) = $&						ifTrue: [rest := in upTo: $;.								did := out position.								rest = 'lt' ifTrue: [out nextPut: $<].								rest = 'gt' ifTrue: [out nextPut: $>].								rest = 'amp' ifTrue: [out nextPut: $&].								rest = 'deg' ifTrue: [out nextPut: $°].								rest = 'quot' ifTrue: [out nextPut: $"].								rest = 'nbsp' ifTrue: [out nextPut: Character space].								did = out position ifTrue: [									self error: 'unknown encoded HTML char'.									"Please add it to this method"]]						ifFalse: [out nextPut: char]].		].	^ out contents! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap := self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!compressWithTable: tokens	"Return a string with all substrings that occur in tokens replaced	by a character with ascii code = 127 + token index.	This will work best if tokens are sorted by size.	Assumes this string contains no characters > 127, or that they	are intentionally there and will not interfere with this process."	| str null finalSize start result ri c ts |	null := Character value: 0.	str := self copyFrom: 1 to: self size.  "Working string will get altered"	finalSize := str size.	tokens doWithIndex:		[:token :tIndex |		start := 1.		[(start := str findString: token startingAt: start) > 0]			whileTrue:			[ts := token size.			((start + ts) <= str size				and: [(str at: start + ts) = $  and: [tIndex*2 <= 128]])				ifTrue: [ts := token size + 1.  "include training blank"						str at: start put: (Character value: tIndex*2 + 127)]				ifFalse: [str at: start put: (Character value: tIndex + 127)].			str at: start put: (Character value: tIndex + 127).			1 to: ts-1 do: [:i | str at: start+i put: null].			finalSize := finalSize - (ts - 1).			start := start + ts]].	result := String new: finalSize.	ri := 0.	1 to: str size do:		[:i | (c := str at: i) = null ifFalse: [result at: (ri := ri+1) put: c]].	^ result! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!contractTo: smallSize	"return myself or a copy shortened by ellipsis to smallSize"	| leftSize |	self size <= smallSize		ifTrue: [^ self].  "short enough"	smallSize < 5		ifTrue: [^ self copyFrom: 1 to: smallSize].    "First N characters"	leftSize := smallSize-2//2.	^ self copyReplaceFrom: leftSize+1		"First N/2 ... last N/2"		to: self size - (smallSize - leftSize - 3)		with: '...'"	'A clear but rather long-winded summary' contractTo: 18"! !!String methodsFor: 'converting' stamp: 'yo 7/8/2004 12:02'!convertFromWithConverter: converter	| readStream writeStream c |	readStream := self readStream.	writeStream := String new writeStream.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		c := converter nextFromStream: readStream.		c ifNotNil: [writeStream nextPut: c] ifNil: [^ writeStream contents]	].	^ writeStream contents! !!String methodsFor: 'converting' stamp: 'ar 4/12/2005 14:01'!convertToSystemString	| readStream writeStream converter |	readStream := self readStream.	writeStream := String new writeStream.	converter := LanguageEnvironment defaultSystemConverter.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		converter nextPut: readStream next toStream: writeStream	].	converter emitSequenceToResetStateIfNeededOn: writeStream.	^ writeStream contents.! !!String methodsFor: 'converting' stamp: 'yo 7/8/2004 12:01'!convertToWithConverter: converter	| readStream writeStream |	readStream := self readStream.	writeStream := String new writeStream.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		converter nextPut: readStream next toStream: writeStream	].	converter emitSequenceToResetStateIfNeededOn: writeStream.	^ writeStream contents.! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!correctAgainst: wordList	"Correct the receiver: assume it is a misspelled word and return the (maximum of five) nearest words in the wordList.  Depends on the scoring scheme of alike:"	| results |	results := self correctAgainst: wordList continuedFrom: nil.	results := self correctAgainst: nil continuedFrom: results.	^ results! !!String methodsFor: 'converting' stamp: 'yo 7/29/2005 16:03'!encodeForHTTPWithTextEncoding: encodingName conditionBlock: conditionBlock	"change dangerous characters to their %XX form, for use in HTTP transactions"	| httpSafeStream encodedStream cont |	httpSafeStream := WriteStream on: (String new).	encodedStream := MultiByteBinaryOrTextStream on: (String new: 6).	encodedStream converter: (TextConverter newForEncoding: encodingName).	self do: [:c |		(conditionBlock value: c)			ifTrue: [httpSafeStream nextPut: (Character value: c charCode)]			ifFalse: [				encodedStream text; reset.				encodedStream nextPut: c.				encodedStream position: 0.				encodedStream binary.				cont := encodedStream contents.				cont do: [:byte |					httpSafeStream nextPut: $%.					httpSafeStream nextPut: (byte // 16) asHexDigit.					httpSafeStream nextPut: (byte \\ 16) asHexDigit.				].			].	].	^ httpSafeStream contents.! !!String methodsFor: 'converting' stamp: 'yo 7/5/2004 16:48'!findSelector	"Dan's code for hunting down selectors with keyword parts; while this doesn't give a true parse, in most cases it does what we want, in where it doesn't, we're none the worse for it."	| sel possibleParens level n |	sel := self withBlanksTrimmed.	(sel includes: $:) ifTrue:		[sel := sel copyReplaceAll: ':' with: ': '.	"for the style (aa max:bb) with no space"		possibleParens := sel findTokens: Character separators.		sel := self class streamContents:			[:s | level := 0.			possibleParens do:				[:token |				(level = 0 and: [token endsWith: ':'])					ifTrue: [s nextPutAll: token]					ifFalse: [(n := token occurrencesOf: $( ) > 0 ifTrue: [level := level + n].							(n := token occurrencesOf: $[ ) > 0 ifTrue: [level := level + n].							(n := token occurrencesOf: $] ) > 0 ifTrue: [level := level - n].							(n := token occurrencesOf: $) ) > 0 ifTrue: [level := level - n]]]]].	sel isEmpty ifTrue: [^ nil].	sel isOctetString ifTrue: [sel := sel asOctetString].	Symbol hasInterned: sel ifTrue:		[:aSymbol | ^ aSymbol].	^ nil! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!initialIntegerOrNil	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"	| firstNonDigit |	(self size == 0 or: [self first isDigit not]) ifTrue: [^ nil].	firstNonDigit := (self findFirst: [:m | m isDigit not]).	firstNonDigit = 0 ifTrue: [firstNonDigit := self size + 1].	^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber"'234Whoopie' initialIntegerOrNil'wimpy' initialIntegerOrNil'234' initialIntegerOrNil'2N' initialIntegerOrNil'2' initialIntegerOrNil'  89Ten ' initialIntegerOrNil'78 92' initialIntegerOrNil"! !!String methodsFor: 'converting' stamp: 'dc 4/10/2007 09:36'!keywords	"Answer an array of the keywords that compose the receiver."	| kwd char keywords |	keywords := Array streamContents:		[:kwds | kwd := WriteStream on: (String new: 16).		1 to: self size do:			[:i |			kwd nextPut: (char := self at: i).			char = $: ifTrue: 					[kwds nextPut: kwd contents.					kwd reset]].		(kwd position = 0) ifFalse: [kwds nextPut: kwd contents]].	(keywords size >= 1 and: [(keywords at: 1) = ':']) ifTrue:		["Has an initial keyword, as in #:if:then:else:"		keywords := keywords allButFirst].	(keywords size >= 2 and: [(keywords at: keywords size - 1) = ':']) ifTrue:		["Has a final keyword, as in #nextPut::andCR"		keywords := keywords copyReplaceFrom: keywords size - 1								to: keywords size with: {':' , keywords last}].	^ keywords! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!romanNumber	| value v1 v2 |	value := v1 := v2 := 0.	self reverseDo:		[:each |		v1 := #(1 5 10 50 100 500 1000) at: ('IVXLCDM' indexOf: each).		v1 >= v2			ifTrue: [value := value + v1]			ifFalse: [value := value - v1].		v2 := v1].	^ value! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!sansPeriodSuffix	"Return a copy of the receiver up to, but not including, the first period.  If the receiver's *first* character is a period, then just return the entire receiver. "	| likely |	likely := self copyUpTo: $..	^ likely size == 0		ifTrue:	[self]		ifFalse:	[likely]! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 11:13'!splitInteger	"Answer an array that is a splitting of self into a string and an integer.	'43Sam' ==> #(43 'Sam').  'Try90' ==> #('Try' 90)	BUT NOTE: 'Sam' ==> #('Sam' 0), and '90' ==> #('' 90)  ie, (<string> <integer>)."	| pos |	(pos := self findFirst: [:d | d isDigit not]) = 0 ifTrue: [^ Array with: '' with: self asNumber].	self first isDigit ifTrue: [		^ Array with: (self copyFrom: 1 to: pos - 1) asNumber 				with: (self copyFrom: pos to: self size)].	(pos := self findFirst: [:d | d isDigit]) = 0 ifTrue: [^ Array with: self with: 0].	^ Array with: (self copyFrom: 1 to: pos - 1)			with: (self copyFrom: pos to: self size) asNumber! !!String methodsFor: 'converting' stamp: 'ar 6/3/2007 18:32'!squeakToUtf8	"Convert the receiver into a UTF8-encoded string"	^self convertToWithConverter: UTF8TextConverter new.! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!stemAndNumericSuffix	"Parse the receiver into a string-valued stem and a numeric-valued suffix.  6/7/96 sw"	| stem suffix position |	stem := self.	suffix := 0.	position := 1.	[stem endsWithDigit and: [stem size > 1]] whileTrue:		[suffix :=  stem last digitValue * position + suffix.		position := position * 10.		stem := stem copyFrom: 1 to: stem size - 1].	^ Array with: stem with: suffix"'Fred2305' stemAndNumericSuffix"! !!String methodsFor: 'converting' stamp: 'ar 7/21/2007 21:50'!substrings	"Answer an array of the substrings that compose the receiver."	| result end beginning |	result := WriteStream on: (Array new: 10).	end := 0.	"find one substring each time through this loop"	[ "find the beginning of the next substring"	beginning := end+1.	[beginning <= self size and:[(self at: beginning) isSeparator]]		whileTrue:[beginning := beginning + 1].	beginning <= self size] whileTrue: [		"find the end"		end := beginning.		[end <= self size and:[(self at: end) isSeparator not]]			whileTrue:[end := end + 1].		end := end - 1.		result nextPut: (self copyFrom: beginning to: end).	].	^result contents! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 11:20'!unparenthetically	"If the receiver starts with (..( and ends with matching )..), strip them"	| curr |	curr := self.	[((curr first = $() and: [curr last = $)])] whileTrue:		[curr := curr copyFrom: 2 to: (curr size - 1)].	^ curr"'((fred the bear))' unparenthetically"		! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!unzipped	| magic1 magic2 |	magic1 := (self at: 1) asInteger.	magic2 := (self at: 2) asInteger.	(magic1 = 16r1F and:[magic2 = 16r8B]) ifFalse:[^self].	^(GZipReadStream on: self) upToEnd! !!String methodsFor: 'converting' stamp: 'ar 6/3/2007 18:32'!utf8ToSqueak	"Convert the receiver from a UTF8-encoded string"	^self convertFromWithConverter: UTF8TextConverter new.! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!withBlanksCondensed	"Return a copy of the receiver with leading/trailing blanks removed	 and consecutive white spaces condensed."	| trimmed lastBlank |	trimmed := self withBlanksTrimmed.	^String streamContents: [:stream |		lastBlank := false.		trimmed do: [:c | (c isSeparator and: [lastBlank]) ifFalse: [stream nextPut: c].			lastBlank := c isSeparator]].	" ' abc  d   ' withBlanksCondensed"! !!String methodsFor: 'converting' stamp: 'yo 7/5/2004 16:43'!withBlanksTrimmed	"Return a copy of the receiver from which leading and trailing blanks have been trimmed."	| first result |	first := self findFirst: [:c | c isSeparator not].	first = 0 ifTrue: [^ ''].  "no non-separator character"	result :=  self		copyFrom: first		to: (self findLast: [:c | c isSeparator not]).	result isOctetString ifTrue: [^ result asOctetString] ifFalse: [^ result].	" ' abc  d   ' withBlanksTrimmed"! !!String methodsFor: 'converting' stamp: 'md 9/19/2004 15:19'!withFirstCharacterDownshifted	"Return a copy with the first letter downShifted"		| answer |		self ifEmpty: [^ self copy].	answer := self copy.	answer at: 1 put: (answer at: 1) asLowercase.	^ answer. ! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	| listOfLines currentLast currentStart resultString putativeLast putativeLine crPosition |	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	listOfLines := OrderedCollection new.	currentLast := 0.	[currentLast < self size] whileTrue:		[currentStart := currentLast + 1.		putativeLast := (currentStart + aNumber - 1) min: self size.		putativeLine := self copyFrom: currentStart to: putativeLast.		(crPosition := putativeLine indexOf: Character cr) > 0 ifTrue:			[putativeLast := currentStart + crPosition - 1.			putativeLine := self copyFrom: currentStart to: putativeLast].		currentLast := putativeLast == self size			ifTrue:				[putativeLast]			ifFalse:				[currentStart + putativeLine lastSpacePosition - 1].		currentLast <= currentStart ifTrue:			["line has NO spaces; baleout!!"			currentLast := putativeLast].		listOfLines add: (self copyFrom: currentStart to: currentLast) withBlanksTrimmed].	listOfLines size > 0 ifFalse: [^ ''].	resultString := listOfLines first.	2 to: listOfLines size do:		[:i | resultString := resultString, String cr, (listOfLines at: i)].	^ resultString"#(5 7 20) collect:	[:i | 'Fred the bear went down to the brook to read his book in silence' withNoLineLongerThan: i]"! !!String methodsFor: 'converting' stamp: 'tak 4/25/2004 12:57'!withSeparatorsCompacted	"replace each sequences of whitespace by a single space character"	"' test ' withSeparatorsCompacted = ' test '"	"' test test' withSeparatorsCompacted = ' test test'"	"'test test		' withSeparatorsCompacted = 'test test '"	| out in next isSeparator |	self isEmpty ifTrue: [^ self].	out := WriteStream on: (String new: self size).	in := self readStream.	isSeparator := [:char | char asciiValue < 256				and: [CSSeparators includes: char]].	[in atEnd] whileFalse: [		next := in next.		(isSeparator value: next)			ifTrue: [				out nextPut: $ .				[in atEnd or:					[next := in next.					(isSeparator value: next)						ifTrue: [false]						ifFalse: [out nextPut: next. true]]] whileFalse]			ifFalse: [out nextPut: next]].	^ out contents! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 14:06'!withoutLeadingDigits	"Answer the portion of the receiver that follows any leading series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstNonDigit |	firstNonDigit := (self findFirst: [:m | m isDigit not and: [m ~= $ ]]).	^ firstNonDigit > 0		ifTrue:			[self copyFrom: firstNonDigit  to: self size]		ifFalse:			['']"'234Whoopie' withoutLeadingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!withoutTrailingBlanks	"Return a copy of the receiver from which trailing blanks have been trimmed."	| last |	last := self findLast: [:c | c isSeparator not].	last = 0 ifTrue: [^ ''].  "no non-separator character"	^ self copyFrom: 1 to: last	" ' abc  d   ' withoutTrailingBlanks"! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 14:06'!withoutTrailingDigits	"Answer the portion of the receiver that precedes any trailing series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstDigit |	firstDigit := (self findFirst: [:m | m isDigit or: [m = $ ]]).	^ firstDigit > 0		ifTrue:			[self copyFrom: 1 to: firstDigit-1]		ifFalse:			[self]"'Whoopie234' withoutTrailingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!String methodsFor: 'converting' stamp: 'dgd 11/26/2005 21:19'!zipped	| stream gzstream |	stream := RWBinaryOrTextStream on: String new.	gzstream := GZipWriteStream on: stream.	gzstream nextPutAll: self.	gzstream close.	stream reset.	^ stream contents.! !!String methodsFor: 'encoding' stamp: 'ar 4/10/2005 17:17'!putInteger32: anInteger at: location	| integer |	<primitive: 'putInteger' module: 'IntegerPokerPlugin'>	"IntegerPokerPlugin doPrimitive: #putInteger"	"the following is close to 20x faster than the above if the primitive is not compiled"	"PUTCOUNTER := PUTCOUNTER + 1."	integer := anInteger.	integer < 0 ifTrue: [integer :=  1073741824 - integer. ].	self at: location+3 put: (Character value: (integer \\ 256)).	self at: location+2 put: (Character value: (integer bitShift: -8) \\ 256).	self at: location+1 put: (Character value: (integer bitShift: -16) \\ 256).	self at: location put: (Character value: (integer bitShift: -24) \\ 256)."Smalltalk at: #PUTCOUNTER put: 0"! !!String methodsFor: 'encoding' stamp: 'ar 4/10/2005 17:18'!writeLeadingCharRunsOn: stream	| runLength runValues runStart leadingChar |	self isEmpty ifTrue: [^ self].	runLength := OrderedCollection new.	runValues := OrderedCollection new.	runStart := 1.	leadingChar := (self at: runStart) leadingChar.	2 to: self size do: [:index |		(self at: index) leadingChar = leadingChar ifFalse: [			runValues add: leadingChar.			runLength add: (index - runStart).			leadingChar := (self at: index) leadingChar.			runStart := index.		].	].	runValues add: (self last) leadingChar.	runLength add: self size + 1 -  runStart.	stream nextPut: $(.	runLength do: [:rr | rr printOn: stream. stream space].	stream skip: -1; nextPut: $).	runValues do: [:vv | vv printOn: stream. stream nextPut: $,].	stream skip: -1.! !!String methodsFor: 'internet' stamp: 'yo 12/28/2003 01:17'!decodeMimeHeader	"See RFC 2047, MIME Part Three: Message Header Extension for Non-ASCII  	Text. Text containing non-ASCII characters is encoded by the sequence  	=?character-set?encoding?encoded-text?=  	Encoding is Q (quoted printable) or B (Base64), handled by  	Base64MimeConverter / RFC2047MimeConverter.	Thanks to Yokokawa-san, it works in m17n package.  Try the following:	'=?ISO-2022-JP?B?U1dJS0lQT1AvGyRCPUJDKyVpJXMlQRsoQi8=?= =?ISO-2022-JP?B?GyRCJVElRiUjJSobKEIoUGF0aW8p?=' decodeMimeHeader."	| input output temp charset decoder encodedStream encoding pos |	input := ReadStream on: self.	output := WriteStream on: String new.	[output		nextPutAll: (input upTo: $=).	"ASCII Text"	input atEnd]		whileFalse: [(temp := input next) = $?				ifTrue: [charset := input upTo: $?.					encoding := (input upTo: $?) asUppercase.					temp := input upTo: $?.					input next.					"Skip final ="					(charset isNil or: [charset size = 0]) ifTrue: [charset := 'LATIN-1'].					encodedStream := MultiByteBinaryOrTextStream on: String new encoding: charset.					decoder := encoding = 'B'								ifTrue: [Base64MimeConverter new]								ifFalse: [RFC2047MimeConverter new].					decoder						mimeStream: (ReadStream on: temp);						 dataStream: encodedStream;						 mimeDecode.					output nextPutAll: encodedStream reset contents.					pos := input position.					input skipSeparators.					"Delete spaces if followed by ="					input peek = $=						ifFalse: [input position: pos]]				ifFalse: [output nextPut: $=;						 nextPut: temp]].	^ output contents! !!String methodsFor: 'internet' stamp: 'yo 11/3/2004 19:24'!isoToUtf8	"Convert ISO 8559-1 to UTF-8"	| s v |	s := WriteStream on: (String new: self size).	self do: [:c |		v := c asciiValue.		(v > 128)			ifFalse: [s nextPut: c]			ifTrue: [				s nextPut: (192+(v >> 6)) asCharacter.				s nextPut: (128+(v bitAnd: 63)) asCharacter]].	^s contents. ! !!String methodsFor: 'internet' stamp: 'yo 11/3/2004 19:24'!utf8ToIso	"Only UTF-8 characters that maps to 8-bit ISO-8559-1 values are converted. Others raises an error"	| s i c v c2 v2 |	s := WriteStream on: (String new: self size).		i := 1.	[i <= self size] whileTrue: [		c := self at: i. i:=i+1.		v := c asciiValue.		(v > 128)			ifFalse: [ s nextPut: c ]			ifTrue: [((v bitAnd: 252) == 192)				ifFalse: [self error: 'illegal UTF-8 ISO character']				ifTrue: [					(i > self size) ifTrue: [ self error: 'illegal end-of-string, expected 2nd byte of UTF-8'].					c2 := self at: i. i:=i+1.					v2 := c2 asciiValue.					((v2 bitAnd: 192) = 128) ifFalse: [self error: 'illegal 2nd UTF-8 char']. 					s nextPut: ((v2 bitAnd: 63) bitOr: ((v << 6) bitAnd: 192)) asCharacter]]].	^s contents. ! !!String methodsFor: 'internet' stamp: 'yo 11/3/2004 19:24'!withInternetLineEndings	"change line endings from CR's to CRLF's.  This is probably inprepration for sending a string over the Internet"	| cr lf |	cr := Character cr.	lf := Character linefeed.	^self class streamContents: [ :stream |		self do: [ :c |			stream nextPut: c.			c = cr ifTrue:[ stream nextPut: lf ]. ] ].! !!String methodsFor: 'internet' stamp: 'yo 11/3/2004 19:24'!withSqueakLineEndings	"assume the string is textual, and that CR, LF, and CRLF are all 	valid line endings.  Replace each occurence with a single CR"	| cr lf input c crlf inPos outPos outString lineEndPos newOutPos |	cr := Character cr.	lf := Character linefeed.	crlf := CharacterSet new.	crlf add: cr; add: lf.	inPos := 1.	outPos := 1.	outString := String new: self size.	[ lineEndPos := self indexOfAnyOf: crlf startingAt: inPos ifAbsent: [0].		lineEndPos ~= 0 ] whileTrue: [			newOutPos := outPos + (lineEndPos - inPos + 1).			outString replaceFrom: outPos to: newOutPos - 2 with: self startingAt: inPos.			outString at: newOutPos-1 put: cr.			outPos := newOutPos.			((self at: lineEndPos) = cr and: [ lineEndPos < self size and: [ (self at: lineEndPos+1) = lf ] ]) ifTrue: [				"CRLF ending"				inPos := lineEndPos + 2 ]			ifFalse: [ 				"CR or LF ending"				inPos := lineEndPos + 1 ]. ].	"no more line endings.  copy the rest"	newOutPos := outPos + (self size - inPos + 1).	outString replaceFrom: outPos to: newOutPos-1 with: self startingAt: inPos.	^outString copyFrom: 1 to: newOutPos-1	! !!String methodsFor: 'internet' stamp: 'yo 11/3/2004 19:24'!withoutQuoting	"remove the initial and final quote marks, if present"	"'''h''' withoutQuoting"	| quote |	self size < 2 ifTrue: [ ^self ].	quote := self first.	(quote = $' or: [ quote = $" ])		ifTrue: [ ^self copyFrom: 2 to: self size - 1 ]		ifFalse: [ ^self ].! !!String methodsFor: 'paragraph support' stamp: 'yo 8/26/2002 22:19'!indentationIfBlank: aBlock	"Answer the number of leading tabs in the receiver.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value."	| reader leadingTabs lastSeparator cr tab ch |	cr := Character cr.	tab := Character tab.	reader := ReadStream on: self.	leadingTabs := 0.	[reader atEnd not and: [(ch := reader next) = tab]]		whileTrue: [leadingTabs := leadingTabs + 1].	lastSeparator := leadingTabs + 1.	[reader atEnd not and: [ch isSeparator and: [ch ~= cr]]]		whileTrue: [lastSeparator := lastSeparator + 1. ch := reader next].	lastSeparator = self size | (ch = cr)		ifTrue: [^aBlock value: leadingTabs].	^ leadingTabs.! !!String methodsFor: 'printing' stamp: 'yo 8/26/2002 22:57'!encodeDoublingQuoteOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream print: $'.	1 to: self size do:		[:i |		aStream print: (x := self at: i).		x = $' ifTrue: [aStream print: x]].	aStream print: $'! !!String methodsFor: 'printing' stamp: 'yo 8/26/2002 22:58'!storeOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream nextPut: $'.	1 to: self size do:		[:i |		aStream nextPut: (x := self at: i).		x = $' ifTrue: [aStream nextPut: x]].	aStream nextPut: $'! !!String methodsFor: 'system primitives' stamp: 'ar 4/10/2005 16:55'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned."	| index c1 c2 |	matchTable == nil ifTrue: [		key size = 0 ifTrue: [^ 0].		start to: body size - key size + 1 do:			[:startIndex |			index := 1.				[(body at: startIndex+index-1)					= (key at: index)]					whileTrue:					[index = key size ifTrue: [^ startIndex].					index := index+1]].		^ 0	].	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index := 1.		[c1 := body at: startIndex+index-1.		c2 := key at: index.		((c1 leadingChar = 0) ifTrue: [(matchTable at: c1 asciiValue + 1)]						ifFalse: [c1 asciiValue + 1])			= ((c2 leadingChar = 0) ifTrue: [(matchTable at: c2 asciiValue + 1)]								ifFalse: [c2 asciiValue + 1])]			whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0! !!String methodsFor: 'system primitives' stamp: 'yo 11/3/2004 19:24'!numArgs 	"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector.  Note that currently this will answer -1 for anything begining with an uppercase letter even though the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."	| firstChar numColons excess start ix |	self size = 0 ifTrue: [^ -1].	firstChar := self at: 1.	(firstChar isLetter or: [firstChar = $:]) ifTrue:		["Fast reject if any chars are non-alphanumeric"		(self findSubstring: '~' in: self startingAt: 1 matchTable: Tokenish) > 0 ifTrue: [^ -1].		"Fast colon count"		numColons := 0.  start := 1.		[(ix := self findSubstring: ':' in: self startingAt: start matchTable: CaseSensitiveOrder) > 0]			whileTrue:				[numColons := numColons + 1.				start := ix + 1].		numColons = 0 ifTrue: [^ 0].		firstChar = $:			ifTrue: [excess := 2 "Has an initial keyword, as #:if:then:else:"]			ifFalse: [excess := 0].		self last = $:			ifTrue: [^ numColons - excess]			ifFalse: [^ numColons - excess - 1 "Has a final keywords as #nextPut::andCR"]].	firstChar isSpecial ifTrue:		[self size = 1 ifTrue: [^ 1].		2 to: self size do: [:i | (self at: i) isSpecial ifFalse: [^ -1]].		^ 1].	^ -1.! !!String methodsFor: 'testing' stamp: 'yo 8/4/2003 12:26'!isAsciiString	| c |	c := self detect: [:each | each asciiValue > 127] ifNone: [nil].	^ c isNil.! !!String methodsFor: 'private' stamp: 'yo 11/3/2004 19:24'!correctAgainstEnumerator: wordBlock continuedFrom: oldCollection	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."	| choices scoreMin results score maxChoices |	scoreMin := self size // 2 min: 3.	maxChoices := 10.	oldCollection isNil		ifTrue: [ choices := SortedCollection sortBlock: [ :x :y | x value > y value ] ]		ifFalse: [ choices := oldCollection ].	wordBlock isNil		ifTrue:			[ results := OrderedCollection new.			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]		ifFalse:			[ wordBlock value: [ :word |				(score := self alike: word) >= scoreMin ifTrue:					[ choices add: (Association key: word value: score).						(choices size >= maxChoices) ifTrue: [ scoreMin := (choices at: maxChoices) value] ] ].			results := choices ].	^ results! !!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:32'!uversionEqual: anObject	^anObject isString and: [ self = anObject ]! !!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 21:13'!uversionLessThan: anObject	^anObject isInteger or: [ self < anObject ]! !!String methodsFor: '*Universes' stamp: 'ls 8/26/2007 09:16'!asUVersion	^UVersion readFromString: self! !!String class methodsFor: 'initialization' stamp: 'ar 4/9/2005 22:37'!initialize   "self initialize"	| order |	AsciiOrder := (0 to: 255) as: ByteArray.	CaseInsensitiveOrder := AsciiOrder copy.	($a to: $z) do:		[:c | CaseInsensitiveOrder at: c asciiValue + 1				put: (CaseInsensitiveOrder at: c asUppercase asciiValue +1)].	"Case-sensitive compare sorts space, digits, letters, all the rest..."	CaseSensitiveOrder := ByteArray new: 256 withAll: 255.	order := -1.	' 0123456789' do:  "0..10"		[:c | CaseSensitiveOrder at: c asciiValue + 1 put: (order := order+1)].	($a to: $z) do:     "11-64"		[:c | CaseSensitiveOrder at: c asUppercase asciiValue + 1 put: (order := order+1).		CaseSensitiveOrder at: c asciiValue + 1 put: (order := order+1)].	1 to: CaseSensitiveOrder size do:		[:i | (CaseSensitiveOrder at: i) = 255 ifTrue:			[CaseSensitiveOrder at: i put: (order := order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	"a table for translating to lower case"	LowercasingTable := String withAll: (Character allByteCharacters collect: [:c | c asLowercase]).	"a table for translating to upper case"	UppercasingTable := String withAll: (Character allByteCharacters collect: [:c | c asUppercase]).	"a table for testing tokenish (for fast numArgs)"	Tokenish := String withAll: (Character allByteCharacters collect:									[:c | c tokenish ifTrue: [c] ifFalse: [$~]]).	"CR and LF--characters that terminate a line"	CSLineEnders := CharacterSet empty.	CSLineEnders add: Character cr.	CSLineEnders add: Character lf. 	"separators and non-separators"	CSSeparators := CharacterSet separators.	CSNonSeparators := CSSeparators complement.! !!String class methodsFor: 'initialization' stamp: 'yo 8/11/2003 21:11'!initializeHtmlEntities	"self initializeHtmlEntities"	HtmlEntities := (Dictionary new: 128)		at: 'amp'	put: $&;		at: 'lt'		put: $<;		at: 'gt'		put: $>;		at: 'quot'	put: $";		at: 'euro'	put: Character euro;		yourself.	#('nbsp' 'iexcl' 'cent' 'pound' 'curren' 'yen' 'brvbar' 'sect' 'uml' 'copy' 'ordf' 'laquo' 'not' 'shy' 'reg' 'hibar' 'deg' 'plusmn' 'sup2' 'sup3' 'acute' 'micro' 'para' 'middot' 'cedil' 'sup1' 'ordm' 'raquo' 'frac14' 'frac12' 'frac34' 'iquest' 'Agrave' 'Aacute' 'Acirc' 'Atilde' 'Auml' 'Aring' 'AElig' 'Ccedil' 'Egrave' 'Eacute' 'Ecirc' 'Euml' 'Igrave' 'Iacute' 'Icirc' 'Iuml' 'ETH' 'Ntilde' 'Ograve' 'Oacute' 'Ocirc' 'Otilde' 'Ouml' 'times' 'Oslash' 'Ugrave' 'Uacute' 'Ucirc' 'Uuml' 'Yacute' 'THORN' 'szlig' 'agrave' 'aacute' 'acirc' 'atilde' 'auml' 'aring' 'aelig' 'ccedil' 'egrave' 'eacute' 'ecirc' 'euml' 'igrave' 'iacute' 'icirc' 'iuml' 'eth' 'ntilde' 'ograve' 'oacute' 'ocirc' 'otilde' 'ouml' 'divide' 'oslash' 'ugrave' 'uacute' 'ucirc' 'uuml' 'yacute' 'thorn' 'yuml' ) withIndexDo: [:each :index | HtmlEntities at: each put: (index + 159) asCharacter]! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!fromPacked: aLong	"Convert from a longinteger to a String of length 4."	| s |	s := self new: 4.	s at: 1 put: (aLong digitAt: 4) asCharacter.	s at: 2 put: (aLong digitAt: 3) asCharacter.	s at: 3 put: (aLong digitAt: 2) asCharacter.	s at: 4 put: (aLong digitAt: 1) asCharacter.	^s"String fromPacked: 'TEXT' asPacked"! !!String class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 13:27'!readFrom: inStream	"Answer an instance of me that is determined by reading the stream, 	inStream. Embedded double quotes become the quote Character."	| outStream char done |	outStream := WriteStream on: (self new: 16).	"go to first quote"	inStream skipTo: $'.	done := false.	[done or: [inStream atEnd]]		whileFalse: 			[char := inStream next.			char = $'				ifTrue: 					[char := inStream next.					char = $'						ifTrue: [outStream nextPut: char]						ifFalse: [done := true]]				ifFalse: [outStream nextPut: char]].	^outStream contents! !!String class methodsFor: 'instance creation' stamp: 'dc 2/12/2007 10:47'!space	"Answer a string containing a single space character."	^ self with: Character space! !!String class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 17:34'!with: aCharacter	| newCollection |	aCharacter asInteger < 256		ifTrue:[newCollection := ByteString new: 1]		ifFalse:[newCollection := WideString new: 1].	newCollection at: 1 put: aCharacter.	^newCollection! !!String class methodsFor: 'primitives' stamp: 'yo 12/15/2005 13:41'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	order == nil ifTrue: [		len1 := string1 size.		len2 := string2 size.		1 to: (len1 min: len2) do:[:i |			c1 := (string1 at: i) asInteger.			c2 := (string2 at: i) asInteger.			c1 = c2 ifFalse: [c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].		].		len1 = len2 ifTrue: [^ 2].		len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].	].	len1 := string1 size.	len2 := string2 size.	1 to: (len1 min: len2) do:[:i |		c1 := (string1 at: i) asInteger.		c2 := (string2 at: i) asInteger.		c1 < 256 ifTrue: [c1 := order at: c1 + 1].		c2 < 256 ifTrue: [c2 := order at: c2 + 1].		c1 = c2 ifFalse:[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].	].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!String class methodsFor: 'primitives' stamp: 'nice 3/15/2007 20:59'!findFirstInString: aString inCharacterSet: aCharacterSet startingAt: start 	"Trivial, non-primitive version"		start		to: aString size		do: [:i | (aCharacterSet					includes: (aString at: i))				ifTrue: [^ i]].	^ 0! !!String class methodsFor: 'primitives' stamp: 'nice 5/9/2006 20:17'!findFirstInString: aString inSet: inclusionMap startingAt: start	"Trivial, non-primitive version"		| i stringSize ascii more |	inclusionMap size ~= 256 ifTrue: [^ 0].	stringSize := aString size.	more := true.	i := start - 1.	[more and: [(i := i + 1) <= stringSize]] whileTrue: [		ascii := (aString at: i) asciiValue.		more := ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].	].	i > stringSize ifTrue: [^ 0].	^ i! !!String class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:36'!indexOfAscii: anInteger inString: aString startingAt: start	"Trivial, non-primitive version"	| stringSize |	stringSize := aString size.	start to: stringSize do: [:pos |		(aString at: pos) asInteger = anInteger ifTrue: [^ pos]].	^ 0! !!String class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:29'!stringHash: aString initialHash: speciesHash	| stringSize hash low |	stringSize := aString size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: stringSize do: [:pos |		hash := hash + (aString at: pos) asInteger.		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash.! !!String class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:36'!translate: aString from: start  to: stop  table: table	"Trivial, non-primitive version"	| char |	start to: stop do: [:i |		char := (aString at: i) asInteger.		char < 256 ifTrue: [aString at: i put: (table at: char+1)].	].! !!String class methodsFor: 'accessing' stamp: 'ar 3/17/2007 21:21'!noSeparatorMap	^CSNonSeparators byteArrayMap! !!String class methodsFor: 'accessing' stamp: 'ar 3/17/2007 21:28'!separatorMap	^CSSeparators byteArrayMap! !!StringHolder methodsFor: 'accessing' stamp: 'sw 1/12/1999 11:47'!contents: textOrString 	"Set textOrString to be the contents of the receiver."	contents := textOrString "asString"! !!StringHolder methodsFor: 'accessing' stamp: 'di 11/23/1998 15:21'!textContents: aStringOrText 	"Set aStringOrText to be the contents of the receiver."	contents := aStringOrText! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 10/16/1998 11:36'!embeddedInMorphicWindowLabeled: labelString	| window |	window := (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	^ window! !!StringHolder methodsFor: 'initialize-release' stamp: 'jm 3/24/98 17:56'!initialize	"Initialize the state of the receiver with its default contents."	contents := self defaultContents.! !!StringHolder methodsFor: 'initialize-release' stamp: 'sma 4/30/2000 10:15'!openLabel: aString andTerminate: terminateBoolean	"Create a standard system view of the model, me, a StringHolder and open it.; do not terminate the active process if in mvc"	| topView codeView |	Smalltalk isMorphic ifTrue: [^ self openAsMorphLabel: aString].	topView := (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView := PluggableTextView on: self 			text: #contents accept: #acceptContents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	"self contents size > 0 ifTrue: [			codeView hasUnacceptedEdits: true].  Is it already saved or not??"	terminateBoolean		ifTrue:			[topView controller open]		ifFalse:			[topView controller openNoTerminate]! !!StringHolder methodsFor: 'tiles' stamp: 'di 11/4/2000 11:07'!openSyntaxView	"Open a syntax view on the current method"	| class selector |	(selector := self selectedMessageName) ifNotNil: [		class := self selectedClassOrMetaClass.		SyntaxMorph testClass: class andMethod: selector.	]! !!StringHolder class methodsFor: 'class initialization'!initialize	"The class variables were initialized once, and subsequently filled with	information. Re-executing this method is therefore dangerous." 	 	"workSpace := StringHolder new"	"StringHolder initialize"! !!StringHolderController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:14'!performMenuMessage: aSelector	"Intercept #again so the model does not get locked by keying the search text."	| hadEdits |	hadEdits := view canDiscardEdits not.	super performMenuMessage: aSelector.	(hadEdits not and:	 [aSelector == #again and:	 [(UndoMessage sends: #undoAgain:andReselect:typedKey:) and:	 [UndoMessage arguments at: 3]]])		ifTrue: [self userHasNotEdited].! !!StringHolderView methodsFor: 'initialize-release' stamp: 'jm 3/24/98 14:39'!initialize 	"Refer to the comment in View|initialize."	super initialize.	displayContents := '' asParagraph.	hasUnacceptedEdits := false.	askBeforeDiscardingEdits := true.! !!StringHolderView methodsFor: 'model access'!editString: aString 	"The paragraph to be displayed is created from the characters in aString."	displayContents := Paragraph withText: aString asText		style: TextStyle default copy		compositionRectangle: (self insetDisplayBox insetBy: 6 @ 0)		clippingRectangle: self insetDisplayBox		foreColor: self foregroundColor backColor: self backgroundColor.	(self controller isKindOf: ParagraphEditor)		ifTrue: [controller changeParagraph: displayContents]! !!StringHolderView methodsFor: 'updating' stamp: 'jm 3/24/98 14:38'!askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	askBeforeDiscardingEdits := aBoolean.! !!StringHolderView methodsFor: 'updating' stamp: 'tk 4/13/1998 17:17'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value."	hasUnacceptedEdits := aBoolean.! !!StringHolderView methodsFor: 'updating' stamp: 'dgd 9/21/2003 17:42'!promptForCancel	"Ask if it is OK to cancel changes to text"	| okToCancel stripes |	self topView isCollapsed ifTrue:		[(self confirm: 'Changes have not been saved.Is it OK to cancel those changes?' translated) ifTrue: [model clearUserEditFlag].		^ self].	stripes := (Form extent: 16@16 fromStipple: 16r36C9) bits.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel := self confirm: 'Changes have not been saved.Is it OK to cancel those changes?' translated.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel ifTrue:		[self updateDisplayContents.		model clearUserEditFlag].! !!StringHolderView class methodsFor: 'instance creation'!container: aContainer 	"Answer an instance of me whose model is aContainer. Give it a 2-dot 	border."	| aCodeView |	aCodeView := self new model: aContainer.	aCodeView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	^aCodeView! !!StringHolderView class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 10:15'!open: aStringHolder label: labelString 	"NOTE this should be in the model class, and all senders so redirected,	in order that the view class can be discarded in a morphic world."	"Create a standard system view of the model, aStringHolder, as viewed by 	an instance of me. The label of the view is aString."	| aStringHolderView topView |	Smalltalk isMorphic ifTrue: [^ aStringHolder openAsMorphLabel: labelString].	aStringHolderView := self container: aStringHolder.	topView := StandardSystemView new.	topView model: aStringHolderView model.	topView addSubView: aStringHolderView.	topView label: labelString.	topView minimumSize: 100 @ 50.	topView controller open! !!StringReadoutTile methodsFor: 'accessing' stamp: 'sw 11/1/97 13:15'!literal: anObject	literal := anObject.	self updateLiteralLabel.	submorphs last informTarget! !!StringReadoutTile methodsFor: 'literal' stamp: 'sw 9/15/1999 15:14'!setLiteralTo: anObject width: w	"like literal:width: but does not inform the target"	literal := anObject.	self updateLiteralLabel.	submorphs last setWidth: w.	self updateLiteralLabel! !!StringSocket class methodsFor: '*universes' stamp: 'ls 8/3/2004 18:04'!decodeStringArray: aString	| idx numStrings |	idx _ 1.	numStrings _ aString getInteger32: idx.	idx _ idx + 4.	numStrings < 0 ifTrue: [ ^self error: 'invalid string socket encoding' ].	numStrings > 10000000 ifTrue: [ self error: 'refusing to decode humongous string socket' ].		^(1 to: numStrings) collect: [ :ignored |		| size str |		size _ aString getInteger32: idx.		idx _ idx + 4.		str _ aString copyFrom: idx to: idx+size-1.		idx _ idx + size.		str ]	! !!StringSocket class methodsFor: '*universes' stamp: 'ls 8/2/2004 16:18'!encodeStringArray: stringArray	| size outBuf outBufIndex |	size _ self spaceToEncode: stringArray.		outBuf _ String new: size.	outBufIndex _ 1.	outBuf putInteger32: stringArray size at: outBufIndex.	outBufIndex _ outBufIndex + 4.	stringArray do: [ :each |		outBuf putInteger32: each size at: outBufIndex.		outBufIndex _ outBufIndex + 4.		outBuf 			replaceFrom: outBufIndex 			to: outBufIndex + each size - 1 			with: each 			startingAt: 1.		outBufIndex _ outBufIndex + each size.	].		^outBuf! !!StringSocket class methodsFor: '*universes' stamp: 'ls 8/2/2004 16:18'!spaceToEncode: stringArray	^stringArray inject: 4 into: [ :sum :array |		sum + (array size + 4) ].! !!StringTest methodsFor: 'tests - converting' stamp: 'dc 4/10/2007 09:35'!testUpTo	"self debug: #testUpTo"	self assert: #up:to: keywords = #(up: to:).	self assert: #copy:from:to: keywords = #(copy: from: to:).	self assert: #up keywords = #(up).	self assert: #at: keywords = #(at:).	! !!StringTest methodsFor: 'tests - converting' stamp: 'md 2/5/2007 15:21'!testZipped	| compressed |		compressed := 'hello' zipped.	self assert: (compressed unzipped = 'hello').! !!StringTest methodsFor: 'testing - converting' stamp: 'KR 06/24/2005 11:21'!testPercentEncodingJa	| leading hiraA hiraO hiraAO encodedHiraA encodedHiraO encodedHiraAO |    "Make Japanese String from unicode. see http://www.unicode.org/charts/PDF/U3040.pdf"     leading := JapaneseEnvironment leadingChar.	hiraA := (Character leadingChar: leading code: 16r3042) asString.  "HIRAGANA LETTER A"	hiraO := (Character leadingChar: leading code: 16r304A) asString.  "HIRAGANA LETTER O"	hiraAO := hiraA, hiraO.	"Percent Encoded Japanese String"	encodedHiraA := hiraA encodeForHTTP.	self assert: encodedHiraA = '%E3%81%82'.	encodedHiraO := hiraO encodeForHTTP.	self assert: encodedHiraO = '%E3%81%8A'.	encodedHiraAO := hiraAO encodeForHTTP.	self assert: encodedHiraAO =  '%E3%81%82%E3%81%8A'.     "without percent encoded string"	self assert: '' unescapePercents = ''.	self assert: 'abc' unescapePercents = 'abc'.	"latin1 character"	self assert: hiraAO unescapePercents = hiraAO.  "multibyte character"	"encoded latin1 string"	self assert: '%61' unescapePercents = 'a'.	self assert: '%61%62%63' unescapePercents = 'abc'.	"encoded multibyte string"	Locale currentPlatform: (Locale isoLanguage: 'ja') during: [ 		self assert: encodedHiraA unescapePercents = hiraA.		self assert: encodedHiraAO unescapePercents = hiraAO].	"mixed string"	Locale currentPlatform: (Locale isoLanguage: 'ja') during: [ 		self assert: (encodedHiraAO,'a') unescapePercents = (hiraAO, 'a').		self assert: ('a', encodedHiraA) unescapePercents = ('a', hiraA).		self assert: ('a', encodedHiraA, 'b')  unescapePercents = ('a', hiraA, 'b').		self assert: ('a', encodedHiraA, 'b', encodedHiraO) unescapePercents = ('a', hiraA, 'b', hiraO).		self assert: (encodedHiraA, encodedHiraO, 'b', encodedHiraA) unescapePercents = (hiraA, hiraO, 'b', hiraA)].	"for Seaside"	Locale currentPlatform: (Locale isoLanguage: 'ja') during: [ 		self assert: (encodedHiraA, '+', encodedHiraO) unescapePercents = (hiraA, ' ', hiraO)].! !!StringTest methodsFor: 'tests - indexOf' stamp: 'nice 3/15/2007 21:11'!testIndexOf		"test for http://bugs.impara.de/view.php?id=3574"	self assert: ('abc-' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 4.	self assert: ('ab7' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 3.	self assert: ('a2c' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 2.	self assert: ('3bc' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 1.	self assert: ('abc' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 0.		"extension to wide characters"	self assert: ((String with: 803 asCharacter with: 811 asCharacter) indexOfAnyOf: (CharacterSet newFrom: (String with: 811 asCharacter with: 812 asCharacter))) = 2.		self assert: ('abc' indexOfAnyOf: (CharacterSet newFrom: (String with: 811 asCharacter with: 812 asCharacter))) = 0.		self assert: ('abc' indexOfAnyOf: (CharacterSet newFrom: (String with: 811 asCharacter with: $c))) = 3.		"make sure start index is used in wide string algorithm"	self assert: ('ab bcd abc' copyWith: 811 asCharacter) substrings = {'ab'. 'bcd'. 'abc' copyWith: 811 asCharacter}.! !!StringTest methodsFor: 'testing - instance creation' stamp: 'dc 3/21/2007 11:22'!testSpace	"self debug: #testSpace"		string := String new.	self assert: string size = 0. "instead of #isEmpty to be consistent with the following test"		string := String space.	self assert: string size = 1.	self assert: string = ' '! !!Switch methodsFor: 'action'!offAction: anAction 	"Set the off action of the receiver to anAction."	offAction := anAction fixTemps! !!Switch methodsFor: 'action'!onAction: anAction 	"Set the on action of the receiver to anAction."	onAction := anAction fixTemps! !!Switch methodsFor: 'state'!clear	"Set the state of the receiver to 'off'. If the state of the receiver was 	previously 'on', then 'self change' is sent. The receiver's off action is 	NOT executed."	self isOn		ifTrue: 			[on := false.			self changed]! !!Switch methodsFor: 'state'!set	"Set the state of the receiver to 'on'. If the state of the receiver was 	previously 'off', then 'self change' is sent. The receiver's on action is 	NOT executed."	self isOff		ifTrue: 			[on := true.			self changed]! !!Switch methodsFor: 'state'!turnOff	"Set the state of the receiver to 'off'. If the state of the receiver was 	previously 'on', then 'self change' is sent and the receiver's off action is 	executed."	self isOn		ifTrue: 			[on := false.			self changed.			self doAction: offAction]! !!Switch methodsFor: 'state'!turnOn	"Set the state of the receiver to 'on'. If the state of the receiver was 	previously 'off', then 'self change' is sent and the receiver's on action is 	executed."	self isOff		ifTrue: 			[on := true.			self changed.			self doAction: onAction]! !!Switch methodsFor: 'private'!initializeOff	on := false. 	onAction := nil.	offAction := nil! !!Switch methodsFor: 'private'!initializeOn	on := true. 	onAction := nil.	offAction := nil! !!Symbol methodsFor: 'converting' stamp: 'ar 4/10/2005 22:42'!asString 	"Refer to the comment in String|asString."	| newString |	newString := self species new: self size.	newString replaceFrom: 1 to: newString size with: self startingAt: 1.	^newString! !!Symbol class methodsFor: 'access' stamp: 'yo 11/3/2004 19:24'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."	| size selectorList ascii |	selectorList := OrderedCollection new.	(size := aString size) = 0 ifTrue: [^selectorList].	aString size = 1 ifTrue:		[			ascii := aString first asciiValue.			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]		].	aString first isLetter ifFalse:		[			aString size == 2 ifTrue: 				[Symbol hasInterned: aString ifTrue:					[:s | selectorList add: s]].			^selectorList		].	selectorList := selectorList copyFrom: 2 to: selectorList size.	self allSymbolTablesDo: [:each |		each size >= size ifTrue:			[(each findSubstring: aString in: each startingAt: 1 				matchTable: CaseInsensitiveOrder) > 0						ifTrue: [selectorList add: each]]].	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"		each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]."Symbol selectorsContaining: 'scon'"! !!Symbol class methodsFor: 'access' stamp: 'RAA 5/29/2001 14:35'!thatStarts: leadingCharacters skipping: skipSym	"Answer a selector symbol that starts with leadingCharacters.	Symbols beginning with a lower-case letter handled directly here.	Ignore case after first char.	If skipSym is not nil, it is a previous answer; start searching after it.	If no symbols are found, answer nil.	Used by Alt-q (Command-q) routines"	| size firstMatch key |	size := leadingCharacters size.	size = 0 ifTrue: [^skipSym ifNil: [#''] ifNotNil: [nil]].	firstMatch := leadingCharacters at: 1.	size > 1 ifTrue: [key := leadingCharacters copyFrom: 2 to: size].	self allSymbolTablesDo: [:each |			each size >= size ifTrue:				[					((each at: 1) == firstMatch and:						[key == nil or:							[(each findString: key startingAt: 2 caseSensitive: false) = 2]])								ifTrue: [^each]				]		] after: skipSym.	^nil"Symbol thatStarts: 'sf' skipping: nil""Symbol thatStarts: 'sf' skipping: #sfpGetFile:with:with:with:with:with:with:with:with:""Symbol thatStarts: 'candidate' skipping: nil"! !!Symbol class methodsFor: 'class initialization' stamp: 'RAA 12/17/2000 18:05'!compactSymbolTable	"Reduce the size of the symbol table so that it holds all existing symbols + 25% (changed from 1000 since sets like to have 25% free and the extra space would grow back in a hurry)"	| oldSize |	Smalltalk garbageCollect.	oldSize := SymbolTable array size.	SymbolTable growTo: SymbolTable size * 4 // 3 + 100.	^oldSize printString,'  ',(oldSize - SymbolTable array size) printString, ' slot(s) reclaimed'! !!Symbol class methodsFor: 'class initialization' stamp: 'RAA 5/29/2001 09:04'!initialize	"Symbol initialize"	Symbol rehash.	OneCharacterSymbols := nil.	OneCharacterSymbols := (1 to: 256) collect: [ :i | (i - 1) asCharacter asSymbol].	Smalltalk addToShutDownList: self.! !!Symbol class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 17:37'!intern: aStringOrSymbol 	^(self lookup: aStringOrSymbol) ifNil:[		| aClass aSymbol |		aStringOrSymbol isSymbol ifTrue:[			aSymbol := aStringOrSymbol.		] ifFalse:[			aClass := aStringOrSymbol isOctetString ifTrue:[ByteSymbol] ifFalse:[WideSymbol].			aSymbol := aClass new: aStringOrSymbol size.			aSymbol string: aStringOrSymbol.		].		NewSymbols add: aSymbol.		aSymbol].! !!Symbol class methodsFor: 'private' stamp: 'ar 4/10/2005 22:43'!hasInterned: aString ifTrue: symBlock 	"Answer with false if aString hasnt been interned (into a Symbol),  	otherwise supply the symbol to symBlock and return true."	| symbol |	^ (symbol := self lookup: aString)		ifNil: [false]		ifNotNil: [symBlock value: symbol.			true]! !!Symbol class methodsFor: 'private' stamp: 'RAA 5/29/2001 14:33'!possibleSelectorsFor: misspelled 	"Answer an ordered collection of possible corrections	for the misspelled selector in order of likelyhood"	| numArgs candidates lookupString best binary short long first ss |	lookupString := misspelled asLowercase. "correct uppercase selectors to lowercase"	numArgs := lookupString numArgs.	(numArgs < 0 or: [lookupString size < 2]) ifTrue: [^ OrderedCollection new: 0].	first := lookupString first.	short := lookupString size - (lookupString size // 4 max: 3) max: 2.	long := lookupString size + (lookupString size // 4 max: 3).	"First assemble candidates for detailed scoring"	candidates := OrderedCollection new.	self allSymbolTablesDo: [:s | (((ss := s size) >= short	"not too short"			and: [ss <= long			"not too long"					or: [(s at: 1) = first]])	"well, any length OK if starts w/same letter"			and: [s numArgs = numArgs])	"and numArgs is the same"			ifTrue: [candidates add: s]].	"Then further prune these by correctAgainst:"	best := lookupString correctAgainst: candidates.	((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [		binary := misspelled, ':'.		"try for missing colon"		Symbol hasInterned: binary ifTrue: [:him | best addFirst: him]].	^ best! !!Symbol class methodsFor: 'private' stamp: 'RAA 5/29/2001 09:04'!shutDown: aboutToQuit	SymbolTable addAll: NewSymbols.	NewSymbols := WeakSet new.! !!SymbolListTile methodsFor: 'accessing' stamp: 'yo 7/2/2004 21:27'!literal: anObject	"Set the receiver's literal as indicated"	self flag: #yo.	literal := anObject asSymbol.	self updateLiteralLabel."	key := Vocabulary eToyVocabulary translationKeyFor: literal.	key isNil ifFalse: [literal := key]."	self flag: #deferred.  "The below formerly was necessary but now is problematical, leading to low-space condition etc.  May need to revisit, since as I comment this out now I am uncertain what if anything this may break"	"self labelMorph informTarget"! !!SymbolListTile methodsFor: 'customevents-initialization' stamp: 'nk 7/21/2003 22:14'!updateChoices	choices := (Vocabulary vocabularyNamed: dataType) choices.	(choices includes: literal) ifFalse: [ literal := choices first. self changed ]! !!SymbolListTile methodsFor: 'initialization' stamp: 'sw 10/30/2000 09:04'!choices: choiceList dataType: aDataType	"Initialize the receiver with the given choice-list and data type"	choices := choiceList.	dataType := aDataType.	literal := choiceList first! !!SymbolListTile methodsFor: 'initialization' stamp: 'tak 12/6/2004 01:38'!initialize	super initialize.	literal := #nothing! !!SymbolListTile methodsFor: 'misc' stamp: 'sw 11/6/2001 13:30'!setLiteralInitially: anObject	"Establish the initial literal.  Get the label correct, but do *not* send the value back to the target via the setter (unlike #literal:)"	literal := anObject ifNotNil: [anObject asSymbol].	self updateLiteralLabel! !!SymbolListTile methodsFor: 'player viewer' stamp: 'yo 1/12/2005 14:28'!updateLiteralLabel	"Update the wording emblazoned on the tile, if needed.  Copied down, for jimmying, unfortunately"	| myLabel |	(myLabel := self labelMorph) ifNil: [^ self].	myLabel useSymbolFormat.	myLabel acceptValue: literal asString.	self changed.! !!SymbolListType methodsFor: '*eToys-tiles' stamp: 'sw 12/3/2001 19:15'!defaultArgumentTile	"Answer a tile to represent the type"	| aTile choices |	aTile := SymbolListTile new choices: (choices := self choices) dataType: self vocabularyName.	aTile addArrows.	aTile setLiteral: choices first.	^ aTile! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 8/21/2001 09:36'!actualObject	| sub |	"Who is self in these tiles?  Usually a Player."	(self nodeClassIs: LiteralVariableNode) ifTrue: [		(sub := self findA: StringMorph) ifNil: [^ nil].		"Need to decompile here for odd synonyms of 'self' ?"		^ Compiler evaluate: sub contents for: Player logged: false].	(self nodeClassIs: VariableNode) ifTrue: [		(sub := self findA: StringMorph) ifNil: [^ nil].		^ References at: (self cleanUpString: sub) asSymbol ifAbsent: [nil]].	(self nodeClassIs: LiteralNode) ifTrue: [		(sub := self findA: StringMorph) ifNil: [^ nil].		^ Compiler evaluate: sub contents for: nil logged: false].	(sub := self findA: SyntaxMorph) ifNil: [^ nil].	^ sub actualObject	"receiver"! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 9/20/2001 13:21'!argumentNodes	"Return a collection of this message's argument nodes.  "	| cls coll rec |	parseNode ifNil: [^ #()].	cls := parseNode class.	cls == SelectorNode ifTrue: [^ #()].	cls == KeyWordNode ifTrue: [^ #()].	coll := OrderedCollection new.	rec := self receiverNode.	submorphs do: [:sub | 		(sub isSyntaxMorph and: [sub ~~ rec]) ifTrue: [			sub isNoun ifTrue: [coll addLast: sub]	"complete arg"				ifFalse: [coll := coll, sub argumentNodes]]].	"MessagePartNode, MessageNode with no receiver"	^ coll! !!SyntaxMorph methodsFor: 'accessing' stamp: 'di 12/13/2000 15:25'!borderColor: colorOrSymbolOrNil	borderColor = colorOrSymbolOrNil ifFalse: [		borderColor := colorOrSymbolOrNil.		self bounds area < 40000			ifTrue: [self invalidRect: self bounds]			ifFalse: [(self bounds areasOutside: (self bounds insetBy: self borderWidth))						do: [:r | self invalidRect: r]]].! !!SyntaxMorph methodsFor: 'accessing' stamp: 'RAA 4/4/2001 12:36'!cleanUpString: stringSubMorph	| style rawData |	^ stringSubMorph 		valueOfProperty: #syntacticallyCorrectContents 		ifAbsent: [			style := stringSubMorph valueOfProperty: #syntacticReformatting.			rawData := stringSubMorph contents.			 (#(unary tempVariableDeclaration blockarg2 methodHeader1 tempVariable variable) includes: style) ifTrue: [				rawData := self unSpaceAndUpShift: rawData appending: nil.			].			style == #keywordGetz ifTrue: [				rawData := self unSpaceAndUpShift: rawData appending: 'Getz:'.			].			style == #keywordSetter ifTrue: [				rawData := self unSpaceAndUpShift: 'set ',rawData appending: ':'.			].			style == #unaryGetter ifTrue: [				rawData := self unSpaceAndUpShift: 'get ',rawData appending: nil.			].			(#(keyword2 methodHeader2) includes: style)  ifTrue: [				rawData := self unSpaceAndUpShift: rawData appending: ':'.			].			rawData		]! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 7/19/2001 20:04'!color: aColorOrSymbol	| deselectedColor cc |	aColorOrSymbol isColor ifTrue: [		self valueOfProperty: #deselectedColor ifAbsent: ["record my color the first time"			self setProperty: #deselectedColor toValue: aColorOrSymbol.			^ super color: (self scaleColorByUserPref: aColorOrSymbol)].		^ super color: aColorOrSymbol].	deselectedColor := self valueOfProperty: #deselectedColor ifAbsent: [nil].	deselectedColor ifNotNil: [^ super color: (self scaleColorByUserPref: deselectedColor)].	aColorOrSymbol == #comment  ifTrue: [^ self color: Color blue lighter].	SyntaxMorph noTileColor ifTrue: [	"override"		^ self color: Color transparent].	"Fix this to be real color!!"	(cc := self class translateColor: aColorOrSymbol) isColor		ifTrue: [^ self color: cc]		ifFalse: [Transcript show: aColorOrSymbol, ' needs to be handled in translateColor:'; cr.			^ self color: Color transparent].	"help!!"! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 9/19/2001 15:39'!enclosingPane	"The object that owns this script layout"	| oo higher |	oo := self owner.	[higher := oo isSyntaxMorph.	higher := higher or: [oo class == TransformMorph].	higher := higher or: [oo class == TwoWayScrollPane].	higher ifFalse: [^ oo].	higher] whileTrue: [oo := oo owner].! !!SyntaxMorph methodsFor: 'accessing' stamp: 'RAA 8/15/1999 16:11'!parseNode: x		parseNode := x			! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 9/23/2001 00:27'!receiverObject	"Return some object that could be the receiver to me (a selector).  Either the actual object who is the receiver in this message, or a guy of the right class."	| rec value mm |	(rec := owner) isSyntaxMorph ifFalse: [^ nil].	rec := rec receiverNode.	rec ifNil: [(rec := owner owner) isSyntaxMorph ifFalse: [^ nil].				rec := rec receiverNode].		rec ifNil: [(rec := owner owner owner) isSyntaxMorph ifFalse: [^ nil].				rec := rec receiverNode].	rec isSelfTile ifTrue: [		^ ((mm := self containingWindow model) respondsTo: #targetObject) 			ifTrue: [mm targetObject]			ifFalse: [mm selectedClassOrMetaClass new]].	value := rec ifNotNil: [rec try].	value class == Error ifTrue: [		value := Vocabulary instanceWhoRespondsTo: self selector].	^ value! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 1/13/2001 20:08'!rename: newSelector	| keywords mainSel list last |	"Attempt to change the name as listed in my tiles.  Can change the number of argumtents.  MethodNode (SelectorNode (SelectorNode (string))) or MethodNode (SelectorNode (SelectorNode (string) TempVarNode() SelectorNode (string) TempVarNode()))"	self isMethodNode ifFalse: [		self rootTile == self ifTrue: [^ self].  "not in a script"		^ self rootTile rename: newSelector  "always do at the root"].	keywords := newSelector keywords.	mainSel := self findA: SelectorNode.	list := mainSel submorphs select: [:mm | 		mm isSyntaxMorph and: [mm parseNode class == SelectorNode]].	1 to: (list size min: keywords size) do: [:ind |		((list at: ind) findA: UpdatingStringMorph) contents: (keywords at: ind)].	keywords size + 1 to: list size do: [:ind | "removing keywords"		[last := mainSel submorphs last.		 (last isSyntaxMorph and: [last parseNode class == TempVariableNode])] whileFalse: [				last delete].		[last := mainSel submorphs last.		 (last isSyntaxMorph and: [last parseNode class == SelectorNode])] whileFalse: [				last delete].	"the TempVariableNode and others"		mainSel submorphs last delete.	"the SelectorNode"		].	list size + 1 to: keywords size do: [:ind | "adding keywords"		"add a SelectorNode, add a spacer, add a TempVarNode"		mainSel addToken: (keywords at: ind) type: #keyword1 			on: (SelectorNode new key: (keywords at: ind) code: nil).		mainSel addMorphBack: (mainSel transparentSpacerOfSize: 4@4).		(TempVariableNode new name: 'arg', ind printString index: ind type: nil scope: nil)			 asMorphicSyntaxIn: mainSel].! !!SyntaxMorph methodsFor: 'alans styles' stamp: 'RAA 2/26/2001 13:39'!constructSelfVariant: receiver and: key	| wordy |	(receiver isKindOf: VariableNode) ifFalse: [^nil].	receiver name = 'self'  ifFalse: [^nil].	(wordy := self translateFromWordySelfVariant: key) ifNil: [^nil].	^wordy! !!SyntaxMorph methodsFor: 'alans styles' stamp: 'RAA 3/25/2001 17:16'!noiseStringMorph: aNoiseString	| sMorph |	sMorph := self aSimpleStringMorphWith: aNoiseString.	sMorph 		font: (self fontToUseForSpecialWord: aNoiseString); 		setProperty: #noiseWord toValue: true.	^sMorph! !!SyntaxMorph methodsFor: 'alans styles' stamp: 'tk 7/28/2001 09:05'!translateToWordyGetter: key	"  setBlob:  becomes  's blob :=  "	^ '''s ', 	  (self splitAtCapsAndDownshifted: (key asString allButFirst: 3) 			withFirstCharacterDownshifted)! !!SyntaxMorph methodsFor: 'alans styles' stamp: 'RAA 2/26/2001 13:45'!translateToWordySelfVariant: aString	| lc |	lc := aString asLowercase.	lc = 'me' ifTrue: [^#selfWrittenAsMe].	lc = 'my' ifTrue: [^#selfWrittenAsMy].	lc = 'i''ll' ifTrue: [^#selfWrittenAsIll].	lc = 'i''m' ifTrue: [^#selfWrittenAsIm].	lc = 'this' ifTrue: [^#selfWrittenAsThis].	^nil! !!SyntaxMorph methodsFor: 'card & stack' stamp: 'tk 11/4/2001 21:47'!setTarget: aPlayer	"Find my UpdatingStringMorph and set its getSelector, putSelector, and target"	| updatingString |	(updatingString := self readOut) ifNil: [^ self].	updatingString putSelector: (Utilities setterSelectorFor: self knownName).	updatingString getSelector: (Utilities getterSelectorFor: self knownName).	updatingString target: aPlayer. ! !!SyntaxMorph methodsFor: 'change reporting' stamp: 'tk 9/28/2001 13:36'!colorChangedForSubmorph: colorPatch	| sel newSel cc ms phrase completeMsg |	"reporting a color change"	(self nodeClassIs: MessageNode) ifFalse: [^ nil].	(sel := self selector) ifNil: [^ nil].	(Color colorNames includes: sel) | (sel == #r:g:b:) ifFalse: [^ nil].		"a standard color name"	"replace self with new tiles from the color"	(newSel := (cc := colorPatch color) name) 		ifNil: [ms := MessageSend receiver: Color selector: #r:g:b: arguments: 				(Array with: cc red with: cc green with: cc blue).			phrase := ms asTilesIn: Color globalNames: true]		ifNotNil: [ms := MessageSend receiver: Color selector: newSel arguments: #().			phrase := ms asTilesIn: Color globalNames: true].	self deletePopup.	completeMsg := self isNoun ifTrue: [self] ifFalse: [owner].	completeMsg owner replaceSubmorph: completeMsg by: phrase.	"rec setSelection: {rec. nil. rec}."	phrase acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 9/30/2001 11:09'!morphToDropInPasteUp: aPasteUp	"If property #beScript is true, create a scriptor around me."	| actualObject itsSelector aScriptor adjustment handy tw blk |	(self valueOfProperty: #beScript ifAbsent: [false]) ifFalse: [^ self].	self removeProperty: #beScript.	actualObject := self actualObject ifNil: [					self valueOfProperty: #scriptedPlayer ifAbsent: [nil]].	actualObject ifNil: [^ self].	self removeProperty: #scriptedPlayer.	actualObject assureUniClass.	itsSelector := self userScriptSelector.	aScriptor := itsSelector isEmptyOrNil		ifFalse:			[adjustment := 0@0.			actualObject scriptEditorFor: itsSelector]		ifTrue:			[adjustment := 60 @ 20.			actualObject newScriptorAround: self].	aScriptor ifNil: [^self].	handy := aPasteUp primaryHand.	aScriptor position: handy position - adjustment.	aPasteUp addMorphFront: aScriptor.	"do this early so can find World"	aScriptor showingMethodPane ifFalse: [		"(tw := aScriptor findA: TwoWayScrollPane) ifNil:			[itsSelector ifNil: ['blank script'.				tw := aScriptor findA: TwoWayScrollPane.				blk := (tw scroller findA:  SyntaxMorph ""MethodNode"") findA: BlockNode.				blk addMorphFront: self]].		"		SyntaxMorph setSize: nil andMakeResizable: aScriptor.		].	^ aScriptor! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 9/24/2001 10:04'!structureMatchWith: aMorph	| meNoun itNoun |	"Return true if the node types would allow aMorph to replace me.  This tests the gross structure of the method only."	meNoun := self isNoun.	itNoun := aMorph isNoun.	"Consider these nouns to be equal:  TempVariableNode, LiteralNode, VariableNode, (MessageNode with receiver), CascadeNode, AssignmentNode"	meNoun & itNoun ifTrue: [^ true].	meNoun & aMorph isBlockNode ifTrue: [^ true].	"If I am a BlockNode, and it is a TempVariableNode, add it into list"	"If I am a BlockNode, and it is a noun, add it as a new line"	self isBlockNode ifTrue:		[itNoun ifTrue: [^ true].		(aMorph nodeClassIs: ReturnNode) ifTrue:			[^ (self submorphs				detect: [:mm | ((mm isSyntaxMorph) and: [mm nodeClassIs: ReturnNode])]				ifNone: [nil]) isNil].	"none already in this block"				"If I am a BlockNode, and it is a ReturnNode, add to end"		(aMorph nodeClassIs: CommentNode) ifTrue: [^ true]].	(self isMethodNode) ifTrue: [^ false].	"Later add args and keywords"		"Later allow comments to be dropped in"		"Add MethodTemps by dropping into the main block"	(self nodeClassIs: ReturnNode) & (aMorph parseNode class == MessageNode) 		ifTrue: [^ true].		"Command replace Return"	(self nodeClassIs: MessageNode) & (aMorph parseNode class == ReturnNode) ifTrue: [		(owner submorphs select: [:ss | ss isSyntaxMorph]) last == self			ifTrue: [^ true]].	"Return replace last command"	(aMorph nodeClassIs: AssignmentNode) ifTrue: [		itNoun ifFalse: ["create a new assignment"			^ self isAVariable & self isDeclaration not]].	"only assign to a variable"	"If nodes are of equal class, replace me with new one."	(self nodeClassIs: aMorph parseNode class) ifTrue: [		(self nodeClassIs: MessageNode) 				ifFalse: [^ true]	"normal match"				ifTrue: [^ self receiverNode == aMorph receiverNode]].	"both nil"	^ false "otherwise reject"! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/17/2000 08:21'!keyStroke: evt	"Handle a keystroke event."	| spacer |	evt keyCharacter = Character backspace ifTrue:		[(owner notNil and: [owner isSyntaxMorph]) ifTrue:			[owner isBlockNode ifTrue:				["Delete a statement."				(spacer := self submorphAfter) class == AlignmentMorph						ifTrue: [spacer delete].				self delete].			]].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 9/26/2001 05:56'!mouseDown: evt 	| dup rootTile |	evt yellowButtonPressed ifTrue: [^ self showMenu: evt].	(rootTile := self rootTile) isMethodNode ifTrue:		[self currentSelectionDo:			[:innerMorph :mouseDownLoc :outerMorph |			(outerMorph notNil and: [self == innerMorph])				ifTrue: ["Click on prior selection -- record click point."						self setSelection: {self. evt cursorPoint. outerMorph}]				ifFalse: ["A new selection sequence."						self setSelection: {self. evt cursorPoint. nil}]].		^ self].	"Out in the world -- treat as a unit"	rootTile isSticky ifTrue: [^ self].	"later may allow to be selected"	rootTile isPartsDonor 		ifTrue: [dup := rootTile duplicate.				dup setProperty: #beScript toValue: true]		ifFalse: [dup := rootTile].	evt hand attachMorph: dup.	Preferences tileTranslucentDrag		ifTrue: [^ dup lookTranslucent]		ifFalse: [^ dup align: dup topLeft with: evt hand position + self cursorBaseOffset]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 10/17/2001 13:41'!mouseMove: evt	| dup selection |	owner isSyntaxMorph ifFalse: [^ self].false ifTrue: ["for now, do not drag off a tile"	self currentSelectionDo:		[:innerMorph :mouseDownLoc :outerMorph |		mouseDownLoc ifNotNil: [			(evt cursorPoint dist: mouseDownLoc) > 4 ifTrue:				["If drag 5 pixels, then tear off a copy of outer selection."				selection := outerMorph ifNil: [self].				selection deletePopup.				evt hand attachMorph: (dup := selection duplicate).				Preferences tileTranslucentDrag					ifTrue: [dup lookTranslucent]					ifFalse: [dup align: dup topLeft								with: evt hand position + self cursorBaseOffset].				self setSelection: nil.	"Why doesn't this deselect?"				(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m isBlockNode]])					ifNotNilDo: [:m | "Activate enclosing block."								m startStepping]]]].	].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/17/2000 08:13'!mouseUp: evt	| newSel |	self rootTile isMethodNode ifFalse: [^ self].	self currentSelectionDo:		[:innerMorph :mouseDownLoc :outerMorph |		newSel := outerMorph			ifNil: [self "first click"]			ifNotNil: [(outerMorph firstOwnerSuchThat:							[:m | m isSyntaxMorph and: [m isSelectable]]) ifNil: [self]].		newSel isMethodNode ifTrue: [^ self setSelection: nil].		self setSelection: {self. nil. newSel}]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 12/1/2000 15:42'!wantsKeyboardFocusFor: aSubmorph	| doEdit |	"only let strings edit on shift-click.  Editing on ordinary click defeats the brown selection and tile dragging."	doEdit := self world primaryHand lastEvent shiftPressed.	doEdit ifTrue: ["remove the arrows during editing"		self valueOfProperty: #myPopup ifPresentDo: [:panel |			panel delete. self removeProperty: #myPopup]].	^ doEdit! !!SyntaxMorph methodsFor: 'formatting options' stamp: 'di 2/21/2001 11:42'!alansTest1		| root |	root := self rootTile ifNil: [self].	^root valueOfProperty: #alansNewStyle ifAbsent: [self usingClassicTiles not]! !!SyntaxMorph methodsFor: 'formatting options' stamp: 'RAA 2/26/2001 09:02'!controlContrast2: evt	| origin scale startingContrastX |	evt isMouseUp ifTrue: [		^self removeProperty: #startingPointForSomeAdjustment	].	evt isMouseDown ifTrue: [		^self setProperty: #startingPointForSomeAdjustment toValue: evt cursorPoint	].	ContrastFactor ifNil: [ContrastFactor := 0.5].	scale := 200.0.	startingContrastX := ContrastFactor * scale.	origin := self valueOfProperty: #startingPointForSomeAdjustment.	ContrastFactor := (evt cursorPoint x - origin x + startingContrastX) / scale min: 1.0 max: 0.0.	self finalAppearanceTweaks.! !!SyntaxMorph methodsFor: 'formatting options' stamp: 'RAA 5/11/2001 07:41'!controlSpacing2: evt	| origin scale startingContrastX |	evt isMouseUp ifTrue: [		^self removeProperty: #startingPointForSomeAdjustment	].	evt isMouseDown ifTrue: [		^self setProperty: #startingPointForSomeAdjustment toValue: evt cursorPoint	].	SizeScaleFactor ifNil: [SizeScaleFactor := 0.15].	scale := 200.0.	startingContrastX := SizeScaleFactor * scale.	origin := self valueOfProperty: #startingPointForSomeAdjustment.	SizeScaleFactor := (evt cursorPoint x - origin x + startingContrastX) / scale min: 1.0 max: 0.0.	self finalAppearanceTweaks.! !!SyntaxMorph methodsFor: 'initialization' stamp: 'sw 3/6/2001 11:26'!inAPluggableScrollPane	"Answer a PluggableTileScriptorMorph that holds the receiver"	| widget |	widget := PluggableTileScriptorMorph new.	widget extent: 10@10; borderWidth: 0.	widget scroller addMorph: self.	widget setScrollDeltas.	widget hResizing: #spaceFill; vResizing: #spaceFill.	^ widget! !!SyntaxMorph methodsFor: 'initialization' stamp: 'di 1/31/2001 10:14'!openInWindow	| window widget sel |	sel := ''.	self firstSubmorph allMorphs do: [:rr | 			(rr isKindOf: StringMorph) ifTrue: [sel := sel, rr contents]].	window := (SystemWindow labelled: 'Tiles for ', self parsedInClass printString, '>>',sel).	widget := self inAScrollPane.	widget color: Color paleOrange.	window		addMorph: widget		frame: (0@0 extent: 1.0@1.0).	window openInWorldExtent: (		self extent + (20@40) min: (Display boundingBox extent * 0.8) rounded	)! !!SyntaxMorph methodsFor: 'initialization' stamp: 'FBS 2/24/2004 14:21'!returnNode: aNode expression: expr	| row expMorph sMorph aNoiseString |	row := self addRow: #return on: aNode.	self alansTest1 ifTrue: [		row setSpecialOuterTestFormat.		aNoiseString := ' Reply '.		sMorph := self aSimpleStringMorphWith: aNoiseString.		sMorph 			emphasis: TextEmphasis bold emphasisCode;			setProperty: #syntacticallyCorrectContents toValue: '^'.		row addMorphBack: sMorph.	] ifFalse: [		row addToken: '^ ' type: #upArrow on: aNode.	].	expMorph := expr asMorphicSyntaxIn: row.	self alansTest1 ifTrue: [		(expMorph hasProperty: #deselectedColor) ifFalse: [expMorph setConditionalPartStyle].	].	expr addCommentToMorph: row.	^row! !!SyntaxMorph methodsFor: 'initialization' stamp: 'tk 1/19/2001 13:29'!sample: arg1"a comment"| temp1 |temp1 := 5.temp1 yourself.temp1 min: arg1.! !!SyntaxMorph methodsFor: 'insertion drop zones' stamp: 'tk 9/13/2001 15:24'!trackDropZones	| hand i localPt insertion insHt ii prevBot nxtHt d c1 c2 ht2 spacer1 spacer2 wid ht1 dc each |	hand := self primaryHand.	("hand lastEvent redButtonPressed &" hand hasSubmorphs		and: [(self hasOwner: hand) not]) ifFalse: [^ self].	insertion := hand firstSubmorph renderedMorph.	insertion isSyntaxMorph ifFalse: [^ self].	insertion isNoun ifFalse: [(insertion nodeClassIs: CommentNode) ifFalse: [^ self]].	localPt := self globalPointToLocal: hand position.	insHt := insertion height.  "**just use standard line height here"	self removeDropZones.  "Maybe first check if in right place, then just tweak heights."	i := (ii := self indexOfMorphAbove: localPt) min: submorphs size-1.	prevBot := i <= 0 ifTrue: [(self innerBounds) top]					ifFalse: [(self submorphs at: i) bottom].	nxtHt := (submorphs isEmpty		ifTrue: [insertion]		ifFalse: [self submorphs at: i+1]) height.	d := ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]			ifFalse: [0 max: (localPt y - prevBot min: nxtHt)].	"Top and bottom spacer heights cause continuous motion..."	c1 := Color transparent.  c2 := Color transparent.	ht2 := d*insHt//nxtHt.  ht1 := insHt - ht2.	wid := self width - (2*borderWidth) - (2*self layoutInset).	wid isPoint ifTrue: [wid := wid x].	(spacer1 := BorderedMorph newBounds: (0@0 extent: wid@ht1)				color: (ht1 > (insHt//2) ifTrue: [c1] ifFalse: [c2]))					borderWidth: 1; borderColor: spacer1 color.	self privateAddMorph: spacer1 atIndex: (i+1 max: 1).	(spacer2 := BorderedMorph newBounds: (0@0 extent: wid@ht2)				color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]))					borderWidth: 1; borderColor: spacer2 color.	spacer1 setProperty: #dropZone toValue: true.	spacer2 setProperty: #dropZone toValue: true.	self privateAddMorph: spacer2 atIndex: (i+3 min: submorphs size+1).	self fullBounds.  "Force layout prior to testing for cursor containment"	"Maintain the drop target highlight -- highlight spacer if hand is in it."	{spacer1. spacer2} do:		[:spacer | (spacer containsPoint: localPt) ifTrue:			[spacer color: self dropColor.			"Ignore border color.  Maybe do it later.			self borderColor = self dropColor				ifTrue: [self borderColor: self stdBorderColor]"]].	"If no submorph (incl spacers) highlighted, then re-highlight the block."	"Ignore border color.  Maybe do it later.	((self wantsDroppedMorph: insertion event: hand lastEvent) and:		[(self submorphs anySatisfy: [:m | m containsPoint: localPt]) not])			ifTrue: [self borderColor: self dropColor].	"	"Dragging a tile within a Block, if beside a tile, color it a dropzone"	"Transcript show: localPt y printString; space; show: submorphs first top 		printString; space; show: submorphs last top printString; cr."	dc := self dropColor.	1 to: ((ii+4 min: submorphs size) max: 1) do: [:ind | 		each := submorphs at: ind.		each isSyntaxMorph ifTrue: [			localPt y >= each top 				ifTrue: ["in this one or beyond"					(localPt y < each bottom) 						ifTrue: [(each submorphs anySatisfy: [:m | 								m containsPoint: localPt])							ifTrue: [each setDeselectedColor]							ifFalse: [each color: dc]]						ifFalse: [each color = dc ifTrue: [each setDeselectedColor]]]				ifFalse: [each color = dc ifTrue: [each setDeselectedColor]]]].! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 9/13/2001 15:28'!acceptDroppingMorph: aMorph event: evt	| itNoun old |	"Two cases: 1) a phrase being dropped into a block.  Add a new line.		2) aMorph is replacing self by dropping on it.	For the moment, you have to drop it the right place (the end of a tile if it is complex).  We do not look at enclosing morphs"	itNoun := aMorph isNoun.	self withAllOwnersDo:		[:m | (m isSyntaxMorph and: [m isBlockNode])				ifTrue: [m stopStepping; removeDropZones]].	self isBlockNode & itNoun ifTrue:		[(aMorph nodeClassIs: TempVariableNode) ifTrue:				["If I am a BlockNode, and it is a TempVariableNode, add it into list"				(self addBlockArg: aMorph)].		"If I am a BlockNode and it is a noun add it as a new line"		^ self addToBlock: aMorph event: evt].					self isBlockNode ifTrue: [		 (aMorph nodeClassIs: CommentNode) ifTrue: [^ self addToBlock: aMorph event: evt].		 (aMorph nodeClassIs: ReturnNode) ifTrue: [^ self addToBlock: aMorph event: evt]].	"Later add args and keywords.  later allow comments to be dropped"	"Can't put statement, literal, assignment, or cascade into left side of assignment"	(owner isSyntaxMorph) ifTrue:		[(owner nodeClassIs: AssignmentNode) ifTrue:			[(owner submorphIndexOf: self) = 1 ifTrue:				[aMorph isAVariable ifFalse: [ ^ self]]]].	(aMorph nodeClassIs: AssignmentNode) ifTrue: [		itNoun ifFalse: ["create a new assignment"			self isAVariable ifTrue: [^ self newAssignment]					ifFalse: [^ self]]].	"only assign to a variable"	aMorph deselect.	(old := owner) replaceSubmorph: self by: aMorph.	"do the normal replacement"	(old isSyntaxMorph) ifTrue: [old cleanupAfterItDroppedOnMe].	"now owned by no one"! !!SyntaxMorph methodsFor: 'layout' stamp: 'FBS 2/24/2004 14:24'!addBlockArg: aMorph	"Add a temporary to a block or the method.  Return true if succeed"	"(aMorph nodeClassIs: TempVariableNode) is known to be true."	"***NOTE: This method should be combined with addTempVar:"	| tempHolder tt var nn |	owner isMethodNode ifTrue: [		^ (self addTempVar: aMorph)].	"Node for them is not inside the block"		"If exists, drop the temp in this block and let user extend it."	nn := aMorph decompile string.	"name"	(self isKnownVarName: nn) ifTrue: [^ false].	"already defined"	tt := self firstSubmorph.	tempHolder := tt firstSubmorph isSyntaxMorph 				ifTrue: [(tt nodeClassIs: BlockArgsNode) 							ifTrue: [tt] ifFalse: [nil]]				ifFalse: [nil].	tempHolder ifNil: ["make new row"		tempHolder := self addRow: #blockarg1 on: (BlockArgsNode new).		tempHolder addNoiseString: self noiseBeforeBlockArg.		tempHolder submorphs last firstSubmorph emphasis: TextEmphasis bold emphasisCode.		tempHolder useRoundedCorners.		self addMorphFront: tempHolder.		aMorph parseNode name: nn key: nn code: nil.		aMorph parseNode asMorphicSyntaxIn: tempHolder.		tempHolder cleanupAfterItDroppedOnMe.		^ true].	"Know this variable is not present, so add it"	aMorph parseNode name: nn key: nn code: nil.	tempHolder addMorphBack: (tempHolder transparentSpacerOfSize: 4@4).	var := tempHolder addRow: #tempVariable on: aMorph parseNode.	var layoutInset: 1.	var addMorphBack: (self aSimpleStringMorphWith: nn).	var cleanupAfterItDroppedOnMe.	^ true! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 3/25/2001 16:15'!addColumn: aColorOrSymbol on: aNode	| col |	self addMorphBack: (col := self class column: aColorOrSymbol on: aNode)."col setProperty: #howCreated toValue: thisContext longStack."	self alansTest1 ifTrue: [		(aColorOrSymbol == #block and: [self isMethodNode not]) ifTrue: [			col setConditionalPartStyle.		].	].	^ col! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/15/2001 19:22'!addRow: aColorOrSymbol on: aNode	| row |	self addMorphBack: (row := self class row: aColorOrSymbol on: aNode)."row setProperty: #howCreated toValue: thisContext longStack."	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 8/24/2001 15:15'!addSingleKeywordRow: aStringLikeItem	| row sMorph modifiedString |	(row := self class row: #text on: nil) borderWidth: 1.	modifiedString := self substituteKeywordFor: aStringLikeItem.	sMorph := self addString: modifiedString special: true.	sMorph font: (self fontToUseForSpecialWord: modifiedString).	modifiedString = aStringLikeItem ifFalse: [		sMorph setProperty: #syntacticallyCorrectContents toValue: aStringLikeItem].	row addMorph: sMorph.	self addMorphBack: row.	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 4/4/2001 13:15'!addString: literalOrVarName special: aBoolean	| answer |	"Create and return an UpdatingStringMorph containing the value.  Use an UpdatingStringMorph, so it can inform its owner when it has been edited. Keep the getSelector being nil"	answer := (self anUpdatingStringMorphWith: literalOrVarName special: aBoolean)		target: self;		putSelector: #acceptIgnoring:;		useStringFormat.	^answer! !!SyntaxMorph methodsFor: 'layout' stamp: 'FBS 2/24/2004 14:23'!addTempVar: aMorph 	"know we are a block inside a MethodNode" 	"(aMorph nodeClassIs: TempVariableNode) is known to be true."	| tempHolder ii tt var nn |	nn := aMorph decompile string.	"name"	(self isKnownVarName: nn) ifTrue: [^ false].	"already defined"	tempHolder := nil.	(ii := owner submorphIndexOf: self) = 1 ifFalse: [		tt := owner submorphs at: ii - 1.		tt isSyntaxMorph ifTrue: [			(tt nodeClassIs: MethodTempsNode) ifTrue: [tempHolder := tt].			(tt nodeClassIs: UndefinedObject) ifTrue: [tempHolder := tt findA: MethodTempsNode]]].	tempHolder ifNil: [		tempHolder := owner addRow: #tempVariable on: MethodTempsNode new.		tempHolder addNoiseString: self noiseBeforeBlockArg.		tempHolder submorphs last firstSubmorph emphasis: TextEmphasis bold emphasisCode.		tempHolder useRoundedCorners.		owner addMorph: tempHolder inFrontOf: self.		aMorph parseNode name: nn key: nn code: nil.		aMorph parseNode asMorphicSyntaxIn: tempHolder.		tempHolder cleanupAfterItDroppedOnMe.		^ true].	aMorph parseNode name: nn key: nn code: nil.	tempHolder addMorphBack: (tempHolder transparentSpacerOfSize: 4@4).	var := tempHolder addRow: #tempVariable on: aMorph parseNode.	var layoutInset: 1.	var addMorphBack: (self addString: nn special: false).	var cleanupAfterItDroppedOnMe.	^ true! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 8/10/2001 09:57'!addTextRow: aStringLikeItem	| row tt |	(row := self class row: #text on: nil) borderWidth: 1.	(tt := TextMorph new) contents: aStringLikeItem.	row addMorph: tt.	"row addMorph: (self addString: (aStringLikeItem copyWithout: Character cr) special: false)."	self addMorphBack: row.	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 7/25/2001 10:01'!addToBlock: aMorph event: evt	"Insert a new line of code.  Figure out who it goes before.  If evt Y is within an existing line (to the right of a tile), then replace that tile."	| whereDropped dropBefore replace |	whereDropped := "self pointFromWorld:" evt cursorPoint.	dropBefore := self submorphs 		detect: [:each | each isSyntaxMorph ifTrue: [			whereDropped y < each top ifTrue: [true]	"before this one"				ifFalse: [whereDropped y < each bottom 							ifTrue: [replace := true]	"replace this one"							ifFalse: [false]]]] "try next line"		ifNone: [nil].	(aMorph nodeClassIs: ReturnNode) ifTrue: [dropBefore := nil].		"Returns are always at the end. (Watch out for comments)"	dropBefore 		ifNil: [self addMorphBack: aMorph]		ifNotNil: [			replace ifNotNil: [aMorph deselect.				self replaceSubmorph: dropBefore by: aMorph.	"replace it!!"				^ dropBefore cleanupAfterItDroppedOnMe].	"now owned by no one"			self addMorph: aMorph inFrontOf: dropBefore].	self cleanupAfterItDroppedOnMe.! !!SyntaxMorph methodsFor: 'layout' stamp: 'FBS 2/24/2004 14:22'!addToken: aString type: aColorOrSymbol on: aNode	| sMorph modifiedString noiseWord row |	row := (self addRow: aColorOrSymbol on: aNode) layoutInset: 1.	self alansTest1 ifFalse: [		sMorph := self addString: aString special: false.		row addMorphBack: sMorph.		^row	].	noiseWord := [ :w |		w ifNotNil: [			row 				addMorphBack: (self noiseStringMorph: w);				addMorphBack: (self tokenVerticalSeparator)		].	].	(self shouldBeBrokenIntoWords: aColorOrSymbol) ifTrue: [		modifiedString := self substituteKeywordFor: aString.		sMorph := self addString: modifiedString special: (aColorOrSymbol ~= #assignmentArrow).			"(#(unary keywordGetz keywordSetter unaryGetter) includes: aColorOrSymbol)"		modifiedString = aString ifFalse: [			sMorph setProperty: #syntacticallyCorrectContents toValue: aString].		sMorph setProperty: #syntacticReformatting toValue: aColorOrSymbol;			contents: modifiedString.	] ifFalse: [		sMorph := self addString: (modifiedString := aString) special: false.	].	(#(keyword2 upArrow) includes: aColorOrSymbol) ifTrue: [		sMorph 			font: (self fontToUseForSpecialWord: modifiedString).	].	(#(keyword2 unary assignmentArrow methodHeader1 methodHeader2) includes: aColorOrSymbol) ifTrue: [		sMorph emphasis: TextEmphasis bold emphasisCode.	].	aColorOrSymbol == #blockarg1 ifTrue: [	].	(aColorOrSymbol == #variable or: [aColorOrSymbol == #tempVariable]) ifTrue: [		aString = 'self' ifTrue: [			sMorph setProperty: #wordyVariantOfSelf toValue: true.		].		noiseWord value: (self noiseWordBeforeVariableNode: aNode string: aString).	].	row addMorphBack: sMorph.	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 3/25/2001 17:22'!addTokenSpecialCase: aString type: aColorOrSymbol on: aNode	| sMorph modifiedString noiseWord col |	noiseWord := nil.	sMorph := self addString: aString special: false.	(aColorOrSymbol == #keyword2) ifTrue: [		modifiedString := aString = 'if:' ifTrue: ['Test'] ifFalse: ['Yes'].		sMorph 			font: (self fontToUseForSpecialWord: modifiedString); 			setProperty: #syntacticallyCorrectContents toValue: aString;			contents: modifiedString.	].	col := (self addRow: aColorOrSymbol on: aNode) layoutInset: 1.	noiseWord ifNotNil: [		col 			addMorphBack: (self noiseStringMorph: noiseWord);			addMorphBack: (self transparentSpacerOfSize: 3@1)	].	col addMorphBack: sMorph.	^col! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 8/24/2001 15:21'!addUnaryRow: aStringLikeItem style: aSymbol	| row sMorph modifiedString fontToUse |	(row := self class row: #text on: nil) borderWidth: 1.	modifiedString := self substituteKeywordFor: aStringLikeItem.	sMorph := self addString: modifiedString special: true.	fontToUse := self fontToUseForSpecialWord: modifiedString.	sMorph 		font: fontToUse emphasis: 1;		setProperty: #syntacticReformatting toValue: #unary.	modifiedString = aStringLikeItem ifFalse: [		sMorph setProperty: #syntacticallyCorrectContents toValue: aStringLikeItem].	row addMorph: sMorph.	self addMorphBack: row.	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/15/2001 19:43'!foldMessage	"I am a message whose receiver is wide, and whose message part is a column.	Rearrange me so that the message part appears indented under the receiver part."	| messageRow node2 |	node2 := parseNode copy receiver: nil.	messageRow := SyntaxMorph row: #keyword1 on: node2.	messageRow 		addMorph: (self transparentSpacerOfSize: 20@10);		addMorphBack: submorphs last.		"<<handle noise words better"	self listDirection: #topToBottom;		wrapCentering: #topLeft;		addMorphBack: (self transparentSpacerOfSize: 4@4);		addMorphBack: messageRow.! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 1/15/2001 11:15'!foldMessageOneArg	"I am a message that is wide, a row with receiver and a row with selector and arg.	Rearrange me so that the message part appears indented under the receiver part."	| messageRow node2 |	node2 := parseNode copy receiver: nil.	messageRow := SyntaxMorph row: #keyword1 on: node2.	messageRow addMorph: (self transparentSpacerOfSize: 20@10);			addMorphBack: submorphs second;			addMorphBack: submorphs second.  "was the third"	self listDirection: #topToBottom;		wrapCentering: #topLeft;		addMorphBack: messageRow.! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 8/22/2001 16:30'!isKnownVarName: newVarName	"Return true if this variable is already known, as an argument, temp var, block temp, or instance variable."	| syntLevel |	(self parsedInClass allInstVarNames includes: newVarName) ifTrue: [^ true].	syntLevel := self.	[syntLevel tempVarNodesDo: [:node | 		node decompile string = newVarName ifTrue: [^ true]].	 (syntLevel := syntLevel owner) isSyntaxMorph] whileTrue.	^ false! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 8/1/2001 13:06'!removeReturnNode	| blk |	"If last line is ^ self, remove it.  I am a methodNode.  Keep if no other tiles in the block."	blk := self findA: BlockNode.	blk submorphs last decompile string = '^self ' ifTrue: [		(blk submorphs count: [:ss | ss isSyntaxMorph]) > 1 ifTrue: [			blk submorphs last delete]].! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 8/22/2001 16:35'!tempVarNodesDo: aBlock	"Execute the block for any block temporary variables, method temps, or method args we have"	| tempHolder argsHolder |	((self parseNode class == MethodNode) or: [self parseNode class == BlockNode]) ifTrue: [		self submorphsDoIfSyntax: [:sub | 				(sub nodeClassIs: MethodTempsNode) ifTrue: [tempHolder := sub].				((sub nodeClassIs: UndefinedObject) and: [tempHolder isNil]) ifTrue: [					tempHolder := sub findA: MethodTempsNode].				(sub nodeClassIs: BlockArgsNode) ifTrue: [tempHolder := sub].				(sub nodeClassIs: SelectorNode) ifTrue: [argsHolder := sub].				]			ifString: [:sub | ].		tempHolder ifNotNil: ["Temp variables"			tempHolder submorphsDoIfSyntax: [:sm | 					(sm nodeClassIs: TempVariableNode) ifTrue: [aBlock value: sm]]				ifString: [:sm | ]].		argsHolder ifNotNil: ["arguments"			argsHolder submorphsDoIfSyntax: [:sm | 					(sm nodeClassIs: TempVariableNode) ifTrue: [aBlock value: sm]]				ifString: [:sm | ]].		].	"otherwise do nothing"! !!SyntaxMorph methodsFor: 'layout' stamp: 'ar 8/10/2003 18:19'!unfoldMessage	"I am a message whose message part is a column.	Rearrange me so that the entire message is one row."	| messageRow |	messageRow := self submorphs last.	self removeMorph: messageRow.	messageRow submorphs do: [:m | self addMorphBack: m].! !!SyntaxMorph methodsFor: 'macpal' stamp: 'sw 6/4/2001 19:26'!currentVocabulary	"Answer the current vocabulary associated with the receiver.  If none is yet set, determine an appropriate vocabulary and cache it within my properties dictionary."	| aVocab aSym |	aSym := self valueOfProperty: #currentVocabularySymbol ifAbsent: [nil].	aSym ifNil:		[aVocab := self valueOfProperty: #currentVocabulary ifAbsent: [nil].		aVocab ifNotNil:			[aSym := aVocab vocabularyName.			self removeProperty: #currentVocabulary.			self setProperty: #currentVocabularySymbol toValue: aSym]].	aSym ifNotNil:		[^ Vocabulary vocabularyNamed: aSym].	aVocab := super currentVocabulary.	self setProperty: #currentVocabularySymbol toValue: aVocab vocabularyName.	^ aVocab! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 11/21/2000 16:35'!acceptIfInScriptor	| root |	"If I am in a ScriptEditorMorph, tell my root to accept the new changes."	(self ownerThatIsA: ScriptEditorMorph) ifNotNil: [		root := self rootTile.		root ifNotNil: [root accept]]. ! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/27/2001 17:15'!acceptInCategory: categoryString	"Turn my current state into the text of a method.  Compile it in my class."	| cls sc sel |	self isMethodNode ifFalse: [		self rootTile == self ifTrue: [^ self].  "not in a script"		^ self rootTile accept  "always accept at the root"].	(cls := self parsedInClass) ifNil: [^ self].	sel := cls compile: self decompile classified: categoryString.	(sc := self firstOwnerSuchThat: [:mm | mm class == ScriptEditorMorph]) 		ifNotNil: [sc hibernate; unhibernate].	"rebuild the tiles"	^ sel! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/27/2001 19:12'!acceptSilently	"Turn my current state into the text of a method.	Compile it in my class.  Don't rebuild the tiles."	| cls |	self isMethodNode ifFalse: [		self rootTile == self ifTrue: [^ false].  "not in a script"		^ self rootTile acceptSilently  "always accept at the root"].	(self ownerThatIsA: ScriptEditorMorph) ifNil: [^ false].	(cls := self parsedInClass) ifNil: [^ false].	cls compile: self decompile classified: 'scripts'.	^ true! !!SyntaxMorph methodsFor: 'menus' stamp: 'di 5/4/2001 12:14'!acceptUnlogged	"This is an exact copy of acceptSilently, except it does not log to the source file.	Used for all but the last of scrolling number changes."	| cls |	self isMethodNode ifFalse:		[self rootTile == self ifTrue: [^ self].  "not in a script"		^ self rootTile acceptUnlogged  "always accept at the root"].	(self ownerThatIsA: ScriptEditorMorph) ifNil: [^ self].	(cls := self parsedInClass) ifNil: [^ self].	cls compile: self decompile		classified: ClassOrganizer default		withStamp: nil		notifying: nil		logSource: false.! !!SyntaxMorph methodsFor: 'menus' stamp: 'md 8/15/2005 11:02'!decompile	| stream |	"Produce Smalltalk code.  We have a tree of SyntaxMorphs, but not a tree of ParseNodes.  The user has dragged in many SyntaxMorphs, each with its own parseNode, but those nodes are not sewn together in a tree.  The only data we get from a ParseNode is its class.	We produce really ugly code.  But we compile it and decompile (prettyPrint) again for user to see."	stream := ColoredCodeStream on: (Text new: 400).	self printOn: stream indent: 1.	"Tree walk and produce text of the code"	^ stream contents! !!SyntaxMorph methodsFor: 'menus' stamp: 'md 7/23/2006 15:14'!offerTilesMenuFor: aReceiver in: aLexiconModel	"Offer a menu of tiles for assignment and constants"	| menu |	menu := MenuMorph new addTitle: 'Hand me a tile for...'.	menu addLine.	menu add: '(accept method now)' target: aLexiconModel selector: #acceptTiles.	menu submorphs last color: Color red darker.	menu addLine.	menu add: 'me, by name' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'<me by name>'. aReceiver}.	menu add: 'self' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'self'. VariableNode}.	menu add: '_   (assignment)' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'<assignment>'. nil}.	menu add: '"a Comment"' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'"a comment"\' withCRs. CommentNode}.	menu submorphs last color: Color blue.	menu add: 'a Number' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'5'. LiteralNode}.	menu add: 'a Character' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'$z'. LiteralNode}.	menu add: '''abc''' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'''abc'''. LiteralNode}.	menu add: 'a Symbol constant' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'#next'. LiteralNode}.	menu add: 'true' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'true'. VariableNode}.	menu add: 'a Test' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'true ifTrue: [self] ifFalse: [self]'. MessageNode}.	menu add: 'a Loop' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'1 to: 10 do: [:index | self]'. MessageNode}.	menu add: 'a Block' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'[self]'. BlockNode}.	menu add: 'a Class or Global' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'Character'. LiteralVariableNode}.	menu add: 'a Reply' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'| temp | temp'. ReturnNode}.	menu popUpAt: ActiveHand position forHand: ActiveHand in: World.! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/17/2001 13:38'!offerVarsMenuFor: aReceiver in: aLexiconModel	"Offer a menu of tiles for assignment and constants"	| menu instVarList cls |	menu := MenuMorph new addTitle: 'Hand me a tile for...'.	menu addLine.	menu add: '(accept method now)' target: aLexiconModel selector: #acceptTiles.	menu submorphs last color: Color red darker.	menu addLine.	menu add: 'new temp variable' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'| temp | temp'. TempVariableNode}.	instVarList := OrderedCollection new.	cls := aReceiver class.	[instVarList addAllFirst: cls instVarNames.	 cls == aLexiconModel limitClass] whileFalse: [cls := cls superclass].	instVarList do: [:nn |		menu add: nn target: self selector: #instVarTile: argument: nn].	menu popUpAt: ActiveHand position forHand: ActiveHand in: World.! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 12/14/2001 11:58'!putOnBackground	"Place the receiver, formerly private to its card, onto the shared background.  If the receiver needs data carried on its behalf by the card, such data will be represented on every card."	| updStr |	(updStr := self readOut) ifNotNil: ["If has a place to put per-card data, set that up."		updStr getSelector ifNotNil: [			self setProperty: #holdsSeparateDataForEachInstance toValue: true]].	super putOnBackground.! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 12/10/2001 17:48'!showMenu: evt	| menu |	menu := MenuMorph new.	self rootTile isMethodNode ifTrue:		[menu add: 'accept method' target: self selector: #accept.		menu addLine.		menu add: 'new temp variable' target: self selector: #attachTileForCode:nodeType: 					argumentList: {'| temp | temp'. TempVariableNode}.		menu addLine.		self parsedInClass allInstVarNames do: [:nn |			menu add: nn,' tile' target: self selector: #instVarTile: argument: nn].		menu addLine.		menu add: 'show code' target: self selector: #showCode.		menu add: 'try out' target: self selector: #try.		menu popUpAt: evt hand position forHand: evt hand in: World].! !!SyntaxMorph methodsFor: 'new tiles' stamp: 'md 7/23/2006 15:11'!attachTileForCode: expression nodeType: nodeClass	| nn master tile |	"create a new tile for a part of speech, and put it into the hand"	"a few special cases"	expression = 'self' ifTrue: [		^ (((self string: expression toTilesIn: Object) 				findA: ReturnNode) findA: nodeClass) attachToHand].	expression = '<me by name>' ifTrue: ["Tile for the variable in References"		nn := nodeClass knownName ifNil: [#+].		(References at: nn asSymbol ifAbsent: [nil]) == nodeClass ifTrue: [			^ self attachTileForCode: nn nodeType: LiteralVariableNode].		"otherwise just give a tile for self"		^ self attachTileForCode: 'self' nodeType: VariableNode].	expression = '<assignment>' ifTrue: ["do something really special"		master := self class new.		master addNoiseString: '  _   ' emphasis: TextEmphasis bold emphasisCode.		tile := master firstSubmorph.		^ (tile parseNode: AssignmentNode new) attachToHand].	"special marker"		"When this is dropped on a variable, enclose it in 			a new assignment statement"	"general case -- a tile for a whole line of code is returned"	^ ((self string: expression toTilesIn: Object) 				findA: nodeClass) attachToHand.! !!SyntaxMorph methodsFor: 'new tiles' stamp: 'tk 8/30/2001 06:22'!instVarTile: aName	"Make and put into hand a tile for an instance variable"	| sm |	sm := ((VariableNode new					name: aName					index: 1					type: 1 "LdInstType") asMorphicSyntaxIn: SyntaxMorph new).	sm roundedCorners.	ActiveHand attachMorph: sm.	Preferences tileTranslucentDrag		ifTrue: [sm lookTranslucent.			sm align: sm center with: ActiveHand position "+ self cursorBaseOffset"]		ifFalse: [sm align: sm topLeft with: ActiveHand position + self cursorBaseOffset]! !!SyntaxMorph methodsFor: 'new tiles' stamp: 'tk 9/13/2001 13:44'!string: anExpression toTilesIn: playerClass	| code tree methodNode |	"Construct SyntaxMorph tiles for some code.  Returns the main BlockNode of a doIt."	"This is really cheating!!  Make a true parse tree later. -tk"	code := String streamContents: [:strm | 		strm nextPutAll: 'doIt'; cr; tab; nextPutAll: anExpression].	"decompile to tiles"	tree := Compiler new 		parse: code 		in: playerClass		notifying: nil.	methodNode := tree asMorphicSyntaxUsing: SyntaxMorph.	anExpression first == $" ifTrue: ["a comment" 		"(methodNode findA: CommentNode) firstSubmorph color: Color blue."		^ methodNode].	^ methodNode submorphs detect: [:mm | 		(mm respondsTo: #parseNode) 			ifTrue: [mm parseNode class == BlockNode] 			ifFalse: [false]].! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'tk 7/31/2001 17:27'!addTemporaryControls	| row stdSize |		stdSize := 8@8.	row := AlignmentMorph newRow		color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	self addMorphBack: row.	{		Morph new			extent: stdSize; 			color: Color paleBlue darker;			setBalloonText: 'Change the contrast';			on: #mouseUp send: #controlContrast2: to: self;			on: #mouseMove send: #controlContrast2: to: self;			on: #mouseDown send: #controlContrast2: to: self.	"Removed because it's default is giant tiles, which no one wants. --tk		Morph new			extent: stdSize; 			color: Color green;			setBalloonText: 'Change basic spacing';			on: #mouseUp send: #controlSpacing2: to: self;			on: #mouseMove send: #controlSpacing2: to: self;			on: #mouseDown send: #controlSpacing2: to: self.	"		Morph new			extent: stdSize; 			color: Color lightRed;			setBalloonText: 'Change basic style';			on: #mouseUp send: #changeBasicStyle to: self.	} do: [ :each |		row addMorphBack: each.		row addMorphBack: (self transparentSpacerOfSize: stdSize).	].! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'yo 12/3/2004 17:01'!alanBinaryPostRcvr: aNode key: key args: args	| nodeWithNilReceiver row |"==Repeat for collection [ collect ( from foo. blah blah foo blah) ]Repeat for 1 to 50 [ do ( from i. blah blab i blah ) ]=="	nodeWithNilReceiver := aNode copy receiver: nil.	(row := self addRow: #keyword2 on: nodeWithNilReceiver)		borderWidth: 1;		parseNode: (nodeWithNilReceiver as: MessageNode);		borderColor: row stdBorderColor.	row addToken: key asString		type: #binary		on: (SelectorNode new key: key asString code: nil "fill this in?").	args first asMorphicSyntaxIn: row.! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'tk 7/30/2001 14:52'!alanKeywordMessage: aNode isAConditional: template key: key args: args	| nodeWithNilReceiver column keywords row onlyOne |	(key == #collect: and: [args first isKindOf: BlockNode]) ifTrue: [		^self			alanKwdCollect: aNode 			isAConditional: template 			key: key 			args: args	].	key == #repeatFor:doing: ifTrue: [		^self			alanKwdRepeatForDoing: aNode 			isAConditional: template 			key: key 			args: args	].	key == #if:do: ifTrue: [		^self			alanKwdIfDo: aNode 			isAConditional: template 			key: key 			args: args	].	(args size = 1 and: [key endsWith: 'Getz:']) ifTrue: [		^self			alanKwdSetter: aNode 			isAConditional: 0 			key: key 			args: args	].	(args size = 1 and: [self isStandardSetterKeyword: key]) ifTrue: [		^self			alanKwdSetter2: aNode 			isAConditional: 0 			key: key 			args: args	].	nodeWithNilReceiver := aNode copy receiver: nil.	template = 1 ifTrue: [		self listDirection: #topToBottom.	].	column := self addColumn: #keyword1 on: nodeWithNilReceiver.	keywords := key keywords.	onlyOne := args size = 1.	onlyOne ifFalse: ["necessary for three keyword messages!!"		column setProperty: #deselectedBorderColor toValue: column compoundBorderColor].	keywords		with: (args first: keywords size)		do: [:kwd :arg |			template = 1 ifTrue: [				column addMorphBack: (column transparentSpacerOfSize: 3@3).			].			(row := column addRow: #keyword2 on: nodeWithNilReceiver)				parseNode: (nodeWithNilReceiver as: 						(onlyOne ifTrue: [MessageNode] ifFalse: [MessagePartNode]));				borderColor: row stdBorderColor.			template = 1 ifTrue: [row addMorphBack: (row transparentSpacerOfSize: 20@6)].			row addToken: kwd				type: #keyword2				on: (onlyOne ifTrue: [SelectorNode new key: kwd code: nil "fill this in?"]								ifFalse: [KeyWordNode new]).			(arg asMorphicSyntaxIn: row) setConditionalPartStyle.		].	onlyOne ifTrue: [		self replaceSubmorph: column by: row.		column := row.	].			! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 3/25/2001 16:31'!alanKwdCollect: aNode isAConditional: template key: key args: args	| nodeWithNilReceiver row kwdHolder |	nodeWithNilReceiver := aNode copy receiver: nil.	(row := self addRow: #keyword2 on: nodeWithNilReceiver)		borderWidth: 1;		parseNode: (nodeWithNilReceiver as: MessageNode);		borderColor: row stdBorderColor.	kwdHolder := row		addToken: key		type: #keyword2		on: (SelectorNode new key: key code: nil "fill this in?").	kwdHolder firstSubmorph 		setProperty: #syntacticallyCorrectContents toValue: key asString;		contents: ''.	args first asMorphicCollectSyntaxIn: row.! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'tk 7/30/2001 14:52'!alanKwdIfDo: aNode isAConditional: template key: key args: args	"(know it has more than one arg)"	| nodeWithNilReceiver column keywords row |	nodeWithNilReceiver := aNode copy receiver: nil.	column := self addColumn: #keyword1 on: nodeWithNilReceiver.	"column borderColor: column compoundBorderColor."	keywords := key keywords.	keywords		with: (args first: keywords size)		do: [:kwd :arg |			(row := column addRow: #keyword2 on: nodeWithNilReceiver)				parseNode: (nodeWithNilReceiver as: MessagePartNode).			kwd = 'do:' ifTrue: [				row addMorphBack: (row transparentSpacerOfSize: 26@6).			] ifFalse: [				row addMorphBack: (row transparentSpacerOfSize: 10@6).			].			row addTokenSpecialCase: kwd				type: #keyword2				on: KeyWordNode new.			(arg asMorphicSyntaxIn: row) setConditionalPartStyle.		].			! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/28/2001 10:16'!alanKwdRepeatForDoing: aNode isAConditional: template key: key args: args	| nodeWithNilReceiver row column keywords |	nodeWithNilReceiver := aNode copy receiver: nil.	column := self addColumn: #keyword1 on: nodeWithNilReceiver.	keywords := key keywords.	keywords		with: (args first: keywords size)		do: [:kwd :arg |			(row := column addRow: #keyword2 on: nodeWithNilReceiver)				parseNode: (nodeWithNilReceiver as: MessagePartNode).			row addToken: kwd				type: #keyword2				on: KeyWordNode new.			(arg asMorphicSyntaxIn: row) setConditionalPartStyle.		].! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'FBS 2/24/2004 14:22'!alanKwdSetter2: aNode isAConditional: template key: key args: args	"translates		foo setHeading: 0	to		foo's heading := 0	"	| kwdHolder wordy |	kwdHolder := self		addToken: key		type: #keywordSetter		on: (SelectorNode new key: key code: nil "fill this in?").	wordy := self translateToWordySetter: key.	kwdHolder firstSubmorph 		setProperty: #syntacticReformatting toValue: #keywordSetter;		contents: wordy;		emphasis: TextEmphasis bold emphasisCode.	wordy = key asString ifFalse: [		kwdHolder firstSubmorph 			setProperty: #syntacticallyCorrectContents toValue: key asString].	(args first asMorphicSyntaxIn: self) setConditionalPartStyle			! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'md 7/23/2006 15:15'!alanKwdSetter: aNode isAConditional: template key: key args: args	| nodeWithNilReceiver row kwdHolder |	nodeWithNilReceiver := aNode copy receiver: nil.	(row := self addRow: #keyword2 on: nodeWithNilReceiver)		borderWidth: 1;		parseNode: (nodeWithNilReceiver as: MessageNode);		borderColor: row stdBorderColor.	row addNoiseString: '''s' emphasis: TextEmphasis bold emphasisCode.	kwdHolder := row		addToken: key		type: #keywordGetz		on: (SelectorNode new key: key code: nil "fill this in?").	kwdHolder firstSubmorph 		setProperty: #syntacticReformatting toValue: #keywordGetz;		setProperty: #syntacticallyCorrectContents toValue: key asString;		contents: (self splitAtCapsAndDownshifted: (key asString allButLast: 5));		emphasis: TextEmphasis bold emphasisCode.	row addNoiseString: '_' emphasis: TextEmphasis bold emphasisCode.	(args first asMorphicSyntaxIn: row) setConditionalPartStyle			! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'FBS 2/24/2004 14:21'!alanUnaryGetter: aNode key: key	"I am a MessageNode.  Fill me with a SelectorNode {getX} whose string is {'s x}.  All on one level."	| selSyn usm wordy |	selSyn := self		addToken: key		type: #unaryGetter		on: (SelectorNode new key: key code: nil "fill this in?").	usm := selSyn firstSubmorph.	usm setProperty: #syntacticReformatting toValue: #unaryGetter.	wordy := self translateToWordyGetter: key.	wordy = key asString ifFalse: [		usm setProperty: #syntacticallyCorrectContents toValue: key asString].	usm contents: wordy; emphasis: TextEmphasis bold emphasisCode.! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 4/4/2001 12:49'!alanUnaryPostRcvr: aNode key: key selector: selector	| row |	(self isStandardGetterSelector: key) ifTrue: [		^self alanUnaryGetter: aNode key: key	].	row := (self addUnaryRow: key style: #unary) layoutInset: 1.	^ row parseNode: selector! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'md 7/23/2006 15:14'!assignmentNode: aNode variable: variable value: value	| row v expMorph |	row := self addRow: #assignment on: aNode.	v := variable asMorphicSyntaxIn: row.	self alansTest1 ifTrue: [v setConditionalPartStyle; layoutInset: 2].	row addToken: ' := ' type: #assignmentArrow on: aNode.	expMorph := value asMorphicSyntaxIn: row.	self alansTest1 ifTrue: [		row setSpecialOuterTestFormat.		(expMorph hasProperty: #deselectedColor) ifFalse: [expMorph setConditionalPartStyle].	].	^row! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/22/2001 17:00'!cascadeNode: aNode receiver: receiver messages: messages	| row |	self alansTest1 ifTrue: [		row := self addColumn: #cascade on: aNode.		row setSpecialOuterTestFormat.	] ifFalse: [		row := self addRow: #cascade on: aNode	].	receiver asMorphicSyntaxIn: row.	messages do: [:m | m asMorphicSyntaxIn: row].	^ row"	(node2 := aNode copy) receiver: nil messages: messages.	cascadeMorph := row addColumn: #cascade2 on: node2.	messages do: [ :m | m asMorphicSyntaxIn: cascadeMorph].	^row"! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/26/2001 14:04'!messageOneArg: key receiver: receiver selector: selector args: args	| row firstArgMorph |	row := (self addSingleKeywordRow: key) layoutInset: 1.	row parseNode: selector.	firstArgMorph := args first asMorphicSyntaxIn: self.	receiver ifNil: [^ self].	(firstArgMorph fullBounds height > 100			or: [firstArgMorph fullBounds width > 250])		ifTrue: [self foldMessageOneArg].! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/26/2001 17:12'!methodNodeInner: aNode selectorOrFalse: selectorOrFalse precedence: precedence arguments: arguments temporaries: temporaries primitive: primitive block: block	| header selNode |	selNode := selectorOrFalse class == SelectorNode 		ifTrue: [selectorOrFalse] 		ifFalse: [SelectorNode new key: selectorOrFalse code: nil].	header := self addRow: Color white on: selNode.	precedence = 1		ifTrue: [header addToken: aNode selector type: #methodHeader1 on: selNode]		ifFalse: [aNode selector keywords with: arguments do:					[:kwd :arg | 					header addToken: kwd type: #methodHeader2 on: selNode.					(arg asMorphicSyntaxIn: header) color: #blockarg2]].	aNode addCommentToMorph: self.	self addTemporaries: temporaries.	(primitive > 0 and: [(primitive between: 255 and: 519) not]) ifTrue:		["Dont decompile <prim> for, eg, ^ self "		self addTextRow: (String streamContents: [ :strm | aNode printPrimitiveOn: strm])].	block asMorphicSyntaxIn: self.	^ self! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'tk 7/31/2001 17:37'!methodNodeOuter: aNode	| block |		self borderWidth: 0.	aNode asMorphicSyntaxIn: self.	self alansTest1 ifTrue: [self addTemporaryControls].	self finalAppearanceTweaks.		"self setProperty: #deselectedColor toValue: Color transparent."	block := self findA: BlockNode.		"block setProperty: #deselectedColor toValue: Color transparent."	block submorphs size = 1 ifTrue: [^ self].	"keep '^ self' if that is the only thing in method"	block submorphs last decompile string = '^  self ' ifTrue: [		block submorphs last delete].	^ self! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/15/2001 19:49'!vanillaMessageNode: aNode receiver: receiver selector: selector arguments: arguments	| substitute row sel |	sel := #message.	((self nodeClassIs: CascadeNode) and: [self parseNode receiver ~~ aNode]) ifTrue: [		sel := #keyword2.		receiver ifNotNil: [self inform: 'receiver should be nil']].	row := self addRow: sel on: aNode.	substitute := aNode as: TileMessageNode.	(aNode macroPrinter == #printCaseOn:indent:) ifTrue: [		aNode asMorphicCaseOn: row indent: nil.		^ self].	aNode macroPrinter		ifNotNil: 			[substitute perform: aNode macroPrinter with: row with: nil]		ifNil: 			[substitute 				printKeywords: selector key				arguments: arguments				on: row				indent: nil].	^ row addTransparentSpacerOfSize: 3@0.	"horizontal spacing only"! !!SyntaxMorph methodsFor: 'node types' stamp: 'tk 9/26/2001 05:50'!isDeclaration	"Return true if I am a TempVarNode inside a declaration of some kind, including a method arg"	| opc |	owner isSyntaxMorph ifFalse: [^ false].	opc := owner parseNode class.	opc == BlockArgsNode ifTrue: [^ true].	opc == MethodTempsNode ifTrue: [^ true].	opc == SelectorNode ifTrue: [^ true].	^ false! !!SyntaxMorph methodsFor: 'player' stamp: 'tk 2/15/2002 13:03'!variableDocks	"Answer a list of VariableDock objects for docking up my data with an instance held in my containing playfield.  For a numeric-readout tile."	"Is CardPlayer class holding my variableDock, or should I be using the caching mechanism in Morph>>variableDocks?"	| updatingString lab nn aGetter |	(updatingString := self readOut) ifNil: [^ #()].	updatingString getSelector ifNil: [		lab := self submorphNamed: 'label' ifNone: [self defaultName].		nn := lab contents asString.		"nn at: 1 put: nn first asUppercase."		updatingString getSelector: (aGetter := 'get',nn) asSymbol;			putSelector: (ScriptingSystem setterSelectorForGetter: aGetter).		].	^ Array with: (VariableDock new 			variableName: (updatingString getSelector allButFirst: 3) withFirstCharacterDownshifted 			type: #number 			definingMorph: updatingString 			morphGetSelector: #valueFromContents 			morphPutSelector: #acceptValue:)! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'md 7/23/2006 15:14'!assignmentArrow	"Offer to embed this variable in a new assignment statement.  (Don't confuse this with upDownAssignment:, which runs the up and down arrows that rotate among assignment types.)"	| rr |	self isAVariable ifFalse: [^ nil].	self isDeclaration ifTrue: [^ nil].	^ (rr := RectangleMorph new)		extent: 11@13; borderWidth: 1; color: Color lightGreen;		borderColor: Color gray;		addMorph: ((self noiseStringMorph: '_') topLeft: rr topLeft + (3@0));		on: #mouseUp send: #newAssignment to: self! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'gk 2/23/2004 21:08'!changeSound: upDown	| ind arg st soundChoices index it current |	"move in the list of sounds.  Adjust arg tile after me"	ind := owner submorphs indexOf: self.	arg := owner submorphs atWrap: ind+1.	arg isSyntaxMorph ifFalse: [^ self].	st := arg submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	soundChoices := SoundService default sampledSoundChoices.	current := st contents copyFrom: 2 to: st contents size-1.	"remove string quotes"	index := soundChoices indexOf: current.	index > 0 ifTrue:		[st contents: (it := soundChoices atWrap: index + upDown) printString.		self playSoundNamed: it].! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 8/26/2001 14:31'!colorPatch	"Return a color patch button that lets the user choose a color and modifies the code"	| cc patch sel completeMsg |			((self nodeClassIs: MessageNode) "or: [self nodeClassIs: SelectorNode]") ifFalse: [^ nil].	(sel := self selector) ifNil: [^ nil].	(Color colorNames includes: sel) | (sel == #r:g:b:) ifFalse: [^ nil].		"a standard color name"	completeMsg := self isNoun ifTrue: [self] 				ifFalse: [owner isNoun ifTrue: [owner] ifFalse: [owner owner]].	(cc := completeMsg try) class == Color ifFalse: [^ nil].	patch := ColorTileMorph new colorSwatchColor: cc.		"sends colorChangedForSubmorph: to the messageNode"	patch color: Color transparent; borderWidth: 0.  patch submorphs last delete.	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 2/21/2001 16:37'!deleteLine	| temp |	temp := owner.	self deletePopup.	self delete.	temp setSelection: nil.	temp acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 2/21/2001 13:09'!dismisser	"Return the icon to delete this line of tiles.  I am an entire line in a block."	| handle handleSpec colorToUse iconName form |	(owner isSyntaxMorph and: [owner nodeClassIs: BlockNode]) ifFalse: [^ nil].	handleSpec := Preferences haloSpecifications fourth.	"dismiss"	handle := EllipseMorph			newBounds: (Rectangle center: 10@10 extent: 16 asPoint)			color: (colorToUse := Color colorFrom: handleSpec color).	iconName := handleSpec iconSymbol.	form := ScriptingSystem formAtKey: iconName.	"#'Halo-Dismiss'"	handle addMorphCentered: (ImageMorph new				image: form; 				color: colorToUse makeForegroundColor;				lock).	handle on: #mouseDown send: #deleteLine to: self.	^ handle! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 10/17/2001 13:38'!dupTile: evt	| dup |	self deletePopup.	"self deselect."	dup := self duplicateMorph: evt.	Preferences tileTranslucentDrag		ifTrue: [dup align: dup center with: evt hand position.				dup lookTranslucent]		ifFalse: [dup align: dup topLeft					with: evt hand position + self cursorBaseOffset].! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 10/17/2001 13:29'!duplicator	"Return the icon to duplicate this tile."	| handle handleSpec colorToUse iconName form |	handleSpec := Preferences haloSpecifications at: 11.	"duplicate"	handle := EllipseMorph			newBounds: (Rectangle center: 10@10 extent: 16 asPoint)			color: (colorToUse := Color colorFrom: handleSpec color).	iconName := handleSpec iconSymbol.	form := ScriptingSystem formAtKey: iconName.	"#'Halo-Dup'"	handle addMorphCentered: (ImageMorph new				image: form; 				color: colorToUse makeForegroundColor;				lock).	handle on: #mouseDown send: #dupTile: to: self.	^ handle! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/28/2001 13:38'!extend	| messageNodeMorph first |	"replace this noun with a new message like (arg + 1).  If type is not known, ask the user to type in a selector.  Use nil as arg.  Let user drag something to it afterwards."	"Later do evaluation of self to see what type and offer right selector"	self deselect.	messageNodeMorph := (MessageSend receiver: 1 selector: #+ arguments: #(1))								asTilesIn: Player globalNames: false.	owner replaceSubmorph: self by: messageNodeMorph.	first := messageNodeMorph submorphs detect: [:mm | mm isSyntaxMorph].	messageNodeMorph replaceSubmorph: first by: self.	self acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 8/24/2001 13:14'!extendArrow	"Return the extend arrow button.  It replaces the argument with a new message.	I am a number or getter messageNode."	| patch |		self isNoun ifFalse: [^ nil].	self isDeclaration ifTrue: [^ nil].	patch := (ImageMorph new image: (TileMorph classPool at: #SuffixPicture)).	patch on: #mouseDown send: #extend to: self.	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/28/2001 11:35'!newAssignment	"I am a variableNode.  Place me inside an assignment statement."	| new old |	parseNode name: self decompile.	"in case user changed name"	new := owner assignmentNode: AssignmentNode new variable: parseNode 					value: parseNode copy.	self deselect.	(old := owner) replaceSubmorph: self by: new.	"do the normal replacement"	(old isSyntaxMorph) ifTrue: [old cleanupAfterItDroppedOnMe].	"now owned by no one"! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'dgd 2/22/2003 13:40'!offerPopUp	"Put up a halo to allow user to change		Literals (Integer, true),		Selector (beep: sound, +,-,*,//,\\, r:g:b:, setX: incX: decX: for any X,),		Variable (Color),		not AssignmentNode (:= inc dec),	Extend arrows on each literal, variable, and message, (block that is by itself).	Retract arrows on each literal or variable, or message or block that is an argument.	Any literal can be changed by Shift-clicking and typing."	| panel any upDown retract extend colorPatch edge dismiss rr duplicate |	(self hasProperty: #myPopup) ifTrue: [^self].	"already has one"	any := false.	(upDown := self upDownArrows) ifNotNil: [any := true].	"includes menu of selectors"	(retract := self retractArrow) ifNotNil: [any := true].	(extend := self extendArrow) ifNotNil: [any := true].	(dismiss := self dismisser) ifNotNil: [any := true].	(duplicate := self duplicator) ifNotNil: [any := true].	"(assign := self assignmentArrow) ifNotNil: [any := true].			get from menu or any other assignment"	submorphs last class == ColorTileMorph 		ifFalse: [(colorPatch := self colorPatch) ifNotNil: [any := true]].	any ifFalse: [^self].	"Transcript cr; print: parseNode class; space; 		print: (self hasProperty: #myPopup); endEntry."	panel := (RectangleMorph new)				color: Color transparent;				borderWidth: 0.	upDown ifNotNil: 			[panel addMorphBack: upDown first.			upDown first align: upDown first topLeft with: panel topLeft + (0 @ 0).			panel addMorphBack: upDown second.			upDown second align: upDown second topLeft				with: upDown first bottomLeft + (0 @ 1).			upDown size > 2 				ifTrue: 					[panel addMorphBack: upDown third.					upDown third align: upDown third topLeft						with: upDown first topRight + (2 @ 3)]].	rr := self right.	colorPatch ifNotNil: 			[rr := rr + colorPatch submorphs first width + 1.			self addMorphBack: colorPatch	"always in tile"			"colorPatch align: colorPatch topLeft 					with: panel topLeft + (1@1)"].	retract ifNotNil: 			[edge := panel submorphs isEmpty 						ifTrue: [panel left]						ifFalse: [panel submorphs last right].			panel addMorphBack: retract.			retract align: retract topLeft with: (edge + 2) @ (panel top + 3)].	extend ifNotNil: 			[edge := panel submorphs isEmpty 						ifTrue: [panel left]						ifFalse: [panel submorphs last right].			panel addMorphBack: extend.			extend align: extend topLeft with: (edge + 2) @ (panel top + 3)].	duplicate ifNotNil: 			[edge := panel submorphs isEmpty 						ifTrue: [panel left]						ifFalse: [panel submorphs last right].			panel addMorphBack: duplicate.			duplicate align: duplicate topLeft with: (edge + 2) @ (panel top + 1)].	dismiss ifNotNil: 			[edge := panel submorphs isEmpty 						ifTrue: [panel left]						ifFalse: [panel submorphs last right].			panel addMorphBack: dismiss.			dismiss align: dismiss topLeft with: (edge + 2) @ (panel top + 1)].	"	assign ifNotNil: [		edge := panel submorphs isEmpty 			ifTrue: [panel left] 			ifFalse: [panel submorphs last right].		panel addMorphBack: assign.		assign align: assign topLeft with: (edge+2) @ (panel top + 2)]."	panel align: panel topLeft with: rr @ (self top - 2).	panel extent: panel submorphs last bottomRight - panel topLeft.	self setProperty: #myPopup toValue: panel.	self addMorphBack: panel	"Any reason ever to have panel below?"	"(owner listDirection = #topToBottom and: [self listDirection = #leftToRight])		ifTrue: [self addMorphBack: panel]		ifFalse: [owner addMorph: panel after: self]."! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/28/2001 13:39'!replaceKeyWord: evt menuItem: stringMorph	"Replace my entire message (which may be multi-part) with the one specified.  Preserve all argument tiles, either in the new message or in the world outside the scriptor.  I am a SelectorNode or KeyWordNode."	| menu new news newSel mm newTree newRec newArgs top oldArgNodes share ctrY |	(menu := stringMorph owner owner) class == RectangleMorph ifTrue: [		menu delete].	new := stringMorph contents.	new first = $( ifTrue: [^ self].	"Cancel"	new first = $  ifTrue: [^ self].	"nothing"	news := String streamContents: [:strm | "remove fake args"		(new findBetweenSubStrs: #(' 5' $ )) do: [:part | strm nextPutAll: part]].	newSel := stringMorph valueOfProperty: #syntacticallyCorrectContents.	newSel ifNil: [newSel := news].	mm := MessageSend receiver: 5 selector: newSel 			arguments: ((Array new: newSel numArgs) atAllPut: 5).	newTree := mm asTilesIn: Object globalNames: false.	newRec := newTree receiverNode.	newArgs := newTree argumentNodes.	ctrY := self fullBoundsInWorld center y.	top := self messageNode.	newRec owner replaceSubmorph: newRec by: top receiverNode.	oldArgNodes := top argumentNodes.	share := newArgs size min: oldArgNodes size.	(newArgs first: share) with: (oldArgNodes first: share) do: [:newNode :oldNode | 		newNode owner replaceSubmorph: newNode by: oldNode].	"later get nodes for objects of the right type for new extra args"	top owner replaceSubmorph: top by: newTree.	"Deposit extra args in the World"	(oldArgNodes copyFrom: share+1 to: oldArgNodes size) do: [:leftOver |		(leftOver parseNode class == LiteralNode and: [leftOver decompile asString = '5']) 			ifFalse: [newTree pasteUpMorph addMorphFront: leftOver.				leftOver position: newTree enclosingPane fullBoundsInWorld right - 20 @ ctrY.				ctrY := ctrY + 26]			ifTrue: [leftOver delete]].	newTree acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/19/2001 21:32'!replaceSel: evt menuItem: stringMorph	"I rep a SelectorNode.  Replace my selector with new one that was just chosen from a menu"	| menu new old newSel ms oa na case news |	(menu := stringMorph owner owner) class == RectangleMorph ifTrue: [		menu delete].	new := stringMorph contents.	new first = $( ifTrue: [^ self].	"Cancel"	new first = $  ifTrue: [^ self].	"nothing"	news := String streamContents: [:strm | "remove fake args"		(new findBetweenSubStrs: #(' 5' $ )) do: [:part | strm nextPutAll: part]].	newSel := stringMorph valueOfProperty: #syntacticallyCorrectContents.	newSel ifNil: [newSel := news].	old := (ms := self findA: StringMorph) valueOfProperty: #syntacticallyCorrectContents.	old ifNil: [old := (self findA: StringMorph) contents].	oa := old numArgs.  na := newSel numArgs.  case := 5.	(oa = 1) & (na = 1) ifTrue: [case := 1]. 	(oa = 0) & (na = 0) ifTrue: [case := 2].	(oa = 1) & (na  = 0) ifTrue: [case := 3].	(oa = 0) & (na  = 1) ifTrue: [case := 4].	case <= 4 ifTrue: ["replace the selector"		ms contents: news.	"not multi-part"		ms setProperty: #syntacticallyCorrectContents toValue: newSel].	case = 3 ifTrue: [owner tossOutArg: 1].	case = 4 ifTrue: [self addArg: 1].	"more cases here.  Rebuild the entire MessageNode"		self acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/28/2001 10:06'!retract	"replace this message with its receiver.  I am the message node."	| rec cascade msg |	(self nodeClassIs: CascadeNode) ifTrue:		["This is a piece of a cascaded message -- just delete it"		self deletePopup.		cascade := owner.		self delete.		cascade setSelection: {cascade. nil. cascade}.		^ cascade acceptIfInScriptor].	self deletePopup.	(rec := self receiverNode)		ifNil: [msg := owner.			rec := owner receiverNode.			msg owner replaceSubmorph: msg by: rec]		ifNotNil: [owner replaceSubmorph: self by: rec].	rec setSelection: {rec. nil. rec}.	rec acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'di 12/13/2000 12:57'!retractArrow	"Return the retract arrow button.  It replaces the current message with its receiver.	I am in a MessageNode whose first subnode is not a MessagePartNode.  I did not encounter a block on the way up to it.  I am the last subnode in every owner up to it."	| patch |	(self nodeClassIs: MessageNode) ifFalse: [^ nil].	(owner isSyntaxMorph and: [owner parseNode == parseNode]) ifTrue: [^ nil].	patch := (ImageMorph new image: (TileMorph classPool at: #RetractPicture)).	patch on: #mouseDown send: #retract to: self.	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/18/2001 16:27'!selectorMenu	"Put up a menu of all selectors that my receiver could be sent.  Replace me with the one chosen.  (If fewer args, put the tiles for the extra arg to the side, in script's owner (world?).)	Go ahead and eval receiver to find out its type.  Later, mark selectors for side effects, and don't eval those.	Put up a table.  Each column is a viewer category."	| cats value catNames interfaces list setter wording all words ind aVocabulary limitClass |	cats := #().	all := Set new.	value := self receiverObject.	value class == Error ifTrue: [^ nil].		aVocabulary := self vocabularyToUseWith: value.	limitClass := self limitClassToUseWith: value vocabulary: aVocabulary.	catNames := value categoriesForVocabulary: aVocabulary limitClass: limitClass.	cats := catNames collect: [:nn | 		list := OrderedCollection new.		interfaces := value methodInterfacesForCategory: nn 						inVocabulary: aVocabulary limitClass: limitClass.		interfaces do: [:mi | 			(all includes: mi selector) ifFalse: [				"list add: (self aSimpleStringMorphWith: mi elementWording).  Expensive"				words := mi selector.				(words beginsWith: 'get ') ifTrue: [words := words allButFirst: 4].				mi selector last == $: ifTrue: [					words := String streamContents: [:strm | "add fake args"						(words findTokens: $:) do: [:part | strm nextPutAll: part; nextPutAll: ' 5 ']].					words := words allButLast].				mi selector isInfix ifTrue: [words := words, ' 5'].				words := self splitAtCapsAndDownshifted: words.					list add: (self anUpdatingStringMorphWith: words special: true).				words = mi selector ifFalse: [					list last setProperty: #syntacticallyCorrectContents toValue: mi selector].				all add: mi selector].			setter := mi companionSetterSelector asString.			(setter = 'nil') | (all includes: setter) ifFalse: ["need setters also"				wording := (self translateToWordySetter: setter).				list add:  (self aSimpleStringMorphWith: wording, ' 5').				wording = setter ifFalse: [					list last setProperty: #syntacticallyCorrectContents 						toValue: setter].				all add: setter]].		list].	(ind := catNames indexOf: 'scripts') > 0 ifTrue: [		(cats at: ind) first contents = 'empty script' ifTrue: [(cats at: ind) removeFirst]].	cats first addFirst: (self aSimpleStringMorphWith: ' ').	"spacer"	cats first addFirst: (self aSimpleStringMorphWith: '( from ', value class name, ' )').	cats first first color: (Color green mixed: 0.25 with: Color black).	self selectorMenuAsk: cats.	"The method replaceSel:menuItem: does the work.  		and replaces the selector."	! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/20/2001 16:04'!selectorMenuAsk: listOfLists	"I represent a SelectorNode to be replaced by one of the selectors in one of the category lists.  Each list has pre-built StringMorphs in it."	| menu col |	listOfLists isEmpty ifTrue: [^ nil].	listOfLists first addFirst: (self aSimpleStringMorphWith: '( Cancel )').	listOfLists first first color: Color red.	menu := RectangleMorph new.	menu listDirection: #leftToRight; layoutInset: 3; cellInset: 1@0.	menu layoutPolicy: TableLayout new; hResizing: #shrinkWrap; 		vResizing: #shrinkWrap; color: (Color r: 0.767 g: 1.0 b: 0.767);		useRoundedCorners; cellPositioning: #topLeft.	listOfLists do: [:ll |		col := Morph new.	 	col listDirection: #topToBottom; layoutInset: 0; cellInset: 0@0.		col layoutPolicy: TableLayout new; hResizing: #shrinkWrap.		col color: Color transparent; vResizing: #shrinkWrap.		menu addMorphBack: col.		ll do: [:ss | 			col addMorphBack: ss.			ss on: #mouseUp send: #replaceKeyWord:menuItem: to: self]		].	self world addMorph: menu.	menu setConstrainedPosition: (owner localPointToGlobal: self topRight) + (10@-30) 			hangOut: false.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'sw 3/18/2004 00:35'!setSelector: stringLike in: stringMorph	"Store the new selector and accept method."	| aSymbol myType str |	aSymbol := stringLike asSymbol.	(ScriptingSystem helpStringOrNilFor: aSymbol) ifNotNilDo:		[:aString |			self setBalloonText: aString translated].	myType := stringMorph valueOfProperty: #syntacticReformatting ifAbsent: [#none].	str := aSymbol.	(self isStandardSetterKeyword: str) ifTrue: [str := self translateToWordySetter: str].	(self isStandardGetterSelector: str) ifTrue: [str := self translateToWordyGetter: str].	(self shouldBeBrokenIntoWords: myType) 		ifTrue: [str := self substituteKeywordFor: str].	stringMorph contents: str.	"parseNode key: aSymbol code: nil."	str = stringLike ifFalse:		[stringMorph setProperty: #syntacticallyCorrectContents toValue: aSymbol].	self acceptSilently! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/19/2001 15:47'!tossOutArg: extras	"Remove the tiles for the last N keywords and arguments.  Place the tiles beside the current window.  I am a SyntaxMorph for a MessageNode."	| cnt ctr |	cnt := 0.	 submorphs copy reverseDo: [:sub |		ctr := sub fullBoundsInWorld center.		sub delete.		(sub isSyntaxMorph and: [sub parseNode notNil]) ifTrue: [			sub isNoun ifTrue: [				self pasteUpMorph addMorphFront: sub.				sub position: self enclosingPane fullBoundsInWorld right - 20 @ ctr y].			(cnt := cnt + 1) >= extras ifTrue: [^ self]]].! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 8/24/2001 13:35'!upDown: delta event: evt arrow: arrowMorph	| st |	st := submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	(self nodeClassIs: LiteralNode) ifTrue:		[ "+/- 1"		st contents: (self decompile asNumber + delta) printString.		^ self acceptUnlogged].	(self nodeClassIs: VariableNode) ifTrue:		[ "true/false"		st contents: (self decompile string = 'true') not printString.		^ self acceptSilently ifFalse: [self changed].			"maybe set parseNode's key"].	(self upDownArithOp: delta) ifTrue: [^ self].	"+ - // *   < > <= =   beep:"	(self upDownAssignment: delta) ifTrue: [^ self].		"Handle assignment --  increaseBy:  <-   multiplyBy:"! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 7/24/2001 17:54'!upDownArithOp: delta	"Change a + into a -.  Also do sounds (change the arg to the beep:)."	| aList index st |	st := submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	(self nodeClassIs: SelectorNode) ifTrue:		[aList := #(+ - * / // \\ min: max:).		(index := aList indexOf: self decompile asString) > 0 ifTrue:			[self setSelector: (aList atWrap: index + delta) in: st.  ^ true].		aList := #(= ~= > >= isDivisibleBy: < <=).		(index := aList indexOf: self decompile asString) > 0 ifTrue:			[self setSelector: (aList atWrap: index + delta) in: st.  ^ true].		aList := #(== ~~).		(index := aList indexOf: self decompile asString) > 0 ifTrue:			[self setSelector: (aList atWrap: index + delta) in: st.  ^ true].		'beep:' = self decompile asString ifTrue:			["replace sound arg"			self changeSound: delta.			self acceptSilently.  ^ true].		].	^ false! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/20/2001 16:33'!upDownArrows	"Return an array of two up/down arrow buttons.	It replaces the selector or arg with a new one.	I am a number or boolean or a selector (beep:, +,-,*,//,\\, or setX: incX: decX: for any X."	| patch any noMenu |	any := (self nodeClassIs: LiteralNode) and: [parseNode key isNumber].	any := any or: [(self nodeClassIs: VariableNode) and:						[(#('true' 'false') includes: self decompile asString)]].	noMenu := any.	any := any or: [self nodeClassIs: SelectorNode].	"arrows and menu of selectors"	any := any or: [self nodeClassIs: KeyWordNode].	any ifFalse: [^ nil].	patch := {(ImageMorph new image: TileMorph upPicture)				on: #mouseDown send: #upDown:event:arrow: to: self withValue: 1;				on: #mouseStillDown send: #upDownMore:event:arrow: 					to: self withValue: 1;				on: #mouseUp send: #upDownDone to: self.			(ImageMorph new image: TileMorph downPicture)				on: #mouseDown send: #upDown:event:arrow: to: self withValue: -1;				on: #mouseStillDown send: #upDownMore:event:arrow: 					to: self withValue: -1;				on: #mouseUp send: #upDownDone to: self}.	noMenu ifFalse: [patch := patch, {(RectangleMorph new)						extent: 6@10; borderWidth: 1;						borderColor: Color gray;						on: #mouseUp send: #selectorMenu to: self}.					patch last color: ((self nodeClassIs: SelectorNode) 						ifTrue: [Color lightGreen] ifFalse: [Color red darker])].	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 8/24/2001 12:33'!upDownAssignment: delta	"Rotate between increaseBy:  decreaseBy:   :=  multiplyBy:"	| st now want instVar |	st := submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	(self nodeClassIs: SelectorNode) ifTrue:		["kinds of assignment"		((now := self decompile asString) beginsWith: 'set') ifTrue:			["a setX: 3"			want := 1+delta.  instVar := (now allButFirst: 3) allButLast].		(now endsWith: 'IncreaseBy:') ifTrue:			["a xIncreaseBy: 3 a setX: (a getX +3)."			want := 2+delta.  instVar := now allButLast: 11].		(now endsWith: 'DecreaseBy:') ifTrue:			["a xDecreaseBy: 3 a setX: (a getX -3)."			want := 3+delta.  instVar := now allButLast: 11].		(now endsWith: 'MultiplyBy:') ifTrue:			["a xMultiplyBy: 3 a setX: (a getX *3)."			want := 4+delta.  instVar := now allButLast: 11].		want ifNil: [^ false].		instVar := instVar asLowercase.		want := #(1 2 3 4) atWrap: want.		want = 1 ifTrue:			["setter method is present"			self setSelector: ('set', instVar capitalized, ':') in: st.  ^ true].		want = 2 ifTrue:			["notUnderstood will create the method if needed"			self setSelector: instVar, 'IncreaseBy:' in: st.  ^ true].		want = 3 ifTrue:			["notUnderstood will create the method if needed"			self setSelector: instVar, 'DecreaseBy:' in: st.  ^ true].		want = 4 ifTrue:			["notUnderstood will create the method if needed"			self setSelector: instVar, 'MultiplyBy:' in: st.  ^ true].		].	^ false! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'di 5/4/2001 12:26'!upDownMore: delta event: evt arrow: arrowMorph	| st delay1 delay2 now timeOfLastTick currentDelay |	(self nodeClassIs: LiteralNode) ifFalse: [^ self].	st := submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	delay1 := 300.  "ms"	delay2 := 50.  "ms"	now := Time millisecondClockValue.	timeOfLastTick := (self valueOfProperty: #timeOfLastTick) ifNil: [now - delay1].	currentDelay := (self valueOfProperty: #currentDelay) ifNil: [delay1].	now >= (timeOfLastTick + currentDelay) ifTrue:		[self setProperty: #timeOfLastTick toValue: now.		"decrease the delay"		self setProperty: #currentDelay toValue: (currentDelay*8//10 max: delay2).		st contents: (self decompile asNumber + delta) printString.		^ self acceptUnlogged].! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/23/2001 01:33'!getHeader: strm	| se |	"We are in an EToy scriptor and the method header line has been removed.  Try to recover the method name.  Fail if method has args (deal with this later)."	(se := self ownerThatIsA: ScriptEditorMorph) ifNotNil: [		se scriptName numArgs > 0 ifTrue: [^ false].	"abort"		strm nextPutAll: se scriptName].	^ true! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/23/2001 02:11'!printAssignmentNodeOn: strm indent: level	"sometimes an assignment is in parens"	| parens above |	parens := submorphs size >= 3.	parens ifTrue: [		above := self ownerPrecedence.	"high if not in an expression"		parens := above <= 3].	"assignment is a noun inside a message"	parens ifTrue: [strm nextPut: $( ].	self		submorphsDoIfSyntax: [ :sub |			sub printOn: strm indent: level.			strm ensureASpace.		]		ifString: [ :sub |			strm ensureNoSpace. 	":= will have a leading space"			self printSimpleStringMorph: sub on: strm		].	parens ifTrue: [strm ensureNoSpace; nextPut: $) ].! !!SyntaxMorph methodsFor: 'printing' stamp: 'RAA 3/4/2001 12:19'!printBlockArgsNodeOn: strm indent: level	| argString |	self		submorphsDoIfSyntax: [ :sub |			(argString := sub decompile) isEmpty ifFalse: [				strm 					nextPut: $:;					nextPutAll: argString;					space			].		] 		ifString: [ :sub |			"self printSimpleStringMorph: sub on: strm	<<<< do we need this??"		].	strm nextPut: $|; crtab: level.! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/23/2001 01:17'!printBlockNodeOn: strm indent: level	| lev inASyntaxButNotOutermost subNodeClass |	lev := level.	inASyntaxButNotOutermost := owner isSyntaxMorph and: [ owner isMethodNode not].	inASyntaxButNotOutermost ifTrue: [strm nextPut: $[.  lev := lev+1].	self		submorphsDoIfSyntax: [ :sub |			sub printOn: strm indent: lev.			subNodeClass := sub parseNode class.			(#(BlockArgsNode ReturnNode CommentNode) includes: subNodeClass name) ifFalse: [				strm ensureNoSpace; nextPut: $.].			subNodeClass == BlockArgsNode				ifTrue: [strm space]				ifFalse: [strm crtab: lev].		] 		ifString: [ :sub |			self printSimpleStringMorph: sub on: strm		].	inASyntaxButNotOutermost ifTrue: [strm nextPut: $] ].! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/23/2001 01:19'!printCascadeNodeOn: strm indent: level	| parens cnt me above |	parens := parseNode receiver notNil.	parens ifTrue: [me := self selector precedence.		above := self ownerPrecedence.	"high if not in an expression"		parens := me > above].	parens ifTrue: [strm nextPut: $( ].	cnt := 0.	self		submorphsDoIfSyntax: [ :sub |			cnt := cnt + 1.			"maybe we want to test sub isCascadePart for the following???"			cnt > 2 ifTrue: [strm nextPutAll: '; '].			sub printOn: strm indent: level.			strm ensureASpace.		]		ifString: [ :sub |			self printSimpleStringMorph: sub on: strm		].	parens ifTrue: [strm ensureNoSpace; nextPut: $) ].! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/23/2001 01:17'!printMessageNodeOn: strm indent: level	| parens me above |	parens := parseNode receiver notNil.	parens ifTrue: [me := self selector precedence.		above := self ownerPrecedence.	"high if not in an expression"		parens := me > above].	parens ifTrue: [strm nextPut: $( ].	self		submorphsDoIfSyntax: [ :sub |			sub printOn: strm indent: level.			strm ensureASpace.		]		ifString: [ :sub |			self printSimpleStringMorph: sub on: strm		].	parens ifTrue: [strm ensureNoSpace; nextPut: $) ].! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/14/2001 13:52'!printOn: strm indent: level	| nodeClass |	(self hasProperty: #ignoreNodeWhenPrinting) ifFalse: [		nodeClass := parseNode class.		nodeClass == VariableNode ifTrue: [^self printVariableNodeOn: strm indent: level].		nodeClass == LiteralVariableNode ifTrue: [^self printVariableNodeOn: strm indent: level].		nodeClass == MessageNode ifTrue: [^self printMessageNodeOn: strm indent: level].		nodeClass == BlockNode ifTrue: [^self printBlockNodeOn: strm indent: level].		nodeClass == BlockArgsNode ifTrue: [^self printBlockArgsNodeOn: strm indent: level].		nodeClass == MethodNode ifTrue: [^self printMethodNodeOn: strm indent: level].		nodeClass == MethodTempsNode ifTrue: [^self printMethodTempsNodeOn: strm indent: level].		nodeClass == CascadeNode ifTrue: [^self printCascadeNodeOn: strm indent: level].		nodeClass == AssignmentNode ifTrue: [^self printAssignmentNodeOn: strm indent: level].	].	self		submorphsDoIfSyntax: [ :sub |			sub printOn: strm indent: level.			strm ensureASpace.		]		ifString: [ :sub |			self printSimpleStringMorph: sub on: strm		].! !!SyntaxMorph methodsFor: 'printing' stamp: 'RAA 2/16/2001 18:16'!printSimpleStringMorph: aMorph on: strm	| trialContents |	(aMorph hasProperty: #wordyVariantOfSelf) ifTrue: [		strm nextPutAll: 'self '.		strm nextPutAll: ((self translateToWordySelfVariant: aMorph contents) ifNil: [^self]).		^self	].	(aMorph hasProperty: #noiseWord) ifFalse: [		trialContents := self cleanUpString: aMorph.		strm nextPutAll: trialContents	].! !!SyntaxMorph methodsFor: 'scripting' stamp: 'tk 9/26/2001 06:01'!tearOffTile	"For a SyntaxMorph, this means give a copy of me"	| dup |	dup := self duplicate.	ActiveHand attachMorph: dup.	Preferences tileTranslucentDrag		ifTrue: [^ dup lookTranslucent]		ifFalse: [^ dup align: dup topLeft with: ActiveHand position + self cursorBaseOffset]! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 11/17/2000 08:10'!currentSelectionDo: blockForSelection	| rootTile |	(rootTile := self rootTile) isMethodNode ifFalse:		 [^ blockForSelection value: nil value: nil value: nil].	rootTile valueOfProperty: #selectionSpec ifPresentDo:		[:selectionSpec | ^ blockForSelection							value: selectionSpec first							value: selectionSpec second							value: selectionSpec third].	^ blockForSelection value: nil value: nil value: nil! !!SyntaxMorph methodsFor: 'selection' stamp: 'tk 1/17/2001 15:07'!isSelectable	| ss |	"Spacer morphs enclose other morphs with the same parseNode"	self submorphs size > 1 ifTrue: [		ss := self submorphs second.		ss isSyntaxMorph ifTrue: [			ss parseNode == parseNode ifTrue: [				^ self submorphs first class ~~ Morph]]].		"	(self nodeClassIs: SelectorNode) ifTrue: [^ false].	(self nodeClassIs: KeyWordNode) ifTrue: [^ false]."	self isMethodNode ifTrue: [^ false].	parseNode ifNil: [^ false].	^ true! !!SyntaxMorph methodsFor: 'selection' stamp: 'tk 7/31/2001 17:18'!scaleColorByUserPref: aColor		| myRoot underLyingColor |	myRoot := self rootTile.	underLyingColor := myRoot ifNil: [Color transparent] ifNotNil: [myRoot color].	[underLyingColor isTransparent and: [(myRoot := myRoot owner) notNil]] whileTrue: [		underLyingColor := myRoot color.	].		"rude hack to get the desired effect before we have an owner"	underLyingColor isTransparent ifTrue: [underLyingColor := Color r: 0.903 g: 1.0 b: 0.903].	^aColor mixed: (ContrastFactor ifNil: [0.3]) with: underLyingColor"Would like to be able to make MethodNode and outer Block be transparent.  This method does not allow that.  Consider (^ myRoot color) inside the whileTrue.  Consider setting underLyingColor to (myRoot valueOfProperty: #deselectedBorderColor ifAbsent: [myRoot color]) in second line."! !!SyntaxMorph methodsFor: 'selection' stamp: 'tk 7/19/2001 17:52'!setDeselectedColor	"The normal color of the tile, stored with the tile"	| deselectedColor deselectedBorderColor |	deselectedColor := self valueOfProperty: #deselectedColor ifAbsent: [nil].	deselectedBorderColor := self valueOfProperty: #deselectedBorderColor ifAbsent: [nil].	deselectedColor ifNotNil: [		deselectedColor := self scaleColorByUserPref: deselectedColor].	deselectedBorderColor ifNotNil: [		deselectedBorderColor := self scaleColorByUserPref: deselectedBorderColor].	self 		color: (deselectedColor ifNil: [Color transparent]);		borderColor: (deselectedBorderColor ifNil: [Color transparent])! !!SyntaxMorph methodsFor: 'submorphs-accessing' stamp: 'tk 1/13/2001 20:41'!findA: aClass	| ans |	"Allow finding on the class of the parseNode"	(ans := super findA: aClass) ifNotNil: [^ ans].	submorphs do: [:ss | 		ss isSyntaxMorph ifTrue: [			ss parseNode class == aClass ifTrue: [^ ss]]].	^ nil! !!SyntaxMorph methodsFor: 'type checking' stamp: 'sw 2/23/2001 23:40'!argTypeFor: aSelector	"Answer the type of the argument of this selector.  Return #unknown if not found."	| itsInterface |	aSelector numArgs = 0 		ifTrue: [self inform: aSelector, ' does not take an argument'. ^ #error "7"].	itsInterface := self currentVocabulary methodInterfaceAt: aSelector ifAbsent:		[^ #unknown].	^ itsInterface typeForArgumentNumber: 1! !!SyntaxMorph methodsFor: 'type checking' stamp: 'sw 2/15/2001 14:25'!okToBeReplacedBy: aSyntaxMorph	"Return true if it is OK to replace me with aSyntaxMorph.  Enforce the type rules in the old EToy green tiles."	| itsType myType |	(Preferences eToyFriendly or: [Preferences typeCheckingInTileScripting])		ifFalse: [^ true].	"not checking unless one of those prefs is true"	(parseNode class == BlockNode and: [aSyntaxMorph parseNode class == BlockNode]) 		ifTrue: [^ true].	(parseNode class == ReturnNode and: [aSyntaxMorph parseNode class == ReturnNode]) 		ifTrue: [^ true].	parseNode class == KeyWordNode ifTrue: [^ false].	aSyntaxMorph parseNode class == KeyWordNode ifTrue: [^ false].	parseNode class == SelectorNode ifTrue: [^ false].	aSyntaxMorph parseNode class == SelectorNode ifTrue: [^ false].	owner isSyntaxMorph ifFalse: [^ true].	"only within a script"		"Transcript show: aSyntaxMorph resultType printString, ' dropped on ', 			self receiverOrArgType printString; cr.		"	(itsType := aSyntaxMorph resultType) == #unknown ifTrue: [^ true].	(myType := self receiverOrArgType) == #unknown ifTrue: [^ true].		"my type in enclosing message"	^ myType = itsType! !!SyntaxMorph methodsFor: 'type checking' stamp: 'tk 2/9/2001 15:56'!receiverOrArgType	| ty |	"Return my type in my role as a receiver or as an argument.  Ask my enclosing message first, then ask myself.  (If owner accepts any #object, and I am a #point, do return #object.)"	^ (ty := self receiverOrArgTypeAbove) == #unknown		ifTrue: [self resultType]		ifFalse: [ty]! !!SyntaxMorph methodsFor: 'type checking' stamp: 'sw 2/27/2001 09:11'!receiverTypeFor: aSelector	"Answer the type of the receiver of this selector.  Return #unknown if not found."	| itsInterface |	aSelector ifNil: [^ #unknown].	itsInterface := self currentVocabulary methodInterfaceAt: aSelector ifAbsent:		[^ #unknown].	^ itsInterface receiverType! !!SyntaxMorph methodsFor: 'type checking' stamp: 'sw 2/24/2001 12:13'!resultTypeFor: aSelector	"Answer the result type of selector.  Return #unknown if not found."	| itsInterface |	aSelector ifNil: [self inform: 'Please tell Ted how you caused this'.		^ #abs "a bogus type"].	itsInterface := self currentVocabulary methodInterfaceAt: aSelector ifAbsent:		[^ #unknown].	^ itsInterface resultType! !!SyntaxMorph methodsFor: 'updating' stamp: 'di 11/13/2000 20:30'!update: aSymbol	| bingo saveOwner newMorph db |	(db := self debugger) ifNil: [^super update: aSymbol].	aSymbol == #contents ifTrue: [		saveOwner := owner.		db removeDependent: self.		markerMorph ifNotNil: [markerMorph delete. markerMorph := nil].		newMorph := db createSyntaxMorph.		self delete.		saveOwner addMorph: newMorph.		saveOwner owner setScrollDeltas.		newMorph update: #contentsSelection.	].	aSymbol == #contentsSelection ifTrue: [		markerMorph ifNil: [			markerMorph := RectangleMorph new.			markerMorph				color: Color transparent;				borderWidth: 2;				borderColor: Color red;				lock.			owner addMorphFront: markerMorph.		].		bingo := parseNode rawSourceRanges keyAtValue: db pcRange ifAbsent: [nil].		self testForNode: bingo andDo: [ :foundMorph | 			markerMorph				position: foundMorph position;				extent: foundMorph extent.			owner owner scrollIntoView: foundMorph bounds extra: 0.5.			^self		].	].	super update: aSymbol! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 2/26/2001 22:59'!column: aColor on: aParseNode	| c color |	color := self translateColor: aColor.	(c := self newColumn)		parseNode: aParseNode;		layoutInset: c standardInset;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: color;		borderWidth: 1;		borderColor: c stdBorderColor;		wrapCentering: #topLeft;		cellPositioning: c standardCellPositioning.	^c! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 2/26/2001 23:00'!row: aColor on: aParseNode	| r color |	color := self translateColor: aColor.	(r := self newRow)		parseNode: aParseNode;		layoutInset: r standardInset;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: color;		borderWidth: 1;		borderColor: r stdBorderColor;		wrapCentering: #topLeft;		cellPositioning: r standardCellPositioning.	^r! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'di 5/2/2001 09:59'!setSize: oldExtent andMakeResizable: outerMorph	| tw |	(tw := outerMorph findA: TwoWayScrollPane) ifNil: [^self].	tw hResizing: #spaceFill;		vResizing: #spaceFill;		color: Color transparent;		setProperty: #hideUnneededScrollbars toValue: true.	outerMorph 		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		cellPositioning: #topLeft.	outerMorph fullBounds.! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'dvf 8/23/2003 12:20'!testAll	| source tree total count systNav|"SyntaxMorph testAll"	systNav := self systemNavigation.	count := total := 0.	systNav allBehaviorsDo: [ :aClass | total := total + 1].'Testing all behaviors'	displayProgressAt: Sensor cursorPoint	from: 0 to: total	during: [ :bar |		systNav allBehaviorsDo: [ :aClass |			bar value: (count := count + 1).			aClass selectors do: [ :aSelector |				source := (aClass compiledMethodAt: aSelector) getSourceFromFile.				tree := Compiler new 					parse: source 					in: aClass 					notifying: nil.				tree asMorphicSyntaxUsing: SyntaxMorph.			].		].	].! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'dvf 8/23/2003 12:20'!testAllMethodsOver: methodSize 	"MessageTally spyOn: [SyntaxMorph testAllMethodsOver: 600]"	"Add up the total layout area for syntax morphs representing all  	methods over the given size. This is a stress-test for SyntaxMorph  	layout. A small value for the total area is also a figure of merit in the  	presentation of Squeak source code in general."	"Results:  	#(69 600 180820874 103700) 11/4  	70% build morphs, 12% get source, 9% layout, 8% parse, 1% roundoff  	Folded wide receivers, don't center keywords any more.  	#(68 600 160033784 127727) 11/9  	76% build morphs, 8% get source, 8% layout, 8% parse, 0% roundoff  	Folded more messages, dropped extra vertical spacing in blocks.  	#(68 600 109141704 137308) 11/10  	79% build morphs, 6% get source, 8% layout, 7% parse  	Folded more messages, dropped extra horizontal spacing.  	#(68 600 106912968 132171) 11/10  	80% build morphs, ??% get source, 11% layout, 7% parse  	Unfolded keyword messages that will fit on one line.  	#(68 600 96497372 132153) 11/10  	81% build morphs, ??% get source, 8% layout, 8% parse  	After alignment rewrite...  	#(74 600 101082316 244799) 11/12  	76% build morphs, 4% get source, 15% layout, 5% parse  	After alignment rewrite...  	#(74 600 101250620 204972) 11/15  	74% build morphs, 6% get source, 13% layout, 7% parse  	"	| tree source biggies morph stats time area |	biggies := self systemNavigation 				allMethodsSelect: [:cm | cm size > methodSize].	stats := OrderedCollection new.	'Laying out all ' , biggies size printString , ' methods over ' , methodSize printString , ' bytes...'		displayProgressAt: Sensor cursorPoint		from: 1		to: biggies size		during: [:bar | biggies				withIndexDo: [:methodRef :i | 					bar value: i.					Utilities						setClassAndSelectorFrom: methodRef						in: [:aClass :aSelector | 							source := (aClass compiledMethodAt: aSelector) getSourceFromFile.							time := Time										millisecondsToRun: [tree := Compiler new														parse: source														in: aClass														notifying: nil.											morph := tree asMorphicSyntaxUsing: SyntaxMorph.											area := morph fullBounds area]].					stats add: {methodRef. area. time}]].	^ {{biggies size. methodSize. stats		detectSum: [:a | a second]. stats		detectSum: [:a | a third]}. (stats		asSortedCollection: [:x :y | x third >= y third]) asArray}! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'di 7/30/2001 16:29'!testClass: aClass andMethod: aSelector	| tree |	tree := Compiler new 		parse: (aClass sourceCodeAt: aSelector) 		in: aClass 		notifying: nil.	(tree asMorphicSyntaxUsing: SyntaxMorph)		parsedInClass: aClass;		openInWindow! !!SyntaxUpdatingStringMorph methodsFor: 'drawing' stamp: 'tk 1/31/2002 09:53'!drawOn: aCanvas	| tempForm strm where chars wid spaceWidth putLigature topOfLigature sizeOfLigature colorOfLigature dots charZero canvas f |	tempForm := Form extent: self extent depth: aCanvas depth.	canvas := tempForm getCanvas.	f := self fontToUse.	spaceWidth := f widthOf: Character space.	strm := ReadStream on: contents.	charZero := Character value: 0.	"a marker for center dot ·"	where := 0@0.	topOfLigature := self height // 2 - 1.	sizeOfLigature := (spaceWidth-2)@(spaceWidth-2).	colorOfLigature := Color black alpha: 0.45	"veryLightGray".	dots := OrderedCollection new.	putLigature := [		dots add: ((where x + 1) @ topOfLigature extent: sizeOfLigature).		where := where + (spaceWidth@0)].	strm peek = charZero ifTrue: [		strm next.		putLigature value].	[strm peek = charZero] whileTrue: [strm next].	[strm atEnd] whileFalse: [		chars := strm upTo: charZero.		wid := f widthOfString: chars.		canvas drawString: chars at: where.		where := where + (wid@0).		strm atEnd ifFalse: [putLigature value.			[strm peek = charZero] whileTrue: [strm next]].	].	aCanvas paintImage: tempForm at: self topLeft.	dots do: [ :each |		aCanvas 			fillRectangle: (each translateBy: self topLeft) 			fillStyle: colorOfLigature.	].! !!SystemChangeNotifierTest methodsFor: 'Private' stamp: 'rw 10/19/2006 17:23'!systemChangeNotifier	"The notifier to use. Do not use the one in the system so that the fake events triggered in the tests perturb clients of the system's change notifier (e.g. the changes file then shows fake entries)."	^notifier! !!SystemChangeNotifierTest methodsFor: 'Running' stamp: 'rw 10/19/2006 17:21'!setUp	super setUp.	notifier := SystemChangeNotifier createInstance.! !!SystemChangeNotifierTest methodsFor: 'Running' stamp: 'rw 10/19/2006 17:23'!tearDown	super tearDown.	self capturedEvent: nil.	notifier releaseAll.	notifier := nil! !!SystemChangeNotifierTest methodsFor: 'Testing-system triggers' stamp: 'rw 10/19/2006 17:24'!testClassRenamedEvent	"self run: #testClassRenamedEvent"	self systemChangeNotifier notify: self ofAllSystemChangesUsing: #event:.	self systemChangeNotifier 		classRenamed: self class		from: #OldFooClass		to: #NewFooClass		inCategory: #FooCat.	self		checkEventForClass: self class		category: #FooCat		change: #Renamed."	self assert: capturedEvent oldName = #OldFooClass.	self assert: capturedEvent newName = #NewFooClass"! !!SystemChangeNotifierTest commentStamp: 'rw 4/3/2006 17:19' prior: 0!A SystemChangeNotifierTest is a test class that tests whether the triggering of changes indeed results in the intended changes to be sent to registered object. The basic mechanism for each test is fairly simple:	- register the receiver as the one to get the change notifier.	- manually trigger a change (so the system is not polluted just to see whether we get the needed event).	- the method #event: is invoked and remembers the change event.	- the change event is checked to see whether it was the intended one.Instance Variables	capturedEvent:		Remembers the captured event!!SystemDictionary methodsFor: 'class and trait names' stamp: 'rw 10/7/2006 08:34'!renameClass: aClass as: newName 	"Rename the class, aClass, to have the title newName."	"Original one I want to keep but needs to be fixed"		| oldref i oldName category |	oldName := aClass name.	category := aClass category.	SystemOrganization classify: newName under: aClass category.	SystemOrganization removeElement: aClass name.	oldref _ self associationAt: aClass name.	self removeKey: aClass name.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i _ list indexOf: aClass name ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemDictionary methodsFor: 'class names' stamp: 'rw 10/17/2006 23:07'!renameClass: aClass from: oldName 	"Rename the class, aClass, to have the title newName."	| oldref i newName category |	newName := aClass name.	category := SystemOrganization categoryOfElement: oldName.	SystemOrganization classify: newName under: category.	SystemOrganization removeElement: oldName.	oldref := self associationAt: oldName.	self removeKey: oldName.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i := list indexOf: oldName ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemDictionary class methodsFor: 'initialization' stamp: 'ar 10/5/2007 18:16'!initialize	"SystemDictionary initialize"	| oldList |	oldList _ StartUpList.	StartUpList _ OrderedCollection new.	"These get processed from the top down..."	#(		Delay		DisplayScreen		Cursor		InputSensor		ProcessorScheduler  "Starts low space watcher and bkground."		FileDirectory  "Enables file stack dump and opens sources."		ShortIntegerArray		ShortRunArray		CrLfFileStream	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].	oldList ifNotNil: [oldList do: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToStartUpList: theClass]]].	#(		ImageSegment		PasteUpMorph		ControlManager	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].			oldList _ ShutDownList.	ShutDownList _ OrderedCollection new.	"These get processed from the bottom up..."	#(		Delay		DisplayScreen		InputSensor		Form		ControlManager		PasteUpMorph		StrikeFont		Color		FileDirectory		SoundPlayer		HttpUrl		Password		PWS		MailDB		ImageSegment	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToShutDownList: cls].	].	oldList ifNotNil: [oldList reverseDo: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToShutDownList: theClass]]].! !!SystemQueryPhrase methodsFor: 'initialization' stamp: 'sw 9/26/2001 03:04'!initialize	"Initialize the receiver.  In this case we primarily seek to undo the damage done by inherited implementors of #initialize"	super initialize.	self removeAllMorphs.	resultType := #Boolean.	self vResizing: #shrinkWrap! !!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57'!initialize	"Initialize a system window. Add label, stripes, etc., if desired"	super initialize.	allowReframeHandles _ true.	labelString ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	borderColor _ Color lightGray.	borderWidth _ 1.	self color: Color lightGray lighter lighter lighter.	self layoutPolicy: ProportionalLayout new.		self initializeLabelArea.					self addCornerGrips.	self extent: 300 @ 200.	mustNotClose _ false.	updatablePanes _ Array new.			Preferences menuAppearance3d		ifTrue: [			self				addDropShadow;				shadowColor: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.333);				shadowOffset: 1@1.		].					! !!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57'!initializeLabelArea	"Initialize the label area (titlebar) for the window."	label _ StringMorph new contents: labelString;						 font: Preferences windowTitleFont emphasis: 0.			"Add collapse box so #labelHeight will work"			collapseBox _ self createCollapseBox.			stripes _ Array						with: (RectangleMorph newBounds: bounds)						with: (RectangleMorph newBounds: bounds).			"see extent:"			self addLabelArea.			self setLabelWidgetAllowance.			self addCloseBox.			self addMenuControl.			labelArea addMorphBack: (Morph new extent: self class borderWidth @ 0).			labelArea addMorphBack: label.			self wantsExpandBox				ifTrue: [self addExpandBox].			labelArea addMorphBack: collapseBox.			self setFramesForLabelArea.			Preferences clickOnLabelToEdit				ifTrue: [label						on: #mouseDown						send: #relabel						to: self].			Preferences noviceMode				ifTrue: [closeBox						ifNotNil: [closeBox setBalloonText: 'close window'].					menuBox						ifNotNil: [menuBox setBalloonText: 'window menu'].					collapseBox						ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].! !!TGettableStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/28/2007 16:10'!testAtEnd	| stream |	self assert: self emptyStream atEnd.	stream := self streamOnArray.	self deny: stream atEnd.	stream next: 3.	self assert: stream atEnd.! !!TGettableStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/28/2007 16:30'!testNextMatchFor	| stream |	stream := self streamOnArray.	self assert: (stream nextMatchFor: 1).	self assert: (stream nextMatchFor: #(a b c)).	self assert: (stream nextMatchFor: false).		stream := self streamOnArray.	self deny: (stream nextMatchFor: false).	self assert: (stream nextMatchFor: #(a b c)).	self assert: (stream nextMatchFor: false).! !!TGettableStreamTest methodsFor: 'tests - testing' stamp: 'dc 3/1/2007 14:48'!testPeekFor	| stream |	stream := self streamOnArray.	self assert: (stream peekFor: 1).	self assert: (stream peekFor: #(a b c)).	self assert: (stream peekFor: false).	stream := self streamOnArray.	self deny: (stream peekFor: #(a b c)).	self deny: (stream peekFor: false).	self assert: (stream peekFor: 1).	self deny: (stream peekFor: 1).	self deny: (stream peekFor: false).	self assert: (stream peekFor: #(a b c)).		self deny: (stream peekFor: 1).	self deny: (stream peekFor: #(a b c)).	self assert: (stream peekFor: false).		self assert: (stream atEnd).	self deny: (stream peekFor: nil).	self deny: (stream peekFor: 1).	self deny: (stream peekFor: #(a b c)).	self deny: (stream peekFor: false).! !!TGettableStreamTest methodsFor: 'tests - testing' stamp: 'dc 3/1/2007 14:54'!testPeekFor2	| stream negative number |	stream := self streamOn: '- 145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self assert: negative.	self assert: number = '145'.	stream := self streamOn: '-145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self assert: negative.	self assert: number = '145'.		stream := self streamOn: ' 145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self deny: negative.	self assert: number = '145'.		stream := self streamOn: '145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self deny: negative.	self assert: number = '145'.! !!TGettableStreamTest methodsFor: 'tests - enumerating' stamp: 'dc 2/28/2007 16:20'!testDo	self emptyStream do: [:value | self fail]! !!TGettableStreamTest methodsFor: 'tests - enumerating' stamp: 'dc 2/28/2007 16:20'!testDo2	| stream string |	stream := self streamOnArray.	string := String new.		stream do: [:value | string := string, ' ', value asString].		self assert: string = (' ', 1 asString, ' ', #(a b c) asString, ' ', false asString)! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:23'!testNext	|stream|	stream := self streamOnArray.	self assert: stream next = 1.	self assert: stream next = #(a b c).	self assert: stream next = false.		stream := self streamOnString.	self assert: stream next = $a.	self assert: stream next = $b.	self assert: stream next = $c.	self assert: stream next = $d.	self assert: stream next = $e.	! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:24'!testNexts	self assert: (self emptyStream next: 0) isEmpty.	self assert: (self streamOnArray next: 0) isEmpty.	self assert: (self streamOnArray next: 1) = #(1).	self assert: (self streamOnArray next: 2) = #(1 #(a b c)).	self assert: (self streamOnArray next: 3) = #(1 #(a b c) false).! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 15:40'!testNexts2	| stream |	stream := self streamOnArray.	self assert: (stream next: 2) = #(1 #(a b c)).	self assert: (stream next: 1) = #(false).! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:35'!testPeek	| stream |	stream := self streamOnArray.		self assert: stream peek = 1.	self deny: stream peek = #(a b c).	self deny: stream peek = false.		stream next.		self deny: stream peek = 1.	self assert: stream peek = #(a b c).	self deny: stream peek = false.		stream next.		self deny: stream peek = 1.	self deny: stream peek = #(a b c).	self assert: stream peek = false.		stream next.		"In ANSI Smalltalk Standard Draft, it is said that nil will return nil at the end when using #peek."	self assert: stream peek isNil.! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:37'!testPeek2	| stream |	stream := self streamOn: #(nil nil nil).		self assert: stream peek isNil.	stream next.	self assert: stream peek isNil.	stream next.	self assert: stream peek isNil.	stream next.		"Yes, #peek answers nil when there is no more element to read."	self assert: stream peek isNil.! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/1/2007 12:41'!testUpTo	| returnValue stream |	returnValue := (self emptyStream upTo: nil).	self assert: returnValue isCollection.	self assert: returnValue isEmpty.		stream := self streamOnArray.	returnValue := stream upTo: #(a b c).	self assert: returnValue = #(1).	self assert: stream peek = false.		stream := self streamOnArray.	returnValue := stream upTo: true.	self assert: returnValue = #(1 #(a b c) false).	self assert: stream atEnd.! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/1/2007 12:42'!testUpTo2	| returnValue stream |	stream := self streamOnString.	returnValue := stream upTo: $d.	self assert: returnValue = 'abc'.	self assert: stream peek = $e.! !!TGettableStreamTest methodsFor: 'tests - positionning' stamp: 'dc 3/1/2007 15:17'!testSkipTo	| stream |	stream := self emptyStream.	self deny: (stream skipTo: nil).		stream := self streamOnArray.	self deny: stream atEnd.	self deny: (stream skipTo: nil).	self assert: stream atEnd.		stream := self streamOnArray.	self assert: stream peek = 1.	self assert: (stream skipTo: #(a b c)).	self assert: stream peek = false.	self assert: (stream skipTo: false).	self assert: stream atEnd.! !!TGettableStreamTest methodsFor: 'tests - positionning' stamp: 'dc 3/1/2007 15:18'!testSkipTo2	| stream |		stream := self streamOnString.	self assert: (stream skipTo: $b).	self assert: stream peek = $c.	self assert: (stream skipTo: $d).	self assert: stream peek = $e.	self assert: (stream skipTo: $e).	self assert: stream atEnd.! !!TGettableStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:19'!testBack	"Test the new implemtation of the method back."	|stream|	stream := self streamOn: 'abc'.	stream next: 2.	self assert: stream back = $b.! !!TGettableStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:22'!testBackOnPosition1	"Test the new implemtation of the method back."	|stream|	stream := self streamOn: 'abc'.	stream next.	self assert: stream back = $a.! !!TGettableStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:20'!testOldBack	"Test the old behavior of the method back. The method #oldBack is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. The method #oldBack considers that the pointer is *on* an element. (Damien Cassou - 1 August 2007)"	|stream|	stream := self streamOn: 'abc'.	stream next: 2.	self assert: stream oldBack = $a.! !!TGettableStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:22'!testOldBackOnPosition1	"Test the old behavior of the method back. The method #oldBack is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. The method #oldBack considers that the pointer is *on* an element. (Damien Cassou - 1 August 2007)"	|stream|	stream := self streamOn: 'abc'.	stream next.	self assert: stream oldBack = nil.! !!TPuttableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/9/2007 10:49'!testNextPutAllAppending	| stream |	stream := self emptyStream.	self shouldnt: [		stream			nextPutAll: 'abc'.	] raise: Error.! !!TPuttableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/9/2007 10:50'!testNextPutAllReplacing	| stream |	stream := self streamOnString.	stream reset.	self shouldnt: [		stream			nextPutAll: 'abc'.	] raise: Error.! !!TPuttableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/9/2007 10:49'!testNextPutAppending	| stream |	stream := self emptyStream.	self shouldnt: [		stream			nextPut: $a;			nextPut: $b;			nextPut: $c.	] raise: Error.! !!TPuttableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/9/2007 10:50'!testNextPutReplacing	| stream |	stream := self streamOnArray.	stream reset.	self shouldnt: [		stream			nextPut: $a;			nextPut: $b;			nextPut: $c.	] raise: Error.! !!TReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/6/2007 18:26'!testContents2	"From ANSI Smalltalk Standard draft 1.9: 			it is unspecified whether or not the returned collection [using #contents] is the same object as the backing store collection. However, if the returned collection is not the same object as the stream backing store collection then the class of the returned collection is the same class as would be returned if the message #select: was sent to the backing store collection."			"In Squeak, there is #species to know what class should be used on copy, selection..."	| interval stream streamContents |	interval := 1 to: 32.	stream := self streamOn: interval.	streamContents := stream contents.		(streamContents == interval)		ifFalse: [self assert: streamContents class = Interval new species]! !!TReadStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 3/7/2007 13:50'!testNew	self should: [self classUnderTest new] raise: Error.! !!TReadStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/28/2007 15:39'!testOn	self shouldnt: [self streamOn: '  '] raise: Error.	self assert: (self streamOn: '  ') position isZero.! !!TReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/28/2007 15:38'!testPosition	| stream |	self assert: self emptyStream position isZero.		stream := self streamOnArray.	self assert: stream position = 0.	stream next.	self assert: stream position = 1.	stream next.	self assert: stream position = 2.	stream next.	self assert: stream position = 3.	stream next.	self assert: stream position = 3.	stream next.	self assert: stream position = 3.! !!TSequencedStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 15:32'!testContents	| stream |	self assert: self emptyStream contents = ''.		stream := self streamOnArray.	self assert: stream contents = #(1 #(a b c) false).	stream position: 3.	self assert: stream contents = #(1 #(a b c) false).		stream := self streamOnString.	self assert: stream contents = 'abcde'.	stream setToEnd.	self assert: stream contents = 'abcde'.! !!TSequencedStreamTest methodsFor: 'tests - positioning' stamp: 'dc 8/2/2007 12:07'!testBackUpTo1	|stream|	stream := ReadStream on: 'abcdabg'.	stream setToEnd.	self assert: (stream backUpTo: 'ab').	self assert: stream peek = $g! !!TSequencedStreamTest methodsFor: 'tests - positioning' stamp: 'dc 8/2/2007 12:11'!testBackUpToEmptyPattern1	"This test represents the current behavior which is not clearly defined and could be revised."	|stream|	stream := ReadStream on: 'abcdabg'.	stream setToEnd.	self should: [stream backUpTo: ''] raise: Error.! !!TSequencedStreamTest methodsFor: 'tests - positioning' stamp: 'dc 8/2/2007 12:08'!testBackUpToPatternNotFound1	|stream|	stream := ReadStream on: 'abcdabg'.	stream setToEnd.	self deny: (stream backUpTo: 'zz').	self assert: stream position = 0! !!TSequencedStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/28/2007 15:44'!testReset	| stream |	stream := self emptyStream.	stream reset.	self assert: stream position = 0.		stream := self streamOnArray.	stream reset.	self assert: stream position = 0.	self deny: stream atEnd.	stream position: 3.	self assert: stream atEnd.	stream reset.	self assert: stream position = 0.! !!TSequencedStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/27/2007 17:41'!testSetPosition	| stream |	stream := self emptyStream.	self should: [stream position: -2] raise: Error.	self shouldnt: [stream position: 0] raise: Error.	stream := self streamOnArray.	self should: [stream position: -1] raise: Error.	self shouldnt: [stream position: 0] raise: Error.	self shouldnt: [stream position: 1] raise: Error.	self shouldnt: [stream position: 2] raise: Error.	"According to ANSI Smalltalk Standard 1.9 Draft, the following should be tested too:	self should: [stream position: 3] raise: Error.		However, I don't see the point of raising an error when positioning at the end.		I prefer testing the absence of error:	"	self shouldnt: [stream position: 3] raise: Error.	self should: [stream position: 4] raise: Error.! !!TSequencedStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/27/2007 17:47'!testSetToEnd	| stream |	stream := self emptyStream.	stream setToEnd.	self assert: stream atEnd.		stream := self streamOnArray.	stream setToEnd.	self assert: stream atEnd.	stream position: 1.	self deny: stream atEnd.	stream setToEnd.	self assert: stream atEnd.! !!TStreamTest methodsFor: 'accessing' stamp: 'dc 3/7/2007 14:00'!classUnderTest	self explicitRequirement! !!TStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/28/2007 13:59'!emptyStream	^ self streamOn: String new! !!TStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/28/2007 13:57'!streamOnArray	^ self streamOn: (Array with: 1 with: #(a b c) with: false)! !!TStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/28/2007 13:57'!streamOnString	^ self streamOn: 'abcde'! !!TStreamTest methodsFor: 'helpers' stamp: 'dc 3/7/2007 13:55'!streamOn: aCollection	^ self classUnderTest on: aCollection! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:35'!ascent	ascent ifNil:[ascent := ttcDescription ascender * self pixelSize // (ttcDescription ascender - ttcDescription descender) * Scale y].	^ (fallbackFont notNil			and: [fallbackFont ascent > ascent])		ifTrue: [fallbackFont ascent]		ifFalse: [ascent]! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:43'!descent	"One is added to make sure the gap between lines is filled.  If we don't add, multi line selection in a text pane look ugly."	^descent ifNil:[descent := (ttcDescription descender * self pixelSize // (ttcDescription descender - ttcDescription ascender)) * Scale y + 1].! !!TTCFont methodsFor: 'accessing' stamp: 'dgd 5/19/2007 16:20'!fallbackFont: aFontSetOrNil	aFontSetOrNil == self		ifTrue:[^ self error: 'Invalid fallback font'].	fallbackFont _ aFontSetOrNil.! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:44'!height	"Answer my height in pixels. This will answer a Float."	^height ifNil:[height := self pixelSize * Scale y]! !!TTCFont methodsFor: 'accessing' stamp: 'ar 6/2/2007 21:12'!maxAscii	"Answer the max. code point in this font. The name of this method is historical."	^maxAscii ifNil:[ttcDescription size].! !!TTCFont methodsFor: 'accessing' stamp: 'ar 6/2/2007 21:12'!minAscii	"Answer the min. code point in this font. The name of this method is historical."	^ 0.! !!TTCFont methodsFor: 'as yet unclassified' stamp: 'dgd 5/19/2007 16:19'!setupDefaultFallbackFont	| fonts f |	fonts _ TextStyle default fontArray.	f _ fonts first.	1 to: fonts size do: [:i |		self height > (fonts at: i) height ifTrue: [f _ fonts at: i].	].	(f == self)		ifFalse:[ self fallbackFont: f ].	self reset.! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:19'!cache	^cache! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:40'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| form glyphInfo destX destY hereX nextX actualFont |	destX := aPoint x.	glyphInfo := Array new: 5.	startIndex to: stopIndex do: [:charIndex |		self glyphInfoOf: (aString at: charIndex) into: glyphInfo.		form := glyphInfo at: 1.		hereX := glyphInfo at: 2.		nextX := glyphInfo at: 3.		(actualFont := glyphInfo at: 5) ==  aBitBlt lastFont			ifFalse: [actualFont installOn: aBitBlt].		destY := baselineY - (glyphInfo at: 4). 		aBitBlt sourceForm: form.		aBitBlt destX: destX.		aBitBlt destY: destY.		aBitBlt sourceX: hereX; sourceY: 0.		aBitBlt width: nextX - hereX.		aBitBlt height: form height.		aBitBlt copyBits.		destX := destX + (nextX - hereX) + kernDelta.	].	^ destX @ destY! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:26'!installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor	self foregroundColor: fgColor. "install color"	aDisplayContext installTTCFont: self foregroundColor: foregroundColor backgroundColor: bgColor! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:19'!ttcDescription: aTTCDescription	ttcDescription := aTTCDescription.	self flushCache.! !!TTCFont methodsFor: 'public' stamp: 'ar 6/2/2007 21:16'!widthOf: aCharacter	"This method cannot use #formOf: because formOf: discriminates the color and causes unnecessary bitmap creation."	aCharacter charCode > self maxAscii ifTrue: [		fallbackFont ifNotNil: [^ fallbackFont widthOf: aCharacter].		^ 1	].	^(self formOf: aCharacter) width! !!TTCFont methodsFor: 'private' stamp: 'ar 11/14/2006 15:19'!at: char put: form	| assoc |	assoc := foregroundColor -> form.	GlyphCacheData at: (GlyphCacheIndex := GlyphCacheIndex \\ GlyphCacheSize + 1) put: assoc.	cache at: (char asInteger + 1) put: assoc.! !!TTCFont methodsFor: 'private' stamp: 'ar 6/2/2007 21:13'!formOf: char	| code form |	char charCode > self maxAscii		ifTrue: [^ self fallbackFont formOf: char].	cache ifNil:[self foregroundColor: Color black]. "make sure we have a cache"	code := char charCode.	form := cache at: (code + 1).	form class == Association ifTrue:[^self computeForm: code]. "in midst of loading"	form ifNil:[		form := self computeForm: code.		cache at: code+1 put: form.		GlyphCacheData at: (GlyphCacheIndex := GlyphCacheIndex \\ GlyphCacheSize + 1) put: form.	].	^form! !!TTCFont methodsFor: 'private' stamp: 'ar 11/14/2006 15:43'!glyphInfoOf: aCharacter into: glyphInfoArray	"Answer the width of the argument as a character in the receiver."	| form |	(self hasGlyphOf: aCharacter) ifFalse: [		^ self fallbackFont glyphInfoOf: aCharacter into: glyphInfoArray.	].	form := self formOf: aCharacter.	glyphInfoArray at: 1 put: form;		at: 2 put: 0;		at: 3 put: form width;		at: 4 put: ascent "(self ascentOf: aCharacter)";		at: 5 put: self.	^ glyphInfoArray.! !!TTCFont methodsFor: 'private' stamp: 'ar 6/2/2007 21:13'!hasGlyphOf: aCharacter	"Answer whether this font includes a glyph for the given character"	^ aCharacter charCode <= self maxAscii! !!TTCFont methodsFor: 'initialize' stamp: 'ar 11/14/2006 15:17'!flushCache	"Flush the cache of this font"	cache := foregroundColor := colorToCacheMap := nil.! !!TTCFont methodsFor: 'initialize' stamp: 'ar 6/2/2007 21:14'!foregroundColor: fgColor	"Install the given foreground color"	foregroundColor = fgColor ifFalse:[		foregroundColor := fgColor.		colorToCacheMap ifNil:[colorToCacheMap := Dictionary new].		cache := colorToCacheMap at: fgColor ifAbsentPut:[WeakArray new: self maxAscii+1].		ShutdownList ifNotNil:[ShutdownList add: self].	].! !!TTCFont commentStamp: 'nk 4/2/2004 11:32' prior: 0!I represent a font that uses TrueType derived glyph.  Upon a request for glyph for a character through a call to #formOf: (or #widthOf:), I first search corresponding glyph in the cache.  If there is not, it creates a 32bit depth form with the glyph.  The cache is weakly held.  The entries are zapped at full GC.Structure: ttcDescription	TTFontDescription -- The Squeak data structure for a TrueType font data file. pointSize		Number -- Nominal Em size in points. Conversion to pixel sizes depends on the definition of TextStyle class>>pixelsPerInch. foregroundColor	Color -- So far, this font need to know the glyph color in cache. cache			WeakArray of <Color -> <Array(256) of glyph>> derivatives		Array -- stores the fonts in the same family but different emphasis.!!TTCFont class methodsFor: 'class initialization' stamp: 'ar 11/14/2006 15:48'!initialize"	self initialize"	| tt |	self allSubInstancesDo:[:fnt| fnt flushCache].	GlyphCacheSize := 512.	GlyphCacheData := Array new: GlyphCacheSize.	GlyphCacheIndex := 0.	GlyphCacheReady := true.		tt := TTFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].	(FileList respondsTo: #registerFileReader:) ifTrue: [		FileList registerFileReader: self	].	Smalltalk addToShutDownList: self.! !!TTCFont class methodsFor: 'class initialization' stamp: 'ar 11/14/2006 15:28'!shutDown	"Flush the glyph cache"	GlyphCacheData atAllPut: nil.	GlyphCacheIndex := 0.	ShutdownList ifNotNil:[ShutdownList do:[:fnt| fnt flushCache]].	ShutdownList := WeakSet new.! !!TTCFont class methodsFor: 'other' stamp: 'ar 11/14/2006 15:19'!recreateCache"	self recreateCache."	self allSubInstances do: [:inst | inst flushCache].	Smalltalk garbageCollect.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 2/12/2007 19:34'!isFontSet	^ true.! !!TTFontDescription methodsFor: 'accessing' stamp: 'ar 6/2/2007 21:15'!size	"Answer the logical number of characters in this font"	^glyphTable size - 1! !!TTFontReader methodsFor: 'processing' stamp: 'bf 6/12/2006 18:00'!processCharMap: assoc	"Process the given character map"	| charTable glyph cmap |	cmap := assoc value.	assoc key = 0 ifTrue: "Unicode table"		[charTable := SparseLargeTable new: cmap size			chunkSize: 256 arrayClass: Array base: 1			defaultValue: glyphs first.		1 to: charTable size do:			[:i |			glyph := glyphs at: (cmap at: i) + 1 ifAbsent: [glyphs first].			charTable at: i put: glyph].		charTable zapDefaultOnlyEntries.		^charTable].	charTable := Array new: 256 withAll: glyphs first. "Initialize with default glyph"	assoc key = 1 ifTrue: "Mac encoded table"		[1 to: (cmap size min: charTable size) do:			[:i |			glyph := glyphs at: (cmap at: i) + 1.			charTable at: (self macToWin: i) put: glyph]].	assoc key = 3 ifTrue: "Win encoded table"		[1 to: (cmap size min: charTable size) do:			[:i |			glyph := glyphs at: (cmap at: i) + 1.			charTable at: i put: glyph]].	^ charTable! !!TTFontReader methodsFor: 'processing' stamp: 'bf 6/12/2006 16:28'!processCharacterMappingTable: entry	"Read the font's character to glyph index mapping table.	If an appropriate mapping can be found then return an association	with the format identifier and the contents of the table"	| copy initialOffset nSubTables pID sID offset cmap assoc |	initialOffset := entry offset.	entry skip: 2. "Skip table version"	nSubTables := entry nextUShort.	1 to: nSubTables do:[:i|		pID := entry nextUShort.		sID := entry nextUShort.		offset := entry nextULong.		"Check if this is either a Unicode (0), Macintosh (1),		or a Windows (3) encoded table"		(#(0 1 3) includes: pID) ifTrue:[			"Go to the beginning of the table"			copy := entry copy.			copy offset: initialOffset + offset.			cmap := self decodeCmapFmtTable: copy.			(pID = 0 and: [cmap notNil]) "Prefer Unicode encoding over everything else"				ifTrue: [^ pID -> cmap].			assoc := pID -> cmap. "Keep it in case we don't find a better table"		].	].	^assoc! !!TTFontReader methodsFor: 'private' stamp: 'bf 6/12/2006 17:14'!decodeCmapFmtTable: entry	| cmapFmt length cmap firstCode entryCount segCount segments offset code |	cmapFmt := entry nextUShort.	length := entry nextUShort.	entry skip: 2. "skip version"	cmapFmt = 0 ifTrue: "byte encoded table"		[length := length - 6. 		"should be always 256"		length <= 0 ifTrue: [^ nil].	"but sometimes, this table is empty"		cmap := Array new: length.		entry nextBytes: length into: cmap startingAt: entry offset.		^ cmap].	cmapFmt = 4 ifTrue: "segment mapping to deltavalues"		[segCount := entry nextUShort // 2.		entry skip: 6. "skip searchRange, entrySelector, rangeShift"		segments := Array new: segCount.		segments := (1 to: segCount) collect: [:e | Array new: 4].		1 to: segCount do: [:i | (segments at: i) at: 2 put: entry nextUShort]. "endCount"		entry skip: 2. "skip reservedPad"		1 to: segCount do: [:i | (segments at: i) at: 1 put: entry nextUShort]. "startCount"		1 to: segCount do: [:i | (segments at: i) at: 3 put: entry nextShort]. "idDelta"		offset := entry offset.		1 to: segCount do: [:i | (segments at: i) at: 4 put: entry nextUShort]. "idRangeOffset"		entryCount := segments inject: 0 into: [:max :seg | max max: seg second].		cmap := Array new: entryCount+1 withAll: 0..		segments withIndexDo:			[:seg :si |			seg first to: seg second do:				[:i |				seg last > 0 ifTrue:					["offset to glypthIdArray - this is really C-magic!!"					entry offset: i - seg first - 1 * 2 + seg last + si + si + offset. 					code := entry nextUShort.					code > 0 ifTrue: [code := code + seg third]]				ifFalse:					["simple offset"					code := i + seg third].				cmap at: i + 1 put: code]].		^ cmap].	cmapFmt = 6 ifTrue: "trimmed table"		[firstCode := entry nextUShort.		entryCount := entry nextUShort.		cmap := Array new: entryCount + firstCode withAll: 0.		entryCount timesRepeat:			[cmap at: (firstCode := firstCode + 1) put: entry nextUShort].		^ cmap].	^ nil! !!TabbedPalette methodsFor: '*eToys-e-toy support' stamp: 'sw 7/5/1998 15:40'!succeededInRevealing: aPlayer	| result |	result := super succeededInRevealing: aPlayer.	result ifTrue:		["BookMorph code will have called goToPageNumber:; here, we just need to get the tab selection right here"		self selectTabOfBook: self currentPalette].	^ result! !!TabbedPalette methodsFor: '*eToys-viewer tab' stamp: 'sw 3/3/1999 13:17'!viewMorph: aMorph	"The receiver is expected to have a viewer tab; select it, and target it to aMorph"	| aPlayer aViewer oldOwner |	((currentPage isKindOf: Viewer) and: [currentPage scriptedPlayer == aMorph player])		ifTrue:			[^ self].	oldOwner := owner.	self delete.	self visible: false.	aPlayer := aMorph assuredPlayer.	self showNoPalette.	aViewer :=  StandardViewer new initializeFor: aPlayer barHeight: 0.	aViewer enforceTileColorPolicy.	self showNoPalette.	currentPage ifNotNil: [currentPage delete].	self addMorphBack: (currentPage := aViewer beSticky).	self snapToEdgeIfAppropriate.	tabsMorph highlightTab: nil.	self visible: true.	oldOwner addMorphFront: self.	self world startSteppingSubmorphsOf: aViewer.	self layoutChanged! !!TestIndenting methodsFor: 'running' stamp: 'hmm 2/2/2001 14:29'!setUp	| text |	text := 'p	' asText, (Text string: 'word word' attribute: (TextIndent tabs: 1)).	para := text asParagraph! !!TestNewParagraphFix methodsFor: 'running' stamp: 'hmm 10/1/2000 17:41'!setUp	| morph |	morph := TextMorph new contents: 'i i'.	morph fit.	para := morph paragraph! !!TestParagraphFix methodsFor: 'running' stamp: 'hmm 10/1/2000 15:05'!setUp	para := 'i i' asParagraph! !!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 8/17/2007 13:38'!testValueWithinNonLocalReturnFixReal	"self run: #testValueWithinNonLocalReturnFixReal"	"The real test for the fix is just as obscure as the original problem"	| startTime deltaTime |	self valueWithinNonLocalReturn.	startTime := Time millisecondClockValue.	[[] repeat] valueWithin: 100 milliSeconds onTimeout:[		"This *should* timeout after 100 msecs but the pending process from		the previous invokation will signal timeout after 20 msecs already		which will in turn cut this invokation short."		deltaTime := Time millisecondClockValue - startTime.		self deny: deltaTime < 90.	].! !!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 8/17/2007 13:38'!testValueWithinNonLocalReturnFixSimply	"self run: #testValueWithinNonLocalReturnFixSimply"	"The simple version to test the fix"	self valueWithinNonLocalReturn.	self shouldnt:[(Delay forMilliseconds: 50) wait] raise: TimedOut.! !!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 8/17/2007 13:37'!valueWithinNonLocalReturn	"Do a non-local return from a valueWithin: block"	[^self] valueWithin: 20 milliSeconds onTimeout:[].! !!Text methodsFor: 'accessing' stamp: 'tk 12/30/97 07:17'!replaceFrom: start to: stop with: aText	| txt |	txt := aText asText.	"might be a string"	string := string copyReplaceFrom: start to: stop with: txt string.	runs := runs copyReplaceFrom: start to: stop with: txt runs! !!Text methodsFor: 'attributes' stamp: 'rbb 2/18/2005 09:14'!askIfAddStyle: priorMethod req: requestor	"Ask the user if we have a complex style (i.e. bold) for the first time"	| tell answ old |	(Preferences browseWithPrettyPrint and: [Preferences colorWhenPrettyPrinting])		ifTrue: [self couldDeriveFromPrettyPrinting ifTrue: [^ self asString]].	self runs coalesce.	self unembellished ifTrue: [^ self asString].	priorMethod ifNotNil: [old := priorMethod getSourceFromFile].	(old == nil or: [old unembellished])		ifTrue:			[tell := 'This method contains style for the first time (e.g. bold or colored text).Do you really want to save the style info?'.			answ := (UIManager default 						chooseFrom: #('Save method with style' 'Save method simply')						title: tell).			answ = 2 ifTrue: [^ self asString]]! !!Text methodsFor: 'attributes' stamp: 'sw 12/7/1999 12:31'!unembellished 	"Return true if the only emphases are the default font and bold"	| font1 bold |	font1 := TextFontChange defaultFontChange.	bold := TextEmphasis bold.	Preferences ignoreStyleIfOnlyBold ifFalse:		["Ignore font1 only or font1-bold followed by font1-plain"		^ (runs values = (Array with: (Array with: font1)))		or: [runs values = (Array with: (Array with: font1 with: bold) 								with: (Array with: font1))]].	"If preference is set, then ignore any combo of font1 and bold"	runs withStartStopAndValueDo:		[:start :stop :emphArray |		emphArray do:			[:emph | (font1 = emph or: [bold = emph]) ifFalse: [^ false]]].	^ true! !!Text methodsFor: 'converting' stamp: 'ar 12/17/2001 00:38'!removeAttributesThat: removalBlock replaceAttributesThat: replaceBlock by: convertBlock	"Enumerate all attributes in the receiver. Remove those passing removalBlock and replace those passing replaceBlock after converting it through convertBlock"	| added removed new |	"Deliberately optimized for the no-op default."	added := removed := nil.	runs withStartStopAndValueDo: [ :start :stop :attribs | 		attribs do: [ :attrib |			(removalBlock value: attrib) ifTrue:[				removed ifNil:[removed := WriteStream on: #()].				removed nextPut: {start. stop. attrib}.			] ifFalse:[				(replaceBlock value: attrib) ifTrue:[					removed ifNil:[removed := WriteStream on: #()].					removed nextPut: {start. stop. attrib}.					new := convertBlock value: attrib.					added ifNil:[added := WriteStream on: #()].					added nextPut: {start. stop. new}.				].			].		].	].	(added == nil and:[removed == nil]) ifTrue:[^self].	"otherwise do the real work"	removed ifNotNil:[removed contents do:[:spec|		self removeAttribute: spec last from: spec first to: spec second]].	added ifNotNil:[added contents do:[:spec|		self addAttribute: spec last from: spec first to: spec second]].! !!Text methodsFor: 'converting' stamp: 'dvf 10/1/2003 02:58'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the receiver starting at index, repStart, in replacementCollection. Do it to both the string and the runs."	| rep newRepRuns |	rep := replacement asText.	"might be a string"	string replaceFrom: start to: stop with: rep string startingAt: repStart.	newRepRuns := rep runs copyFrom: repStart to: repStart + stop - start.	runs := runs copyReplaceFrom: start to: stop with: newRepRuns! !!Text methodsFor: 'converting' stamp: 'nk 9/16/2003 16:46'!withSqueakLineEndings	"Answer a copy of myself in which all sequences of <CR><LF> or <LF> have been changed to <CR>"	| newText |	(string includes: Character lf) ifFalse: [ ^self copy ].	newText := self copyReplaceAll: String crlf with: String cr asTokens: false.	(newText asString includes: Character lf) ifFalse: [ ^newText ].	^newText copyReplaceAll: String lf with: String cr asTokens: false.! !!Text methodsFor: 'copying'!copyFrom: start to: stop 	"Answer a copied subrange of the receiver."	| realStart realStop |	stop > self size		ifTrue: [realStop := self size]		"handle selection at end of string"		ifFalse: [realStop := stop].	start < 1		ifTrue: [realStart := 1]			"handle selection before start of string"		ifFalse: [realStart := start].	^Text 		string: (string copyFrom: realStart to: realStop)		runs: (runs copyFrom: realStart to: realStop)! !!Text methodsFor: 'copying' stamp: 'BG 6/12/2003 13:11'!copyReplaceFrom: start to: stop with: aTextOrString	| txt |	txt := aTextOrString asText.	"might be a string"	^self class              string: (string copyReplaceFrom: start to: stop with: txt string)             runs: (runs copyReplaceFrom: start to: stop with: txt runs)! !!Text methodsFor: 'emphasis'!addAttribute: att from: start to: stop 	"Set the attribute for characters in the interval start to stop."	runs :=  runs copyReplaceFrom: start to: stop			with: ((runs copyFrom: start to: stop)				mapValues:				[:attributes | Text addAttribute: att toArray: attributes])! !!Text methodsFor: 'emphasis' stamp: 'ar 12/17/2001 23:48'!alignmentAt: characterIndex ifAbsent: aBlock	| attributes emph |	self size = 0 ifTrue: [^aBlock value].	emph := nil.	attributes := runs at: characterIndex.	attributes do:[:att | (att isKindOf: TextAlignment) ifTrue:[emph := att]].	^ emph ifNil: aBlock ifNotNil:[emph alignment]! !!Text methodsFor: 'emphasis' stamp: 'sw 12/7/1999 12:30'!attributesAt: characterIndex 	"Answer the code for characters in the run beginning at characterIndex."	"NB: no senders any more (supplanted by #attributesAt:forStyle: but retained for the moment in order not to break user code that may exist somewhere that still calls this"	| attributes |	self size = 0		ifTrue: [^ Array with: (TextFontChange new fontNumber: 1)].  "null text tolerates access"	attributes := runs at: characterIndex.	^ attributes! !!Text methodsFor: 'emphasis' stamp: 'sw 12/7/1999 11:32'!attributesAt: characterIndex forStyle: aTextStyle	"Answer the code for characters in the run beginning at characterIndex."	| attributes |	self size = 0		ifTrue: [^ Array with: (TextFontChange new fontNumber: aTextStyle defaultFontIndex)].  "null text tolerates access"	attributes := runs at: characterIndex.	^ attributes! !!Text methodsFor: 'emphasis' stamp: 'di 4/1/1999 15:17'!emphasisAt: characterIndex	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes emph |	self size = 0 ifTrue: [^ 0].	"null text tolerates access"	emph := 0.	attributes := runs at: characterIndex.	attributes do: 		[:att | emph := emph bitOr: att emphasisCode].	^ emph	! !!Text methodsFor: 'emphasis' stamp: 'di 11/10/97 13:36'!find: attribute	"Return the first interval over which this attribute applies"	| begin end |	begin := 0.	runs withStartStopAndValueDo:		[:start :stop :attributes |		(attributes includes: attribute)			ifTrue: [begin = 0 ifTrue: [begin := start].					end := stop]			ifFalse: [begin > 0 ifTrue: [^ begin to: end]]].	begin > 0 ifTrue: [^ begin to: end].	^ nil! !!Text methodsFor: 'emphasis' stamp: 'sw 12/7/1999 10:58'!fontAt: characterIndex withStyle: aTextStyle	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes font |	self size = 0 ifTrue: [^ aTextStyle defaultFont].	"null text tolerates access"	attributes := runs at: characterIndex.	font := aTextStyle defaultFont.  "default"	attributes do: 		[:att | att forFontInStyle: aTextStyle do: [:f | font := f]].	^ font! !!Text methodsFor: 'emphasis'!fontNumberAt: characterIndex 	"Answer the fontNumber for characters in the run beginning at characterIndex."	| attributes fontNumber |	self size = 0 ifTrue: [^1].	"null text tolerates access"	attributes := runs at: characterIndex.	fontNumber := 1.	attributes do: [:att | (att isMemberOf: TextFontChange) ifTrue: [fontNumber := att fontNumber]].	^ fontNumber	! !!Text methodsFor: 'emphasis' stamp: 'md 1/20/2006 17:11'!makeSelectorBold	"For formatting Smalltalk source code, set the emphasis of that portion of 	the receiver's string that parses as a message selector to be bold."	| parser i |	string size = 0 ifTrue: [^ self].	i := 0.	[(string at: (i := i + 1)) isSeparator] whileTrue.	(string at: i) = $[ ifTrue: [^ self].  "block, no selector"	[(parser := Compiler parserClass new) parseSelector: string] on: Error do: [^ self].	self makeBoldFrom: 1 to: (parser endOfLastToken min: string size)! !!Text methodsFor: 'emphasis' stamp: 'sma 2/5/2000 12:03'!makeSelectorBoldIn: aClass	"For formatting Smalltalk source code, set the emphasis of that portion of 	the receiver's string that parses as a message selector to be bold."	| parser |	string size = 0 ifTrue: [^self].	(parser := aClass parserClass new) parseSelector: string.	self makeBoldFrom: 1 to: (parser endOfLastToken min: string size)! !!Text methodsFor: 'emphasis'!removeAttribute: att from: start to: stop 	"Remove the attribute over the interval start to stop."	runs :=  runs copyReplaceFrom: start to: stop			with: ((runs copyFrom: start to: stop)				mapValues:				[:attributes | attributes copyWithout: att])! !!Text methodsFor: 'private' stamp: 'tk 12/16/97 14:14'!setString: aString setRunsChecking: aRunArray	"Check runs and do the best you can to make them fit..."	string := aString.	"check the runs"	aRunArray ifNil: [^ aString asText].	(aRunArray isKindOf: RunArray) ifFalse: [^ aString asText].	aRunArray runs size = aRunArray values size ifFalse: [^ aString asText].	(aRunArray values includes: #()) ifTrue: [^ aString asText].	"not allowed?"	aRunArray size = aString size ifFalse: [^ aString asText].		runs := aRunArray.! !!Text methodsFor: 'private'!setString: aString setRuns: anArray	string := aString.	runs := anArray! !!Text class methodsFor: 'class initialization' stamp: 'mir 8/3/2004 13:30'!initTextConstants 	"Initialize constants shared by classes associated with text display, e.g., 	Space, Tab, Cr, Bs, ESC."		"1/24/96 sw: in exasperation and confusion, changed cmd-g mapping from 231 to 232 to see if I could gain any relief?!!"	| letter varAndValue tempArray width |	"CtrlA..CtrlZ, Ctrla..Ctrlz"	letter := $A. 	#(		212 230 228 196 194 226 241 243 214 229 200 217 246 			245 216 202 210 239 211 240 197 198 209 215 242 231	 		1 166 228 132 130 12 232 179 150 165 136 153 182 			14 15 138 17 18 19 11 21 134 145 151 178 167 ) do:		[:kbd |		TextConstants at: ('Ctrl', letter asSymbol) asSymbol put: kbd asCharacter.		letter := letter == $Z ifTrue: [$a] ifFalse: [(letter asciiValue + 1) asCharacter]].	varAndValue := #(		Space	32		Tab		9		CR		13		Enter	3		BS		8		BS2		158		ESC		160		Clear 	173	).	varAndValue size odd ifTrue: [self error: 'unpaired text constant'].	(2 to: varAndValue size by: 2) do:		[:i | TextConstants at: (varAndValue at: i - 1) put: (varAndValue at: i) asCharacter].	varAndValue := #(		CtrlDigits 			(159 144 143 128 127 129 131 180 149 135)		CtrlOpenBrackets	(201 7 218 249 219 15)			"lparen gottn by ctrl-:= = 201; should be 213 but can't type that on Mac"			"location of non-character stop conditions"		EndOfRun	257		CrossedX	258			"values for alignment"		LeftFlush	0		RightFlush	1		Centered	2		Justified	3			"subscripts for a marginTabsArray tuple"		LeftMarginTab	1		RightMarginTab	2			"font faces"		Basal	0		Bold	1		Italic	2			"in case font doesn't have a width for space character"			"some plausible numbers-- are they the right ones?"		DefaultSpace			4		DefaultTab				24		DefaultLineGrid			16		DefaultBaseline			12		DefaultFontFamilySize	3	"basal, bold, italic"	).	varAndValue size odd ifTrue: [self error: 'unpaired text constant'].	(2 to: varAndValue size by: 2) do:		[:i | TextConstants at: (varAndValue at: i - 1) put: (varAndValue at: i)].	TextConstants at: #DefaultRule	put: Form over.	TextConstants at: #DefaultMask	put: Color black.	width := Display width max: 720.	tempArray := Array new: width // DefaultTab.	1 to: tempArray size do:		[:i | tempArray at: i put: DefaultTab * i].	TextConstants at: #DefaultTabsArray put: tempArray.	tempArray := Array new: (width // DefaultTab) // 2.	1 to: tempArray size do:		[:i | tempArray at: i put: (Array with: (DefaultTab*i) with: (DefaultTab*i))].	TextConstants at: #DefaultMarginTabsArray put: tempArray."Text initTextConstants "! !!Text class methodsFor: 'instance creation'!streamContents: blockWithArg 	| stream |	stream := TextStream on: (self new: 400).	blockWithArg value: stream.	^ stream contents! !!TextAction methodsFor: 'as yet unclassified' stamp: 'nk 2/26/2005 09:49'!analyze: aString	"Analyze the selected text to find both the parameter to store and the text to emphesize (may be different from original selection).  Does not return self!!.  May be of the form:3+4<3+4>Click Here<3+4><3+4>Click Here"	"Obtain the showing text and the instructions"	| b1 b2 trim param show |	b1 := aString indexOf: $<.	b2 := aString indexOf: $>.	(b1 < b2) & (b1 > 0) ifFalse: ["only one part"		param := self validate: aString.		param ifNil: [ ^{ nil. nil } ].		^ Array with: param with: (param size = 0 ifTrue: [nil] ifFalse: [param])].	"Two parts"	trim := aString withBlanksTrimmed.	(trim at: 1) == $< 		ifTrue: [(trim last) == $>			ifTrue: ["only instructions" 				param := self validate: (aString copyFrom: b1+1 to: b2-1).				show := param size = 0 ifTrue: [nil] ifFalse: [param]]			ifFalse: ["at the front"				param := self validate: (aString copyFrom: b1+1 to: b2-1).				show := param size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: b2+1 to: aString size]]]		ifFalse: [(trim last) == $>			ifTrue: ["at the end"				param := self validate: (aString copyFrom: b1+1 to: b2-1).				show := param size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: 1 to: b1-1]]			ifFalse: ["Illegal -- <> has text on both sides"				show := nil]].	^ Array with: param with: show! !!TextAction class methodsFor: 'as yet unclassified' stamp: 'di 1/14/98 09:30'!initialize   "TextAction initialize"	Purple := Color r: 0.4 g: 0 b: 1.0! !!TextAlignment methodsFor: 'as yet unclassified' stamp: 'ar 12/15/2001 23:33'!alignment: aNumber	alignment := aNumber.! !!TextColor methodsFor: 'accessing'!color: aColor	color := aColor! !!TextColor methodsFor: 'scanning' stamp: 'tk 12/16/97 09:47'!writeScanOn: strm	"Two formats.  c125000255 or cblue;"	| nn str |	strm nextPut: $c.	(nn := color name) ifNotNil: [		(self class respondsTo: nn) ifTrue: [			^ strm nextPutAll: nn; nextPut: $;]].	(Array with: color red with: color green with: color blue) do: [:float |		str := '000', (float * 255) asInteger printString.		strm nextPutAll: (str copyFrom: str size-2 to: str size)]! !!TextColor class methodsFor: 'instance creation' stamp: 'sma 3/24/2000 10:49'!scanFrom: strm	"read a color in the funny format used by Text styles on files. c125000255 or cblue;"	| r g b |	strm peek isDigit		ifTrue:			[r := (strm next: 3) asNumber.			g := (strm next: 3) asNumber.			b := (strm next: 3) asNumber.			^ self color: (Color r: r g: g b: b range: 255)].	"A name of a color"	^ self color: (Color perform: (strm upTo: $;) asSymbol)! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:46'!analyze: aString	| list |	list := super analyze: aString.	evalString := list at: 1.	^ list at: 2! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/5/97 17:01'!evalString: str	evalString := str ! !!TextDoIt class methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:06'!scanFrom: strm	"read a doit in the funny format used by Text styles on files. d10 factorial;;  end with two semicolons"	| pos end doit |	pos := strm position.	[strm skipTo: $;. strm peek == $;] whileFalse.	end := strm position - 1.	strm position: pos.	doit := strm next: end-pos.	strm skip: 2.  ";;"	^ self evalString: doit! !!TextEmphasis methodsFor: 'as yet unclassified'!emphasisCode: int	emphasisCode := int.	setMode := true! !!TextEmphasis methodsFor: 'as yet unclassified'!turnOff	setMode := false! !!TextFieldMorph methodsFor: '*eToys-card & stack' stamp: 'tk 1/6/2001 14:15'!setNewContentsFrom: textOrString	"talk to my text"	| tm |	(tm := self findA: TextMorph) ifNil: [^ nil].	tm valueOfProperty: #cardInstance ifAbsent: ["move it down"		tm setProperty: #cardInstance toValue: (self valueOfProperty: #cardInstance)].	tm valueOfProperty: #holdsSeparateDataForEachInstance ifAbsent: ["move it down"		tm setProperty: #holdsSeparateDataForEachInstance toValue: 			(self valueOfProperty: #holdsSeparateDataForEachInstance)].	^ tm setNewContentsFrom: textOrString! !!TextFieldMorph class methodsFor: '*eToys-instance creation' stamp: 'sw 6/13/2001 22:48'!exampleBackgroundField	"Answer a scrollable background field for a parts bin"	| aMorph |	aMorph := self authoringPrototype.	aMorph contents: 'background field' asText allBold.	aMorph setProperty: #shared toValue: true.	aMorph setNameTo: 'scrollingField1'.	aMorph setProperty: #holdsSeparateDataForEachInstance toValue: true.	^ aMorph! !!TextFontChange methodsFor: 'as yet unclassified'!fontNumber: int	fontNumber := int! !!TextFontReference methodsFor: 'as yet unclassified'!toFont: aFont	font := aFont! !!TextIndent methodsFor: 'access' stamp: 'ls 6/22/1998 17:51'!amount: anInteger	"change the number of tabs to indent by"	amount := anInteger! !!TextIndent class methodsFor: 'example' stamp: 'ls 6/24/1998 18:06'!example	"TextIndent example"	| text pg |	"create an example text with some indentation"	text := 'abcdao euoaeuo aeuo aeuoaeu o aeuoeauefgh bcd efghi'  asText.	text addAttribute: (TextColor red)  from: 3 to: 8.	text addAttribute: (TextIndent amount: 1) from: 1 to: 2.	text addAttribute: (TextIndent amount: 2) from: 20 to: 35.	"stick it in a paragraph and display it"	pg := text asParagraph.	pg compositionRectangle: (0@0 extent: 100@200).	pg textStyle alignment: 2.	pg displayAt: 0@0.! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:10'!dominates: other	"NOTE: The use of active in this code is specific to its use in the method		Text class addAttribute: att toArray: others"	(active and: [other class == self class and: [other kern + kern = 0]])		ifTrue: [active := false.  ^ true].  "can only dominate once"	^ false! !!TextKern methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 09:59'!kern: kernValue	kern := kernValue.	self reset.! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:04'!reset	active := true! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:49'!analyze: aString	| list |	list := super analyze: aString.	classAndMethod := list at: 1.	^ list at: 2! !!TextLink methodsFor: 'as yet unclassified' stamp: 'LC 10/8/2001 10:53'!analyze: aString with: nonMethod	"Initalize this attribute holder with a piece text the user typed into a paragraph.  Returns the text to emphesize (may be different from selection)  Does not return self!!.  nonMethod is what to show when clicked, i.e. the last part of specifier (Comment, Definition, or Hierarchy).  May be of the form:Point<Point>Click Here<Point><Point>Click Here"	"Obtain the showing text and the instructions"	| b1 b2 trim |	b1 := aString indexOf: $<.	b2 := aString indexOf: $>.	(b1 < b2) & (b1 > 0) ifFalse: ["only one part"		classAndMethod := self validate: aString, ' ', nonMethod.		^ classAndMethod ifNotNil: [aString]].	"Two parts"	trim := aString withBlanksTrimmed.	(trim at: 1) == $< 		ifTrue: [(trim last) == $>			ifTrue: ["only instructions" 				classAndMethod := self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod ifNotNil: [classAndMethod]]			ifFalse: ["at the front"				classAndMethod := self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod ifNotNil: [aString copyFrom: b2+1 to: aString size]]]		ifFalse: [(trim last) == $>			ifTrue: ["at the end"				classAndMethod := self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod ifNotNil: [aString copyFrom: 1 to: b1-1]]			ifFalse: ["Illegal -- <> has text on both sides"				^ nil]]! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/5/97 17:09'!classAndMethod: aString	classAndMethod := aString! !!TextLink methodsFor: 'as yet unclassified' stamp: 'nk 2/26/2005 09:50'!validate: specString	"Can this string be decoded to be Class space Method (or Comment, Definition, Hierarchy)? If so, return it in valid format, else nil" 	| list first mid last |	list := specString findTokens: ' 	.|'.	list isEmpty ifTrue: [ ^nil ].	last := list last.	last first isUppercase ifTrue: [		(#('Comment' 'Definition' 'Hierarchy') includes: last) ifFalse: [^ nil].		"Check for 'Rectangle Comment Comment' and remove last one"		(list at: list size - 1 ifAbsent: [^nil]) = last ifTrue: [list := list allButLast]].	list size > 3 ifTrue: [^ nil].	list size < 2 ifTrue: [^ nil].	Symbol hasInterned: list first ifTrue: [:sym | first := sym].	first ifNil: [^ nil].	Smalltalk at: first ifAbsent: [^ nil].	mid := list size = 3 		ifTrue: [(list at: 2) = 'class' ifTrue: ['class '] ifFalse: [^ nil]]		ifFalse: [''].	"OK if method name is not interned -- may not be defined yet"	^ first, ' ', mid, last! !!TextMorph methodsFor: '*eToys-card & stack' stamp: 'sw 5/31/2000 01:18'!newContents: stringOrText fromCard: aCard	"Accept new text contents."	| newText setter |	newText := stringOrText asText.	text = newText ifTrue: [^ self].  "No substantive change"	text ifNotNil: [		text embeddedMorphs do: [ :m | m delete ] ].	text := newText.	"add all morphs off the visible region; they'll be moved into the right place when they become visible.  (this can make the scrollable area too large, though)"	stringOrText asText embeddedMorphs do: [ :m | 		self addMorph: m. 		m position: (-1000@0)].	self releaseParagraph.  "update the paragraph cache"	self paragraph.  "re-instantiate to set bounds"	self holdsSeparateDataForEachInstance		ifTrue:			[setter := self valueOfProperty: #setterSelector.			setter ifNotNil:				[aCard perform: setter with: newText]].	self world ifNotNil:		[self world startSteppingSubmorphsOf: self ].! !!TextMorph methodsFor: '*eToys-card & stack' stamp: 'tk 1/8/2001 13:14'!setNewContentsFrom: stringOrTextOrNil	"Using stringOrTextOrNil as a guide, set the receiver's contents afresh.  If the input parameter is nil, the a default value stored in a property of the receiver, if any, will supply the new initial content.  This method is only called when a VariableDock is attempting to put a new value.  This is still messy and ill-understood and not ready for prime time."	| defaultValue tt atts |	stringOrTextOrNil ifNotNil: [^ self newContents: stringOrTextOrNil 		fromCard: (self valueOfProperty: #cardInstance)].		   "Well, totally yuk -- emergency measure late on eve of demo"	defaultValue := self valueOfProperty: #defaultValue 					ifAbsent: [atts := text attributesAt: 1.	"Preserve size, emphasis"						tt := text copyReplaceFrom: 1 to: text size								with: 'blankText'.						atts do: [:anAtt | tt addAttribute: anAtt].						tt].	self contents: defaultValue deepCopy wrappedTo: self width.! !!TextMorph methodsFor: '*eToys-e-toy support' stamp: 'sw 9/15/2000 06:14'!getNumericValue	"Obtain a numeric value from the receiver; if no digits, return zero"	| aString |	^ [(aString := text string) asNumber] ifError: [:a :b | ^ aString asInteger ifNil: [0]]! !!TextMorph class methodsFor: '*eToys-parts bin' stamp: 'sw 6/13/2001 22:46'!exampleBackgroundField	"Answer a background field for a parts bin"	| aMorph |	aMorph := TextMorph authoringPrototype.	aMorph contents: 'background field' asText allBold.	aMorph setProperty: #shared toValue: true.	aMorph setNameTo: 'field1'.	aMorph setProperty: #holdsSeparateDataForEachInstance toValue: true.		^ aMorph! !!TextPrintIt methodsFor: 'as yet unclassified' stamp: 'dvf 10/1/2003 13:27'!actOnClickFor: anObject in: aParagraph at: clickPoint editor: editor	"Note: evalString gets evaluated IN THE CONTEXT OF anObject	 -- meaning that self and all instVars are accessible"	| result range index |	result := Compiler evaluate: evalString for: anObject logged: false.	result := ' ', result printString,' '.	"figure out where the attribute ends in aParagraph"	index := (aParagraph characterBlockAtPoint: clickPoint) stringIndex.	range := aParagraph text rangeOf: self startingAt: index.	editor selectFrom: range last+1 to: range last.	editor zapSelectionWith: result.	editor selectFrom: range last to: range last + result size.	^ true ! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/21/2001 11:26'!adjustTargetMargin: aFractionalPoint	| n |	n := (aFractionalPoint * 4) rounded.	myTarget margins: n.	self showSliderFeedback: n.! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'md 10/22/2003 15:22'!changeStyle	| aList reply style |	aList := StrikeFont actualFamilyNames.	aList addFirst: 'DefaultTextStyle'.	reply := (SelectionMenu labelList: aList lines: #(1) selections: aList) startUp.	reply ifNil: [^self].	(style := TextStyle named: reply) ifNil: [Beeper beep. ^ true].	self applyToWholeText ifTrue: [self activeEditor selectAll].	self activeEditor changeStyleTo: style copy.	self activeTextMorph updateFromParagraph.! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/21/2001 11:07'!changeTargetColorTo: aColor	self applyToWholeText ifTrue: [		lastGlobalColor := aColor	].	self changeSelectionAttributeTo: (TextColor color: aColor)! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/15/2001 12:01'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList := self activeTextMorph textStyle fontNamesWithPointSizes.	reply := (SelectionMenu labelList: aList selections: aList) startUp.	reply ifNil: [^self].	self applyToWholeText ifTrue: [self activeEditor selectAll].	self activeEditor replaceSelectionWith:		(Text string: self activeEditor selection asString 			attribute: (TextFontChange fontNumber: (aList indexOf: reply))).	self activeTextMorph updateFromParagraph.! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'dgd 8/31/2003 21:56'!rebuild	| buttonColor c |	self removeAllMorphs.	self addAColumn: {		self lockedString: ('Text Properties for {1}' translated format:{myTarget name}).	}.	self addAColumn: {		self paneForApplyToWholeText.	}.	c := self addAColumn: {		self activeTextMorph.	}.	c 		wrapCentering: #topLeft;		color: Color white;		borderWidth: 2;		borderColor: color darker.	self addAColumn: {		self paneForTextColorPicker.	}.	self addARow: {		self paneForAutoFitToggle.	}.	self addARow: {		self paneForWrappingToggle.	}.	self addARow: {		self paneForMargins.	}.	buttonColor := color lighter.	self addARow: {		self inAColumn: {			self addARow: {				self 					buttonNamed: 'Size' translated action: #offerFontMenu color: buttonColor					help: 'font changing' translated.				self 					buttonNamed: 'Style' translated action: #changeStyle color: buttonColor					help: 'font changing' translated.				self 					buttonNamed: 'N' translated action: #changeToNormalText color: buttonColor					help: 'normal text' translated.				self 					buttonNamed: 'B' translated action: #toggleBold color: buttonColor					help: 'bold text' translated.				self 					buttonNamed: 'I' translated action: #toggleItalic color: buttonColor					help: 'italic text' translated.				self 					buttonNamed: 'n' translated action: #toggleNarrow color: buttonColor					help: 'narrow text' translated.				self 					buttonNamed: 'U' translated action: #toggleUnderlined color: buttonColor					help: 'underlined text' translated.				self 					buttonNamed: 'S' translated action: #toggleStruckOut color: buttonColor					help: 'struck out text' translated.				self 					buttonNamed: 'Kern-' translated action: #kernMinus color: buttonColor					help: 'decrease kern' translated.				self 					buttonNamed: 'Kern+' translated action: #kernPlus color: buttonColor					help: 'increase kern' translated.			}.		}.	}.	self addARow: {		self inAColumn: {			self addARow: {				self 					buttonNamed: 'Accept' translated action: #doAccept color: buttonColor					help: 'keep changes made and close panel' translated.				self 					buttonNamed: 'Cancel' translated action: #doCancel color: buttonColor					help: 'cancel changes made and close panel' translated.			}.		}.	}.! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/15/2001 11:50'!toggleApplyToWholeText	applyToWholeText := applyToWholeText not.! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/16/2001 09:15'!toggleSelectionAttribute: newAttribute	| selText oldAttributes |	self applyToWholeText ifTrue: [self activeEditor selectAll].	selText := self activeEditor selection asText.	oldAttributes := selText attributesAt: 1 forStyle: self activeTextMorph textStyle.	oldAttributes do: [:att |		(att dominates: newAttribute) ifTrue: [newAttribute turnOff]	].	self activeEditor replaceSelectionWith: (selText addAttribute: newAttribute).	self activeTextMorph updateFromParagraph.! !!TextPropertiesMorph methodsFor: 'initialization' stamp: 'nk 2/12/2004 13:06'!initialize	"initialize the state of the receiver"	super initialize.	""	applyToWholeText := true.	myTarget		ifNil: [""			myTarget := TextMorph new openInWorld.			myTarget contents: ''].	activeTextMorph := myTarget copy.	activeTextMorph extent: 300 @ 100;	 			 releaseCachedState.	thingsToRevert		at: #wrapFlag: put: myTarget isWrapped;		 at: #autoFit: put: myTarget isAutoFit;		 at: #margins: put: myTarget margins;		at: #extent: put: myTarget extent.	self rebuild! !!TextSqkPageLink methodsFor: 'as yet unclassified' stamp: 'tk 1/12/1999 12:56'!actOnClickFor: textMorph	"I represent a link to either a SqueakPage in a BookMorph, or a regular url"	| book |	((url endsWith: '.bo') or: [url endsWith: '.sp']) ifFalse: [		^ super actOnClickFor: textMorph].	book := textMorph ownerThatIsA: BookMorph.	book ifNotNil: [book goToPageUrl: url].	"later handle case of page being in another book, not this one"	^ true! !!TextSqkProjectLink methodsFor: 'as yet unclassified' stamp: 'RAA 10/19/2000 16:24'!analyze: aString	^url := aString! !!TextStream methodsFor: 'as yet unclassified' stamp: 'dvf 10/1/2003 02:51'!nextPutAll: aCollection 	"Optimized access to get around Text at:Put: overhead"	| n |	n := aCollection size.     position + n > writeLimit       ifTrue:        [self growTo: position + n + 10].	collection 		replaceFrom: position+1		to: position + n		with: aCollection		startingAt: 1.	position := position + n! !!TextStream methodsFor: 'as yet unclassified'!withAttribute: att do: strmBlock	| pos1 val |	pos1 := self position.	val := strmBlock value.	collection addAttribute: att from: pos1+1 to: self position.	^ val! !!TextStream methodsFor: 'as yet unclassified' stamp: 'djp 11/6/1999 20:30'!withAttributes: attributes do: streamBlock 	| pos1 val |	pos1 := self position.	val := streamBlock value.	attributes do: [:attribute |		collection			addAttribute: attribute			from: pos1 + 1			to: self position].	^ val! !!TextURL methodsFor: 'as yet unclassified' stamp: 'rbb 2/18/2005 09:24'!actOnClickFor: anObject	"Do what you can with this URL.  Later a web browser."	| response m |	(url beginsWith: 'sqPr://') ifTrue: [		ProjectLoading thumbnailFromUrl: (url copyFrom: 8 to: url size).		^self		"should not get here, but what the heck"	].	"if it's a web browser, tell it to jump"	anObject isWebBrowser		ifTrue: [anObject jumpToUrl: url. ^ true]		ifFalse: [((anObject respondsTo: #model) and: [anObject model isWebBrowser])				ifTrue: [anObject model jumpToUrl: url. ^ true]].		"if it's a morph, see if it is contained in a web browser"		(anObject isKindOf: Morph) ifTrue: [			m := anObject.			[ m ~= nil ] whileTrue: [				(m isWebBrowser) ifTrue: [					m  jumpToUrl: url.					^true ].				(m hasProperty: #webBrowserView) ifTrue: [					m model jumpToUrl: url.					^true ].				m := m owner. ]		].	"no browser in sight.  ask if we should start a new browser"	((self confirm: 'open a browser to view this URL?' translated) and: [WebBrowser default notNil]) ifTrue: [		WebBrowser default openOnUrl: url.		^ true ].	"couldn't display in a browser.  Offer to put up just the source"	response := (UIManager default 				chooseFrom: (Array with: 'View web page as source' translated									with: 'Cancel' translated)				title:  'Couldn''t find a web browser. View\page as source?' withCRs translated).	response = 1 ifTrue: [HTTPSocket httpShowPage: url].	^ true! !!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:47'!analyze: aString	| list |	list := super analyze: aString.	url := list at: 1.	^ list at: 2! !!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 08:55'!url: aString	url := aString! !!ThumbnailForAllPlayersTool methodsFor: 'stepping' stamp: 'sw 7/28/2004 22:23'!step	"periodic action"	| aMorph |	((aMorph := objectToView costume) notNil and: [aMorph isInWorld]) ifTrue:		[super step]  "don't bother changing my readout to blank when/if object disappears"! !!TileLikeMorph methodsFor: 'dropping/grabbing' stamp: 'ar 2/9/2001 23:57'!justGrabbedFrom: formerOwner	| editor |	formerOwner ifNil:[^self].	editor := formerOwner topEditor.	editor ifNotNil:[editor scriptEdited].! !!TileMessageNode methodsFor: 'printing' stamp: 'RAA 6/9/2000 18:25'!printIfNilNotNil: aMorph indent: level	| newNode |	newNode := aMorph parseNode clone.	newNode receiver ifNotNil:		[newNode receiver: newNode receiver ifNilReceiver].	"fudge so it prints right"	(arguments first isJust: NodeNil) ifTrue:		[^ newNode morphFromKeywords: #ifNotNil:				arguments: { arguments second }				on: aMorph indent: level].	(arguments second isJust: NodeNil) ifTrue:		[^ newNode morphFromKeywords: #ifNil:				arguments: { arguments first }				on: aMorph indent: level].	^ newNode morphFromKeywords: #ifNil:ifNotNil:			arguments: arguments			on: aMorph indent: level! !!TileMessageNode methodsFor: 'printing' stamp: 'RAA 6/9/2000 17:15'!printWhileOn: aMorph indent: level	(arguments first isJust: NodeNil) ifTrue: [		selector := SelectorNode new			key: (selector key == #whileTrue:				ifTrue: [#whileTrue] ifFalse: [#whileFalse])			code: #macro.		arguments := Array new	].	self printKeywords: selector key arguments: arguments		on: aMorph indent: level! !!TileMorph methodsFor: 'accessing' stamp: 'di 9/18/97 12:02'!literal: anObject	literal := anObject.	self updateLiteralLabel.	self acceptNewLiteral.		"Show that we are out of date, install is needed"! !!TileMorph methodsFor: 'arrows' stamp: 'ar 11/2/2000 22:29'!addArrows	| frame |	downArrow := ImageMorph new image: DownPicture.	upArrow := ImageMorph new image: UpPicture.	frame := Morph new color: Color transparent.	frame 		layoutPolicy: TableLayout new;		listDirection: #topToBottom;		hResizing: #shrinkWrap; 		vResizing: #shrinkWrap;		cellInset: 0@1;		layoutInset: 0@1.	frame addMorphBack: upArrow; addMorphBack: downArrow.	self addMorphFront: frame.! !!TileMorph methodsFor: 'arrows' stamp: 'tk 8/16/2000 09:48'!addRetractArrow	"Must be situated in a script"	self couldRetract ifNil: [^ self].	retractArrow := ImageMorph new image: RetractPicture.	suffixArrow ifNotNil: [		self addMorph: retractArrow inFrontOf: suffixArrow].	fullBounds := nil.	self extent: self fullBounds extent! !!TileMorph methodsFor: 'arrows' stamp: 'ar 11/2/2000 22:30'!addSuffixArrow	suffixArrow := ImageMorph new image: SuffixPicture.	self addMorphBack: suffixArrow.! !!TileMorph methodsFor: 'arrows' stamp: 'tak 12/5/2004 14:36'!arrowAction: delta 	"Do what is appropriate when an arrow on the tile is pressed; delta will  	be +1 or -1"	| index options |	(type == #literal			and: [literal isNumber])		ifTrue: [self value: literal + delta]		ifFalse: [options := self options						ifNil: [^ self].			index := (options first indexOf: self value)						+ delta.			self				value: (options first atWrap: index).			submorphs last				setBalloonText: (options second atWrap: index)]! !!TileMorph methodsFor: 'arrows' stamp: 'tk 8/16/2000 08:59'!couldRetract	"See if it makes sense to retract this tile and the op before it.  Return the phrase that gets retracted, or nil if not allowed."	| phrase pad |	(phrase := self ownerThatIsA: PhraseTileMorph) ifNil: [^ nil].	(pad := phrase ownerThatIsA: TilePadMorph) ifNil: [^ nil].	(phrase firstSubmorph "goodPad") type == pad type ifFalse: [		phrase submorphs size < 3 ifFalse: [^ nil].	"types should have matched"		"Go up a level"		(phrase := pad ownerThatIsA: PhraseTileMorph) ifNil: [^ nil].		(pad := phrase ownerThatIsA: TilePadMorph) ifNil: [^ nil].		(phrase firstSubmorph "goodPad") type == pad type ifFalse: [^ nil].		].	^ phrase! !!TileMorph methodsFor: 'arrows' stamp: 'ar 9/24/2000 19:11'!deleteLastTwoTiles	"Remove the current suffix (last two tiles) in this line of tiles"	| phrase pad goodPad |	(phrase := self couldRetract) ifNil: [^ self].	pad := phrase ownerThatIsA: TilePadMorph.	goodPad := phrase firstSubmorph.	pad owner addMorphBack: goodPad.	pad delete.	(goodPad lastSubmorph respondsTo: #addSuffixArrow) 		ifTrue: [goodPad lastSubmorph addSuffixArrow; addRetractArrow]		ifFalse: [goodPad lastSubmorph lastSubmorph addSuffixArrow; addRetractArrow].	goodPad topEditor install. "recompile"! !!TileMorph methodsFor: 'arrows' stamp: 'tk 8/10/2000 14:34'!deleteSuffixArrow	suffixArrow delete.	suffixArrow := nil.	retractArrow ifNotNil: ["backward compat"		retractArrow delete.		retractArrow := nil].	self updateLiteralLabel! !!TileMorph methodsFor: 'arrows' stamp: 'sw 1/4/2005 02:09'!phraseForOp: op arg: arg resultType: resultType	"Answer a numeric-valued phrase derived from the receiver, whose extension arrow has just been hit.  Pass along my float-precision."	| phrase srcLabel distLabel |	phrase := self presenter				phraseForReceiver: literal				op: op				arg: 1				resultType: #Number.	srcLabel := self findA: UpdatingStringMorph.	distLabel := phrase submorphs first submorphs first findA: UpdatingStringMorph.	distLabel floatPrecision: srcLabel floatPrecision.	^ phrase! !!TileMorph methodsFor: 'arrows' stamp: 'tak 12/5/2004 15:33'!showSuffixChoices	"The suffix arrow has been hit, so respond appropriately"	| plusPhrase phrase pad outer num |	(phrase := self ownerThatIsA: PhraseTileMorph) ifNil: [^ self].	(type == #literal) & (literal isNumber) ifTrue: ["Tile is a constant number"		phrase lastSubmorph == owner "pad"			ifTrue: ["we are adding the first time (at end of our phrase)"				plusPhrase := self phraseForOp: #+ arg: 1 resultType: #Number.				plusPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: #+).				owner acceptDroppingMorph: plusPhrase event: self primaryHand lastEvent.				num := plusPhrase firstSubmorph firstSubmorph.				num deleteSuffixArrow]].	type == #operator ifTrue: ["Tile is accessor of an expression"		phrase resultType == #Number ifTrue:			[outer := phrase ownerThatIsA: PhraseTileMorph.			pad := self ownerThatIsA: TilePadMorph.			outer ifNotNil:				[outer lastSubmorph == pad ifTrue: [ "first time"					plusPhrase := self presenter phraseForReceiver: 1 							op: #+ arg: 1 resultType: #Number.					plusPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: #+).					pad acceptDroppingMorph: plusPhrase event: self primaryHand lastEvent.					plusPhrase firstSubmorph removeAllMorphs; addMorph: phrase.	"car's heading"					self deleteSuffixArrow.					pad topEditor install "recompile"]]]].	(phrase topEditor ifNil: [phrase]) enforceTileColorPolicy! !!TileMorph methodsFor: 'arrows' stamp: 'ar 2/12/2001 13:55'!variableDelay: aBlock	| now delay dt |	(self hasProperty: #inVariableDelay) ifTrue:[^self].	nArrowTicks ifNil: [nArrowTicks := 1].	now := Time millisecondClockValue.	aBlock value.	delay := nArrowTicks > 5 ifTrue: [100] ifFalse: [300].	nArrowTicks := nArrowTicks + 1.	dt := Time millisecondClockValue - now max: 0.  "Time it took to do."	dt < delay ifTrue: [		self setProperty: #inVariableDelay toValue: true.		self addAlarm: #removeProperty: withArguments: #(inVariableDelay) after: (delay - dt)].! !!TileMorph methodsFor: 'code generation' stamp: 'sw 8/30/2004 16:34'!acceptNewLiteral	"Tell the scriptEditor who I belong to that I have a new literal value."	| topScript |	topScript := self outermostMorphThat:		[:m | m isKindOf: ScriptEditorMorph].	topScript ifNotNil: [topScript installWithNewLiteral].	(self ownerThatIsA: ViewerLine) ifNotNilDo:		[:aLine |			(self ownerThatIsA: PhraseTileMorph) ifNotNil:				[aLine removeHighlightFeedback.				self layoutChanged.				ActiveWorld doOneSubCycle.				aLine addCommandFeedback]]! !!TileMorph methodsFor: 'code generation'!precedingTileType	"Return the slot reference type of the preceding TileMorph in my owner."	| row i tile |	row := owner submorphs.	i := row indexOf: self.	((i > 1) and: [(tile := row at: i - 1) isKindOf: TileMorph])		ifTrue: [^ tile type]		ifFalse: [^ #unknown].! !!TileMorph methodsFor: 'code generation' stamp: 'sw 9/26/97 10:51'!scriptEdited	"Tell the scriptEditor who I belong to that I have changed.  "	| him |	(him := self outermostMorphThat: [:m| m isKindOf: ScriptEditorMorph])		ifNotNil: [him scriptEdited]! !!TileMorph methodsFor: 'code generation' stamp: 'yo 4/4/2005 16:14'!storeCodeOn: aStream indent: tabCount 	"Store code representing the receiver onto the stream, with the given amount of indentation"	| op playerBearingCode |	playerBearingCode := self playerBearingCode.	"Must determine whom is scripted for what follows to work; if it's ever nil, we've got trouble"	type = #expression 		ifTrue: 			[^aStream				nextPut: $(;				nextPutAll: operatorOrExpression;				nextPut: $)].	type = #literal 		ifTrue: 			[^aStream				nextPut: $(;				nextPutAll: literal printString;				nextPut: $)].	type == #objRef 		ifTrue: 			[^playerBearingCode == actualObject 				ifTrue: 					["If the object is the method's own 'self' then we MUST, rather than just MAY, put out 'self' rather than the referencer call, though the latter will temporarily work if only one instance of the uniclass exists."					aStream nextPutAll: 'self']				ifFalse: 					[(actualObject isPlayerLike and: [actualObject isSequentialStub]) ifTrue: [						actualObject storeCodeOn: aStream indent: tabCount.					] ifFalse: [						 Preferences capitalizedReferences 						ifTrue: 							["Global dictionary References"							self flag: #deferred.	"Start deploying the meesage-receiver hints soon"							aStream nextPutAll: actualObject uniqueNameForReference]						ifFalse: 							["old class-inst-var-based scheme used  Feb 1998 to Oct 2000, and indeed						ongoing in school year 2000-01 at the open school"							aStream nextPutAll: 'self class '.							aStream 								nextPutAll: (playerBearingCode class referenceSelectorFor: actualObject)]]]].	type = #operator 		ifTrue: 			[op := ((UpdatingOperators includesKey: operatorOrExpression) 				and: [self precedingTileType = #slotRef]) 					ifTrue: [UpdatingOperators at: operatorOrExpression]					ifFalse: [operatorOrExpression].			^op isEmpty 				ifTrue: [aStream position: aStream position - 1]				ifFalse: [aStream nextPutAll: op]]	"The following branch has long been disused	type = #slotRef ifTrue:		[self isThisEverCalled.		refType := self slotRefType.		refType = #get ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities getterSelectorFor: slotName)].		refType = #set ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities setterSelectorFor: slotName);				nextPut: $:].		refType = #update ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: slotName;				nextPutAll: ': ';				nextPutAll: targetName;				space;				nextPutAll: slotName]]"! !!TileMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:15'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.actualObject := deepCopier references at: actualObject ifAbsent: [actualObject].! !!TileMorph methodsFor: 'copying' stamp: 'sw 6/4/2001 16:45'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.type := type veryDeepCopyWith: deepCopier.slotName := slotName veryDeepCopyWith: deepCopier.literal := literal veryDeepCopyWith: deepCopier.operatorOrExpression := operatorOrExpression veryDeepCopyWith: deepCopier."actualObject := actualObject.		Weakly copied"downArrow := downArrow veryDeepCopyWith: deepCopier.upArrow := upArrow veryDeepCopyWith: deepCopier.suffixArrow := suffixArrow veryDeepCopyWith: deepCopier.typeColor := typeColor veryDeepCopyWith: deepCopier.lastArrowTick := lastArrowTick veryDeepCopyWith: deepCopier.nArrowTicks := nArrowTicks veryDeepCopyWith: deepCopier.operatorReadoutString := operatorReadoutString veryDeepCopyWith: deepCopier.possessive := possessive veryDeepCopyWith: deepCopier.retractArrow := retractArrow veryDeepCopyWith: deepCopier.vocabularySymbol := vocabularySymbol.  "Weakly copied"vocabulary := nil.   "obsolete - clobbered"! !!TileMorph methodsFor: 'dropping/grabbing' stamp: 'ar 2/9/2001 23:57'!justGrabbedFrom: formerOwner	| editor |	formerOwner ifNil:[^self].	editor := formerOwner topEditor.	editor ifNotNil:[editor scriptEdited].! !!TileMorph methodsFor: 'event handling' stamp: 'ar 2/8/2001 20:07'!handlesMouseDown: evt	"Answer whether the receiver would handle the mouseDown represented by evt"	| aPoint |	aPoint := evt cursorPoint.	(operatorOrExpression notNil and: [upArrow notNil]) ifTrue: [^ true].		"Click on the operator presents list of alternatives"	upArrow ifNotNil: [^true].	suffixArrow ifNotNil: [^true].	retractArrow ifNotNil: [^true].	^ super handlesMouseDown: evt! !!TileMorph methodsFor: 'event handling' stamp: 'tak 12/6/2004 01:28'!mouseDown: evt 	self setProperty: #previousLiteral toValue: self literalFromContents.	self setProperty: #previousPoint toValue: evt position.	self currentHand releaseKeyboardFocus.	evt hand		waitForClicksOrDrag: self		event: evt		selectors: {#mouseStillDown:. nil. nil. #startDrag:}		threshold: 5.	^ super mouseDown: evt! !!TileMorph methodsFor: 'event handling' stamp: 'wiz 9/22/2007 23:46'!mouseMove: evt 	self options		ifNotNil: [^ self showOptions].	(self hasProperty: #previousLiteral)		ifFalse: [^ self].	self currentHand releaseKeyboardFocus.	"Once reviving the value at drag start"	literal := self valueOfProperty: #previousLiteral.	"Then applying delta"	self arrowAction: (self valueOfProperty: #previousPoint) y - evt position y * self arrowDelta abs.	^ super mouseMove: evt! !!TileMorph methodsFor: 'event handling' stamp: 'tak 12/6/2004 01:00'!mouseStillDown: evt 	"See if arrows are being pressed and call arrowAction:..."	| aPoint |	upArrow		ifNil: [^ super mouseStillDown: evt].	aPoint := evt cursorPoint.	(upArrow containsPoint: aPoint)		ifTrue: [^ self				variableDelay: [self arrowAction: self arrowDelta]].	(downArrow containsPoint: aPoint)		ifTrue: [^ self				variableDelay: [self arrowAction: self arrowDelta negated]].	self options		ifNotNil: [^ self showOptions]! !!TileMorph methodsFor: 'events-processing' stamp: 'ar 9/18/2000 18:03'!handlerForMouseDown: anEvent	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event"	| aPoint |	upArrow ifNotNil:		[(upArrow bounds containsPoint: (aPoint := anEvent cursorPoint))			ifTrue: [^self].		(downArrow bounds containsPoint: aPoint)			ifTrue: [^self]].	^super handlerForMouseDown: anEvent! !!TileMorph methodsFor: 'e-toy support' stamp: 'sw 6/4/2001 16:48'!adoptVocabulary: aVocabulary	"Set the receiver's vocabulary"	vocabularySymbol := aVocabulary vocabularyName.	self updateWordingToMatchVocabulary.	super adoptVocabulary: aVocabulary! !!TileMorph methodsFor: 'initialization' stamp: 'dgd 9/1/2003 13:35'!bringUpToDate	"Make certain, if the receiver is an object-reference tile, that it shows the current external name of the object, which may just have changed.  This only applies to the Player regime." 	| newLabel |		(type == #objRef and: [actualObject isPlayerLike]) ifTrue:		[newLabel := actualObject externalName.		self isPossessive ifTrue:			[newLabel := newLabel, '''s' translated].		self line1: newLabel]! !!TileMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:44'!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: 1 @ 1.	self		typeColor: (Color				r: 0.8				g: 1.0				b: 0.6).	type := #literal.	"#literal, #slotRef, #objRef, #operator, #expression"	slotName := ''.	literal := 1.	self layoutPolicy: TableLayout new.	self cellInset: 2 @ 0.	self layoutInset: 1 @ 0.	self listDirection: #leftToRight.	self wrapCentering: #center.	self hResizing: #shrinkWrap.	self vResizing: #spaceFill! !!TileMorph methodsFor: 'initialization' stamp: 'yo 4/4/2005 14:31'!referToSimilarObject: anObject	"Make the receiver be an object-reference tile whose referent is anObject"	actualObject := anObject.! !!TileMorph methodsFor: 'initialization' stamp: 'sw 9/28/2000 12:27'!referTo: anObject	"Make the receiver be an object-reference tile whose referent is anObject"	type := #objRef.	typeColor := ScriptingSystem colorForType: anObject basicType.	actualObject := anObject.	self line1: anObject uniqueNameForReference! !!TileMorph methodsFor: 'initialization' stamp: 'sw 3/3/2004 16:28'!retargetFrom: oldPlayer to: newPlayer	"Change the receiver so that if formerly it referred to oldPlayer, it refers to newPlayer instead"	| newLabel |	(type == #objRef  and: [actualObject == oldPlayer]) ifTrue:		[actualObject := newPlayer.		newLabel := actualObject externalName.		self isPossessive ifTrue:			[newLabel := newLabel, '''s' translated].		self line1: newLabel]! !!TileMorph methodsFor: 'initialization'!setExpression: exprString label: labelString	type := #expression.	operatorOrExpression := exprString.	self line1: labelString.! !!TileMorph methodsFor: 'initialization' stamp: 'nk 8/30/2004 08:02'!setLiteral: anObject	"Set the receiver's literal to be anObject.  Create a readout morph and add it to the receiver, deleting any existing one that may be there."	| m already |	already := submorphs detect: [:aSubMorph  | aSubMorph isKindOf: UpdatingStringMorph] ifNone: [nil].	already ifNotNil: [already delete].	type := #literal.	m := UpdatingStringMorph contents: ' ' font: ScriptingSystem fontForTiles.	m target: self; getSelector: #literal; putSelector: #literal:.	(anObject isString or: [ anObject isText]) ifTrue: [m useStringFormat].	self addMorphBack: m.	self setLiteralInitially: anObject.! !!TileMorph methodsFor: 'initialization' stamp: 'sw 9/27/2001 04:09'!setOperator: aString andUseWording: wording	"Set the operator symbol from the string provided"	type := #operator.	operatorOrExpression := aString asSymbol. 	self line1: wording.	(ScriptingSystem doesOperatorWantArrows: operatorOrExpression)		ifTrue: [self addArrows].	self updateLiteralLabel	"operatorOrExpression == #heading ifTrue: [self halt]."! !!TileMorph methodsFor: 'initialization' stamp: 'sw 5/17/2001 12:17'!setOperatorAndUseArrows: aString	"Set the operator as per aString, and add up/down arrows"	type := #operator.	operatorOrExpression := aString asSymbol. 	self line1: (self currentVocabulary tileWordingForSelector: operatorOrExpression).	self addArrows; updateLiteralLabel.	submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: operatorOrExpression)! !!TileMorph methodsFor: 'initialization' stamp: 'sw 9/13/2001 21:58'!setSlotRefOperator: getter	"getter represents the name of a slot that the receiver is to represent; configure the receiver to serve thi duty, and set upthe wording on the tile appropriately"	type := #operator.	operatorOrExpression := getter asSymbol.	self line1:  (self currentEToyVocabulary tileWordingForSelector: operatorOrExpression).	self updateLiteralLabel! !!TileMorph methodsFor: 'initialization' stamp: 'dgd 8/26/2004 12:04'!setToReferTo: anObject	"Set the receiver to bear an object reference to the given object."	self flag: #yo.	type := #objRef.	actualObject := anObject.	self line1: anObject nameForViewer.	self typeColor: (ScriptingSystem colorForType: #Player).	self enforceTileColorPolicy! !!TileMorph methodsFor: 'initialization' stamp: 'yo 7/2/2004 21:44'!updateWordingToMatchVocabulary	"The current vocabulary has changed; change the wording on my face, if appropriate"	| aMethodInterface |	type == #operator ifTrue:		[self line1: (self currentVocabulary tileWordingForSelector: operatorOrExpression).		(ScriptingSystem doesOperatorWantArrows: operatorOrExpression)			ifTrue: [self addArrows].		self updateLiteralLabel.		aMethodInterface := self currentVocabulary methodInterfaceAt: operatorOrExpression			ifAbsent: [				Vocabulary eToyVocabulary					methodInterfaceAt: operatorOrExpression ifAbsent: [^ self]].		self setBalloonText: aMethodInterface documentation.	].	type == #objRef ifTrue: [		self isPossessive			ifTrue: [self bePossessive]			ifFalse: [self labelMorph contents: self actualObject nameForViewer asSymbol translated]].		"submorphs last setBalloonText: aMethodInterface documentation"! !!TileMorph methodsFor: 'macpal' stamp: 'sw 6/4/2001 19:33'!currentVocabulary	"Answer the receiver's current vocabulary"	| outer aVocab |	vocabulary ifNotNil:  "old structures -- bring up to date"		[vocabularySymbol := vocabulary vocabularyName.		vocabulary := nil].	^ vocabularySymbol		ifNotNil:			[Vocabulary vocabularyNamed: vocabularySymbol]		ifNil:			[(outer := self ownerThatIsA: StandardViewer orA: ScriptEditorMorph) 				ifNotNil:					[aVocab := outer currentVocabulary.					vocabularySymbol := aVocab vocabularyName.					aVocab]				ifNil:					[super currentVocabulary]]! !!TileMorph methodsFor: 'misc' stamp: 'dgd 8/30/2003 22:19'!addCustomMenuItems:  aMenu hand: aHandMorph	"Add custom halo menu items to a menu"	| aPlayer |	super addCustomMenuItems: aMenu hand: aHandMorph.	((aPlayer := self associatedPlayer) notNil and:		[aPlayer costume isMorph]) ifTrue:			[aMenu addLine.			aMenu add: 'hand me this object' translated target: self action: #handReferentMorph.			aMenu balloonTextForLastItem: 'This tile refers to an actual graphical object; use this menu item to grab that object.  Caution!!  This may remove the object from a place it really ought to stay.' translated.			aMenu addLine ]! !!TileMorph methodsFor: 'misc' stamp: 'sw 4/9/2001 12:55'!handReferentMorph	"Hand the user the actual morph referred to"	| aMorph surrogate |	((aMorph := actualObject costume) isMorph and:		[aMorph isWorldMorph not])			ifTrue:				[surrogate := CollapsedMorph collapsedMorphOrNilFor: aMorph.				surrogate					ifNotNil:						[surrogate uncollapseToHand]					ifNil:						[ActiveHand attachMorph: aMorph]]! !!TileMorph methodsFor: 'misc' stamp: 'sw 9/17/1999 08:02'!minimumWidth	| aWidth |	aWidth := self basicWidth.	upArrow ifNotNil: [aWidth := aWidth + UpArrowAllowance].	suffixArrow ifNotNil: [aWidth := aWidth + SuffixArrowAllowance].	^ aWidth	! !!TileMorph methodsFor: 'misc' stamp: 'sw 9/15/2000 06:00'!setLiteralInitially: anObject	"Establish the initial literal.  Get the label correct, but do *not* send the value back to the target via the setter (unlike #literal:)"	literal := anObject.	self updateLiteralLabel! !!TileMorph methodsFor: 'misc' stamp: 'sw 1/28/2005 00:54'!soundChoices	"Answer a list of sound choices.  This applies only to tiles that have sound-names as their literals, viz. SoundTiles and SoundReadoutTiles."	| aList |	aList := SoundService default sampledSoundChoices asOrderedCollection.	aList removeAllFoundIn: (ScriptingSystem soundNamesToSuppress copyWithout: literal).	^ aList asSortedArray! !!TileMorph methodsFor: 'misc' stamp: 'sw 8/28/2004 15:20'!typeColor: aColor	"Set the receiver's typeColor"	borderColor := ScriptingSystem standardTileBorderColor.	typeColor := aColor.	color := ScriptingSystem uniformTileInteriorColor ! !!TileMorph methodsFor: 'mouse handling' stamp: 'sw 11/22/2000 10:50'!presentOperatorAlternatives: evt	"The receiver is a tile that represents an operator; a click on the receiver's label will pop up a menu of alternative operator choices"	| result ops |	((ops := ScriptingSystem arithmeticalOperatorsAndHelpStrings first) includes: operatorOrExpression) ifFalse:		[((ops := ScriptingSystem numericComparitorsAndHelpStrings first) includes: operatorOrExpression)			ifFalse: [^ self]].			(result := (SelectionMenu selections: ops) startUp) ifNotNil:		[self setOperatorAndUseArrows: result asString.		self scriptEdited]! !!TileMorph methodsFor: 'mouse handling' stamp: 'yo 3/14/2005 10:27'!showOptions	"The receiver is a tile that represents an operator; a click on the 	receiver's label will pop up a menu of alternative operator choices"	| result menuChoices word |	menuChoices := (self options first collect: [:each | each asString translated]) collect: [:each | 							word := self currentVocabulary translatedWordingFor: each asSymbol.							word isEmpty								ifTrue: ['<-']								ifFalse: [word]].	result := (SelectionMenu labelList: menuChoices lines: nil selections: self options first) startUp.	result 		ifNotNil: [self value: result.			self scriptEdited]! !!TileMorph methodsFor: 'player viewer' stamp: 'sw 9/13/2001 21:58'!updateLiteralLabel	"Update the wording emblazoned on the tile, if needed"	| myLabel |	(myLabel := self labelMorph) ifNil: [^ self].	myLabel acceptValue:		(type == #literal			ifTrue:				[literal] 			ifFalse: [operatorReadoutString 				ifNil:		[self currentEToyVocabulary tileWordingForSelector: operatorOrExpression]				ifNotNil:  	[operatorReadoutString]]).	self changed.! !!TileMorph methodsFor: 'tiles from method' stamp: 'tk 8/6/1999 16:00'!selectorTile: msgNode in: aScriptor	| sel selTile |	"Make a selector (operator) tile"	sel := msgNode selector key.	sel == #color:sees: ifTrue: [		selTile := (Viewer new) colorSeesPhrase submorphs second.	"ColorSeer tile"		selTile colorSwatchColor: msgNode arguments first eval.		^ selTile].	^ self setOperator: sel! !!TileMorph methodsFor: 'private' stamp: 'ar 11/2/2000 19:21'!convertAlignment	"Convert the receiver's alignment rules"	| where frame |	owner ifNotNil:[		owner class == TilePadMorph ifTrue:[			owner layoutPolicy: TableLayout new.			owner hResizing: #shrinkWrap.			owner vResizing: #spaceFill.		].	].	self layoutPolicy: TableLayout new.	self cellInset: 2@0.	self layoutInset: 1@0.	self listDirection: #leftToRight.	self wrapCentering: #center.	self hResizing: #shrinkWrap.	self vResizing: #spaceFill.	"Now convert up and down arrow"	(upArrow notNil and:[upArrow owner == self "e.g., not converted"		and:[downArrow notNil and:[downArrow owner == self]]]) ifTrue:[			"where to insert the frame"			where := (submorphs indexOf: upArrow) min: (submorphs indexOf: downArrow).			frame := Morph new color: Color transparent.			frame 				layoutPolicy: TableLayout new;				listDirection: #topToBottom;				hResizing: #shrinkWrap; 				vResizing: #shrinkWrap;				cellInset: 0@1;				layoutInset: 0@1.			self privateAddMorph: frame atIndex: where.			frame addMorphBack: upArrow; addMorphBack: downArrow.		].! !!TileMorph methodsFor: 'private' stamp: 'sw 10/30/2000 09:00'!line1: line1	"Emblazon the receiver with the requested label.  If the receiver already has a label, make the new label be of the same class"	| m desiredW classToUse lab |	classToUse := (lab := self labelMorph) ifNotNil: [lab class] ifNil: [StringMorph].	self removeAllMorphs.	m := classToUse contents: line1 font: ScriptingSystem fontForTiles.	desiredW := m width + 6.	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	m position: self center - (m extent // 2).	self addMorph: m.! !!TileMorph methodsFor: 'private' stamp: 'tk 8/14/2000 13:32'!test	| pos hh |	"Set the position of all my submorphs.  Compute my bounds.  Caller must call layoutChanged or set fullBounds to nil."	fullBounds ifNil: [		pos := self topLeft.		self submorphsDo: [:sub | 			hh := (self class defaultH - sub height) // 2.	"center in Y"			sub privateBounds: (pos + (2@hh) extent: sub extent).			pos x: (sub right min: 1200)].	"2 pixels spacing on left"		bounds := bounds topLeft corner: pos + (2 @ self class defaultH).		fullBounds := bounds.		].	owner class == TilePadMorph ifTrue: [owner bounds: bounds].	^ fullBounds! !!TileMorph class methodsFor: 'class initialization' stamp: 'sw 1/21/98 17:30'!fixCaretForms	"TileMorph fixCaretForms"	"UpPicture storeString"	"DownPicture storeString"	UpPicture :=  Form	extent: 9@8	depth: 16	fromArray: #( 0 0 60817408 0 0 0 0 60818336 0 0 0 928 60818336 60817408 0 0 928 60818336 60817408 0 0 60818336 60818336 60818336 0 928 60818336 60818336 60818336 0 928 60818336 60818336 60818336 60817408 60818336 60818336 60818336 60818336 60817408)	offset: 0@0.	DownPicture := Form	extent: 9@8	depth: 16	fromArray: #( 60818336 60818336 60818336 60818336 60817408 928 60818336 60818336 60818336 60817408 928 60818336 60818336 60818336 0 0 60818336 60818336 60818336 0 0 928 60818336 60817408 0 0 928 60818336 60817408 0 0 0 60818336 0 0 0 0 60817408 0 0)	offset: 0@8.	SuffixPicture :=  Form	extent: 10@8	depth: 16	fromArray: #( 928 0 0 0 0 60818336 60818336 0 0 0 60818336 60818336 60818336 60817408 0 60818336 60818336 60818336 60818336 0 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 0 60818336 60818336 60818336 0 0)	offset: 0@0! !!TileMorph class methodsFor: 'class initialization' stamp: 'tk 8/15/2000 11:00'!initialize	"TileMorph readInArrowGraphics    -- call manually if necessary to bring graphics forward"	"TileMorph initialize"	UpdatingOperators := Dictionary new.	UpdatingOperators at: #incr: put: #+.	UpdatingOperators at: #decr: put: #-.	UpdatingOperators at: #set: put: ''.	RetractPicture ifNil: [		RetractPicture := (SuffixPicture flipBy: #horizontal centerAt: (SuffixPicture center))].	SuffixArrowAllowance := 5 + SuffixPicture width + RetractPicture width.	UpArrowAllowance := 10.! !!TileMorph class methodsFor: 'class initialization' stamp: 'mdr 9/4/2000 11:06'!readInArrowGraphics	"TileMorph readInArrowGraphics"	| obj |	obj := (FileStream readOnlyFileNamed: 'tile inc arrow.morph') fileInObjectAndCode.	UpPicture := obj form.	obj := (FileStream readOnlyFileNamed: 'tile dec arrow.morph') fileInObjectAndCode.	DownPicture := obj form.	obj := (FileStream readOnlyFileNamed: 'tile suffix arrow.morph')fileInObjectAndCode.	SuffixPicture := obj form.! !!TilePadMorph methodsFor: 'layout' stamp: 'sw 1/6/2005 03:25'!acceptDroppingMorph: aMorph event: evt 	"Accept the given morph within my bowels"	| editor wasPossessive morphToUse |	wasPossessive := submorphs notEmpty and: [submorphs first isPossessive].	morphToUse := self morphToDropFrom: aMorph.	self prepareToUndoDropOf: morphToUse.	self removeAllMorphs.	morphToUse position: self position.	self addMorph: morphToUse.	wasPossessive ifTrue: [morphToUse bePossessive].	morphToUse lastTile addRetractArrow.	"if can"	(editor := self topEditor) ifNotNil: [editor install]! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'ar 8/16/2001 13:30'!isColorConstant: aParseNode	"Is this a Color constant, of the form (MessageNode (VariableNode Color->Color) (SelectorNode #r:g:b:) (LiteralNode LiteralNode LiteralNode))"	| rec |	((rec := aParseNode receiver) isKindOf: VariableNode) ifFalse: [^ false].	rec key isVariableBinding ifFalse: [^ false].	rec key value == Color ifFalse: [^ false].	aParseNode selector key == #r:g:b: ifFalse: [^ false].	aParseNode arguments  size = 3 ifFalse: [^ false].	^ true! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'tk 8/3/1999 13:25'!isOutsideRef: aParseNode	"Is this a reference to an outside Player, of the form (self class refUnscriptedPlayer1)?(MessageNode (VariableNode 'self') (SelectorNode 'class')) (SelectorNode 'refUnscriptedPlayer1')"	| rec |	((rec := aParseNode receiver) isKindOf: MessageNode) ifFalse: [^ false].	rec receiver isSelfPseudoVariable ifFalse: [^ false].	rec selector key == #class ifFalse: [^ false].	aParseNode selector key numArgs = 0 ifFalse: [^ false].	(aParseNode selector key beginsWith: 'ref') ifFalse: [^ false].	^ true! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'sw 5/1/2005 03:42'!morphToDropFrom: aMorph 	"Given a morph being carried by the hand, which the hand is about to drop, answer the actual morph to be deposited.  Normally this would be just the morph itself, but several unusual cases arise, which this method is designed to service."	| vwr |	(aMorph isKindOf: WatcherWrapper)		ifTrue: [^ aMorph getterTilesForDrop].	^ ((self type capitalized = #Graphic)  "Special-case requested by Alan 4/30/05"		and: [aMorph isKindOf: TileMorph] and: [aMorph resultType = #Player])			ifFalse:				[aMorph]			ifTrue:				[vwr := CategoryViewer new initializeFor: aMorph associatedPlayer categoryChoice: #basic.				vwr getterTilesFor: (Utilities getterSelectorFor: #graphic)  type: #Graphic]! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'sw 9/17/1999 08:03'!setType: aSymbol	type := aSymbol.	self color: (ScriptingSystem colorForType: type).	self extent: (self basicWidth @ TileMorph defaultH)! !!TilePadMorph methodsFor: 'mouse' stamp: 'sw 5/1/2005 03:17'!canAccept: aMorph	"Answer whether this pad can accept the given morph"	| itsType myType |	((aMorph isKindOf: PhraseTileMorph) or: [aMorph isKindOf: TileMorph orOf: WatcherWrapper]) 		ifTrue:			[^ ((itsType := aMorph resultType capitalized) = (myType := self type capitalized)) or:				[(myType = #Graphic) and: [itsType = #Player]]].	^ false! !!Time methodsFor: 'private' stamp: 'gk 8/31/2006 00:20'!seconds: secondCount	"Private - only used by Time class."	seconds _ secondCount.	nanos _ 0! !!Time methodsFor: 'private' stamp: 'gk 8/31/2006 00:20'!seconds: secondCount nanoSeconds: nanoCount 	"Private - only used by Time class."	seconds _ secondCount.	nanos _ nanoCount! !!Time methodsFor: 'private' stamp: 'gk 8/30/2006 23:28'!ticks: anArray	"ticks is an Array: { days. seconds. nanoSeconds }"	seconds _ anArray at: 2.	nanos _ anArray at: 3! !!Time class methodsFor: 'ansi protocol' stamp: 'kph 12/9/2006 10:17'!milliSecondsSinceMidnight	^ DateAndTime milliSecondsSinceMidnight! !!Time class methodsFor: 'ansi protocol' stamp: 'kph 12/9/2006 10:18'!now	"Answer a Time representing the time right now - this is a 24 hour clock."	| ms |		ms := self milliSecondsSinceMidnight.	^ self seconds:  (ms // 1000) nanoSeconds: (ms \\ 1000) * 1000000! !!Time class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 00:39'!seconds: seconds	"Answer a Time from midnight."	^ self basicNew ticks: (Duration seconds: seconds) ticks! !!Time class methodsFor: 'squeak protocol' stamp: 'gk 8/30/2006 23:29'!seconds: seconds nanoSeconds: nanoCount	"Answer a Time from midnight."	^ self basicNew		ticks: (Duration seconds: seconds nanoSeconds: nanoCount) ticks! !!Time class methodsFor: 'clock' stamp: 'kph 12/14/2006 01:43'!secondsWhenClockTicks	"waits for the moment when a new second begins"	| lastSecond delay |	delay :=  Delay forMilliseconds: 1.	lastSecond _ self primSecondsClock.	[ lastSecond = self primSecondsClock ] whileTrue: [ delay wait ]. 	^ lastSecond + 1! !!TimeTest methodsFor: 'Tests' stamp: 'gk 8/31/2006 00:47'!testSqueakInquiries	| timewords totalseconds condensed corrected |	self assert: 		(self timeClass namesForTimes: #(2 10000023 10000026))			= #('January, 1901' 'April, 1901, 4/26/1901, 5:47 pm' 'April, 1901, 4/26/1901, 5:47 pm').	timewords := #(0.5 30 62 130 4000 10000 60000 86401) 		collect: [ :ss | self timeClass humanWordsForSecondsAgo: ss ].	self assert: 		timewords = #('a second ago' '30 seconds ago' 'a minute ago' '2 minutes ago' 			'an hour ago' '2 hours ago' '16 hours ago' 'yesterday').	totalseconds :=  self timeClass totalSeconds.	condensed := self timeClass condenseBunches: 		(#(20 400 401  20000 20200 20300 40000 45000  200000 201000 202000) 			collect: [:tt | totalseconds - tt]).	corrected := condensed collect: [ :e | totalseconds - e ].	self		assert: (corrected includesAllOf: #(20 400 401 20000 40000 45000 200000)).! !!TraitBehavior methodsFor: 'class compatibility' stamp: 'dc 5/8/2007 13:51'!allClassVarNames	^#()! !!TraitBehavior methodsFor: 'class compatibility' stamp: 'dc 7/23/2007 11:13'!allSubclasses	^ Array new! !!TraitBehavior methodsFor: 'class compatibility' stamp: 'dc 7/26/2007 16:51'!classVarNames	^#()! !!TraitBehavior methodsFor: 'class compatibility' stamp: 'dc 7/23/2007 11:13'!subclasses	^ Array new! !!TraitTest methodsFor: 'testing' stamp: 'ms 5/8/2007 19:23'!testAllClassVarNames			self assert: self t1 allClassVarNames isEmpty! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/8/1998 13:12'!open	| openCount |	openCount := 0.	self dependents do:		[:d | ((d isKindOf: PluggableTextView) or:			[d isKindOf: PluggableTextMorph]) ifTrue: [openCount := openCount + 1]].	openCount = 0		ifTrue: [self openLabel: 'Transcript']		ifFalse: [self openLabel: 'Transcript #' , (openCount+1) printString]! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/27/1998 16:36'!openAsMorphLabel: labelString 	"Build a morph viewing this transcriptStream"	| window |	window := (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: nil accept: nil			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	^ window! !!TranscriptStream methodsFor: 'initialization' stamp: 'sma 4/30/2000 10:16'!openLabel: aString 	"Open a window on this transcriptStream"	| topView codeView |	Smalltalk isMorphic ifTrue: [^ (self openAsMorphLabel: aString) openInWorld].	topView := (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView := PluggableTextView on: self text: nil accept: nil					readSelection: nil menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	topView controller open! !!TranscriptStream methodsFor: 'private' stamp: 'mir 1/11/2000 11:41'!semaphore	^AccessSema ifNil:[AccessSema := Semaphore forMutualExclusion]! !!TranscriptStream class methodsFor: 'as yet unclassified' stamp: 'di 5/8/1998 13:51'!new	^ self on: (String new: 1000)"INSTALLING:TextCollector allInstances do:	[:t | t breakDependents.	t become: TranscriptStream new].TESTING: (Execute this text in a workspace)Do this first...	tt := TranscriptStream new.	tt openLabel: 'Transcript test 1'.Then this will open a second view -- ooooh...	tt openLabel: 'Transcript test 2'.And finally make them do something...	tt clear.	[Sensor anyButtonPressed] whileFalse:		[1 to: 20 do: [:i | tt print: (2 raisedTo: i-1); cr; endEntry]]."! !!Transcripter methodsFor: 'accessing' stamp: 'di 8/14/97 12:44'!endEntry	| c d cb |	c := self contents.	Display extent ~= DisplayScreen actualScreenSize ifTrue:		["Handle case of user resizing physical window"		DisplayScreen startUp.		frame := frame intersect: Display boundingBox.		^ self clear; show: c].	para setWithText: c asText		style: TextStyle default		compositionRectangle: ((frame insetBy: 4) withHeight: 9999)		clippingRectangle: frame		foreColor: self black backColor: self white.	d := para compositionRectangle bottom - frame bottom.	d > 0 ifTrue:		["Scroll up to keep all contents visible"		cb := para characterBlockAtPoint: para compositionRectangle topLeft											+ (0@(d+para lineGrid)).		self on: (c copyFrom: cb stringIndex to: c size).		readLimit:= position:= collection size.		^ self endEntry].	para display! !!Transcripter methodsFor: 'command line' stamp: 'di 8/12/97 22:11'!confirm: queryString 	| choice |	[true]		whileTrue: 			[choice := self request: queryString , 'Please type yes or no followed by return'.			choice first asUppercase = $Y ifTrue: [^ true].			choice first asUppercase = $N ifTrue: [^ false]]! !!Transcripter methodsFor: 'command line' stamp: 'di 11/3/2000 18:52'!readEvalPrint	| line okToRevert |	okToRevert := true.	[#('quit' 'exit' 'done' ) includes: (line := self request: '>')]		whileFalse:		[line = 'revert'		ifTrue: [okToRevert			ifTrue: [Utilities revertLastMethodSubmission.					self cr; show: 'reverted: ' , Utilities mostRecentlySubmittedMessage.					okToRevert := false]			ifFalse: [self cr; show: 'Only one level of revert currently supported']]		ifFalse: [self cr; show: ([Compiler evaluate: line] ifError: [:err :ex | err])]]! !!Transcripter methodsFor: 'command line' stamp: 'sma 2/26/2000 19:39'!request: prompt	| startPos char contents | 	self cr; show: prompt.	startPos := position.	[[Sensor keyboardPressed] whileFalse.	(char := Sensor keyboard) = Character cr]		whileFalse:		[char = Character backspace			ifTrue: [readLimit := position := (position - 1 max: startPos)]			ifFalse: [self nextPut: char].		self endEntry].	contents := self contents.	^ contents copyFrom: startPos + 1 to: contents size! !!Transcripter methodsFor: 'initialization' stamp: 'di 8/14/97 12:44'!initInFrame: rect	frame := rect insetBy: 2.  "Leave room for border"	para := Paragraph withText: self contents asText				style: TextStyle default				compositionRectangle: ((frame insetBy: 4) withHeight: 9999)				clippingRectangle: frame				foreColor: self black backColor: self white! !!Transcripter class methodsFor: 'instance creation' stamp: 'di 8/14/97 12:09'!newInFrame: frame"(Transcripter newInFrame: (0@0 extent: 100@200))	nextPutAll: 'Hello there'; endEntry;	cr; print: 355.0/113; endEntry;	readEvalPrint."	| transcript |	transcript := self on: (String new: 100).	transcript initInFrame: frame.	^ transcript clear! !!Transcripter class methodsFor: 'instance creation' stamp: 'ar 11/16/1999 20:16'!startTranscriptProcess   "Transcripter startTranscriptProcess"	| activeProcess |	Transcript := self newInFrame: Display boundingBox.	activeProcess := [Transcript readEvalPrint.					Smalltalk processShutDownList: true; quitPrimitive]						newProcess					priority: Processor userSchedulingPriority.	activeProcess resume.	Processor terminateActive! !!TransformMorph methodsFor: 'geometry' stamp: 'ge 9/6/2006 17:51'!numberOfItemsPotentiallyInViewWith: submorphCount	"Answer the number of items that could potentially be viewed in full,	computed as my visible height divided by the average height of my submorphs.	Ignore visibility of submorphs."	^self innerBounds height // (self localSubmorphBounds height / submorphCount)! !!TransformationMorph methodsFor: 'accessing' stamp: 'wiz 12/7/2006 19:10'!forwardDirection	"Return the rendee's forward direction. 	If I have no rendee then return 0.0 degrees "	| rendee |	( rendee := self renderedMorph) == self  ifTrue: [ ^ 0.0 ] .		^ rendee forwardDirection! !!TransformationMorph methodsFor: 'classification' stamp: 'wiz 12/7/2006 14:05'!renderedMorph"We are a renderer. Answer appropriately."submorphs isEmpty ifTrue: [^self].	^self firstSubmorph renderedMorph! !!TransformationMorph methodsFor: 'geometry eToy' stamp: 'wiz 12/7/2006 19:10'!forwardDirection: degrees "If we have a rendee set its forward direction. Else do nothing." | rendee |( rendee := self renderedMorph) == self ifTrue: [ ^ self  ] .	^rendee forwardDirection: degrees! !!TransformationMorph methodsFor: 'geometry eToy' stamp: 'wiz 12/7/2006 16:30'!heading	"End recusion when necessary."	| rendee |	(rendee := self renderedMorph) == self ifTrue: [ ^0.0 ] .	^ rendee heading! !!TransformationMorph methodsFor: 'geometry eToy' stamp: 'wiz 4/18/2007 01:16'!heading: newHeading "If we have a rendee set its heading. Else do nothing." | rendee |( rendee := self renderedMorph) == self ifTrue: [ ^ self  ] .	^rendee heading: newHeading! !!TransformationMorph methodsFor: 'testing' stamp: 'wiz 11/24/2006 00:09'!isStickysubmorphs isEmpty ifFalse: [ ^ 	submorphs first isSticky ] .	^false! !!TypeListTile methodsFor: 'accessing' stamp: 'tak 12/6/2004 02:50'!value: anObject 	| scriptEditor |	super value: anObject.	(scriptEditor := self ownerThatIsA: ScriptEditorMorph)		ifNotNil: [scriptEditor setParameterType: anObject]! !!TypeListTile methodsFor: 'arrows' stamp: 'em 3/29/2005 15:01'!addMenuIcon	"Add a little menu icon; store it in my suffixArrow slot"	suffixArrow := ImageMorph new image: (ScriptingSystem formAtKey: #MenuTriangle).	suffixArrow setBalloonText: 'click here to choose a new type for this parameter' translated.	self addMorphBack: suffixArrow! !!TypeListTile methodsFor: 'mouse handling' stamp: 'tak 12/6/2004 02:43'!showOptions	| topScript |	suffixArrow		ifNotNil: [(suffixArrow bounds containsPoint: ActiveHand cursorPoint)				ifTrue: [^ super showOptions]].	topScript := self				outermostMorphThat: [:m | m isKindOf: ScriptEditorMorph].	topScript		ifNotNil: [topScript handUserParameterTile]! !!TypeListTile methodsFor: 'user interface' stamp: 'sw 7/19/2002 14:48'!acceptNewLiteral: aLiteral	"Accept the new literal"	| scriptEditor |	super acceptNewLiteral: aLiteral.	(scriptEditor := self ownerThatIsA: ScriptEditorMorph) ifNotNil:			[scriptEditor setParameterType: aLiteral asSymbol]! !!UAccount methodsFor: 'packages' stamp: 'ls 7/28/2004 18:03'!addPackageName: name	packageNames add: name! !!UAccount methodsFor: 'packages' stamp: 'ls 7/28/2004 18:03'!ownsPackageName: name	^packageNames includes: name! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47'!email: aString	email _ aString! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:50'!password	^password! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47'!password: anObject	password _ anObject! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:50'!username	^username! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47'!username: anObject	username _ anObject! !!UAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 18:02'!initialize	username _ 'joeblow'.	password _ ''.	packageNames _ Set new.! !!UAccount methodsFor: 'printing' stamp: 'ls 2/15/2005 23:44'!printOn: aStream	aStream nextPutAll: 'Account: ', username! !!UAccount commentStamp: '<historical>' prior: 0!An account as used in the standard UPolicy's.!!UAccountEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:52'!acceptFields	fields do: [ :f | f accept ]! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:40'!morphicView	| win column nameRow submitButton passwordRow password1Row password2Row emailRow submitButtonHolder |	window ifNotNil: [^window].	win := SystemWindow labelled: 'Account Editor'.	win model: self.	column := AlignmentMorph newColumn.	win addMorph: column frame: (0 @ 0 extent: 1 @ 1).	nameRow := UInterfaceUtilities 				makeFieldRowNamed: 'name:'				getSelector: #username				setSelector: nil				isPassword: false				for: self.	column addMorphBack: nameRow.	passwordRow := UInterfaceUtilities 				makeFieldRowNamed: 'password:'				getSelector: #password				setSelector: #password:				isPassword: true				for: self.	column addMorphBack: passwordRow.	password1Row := UInterfaceUtilities 				makeFieldRowNamed: 'new password'				getSelector: #password1				setSelector: #password1:				isPassword: true				for: self.	column addMorphBack: password1Row.	password2Row := UInterfaceUtilities 				makeFieldRowNamed: 'confirm:'				getSelector: #password2				setSelector: #password2:				isPassword: true				for: self.	column addMorphBack: password2Row.	emailRow := UInterfaceUtilities 				makeFieldRowNamed: 'email:'				getSelector: #newEmail				setSelector: #newEmail:				isPassword: false				for: self.	column addMorphBack: emailRow.	submitButtonHolder := Morph new.	"necessary to keep SystemWindow from screwing up the colors of the button"	submitButtonHolder		layoutPolicy: TableLayout new;		hResizing: #spaceFill;		borderColor: self defaultBackgroundColor.	submitButton := UInterfaceUtilities 				makeButtonWithAction: #submit				andLabel: 'Submit'				for: self.	submitButton		useSquareCorners;		borderWidth: 0.	submitButtonHolder addMorph: submitButton.	column addMorphBack: submitButtonHolder.	^window := win! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34'!noteField: field 	"note that the receiver has the specified text field"	fields ifNil: [fields := OrderedCollection new].	fields add: field! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:38'!openInMorphic	^self morphicView openInWorldExtent:  251@263! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:12'!returnTrue	^true! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:52'!submit	self acceptFields.	newPassword = newPassword2 ifFalse: [		^self inform: 'new passwords do not match!!' ].	whenDone value: password value: newPassword value: newEmail	! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:52'!newEmail	^newEmail! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:53'!newEmail: anObject	newEmail _ anObject! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:50'!password	^password! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password1	^newPassword! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password1: aString	newPassword _ aString asString.	self changed: #password1.	^true! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password2	^newPassword2! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password2: aString	newPassword2 _ aString asString.	self changed: #password2.	^true! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 2/13/2005 16:50'!password: aString	password _ aString.	self changed: #password! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:50'!username	^username! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 18:01'!window	^window! !!UAccountEditor methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 17:40'!username: username0  password: password0  email: email0  whenDone: aBlock	username _ username0.	password _ password0.	newPassword _ ''.	newPassword2 _ ''.	newEmail _ email0.	whenDone _ aBlock.! !!UAccountEditor commentStamp: '<historical>' prior: 0!A tool for editing an account!!UAccountEditor class methodsFor: 'class initialization' stamp: 'ls 2/13/2005 16:58'!initialize	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UAccountEditor class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:41'!username: username0  password: password0  email: email0  whenDone: aBlock	^self basicNew		username: username0  password: password0  email: email0  whenDone: aBlock;		yourself! !!UCompoundUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 14:56'!components: anObject	components _ anObject.	components do: [ :c | c addDependent:  self ].! !!UCompoundUniverse methodsFor: 'accessing' stamp: 'ls 7/29/2004 18:50'!standardUniverses	^Array streamContents: [ :str |		components do: [ :comp |			str nextPutAll: comp standardUniverses  ] ]! !!UCompoundUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:09'!packages	^Array streamContents: [ :pstr |		components do: [ :univ |			pstr nextPutAll: univ packages ] ]! !!UCompoundUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 14:58'!updatePackagesViaWWW	components do: [ :component | component updatePackagesViaWWW ]! !!UCompoundUniverse methodsFor: 'updating' stamp: 'ls 2/13/2005 14:57'!update: aSymbol	aSymbol = #packages ifTrue: [ self changed: #packages ].! !!UCompoundUniverse commentStamp: 'ls 7/29/2004 18:48' prior: 0!A universe that is the union of other universes.!!UCompoundUniverse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:47'!composedOf: universes	^self new		components: universes;		yourself! !!UConfiguration methodsFor: 'packages' stamp: 'ls 7/28/2004 10:19'!includesPackageNamed: name	^self installedPackages anySatisfy: [ :p | p name = name ]! !!UConfiguration methodsFor: 'packages' stamp: 'ls 8/26/2007 12:25'!includesPackageSpec: packageSpec	^self installedPackages anySatisfy: [ :p | p packageSpec = packageSpec ]! !!UConfiguration methodsFor: 'packages' stamp: 'ls 7/27/2004 22:02'!installedPackages	^installedPackages! !!UConfiguration methodsFor: 'packages' stamp: 'ls 7/28/2004 10:18'!packageNamed: name	^self installedPackages detect: [ :p | p name = name ]! !!UConfiguration methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:55'!initialize	installedPackages _ Set new.! !!UConfiguration methodsFor: 'installing' stamp: 'ls 7/27/2004 21:55'!installPackage: aPackage	| matchingPackages |	matchingPackages _ installedPackages select: [ :p | p name = aPackage name ].	installedPackages removeAll: matchingPackages.	aPackage install.	installedPackages add: aPackage.	! !!UConfiguration commentStamp: '<historical>' prior: 0!One configuration of packages.!!UConfiguration class methodsFor: 'system' stamp: 'ls 7/27/2004 21:57'!forSystem	"return a configuration describing the currently running system"	^SystemConfiguration ifNil: [ SystemConfiguration _ self new ].	! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/19/2007 14:30'!allCategories	^ (universe packages collect: [:package | package category])			asSet			asSortedCollection: [:cat1 :cat2 | cat1 asString < cat2 asString]! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/19/2007 14:38'!allPackages	^ universe packageNames asSortedCollection.! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/22/2007 12:27'!allPossibleUpgrades	^ universe packageNames		inject: OrderedCollection new		into: [ :upgrades :name |			(configuration includesPackageNamed: name)			ifTrue: [| cpack mypack |				cpack := configuration packageNamed: name.				mypack := universe newestPackageNamed: name.				(mypack version > cpack version)					ifTrue: [upgrades add: mypack]].								upgrades].! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/19/2007 14:39'!installedPackageVersions	^ configuration installedPackages 		asSortedCollection: [:p1 :p2 | p1 name < p2 name].! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/19/2007 14:36'!packageVersionsForPackage: aPackageName	^ (universe packages		select: [:package | package name = aPackageName])		asSortedCollection: [:p1 :p2 | p1 version < p2 version].	! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/19/2007 14:37'!packagesForCategory: aCategory	^ (universe packages		select: [:package | package category = aCategory]		thenCollect: [:package | package name])		asSortedCollection ! !!UGlobalInstaller methodsFor: 'private - package selection' stamp: 'dc 4/21/2007 12:25'!allPackagesNeededToInstall: initialPackage  orIfImpossible: errorBlock	"find all packages needed to installed initialPackage; if it is impossible to accomplish, invoke errorBlock with the name of the missing package"	| newPackages packagesToConsider |	newPackages := Set new.	packagesToConsider := OrderedCollection with: initialPackage.	[ packagesToConsider isEmpty ]		whileFalse: [| package |			package := packagesToConsider removeFirst.			(newPackages includes: package) ifFalse: [			newPackages add: package.			package depends do: [ :depName |				((configuration includesPackageNamed: depName) not and: [ selectedPackageVersions noneSatisfy: [ :p | p name = depName  ] ])				ifTrue: [					"the dependency is needed but is not installed or planned to be installed"					(universe hasPackageNamed: depName) ifTrue: [						"in principle, one could additionally consider trying a different package than the newest..."						packagesToConsider add: (universe newestPackageNamed: depName) ]					ifFalse: [						^errorBlock value: depName ] ] ] ] ].		^newPackages! !!UGlobalInstaller methodsFor: 'private - package selection' stamp: 'dc 4/21/2007 13:13'!orderPackagesByDependency: packages	"return a collection of the specified packages such that, when possible, any dependencies of a package are ordered before that package"	"The present algorithm is simple but slow..."	| remainingPackages orderedPackages packagesToAdd |	remainingPackages := Set new.	orderedPackages := OrderedCollection new.	remainingPackages addAll: packages.		"each time through this loop, add to orderedPackages any packages whose dependencies are not in remainaingPackages"	[	packagesToAdd := remainingPackages select: [ :p | p depends noneSatisfy: [ :depName | remainingPackages anySatisfy: [ :p2 | p2 name = depName ] ] ].		packagesToAdd isEmpty not	] whileTrue: [		orderedPackages addAll: packagesToAdd.		remainingPackages := remainingPackages difference: packagesToAdd ].		orderedPackages addAll: remainingPackages.	^ orderedPackages! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 4/21/2007 12:43'!anyPackageSelected	^ selectedPackageVersions notEmpty! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 4/22/2007 12:23'!containsAnyUpgrade	^ self allPossibleUpgrades notEmpty ! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 4/19/2007 17:30'!isPackageInstalled: aPackage	^ self installedPackageVersions anySatisfy: [:packageVersion | packageVersion name =  aPackage]! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 4/19/2007 17:05'!isPackageSelected: aPackageName	^ self selectedPackageVersions		anySatisfy: [:packageVersion | packageVersion name = aPackageName ]! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 4/19/2007 17:29'!isPackageVersionInstalled: aPackageVersion	^ self installedPackageVersions includes: aPackageVersion! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 5/28/2007 11:27'!isPackageVersionSelected: aPackageVersion	^ selectedPackageVersions includes: aPackageVersion! !!UGlobalInstaller methodsFor: 'private' stamp: 'dc 4/19/2007 14:13'!configuration: aConfiguration 	configuration := aConfiguration! !!UGlobalInstaller methodsFor: 'private' stamp: 'dc 4/19/2007 14:13'!universe: aUniverse 	universe := aUniverse! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/22/2007 12:51'!deselectPackageNamed: aPackageName	self selectedPackageVersions 		removeAllSuchThat: [:package | package name = aPackageName ]! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/22/2007 12:47'!deselectPackageVersion: aPackageVersion	self selectedPackageVersions 		remove: aPackageVersion  ifAbsent: nil! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/21/2007 13:15'!doInstall	| orderedPackages |	self anyPackageSelected not ifTrue: [^self].	orderedPackages := self orderPackagesByDependency: selectedPackageVersions.	orderedPackages		do: [ :p | 				Utilities informUser: 'installing ', p printString						during: [configuration installPackage: p] ].	self initializeSelectedPackageVersions.! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/21/2007 12:20'!planToInstallPackage: initialPackage	"plan to install a package plus its dependencies; refuses if any dependencies cannot be met"	| newPackages |	"find all packages needed to install this one"	newPackages := self allPackagesNeededToInstall: initialPackage						orIfImpossible: [ :missingDep |								^self notify: 'could not find necessary package: ', missingDep ].		selectedPackageVersions removeAllSuchThat: [ :p | p name = initialPackage name ].	newPackages do: [ :p | selectedPackageVersions add: p ].! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/22/2007 12:54'!planToInstallPackageNamed: aPackageName	self planToInstallPackage: (universe newestPackageNamed: aPackageName)! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/21/2007 15:01'!requestPackageList	Utilities informUser: 'updating package list...' during:  [		universe updatePackagesViaWWW ]! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/22/2007 12:27'!selectAllUpgrades	"select packages that appear to be upgrades of packages that are already installed"	self allPossibleUpgrades 		do: [:package | self planToInstallPackage: package]! !!UGlobalInstaller methodsFor: 'initialize-release' stamp: 'dc 4/21/2007 13:12'!initialize	super initialize.	self initializeSelectedPackageVersions! !!UGlobalInstaller methodsFor: 'initialize-release' stamp: 'dc 4/21/2007 13:12'!initializeSelectedPackageVersions	selectedPackageVersions := Set new! !!UGlobalInstaller methodsFor: 'accessing' stamp: 'dc 4/21/2007 12:41'!selectedPackageVersions	^ selectedPackageVersions! !!UGlobalInstaller methodsFor: 'accessing' stamp: 'ls 6/3/2007 10:34'!universe	^universe! !!UGlobalInstaller commentStamp: 'dc 7/24/2007 11:43' prior: 0!I'm used by universe browsers to keep track of the configuration, the universe, the selected packages... I provide features to install new packages, to upgrade the system...!!UGlobalInstaller class methodsFor: 'instance-creation' stamp: 'dc 4/19/2007 14:11'!universe: aUniverse	^ self universe: aUniverse configuration: UConfiguration forSystem ! !!UGlobalInstaller class methodsFor: 'instance-creation' stamp: 'dc 4/19/2007 14:12'!universe: aUniverse configuration: aConfiguration	^ self new		universe: aUniverse;		configuration: aConfiguration;		yourself! !!UGlobalInstallerTest methodsFor: 'Running' stamp: 'ls 1/16/2005 14:11'!setUp	| package |	universe _ UStandardUniverse new.		package _ UPackage new.	package name: 'A'.	package addDependency: 'B'.	universe addPackage: package.		package _ UPackage new.	package name: 'B'.	package addDependency: 'C'.	universe addPackage: package.		package _ UPackage new.	package name: 'C'.	package addDependency: 'D'.	package addDependency: 'E'.	universe addPackage: package.		package _ UPackage new.	package name: 'D'.	universe addPackage: package.		package _ UPackage new.	package name: 'E'.	universe addPackage: package.	package _ UPackage new.	package name: 'Broken'.	package addDependency: 'NonExistent'.	universe addPackage: package.	! !!UGlobalInstallerTest methodsFor: 'Running' stamp: 'ls 8/14/2007 21:41'!testBasicDependency	| installer neededPackages |	installer := UGlobalInstaller universe: universe.	neededPackages := installer 				allPackagesNeededToInstall: (universe newestPackageNamed: 'A')				orIfImpossible: [:ign | self error: 'dependency not found'].	self should: [neededPackages size = 5].			installer := UGlobalInstaller universe: universe.	neededPackages := installer 				allPackagesNeededToInstall: (universe newestPackageNamed: 'B')				orIfImpossible: [:ign | self error: 'dependency not found'].	self should: [neededPackages size = 4]! !!UGlobalInstallerTest methodsFor: 'Running' stamp: 'ls 8/14/2007 21:42'!testBrokenDependency	| installer neededPackages |	installer := UGlobalInstaller universe: universe.	neededPackages _ installer allPackagesNeededToInstall: (universe newestPackageNamed: 'Broken')  orIfImpossible: [ :ign | nil ].	self should: [ neededPackages isNil ].	! !!UIFileOut methodsFor: 'testing' stamp: 'ls 9/4/2004 14:02'!handlesFilename: filename	^#('.cs' '.st' '.st.gz' '.cs.gz') anySatisfy: [ :ending | filename endsWith: ending ]! !!UIFileOut methodsFor: 'installing' stamp: 'ls 7/29/2004 20:01'!install: inStream  usingBaseName: basename	"find a changeset name that is not used"	| num changesetName stream |	num _ 0.	[  	changesetName _ basename.	   	num > 0 ifTrue:[ changesetName _ changesetName, '-', num printString. ].		(ChangeSorter changeSetNamed: changesetName) notNil ]	whileTrue: [ num _ num + 1 ].		"decompress if necessary"	inStream peek asInteger = 16r1F		ifTrue: [ stream _ ReadStream on: ((GZipReadStream on: inStream) upToEnd) asString ]		ifFalse: [ stream _ inStream ].			ChangeSorter newChangesFromStream: stream named: changesetName! !!UIMonticello methodsFor: 'testing' stamp: 'ls 8/19/2007 12:45'!handlesFileEnding: ending	ending = 'mcz' ifTrue: [ ^true ].	(ending = 'mcm' and: [ self isMCMReaderAvailable ]) ifTrue: [ ^true ].	^false! !!UIMonticello methodsFor: 'testing' stamp: 'ls 8/19/2007 12:44'!isMCMReaderAvailable	^ Smalltalk includesKey: self mcmReaderClassName! !!UIMonticello methodsFor: 'testing' stamp: 'ls 8/19/2007 12:44'!mcmReaderClassName	^ #MCMcmReader! !!UIMonticello methodsFor: 'installing' stamp: 'ls 8/19/2007 12:47'!installFileNamed: filename 	(filename asLowercase endsWith: '.mcm') 		ifTrue: [^ self mcmReader loadVersionFile: filename].	Smalltalk at: #MCMczReader		ifPresent: [:reader | ^ reader loadVersionFile: filename].	MczInstaller installFileNamed: filename! !!UIMonticello methodsFor: 'installing' stamp: 'ls 8/19/2007 12:46'!mcmReader	^ Smalltalk at: self mcmReaderClassName! !!UIMpeg methodsFor: 'testing' stamp: 'ls 7/29/2004 11:04'!handlesFileEnding: ending	^#('mpg' 'mpeg') includes: ending! !!UIMpeg methodsFor: 'installing' stamp: 'ls 7/29/2004 11:39'!install: stream usingBasename: basename	| movieDir movieFile |	movieDir := FileDirectory default directoryNamed: 'movies'.	movieDir assureExistence.		movieDir removeFileNamed: basename.		movieFile _ movieDir newFileNamed: basename, '.mpeg'.	stream binary.  movieFile binary.	movieFile nextPutAll: stream upToEnd.	movieFile close.		Smalltalk at: #MPEGMoviePlayerMorph ifPresent: [ :player |		player playFile: (movieDir fullNameFor: basename, '.mpeg') ]! !!UIProject methodsFor: 'testing' stamp: 'ls 7/29/2004 11:05'!handlesFileEnding: ending	^#('pr') includes: ending! !!UIProject methodsFor: 'installing' stamp: 'ls 9/18/2004 18:18'!installFileNamed: filename	FileDirectory splitName: filename to: [ :path :base |		[ 				ProjectViewMorph openFromDirectory: (FileDirectory on: path) andFileName: base		] on: ProjectEntryNotification do:		[ :ex |			"don't enter it" ] ]! !!UISar methodsFor: 'testing' stamp: 'ls 7/29/2004 11:04'!handlesFileEnding: ending	^#('sar') includes: ending! !!UISar methodsFor: 'installing' stamp: 'ls 7/29/2004 11:44'!installFileNamed: filename	SARInstaller installSAR: filename! !!UInterfaceUtilities commentStamp: 'ls 2/13/2005 17:22' prior: 0!This class holds miscellaneous bits of code used to build user interfaces in the various Universes tools.!!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:37'!makeButtonWithAction: selector andGetState: getStateSelector andLabel: aString for: model	^(PluggableButtonMorph on: model getState: getStateSelector action: selector)		label: aString;		useRoundedCorners;		vResizing: #spaceFill;		hResizing: #spaceFill;		onColor: model defaultBackgroundColor offColor: model defaultBackgroundColor muchLighter;		yourself! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:41'!makeButtonWithAction: selector  andLabel: aString for: model	^self makeButtonWithAction: selector andGetState: #returnTrue  andLabel: aString	for: model! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:34'!makeFieldGet: getSelector  set: setSelector  for: model	| field fieldHeight |	fieldHeight _ TextStyle default defaultFont pointSize + 8.					field := PluggableTextMorph on: model text: getSelector accept: setSelector.	field height: fieldHeight.	field hResizing: #spaceFill.	field hideScrollBarsIndefinitely.	field setProperty: #alwaysAccept toValue: true.	model noteField: field.	^field! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:42'!makeFieldRowNamed: fieldName  getSelector: getSelector setSelector: setSelector for: model	^self makeFieldRowNamed: fieldName  getSelector: getSelector setSelector: setSelector isPassword: false for: model! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:36'!makeFieldRowNamed: fieldName  getSelector: getSelector setSelector: setSelector isPassword: isPassword for: model	| row field |	row _ AlignmentMorph newRow.	row color: Color transparent.	row cellInset: 3@0.		field _ self makeFieldGet: getSelector set: setSelector for: model.	isPassword ifTrue:[		field font: (StrikeFont passwordFontSize: TextStyle default defaultFont pointSize) ].	row addMorph: (StringMorph contents: fieldName).	row addMorphBack: field.	^row! !!UMAddAccount methodsFor: '*universes-server' stamp: 'ls 7/28/2004 21:46'!applyToServer: server forConnection: connection	server connection: connection requestedAccountWithUsername: username password: password email: email! !!UMAddAccount methodsFor: 'converting' stamp: 'ls 7/28/2004 14:34'!asStringArray	^{'addaccount' . username . password . email}! !!UMAddAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:33'!username: username0  password: password0  email: email0	username _ username0.	password _ password0.	email _ email0.	! !!UMAddAccount methodsFor: 'logging' stamp: 'ls 5/28/2007 17:24'!maybeLogMessage	"Return a string for logging this message, if there is one"	^'AddAccount ', username, ' ', email! !!UMAddAccount commentStamp: '<historical>' prior: 0!A request to add a user account.!!UMAddAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:34'!fromStringArray: stringArray	^self username: stringArray second password: stringArray third email: stringArray fourth! !!UMAddAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:34'!username: username  password: password  email: email	^self basicNew username: username  password: password  email: email! !!UMAddPackage methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:03'!applyToServer: server forConnection: connection	server connection: connection requestedForUsername: username andPassword: password toAddPackage: package! !!UMAddPackage methodsFor: 'converting' stamp: 'ls 7/28/2004 16:56'!asStringArray	^{'addpackage' . username . password },	  package stringArrayEncoding! !!UMAddPackage methodsFor: 'printing' stamp: 'ls 1/13/2007 21:24'!printOn: aStream	aStream 		print: self class;		nextPutAll: ' (';		print: package;		nextPutAll: ')'! !!UMAddPackage methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:37'!username: username0 password: password0 package: package0	username _ username0.	password _ password0.	package _ package0.	! !!UMAddPackage methodsFor: 'logging' stamp: 'ls 5/28/2007 17:43'!maybeLogMessage	"Return a string for logging this message, if there is one"	^'AddPackage ', username, ' ', package name, '/', package version printString! !!UMAddPackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:07'!fromStringArray: array	^self username: array second password: array third package: (UPackage decodeFromStringStream: (ReadStream on: (array allButFirst: 3)))! !!UMAddPackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:37'!username: username password: password package: package	^self basicNew username: username password: password package: package! !!UMConnectionFailed commentStamp: '<historical>' prior: 0!An error in establishing a connection to a server.!!UMEditAccount methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:55'!applyToServer: server forConnection: connection	server connection: connection requestedAccountChangeForUsername: username password: password newPassword: newPassword newEmail: newEmail! !!UMEditAccount methodsFor: 'converting' stamp: 'ls 7/28/2004 14:36'!asStringArray	^{'editaccount' . username . password . newPassword . newEmail}! !!UMEditAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:36'!username: username0  password: password0  newPassword: newPassword0 newEmail: newEmail0	username _ username0.	password _ password0.	newPassword _ newPassword0.	newEmail _ newEmail0.	! !!UMEditAccount commentStamp: '<historical>' prior: 0!A request to change the password or email of an account.!!UMEditAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:38'!fromStringArray: array	^self username: array second password: array third newPassword: array fourth newEmail: array fifth! !!UMEditAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:36'!username: username  password: password  newPassword: newPassword newEmail: newEmail	^self basicNew username: username  password: password  newPassword: newPassword newEmail: newEmail! !!UMEditedAccount methodsFor: '*universes-editor' stamp: 'ls 7/28/2004 17:59'!applyToEditor: editor	editor accountUpdatedWithUsername: username  password:  newPassword  email: newEmail! !!UMEditedAccount methodsFor: 'converting' stamp: 'ls 7/28/2004 17:37'!asStringArray	^{'editedaccount' . username . newPassword . newEmail }! !!UMEditedAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 17:36'!username: username0  newPassword: newPassword0  newEmail: newEmail0	username _ username0.	newPassword _ newPassword0.	newEmail _ newEmail0.	! !!UMEditedAccount commentStamp: '<historical>' prior: 0!Notification that an account has been successfully edited.!!UMEditedAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:38'!fromStringArray: array	^self username: array second newPassword: array third newEmail: array fourth! !!UMEditedAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:37'!username: username  newPassword: newPassword  newEmail: newEmail	^self basicNew		username: username  newPassword: newPassword  newEmail: newEmail;		yourself! !!UMError methodsFor: '*universes-editor' stamp: 'ls 7/28/2004 21:58'!applyToEditor: editor	"the inform: is deferred, because otherwise the editor can stop stepping!!"	WorldState addDeferredUIMessage: [ editor inform: 'Error: ', description ]! !!UMError methodsFor: '*universes-server' stamp: 'ls 7/28/2004 13:35'!applyToServer: server forConnection: connection	"if the client sends an error back, then the connection is really messed up"	server destroyConnection: connection	! !!UMError methodsFor: 'converting' stamp: 'ls 7/28/2004 13:36'!asStringArray	^{'error' . description }! !!UMError methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 13:26'!description: aString	description := aString! !!UMError commentStamp: '<historical>' prior: 0!An error message from the server to the client.!!UMError class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 13:33'!description: aString	^self basicNew		description: aString;		yourself! !!UMError class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:02'!fromStringArray: array	^self description: array second! !!UMMalformed methodsFor: 'converting' stamp: 'ls 7/28/2004 11:31'!asStringArray	^self error: 'a malformed packet cannot be converted to a string array'! !!UMMalformed methodsFor: 'accessing' stamp: 'ls 7/28/2004 11:45'!stringArray: anObject	stringArray _ anObject! !!UMMalformed commentStamp: '<historical>' prior: 0!a malformed packet!!UMMalformed class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 11:30'!fromStringArray: array	^self basicNew stringArray: array; yourself! !!UMPackageAdded methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:01'!applyToClient: aClient	aClient packageAdded: package! !!UMPackageAdded methodsFor: '*universes-editor' stamp: 'ls 7/30/2004 15:38'!applyToEditor: editor	editor closeEditorForPackage: package.! !!UMPackageAdded methodsFor: 'converting' stamp: 'ls 7/28/2004 15:07'!asStringArray	^#('packageadded'), package stringArrayEncoding! !!UMPackageAdded methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:59'!package: aPackage	package _ aPackage! !!UMPackageAdded commentStamp: 'ls 7/28/2004 15:08' prior: 0!A message declaring that a package has been added to the universe.!!UMPackageAdded class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:07'!fromStringArray: array	| str |	str _ ReadStream on: array.	str next.	^self package: (UPackage decodeFromStringStream: str)! !!UMPackageAdded class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:07'!package: aPackage	^self basicNew		package: aPackage;		yourself! !!UMPackageList methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:01'!applyToClient: aClient	aClient newPackageList: packages! !!UMPackageList methodsFor: 'converting' stamp: 'ls 7/28/2004 15:04'!asStringArray	^Array streamContents: [ :str |		str nextPut: 'packages'.		str nextPut: packages size printString.		packages do: [ :pack |			str nextPutAll: pack stringArrayEncoding ]. ].! !!UMPackageList methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 12:01'!packages: aCollection	packages _ aCollection! !!UMPackageList commentStamp: '<historical>' prior: 0!A message describing a list of packages that are in the server's universe.!!UMPackageList class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:05'!fromStringArray: array	| str packages numPackages |	str _ ReadStream on: array.	str next.  "skip the 'packages' designation".	packages _ OrderedCollection new.	numPackages _ Integer readFromString: str next.	numPackages timesRepeat: [		packages add: (UPackage decodeFromStringStream: str) ].			^self packages: packages! !!UMPackageList class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 12:01'!packages: aCollection	^self basicNew		packages: aCollection;		yourself! !!UMPackageRemoved methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:02'!applyToClient: aClient	aClient removedPackageNamed: packageName  withVersion: version! !!UMPackageRemoved methodsFor: 'converting' stamp: 'ls 7/28/2004 14:57'!asStringArray	^{'packageremoved' . packageName . version printString }! !!UMPackageRemoved methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:57'!packageName: aString  version: aVersion	packageName _ aString.	version _ aVersion.! !!UMPackageRemoved commentStamp: '<historical>' prior: 0!A message claiming that a package has been removed.!!UMPackageRemoved class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:58'!fromStringArray: array	^self packageName: array second version: (UVersion readFromString: array third)! !!UMPackageRemoved class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:58'!packageName: aString version: aVersion	^self basicNew		packageName: aString version: aVersion;		yourself! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:41'!applyToClient: client! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:42'!applyToEditor: editor! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:42'!applyToMultiServer: server forConnection: connection! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:41'!applyToServer: server forConnection: connection! !!UMProtocolVersion methodsFor: 'converting' stamp: 'ls 2/15/2005 21:41'!asStringArray	^{'protocolversion' . version asString}! !!UMProtocolVersion methodsFor: 'attributes' stamp: 'ls 2/15/2005 21:40'!version	^version! !!UMProtocolVersion methodsFor: 'initialize-release' stamp: 'ls 2/15/2005 21:39'!version: anInteger	version _ anInteger! !!UMProtocolVersion commentStamp: '<historical>' prior: 0!Tell the receiver what protocol version the sender understands.  The receiver should not send messages back which use a newer protocol version.!!UMProtocolVersion class methodsFor: 'instance creation' stamp: 'ls 2/15/2005 21:40'!fromStringArray: array	^self version: (Integer readFromString: array second)! !!UMProtocolVersion class methodsFor: 'instance creation' stamp: 'ls 2/15/2005 21:40'!version: anInteger	^self new version: anInteger; yourself! !!UMRemovePackage methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:20'!applyToServer: server forConnection: connection	server connection: connection requestedForUsername: username andPassword: password toRemovePackageNamed: packageName withVersion: packageVersion! !!UMRemovePackage methodsFor: 'converting' stamp: 'ls 7/29/2004 15:46'!asStringArray	^{'removepackage' . username . password . packageName . packageVersion printString }! !!UMRemovePackage methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:39'!username: username0 password: password0 packageName: packageName0 packageVersion: packageVersion0	username _ username0.	password _ password0.	packageName _ packageName0.	packageVersion _ packageVersion0.	! !!UMRemovePackage methodsFor: 'logging' stamp: 'ls 5/28/2007 17:43'!maybeLogMessage	"Return a string for logging this message, if there is one"	^'RemovePackage ', username, ' ', packageName, '/', packageVersion printString! !!UMRemovePackage commentStamp: '<historical>' prior: 0!A request to remove a package from a universe.!!UMRemovePackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:26'!fromStringArray: array	^self username: array second password: array third packageName: array fourth packageVersion: (UVersion readFromString: array fifth)! !!UMRemovePackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:41'!username: username password: password packageName: packageName packageVersion: packageVersion	^self basicNew username: username password: password packageName: packageName packageVersion: packageVersion! !!UMRequestPackages methodsFor: '*universes-server' stamp: 'ls 7/28/2004 13:08'!applyToServer: server forConnection: connection	connection nextPut: (UMPackageList packages: server universe packages) asStringArray! !!UMRequestPackages methodsFor: 'converting' stamp: 'ls 7/28/2004 11:59'!asStringArray	^#('requestpackages')! !!UMRequestPackages commentStamp: '<historical>' prior: 0!A package requesting that a copy of all packages in the server's universe.!!UMRequestPackages class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 11:59'!fromStringArray: array	^self basicNew! !!UMSelectServer methodsFor: '*universes-server' stamp: 'ls 2/13/2005 16:18'!applyToMultiServer: server forConnection: connection	server switchConnection: connection toServerNamed: shortName! !!UMSelectServer methodsFor: '*universes-server' stamp: 'ls 8/26/2007 12:05'!applyToServer: server forConnection: connection	"do nothing"! !!UMSelectServer methodsFor: 'converting' stamp: 'ls 2/13/2005 16:06'!asStringArray	^{'selectserver' . shortName}! !!UMSelectServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 16:12'!shortName: aString	shortName _ aString! !!UMSelectServer commentStamp: 'ls 2/13/2005 16:05' prior: 0!A request to a multi-server, to select the server for a specific universe.  Subsequent messages should be directed to the selected universe instead of to the specific universes.!!UMSelectServer class methodsFor: 'instance creation' stamp: 'ls 2/13/2005 16:06'!fromStringArray: stringArray	^self shortName: stringArray second! !!UMSelectServer class methodsFor: 'instance creation' stamp: 'ls 2/13/2005 16:06'!shortName: aString	^self new		shortName: aString;		yourself! !!UMessage methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:00'!applyToClient: aClient	"apply this message to a UUniverseClient"	! !!UMessage methodsFor: '*universes-editor' stamp: 'ls 7/28/2004 15:40'!applyToEditor: editor	! !!UMessage methodsFor: '*universes-server' stamp: 'ls 2/13/2005 16:18'!applyToMultiServer: server  forConnection: connection	connection nextPut: (UMError description: 'message inappropriate for multi-server') asStringArray! !!UMessage methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:25'!applyToServer: server  forConnection: connectionself inspect.	connection nextPut: (UMError description: 'message inappropriate for server') asStringArray! !!UMessage methodsFor: 'converting' stamp: 'ls 7/28/2004 11:30'!asStringArray	^self subclassResponsibility! !!UMessage methodsFor: 'logging' stamp: 'ls 5/28/2007 17:22'!maybeLogMessage	"Return a string for logging this message, if there is one"	^nil! !!UMessage commentStamp: '<historical>' prior: 0!A message that can be sent to or from a UServer.  All instances may be converted to an array of strings, and that array of strings may be parsed back with fromStringArray:.!!UMessage class methodsFor: 'instance creation' stamp: 'ls 2/15/2005 21:41'!fromStringArray: array	| class |	class _ nil.	array first = 'requestpackages' ifTrue: [ class _ UMRequestPackages ].	array first = 'packages' ifTrue: [ class _ UMPackageList ].	array first = 'error' ifTrue: [ class _ UMError ].	array first = 'addaccount' ifTrue: [ class _ UMAddAccount ].	array first = 'addpackage' ifTrue: [ class _ UMAddPackage ].	array first = 'editaccount' ifTrue: [ class _ UMEditAccount ].	array first = 'editedaccount' ifTrue: [ class _ UMEditedAccount ].	array first = 'packageadded' ifTrue: [ class _ UMPackageAdded ].	array first = 'packageremoved' ifTrue: [ class _ UMPackageRemoved ].	array first = 'removepackage' ifTrue: [ class _ UMRemovePackage ].	array first = 'selectserver' ifTrue: [ class _ UMSelectServer ].	array first = 'protocolversion' ifTrue: [ class _ UMProtocolVersion ].	class ifNil: [			^UMMalformed fromStringArray: array ].		^[ class fromStringArray: array ] on: Error do: [ :ex | UMMalformed fromStringArray: array ]! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:33'!destroy	hasBeenWritten _ true! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:34'!isConnected	^hasBeenWritten not! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:32'!nextOrNil	hasBeenRead ifTrue:[ ^nil ].	hasBeenRead _ true.	^inputMessage! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:53'!nextPut: anObject	outputQueue nextPut: anObject.	hasBeenWritten _ true! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:32'!processIO! !!UOneShotConnection methodsFor: 'initialize-release' stamp: 'ls 8/2/2004 16:33'!initializeWithInMessage: inMessage0  andOutQueue: aSharedQueue	inputMessage _ inMessage0.	outputQueue _ aSharedQueue.	hasBeenRead _ false.	hasBeenWritten _ false.! !!UOneShotConnection commentStamp: '<historical>' prior: 0!A fake StringSocket used to integrate a UUniverseServer with an HTTP server.A OneShotConnection has exactly one input message and only accepts one output message.  It puts the supplied output message onto a SharedQueue and then disconnects itself.!!UOneShotConnection class methodsFor: 'instance creation' stamp: 'ls 8/2/2004 16:31'!withInMessage: inMessage0  andOutQueue: aSharedQueue	^self basicNew		initializeWithInMessage: inMessage0  andOutQueue: aSharedQueue;		yourself! !!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 17:59'!addUser: user withPassword: password andEmail: email	^UPolicyResponse denied! !!UPStable methodsFor: 'policies' stamp: 'ls 3/11/2007 00:04'!changeUser: user withPassword: password toHavePassword: newPassword andNewEmail: newEmail	"the changes must be made on the server, not over the standard protocol"	^UPolicyResponse denied! !!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 18:00'!package: package mayBeAddedBy: user withPassword: password	^(user = masterUser and: [ password = masterPassword ])		ifTrue: [ UPolicyResponse allowed ]		ifFalse: [ UPolicyResponse denied ]! !!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 18:00'!packageNamed: packageName  withVersion: version  mayBeRemovedBy: user  withPassword: password	(user = masterUser and: [ password = masterPassword ])		ifTrue: [ ^UPolicyResponse allowed ]		ifFalse: [ ^UPolicyResponse denied ]! !!UPStable methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 22:08'!masterPassword: password	masterPassword _ password! !!UPStable methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 22:08'!masterUser: userName	masterUser _ userName! !!UPStable commentStamp: '<historical>' prior: 0!A policy somewhat suitable for stable versions.  All updates must come through a single master userid and password.!!UPWild methodsFor: 'policies' stamp: 'ls 5/13/2007 10:04'!addUser: username withPassword: password  andEmail: email	| newAccount |	(accounts anySatisfy: [ :acc | acc username = username]) ifTrue: [		"already an account here"		^UPolicyResponse denied: 'account already exists' ].	superUser ifNotNil: [		superUser username = username ifTrue: [			"cannot create an account with the superuser's name"			^UPolicyResponse denied: 'same account name as the superuser' ] ].			(self class isReasonableUsername: username) ifFalse: [		^UPolicyResponse denied: 'invalid account name' ].		newAccount _ UAccount new.	newAccount username: username.	newAccount password: password.	newAccount email: email.		accounts add: newAccount.	^UPolicyResponse allowed! !!UPWild methodsFor: 'policies' stamp: 'ls 2/13/2005 16:38'!changeUser: username withPassword: password toHavePassword: newPassword andNewEmail: newEmail	| account |	account _ self findAccount: username withPassword: password.	account ifNil: [ ^UPolicyResponse denied: 'username not present or password does not match' ].		newPassword isEmpty ifFalse: [account password: newPassword ].	newEmail isEmpty ifFalse: [account email: newEmail ].	^UPolicyResponse allowed! !!UPWild methodsFor: 'policies' stamp: 'ls 7/28/2004 21:34'!package: aPackage  mayBeAddedBy: username  withPassword: password	^self tryToGivePackageName: aPackage name toUsername: username withPassword: password! !!UPWild methodsFor: 'policies' stamp: 'ls 7/28/2004 18:15'!packageNamed: packageName withVersion: version mayBeRemovedBy: username withPassword: password	^self tryToGivePackageName: packageName toUsername: username withPassword: password! !!UPWild methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 21:35'!initialize	accounts _ OrderedCollection new! !!UPWild methodsFor: 'initialize-release' stamp: 'ls 4/14/2007 18:39'!superUser: anAccount	superUser ifNotNil: [		accounts remove: superUser ].	superUser := anAccount.	accounts add: superUser.	! !!UPWild methodsFor: 'account assignment' stamp: 'ls 7/28/2004 18:14'!findAccount: username withPassword: password	| account |	account _ accounts detect: [ :acc | acc username = username] ifNone: [		"no such account"		^nil ].		account password = password ifFalse:[		"wrong password"		^nil ].		^account! !!UPWild methodsFor: 'account assignment' stamp: 'ls 4/14/2007 18:40'!tryToGivePackageName: packageName toUsername: username  withPassword: password	| account |	(self class isReasonablePackageName: packageName) ifFalse: [		^UPolicyResponse denied: 'invalid package name' ].		account _ self findAccount: username withPassword: password.	account ifNil: [ ^UPolicyResponse denied: 'incorrect password or no such user' ].	account == superUser ifTrue: [		^UPolicyResponse allowed ].	(account ownsPackageName: packageName) ifTrue: [		^UPolicyResponse allowed ].		(accounts anySatisfy: [ :acc | acc ownsPackageName: packageName ]) ifTrue: [		^UPolicyResponse denied: 'package is owned by another' ].		account addPackageName: packageName.	^UPolicyResponse allowed! !!UPWild commentStamp: 'ls 4/14/2007 18:34' prior: 0!This is the wild-n-wooly policy.  Anyone may create a new account, and the first person to try to add or remove a package with a given name comes to exclusively own that package name.  Only the owner of a package name may make changes to packages with that name.As an exception, the supuser/suppassword may be used to change any package.  This is intended to allow a universe manager to override decisions made by package owners.!!UPWild class methodsFor: 'reasonable names' stamp: 'ls 7/29/2004 16:51'!isReasonablePackageName: aString	^aString allSatisfy: [ :c | c isAlphaNumeric or: [ ' -.' includes: c ]]! !!UPWild class methodsFor: 'reasonable names' stamp: 'ls 2/15/2005 23:45'!isReasonableUsername: aString	^aString isEmpty not and: [ aString allSatisfy: [ :c | c isAlphaNumeric ] ]! !!UPackage methodsFor: 'comparing' stamp: 'ls 8/26/2007 11:39'!= anotherPackage	self hash = anotherPackage hash ifFalse: [ ^false ].	self name = anotherPackage name ifFalse: [ ^false ].	self version = anotherPackage version ifFalse: [ ^false ].	self category = anotherPackage category ifFalse: [ ^false ].	self depends = anotherPackage depends ifFalse: [ ^false ].	self provides = anotherPackage provides ifFalse: [ ^false ].	self squeakMapID = anotherPackage squeakMapID ifFalse: [ ^false ].	self url asString = anotherPackage url asString ifFalse: [ ^false ].	self maintainer = anotherPackage maintainer ifFalse: [ ^false ].	self homepage isNil = anotherPackage homepage isNil ifFalse: [ ^false ].	(self homepage isNil or: [ 		self homepage toText = anotherPackage homepage toText]) ifFalse: [ ^false ].	self description = anotherPackage description ifFalse:[ ^false ].	^true! !!UPackage methodsFor: 'comparing' stamp: 'ls 7/28/2004 09:58'!hash	^self name hash bitXor: self version hash! !!UPackage methodsFor: 'comparing' stamp: 'ls 11/26/2006 12:34'!isUPackage	^true! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:19'!addDependency: aString	depends add: aString! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 11:10'!category: aPackageCategory	category := aPackageCategory! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 1/13/2007 14:41'!categoryString: aString	self category: (UPackageCategory readFromString: aString).! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 15:39'!depends: aCollection	depends _ Set withAll: aCollection! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17'!description: aString	description _ aString! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:20'!homepage: aURL	homepage _ aURL! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 11/5/2007 12:28'!initialize	name := '(unnamed package)'.	version := UVersion readFromString: '0'.	category := self defaultCategory.	depends := Set new.	provides := Set new.	description := ''.	url := nil.	homepage := nil.	maintainer := ''! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:32'!maintainer: aString	maintainer _ aString! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17'!name: aString	name _ aString! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:27'!provides: aCollection	provides _ Set withAll: aCollection! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 8/26/2007 11:38'!squeakMapID: aUUID 	squeakMapID := aUUID! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:18'!url: aURL	url _ aURL! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17'!version: aVersion	version _ aVersion.	! !!UPackage methodsFor: 'accessing' stamp: 'ls 11/26/2006 10:54'!category	^ category ifNil: [self defaultCategory]! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!depends	^depends! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!description	^description! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 18:05'!homepage	"a homepage describing the package, or nil if there isn't one"	^homepage! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:33'!maintainer	^maintainer ifNil: [ '' ]! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!name	^name! !!UPackage methodsFor: 'accessing' stamp: 'ls 8/26/2007 09:18'!packageSpec	^UPackageSpec name: name version: version! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:29'!provides	^provides ifNil: [ Set new ]! !!UPackage methodsFor: 'accessing' stamp: 'ls 8/26/2007 11:37'!squeakMapID	^ squeakMapID! !!UPackage methodsFor: 'accessing' stamp: 'ls 10/19/2006 10:30'!url	"The location of the package to install.  If it is nil, then the package is virtual and only has meaning for its dependencies."	^url! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/27/2004 21:32'!version	^version! !!UPackage methodsFor: 'miscellania' stamp: 'ls 11/26/2006 11:07'!defaultCategory	^ UPackageCategory withComponents: #('Uncategorized' )! !!UPackage methodsFor: 'installing' stamp: 'ls 5/13/2007 18:10'!cachedCopyFilename	"Download the package to a local cache, if it is not already in the cache.  Return the filename of the file in the cache.  If the package has no URL, download nothing and return nil."	| filename doc file downloadDir |	self url ifNil: [ ^nil ].		downloadDir _ FileDirectory default directoryNamed: 'universetmp'.	downloadDir assureExistence.		filename _ self url path last.	(downloadDir isAFileNamed: filename)	ifFalse: [		"download the file"		doc _ url retrieveContents.		((doc contentType asString = 'text/plain') and: [			doc content beginsWith: 'error']) ifTrue: [			"HACK to see if the download failed; the real solution is to make retrieveContents report errors"			^self error: 'download failed' ].		file _ downloadDir newFileNamed: filename.		file binary.		file nextPutAll: doc content.		file close. ].	^ (downloadDir fullNameFor: filename).! !!UPackage methodsFor: 'installing' stamp: 'dc 7/24/2007 11:40'!install	self url ifNil: [^ self].	UPackageInstaller installFileNamed: self cachedCopyFilename! !!UPackage methodsFor: 'testing' stamp: 'ls 12/31/2006 16:11'!isPackageCategory	^false! !!UPackage methodsFor: 'printing' stamp: 'ls 8/31/2007 12:25'!longDescription	^Text streamContents: [ :str |		str nextPutAll: self description; cr; cr.		str nextPutAll: 'Category: '; print: self category; cr.		self provides isEmpty ifFalse: [			str nextPutAll: 'Provides:'; cr.			self provides do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		self  depends isEmpty ifFalse: [			str nextPutAll: 'Depends on:'; cr.			self  depends do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		str nextPutAll: ('Maintained by: ', self  maintainer); cr.		str nextPutAll: 'Downloads from: '.		self  url ifNil: [ str nextPutAll: '(no url)' ] ifNotNil: [ str nextPutAll: self  url asString ].		str cr.		self  homepage ifNotNil: [			str nextPutAll: 'Homepage: '.			str nextPutAll: (Text string: self homepage asString attribute: (TextURL new url: self homepage asString)).			str cr].		self squeakMapID ifNotNil: [			| smurl |			str nextPutAll: 'SqueakMap UUID: ', self squeakMapID asString, String cr.			smurl := 'http://map.squeak.org/package/', self squeakMapID asString.			str nextPutAll: (Text string: '[browse SqueakMap web page]' attribute: (TextURL new url: smurl)).			str cr.						str nextPutAll: (Text string: '[open SqueakMap browser]' attribute: (TextDoIt evalString: 'USqueakMapUtil browsePackageID: (UUID fromString: ''', self squeakMapID asString, ''')')).			str cr.			]. ] .! !!UPackage methodsFor: 'printing' stamp: 'ls 7/27/2004 21:19'!printOn: aStream	aStream		nextPutAll: name;		nextPutAll: ' version ';		print: version! !!UPackage methodsFor: 'serializing' stamp: 'ls 2/13/2005 13:29'!printXMLPackageList: names on: stream	names do: [ :n |		stream nextPutAll: ' <packagename>'; nextPutAll: n escapeEntities; nextPutAll: '</packagename>' ].! !!UPackage methodsFor: 'serializing' stamp: 'ls 8/26/2007 11:40'!xmlForExport	^String streamContents: [ :str |		str			nextPutAll: '<package>'; cr;			nextPutAll: '<name>'; nextPutAll: self name escapeEntities; nextPutAll: '</name>'; cr;			nextPutAll: '<version>'; nextPutAll:  self version printString escapeEntities; nextPutAll: '</version>'; cr;			nextPutAll: '<category>'; print: self category; nextPutAll: '</category>'; cr;			nextPutAll: '<description>'; nextPutAll: self description escapeEntities; nextPutAll: '</description>'; cr.		self url ifNotNil: [			str nextPutAll: '<url>'; nextPutAll: self url toText escapeEntities; nextPutAll: '</url>'; cr ].		self homepage ifNotNil: [			str nextPutAll: '<homepage>'; nextPutAll:  self homepage toText escapeEntities; nextPutAll: '</homepage>'; cr ].		str nextPutAll: '<maintainer>'; nextPutAll: self maintainer escapeEntities; nextPutAll: '</maintainer>'; cr.					str nextPutAll: '<provides>'.		self printXMLPackageList: self provides on: str.		str nextPutAll: '</provides>'.		str nextPutAll: '<depends>'.		self printXMLPackageList: self depends on: str.		str nextPutAll: '</depends>'.		squeakMapID ifNotNil: [			str nextPutAll: '<squeakMapID>'.			str nextPutAll: squeakMapID asString.			str nextPutAll: '</squeakMapID>'.			].		str nextPutAll: '</package>'; cr. ]! !!UPackage methodsFor: '*universes-messages' stamp: 'ls 8/26/2007 11:46'!stringArrayEncoding	^Array streamContents: [ :str |		str			nextPut: self name;			nextPut: self version printString;			nextPut: self description;			nextPut: (self url ifNil: [ '(no download url)' ] ifNotNil: [ self url toText ]);			nextPut: (self homepage ifNil: [ '' ] ifNotNil: [ self homepage toText ]);			nextPut: self maintainer;			nextPut: self provides size printString;			nextPutAll: self provides;			nextPut: self depends size printString;			nextPutAll: self depends;			nextPut: 0 printString;  "legacy conflicts field"			nextPut: self category printString;			nextPut: (self squeakMapID ifNil: [''] ifNotNil: [self squeakMapID asString])].! !!UPackage commentStamp: 'ls 7/27/2004 21:20' prior: 0!One release of one package.!!UPackage class methodsFor: '*universes-messages' stamp: 'ls 8/26/2007 12:01'!decodeFromStringStream: str	| package numDepends homePageText numProvides numConflicts urlString |	package _ self new.	package name: str next.	package version: (UVersion readFromString: str next).	package description: str next.	urlString := str next.	(urlString withBlanksTrimmed beginsWith: '(') ifFalse: [		(urlString withBlanksTrimmed beginsWith: 'http://(') ifFalse: [			package url: (Url absoluteFromText: urlString) ] ].	homePageText _ str next.	package homepage: (homePageText isEmpty ifTrue: [ nil ] ifFalse: [ homePageText asUrl ]).	package maintainer: str next.	numProvides _ Integer readFromString: str next. 	package provides: (str next: numProvides).	numDepends _ Integer readFromString: str next. 	package depends: (str next: numDepends).	numConflicts _ Integer readFromString: str next. 	str next: numConflicts.  "skip them"	str atEnd ifFalse: [		package category: (UPackageCategory readFromString: str next)].		str atEnd ifFalse: [		| idstr |		idstr := str next.		idstr isEmpty ifFalse: [			package squeakMapID:  (UUID fromString: idstr) ].		].		^package! !!UPackage class methodsFor: 'decoding' stamp: 'ls 8/26/2007 12:01'!decodeFromXMLElement: doc	| package urlString |	package _ self new.	package name: (self getXMLPartNamed: 'name' from: doc).	package version: (UVersion readFromString: (self getXMLPartNamed: 'version' from: doc)).	package description: (self getXMLPartNamed: 'description' from: doc).	urlString _ self getXMLPartNamed: 'url' from: doc.	urlString isEmpty ifFalse: [		(urlString withBlanksTrimmed beginsWith: 'http://(') ifFalse: [	 		package url: (Url absoluteFromText: urlString). ] ].	(doc elementAt: 'homepage') ifNotNil: [		package homepage: (Url absoluteFromText: (self getXMLPartNamed: 'homepage' from: doc)) ].	package maintainer: (self getXMLPartNamed: 'maintainer' from: doc).	package provides: (self getXMLPackageList: 'provides' from: doc).	package depends: (self getXMLPackageList: 'depends' from: doc).	(doc elementAt: 'category') ifNotNil: [		package category: (UPackageCategory readFromString: (self getXMLPartNamed: 'category' from: doc ))].	(doc elementAt: 'squeakMapID') ifNotNil: [		| idstr |		idstr := self getXMLPartNamed: 'squeakMapID' from: doc.		idstr isEmpty ifFalse: [			package squeakMapID: (UUID fromString: idstr)]].	^package! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:24'!decodePackagesFromXMLStream: stream	| doc |	doc _ XMLDOMParser parseDocumentFrom: stream.	^doc elements collect: [ :element | self decodeFromXMLElement: element ].! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:12'!getXMLPackageList: listname from: element	| listElement |	listElement _ element elementAt: listname.	listElement ifNil: [ ^#() ].	^listElement elements collect: [ :nameXML |		nameXML contents first string ]! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/2/2007 15:00'!getXMLPartNamed: partName  from: xmlDoc	| element |	element _ xmlDoc elementAt: partName.	(element isNil or: [ element contents isEmpty ]) ifTrue:[ ^ '' ].	^element contents first string! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:41'!readPackageListFromFileNamed: filename	| file packages |	file _ FileStream readOnlyFileNamed: filename.	packages _ self decodePackagesFromXMLStream: file.	file close.	^packages! !!UPackage class methodsFor: 'saving' stamp: 'ls 2/13/2005 14:47'!savePackageList: packageList  onFileNamed: filename	| tmpName file |	tmpName _ filename, 'tmp'.	FileDirectory default deleteFileNamed: tmpName ifAbsent:  [].	file _ FileStream fileNamed: tmpName.	packageList do: [ :package |		file nextPutAll: package xmlForExport ].	file close.	FileDirectory default rename: tmpName toBe: filename.! !!UPackageCategory methodsFor: 'comparing' stamp: 'ls 12/31/2006 16:10'!= aCategory	^aCategory isPackageCategory and: [		components = aCategory components ]! !!UPackageCategory methodsFor: 'comparing' stamp: 'ls 11/26/2006 11:06'!hash	^components hash! !!UPackageCategory methodsFor: 'comparing' stamp: 'ls 11/26/2006 12:33'!isUPackageCategory	^true! !!UPackageCategory methodsFor: 'attributes' stamp: 'ls 11/26/2006 11:05'!components	^components! !!UPackageCategory methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 10:59'!initialize	components := #()! !!UPackageCategory methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 10:59'!initialize: anArrayOfStrings	components := anArrayOfStrings! !!UPackageCategory methodsFor: 'testing' stamp: 'ls 12/31/2006 16:10'!isPackageCategory	^true! !!UPackageCategory methodsFor: 'subcategories' stamp: 'ls 11/26/2006 12:20'!isSubcategoryOf: prefix	components isEmpty ifTrue: [ ^false ].	^components allButLast = prefix components! !!UPackageCategory methodsFor: 'printing' stamp: 'ls 11/26/2006 11:04'!printOn: aStream	components do: [ :comp |		aStream nextPutAll: comp ]	separatedBy: [ aStream nextPut: $/ ]! !!UPackageCategory commentStamp: 'ls 11/26/2006 10:59' prior: 0!A category for a package.!!UPackageCategory class methodsFor: 'instance creation' stamp: 'ls 11/26/2006 11:03'!readFrom: aStream	"[UPackageCategory readFromString: 'Core/Umbrella Packages']"	| comps nextComp |	comps := OrderedCollection new.	[aStream atEnd] whileFalse: [		nextComp := (aStream upTo: $/) withBlanksTrimmed.		nextComp isEmpty ifFalse: [			comps add: nextComp ] ].		^self withComponents: comps! !!UPackageCategory class methodsFor: 'instance creation' stamp: 'ls 11/26/2006 12:21'!root	^self withComponents: #()! !!UPackageCategory class methodsFor: 'instance creation' stamp: 'ls 11/26/2006 11:05'!withComponents: anArrayOfStrings	^self basicNew initialize: (Array withAll: anArrayOfStrings)! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 16:41'!acceptFields	fields do: [ :f | f accept ]! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 8/26/2007 11:30'!guessSqueakMapID	| squeakmap map smpackage |	self acceptFields.	squeakmap := Smalltalk at: #SMSqueakMap ifAbsent: [		^self inform: 'SqueakMap not loaded, cannot guess'].	map := squeakmap default.	smpackage := map packages detect: [ :smp | smp name = self packageName ] ifNone: [		^self inform: 'could not find a SqueakMap package named ', self packageName].	self smidString: smpackage id asString	! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 16:34'!makeFieldGet: getSelector  set: setSelector	| field fieldHeight |	fieldHeight _ TextStyle default defaultFont pointSize + 8.					field := PluggableTextMorph on: self text: getSelector accept: setSelector.	field extent: 200@fieldHeight.	field hideScrollBarsIndefinitely.	field setProperty: #alwaysAccept toValue: true.		fields ifNil: [ fields _ OrderedCollection new].	fields add: field.		^field! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 8/26/2007 11:25'!makeGuessSMIDButton	^(UInterfaceUtilities makeButtonWithAction: #guessSqueakMapID  andLabel: 'guess' for: self)		hResizing: #shrinkWrap! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 8/26/2007 11:24'!morphicView	| win column nameRow versionRow urlRow descriptionField submitButton dependsRow homepageRow providesRow maintainerRow categoryRow smidRow |	window ifNotNil: [ ^window ].	win _ SystemWindow labelled: 'Package Editor'.	win model: self.	column _ AlignmentMorph newColumn.	win addMorph: column frame: (0@0  extent:  1@0.6).		nameRow _ UInterfaceUtilities makeFieldRowNamed: 'name:' getSelector: #packageName setSelector: #packageName: for: self.	column addMorphBack: nameRow.		versionRow _ UInterfaceUtilities makeFieldRowNamed: 'version:' getSelector: #versionString setSelector: #versionString: for: self.	column addMorphBack: versionRow.		categoryRow _ UInterfaceUtilities makeFieldRowNamed: 'category:' getSelector: #categoryString setSelector: #categoryString: for: self.	column addMorphBack: categoryRow.		maintainerRow _ UInterfaceUtilities makeFieldRowNamed: 'maintainer:' getSelector: #maintainer setSelector: #maintainer: for: self.	column addMorphBack: maintainerRow.		homepageRow _ UInterfaceUtilities makeFieldRowNamed: 'homepage:' getSelector: #homepageString setSelector: #homepageString: for: self.	column addMorphBack: homepageRow.		smidRow _ UInterfaceUtilities makeFieldRowNamed: 'SqueakMap ID:' getSelector: #smidString setSelector: #smidString: for: self.	smidRow addMorphBack: self makeGuessSMIDButton.	column addMorphBack: smidRow.			urlRow _ UInterfaceUtilities makeFieldRowNamed: 'download from:' getSelector: #urlString setSelector: #urlString: for: self.	column addMorphBack: urlRow.	providesRow _ UInterfaceUtilities makeFieldRowNamed: 'provides:' getSelector: #providesString setSelector: #providesString: for: self.	column addMorphBack: providesRow.		dependsRow _ UInterfaceUtilities makeFieldRowNamed: 'depends:' getSelector: #dependsString setSelector: #dependsString: for: self.	column addMorphBack: dependsRow.	column addMorphBack: (StringMorph contents: 'Description:').		descriptionField _ self makeFieldGet: #description set: #description:.	win addMorph: descriptionField frame: (0@0.6 extent: 1@0.3).		submitButton _ UInterfaceUtilities makeButtonWithAction: #submit andLabel: 'Submit' for: self.	win addMorph: submitButton frame: (0@0.9 extent: 1@0.1).			^window _ win! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34'!noteField: field 	"note that the receiver has the specified text field"	fields ifNil: [fields := OrderedCollection new].	fields add: field! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 8/26/2007 11:21'!openInMorphic	^self morphicView openInWorldExtent:  592@557! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 18:05'!returnTrue	^true! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 16:43'!submit	self acceptFields.	whenComplete value: package! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 11/26/2006 11:22'!categoryString	^package category printString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 1/13/2007 14:41'!categoryString: aText 	package categoryString: aText asString.	self changed: #categoryString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:58'!dependsString	^self stringForPackageNames: package depends! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!dependsString: aString 	package depends: (self packageNamesFromString: aString).	self changed: #dependsString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:40'!description	^package description! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:41'!description: aString	package description: aString asString.	self changed: #description.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 18:00'!homepageString	^package homepage		ifNil: [ '' ]		ifNotNil: [ package homepage toText ]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 18:01'!homepageString: newHomePage	newHomePage asString = ''		ifTrue: [ package homepage: nil ]		ifFalse: [ package homepage: (Url absoluteFromText: newHomePage asString) ].	self changed: #homepageString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!maintainer	^package maintainer! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 18:00'!maintainer: aStringOrText 	package maintainer: aStringOrText asString.	self changed: #maintainer! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:45'!package	^package! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:38'!packageName	^package name! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:43'!packageName: aString	package name: aString asString.	self changed: #packageName.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!packageNamesFromString: aString 	| depNames |	depNames := aString asString findTokens: ','.	depNames := depNames collect: [:d | d withBlanksTrimmed].	^depNames! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!providesString	^self stringForPackageNames: package provides! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!providesString: aString 	package provides: (self packageNamesFromString: aString).	self changed: #providesString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 8/26/2007 11:37'!smidString	^package squeakMapID		ifNil: ['']		ifNotNil: [package squeakMapID asString ]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 8/26/2007 11:43'!smidString: aStringOrText 	| id str |	str := aStringOrText asString withBlanksTrimmed.	id := str isEmpty ifTrue: [nil] ifFalse: [UUID fromString: str].	package squeakMapID: id.	self changed: #smidString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:58'!stringForPackageNames: depends 	| first |	first := true.	^String streamContents: 			[:str | 			depends do: 					[:depName | 					first ifTrue: [first := false] ifFalse: [str nextPutAll: ', '].					str nextPutAll: depName]]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 10/20/2006 18:36'!urlString	^package url ifNotNil: [ package url toText ]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 10/25/2006 15:18'!urlString: aString	| url trimmedString |	trimmedString := aString asString withBlanksTrimmed.	url := (trimmedString isEmpty or: [ trimmedString beginsWith: '(' ])		ifTrue: [ nil ]		ifFalse: [ Url absoluteFromText: trimmedString ].	package url: url.	self changed: #urlString.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:39'!versionString	^package version printString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:39'!versionString: aString	package version: (UVersion readFromString: aString).	self changed: #versionString.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 17:12'!window	^window! !!UPackageEditor methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 16:28'!package: aPackage  whenComplete: aBlock	package _ aPackage.	whenComplete _ aBlock.	! !!UPackageEditor commentStamp: '<historical>' prior: 0!A simple GUI for editing a package and then doing something with it.!!UPackageEditor class methodsFor: 'class initialization' stamp: 'ls 2/13/2005 16:58'!initialize	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UPackageEditor class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 16:28'!package: aPackage  whenComplete: aBlock	^self basicNew		package: aPackage  whenComplete: aBlock;		yourself! !!UPackageInstaller methodsFor: 'comparing' stamp: 'ls 7/29/2004 11:02'!= anInstaller	^self class = anInstaller class! !!UPackageInstaller methodsFor: 'comparing' stamp: 'ls 7/29/2004 11:03'!hash	^self class hash! !!UPackageInstaller methodsFor: 'testing' stamp: 'ls 7/29/2004 10:59'!handlesFileEnding: anEnding	^false! !!UPackageInstaller methodsFor: 'testing' stamp: 'ls 7/29/2004 11:08'!handlesFilename: filename	^self handlesFileEnding: (FileDirectory extensionFor: filename)	! !!UPackageInstaller methodsFor: 'installing' stamp: 'ls 7/29/2004 11:06'!install: stream  usingBaseName: baseName	self subclassResponsibility! !!UPackageInstaller methodsFor: 'installing' stamp: 'ls 9/4/2004 15:02'!installFileNamed: filename	| stream baseName |	stream _ (FileStream readOnlyFileNamed: filename).	baseName _ (FileDirectory splitName: filename to: [:path :base|base]) copyUpTo: $. .	self install: stream usingBaseName: baseName.	stream close.	! !!UPackageInstaller commentStamp: '<historical>' prior: 0!A simply hierarchy for loading Squeak content in various formats.!!UPackageInstaller class methodsFor: 'initialization' stamp: 'ls 7/29/2004 11:09'!initialize	Installers ifNil: [ Installers _ Set new ].		{UIFileOut. UIMonticello. UIMpeg. UIProject. UISar} do: [ :c |		self registerInstaller: c new ]! !!UPackageInstaller class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 11:10'!installFileNamed: filename	(self installerForFilename: filename) installFileNamed: filename! !!UPackageInstaller class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 11:10'!installerForFilename: filename	^self registeredInstallers detect: [ :i | i handlesFilename: filename ] ifNone: [ self error: 'no installer handles file ', filename ].! !!UPackageInstaller class methodsFor: 'registry' stamp: 'ls 7/29/2004 11:02'!registerInstaller: installer	Installers add: installer! !!UPackageInstaller class methodsFor: 'registry' stamp: 'ls 7/29/2004 11:11'!registeredInstallers	^Installers asArray! !!UPackageSerializer commentStamp: 'ls 2/13/2005 12:49' prior: 0!A class for loading and saving lists of packages!!UPackageSpec methodsFor: 'comparison' stamp: 'ls 8/26/2007 09:11'!= aPackageSpec	^(aPackageSpec isKindOf: UPackageSpec) and: [		aPackageSpec name = name and: [			aPackageSpec version = version ]]! !!UPackageSpec methodsFor: 'comparison' stamp: 'ls 8/26/2007 09:18'!hash	^name hash bitXor: version hash! !!UPackageSpec methodsFor: 'initialization' stamp: 'ls 8/26/2007 09:10'!initialize	super initialize.	name := '(unnamed)'.	version = UVersion readFromString: '0'! !!UPackageSpec methodsFor: 'initialization' stamp: 'ls 8/26/2007 09:14'!name: aString version: aUVersionOrString	name := aString.	version := aUVersionOrString asUVersion.	! !!UPackageSpec methodsFor: 'attributes' stamp: 'ls 8/26/2007 09:11'!name	^name! !!UPackageSpec methodsFor: 'attributes' stamp: 'ls 8/26/2007 09:11'!version	^version! !!UPackageSpec methodsFor: 'printing' stamp: 'ls 8/26/2007 09:17'!printOn: aStream	aStream		nextPutAll: name;		nextPutAll: '/';		print: version! !!UPackageSpec commentStamp: 'ls 8/26/2007 09:09' prior: 0!The information needed to identify a package within a universe: a name plus a version.!!UPackageSpec class methodsFor: 'instance creation' stamp: 'ls 8/26/2007 09:14'!name: aString version: aUVersionOrString 	^ self basicNew name: aString version: aUVersionOrString! !!UPackageSpec class methodsFor: 'instance creation' stamp: 'ls 8/26/2007 09:13'!new	^self error: 'create instances with name:version:'! !!UPackageTestCase methodsFor: 'setup' stamp: 'ls 11/26/2006 11:10'!setUp	p1 _ UPackage new.	p1 name: 'Scamper'.	p1 category: (UPackageCategory withComponents: #('Networking')).	p1 description: 'A web browser'.	p1 url: 'http://www.squeak.org' asUrl.	p1 homepage: p1 url.	p1 version: (UVersion readFromString: '1.0').	p1 maintainer: 'John Doe'.	p2 _ p1 deepCopy.! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 8/26/2007 12:00'!testCompare	self should: [ p1 = p2 ].	self should: [ p1 hash = p2 hash ].	p2 homepage: 'http://www.squeakland.org' asUrl.	self shouldnt: [ p1 = p2 ].	p2 homepage: p1 homepage.	self should: [ p1 = p2 ].	self should: [ p1 hash = p2 hash ].	p1 homepage: nil.	p2 homepage: nil.	self should: [ p1 = p2 ].	self should: [ p1 hash = p2 hash ].	p2 maintainer: 'Jane'.	self shouldnt: [ p1 = p2 ].! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 2/13/2005 12:59'!testEncoding	self should: [ p1 = (UPackage decodeFromStringStream: (ReadStream on: p1 stringArrayEncoding)) ].! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 11/26/2006 10:50'!testXML	| xmlString stream readp1 readp2 readPackages readp3 |	p2 version: (UVersion readFromString: '1.2').	p1 description: 'blah blah <>&"'''.	xmlString _ String streamContents: [ :str |		str 			nextPutAll: p1 xmlForExport;			nextPutAll: p2 xmlForExport.					str nextPutAll: '<package><name>IRCe</name><version>10.7.6</version><description>This is a significant rewrite of the built-in Squeak IRC client GUI. A new user interface includes having one console window per connection and then having all console messages, channel messages and private messages contained inside the main console window using tabbed swapped panes.                                         Numerous other changes are also included but are not described here. The change-set contains documentation for all features added or modified.Instructions at http://squeak.preeminent.org/irc-help/irc-help.html</description><url>http://kilana.unibe.ch:8888/IRC/Network-IRC-fc.10.7.6.mcz</url><maintainer></maintainer><provides></provides><depends></depends><conflicts></conflicts></package>' ].	stream _ ReadStream on: xmlString.	readPackages _ UPackage decodePackagesFromXMLStream: stream.	self should: [ readPackages size = 3 ].	readp1 _ readPackages first.	readp2 _ readPackages second.	readp3 _ readPackages third.	self should: [ readp1 = p1 ].	self should: [ readp2 = p2 ].	self should: [ readp3 name = 'IRCe'].	self should: [ readp3 version = (UVersion readFromString: '10.7.6')].	! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48'!addUser: user  withPassword: password  andEmail: email	^UPolicyResponse allowed! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48'!changeUser: user withPassword: password toHavePassword: newPassword andNewEmail: newEmail	^UPolicyResponse allowed! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48'!package: aPackage  mayBeAddedBy: user  withPassword: password	^UPolicyResponse allowed! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48'!packageNamed: packageName  withVersion: version  mayBeRemovedBy: user  withPassword: password	^UPolicyResponse allowed! !!UPermissivePolicy commentStamp: '<historical>' prior: 0!A policy that allows anything.!!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47'!addUser: user  withPassword: password  andEmail: email	^UPolicyResponse denied! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47'!changeUser: user withPassword: password toHavePassword: newPassword andNewEmail: newEmail	^UPolicyResponse denied! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47'!package: aPackage  mayBeAddedBy: user  withPassword: password	^UPolicyResponse denied! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47'!packageNamed: packageName  withVersion: version  mayBeRemovedBy: user  withPassword: password	^UPolicyResponse denied! !!UPolicy commentStamp: '<historical>' prior: 0!A policy for manipulations on a universe.  All of the methods return 'true' on success or on allowing the requested operation, or 'false' on an error or if the operation is not allowed.  By default everything is disallowed.Note that since policy is completely implemented on the server, there is no requirement that a particular UUniverse has a policy describable with this class or a subclass.  A particular server can always modify UUniverseServer to implement an arbitrary policy.!!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56'!allowed	^allowed! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56'!allowed: anObject	allowed _ anObject! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:58'!reason	^reason! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56'!reason: anObject	reason _ anObject! !!UPolicyResponse commentStamp: '<historical>' prior: 0!A response to a policy query.!!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:47'!allowed	^self allowed: nil! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/30/2004 10:34'!allowed: reason	^self allowed: true  reason: reason! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:46'!allowed: aBoolean  reason: aReason	^self basicNew		allowed: aBoolean;		reason: (aReason ifNil: ['no reason given']);		yourself! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:46'!denied	^self denied: nil! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 17:58'!denied: reason	^self allowed: false  reason: reason! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:47'!new	self shouldNotImplement ! !!UServerStepperMorph methodsFor: 'closing' stamp: 'ls 2/13/2005 15:20'!delete	super delete.	server stopListening.! !!UServerStepperMorph methodsFor: 'initialization' stamp: 'ls 7/28/2004 13:19'!server: aServer	server _ aServer! !!UServerStepperMorph methodsFor: 'stepping' stamp: 'ls 8/14/2007 20:58'!step	server ifNotNil: [ server step ].! !!UServerStepperMorph methodsFor: 'stepping' stamp: 'ls 7/28/2004 13:19'!stepTime	^10! !!UServerStepperMorph methodsFor: 'stepping' stamp: 'ls 7/28/2004 13:19'!wantsSteps	^true! !!UServerStepperMorph commentStamp: '<historical>' prior: 0!A morph that simply steps a UniverseServer continuously.!!USqueakMapUtil commentStamp: 'ls 8/31/2007 12:16' prior: 0!Utilities for interfacing to SqueakMap.!!USqueakMapUtil class methodsFor: 'browsing' stamp: 'ls 8/31/2007 12:18'!browsePackageID: packageID	"open a SqueakMap browser on the specified package ID"	Smalltalk at: #SMLoader ifPresent: [ :smloaderClass |		| loader |		loader := smloaderClass open.		loader selectedItemWrapper: (loader packageWrapperList detect: [:pw | pwwithoutListWrapper id = packageID])]! !!UStandardUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 12:43'!addPackage: aPackage	"make sure that we end up with no two packages with the same name and version"	packages removeAllSuchThat: [ :p | p name = aPackage name and: [ p version = aPackage version ] ].		"now add the new package"	packages add: aPackage.	self changed: #packages! !!UStandardUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 12:43'!removePackage: aPackage	packages remove: aPackage.	self changed: #packages! !!UStandardUniverse methodsFor: 'packages' stamp: 'ls 2/15/2005 22:42'!updatePackagesViaWWW	| rawPackageList newPackages |	packagesURL ifNil: [ ^self ].	rawPackageList _ packagesURL retrieveContents content.	(rawPackageList withBlanksTrimmed beginsWith: '<') ifFalse: [		"it is possible that the universe is completely empty, but more likely there was an error retrieving the document"		^self ].	newPackages _ UPackage decodePackagesFromXMLStream: (ReadStream on: rawPackageList).	self packages: newPackages! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 8/26/2007 11:57'!initialize	super initialize.	shortName := 'silly'.	serverName := 'localhost'.	serverPort := 6770.	packages := Set new.! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:01'!packages: aCollection	packages _ Set new.	packages addAll: aCollection.	self changed: #packages! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 11:12'!packagesURL: aURL	packagesURL _ aURL! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 10:37'!serverName: aString		serverName _ aString! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 10:37'!serverPort: port	serverPort _ port! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 1/16/2005 14:07'!packages	^packages! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 11:13'!packagesURL	"a URL from which the list of packages may be downloaded"	^packagesURL! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 7/28/2004 13:21'!serverName	^serverName! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 7/28/2004 13:21'!serverPort	^serverPort! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 7/29/2004 18:09'!standardUniverses	^{self}! !!UStandardUniverse commentStamp: 'ls 7/28/2004 10:36' prior: 0!A universe that looks to one single server for authoritative information.!!UTF8ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 6/3/2007 18:47'!fromSystemClipboard: aString	^aString utf8ToSqueak! !!UTF8ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 6/3/2007 18:48'!toSystemClipboard: aString	^aString squeakToUtf8! !!UUniverse methodsFor: 'packages' stamp: 'ls 7/29/2004 19:09'!addPackages: newPackages	newPackages do: [ :p | self addPackage: p ]! !!UUniverse methodsFor: 'packages' stamp: 'tonyg 2/24/2005 20:14'!buildPackageCache	self packages do: [ :p | p cachedCopyFilename ].! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06'!hasPackageNamed: name	^self packages anySatisfy: [ :p | p name = name ].	! !!UUniverse methodsFor: 'packages' stamp: 'ls 7/28/2004 17:17'!newestPackageNamed: name	| potentials sorted |	potentials _ self packagesNamed: name.	sorted _ potentials asSortedCollection: [ :p1 :p2 | p1 version < p2 version ].	^sorted last! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06'!packageNames	| names |	names _ Set new.	self packages do: [ :p | names add: p name ].	^names! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:08'!packages	^self subclassResponsibility! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:07'!packagesNamed: name	^self packages select: [ :p | p name = name ].	! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06'!removePackageNamed: packageName withVersion: version	| packagesToRemove |	packagesToRemove _ self packages select: [ :p | p name = packageName and: [ p version = version ] ].	packagesToRemove do: [ :p | self removePackage: p ].	! !!UUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 14:56'!updatePackagesViaWWW	"update the packages in this universe by downloading them from the universe's URL"	^self subclassResponsibility! !!UUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 11:10'!description	"The description is a one-line description of the universe for human consumption."	^description! !!UUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 14:46'!shortName	"A short, computer-friendly alphanumeric identifier"	^shortName! !!UUniverse methodsFor: 'accessing' stamp: 'ls 2/15/2005 21:49'!standardUniverses	"return a list of standard universes within the receiver.  See class UStandardUniverse"	^self subclassResponsibility! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 16:16'!description: aString	description _ aString! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 1/16/2005 14:07'!initialize	description _ 'some universe'.! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 11:10'!shortName: aString	shortName _ aString! !!UUniverse commentStamp: 'ls 2/13/2005 11:10' prior: 0!Abstract.  One "package universe".  A package universe is an evolving set of packages that multiple people can participate in.  Each Squeak image is a member of exactly one universe.!!UUniverse class methodsFor: 'well known' stamp: 'ls 10/7/2007 13:36'!betaUniverse 	"[UUniverse switchSystemToUniverse: UUniverse betaUniverse]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'beta';		description: 'Beta Development';		packagesURL: 'http://universes.dnsalias.net/~universes/repositories/beta.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 10/7/2007 13:40'!betadevUniverse	"a combination of normal plus beta packages"	"[UUniverse switchSystemToUniverse: UUniverse betadevUniverse]"	^UCompoundUniverse composedOf: {		self developmentUniverse.		self betaUniverse	}! !!UUniverse class methodsFor: 'well known' stamp: 'ls 3/22/2007 11:34'!developmentUniverse 	"[UUniverse switchSystemToUniverse: UUniverse developmentUniverse]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'development';		description: 'Development';		packagesURL: 'http://universes.dnsalias.net/~universes/repositories/development.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 2/13/2005 12:45'!exampleCompoundUniverse	"[UUniverse switchSystemToUniverse: UUniverse exampleCompoundUniverse]"	^(UCompoundUniverse composedOf: {		self developmentUniverse.		self homeMoviesUniverse	}) description: 'example compound universe'; yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 3/22/2007 13:22'!homeMoviesUniverse 	"[UUniverse switchSystemToUniverse: UUniverse homeMoviesUniverse]"	^UStandardUniverse new		shortName: 'homemovies';		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		packagesURL: 'http://universes.dnsalias.net/~universes/repositories/homemovies.packages' asUrl;		description: 'Home Movies';		yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 10/7/2007 14:05'!squeak310Universe 	"[UUniverse switchSystemToUniverse: UUniverse squeak310Universe]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'squeak3.10';		description: 'Squeak 3.10';		packagesURL: 'http://universes.dnsalias.net/~universes/repositories/squeak3.10.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 3/22/2007 13:22'!squeak37Universe 	"[UUniverse switchSystemToUniverse: UUniverse squeak37Universe]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'squeak37';		description: 'Squeak 3.7';		packagesURL: 'http://universes.dnsalias.net/~universes/repositories/squeak37.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 3/22/2007 11:34'!squeak39Universe 	"[UUniverse switchSystemToUniverse: UUniverse squeak39Universe]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'squeak3.9';		description: 'Squeak 3.9';		packagesURL: 'http://universes.dnsalias.net/~universes/repositories/squeak3.9.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'class initialization' stamp: 'ls 2/15/2005 23:42'!initialize	"fix up old instances, to have a proper packagesURL"	"this method should be deleted, after suitable time has passed to allow for upgrades"	self allSubInstancesDo: [ :universe |		universe class == UStandardUniverse ifTrue: [			universe packagesURL == nil ifTrue: [				"no URL specified.  guess...."				universe serverPort = 4129 ifTrue: [					universe shortName: 'development'.					universe packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/development.packages' asUrl.					universe serverPort: UUniverseMultiServer defaultPort. ].				universe serverPort = 8940 ifTrue: [ 					universe shortName: 'homevideos'.					universe packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/homemovies.packages' asUrl.					universe serverPort: UUniverseMultiServer defaultPort. ].				universe serverPort = 7273 ifTrue: [ 					universe shortName: 'squeak37'.					universe packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/squeak37.packages' asUrl.					universe serverPort: UUniverseMultiServer defaultPort. ]. ] ] ]! !!UUniverse class methodsFor: 'system' stamp: 'ls 7/29/2004 18:54'!switchSystemToUniverse: aUniverse	SystemUniverse _ aUniverse! !!UUniverse class methodsFor: 'system' stamp: 'ls 2/13/2005 12:44'!systemUniverse	"return the universe this image uses"	^SystemUniverse ifNil: [ SystemUniverse _ self developmentUniverse ]! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 8/14/2007 21:10'!chooseUpgrades	"select packages that appear to be upgrades of packages that are already installed"	self installSet selectAllUpgrades.		self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 8/14/2007 21:13'!doInstall	self installSet anyPackageSelected ifFalse: [		^self inform: 'no packages selected to install' ].	self installSet doInstall.			self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 8/14/2007 21:30'!installSelectedPackage	self anyPackageSelected ifFalse: [ ^self ].	self installSet planToInstallPackage: self selectedPackage.			self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 8/14/2007 21:06'!installSet	^installSet ifNil: [ installSet :=		UGlobalInstaller universe: universe configuration: configuration	]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:56'!anyPackageSelected	^ selectedPackage notNil! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 8/14/2007 21:16'!anyPackagesToInstall	^self installSet anyPackageSelected ! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 8/14/2007 21:26'!canMarkSelectionForInstallation	^self anyPackageSelected and: [ 		(self installSet isPackageVersionSelected: self selectedPackage) not and: [			(self installSet isPackageVersionInstalled: self selectedPackage) not ]]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:23'!categories	^((self sortedPackages collect: [ :p | p category])		asSet		asSortedCollection: [ :p1 :p2 | p1 asString < p2 asString])		asArray! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:35'!categoriesAndPackagesIn: categoryPrefix	| categories packages |	categories := self categories select: [ :cat | cat isSubcategoryOf: categoryPrefix ].	packages := self sortedPackages select: [ :p | p category = categoryPrefix ].	^categories, packages! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:34'!isCategory: anObject	^anObject isUPackageCategory! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:48'!packageDescriptions	^ self sortedPackages collect: [:p | self packageOneLineDescription: p]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 8/26/2007 12:25'!packageOneLineDescription: p 	| commentary |	p isUPackage ifFalse: [ ^p printString ].	commentary := ''.	(self installSet isPackageVersionSelected: p) ifTrue: [commentary := '(to install) '].	(configuration includesPackageSpec: p packageSpec) 		ifTrue: [commentary := '(installed) '].	^ commentary , p printString! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 8/14/2007 21:21'!packagesChanged	self installSet initializeSelectedPackageVersions.  "the selected packages may not be there any more!!"	self selectPackageOrCategory:   nil.		self changed: #packageDescriptions.  self flag: #lex.  "only for compatibility with old, open GUI windows"	self changed: #rootCategoriesAndPackages.	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:24'!rootCategoriesAndPackages	^self categoriesAndPackagesIn: (UPackageCategory root)! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 12/31/2006 16:13'!selectPackageOrCategory: packageOrCategory	selectedPackage := 		packageOrCategory isUPackage			ifTrue: [ packageOrCategory ]			ifFalse: [ nil ].	self changed: #selectedPackage.	self changed: #selectedPackageDescription.	self changed: #canMarkSelectionForInstallation.	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:55'!selectedPackage	^selectedPackage! !!UUniverseBrowser methodsFor: 'package list' stamp: 'dc 3/22/2007 14:22'!selectedPackageDescription	self anyPackageSelected ifFalse: [ ^ '' ].	^ self selectedPackage longDescription 	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:58'!selectedPackageIndex	self flag: #lex.  "only present in case people have existing browser windows open"	^self sortedPackages indexOf: selectedPackage! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 13:02'!selectedPackageIndex: anIndex	self flag: #lex.  "only present in case people have existing browser windows open"	self selectPackageOrCategory:		(anIndex = 0 ifTrue: [ nil ] ifFalse: [ self sortedPackages at: anIndex ]).	self changed: #selectedPackageIndex	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 12/31/2006 16:25'!sortedPackages	| packages |	packages := Set new.	packages addAll: universe packages.	packages addAll: configuration installedPackages.		^packages asSortedCollection: [ :p1 :p2 |		p1 name < p2 name or: [			p1 name = p2 name and: [ p1 version < p2 version ] ] ].	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:19'!subcategoriesOf: categoryPrefix	^self categories select: [ :cat | cat isSubcategoryOf: categoryPrefix ]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 2/13/2005 15:12'!update: aSymbol	aSymbol = #packages ifTrue: [ self packagesChanged ]! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:58'!configuration: aConfiguration	configuration _ aConfiguration! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 8/14/2007 21:18'!initialize	configuration := UConfiguration forSystem.	self universe: UUniverse systemUniverse! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:12'!universe: aUniverse	universe _ aUniverse.	universe addDependent: self.! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 9/4/2004 14:37'!makeButtonWithAction: selector andGetState: getStateSelector andLabel: aString	^(PluggableButtonMorph on: self getState: getStateSelector action: selector)		label: aString;		useRoundedCorners;		vResizing: #spaceFill;		hResizing: #spaceFill;		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor muchLighter;		yourself! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 9/4/2004 14:35'!makeButtonWithAction: selector  andLabel: aString	^self makeButtonWithAction: selector andGetState: #returnTrue andLabel: aString! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 11/26/2006 12:50'!morphicView	| win packageList installButton doInstallButton buttonList upgradeButton updateListButton descriptionArea installButtonHolder |	win _ SystemWindow labelled: 'Universe'.	win model: self.			packageList _ 		PluggableTreeMorph new			model:  self;			name: 'package list';			getRootsSelector: #rootCategoriesAndPackages; 			hasChildrenSelector: #isCategory:; 			getChildrenSelector: #categoriesAndPackagesIn:;			setSelectedSelector: #selectPackageOrCategory:;			getLabelSelector: #packageOneLineDescription:.	win addMorph: packageList frame: ((0@0) extent: (0.5@0.9)).		installButtonHolder _ Morph new.  "necessary to keep SystemWindow from screwing up the colors of the button"	installButtonHolder 		name: 'holder for install button';		layoutPolicy: TableLayout new;		borderColor: self defaultBackgroundColor.	doInstallButton _ self makeButtonWithAction: #doInstall andGetState: #anyPackagesToInstall andLabel: 'Install Selections'.	doInstallButton		useSquareCorners;		borderWidth: 0;		setBalloonText: 'Download and install all the packages that you have selected';		name: 'install selections button'.	installButtonHolder addMorph: doInstallButton.	win addMorph: installButtonHolder frame: ((0@0.9) extent:(1@0.1)).	descriptionArea _ PluggableTextMorph on: self text: #selectedPackageDescription accept: nil.	win addMorph: descriptionArea frame: ((0.5@0.4) extent: (0.5@0.5)).		buttonList _ AlignmentMorph newColumn.	buttonList		cellInset: 0@3;		name: 'button list'.	win addMorph: buttonList frame: ((0.5@0) extent: (0.5@0.4)).			installButton _ self makeButtonWithAction: #installSelectedPackage andGetState: #canMarkSelectionForInstallation andLabel: 'select package'.	installButton setBalloonText: 'Select this package for installation'.	buttonList addMorph: installButton.		upgradeButton _ self makeButtonWithAction: #chooseUpgrades andLabel: 'select all upgrades'.	upgradeButton setBalloonText: 'Select every possible upgrade for the currently installed packages'.	buttonList addMorphBack: upgradeButton.		updateListButton _ self makeButtonWithAction: #requestPackageList andLabel: 'update list from network'.	updateListButton setBalloonText: 'Refresh the list of available packages from the network'.	buttonList addMorphBack: updateListButton.		^win! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 7/29/2004 16:19'!open	self morphicView openInWorld! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 9/4/2004 14:35'!returnTrue	"return true; used for buttons that are always enabled"	^true! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 11/26/2006 13:04'!titleAreaText	self flag: #lex.  "this is only present to support browser windows that are already open"	^universe shortName! !!UUniverseBrowser methodsFor: 'server communication' stamp: 'ls 11/26/2006 12:53'!requestPackageList	Utilities informUser: 'updating package list...' during:  [		universe updatePackagesViaWWW ]! !!UUniverseBrowser commentStamp: '<historical>' prior: 0!A tool to support one-click installs and upgrades of packages within a universe.!!UUniverseBrowser class methodsFor: 'instance creation' stamp: 'ls 2/13/2005 14:53'!forUniverse: aUniverse	^self new universe: aUniverse; yourself! !!UUniverseBrowser class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:15'!open	^self new open! !!UUniverseBrowser class methodsFor: 'class initialization' stamp: 'ls 8/19/2007 12:50'!initialize	#('Package Browser (basic)' 'Universe Browser') do: [:oldName |		TheWorldMenu unregisterOpenCommand: oldName ].		TheWorldMenu registerOpenCommand: {'Universe Browser (basic)'. {self. #open}}.	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UUniverseBrowser class methodsFor: 'class initialization' stamp: 'ls 8/19/2007 12:30'!unload	TheWorldMenu unregisterOpenCommand: 'Universe Browser (basic)'! !!UUniverseBrowser class methodsFor: 'dependencies' stamp: 'ls 7/29/2004 15:16'!orderPackagesByDependency: packages	"return a collection of the specified packages such that, when possible, any dependencies of a package are ordered before that package"	"The present algorithm is simple but slow..."	| remainingPackages orderedPackages packagesToAdd |	remainingPackages _ Set new.	orderedPackages _ OrderedCollection new.	remainingPackages addAll: packages.		"each time through this loop, add to orderedPackages any packages whose dependencies are not in remainaingPackages"	[	packagesToAdd := remainingPackages select: [ :p | p depends noneSatisfy: [ :depName | remainingPackages anySatisfy: [ :p2 | p2 name = depName ] ] ].		packagesToAdd isEmpty not	] whileTrue: [		orderedPackages addAll: packagesToAdd.		remainingPackages := remainingPackages difference: packagesToAdd ].		orderedPackages addAll: remainingPackages.	^orderedPackages! !!UUniverseClient methodsFor: 'public' stamp: 'ls 7/30/2004 15:10'!disconnect	"explicitly close the connection"	socket ifNotNil: [ socket destroy.  socket _ nil ].	stringSocket ifNotNil: [ stringSocket destroy.  stringSocket _ nil ].! !!UUniverseClient methodsFor: 'public' stamp: 'ls 7/30/2004 15:33'!receivedMessagesDo: aBlock	"check for new messages, and then evaluate aBlock for each message that is currently available"	self processIO.	[ inMessages isEmpty ] whileFalse: [		aBlock value: inMessages removeFirst ]! !!UUniverseClient methodsFor: 'public' stamp: 'ls 2/13/2005 15:18'!sendMessage: aMessage	"send the specified message to the server"	outMessages add: aMessage! !!UUniverseClient methodsFor: 'initialization' stamp: 'ls 8/5/2004 17:16'!initialize: aUniverse	universe _ aUniverse.		inMessages _ OrderedCollection new.	outMessages _ OrderedCollection new.		lastConnectionStart _ DateAndTime epoch.! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 8/4/2004 15:46'!newInMessage: aMessage	aMessage applyToClient: self.	inMessages add: aMessage.	! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 2/15/2005 21:44'!processIO	| rawMsg |	(stringSocket notNil and: [ stringSocket isConnected not ]) ifTrue: [		"connection has died"		stringSocket destroy.		stringSocket _ nil ].		(outMessages isEmpty not and: [ socket isNil and: [ stringSocket isNil ] ]) ifTrue: [		"there are outgoing messages queued but there is no stringSocket"		(DateAndTime now - lastConnectionStart) > (Duration minutes: 1) ifTrue: [			self startConnecting ] ].		socket ifNotNil: [		"a connection is in progress"				socket isConnected ifTrue: [			"connection completed"			stringSocket _ StringSocket on: socket.			universe shortName ifNotNil: [				outMessages addFirst: (UMProtocolVersion version: 1).				outMessages addFirst: (UMSelectServer shortName: universe shortName) ].			socket _ nil. ]		ifFalse: [			socket isWaitingForConnection ifFalse: [				"the connection failed"				inMessages add: (UMConnectionFailed description: 'connection failed').				^self disconnect ] ] ].		stringSocket ifNil: [ ^self ].			[ outMessages isEmpty ] whileFalse: [		stringSocket nextPut: outMessages removeFirst asStringArray ].		stringSocket processIO.		[	rawMsg _ stringSocket nextOrNil.		rawMsg isNil not	] whileTrue: [ 		self newInMessage: (UMessage fromStringArray: rawMsg) ]! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 7/30/2004 15:31'!startConnecting	"start a new connection to the server"	self disconnect.		lastConnectionStart _ DateAndTime now.		socket _ Socket newTCP.	socket connectTo: (NetNameResolver addressForName: universe serverName) port: universe serverPort.! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 1/13/2007 14:47'!waitForMessage	"return the next message from the server, waiting if necessary.  Many clients will find this method less convenient than polling on the non-blocking receivedMessagesDo:."	[		self receivedMessagesDo: [ :m | ^m ].		(Delay forMilliseconds: 100) wait.	] repeat.! !!UUniverseClient methodsFor: 'package list' stamp: 'ls 7/30/2004 14:59'!newPackageList: newPackages	universe packages: newPackages.	! !!UUniverseClient methodsFor: 'package list' stamp: 'ls 7/30/2004 15:00'!packageAdded: newPackage	universe addPackage: newPackage! !!UUniverseClient methodsFor: 'package list' stamp: 'ls 7/30/2004 15:02'!removedPackageNamed: packageName  withVersion: version	universe removePackageNamed: packageName  withVersion: version! !!UUniverseClient commentStamp: 'ls 7/30/2004 14:58' prior: 0!A client for talking to a universe server.The universe must be a UStandardUniverse.  The client will track update the universe automatically as messages come in.!!UUniverseClient class methodsFor: 'instance creation' stamp: 'ls 7/30/2004 15:06'!forUniverse: aStandardUniverse	^self basicNew		initialize: aStandardUniverse;		yourself! !!UUniverseClient class methodsFor: 'instance creation' stamp: 'ls 7/30/2004 15:06'!new	^self forUniverse: UUniverse systemUniverse! !!UUniverseClient class methodsFor: 'class initialization' stamp: 'ls 2/13/2005 15:45'!initialize	Preferences removePreference: #universesUsesHTTP ! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34'!acceptFields	fields do: [ :f | f accept ]! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:58'!closeAccountEditor	accountEditor ifNil: [ ^self ].	accountEditor window delete.	accountEditor _ nil.! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:12'!closeEditorForPackage: package	| matchingEditors |	matchingEditors _ packageEditors select: [ :p | p package = package ].	matchingEditors do: [ :editor |		editor window delete.		packageEditors remove: editor ].! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:02'!makeButtonWithAction: selector andGetState: getStateSelector andLabel: aString	^(PluggableButtonMorph on: self getState: getStateSelector action: selector)		label: aString;		useRoundedCorners;		vResizing: #spaceFill;		hResizing: #spaceFill;		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor muchLighter;		yourself! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:02'!makeButtonWithAction: selector  andLabel: aString	^self makeButtonWithAction: selector andGetState: #returnTrue andLabel: aString! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/15/2005 22:02'!morphicView	| win universeDescription buttonList usernameRow passwordRow button  usernamePasswordArea packageList |	win _ SystemWindow labelled: 'Universe Editor'.	win model: self.		universeDescription := PluggableTextMorph on: self text: #universeDescription accept: nil.	universeDescription hideScrollBarsIndefinitely.	win addMorph: universeDescription frame: (0@0 extent: 1@0.1).		buttonList _ AlignmentMorph newColumn.	buttonList cellInset: 0@3.	win addMorph: buttonList frame: (0@0.5 extent: 0.5@0.5).			usernamePasswordArea _ AlignmentMorph newColumn.	win addMorph: usernamePasswordArea frame: (0@0.1 extent: 0.5@0.4).	usernameRow _ UInterfaceUtilities makeFieldRowNamed: 'username' getSelector: #username setSelector: #username: for: self.	usernamePasswordArea addMorphBack: usernameRow.		passwordRow _ UInterfaceUtilities makeFieldRowNamed: 'password:' getSelector: #password setSelector: #password: isPassword: true for: self.	usernamePasswordArea addMorphBack: passwordRow.		button _ self makeButtonWithAction: #createAccount andLabel: 'createAccount'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #editAccount andLabel: 'edit account'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #newPackage andLabel: 'new package'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #newPackageVersion andGetState: #anyPackageSelected andLabel: 'new package version'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #removeVersion andGetState: #anyPackageSelected andLabel: 'remove package version'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #requestPackageList andLabel: 'update package list'.	buttonList addMorphBack: button.	packageList _ PluggableListMorph on: self list: #packageDescriptions  selected: #selectedPackageIndex changeSelected: #selectedPackageIndex: menu: nil.	win addMorph: packageList frame: ((0.5@0.1) extent: (0.5@0.9)).		^win! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34'!noteField: field 	"note that the receiver has the specified text field"	fields ifNil: [fields := OrderedCollection new].	fields add: field! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/29/2004 16:27'!open	self morphicView openInWorld.	"self requestPackageList."! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:02'!returnTrue	^true! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 7/28/2004 18:00'!accountUpdatedWithUsername: newUsername  password:  newPassword  email: newEmail	self acceptFields.	username _ newUsername.	password _ newPassword.	email _ newEmail.		self changed: #username.	self changed: #password.	self changed: #email.		self closeAccountEditor! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 2/13/2005 16:31'!createAccount	self acceptFields.	email _ FillInTheBlankMorph request: 'your email address?'.	email = '' ifTrue: [ ^self ].	self sendMessage: (UMAddAccount username: username password: password email: email).	! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 2/13/2005 16:52'!editAccount	| editor |	self acceptFields.	self closeAccountEditor.		editor _ UAccountEditor		username: username		password: password		email:  ''		whenDone: [ :oldPassword :newPassword :newEmail |			password _ oldPassword.			self sendMessage: (UMEditAccount username: username password: password newPassword: newPassword newEmail: newEmail) ].			editor openInMorphic.		accountEditor _ editor.! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:25'!anyPackageSelected	^selectedPackageIndex > 0! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:26'!packageDescriptions	^self sortedPackages collect: [ :p |				p printString. ]! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 12/31/2006 16:13'!packagesChanged	self selectedPackageIndex: 0.		self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 7/29/2004 16:23'!requestPackageList	self sendMessage: (UMRequestPackages new).	! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!selectedPackage	^self sortedPackages at: self selectedPackageIndex! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!selectedPackageIndex	^selectedPackageIndex! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!selectedPackageIndex: anInteger	selectedPackageIndex _ anInteger.	self changed: #selectedPackageIndex.! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!sortedPackages	^universe packages asSortedCollection: [ :p1 :p2 |		p1 name < p2 name or: [			p1 name = p2 name and: [ p1 version < p2 version ] ] ].	! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!update: aSymbol	aSymbol = #packages ifTrue: [ self packagesChanged ]! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 11/16/2006 16:42'!createNewPackage	| package |	package := UPackage new.	Utilities authorInitialsPerSe ifNotNil: [		package maintainer: Utilities authorInitialsPerSe	].	^package! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 11/16/2006 16:42'!newPackage	| editor |	self acceptFields.	editor _ UPackageEditor package: self createNewPackage whenComplete: [ :p |		self acceptFields.		self sendMessage: (UMAddPackage username: username password: password package: p) ].	editor openInMorphic.	packageEditors add: editor.! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 2/15/2005 22:06'!newPackageVersion	| package editor newPackage |	self anyPackageSelected ifFalse: [ ^self ].	self acceptFields.	package _ self selectedPackage.		newPackage _ package deepCopy.	newPackage version: (UVersion readFromString: (newPackage version asString, 'new')).	editor _ UPackageEditor package: newPackage whenComplete: [ :p |		self acceptFields.		self sendMessage: (UMAddPackage username: username password: password package: p) ].	editor openInMorphic.	packageEditors add: editor.! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 2/13/2005 17:20'!removeVersion	| package |	self anyPackageSelected ifFalse: [ ^self ].	self acceptFields.	package _ self selectedPackage.	(self confirm: ('Delete ', 	package printString, '?')) ifFalse: [		^self ].	self sendMessage: (UMRemovePackage username: username password: password packageName: package name packageVersion: package version).! !!UUniverseEditor methodsFor: 'initialization' stamp: 'ls 2/13/2005 17:16'!initialize: universe0	universe _ universe0.	universe addDependent: self.	client _ UUniverseClient forUniverse: universe.	username _ Utilities authorInitialsPerSe.	password _ ''.		packageEditors _ Set new.	selectedPackageIndex _ 0.! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 15:54'!password	^password! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 16:18'!password: aString	password _ aString asString.	^true! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/29/2004 16:21'!universeDescription 	^universe description! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 15:53'!username	^username! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 16:13'!username: aString	username _ aString asString.	^true! !!UUniverseEditor methodsFor: 'networking' stamp: 'ls 2/13/2005 17:16'!processNetworking	client receivedMessagesDo: [ :message |		message applyToEditor: self ].! !!UUniverseEditor methodsFor: 'networking' stamp: 'ls 7/30/2004 15:40'!sendMessage: aMessage	client sendMessage: aMessage.	! !!UUniverseEditor methodsFor: 'stepping' stamp: 'ls 7/28/2004 17:01'!step	self processNetworking! !!UUniverseEditor methodsFor: 'stepping' stamp: 'ls 7/28/2004 17:01'!stepTimeIn: window	^10! !!UUniverseEditor methodsFor: 'stepping' stamp: 'ls 7/28/2004 17:01'!wantsSteps	^true! !!UUniverseEditor commentStamp: '<historical>' prior: 0!A tool for editing a remote universe.!!UUniverseEditor class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 10:23'!forUniverse: aStandardUniverse	^self basicNew		initialize: aStandardUniverse;		yourself! !!UUniverseEditor class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:13'!new	| choice choices |	choices := UUniverse systemUniverse standardUniverses asArray.	choices isEmpty ifTrue: [ ^self error: 'no standard universes installed' ].	choices size = 1 ifTrue: [		choice _ choices anyOne ]	ifFalse: [		| menu |		menu _			SelectionMenu				labels: (choices collect: [ :u | u description ])				selections: choices.		choice _ menu startUpWithCaption: 'edit which universe?'.		choice ifNil: [ ^self ] ].		^self forUniverse: choice! !!UUniverseEditor class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:13'!open	^self new open! !!UUniverseEditor class methodsFor: 'class initialization' stamp: 'ls 8/19/2007 12:30'!initialize	TheWorldMenu unregisterOpenCommand: 'Package Universe Editor'.	TheWorldMenu registerOpenCommand: {'Universe Editor'. {self. #open}}.	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UUniverseEditor class methodsFor: 'class initialization' stamp: 'ls 8/19/2007 12:30'!unload	TheWorldMenu unregisterOpenCommand: 'Universe Editor'! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/15/2005 22:00'!acceptConnection: stringSocket	stringSocket nextPut: (UMProtocolVersion version: 1) asStringArray.	connections add: stringSocket! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:29'!acceptConnectionOn: socket	self acceptConnection: (StringSocket on: socket).	! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:29'!checkForNewConnections	connectionQueue ifNil: [ ^self ].	[ connections size < 100 ] whileTrue: [		| newSocket |		newSocket _ connectionQueue getConnectionOrNil.		newSocket ifNil: [ ^self ].		connections add: (StringSocket on: newSocket) ].	! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:30'!destroyConnection: aConnection	aConnection destroy.	connections remove: aConnection ifAbsent: [].	! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:32'!processConnection: aConnection	| message |	aConnection isConnected ifFalse: [ ^self destroyConnection: aConnection ].		"process all incoming messages.  Note that some messages move the connection to one of the subsidiary servers, so be careful not to process messages after that happens"	aConnection processIO.	[ 	(connections includes: aConnection) and: [			message _ aConnection nextOrNil.	 	 	message notNil ]	] whileTrue: [	  	self processRawMessage: message fromConnection: aConnection ].	(connections includes: aConnection) ifFalse: [ ^self ].	aConnection isConnected		ifTrue: [ aConnection processIO.  "start sending out the response" ]		ifFalse: [ self destroyConnection: aConnection ]! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:30'!processConnections	connections copy do: [ :c |		self processConnection: c ]! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:51'!processNetworking	self checkForNewConnections.	self processConnections.! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 16:08'!startListening	self stopListening.	connectionQueue _ ConnectionQueue portNumber: port queueLength: 5.	! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 16:08'!stopListening		connectionQueue ifNotNil: [		connectionQueue destroy.		connectionQueue _ nil ].	! !!UUniverseMultiServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 14:33'!addServer: server	servers add: server! !!UUniverseMultiServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 14:49'!addServers: newServers	newServers do: [ :s | self addServer: s ]! !!UUniverseMultiServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 14:33'!initialize	servers _ Set new.	port _ UUniverseMultiServer defaultPort.	connections _ Set new.! !!UUniverseMultiServer methodsFor: 'messages' stamp: 'ls 2/13/2005 14:34'!processRawMessage: aStringArray  fromConnection: connection	| message |	message _ UMessage fromStringArray: aStringArray.	message applyToMultiServer: self forConnection: connection.! !!UUniverseMultiServer methodsFor: 'messages' stamp: 'ls 2/13/2005 16:18'!switchConnection: aConnection  toServerNamed: serverName	| server |	server _ servers detect: [ :s | s universe shortName = serverName ] ifNone: [		aConnection nextPut: (UMError description: 'no such server here') asStringArray.		^self ].	server acceptConnection: aConnection.	connections remove: aConnection.! !!UUniverseMultiServer methodsFor: 'stepping' stamp: 'ls 2/13/2005 14:50'!step	self processNetworking.	servers do: [ :server | server step ].! !!UUniverseMultiServer commentStamp: 'ls 2/13/2005 14:51' prior: 0!A multi-server server.  This listens on one port, and dispatches to whichever universe was requested.An active server needs someone to call #step periodically on it, in order for it to process networking, save checkpoints, etc.!!UUniverseMultiServer class methodsFor: 'defaults' stamp: 'ls 2/13/2005 14:32'!defaultPort	^3702! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 2/15/2005 22:00'!acceptConnection: stringSocket	stringSocket nextPut: (UMProtocolVersion version: 1) asStringArray.	connections add: stringSocket! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 11:02'!acceptConnectionOn: socket	self acceptConnection: (StringSocket on: socket).	! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 13:15'!checkForNewConnections	connectionQueue ifNil: [ ^self ].	[ connections size < 10 ] whileTrue: [		| newSocket |		newSocket _ connectionQueue getConnectionOrNil.		newSocket ifNil: [ ^self ].		connections add: (StringSocket on: newSocket) ].	! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 8/3/2004 18:10'!comancheServiceName	^'universe server on ', universe serverPort printString! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 10:47'!destroyConnection: aConnection	aConnection destroy.	connections remove: aConnection ifAbsent: [].! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 21:28'!processConnection: aConnection	| message |	aConnection isConnected ifFalse: [ ^self destroyConnection: aConnection ].		aConnection processIO.	[ 	message _ aConnection nextOrNil.	  	message notNil	] whileTrue: [	  	self processRawMessage: message fromConnection: aConnection ].	aConnection isConnected		ifTrue: [ aConnection processIO.  "start sending out the response" ]		ifFalse: [ self destroyConnection: aConnection ]! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 10:43'!processConnections	connections copy do: [ :c |		self processConnection: c ]! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 2/13/2005 15:19'!processNetworking	self checkForNewConnections.	self processConnections.	! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 13:21'!startListening	self stopListening.	connectionQueue _ ConnectionQueue portNumber: universe serverPort queueLength: 5.	! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 10:41'!stopListening		connectionQueue ifNotNil: [		connectionQueue destroy.		connectionQueue _ nil ].	! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:53'!connection: connection requestedAccountChangeForUsername: username  password: password  newPassword: newPassword newEmail: newEmail	| response |	response _ policy changeUser: username withPassword: password toHavePassword: newPassword andNewEmail: newEmail.	response allowed ifFalse: [		^self			sendError: 'changing account for ', username, ' failed (', response reason, ')'			onConnection: connection].			self sendMessage: (UMEditedAccount username: username newPassword: newPassword newEmail: newEmail) onConnection: connection! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:53'!connection: connection requestedAccountWithUsername: username  password: password  email: email 	| response |	response _ policy addUser: username withPassword: password andEmail: email.	response allowed ifFalse: [		self			sendError: 'adding account for ', username, ' failed (', response reason, ')'			onConnection: connection].! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:54'!connection: connection requestedForUsername: username  andPassword: password  toAddPackage: package	| response |	response _ policy package: package mayBeAddedBy: username withPassword: password.		response allowed		ifFalse: [			^self 				sendError: 'adding package ', package name, ' failed (', response reason, ')'				onConnection: connection].			universe addPackage: package.	self sendMessage: (UMPackageAdded package: package) onConnection: connection.! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:54'!connection: connection requestedForUsername: username  andPassword: password  toRemovePackageNamed: packageName withVersion: version	| packagesToRemove response |	response _ policy packageNamed: packageName withVersion: version mayBeRemovedBy: username withPassword: password.		response allowed ifFalse: [		^self 			sendError: 'removing package ', packageName, ' failed (', response reason, ')' 			onConnection: connection].			packagesToRemove := universe packages select: [ :p | p name = packageName and: [ p version = version ] ].	packagesToRemove do: [ :p |		universe removePackage: p ].		self sendMessage: (UMPackageRemoved packageName: packageName version: version) onConnection: connection.! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:20'!initializeForUniverse: aUniverse	universe _ aUniverse.	policy _ UPolicy new.	connectionQueue _ nil.	connections _ Set new.! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 13:44'!packageListFilename: filename	packageListFilename _ filename! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:32'!policy: aPolicy	policy _ aPolicy! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 09:16'!saveDirectory: aDirectory	saveDirectory _ aDirectory! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 7/29/2004 09:25'!loadFromCheckpoint	"reload from a checkpoint"	| file savedObject |	(saveDirectory isAFileNamed: 'checkpoint')		ifTrue: [ file _ saveDirectory readOnlyFileNamed: 'checkpoint' ]		ifFalse: [ file _ saveDirectory readOnlyFileNamed: 'checkpoint.die' ].	savedObject := file fileInObjectAndCode.	file close.		universe := savedObject first.	policy := savedObject second.	! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 2/13/2005 15:23'!possiblySaveCheckpointAndPackageList	saveDirectory ifNil: [^self].	(lastSaveTime isNil 		or: [DateAndTime now - lastSaveTime > (Duration minutes: 30)]) 			ifTrue: 				[self saveCheckpoint.				self savePackageList.				lastSaveTime := DateAndTime now]! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 2/13/2005 13:43'!saveCheckpoint	"save a checkpoint"	| tmpFile |	saveDirectory deleteFileNamed: 'checkpoint.tmp'.		tmpFile := saveDirectory newFileNamed: 'checkpoint.tmp'.	(SmartRefStream on: tmpFile) nextPut: {universe.policy}; close.		saveDirectory deleteFileNamed: 'checkpoint.die'.	saveDirectory rename: 'checkpoint.tmp' toBe: 'checkpoint'.		saveDirectory deleteFileNamed: 'checkpoint.die'.	! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 2/13/2005 13:44'!savePackageList	packageListFilename ifNotNil: [		UPackage savePackageList: universe packages onFileNamed: packageListFilename ]! !!UUniverseServer methodsFor: 'stepping' stamp: 'ls 8/2/2004 17:15'!openStepperMorph	(UServerStepperMorph new server: self; yourself) openInWorld! !!UUniverseServer methodsFor: 'stepping' stamp: 'ls 2/13/2005 15:23'!step	"do any necessary periodic work, including polling the network connections"	self processNetworking.	self possiblySaveCheckpointAndPackageList! !!UUniverseServer methodsFor: 'messages' stamp: 'ls 5/28/2007 17:32'!processRawMessage: aStringArray  fromConnection: connection	| message |	message _ UMessage fromStringArray: aStringArray.	message applyToServer: self forConnection: connection.	self logMessage: message.	! !!UUniverseServer methodsFor: 'messages' stamp: 'ls 7/28/2004 14:49'!sendError: description onConnection: stringSocket	self sendMessage: (UMError description: description) onConnection: stringSocket! !!UUniverseServer methodsFor: 'messages' stamp: 'ls 7/28/2004 11:48'!sendMessage: aMessage  onConnection: connection	connection nextPut: aMessage asStringArray  ! !!UUniverseServer methodsFor: 'accessing' stamp: 'ls 7/28/2004 13:08'!universe	^universe! !!UUniverseServer methodsFor: 'logging' stamp: 'ls 5/30/2007 11:40'!logMessage: message	| line |	logfile ifNil: [ ^self ].	line := message maybeLogMessage.	line ifNil: [ ^self ].	logfile		print: DateAndTime now;		space;		nextPutAll: line; 		cr.	logfile flush.! !!UUniverseServer methodsFor: 'logging' stamp: 'ls 5/28/2007 17:27'!logToFileNamed: filename	logfile := FileStream fileNamed: filename.	logfile setToEnd.	! !!UUniverseServer commentStamp: 'ls 2/13/2005 13:45' prior: 0!A server holding the authoratative information about a universe.  Clients may make requests to view and update the universe.The server does not manage its own thread; it requires that processNetworking is called periodically.!!UUniverseServer class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 09:29'!forSaveDirectory: aDirectory	| universe |	universe _ self forUniverse: UUniverse new.	universe saveDirectory: aDirectory.	universe loadFromCheckpoint.	^universe! !!UUniverseServer class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 10:31'!forUniverse: universe	^self basicNew initializeForUniverse: universe.	! !!UUniverseServer class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 10:31'!new	^self shouldNotImplement ! !!UUtilities commentStamp: 'ls 7/28/2004 10:35' prior: 0!Universe miscellania that belong to no particular object.!!UVersion methodsFor: 'comparing' stamp: 'ls 7/27/2004 21:15'!< aVersion	| numToCompare |	numToCompare := components size min: aVersion components size.	(components first: numToCompare) with: (aVersion components first: numToCompare) do: [ :myComp :itsComp |		(myComp uversionLessThan: itsComp) ifTrue: [			^true ].		(itsComp uversionLessThan: myComp) ifTrue: [			^false ] ].		^components size < aVersion components size! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/27/2004 17:31'!= aVersion	components size = aVersion components size ifFalse:[ ^false ].	components with: aVersion components do: [ :myComp :itsComp |		(myComp uversionEqual: itsComp) ifFalse: [			^false ] ].		^true! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/28/2004 10:02'!hash	^components inject: 1 into: [ :tally :new |		(tally bitXor: new hash) hashMultiply ]! !!UVersion methodsFor: 'attributes' stamp: 'ls 7/27/2004 17:33'!components	^components! !!UVersion methodsFor: 'initialization' stamp: 'ls 7/27/2004 17:27'!components: aCollection	components _ aCollection! !!UVersion methodsFor: 'printing' stamp: 'ls 7/27/2004 17:28'!printOn: aStream	components do: [ :comp | aStream nextPutAll: comp asString ].! !!UVersion methodsFor: 'conversion' stamp: 'ls 8/26/2007 09:15'!asUVersion	^self! !!UVersion commentStamp: '<historical>' prior: 0!A relatively simple hierarchical version number.!!UVersion class methodsFor: 'instance creation' stamp: 'ls 7/27/2004 17:24'!fromComponents: components	^self basicNew components: components; yourself! !!UVersion class methodsFor: 'instance creation' stamp: 'ls 7/27/2004 17:27'!readFrom: stream	| components |	components _ OrderedCollection new.	[ stream atEnd ] whileFalse: [		stream peek isDigit ifTrue: [			components add: (Integer readFrom: stream) ]		ifFalse: [			components add: (String streamContents: [ :compStr |				[ stream atEnd not and: [ stream peek isDigit not ] ] whileTrue: [					compStr nextPut: stream next ] ]) ] ].			^self fromComponents: components! !!UVersionTestCase methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:12'!setUp	typicalVersions := #(		'1'		'2'		'1.5.7'		'1.5.8'		'1.6.2'		'1.5'		'1.5a'		'1.5b'		'1.6'		'alpha'		'beta'	) collect: [ :str | UVersion readFromString: str ].	! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/27/2004 17:19'!testCompare	self should: [ (UVersion readFromString: '1') < (UVersion readFromString: '2') ].	self should: [ (UVersion readFromString: '1.5.7') < (UVersion readFromString: '1.5.8') ].	self should: [ (UVersion readFromString: '1.5.7') < (UVersion readFromString: '1.6.2') ].	self should: [ (UVersion readFromString: '1.5') < (UVersion readFromString: '1.5a') ].	self should: [ (UVersion readFromString: '1.5a') < (UVersion readFromString: '1.5b') ].	self should: [ (UVersion readFromString: '1.5b') < (UVersion readFromString: '1.6') ].! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/27/2004 17:24'!testFullOrder	"check that all versions are in some order"	typicalVersions do: [ :v1 |		typicalVersions do: [ :v2 |			self should: [				(v1 < v2)				or: [ (v2 < v1) 				or: [ v1 = v2 ] ] ] ] ]	! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/28/2004 09:59'!testHash	typicalVersions do: [ :v |		self should: [ v hash = v copy hash ] ].		self should: [ (UVersion readFromString: '1.5a') hash = (UVersion readFromString: '1.5a') hash ].! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/27/2004 17:23'!testReversedComparisons	"check that it is never the case that v1<v2 and v2<v1"	typicalVersions do: [ :v1 |		typicalVersions do: [ :v2 |			self should: [ (v1 < v2) not  or:  [  (v2 < v1) not ] ] ] ].	! !!UniclassScript methodsFor: 'access' stamp: 'sw 12/15/2004 20:46'!playerClass	"Answer the playerClass associated with the receiver"	^ playerClass ifNil:		[playerClass := currentScriptEditor playerScripted ifNotNil: [currentScriptEditor playerScripted class]]! !!UniclassScript methodsFor: 'initialization' stamp: 'sw 1/30/2001 11:37'!convertFromUserScript: aUserScript	"The argument represents an old UserScript object.  convert it over"	defaultStatus := aUserScript status.	isTextuallyCoded := aUserScript isTextuallyCoded.	currentScriptEditor := aUserScript currentScriptEditor.	formerScriptingTiles :=  aUserScript formerScriptEditors ifNotNil:		[aUserScript formerScriptEditors collect:			[:aScriptEditor |				Array with: aScriptEditor timeStamp with: aScriptEditor submorphs allButFirst]]! !!UniclassScript methodsFor: 'initialization' stamp: 'sw 1/26/2001 16:44'!initialize	"Initialize the receiver by setting its inst vars to default values"	super initialize.	isTextuallyCoded := false! !!UniclassScript methodsFor: 'initialization' stamp: 'sw 7/2/2002 14:13'!playerClass: aPlayerClass selector: aSelector	"Set the playerClass and selector of the receiver"	super playerClass: aPlayerClass selector: aSelector.	aSelector numArgs = 1 ifTrue:		[argumentVariables := {Variable new name: 'parameter' type: #Number}]! !!UniclassScript methodsFor: 'initialize-release' stamp: 'RAA 5/18/2001 13:25'!releaseCachedState	"release all non-showing scriptors.  What do we do about versions????"	"18 May 2001 - get more aggressive in dropping stuff"	formerScriptingTiles := OrderedCollection new.	currentScriptEditor ifNil: [^ self].	true ifTrue: [^ self].	"<<< to test the reconstruction of scripts, change to false"	currentScriptEditor world ifNil: ["not showing"		currentScriptEditor := nil]! !!UniclassScript methodsFor: 'script editor' stamp: 'sw 1/23/2001 17:12'!currentScriptEditor: anEditor	"Set the receiver's currentScriptEditor as indicated"	currentScriptEditor := anEditor! !!UniclassScript methodsFor: 'script editor' stamp: 'sw 7/20/2002 14:27'!instantiatedScriptEditorForPlayer: aPlayer	"Return the current script editor, creating it if necessary"	currentScriptEditor ifNil:		[currentScriptEditor := (self playerClass includesSelector: selector) 			ifTrue:				[Preferences universalTiles					ifFalse:						[self error: 'duplicate selector'].				ScriptEditorMorph new fromExistingMethod: selector forPlayer: aPlayer]			ifFalse:				[ScriptEditorMorph new setMorph: aPlayer costume scriptName: selector].		(defaultStatus == #ticking and: [selector numArgs == 0]) ifTrue:			[aPlayer costume arrangeToStartStepping]].		^ currentScriptEditor! !!UniclassScript methodsFor: 'textually coded' stamp: 'sw 3/28/2002 00:39'!becomeTextuallyCoded	"Transform the receiver into one which is textually coded"	isTextuallyCoded := true.	lastSourceString := (playerClass compiledMethodAt: selector) decompileString 		"Save this to compare when going back to tiles"! !!UniclassScript methodsFor: 'updating' stamp: 'sw 2/16/2001 00:46'!revertToLastSavedTileVersionFor: anEditor	"revert to the last saved tile version"	Preferences universalTiles		ifFalse:			[formerScriptingTiles isEmptyOrNil ifFalse:				[anEditor reinsertSavedTiles: formerScriptingTiles last second]]		ifTrue:			[anEditor removeAllButFirstSubmorph.			anEditor insertUniversalTiles].	anEditor showingMethodPane: false.	isTextuallyCoded := false! !!UniclassScript methodsFor: 'updating' stamp: 'sw 2/18/2001 18:27'!saveScriptVersion: timeStamp	"Save the tile script version by appending a pair of the form		<time stamp>     <morph list>to my list of former scripting tiles.  The morph-list will get copied back into the Scriptor following restoration.  Only applies to classic tiles."	Preferences universalTiles ifFalse:  "the following only applies to Classic tiles"		[(currentScriptEditor notNil and: [currentScriptEditor showingMethodPane not]) ifTrue:				[formerScriptingTiles ifNil: [formerScriptingTiles := OrderedCollection new].				formerScriptingTiles add:					(Array with: timeStamp						with: (currentScriptEditor submorphs allButFirst collect: [:m | m veryDeepCopy])).				formerScriptingTiles size > 100 ifTrue: [^ self halt: 'apparent runaway versions, proceed at your own risk.']]]! !!UniclassScript methodsFor: 'versions' stamp: 'di 2/19/2001 10:09'!recreateScriptFrom: anEditor	"Used to revert to old tiles"	formerScriptingTiles isEmptyOrNil ifTrue: [^ self].	anEditor reinsertSavedTiles: formerScriptingTiles last second.	isTextuallyCoded := false! !!Unicode commentStamp: 'yo 10/19/2004 20:44' prior: 0!This class holds the entry points for the utility functions around characters.!!Unicode class methodsFor: 'character classification' stamp: 'kwl 6/30/2006 02:55'!isDigit: char 	| value |	value := char charCode.	value > (GeneralCategory size - 1)		ifTrue: [^ false].	^ (GeneralCategory at: value + 1)		= Nd! !!Unicode class methodsFor: 'character classification' stamp: 'kwl 6/30/2006 02:56'!isLetter: char 	| value codeCat |	value := char charCode.	value > (GeneralCategory size - 1)		ifTrue: [^ false].	^ (codeCat := GeneralCategory at: value + 1) >= Ll		and: [codeCat <= Lu]! !!Unicode class methodsFor: 'character classification' stamp: 'kwl 6/30/2006 02:57'!isLowercase: char 	| value |	value := char charCode.	value > (GeneralCategory size - 1)		ifTrue: [^ false].	^ (GeneralCategory at: value + 1)		= Ll! !!Unicode class methodsFor: 'character classification' stamp: 'kwl 6/30/2006 02:58'!isUppercase: char 	| value |	value := char charCode.	value > (GeneralCategory size - 1)		ifTrue: [^ false].	^ (GeneralCategory at: value + 1)		= Lu! !!Unicode class methodsFor: 'class initialization' stamp: 'kwl 6/30/2006 02:53'!initialize	" Unicode initialize "	(self classPool keys		select: [:sym | sym size = 2 and: sym first isUppercase and: sym last isLowercase]) asSortedCollection		inject: 1		into: [:index :sym | sym = #Cn				ifTrue: [self classPool at: sym put: 0. index]				ifFalse: [self classPool at: sym put: index. index + 1]]! !!UnimplementedCallBugz methodsFor: 'as yet unclassified' stamp: 'wiz 5/3/2007 19:53'!testPolyIntersect"self run: #testPolyIntersect"self shouldnt: [ PolygonMorph initializedInstance 					intersects: ( Rectangle center: Display center 											extent: 100 asPoint ) ] 	raise: Error .! !!UnscriptedPlayer methodsFor: 'viewer' stamp: 'sw 1/30/2001 22:43'!assureUniClass	"Create a uniclass and become the receiver into it"	| anInstance |	anInstance := self rootClassForUniclasses instanceOfUniqueClass.	anInstance initializeCostumesFrom: self.	self become: anInstance.	^ anInstance! !!UnscriptedPlayer class methodsFor: 'namespace' stamp: 'sw 9/30/1998 09:05'!referenceSelectorFor: anObject	"The use of this is for immediate evaluation of lines of script in a Viewer.  The class inst var 'ephemeralPlayerRef' is constantly reused for this purpose."	ephemeralPlayerRef := anObject.	^ 'ephemeralPlayerRef'! !!UpdatingMenuItemMorph methodsFor: 'wording' stamp: 'wiz 2/11/2008 16:52'!target: anObject"For us if the old target and wording provider are the same update both."target = wordingProvider 	ifTrue: [ wordingProvider := target := anObject ]	ifFalse: [  target := anObject ] .! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 9/4/97 21:43'!contents: c	contents := c! !!UpdatingRectangleMorph methodsFor: 'accessing'!getSelector: aSymbol	getSelector := aSymbol.! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 10/30/97 00:55'!putSelector: aSymbol	putSelector := aSymbol! !!UpdatingRectangleMorph methodsFor: 'accessing'!target: anObject	target := anObject.! !!UpdatingRectangleMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:17'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].! !!UpdatingRectangleMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:17'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target := target.		Weakly copied"lastValue := lastValue veryDeepCopyWith: deepCopier."getSelector := getSelector.		a Symbol""putSelector := putSelector.		a Symbol"contents := contents veryDeepCopyWith: deepCopier.! !!UpdatingRectangleMorph methodsFor: 'setting' stamp: 'sw 3/23/2001 23:26'!setTargetColor: aColor	"Set my target's color as indicated"	putSelector ifNotNil:		[self color: aColor.		contents := aColor.		self valueProvider perform: self putSelector withArguments: (Array with: aColor)]! !!UpdatingRectangleMorph methodsFor: 'stepping and presenter' stamp: 'sw 7/15/1999 07:27'!step	| s |	super step.	s := self readFromTarget.	s = contents ifFalse:		[self contents: s.		self color: s]! !!UpdatingStringMorph methodsFor: '*eToys-target access' stamp: 'sw 3/7/2004 15:49'!hasStructureOfComplexWatcher	"Answer whether the receiver has precisely the structure of a so-called complex watcher, as used in the etoy system."	| top |	top := (self owner ifNil: [^ false]) owner.	^ ((((top isMemberOf: AlignmentMorph)		and: [top submorphs size = 4])			and: [top submorphs first isMemberOf: TileMorph])				and: [top submorphs third isMemberOf: AlignmentMorph])! !!UserCustomEventNameType methodsFor: 'queries' stamp: 'nk 9/26/2003 23:36'!choices	"Answer an alphabetized list of known user custom event selectors"	| choices |	choices := ScriptingSystem userCustomEventNames.	^choices isEmpty ifTrue: [ #('no event') ] ifFalse: [ choices ]! !!UserScript methodsFor: 'script editor' stamp: 'sw 1/29/98 22:55'!currentScriptEditor: anEditor	currentScriptEditor := anEditor! !!UserScript methodsFor: 'script editor' stamp: 'sw 1/23/2001 11:28'!instantiatedScriptEditor	"Return the current script editor, creating it if necessary"	self isTextuallyCoded ifTrue:			[^ (player costume pasteUpMorph ifNil: [player costume "the world, backstop"]) scriptorForTextualScript: selector ofPlayer: player].	currentScriptEditor ifNil:		[currentScriptEditor := (player class includesSelector: selector) 			ifTrue: [ScriptEditorMorph new 				fromExistingMethod: selector 				forPlayer: player]			ifFalse: [ScriptEditorMorph new				setMorph: player costume				scriptName: selector].		status == #ticking ifTrue: [player costume arrangeToStartStepping]].		^ currentScriptEditor! !!UserScript methodsFor: 'script editor' stamp: 'tk 11/30/2000 16:32'!releaseCachedState	"release all non-showing scriptors.  What do we do about versions????"	self isTextuallyCoded ifTrue: [formerScriptEditors := OrderedCollection new].		"to test new tiles.  We 'commit' to current script."	currentScriptEditor ifNil: [^ self].	true ifTrue: [^ self].	"<<< to test the reconstruction of scripts, change to false"	currentScriptEditor world ifNil: ["not showing"		currentScriptEditor := nil].! !!UserScript methodsFor: 'textually coded' stamp: 'sw 5/19/1998 14:13'!becomeTextuallyCoded	currentScriptEditor := #textuallyCoded! !!UserScript methodsFor: 'updating' stamp: 'sw 1/22/2001 16:45'!updateToPlayer: aPlayer	"Set aPlayer as the current player referenced by the receiver and its script editor"	(currentScriptEditor notNil and: [currentScriptEditor ~~ #textuallyCoded]) ifTrue:		[currentScriptEditor updateToPlayer: aPlayer].	player := aPlayer! !!UserScript methodsFor: 'versions' stamp: 'sw 10/30/2000 08:54'!revertScriptVersionFrom: anEditor installing: aSavedEditor	"Replace anEditor with a brought-up-to-date version of aSavedEditor"	| aPosition oldOwner |	aPosition := anEditor position.	oldOwner := anEditor topRendererOrSelf owner.	anEditor delete.	currentScriptEditor := aSavedEditor bringUpToDate install.	player costume viewAfreshIn: oldOwner showingScript: selector at: aPosition! !!Utilities class methodsFor: 'fetching updates' stamp: 'edc 7/28/2007 10:51'!extractThisVersion: list	"Pull out the part of the list that applies to this version."	| listContents version versIndex |	listContents _ self parseListContents: list.	version _ SystemVersion current version.		versIndex _ (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue: [^ Array new].		"abort"	^ (listContents at: versIndex) last! !!Utilities class methodsFor: 'fetching updates' stamp: 'edc 7/28/2007 10:45'!newUpdatesOn: serverList special: indexPrefix throughNumber: aNumber	"Return a list of fully formed URLs of update files we do not yet have.  Go to the listed servers and look at the file 'updates.list' for the names of the last N update files.  We look backwards for the first one we have, and make the list from there.  tk 9/10/97	No updates numbered higher than aNumber (if it is not nil) are returned " 	| existing doc list out ff raw char maxNumber itsNumber |	maxNumber _ aNumber ifNil: [99999].	out _ OrderedCollection new.	existing _ SystemVersion current updates.	serverList do: [:server |		doc _ HTTPClient httpGet: 'http://' , server,indexPrefix,'updates.list'.				"test here for server being up"		doc class == RWBinaryOrTextStream ifTrue:			[raw _ doc reset; contents.	"one file name per line"			list _ self extractThisVersion: raw.			list reverseDo: [:fileName |				ff _ (fileName findTokens: '/') last.	"allow subdirectories"				itsNumber _ ff initialIntegerOrNil. 				(existing includes: itsNumber)					ifFalse:						[						(itsNumber == nil or: [itsNumber <= maxNumber])							ifTrue:								[out addFirst: 'http://' , server, fileName]]					ifTrue: [^ out]].			((out size > 0) or: [char _ doc reset; skipSeparators; next.				(char == $*) | (char == $#)]) ifTrue:					[^ out "we have our list"]].	"else got error msg instead of file"		"Server was down, try next one"].	self inform: 'All code update servers seem to be unavailable'.	^ out! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'sw 1/28/1999 12:35'!contents: newContents	contents := newContents.	self contentsChanged! !!VariableDock methodsFor: 'getters and setters' stamp: 'sw 10/30/2000 10:55'!computePlayerGetterAndSetterSelectors	"Compute and remember the getter and setter selectors for obtaining and setting values from the player instance"	playerGetSelector := Utilities getterSelectorFor: variableName.	playerPutSelector := Utilities setterSelectorFor: variableName! !!VariableDock methodsFor: 'initialization' stamp: 'sw 10/30/2000 08:52'!variableName: aSymbol type: aType definingMorph: aMorph morphGetSelector: getterSymbol morphPutSelector: putterSymbol	"Initialize the receiver as indicated"	variableName := aSymbol asSymbol.	type := aType.	definingMorph := aMorph.	morphGetSelector := getterSymbol.	morphPutSelector := putterSymbol.	self computePlayerGetterAndSetterSelectors! !!VariableDock methodsFor: 'name' stamp: 'sw 10/30/2000 08:51'!variableName: aSymbol	"Set the receiver's variableName as indicated, and recompute corresponding getters and setters"	variableName := aSymbol asSymbol.	self computePlayerGetterAndSetterSelectors! !!VariableNode methodsFor: '*eToys-tiles' stamp: 'ab 7/13/2004 13:53'!explanation	self isSelfPseudoVariable ifTrue: [^'the pseudo variable <self> (refers to the receiver)'].	^(#('instance' 'temporary' 'LIT3' 'global') 			at: self type 			ifAbsent: ['UNK',self type printString]),' variable <',self name,'>'			"LdInstType := 1.	LdTempType := 2.	LdLitType := 3.	LdLitIndType := 4."! !!VariableNode methodsFor: '*eToys-tiles' stamp: 'ab 7/13/2004 13:54'!variableGetterBlockIn: aContext	| temps index ivars |	(self type = 4 and: [self key isVariableBinding]) ifTrue: [		^[self key value]	].	aContext ifNil: [^nil].	self isSelfPseudoVariable ifTrue: [^[aContext receiver]].	self type = 1 ifTrue: [		ivars := aContext receiver class allInstVarNames.		index := ivars indexOf: self name ifAbsent: [^nil].		^[aContext receiver instVarAt: index]	].	self type = 2 ifTrue: [		temps := aContext tempNames.		index := temps indexOf: self name ifAbsent: [^nil].		^[aContext tempAt: index]	].	^nil! !!View methodsFor: 'bordering' stamp: 'tk 10/21/97 12:31'!backgroundColor: aColor	Display depth = 1 ifTrue:		[(aColor ~= nil and: [aColor isTransparent not]) ifTrue:			["Avoid stipple due to attempts to match non-whites"			^ insideColor := Color white]].	insideColor := aColor! !!View methodsFor: 'bordering'!borderWidthLeft: anInteger1 right: anInteger2 top: anInteger3 bottom: anInteger4	"Set the border widths of the receiver. These arguments represent the left, 	right, top, and bottom border widths."	borderWidth :=			Rectangle				left: anInteger1				right: anInteger2				top: anInteger3				bottom: anInteger4.	self unlock! !!View methodsFor: 'bordering'!foregroundColor: aColor	borderColor := aColor! !!View methodsFor: 'controller access'!model: aModel controller: aController 	"Set the receiver's model to aModel, add the receiver to aModel's list of 	dependents, and set the receiver's controller to aController. Subsequent 	changes to aModel (see Model|change) will result in View|update: 	messages being sent to the receiver. #NoControllerAllowed for the value 	of aController indicates that no default controller is available; nil for the 	value of aController indicates that the default controller is to be used 	when needed. If aController is neither #NoControllerAllowed nor nil, its 	view is set to the receiver and its model is set to aModel."	model ~~ nil & (model ~~ aModel)		ifTrue: [model removeDependent: self].	aModel ~~ nil & (aModel ~~ model)		ifTrue: [aModel addDependent: self].	model := aModel.	aController ~~ nil		ifTrue: 			[aController view: self.			aController model: aModel].	controller := aController! !!View methodsFor: 'display box access'!computeBoundingBox	"Answer the minimum Rectangle that encloses the bounding boxes of the 	receiver's subViews. If the receiver has no subViews, then the bounding 	box is the receiver's window. Subclasses should redefine 	View|boundingBox if a more suitable default for the case of no subViews 	is available."	| aRectangle |	subViews isEmpty ifTrue: [^self getWindow].	aRectangle := self firstSubView transform: self firstSubView boundingBox.	subViews do: 		[:aView | 		aRectangle := aRectangle merge: (aView transform: aView boundingBox).].	^aRectangle expandBy: borderWidth! !!View methodsFor: 'display box access' stamp: 'acg 2/23/2000 00:08'!insetDisplayBox	"Answer the receiver's inset display box. The inset display box is the 	intersection of the receiver's window, tranformed to display coordinates, 	and the inset display box of the superView, inset by the border width. 	The inset display box represents the region of the display screen in 	which the inside of the receiver (all except the border) is displayed. If 	the receiver is totally clipped by the display screen and its superView, 	the resulting Rectangle will be invalid."	insetDisplayBox ifNil: [insetDisplayBox := self computeInsetDisplayBox].	^insetDisplayBox! !!View methodsFor: 'display transformation'!displayTransformation	"Answer a WindowingTransformation that is the result of composing all 	local transformations in the receiver's superView chain with the 	receiver's own local transformation. The resulting transformation 	transforms objects in the receiver's coordinate system into objects in the 	display screen coordinate system."	displayTransformation == nil		ifTrue: [displayTransformation := self computeDisplayTransformation].	^displayTransformation! !!View methodsFor: 'displaying'!displayClippingTo: rect	| bigRect |	bigRect := rect insetBy: -1.	self clippingTo: bigRect do: [Display clippingTo: bigRect do: [self display]]! !!View methodsFor: 'initialize-release'!initialize	"Initialize the state of the receiver. Subclasses should include 'super 	initialize' when redefining this message to insure proper initialization."	self resetSubViews.	transformation := WindowingTransformation identity.	self borderWidth: 0! !!View methodsFor: 'initialize-release'!release	"Remove the receiver from its model's list of dependents (if the model	exists), and release all of its subViews. It is used to break possible cycles	in the receiver and should be sent when the receiver is no longer needed.	Subclasses should include 'super release.' when redefining release."	model removeDependent: self.	model := nil.	controller release.	controller := nil.	subViews ~~ nil ifTrue: [subViews do: [:aView | aView release]].	subViews := nil.	superView := nil! !!View methodsFor: 'initialize-release'!setDefaultBackgroundColor	"Obtain the background color from the receiver's model, unless the #uniformWindowColors preference is set to true, in which case obtain it from generic Object; and install it as the receiver's background color.  5/1/96 sw"	| colorToUse |	colorToUse := Preferences uniformWindowColors		ifTrue:			[Object new defaultBackgroundColor]		ifFalse:			[model defaultBackgroundColor].	self backgroundColor: colorToUse! !!View methodsFor: 'lock access'!lock	"'Lock' the receiver and all of its subViews (see View|isLocked). This has 	the effect of computing and storing the display transformation (see 	View|displayTransformation) and inset display box (see 	View|insetDisplayBox) of the receiver and all its subViews. The locking 	and unlocking of a View is handled automatically by the internal 	methods of the View, but can also be done explicitly if desired."	self isLocked ifTrue: [^self].	displayTransformation := self computeDisplayTransformation.	insetDisplayBox := self computeInsetDisplayBox.	subViews do: [:aSubView | aSubView lock]! !!View methodsFor: 'lock access'!unlock	"Unlock the receiver and all of its subViews (see View|isUnlocked). This 	has the effect of forcing the display transformation (see 	View|displayTransformation) and inset display box (see 	View|insetDisplayBox) of the receiver and all its subViews to be 	recomputed the next time they are referenced. The locking and 	unlocking of a View is handled automatically by the internal methods of 	the View, but can also be done explicitly if desired."	self isUnlocked ifTrue: [^self].	displayTransformation := nil.	insetDisplayBox := nil.	subViews do: [:aSubView | aSubView unlock]! !!View methodsFor: 'miscellaneous' stamp: 'JMM 10/21/2003 18:12'!stretchFrame: newFrameBlock startingWith: startFrame 	"Track the outline of a newFrame as long as mouse drags it.	Maintain max and min constraints throughout the drag"	| frame newFrame click delay |	delay := Delay forMilliseconds: 10.	frame := startFrame origin extent: ((startFrame extent min: self maximumSize)											max: self minimumSize).	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	click := false.	[click and: [Sensor noButtonPressed]] whileFalse: 		[delay wait.		click := click | Sensor anyButtonPressed.		newFrame := newFrameBlock value: frame.		newFrame := newFrame topLeft extent: ((newFrame extent min: self maximumSize)											max: self minimumSize).		newFrame = frame ifFalse:			[Display border: frame width: 2 rule: Form reverse fillColor: Color gray.			Display border: newFrame width: 2 rule: Form reverse fillColor: Color gray.			frame := newFrame]].	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	^ frame! !!View methodsFor: 'scrolling'!scrollBy: aPoint 	"The x component of aPoint specifies the amount of scrolling in the x 	direction; the y component specifies the amount of scrolling in the y 	direction. The amounts are specified in the receiver's local coordinate 	system. Scroll the receiver up or down, left or right. The window of the 	receiver is kept stationary and the subViews and other objects in the 	receiver are translated relative to it. Scrolling doesn't change the 	insetDisplayBox or the viewport since the change in the transformation 	is canceled by the change in the window. In other words, all display 	objects in the view, except the window, are translated by the scrolling 	operation.	Note: subclasses may override to return false if no scrolling takes place."	| aRectangle |	aRectangle := insetDisplayBox.	transformation := transformation scrollBy: aPoint.	window := self getWindow translateBy: aPoint x negated @ aPoint y negated.	self unlock.	insetDisplayBox := aRectangle.	^ true! !!View methodsFor: 'subView access'!resetSubViews	"Set the list of subviews to an empty collection."		subViews := OrderedCollection new! !!View methodsFor: 'testing'!isObscured	| topController displayRect |	(topController := self topView controller)		== ScheduledControllers activeController			ifTrue: [^false].	displayRect := self insetDisplayBox.	ScheduledControllers scheduledControllers do: [:ctrlr |		ctrlr == topController ifTrue: [^false].		(displayRect intersects: ctrlr view insetDisplayBox)			ifTrue: [^true]].	self error: 'not in ScheduledControllers'.	^false! !!View methodsFor: 'window access'!defaultWindow	"Build the minimum Rectangle that encloses all the windows of the 	receiver's subViews. The answer is a Rectangle obtained by expanding 	this minimal Rectangle by the borderWidth of the receiver. If the 	receiver has no subViews, then a Rectangle enclosing the entire display 	screen is answered. It is used internally by View methods if no window 	has been specified for the View. Specialized subclasses of View should 	redefine View|defaultWindow to handle the default case for instances 	that have no subViews."	| aRectangle |	subViews isEmpty ifTrue: [^DisplayScreen boundingBox].	aRectangle := self firstSubView viewport.	subViews do: [:aView | aRectangle := aRectangle merge: aView viewport].	^aRectangle expandBy: borderWidth! !!View methodsFor: 'private'!getViewport	"Answer the Rectangle representing the View's viewport (in the	coordinate system of the superclass). If no viewport has been specified,	the View's window transformed into the superView's coordinate system is	saved and returned. It should be used by methods of View and subclasses	(instead of directly referring to the viewport) unless it is known that a	viewport actually exists. It should not be used outside of View or	subclasses because the viewport is not sharable."	viewport == nil ifTrue: [viewport := (self transform: self getWindow) truncated].	^viewport! !!View methodsFor: 'private'!setTransformation: aTransformation 	"Set the View's local transformation to aTransformation, unlock the View 	(see View|unlock), and set the viewport to undefined (this forces it to be 	recomputed when needed). Should be used instead of setting the 	transformation directly."	transformation := aTransformation.	self unlock.	viewport := nil! !!View methodsFor: 'private'!setWindow: aWindow 	"Set the View's window to aWindow and unlock the View (see	View|unlock). View|setWindow should be used by methods of View and	subclasses to set the View window (rather than directly setting the	instance variable) to insure that the View is unlocked."	window := aWindow.	viewport := nil.	self unlock! !!View methodsFor: 'private'!superView: aView 	"Set the View's superView to aView and unlock the View (see	View|unlock). It is sent by View|addSubView: in order to properly set all	the links."	superView := aView.	self unlock! !!Viewer methodsFor: 'access' stamp: 'sw 10/20/1998 13:20'!scriptedPlayer: aPlayer	scriptedPlayer := aPlayer! !!Viewer methodsFor: 'commands' stamp: 'yo 1/14/2005 19:57'!chooseVocabulary	"Put up a menu allowing the user to specify which protocol to use in this viewer"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'Choose a vocabulary' translated.	"aMenu addStayUpItem."  "For debugging only"	Vocabulary allStandardVocabularies do:		[:aVocabulary |			(scriptedPlayer class implementsVocabulary: aVocabulary)				ifTrue:					[aMenu add: aVocabulary vocabularyName selector: #switchToVocabulary: argument: aVocabulary.					aVocabulary == self currentVocabulary ifTrue:						[aMenu lastItem color: Color blue]. 					aMenu balloonTextForLastItem: aVocabulary documentation]].	aMenu popUpInWorld: self currentWorld! !!Viewer methodsFor: 'commands' stamp: 'sw 1/26/2001 15:26'!newPermanentScript	"Create a new, empty script and attach it to the hand"	| aMorph |	self scriptedPlayer assureUniClass.	aMorph := ImageMorph new image: (ScriptingSystem formAtKey: 'newScript').	aMorph setProperty: #newPermanentScript toValue: true.	aMorph setProperty: #newPermanentPlayer toValue: self scriptedPlayer.	self primaryHand attachMorph: aMorph! !!Viewer methodsFor: 'commands' stamp: 'nb 6/17/2003 12:25'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList := (aPlayer := scriptedPlayer) availableCostumesForArrows.	aList isEmptyOrNil ifTrue: [^ Beeper beep].	itsCurrent := aPlayer costume renderedMorph.	anIndex := aList indexOf: itsCurrent ifAbsent: [nil].	newIndex := anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex := 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter ifNotNil: [self presenter updateViewer: self]! !!Viewer methodsFor: 'commands' stamp: 'nb 6/17/2003 12:25'!previousCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList := (aPlayer := scriptedPlayer) availableCostumesForArrows.	aList isEmptyOrNil ifTrue: [^ Beeper beep].	itsCurrent := aPlayer costume renderedMorph.	anIndex := aList indexOf: itsCurrent ifAbsent: [nil].	newIndex := anIndex		ifNil:		[aList size]		ifNotNil:	[anIndex - 1].	newIndex < 1 ifTrue: [newIndex := aList size].	aPlayer renderedCostume: (aList at: newIndex).	self presenter ifNotNil: [self presenter updateViewer: self]! !!Viewer methodsFor: 'copying' stamp: 'tk 1/7/1999 17:01'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.scriptedPlayer := deepCopier references at: scriptedPlayer ifAbsent: [scriptedPlayer].! !!Viewer methodsFor: 'copying' stamp: 'tk 1/8/1999 07:42'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.scriptedPlayer := scriptedPlayer.		"Weakly copied"	"Store into it to satisfy checkVariables"! !!Viewer methodsFor: 'queries'!aboutMethod: aSelector 	"Give the user documentation for the selector"	| aClass help |	aClass := scriptedPlayer class whichClassIncludesSelector: aSelector.	help := aClass firstCommentAt: aSelector.	help		ifNotNil: [self				inform: (help string withNoLineLongerThan: 25)]! !!Viewer methodsFor: 'queries'!browseMethodFull: aSelector 	"Open a traditional browser on aSelector, in whatever class implements 	aSelector "	| aClass |	aClass := scriptedPlayer class whichClassIncludesSelector: aSelector.	Browser fullOnClass: aClass selector: aSelector! !!Viewer methodsFor: 'queries' stamp: 'sd 1/16/2004 21:10'!browseMethodInheritance: aSelector 	"Open an inheritance browser on aSelector"	| aClass |	aClass := scriptedPlayer class whichClassIncludesSelector: aSelector.	self systemNavigation methodHierarchyBrowserForClass: aClass selector: aSelector! !!Viewer methodsFor: 'queries'!browseVersionsOf: aSelector 	"Open a browser on versions of aSelector"	| aClass |	aClass := scriptedPlayer class whichClassIncludesSelector: aSelector.	Utilities browseVersionsForClass: aClass selector: aSelector! !!Viewer methodsFor: 'special phrases' stamp: 'yo 6/18/2004 16:01'!angleToPhrase	| outerPhrase getTile |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Number				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	getTile := KedamaAngleToTile new.	outerPhrase addMorphBack: getTile.	^outerPhrase! !!Viewer methodsFor: 'special phrases' stamp: 'yo 9/28/2004 18:24'!bounceOnColorPhrase	| outerPhrase bounceOn |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Boolean				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	bounceOn := KedamaBounceOnColorTile new.	"upHill setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer)."	outerPhrase addMorphBack: bounceOn.	^outerPhrase.! !!Viewer methodsFor: 'special phrases' stamp: 'yo 9/27/2004 15:07'!bounceOnPhrase	| outerPhrase upHill |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Boolean				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	upHill := KedamaBounceOnTile new.	"upHill setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer)."	outerPhrase addMorphBack: upHill.	^outerPhrase.! !!Viewer methodsFor: 'special phrases' stamp: 'yo 10/12/2004 22:56'!colorComponentPhraseFor: componentName	| outerPhrase getTile |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Number				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	getTile := KedamaGetColorComponentTile new.	getTile componentName: componentName.	getTile setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer).	outerPhrase addMorphBack: getTile.	^outerPhrase! !!Viewer methodsFor: 'special phrases' stamp: 'yo 6/18/2004 16:01'!distanceToPhrase	| outerPhrase getTile |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Number				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	getTile := KedamaDistanceToTile new.	outerPhrase addMorphBack: getTile.	^outerPhrase! !!Viewer methodsFor: 'special phrases' stamp: 'yo 6/18/2004 16:02'!patchUphillPhrase	| outerPhrase upHill |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Number				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	upHill := KedamaUpHillTile new.	upHill setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer).	outerPhrase addMorphBack: upHill.	^outerPhrase.! !!Viewer methodsFor: 'special phrases' stamp: 'yo 6/18/2004 16:50'!patchValuePhrase	| outerPhrase getTile |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Number				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	getTile := KedamaGetPixelValueTile new.	getTile setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer).	outerPhrase addMorphBack: getTile.	^outerPhrase! !!Viewer methodsFor: 'special phrases' stamp: 'dgd 2/22/2003 19:02'!seesColorPhrase	"In classic tiles, answer a complete phrase that represents the seesColor test"	| outerPhrase seesColorTile |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Boolean				rcvrType: #Player				argType: #Color.	"temp dummy"	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs second) delete.	"operator"	seesColorTile := TileMorph new setOperator: #seesColor:.	outerPhrase addMorphBack: seesColorTile.	(outerPhrase submorphs second) goBehind.	"Make it third"	"	selfTile := self tileForSelf bePossessive.	Done by caller.	selfTile position: 1.	outerPhrase firstSubmorph addMorph: selfTile."	outerPhrase submorphs last addMorph: (ColorTileMorph new 				typeColor: (ScriptingSystem colorForType: #Color)).	^outerPhrase! !!Viewer methodsFor: 'special phrases' stamp: 'yo 3/7/2005 08:39'!turtleOfPhrase	| outerPhrase getTile |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Player				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	getTile := KedamaTurtleOfTile new.	outerPhrase addMorphBack: getTile.	^outerPhrase! !!Viewer methodsFor: 'transition' stamp: 'sw 11/5/1998 15:48'!noteDeletionOf: aMorph	| pal |	aMorph player == scriptedPlayer ifTrue:		[(pal := self standardPalette)			ifNotNil: [pal showNoPalette]			ifNil:	[self delete]]   "Viewer on a discarded player"! !!ViewerLine methodsFor: 'access' stamp: 'sw 10/30/2001 12:43'!elementSymbol: aSymbol	"Set the element symbol"	elementSymbol := aSymbol! !!ViewerLine methodsFor: 'access' stamp: 'yo 4/1/2005 10:55'!morphsBearingPlayers	| c |	c := OrderedCollection new.	self allMorphsWithPlayersDo: [:e :p | c add: e].	^ c asArray.! !!ViewerLine methodsFor: 'access' stamp: 'yo 4/6/2005 14:59'!replacePlayerInReadoutWith: aPlayer 	| tile |	tile := self firstMorphBearingKedamaPlayer.	tile ifNil: [^ self].	(tile isMemberOf: TileMorph) ifFalse: [^ self].	tile type = #objRef ifFalse: [^ self].	tile referToSimilarObject: aPlayer.	self allMorphsDo: [:e |		((e isMemberOf: UpdatingStringMorph) or: [e isMemberOf: UpdatingRectangleMorph]) ifTrue: [			e target isPlayerLike ifTrue: [				e target: aPlayer			].		].	].! !!ViewerLine methodsFor: 'access' stamp: 'yo 4/6/2005 14:59'!replacePlayerWith: aPlayer	| tile |	tile := self firstMorphBearingKedamaPlayer.	tile ifNil: [^ self].	(tile isMemberOf: TileMorph) ifFalse: [^ self].	tile type = #objRef ifFalse: [^ self].	tile referToSimilarObject: aPlayer.! !!ViewerLine methodsFor: 'slot' stamp: 'sw 6/6/2003 21:47'!addCommandFeedback	"Add screen feedback showing what would be torn off in a drag"	| aMorph |	aMorph := RectangleMorph new bounds: ((submorphs fourth topLeft - (2@1)) corner: (submorphs last bottomRight) + (2@0)).	aMorph useRoundedCorners; beTransparent; borderWidth: 2; borderColor: (Color r: 1.0 g: 0.548 b: 0.452); lock.	aMorph setProperty: #highlight toValue: true.	ActiveWorld addMorphFront: aMorph! !!ViewerLine methodsFor: 'slot' stamp: 'sw 8/31/2004 23:50'!addGetterFeedback	"Add feedback during mouseover of a getter"	| aMorph endMorph |	endMorph :=		(#(touchesA: #seesColor: #overlaps:) includes: self elementSymbol)			ifTrue:				[submorphs eighth]			ifFalse:				[submorphs sixth].	aMorph := RectangleMorph new useRoundedCorners bounds: ((submorphs fourth topLeft - (2@-1)) corner: (endMorph bottomRight + (2@-1))).	aMorph beTransparent; borderWidth: 2; borderColor: (Color r: 1.0 g: 0.355 b: 0.839); lock.	aMorph setProperty: #highlight toValue: true.	ActiveWorld addMorphFront: aMorph"Color fromUser (Color r: 1.0 g: 0.355 b: 0.839)"! !!ViewerLine methodsFor: 'slot' stamp: 'sw 5/22/2003 04:30'!addSetterFeedback	"Add screen feedback showing what would be torn off to make a setter"	| aMorph |	aMorph := RectangleMorph new bounds: ((submorphs fourth topLeft - (2@1)) corner: (submorphs last bottomRight) + (2@0)).	aMorph useRoundedCorners; beTransparent; borderWidth: 2; borderColor: (Color r: 1.0 g: 0.548 b: 0.452); lock.	aMorph setProperty: #highlight toValue: true.	ActiveWorld addMorphFront: aMorph! !!Vocabulary methodsFor: '*eToys-queries' stamp: 'yo 2/19/2005 23:41'!tileWordingForSelector: aSelector	"Answer the wording to emblazon on tiles representing aSelector"	| anInterface inherent |	anInterface := self methodInterfaceAt: aSelector asSymbol ifAbsent:		[inherent := Utilities inherentSelectorForGetter: aSelector.		^ inherent			ifNil:				[self translatedWordingFor: aSelector]			ifNotNil:				[inherent translated]].	^ anInterface wording! !!Vocabulary class methodsFor: '*eToys-type vocabularies' stamp: 'mir 7/15/2004 10:54'!newWonderlandVocabulary	"Answer a Wonderland vocabulary -- highly experimental"	| aVocabulary  |	"Vocabulary newWonderlandVocabulary"	aVocabulary := Vocabulary new vocabularyName: #Wonderland.	aVocabulary documentation: 'A simple vocabulary for scripting Alice objects'.	aVocabulary initializeFromTable:  #(		(color color: () Color (basic color) 'The color of the object' unused updating)		"--"		(getX setX: () Number (basic geometry) 'The x position' unused updating)		(getY setY: () Number (basic geometry) 'The y position' unused updating)		(getZ setZ: () Number (basic geometry) 'The z position' unused updating)		"--"		(width setWidth: () Number (geometry) 'The width of the object' unused updating)		(height setHeight: () Number (geometry) 'The height of the object' unused updating)		(depth setDepth: () Number (geometry) 'The depth of the object' unused updating)		"--"		(heading setHeading: () Number (basic geometry) 'The heading of the object' unused updating)		(forwardBy: unused ((distance Number)) none (basic motion) 'Moves the object by the specified distance' 'forward by')		(turnBy: unused ((angle Number)) none (basic motion) 'Turns the object by the specified number of degrees' 'turn by')		(graphic setGraphic: () Graphic (basic graphics) 'The picture currently being worn' unused updating)		(animationIndex setAnimationIndex: () Number (graphics) 'The index in the object''s animation chain' unused updating)		(emptyScript unused () none (scripts) 'The empty script')		(distanceToCamera setDistanceToCamera: () Number (geometry) 'The distance of the object from the camera' unused updating)		(distanceTo: unused ((target Player)) Number (geometry) 'The distance of the object to the given target')	).	^ aVocabulary! !!WatcherWrapper methodsFor: 'accessing' stamp: 'sw 1/6/2005 04:18'!getterTilesForDrop	"Answer getter tiles to use if there is an attempt to drop me onto a tile pad"	| aCategoryViewer |	aCategoryViewer := CategoryViewer new initializeFor: player categoryChoice: #basic.	^ aCategoryViewer getterTilesFor: (Utilities getterSelectorFor: variableName)  type: self resultType! !!WatcherWrapper methodsFor: 'initialization' stamp: 'tak 4/6/2005 13:07'!player: aPlayer variableName: aVariableName	"Set up my initial state"	player := aPlayer.	variableName := aVariableName.	self reconstituteName! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/7/1998 15:30'!isFinalizationSupported	"Check if this VM supports the finalization mechanism"	| tempObject |	IsFinalizationSupported ifNotNil:[^IsFinalizationSupported].	tempObject := WeakArray new: 1.	"Check if the class format 4 is correctly understood by the VM.	If the weak class support is not installed then the VM will report	any weak class as containing 32bit words - not pointers"	(tempObject at: 1) = nil 		ifFalse:[^IsFinalizationSupported :=false].	"Check if objects are correctly freed"	self pvtCreateTemporaryObjectIn: tempObject.	Smalltalk garbageCollect.	^IsFinalizationSupported := (tempObject at: 1) == nil! !!WeakArray class methodsFor: 'private' stamp: 'di 5/21/2001 21:49'!finalizationProcess	[true] whileTrue:		[FinalizationSemaphore wait.		FinalizationLock critical:			[FinalizationDependents do:				[:weakDependent |				weakDependent ifNotNil:					[weakDependent finalizeValues.					"***Following statement is required to keep weakDependent					from holding onto its value as garbage.***"					weakDependent := nil]]]			ifError:			[:msg :rcvr | rcvr error: msg].		].! !!WeakIdentityKeyDictionary methodsFor: 'private' stamp: 'md 10/5/2005 15:44'!scanFor: anObject	"ar 10/21/2000: The method has been copied to this location to indicate that whenever #scanFor: changes #scanForNil: must be changed in the receiver as well."	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish hash |	finish := array size.	finish > 4096		ifTrue: [hash := anObject identityHash * (finish // 4096)]		ifFalse: [hash := anObject identityHash].	start := (hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakIdentityKeyDictionary methodsFor: 'private' stamp: 'ar 7/1/2003 15:15'!scanForNil: anObject	"Private. Scan the key array for the first slot containing nil (indicating an empty slot). Answer the index of that slot."	| start finish hash |	finish := array size.	finish > 4096		ifTrue: [hash := anObject identityHash * (finish // 4096)]		ifFalse: [hash := anObject identityHash].	start := (hash \\ array size) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | (array at: index) == nil ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | (array at: index) == nil ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:02'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	key isNil ifTrue:[^anObject].	index := self findElementOrNil: key.	element := array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakKeyAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ar 10/21/2000 20:00'!finalizeValues	"remove all nil keys and rehash the receiver afterwards"	| assoc |	1 to: array size do:[:i|		assoc := array at: i.		(assoc notNil and:[assoc key == nil]) ifTrue:[array at: i put: nil].	].	self rehash.! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ar 10/21/2000 20:01'!finalizeValues: finiObjects	"Remove all associations with key == nil and value is in finiObjects.	This method is folded with #rehash for efficiency."	| oldArray assoc newIndex |	oldArray := array.	array := Array new: oldArray size.	tally := 0.	1 to: array size do:[:i|		assoc := oldArray at: i.		assoc ifNotNil:[			(assoc key == nil and:[finiObjects includes: assoc value]) ifFalse:[				newIndex := self scanForNil: assoc key.				self atNewIndex: newIndex put: assoc].		].	].! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ar 10/21/2000 19:56'!rehash	"Rehash the receiver. Reimplemented to allow for multiple nil keys"	| oldArray assoc newIndex |	oldArray := array.	array := Array new: oldArray size.	tally := 0.	1 to: array size do:[:i|		assoc := oldArray at: i.		assoc ifNotNil:[			newIndex := self scanForNil: assoc key.			self atNewIndex: newIndex put: assoc.		].	].! !!WeakKeyDictionary methodsFor: 'private' stamp: 'md 10/5/2005 15:44'!scanFor: anObject	"ar 10/21/2000: The method has been copied to this location to indicate that whenever #scanFor: changes #scanForNil: must be changed in the receiver as well."	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ar 10/21/2000 19:46'!scanForNil: anObject	"Private. Scan the key array for the first slot containing nil (indicating an empty slot). Answer the index of that slot."	| start finish |	start := (anObject hash \\ array size) + 1.	finish := array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | (array at: index) == nil ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | (array at: index) == nil ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/30/2000 13:15'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject"	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self findElementOrNil: newObject.	((array at: index) == flag or: [(array at: index) isNil])		ifTrue: [self atNewIndex: index put: newObject].	^newObject! !!WeakSet methodsFor: 'public' stamp: 'nk 3/11/2002 20:35'!collect: aBlock	| each newSet |	newSet := self species new: self size.	tally = 0 ifTrue: [^newSet ].	1 to: array size do:		[:index |			((each := array at: index) == nil or: [each == flag])				ifFalse: [newSet add: (aBlock value: each)]		].	^newSet! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:46'!do: aBlock	| each |	tally = 0 ifTrue: [^self].	1 to: array size do:		[:index |			((each := array at: index) == nil or: [each == flag])				ifFalse: [aBlock value: each]		]! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/30/2000 13:13'!do: aBlock after: anElement	| each startIndex |	tally = 0 ifTrue: [^self].	startIndex := anElement ifNil: [1] ifNotNil:		[self findElementOrNil: anElement].	startIndex + 1 to: array size do:		[:index |			((each := array at: index) == nil or: [each == flag])				ifFalse: [aBlock value: each]		]! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 16:02'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	| index element |	^(index := self scanFor: anObject) = 0		ifFalse: [(element := array at: index) == flag ifFalse: [element]]! !!WeakSet methodsFor: 'public' stamp: 'di 2/3/2001 16:46'!printElementsOn: aStream	| oldPos |	aStream nextPut: $(.	oldPos := aStream position.	self do: [:element | aStream print: element; space].	aStream position > oldPos ifTrue: [aStream skip: -1 "remove the extra space"].	aStream nextPut: $)! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:08'!remove: oldObject ifAbsent: aBlock	| index |	index := self findElementOrNil: oldObject.	(array at: index) == flag ifTrue: [ ^ aBlock value ].	array at: index put: flag.	tally := tally - 1.	self fixCollisionsFrom: index.	^oldObject! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:17'!slowSize	"Careful!! Answer the maximum amount	of elements in the receiver, not the	exact amount"	tally := array inject: 0 into:		[:total :each | (each == nil or: [each == flag])			ifTrue: [total] ifFalse: [total + 1]].	^tally! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 14:30'!fixCollisionsFrom: index	"The element at index has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one"	| length oldIndex newIndex element |	oldIndex := index.	length := array size.	[oldIndex = length			ifTrue: [oldIndex := 1]			ifFalse: [oldIndex := oldIndex + 1].	(element := self keyAt: oldIndex) == flag]		whileFalse: 			[newIndex := self findElementOrNil: element.			oldIndex = newIndex ifFalse: [self swap: oldIndex with: newIndex]]! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 15:43'!growTo: anInteger	"Grow the elements array and reinsert the old elements"	| oldElements |	oldElements := array.	array := WeakArray new: anInteger.	array atAllPut: flag.	tally := 0.	oldElements do:		[:each | (each == flag or: [each == nil]) ifFalse: [self noCheckAdd: each]]! !!WeakSet methodsFor: 'private' stamp: 'nice 4/4/2006 22:09'!initialize: n	"Initialize array to an array size of n"	flag := Object new.	array := WeakArray new: n.	array atAllPut: flag.	tally := 0! !!WeakSet methodsFor: 'private' stamp: 'md 10/5/2005 15:44'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements"	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == flag or: [element = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == flag or: [element = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakSet methodsFor: 'private' stamp: 'yo 11/11/2002 23:10'!scanForLoadedSymbol: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements"	| element start finish |	start := (anObject hash \\ array size) + 1.	finish := array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == flag or: [element asString = anObject asString])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == flag or: [element asString = anObject asString])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakValueAssociation methodsFor: 'accessing' stamp: 'r++ 5/27/2000 18:11'!key: aKey value: anObject 	"Store the arguments as the variables of the receiver."	key := aKey.	self value: anObject! !!WeakValueDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:01'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	index := self findElementOrNil: key.	element := array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakValueAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!Week class methodsFor: 'squeak protocol' stamp: 'gk 8/30/2006 15:10'!starting: aDateAndTime duration: aDuration	"Override - the duration is always one week.	 Week will start from the Week class>>startDay"	| midnight delta adjusted |	midnight _ aDateAndTime asDateAndTime midnight.	delta _ ((midnight dayOfWeek + 7 - (DayNames indexOf: self startDay)) rem: 7) abs.	adjusted _ midnight - (Duration days: delta seconds: 0).	^ super starting: adjusted duration: (Duration weeks: 1).! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:29'!= anObject	^self species == anObject species and: [		self wideCharacterMap = anObject wideCharacterMap ]! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/10/2006 00:26'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.	Intended for use by primitives only. (and comparison)	This version will answer a subset with only byte characters"		| aMap lowmap |	aMap := ByteArray new: 256.	lowmap := map at: 0 ifAbsent: [^aMap].	lowmap := lowmap copyFrom: 1 to: 8. "Keep first 8*32=256 bits..."	self bitmap: lowmap do: [:code | aMap at: code + 1 put: 1].	^aMap! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 22:27'!hash	^self map hash! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:29'!species	^self hasWideCharacters		ifTrue: [WideCharacterSet]		ifFalse: [CharacterSet]! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:14'!wideCharacterMap	^map! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 22:45'!add: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := map at: high ifAbsentPut: [WordArray new: 2048].	self setBitmap: lowmap at: low.	^ aCharacter! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/10/2006 00:21'!do: aBlock 	map		keysAndValuesDo: [:high :lowmap | self				bitmap: lowmap				do: [:low | aBlock						value: (Character value: ((high bitShift: 16) bitOr: low))]]! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:49'!includes: aCharacter 	| val high low |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	^(self		bitmap: (map				at: high				ifAbsent: [^ false])		at: low) isZero not! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 22:45'!remove: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := (map				at: high				ifAbsent: [^ aCharacter]) self clearBitmap: lowmap at: low.	lowmap max = 0		ifTrue: [map removeKey: high].	^ aCharacter! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:00'!size	| size |	size := 0.	map		keysAndValuesDo: [:high :lowmap | self				bitmap: lowmap				do: [:low | size := size + 1]].	^ size! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:46'!bitmap: aMap at: shortInteger	"access a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^(aMap at: collecIndex + 1) bitAnd: (1 bitShift: bitIndex)! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/10/2006 00:10'!bitmap: aMap do: aBlock	"Execute a block with each value (0 based) corresponding to set bits"		0 to: 31 do: [:shift |		| mask |		mask := 1 bitShift: shift.		1 to: aMap size do: [:i | 			((aMap at: i) bitAnd: mask) isZero ifFalse: [aBlock value: ((i - 1 bitShift: 5) bitOr: shift)]]]! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:46'!clearBitmap: aMap at: shortInteger	"clear a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitClear: (1 bitShift: bitIndex))! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:47'!setBitmap: aMap at: shortInteger	"set a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitOr: (1 bitShift: bitIndex))! !!WideCharacterSet methodsFor: 'testing' stamp: 'nice 5/9/2006 23:25'!hasWideCharacters	"Answer true if i contain any wide character"		self do: [:e | e asciiValue >= 256 ifTrue: [^true]].	^false! !!WideCharacterSet methodsFor: 'initialize-release' stamp: 'nice 5/9/2006 22:31'!initialize	map := Dictionary new.! !!WideCharacterSet methodsFor: 'converting' stamp: 'nice 3/23/2007 02:29'!complement	"return a character set containing precisely the characters the receiver does not"		^CharacterSetComplement of: self! !!WideCharacterSet commentStamp: 'nice 5/9/2006 23:33' prior: 0!WideCharacterSet is used to store a Set of WideCharacter with fast access and inclusion test.Implementation should be efficient in memory if sets are sufficently sparse.Wide Characters are at most 32bits.We split them into 16 highBits and 16 lowBits.map is a dictionary key: 16 highBits value: map of 16 lowBits.Maps of lowBits  are stored as arrays of bits in a WordArray.If a bit is set to 1, this indicate that corresponding character is present.Only 2048 entries are necessary in each lowmap.And only lowmap corresponding to a present high value are stored.!!WideString methodsFor: 'accessing' stamp: 'yo 10/31/2002 22:29'!byteAt: index	| d r |	d := (index + 3) // 4.	r := (index - 1) \\ 4 + 1.	^ (self wordAt: d) digitAt: ((4 - r) + 1).! !!WideString methodsFor: 'accessing' stamp: 'yo 11/3/2002 13:19'!byteAt: index put: aByte	| d r w |	d := (index + 3) // 4.	r := (index - 1) \\ 4 + 1.	w := (self wordAt: d) bitAnd: ((16rFF<<((4 - r)*8)) bitInvert32).	w := w + (aByte<<((4 - r)*8)).	self basicAt: d put: w.	^ aByte.! !!WideString methodsFor: 'converting' stamp: 'yo 8/28/2002 14:46'!asFourCode	| result |	self size = 1 ifFalse: [^self error: 'must be exactly four octets'].	result := self basicAt: 1.	(result bitAnd: 16r80000000) = 0 		ifFalse: [self error: 'cannot resolve fourcode'].	(result bitAnd: 16r40000000) = 0 ifFalse: [^result - 16r80000000].	^ result! !!WideString methodsFor: 'converting' stamp: 'yo 8/28/2002 14:47'!asPacked	self inject: 0 into: [:pack :next | pack := pack * 16r100000000 + next asInteger].! !!WideString methodsFor: 'converting' stamp: 'yo 3/14/2005 11:41'!copyFrom: start to: stop	| n |	n := super copyFrom: start to: stop.	n isOctetString ifTrue: [^ n asOctetString].	^ n.! !!WideString methodsFor: 'private' stamp: 'ar 4/9/2005 22:31'!mutateJISX0208StringToUnicode	| c |	1 to: self size do: [:i |		c := self at: i.		(c leadingChar = JISX0208 leadingChar or: [			c leadingChar = (JISX0208 leadingChar bitShift: 2)]) ifTrue: [			self basicAt: i put: (Character leadingChar: JapaneseEnvironment leadingChar code: (c asUnicode)) asciiValue.		]	].! !!WideString class methodsFor: 'enumeration' stamp: 'yo 8/27/2003 07:01'!allMethodsWithEncodingTag: encodingTag	"Answer a SortedCollection of all the methods that implement the message 	aSelector."	| list adder num i |	list := Set new.	adder := [ :mrClass :mrSel |		list add: (			MethodReference new				setStandardClass: mrClass				methodSymbol: mrSel		)	].	num := CompiledMethod allInstances size.	i := 0.	'processing...' displayProgressAt: Sensor cursorPoint from: 0 to: num during: [:bar |		SystemNavigation new allBehaviorsDo: [ :class |			class selectors do: [:s |				bar value: (i := i + 1).								(self string: (class sourceCodeAt: s) asString hasEncoding: encodingTag) ifTrue: [					adder value: class value: s.				]			]		]	].	^ list.! !!WideString class methodsFor: 'enumeration' stamp: 'yo 8/12/2003 17:14'!allMultiStringMethods  	"Answer a SortedCollection of all the methods that implement the message 	aSelector."	| list adder num i |	list := Set new.	adder := [ :mrClass :mrSel |		list add: (			MethodReference new				setStandardClass: mrClass				methodSymbol: mrSel		)	].	num := CompiledMethod allInstances size.	i := 0.	'processing...' displayProgressAt: Sensor cursorPoint from: 0 to: num during: [:bar |		SystemNavigation new allBehaviorsDo: [ :class |			class selectors do: [:s |				bar value: (i := i + 1).								((class sourceCodeAt: s) asString isOctetString) ifFalse: [					adder value: class value: s.				]			]		]	].	^ list.! !!WideString class methodsFor: 'enumeration' stamp: 'yo 8/27/2003 07:00'!allNonAsciiMethods  	"Answer a SortedCollection of all the methods that implement the message 	aSelector."	| list adder num i |	list := Set new.	adder := [ :mrClass :mrSel |		list add: (			MethodReference new				setStandardClass: mrClass				methodSymbol: mrSel		)	].	num := CompiledMethod allInstances size.	i := 0.	'processing...' displayProgressAt: Sensor cursorPoint from: 0 to: num during: [:bar |		SystemNavigation new allBehaviorsDo: [ :class |			class selectors do: [:s |				bar value: (i := i + 1).								((class sourceCodeAt: s) asString isAsciiString) ifFalse: [					adder value: class value: s.				]			]		]	].	^ list.! !!WideString class methodsFor: 'instance creation' stamp: 'ar 4/10/2005 19:38'!fromByteArray: aByteArray 	| inst |	aByteArray size \\ 4 = 0 ifFalse: [^ ByteString fromByteArray: aByteArray ].	inst := self new: aByteArray size // 4.	4 to: aByteArray size by: 4 do: [:i |		inst basicAt: i // 4			put: ((aByteArray at: i - 3) << 24) + 				((aByteArray at: i - 2) << 16) +				 ((aByteArray at: i - 1) << 8) +				(aByteArray at: i)	].	^ inst! !!WideString class methodsFor: 'instance creation' stamp: 'yo 8/30/2002 17:00'!fromISO2022JPString: string 	| tempFileName stream contents |	tempFileName := Time millisecondClockValue printString , '.txt'.	FileDirectory default deleteFileNamed: tempFileName ifAbsent: [].	stream := StandardFileStream fileNamed: tempFileName.	[stream nextPutAll: string]		ensure: [stream close].	stream := FileStream fileNamed: tempFileName.	contents := stream contentsOfEntireFile.	FileDirectory default deleteFileNamed: tempFileName ifAbsent: [].	^ contents! !!WideString class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 19:58'!fromPacked: aLong	"Convert from a longinteger to a String of length 4."	| s val |	s := self new: 1.	val := (((aLong digitAt: 4) << 24) bitOr:((aLong digitAt: 3) << 16))				bitOr: (((aLong digitAt: 2) << 8) bitOr: (aLong digitAt: 1)).	s basicAt: 1 put: val.	^ s."WideString fromPacked: 'TEXT' asPacked"! !!WideString class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 13:39'!fromString: aString 	"Answer an instance of me that is a copy of the argument, aString."	| inst |	(aString isMemberOf: self) ifTrue: [		^ aString copy.	].	inst := self new: aString size.	1 to: aString size do: [:pos |		inst basicAt: pos put: (aString basicAt: pos).	].	^ inst.! !!WideString class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 20:00'!from: aString 	| newString |	(aString isMemberOf: self)		ifTrue: [^ aString copy].	newString := self new: aString size.	1 to: aString size do: [:index | newString basicAt: index put: (aString basicAt: index)].	^ newString! !!WideStringTest methodsFor: 'tests - substrings' stamp: 'nice 3/23/2007 01:52'!testSubstrings	"this is related to http://bugs.squeak.org/view.php?id=6367"		| w1 w2 |	w1 := WideString with: 401 asCharacter with: $a with: 402 asCharacter with: $b.	w2 := WideString with: 403 asCharacter with: 404 asCharacter.	self assert: w1 substrings first = w1.	self assert: (w1 , ' ' , w2) substrings size = 2.	self assert: (w1 , ' ' , w2) substrings last = w2.! !!WideSymbol methodsFor: 'accessing' stamp: 'ar 4/10/2005 23:38'!byteAt: index	| d r |	d := (index + 3) // 4.	r := (index - 1) \\ 4 + 1.	^ (self wordAt: d) digitAt: ((4 - r) + 1).! !!WideSymbol methodsFor: 'private' stamp: 'ar 4/12/2005 14:12'!fixUponLoad: aProject seg: anImageSegment	"We are in an old project that is being loaded from disk. 	Fix up conventions that have changed."	| ms |	"Yoshiki did not put MultiSymbols into outPointers in older images!!	When all old images are gone, remove this method."	ms := Symbol intern: self asString.	self == ms ifFalse: [		"For a project from older m17n image, this is necessary."		self becomeForward: ms.		aProject projectParameters at: #MultiSymbolInWrongPlace put: true	].	"MultiString>>capitalized was not implemented correctly. 	Fix eventual accessors and mutators here."	((self beginsWith: 'get')		and:[(self at: 4) asInteger < 256		and:[(self at: 4) isLowercase]]) ifTrue:[			ms := self asString.			ms at: 4 put: (ms at: 4) asUppercase.			ms := ms asSymbol.			self becomeForward: ms.			aProject projectParameters at: #MultiSymbolInWrongPlace put: true.		].	((self beginsWith: 'set')		and:[(self at: 4) asInteger < 256		and:[(self at: 4) isLowercase		and:[self last = $:		and:[(self occurrencesOf: $:) = 1]]]]) ifTrue:[			ms := self asString.			ms at: 4 put: (ms at: 4) asUppercase.			ms := ms asSymbol.			self becomeForward: ms.			aProject projectParameters at: #MultiSymbolInWrongPlace put: true.		].	^ super fixUponLoad: aProject seg: anImageSegment	"me, not the label"! !!WideSymbol methodsFor: 'private' stamp: 'yo 7/29/2005 21:53'!mutateJISX0208StringToUnicode	| c |	1 to: self size do: [:i |		c := self at: i.		(c leadingChar = JISX0208 leadingChar or: [			c leadingChar = (JISX0208 leadingChar bitShift: 2)]) ifTrue: [			self basicAt: i put: (Character leadingChar: JapaneseEnvironment leadingChar code: (c asUnicode)) asciiValue.		]	].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:07'!refresh	"This is a one-time only method for bootstraping the new registry. Here we will scan all classes for #windowColorSpecification methods and register those to the registry"	registry := nil.	((self systemNavigation allClassesImplementing: #windowColorSpecification)		collect: [:aClass | aClass theNonMetaClass windowColorSpecification])		do: [:spec | self registerColorSpecification: spec toClassNamed: spec classSymbol ].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11'!registry	^registry ifNil: [registry := Dictionary new].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11'!unregisterColorSpecificationForClassNamed: aClassName		self registry removeKey: aClassName asSymbol ! !!WindowingTransformation methodsFor: 'applying transform'!applyInverseTo: anObject 	"Apply the inverse of the receiver to anObject and answer the result. 	Used to map some object in destination coordinates to one in source 	coordinates."	| transformedObject |	transformedObject := anObject translateBy: translation x negated @ translation y negated.	scale == nil		ifFalse: [transformedObject := transformedObject scaleBy: 1.0 / scale x @ (1.0 / scale y)].	^transformedObject! !!WindowingTransformation methodsFor: 'applying transform'!applyTo: anObject 	"Apply the receiver to anObject and answer the result. Used to map some 	object in source coordinates to one in destination coordinates."	| transformedObject |	scale == nil		ifTrue: [transformedObject := anObject]		ifFalse: [transformedObject := anObject scaleBy: scale].	transformedObject := transformedObject translateBy: translation.	^transformedObject! !!WindowingTransformation methodsFor: 'applying transform'!compose: aTransformation 	"Answer a WindowingTransformation that is the composition of the 	receiver and aTransformation. The effect of applying the resulting 	WindowingTransformation to an object is the same as that of first 	applying aTransformation to the object and then applying the receiver to 	its result."	| aTransformationScale newScale newTranslation |	aTransformationScale := aTransformation scale.	scale == nil		ifTrue: 			[aTransformation noScale				ifTrue: [newScale := nil]				ifFalse: [newScale := aTransformationScale].			newTranslation := translation + aTransformation translation]		ifFalse: 			[aTransformation noScale				ifTrue: [newScale := scale]				ifFalse: [newScale := scale * aTransformationScale].			newTranslation := translation + (scale * aTransformation translation)].	^WindowingTransformation scale: newScale translation: newTranslation! !!WindowingTransformation methodsFor: 'scrolling'!scrollBy: aPoint 	"Answer a WindowingTransformation with the same scale as the receiver 	and with a translation of the current translation plus aPoint scaled by 	the current scale. It is used when the translation is known in source 	coordinates, rather than scaled source coordinates (see 	WindowingTransformation|translateBy:). An example is that of scrolling 	objects with respect to a stationary window in the source coordinate 	system. If no scaling is in effect (scale = nil), then 	WindowingTransformation|translateBy: and 	WindowingTransformation|scrollBy: are equivalent."	| newTranslation |	scale == nil		ifTrue: [newTranslation := aPoint]		ifFalse: [newTranslation := scale * aPoint].	^self translateBy: newTranslation! !!WindowingTransformation methodsFor: 'transforming'!scaleBy: aScale 	"Answer a WindowingTransformation with the scale and translation of 	the receiver both scaled by aScale."	| checkedScale newScale newTranslation |	aScale == nil		ifTrue: 			[newScale := scale.			newTranslation := translation]		ifFalse: 			[checkedScale := self checkScale: aScale.			scale == nil				ifTrue: [newScale := checkedScale]				ifFalse: [newScale := scale * checkedScale].			newTranslation := checkedScale * translation].	^WindowingTransformation scale: newScale translation: newTranslation! !!WindowingTransformation methodsFor: 'private'!checkScale: aScale	"Convert aScale to the internal format of a floating-point Point." 	| checkedScale |	checkedScale := aScale asPoint.	^checkedScale x asFloat @ checkedScale y asFloat! !!WindowingTransformation methodsFor: 'private'!setScale: aScale translation: aTranslation 	"Sets the scale to aScale and the translation to aTranslation."	scale := aScale.	translation := aTranslation! !!WindowingTransformation class methodsFor: 'instance creation'!window: aWindow viewport: aViewport 	"Answer an instance of me with a scale and translation based on 	aWindow and aViewport. The scale and translation are computed such 	that aWindow, when transformed, coincides with aViewport."	| scale translation |	aViewport width = aWindow width & (aViewport height = aWindow height)		ifTrue:			[scale := nil]		ifFalse:			[scale := aViewport width asFloat / aWindow width asFloat						@ (aViewport height asFloat / aWindow height asFloat)].	scale == nil		ifTrue: [translation := aViewport left - aWindow left								@ (aViewport top - aWindow top)]		ifFalse: [translation := aViewport left - (scale x * aWindow left)								@ (aViewport top - (scale y * aWindow top))].	^self new setScale: scale translation: translation! !!WordArray methodsFor: 'array arithmetic' stamp: 'yo 10/25/2004 15:52'!* other	| result |	other isNumber ifTrue: [		other isFloat ifTrue: [			result := KedamaFloatArray new: self size.			^ self primMulScalar: self and: other into: result.		] ifFalse: [			result := WordArray new: self size.			^ self primMulScalar: self and: other into: result.		].	].	(other isMemberOf: WordArray) ifTrue: [			result := WordArray new: self size.		^ self primMulArray: self and: other into: result.	].	(other isMemberOf: KedamaFloatArray) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primMulArray: self and: other into: result.	].	^ super * other.! !!WordArray methodsFor: 'array arithmetic' stamp: 'yo 10/25/2004 14:58'!+ other	| result |	other isNumber ifTrue: [		other isFloat ifTrue: [			result := KedamaFloatArray new: self size.			^ self primAddScalar: self and: other into: result.		] ifFalse: [			result := WordArray new: self size.			^ self primAddScalar: self and: other into: result.		].	].	(other isMemberOf: WordArray) ifTrue: [			result := WordArray new: self size.		^ self primAddArray: self and: other into: result.	].	(other isMemberOf: KedamaFloatArray) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primAddArray: self and: other into: result.	].	^ super + other.! !!WordArray methodsFor: 'array arithmetic' stamp: 'yo 10/25/2004 15:52'!- other	| result |	other isNumber ifTrue: [		other isFloat ifTrue: [			result := KedamaFloatArray new: self size.			^ self primSubScalar: self and: other into: result.		] ifFalse: [			result := WordArray new: self size.			^ self primSubScalar: self and: other into: result.		].	].	(other isMemberOf: WordArray) ifTrue: [			result := WordArray new: self size.		^ self primSubArray: self and: other into: result.	].	(other isMemberOf: KedamaFloatArray) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primSubArray: self and: other into: result.	].	^ super - other.! !!WordArray methodsFor: 'array arithmetic' stamp: 'yo 10/25/2004 15:53'!/ other	| result |	other isNumber ifTrue: [		other isFloat ifTrue: [			result := KedamaFloatArray new: self size.			^ self primDivScalar: self and: other into: result.		] ifFalse: [			result := WordArray new: self size.			^ self primDivScalar: self and: other into: result.		].	].	(other isMemberOf: WordArray) ifTrue: [			result := WordArray new: self size.		^ self primDivArray: self and: other into: result.	].	(other isMemberOf: KedamaFloatArray) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primDivArray: self and: other into: result.	].	^ super / other.! !!WordArray class methodsFor: 'as yet unclassified' stamp: 'RAA 5/17/2001 16:07'!bobsTest	| wa s1 s2 wa2 answer rawData |"WordArray bobsTest"	answer := OrderedCollection new.	wa := WordArray with: 16r01020304 with: 16r05060708.	{false. true} do: [ :pad |		0 to: 3 do: [ :skip |			s1 := RWBinaryOrTextStream on: ByteArray new.			s1 next: skip put: 0.		"start at varying positions"			wa writeOn: s1.			pad ifTrue: [s1 next: 4-skip put: 0].	"force length to be multiple of 4"			rawData := s1 contents.			s2 := RWBinaryOrTextStream with: rawData.			s2 reset.			s2 skip: skip.			"get to beginning of object"			wa2 := WordArray newFromStream: s2.			answer add: {				rawData size. 				skip. 				wa2 = wa. 				wa2 asArray collect: [ :each | each radix: 16]			}		].	].	^answer explore! !!Workspace methodsFor: 'variable declarations' stamp: 'sumim 11/26/2006 03:52'!mustDeclareVariableWording		^ mustDeclareVariables not		ifTrue: ['<yes> automatically create variable declaration' translated]		ifFalse: ['<no> automatically create variable declaration' translated]! !!WriteStream methodsFor: 'accessing'!contents	readLimit := readLimit max: position.	^collection copyFrom: 1 to: position! !!WriteStream methodsFor: 'accessing' stamp: 'dc 2/11/2007 14:18'!ensureEndsWith: anObject	"Append anObject to the receiver IFF there is not one on the end."	(position > 0 and: [(collection at: position) = anObject]) ifTrue: [^self].	self nextPut: anObject! !!WriteStream methodsFor: 'accessing' stamp: 'BG 5/26/2003 08:01'!next: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	| newEnd |	collection class == aCollection class ifFalse:		[^ super next: anInteger putAll: aCollection startingAt: startIndex].	newEnd _ position + anInteger.	newEnd > writeLimit ifTrue:		[self growTo: newEnd + 10].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: startIndex.	position _ newEnd.	^aCollection! !!WriteStream methodsFor: 'accessing' stamp: 'ar 4/12/2005 17:34'!nextPut: anObject 	"Primitive. Insert the argument at the next position in the Stream	represented by the receiver. Fail if the collection of this stream is not an	Array or a String. Fail if the stream is positioned at its end, or if the	position is out of bounds in the collection. Fail if the argument is not	of the right type for the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 66>	((collection class == ByteString) and: [		anObject isCharacter and:[anObject isOctetCharacter not]]) ifTrue: [			collection := (WideString from: collection).			^self nextPut: anObject.	].	position >= writeLimit		ifTrue: [^ self pastEndPut: anObject]		ifFalse: 			[position := position + 1.			^collection at: position put: anObject]! !!WriteStream methodsFor: 'accessing' stamp: 'BG 5/24/2003 20:41'!nextPutAll: aCollection	| newEnd |	collection class == aCollection class ifFalse:		[^ super nextPutAll: aCollection ].	newEnd _ position + aCollection size.	newEnd > writeLimit ifTrue:		[self growTo: newEnd + 10].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.	position _ newEnd.! !!WriteStream methodsFor: 'accessing'!size	^readLimit := readLimit max: position! !!WriteStream methodsFor: 'character writing' stamp: 'dc 2/11/2007 14:18'!ensureASpace	"Append a space character to the receiver IFF there is not one on the end."	self ensureEndsWith: Character space! !!WriteStream methodsFor: 'fileIn/Out' stamp: 'yo 8/13/2003 12:18'!nextChunkPut: aString	"Append the argument, aString, to the receiver, doubling embedded terminators."	| i remainder terminator |	terminator := $!!.	remainder := aString.	[(i := remainder indexOf: terminator) = 0] whileFalse:		[self nextPutAll: (remainder copyFrom: 1 to: i).		self nextPut: terminator.  "double imbedded terminators"		remainder := remainder copyFrom: i+1 to: remainder size].	self nextPutAll: remainder.	aString includesUnifiedCharacter ifTrue: [		self nextPut: terminator.		self nextPutAll: ']lang['.		aString writeLeadingCharRunsOn: self.	].	self nextPut: terminator.! !!WriteStream methodsFor: 'positioning'!position: anInteger 	"Refer to the comment in PositionableStream|position:."	readLimit := readLimit max: position.	super position: anInteger! !!WriteStream methodsFor: 'positioning'!reset 	"Refer to the comment in PositionableStream|reset."	readLimit := readLimit max: position.	position := 0! !!WriteStream methodsFor: 'positioning' stamp: 'ar 11/12/1998 21:27'!resetToStart	readLimit := position := 0.! !!WriteStream methodsFor: 'positioning' stamp: 'ajh 5/25/2001 20:19'!setToEnd 	"Refer to the comment in PositionableStream|setToEnd."	readLimit := readLimit max: position.	super setToEnd.! !!WriteStream methodsFor: 'private' stamp: 'di 11/18/1999 22:50'!braceArray: anArray	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	collection := anArray.	position := 0.	readLimit := 0.	writeLimit := anArray size.! !!WriteStream methodsFor: 'private' stamp: 'BG 5/24/2003 22:49'!growTo: anInteger   " anInteger is the required minimal new size of the collection "	| oldSize grownCollection newSize |	oldSize _ collection size.     newSize := anInteger + (oldSize // 4 max: 20).	grownCollection _ collection class new: newSize.	collection _ grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.	writeLimit _ collection size.! !!WriteStream methodsFor: 'private'!on: aCollection	super on: aCollection.	readLimit := 0.	writeLimit := aCollection size! !!WriteStream methodsFor: 'private'!on: aCollection from: firstIndex to: lastIndex	| len |	collection := aCollection.	readLimit := 		writeLimit := lastIndex > (len := collection size)						ifTrue: [len]						ifFalse: [lastIndex].	position := firstIndex <= 1				ifTrue: [0]				ifFalse: [firstIndex - 1]! !!WriteStream methodsFor: 'private' stamp: 'md 2/24/2006 19:50'!pastEndPut: anObject	"Grow the collection by creating a new bigger collection and then	copy over the contents from the old one. We grow by doubling the size	but the growth is kept between 20 and 1000000.	Finally we put <anObject> at the current write position."	| oldSize grownCollection |	oldSize := collection size.	grownCollection := collection class new: oldSize + ((oldSize max: 20) min: 1000000).	collection := grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.	writeLimit := collection size.	collection at: (position := position + 1) put: anObject.	"return the argument - added by kwl"	^ anObject! !!WriteStream methodsFor: 'private'!with: aCollection	super on: aCollection.	position := readLimit := writeLimit := aCollection size! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:22'!testCr	"self debug: #testCr"		| stream |	stream := WriteStream on: 'stream'.	stream cr.	self assert: stream last = Character cr.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:26'!testCrTab	"self debug: #testCrTab"		| stream |	stream := WriteStream on: 'stream'.	stream crtab.	self assert: (stream contents last: 2) = (String with: Character cr with: Character tab)! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:28'!testCrTabs	"self debug: #testCrTabs"		| stream |	stream := WriteStream on: 'stream'.	stream crtab: 2.	self assert: (stream contents last: 3) = (String with: Character cr with: Character tab with: Character tab)! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/11/2007 14:14'!testEnsureASpace	"self debug: #testEnsureASpace"	| stream |	stream := WriteStream on: String new.	stream nextPutAll: 'this is a test'.	stream ensureASpace.	stream nextPutAll: 'for WriteStreamTest'.	self assert: stream contents = 'this is a test for WriteStreamTest'.		"Manually put a space and verify there are no 2 consecutive spaces"	stream := WriteStream on: String new.	stream nextPutAll: 'this is a test '.	stream ensureASpace.	stream nextPutAll: 'for WriteStreamTest'.	self assert: stream contents = 'this is a test for WriteStreamTest'.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/11/2007 14:17'!testEnsureASpace2	"self debug: #testEnsureASpace2"	| stream |	stream := WriteStream on: String new.	stream ensureASpace.	self assert: stream contents = ' '.	! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:29'!testEnsureNoSpace	"self debug: #testEnsureNoSpace"		| stream |	stream := WriteStream with: 'stream'.	stream ensureNoSpace.	self assert: stream contents = 'stream'.		stream := WriteStream with: 'stream '.	stream ensureNoSpace.	self assert: stream contents = 'stream'.		stream := WriteStream with: ' '.	stream ensureNoSpace.	self assert: stream contents = ''.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:39'!testSpace	"self debug: #testSpace"		| stream |	stream := WriteStream on: 'stream'.	stream space.	self assert: stream last = Character space.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:40'!testSpaces	"self debug: #testSpaces"		| stream |	stream := WriteStream on: 'stream'.	stream space: 3.	self assert: (stream contents last: 3) = '   '! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:42'!testTab	"self debug: #testTab"		| stream |	stream := WriteStream on: 'stream'.	stream tab.	self assert: (stream contents last) = Character tab! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:41'!testTabs	"self debug: #testTabs"		| stream |	stream := WriteStream on: 'stream'.	stream tab: 3.	self assert: (stream contents last: 3) = (String with: Character tab with: Character tab with: Character tab)! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/11/2007 13:59'!testInstanciationUsingOn	"self debug: #testInstanciationUsingOn"	| stream |	stream := WriteStream on: #(1 2).	stream nextPut: 3.	self assert: stream contents = #(3)! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/11/2007 13:59'!testInstanciationUsingWith	"self debug: #testInstanciationUsingWith"	| stream |	stream := WriteStream with: #(1 2).	stream nextPut: 3.	self assert: stream contents = #(1 2 3)! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'sd 6/5/2005 09:24'!testNew	self should: [WriteStream new] raise: Error. ! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/24/2007 18:15'!testNextPutAllDifferentFromNextPuts	"self debug: #testNextPutAllDifferentFromNextPuts"		"When a stream is created on a collection, it tries to keep using that collection instead of copying. See thread with title 'Very strange bug on Streams and probably compiler' (Feb 14 2007) on the squeak-dev mailing list."		"nextPutAll verifies the size of the parameter and directly grows the underlying collection of the required size."	|string stream|		string := String withAll: 'z'.	stream := WriteStream on: string.	stream nextPutAll: 'abc'.	self assert: string = 'z'. "string hasn't been modified because #nextPutAll: detects that 'abc' is bigger than the underlying collection. Thus, it starts by creating a new collection and doesn't modify our variable."		string := String withAll: 'z'.	stream := WriteStream on: string.	stream nextPut: $a; nextPut: $b; nextPut: $c.	self assert: string = 'a'. "The first #nextPut: has no problem and replaces $z by $a in the string. Others will detect that string is too small."! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/24/2007 18:05'!testStreamUseGivenCollection	"self debug: #testStreamUseGivenCollection"		"When a stream is created on a collection, it tries to keep using that collection instead of copying. See thread with title 'Very strange bug on Streams and probably compiler' (Feb 14 2007) on the squeak-dev mailing list."		|string stream|		string := String withAll: 'erased'.	stream := WriteStream on: string.	self assert: string = 'erased'.		stream nextPutAll: 'test'.	self assert: string = 'tested'. "Begining of 'erased' has been replaced by 'test'".! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/14/2007 14:12'!testNextPut	"self debug: #testNextPut"	| stream |	stream := WriteStream on: String new.	stream		nextPut: $t;		nextPut: $e;		nextPut: $s;		nextPut: $t.	self assert: stream contents = 'test'! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/14/2007 14:13'!testNextPut2	"self debug: #testNextPut2"	| stream |	stream := WriteStream with: 'test'.	stream nextPut: $s.	self assert: stream contents = 'tests'! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/14/2007 14:13'!testNextPutAll	"self debug: #testNextPutAll"	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: #($t $e $s $t).	self assert: stream contents = 'test'! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'sd 6/5/2005 09:24'!testSetToEnd	| string stream |	string := 'hello'.	stream := WriteStream with: ''.	stream nextPutAll: string.	self assert: stream position = string size.	stream setToEnd.	self assert: stream position = string size.	self assert: stream contents = string! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/14/2007 14:19'!testSize	"self debug: #testSize"	| string streamEmpty streamFull |	string := 'a string'.	streamEmpty := WriteStream on: string.	streamFull := WriteStream with: 'a string'.		self assert: streamEmpty size = 0.	self assert: streamFull size = 8.		streamEmpty nextPut: $..	streamFull nextPut: $..	self assert: streamEmpty size = 1.	self assert: streamFull size = (string size + 1).! !!WriteStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/14/2007 14:48'!testPosition	"self debug: #testPosition"		| stream |	stream := WriteStream with: 'an elephant'.	stream position: 6.	self assert: stream contents = 'an ele'.	stream nextPutAll: 'vator'.	stream assert: stream contents = 'an elevator'! !!WriteStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/14/2007 14:52'!testPosition2	"self debug: #testPosition2"		| stream |	stream := WriteStream with: ''.	self should: [stream position: 2] raise: Error.	self should: [stream position: -2] raise: Error.	stream := WriteStream with: 'a test'.	self shouldnt: [stream position: 2] raise: Error.	self should: [stream position: 7] raise: Error.	self should: [stream position: -2] raise: Error.! !!WriteStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/24/2007 17:55'!testReset	"self debug: #testReset"	|stream stream2|	stream := WriteStream with: 'a test ' copy.	stream reset.	stream nextPutAll: 'to test'.	self assert: stream contents = 'to test'.	stream2 := WriteStream with: 'a test ' copy.	stream2 nextPutAll: 'to test'.	self assert: stream2 contents = 'a test to test'! !!WriteStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/27/2007 16:20'!testIsEmpty	| stream |	stream := WriteStream on: String new.	self assert: stream isEmpty.	stream nextPut: $a.	self deny: stream isEmpty.	stream reset.	self deny: stream isEmpty.! !!WriteStreamTest methodsFor: 'tests - testing' stamp: 'edc 4/12/2007 07:01'!testIsEmpty2    self assert: (WriteStream on: (String new: 100)) isEmpty! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 10/25/2000 11:30'!characters: aString	| newElement |	newElement _ XMLStringNode string: aString.	self top addContent: newElement.! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 1/17/2002 13:13'!documentAttributes: attributeList	self document version: (attributeList at: 'version' ifAbsent: [nil]).	self document encoding: (attributeList at: 'encoding' ifAbsent: [nil]).	self document requiredMarkup: (attributeList at: 'requiredMarkup' ifAbsent: [nil]).! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 1/8/2002 18:19'!endDocument	self pop.	super endDocument! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 1/8/2002 18:11'!endElement: elementName	| currentElement |	currentElement _ self pop.	currentElement name = elementName		ifFalse: [self driver errorExpected: 'End tag "', elementName , '" doesn''t match "' , currentElement name , '".']! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 6/24/2003 14:53'!endElement: localName namespace: namespace namespaceURI: uri qualifiedName: qualifiedName	| currentElement |	currentElement _ self pop.	(currentElement namespace isNil		or: [currentElement namespace = self defaultNamespace])		ifTrue: [			currentElement localName = localName				ifFalse: [self driver errorExpected: 'End tag "', localName , '" doesn''t match "' , currentElement localName  , '".']]		ifFalse: [			currentElement qualifiedName = qualifiedName				ifFalse: [self driver errorExpected: 'End tag "', qualifiedName , '" doesn''t match "' , currentElement qualifiedName  , '".']]! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 3/6/2002 10:49'!processingInstruction: piName data: dataString	| newElement |	newElement _ XMLPI target: piName data: dataString.	self top addElement: newElement! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 11/30/2000 18:14'!startDocument	self document: XMLDocument new.	self push: self document ! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 3/6/2002 10:49'!startElement: elementName attributeList: attributeList	| newElement |	newElement _ XMLElement named: elementName attributes: attributeList.	self incremental		ifFalse: [self stack isEmpty			ifFalse: [self top addElement: newElement]].	self push: newElement! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 6/24/2003 18:52'!startElement: localName namespaceURI: namespaceUri namespace: namespace attributeList: attributeList	| newElement |	"newElement _ namespace = self defaultNamespace		ifTrue: [XMLElement named: localName namespace: nil uri: nil attributes: attributeList]		ifFalse: [XMLElement named: localName namespace: namespace uri: namespaceUri attributes: attributeList]."	newElement _ XMLElement named: localName namespace: namespace uri: namespaceUri attributes: attributeList.	self incremental		ifFalse: [self stack isEmpty			ifFalse: [self top addElement: newElement]].	self push: newElement! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 6/16/2003 17:20'!defaultNamespace	^self top		ifNotNil: [self top namespace]! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 12:04'!pop	| oldTop |	oldTop _ self stack removeLast.	entity _ oldTop.	^oldTop! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 12:02'!push: anObject	self stack add: anObject.	entity _ anObject! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 8/14/2000 18:28'!stack	^stack! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 11:46'!top	^self stack isEmpty		ifTrue: [nil]		ifFalse: [self stack last]! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 6/5/2003 19:29'!domDocument	[self startDocument; parseDocument]		ensure: [self driver stream close].	^document! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 6/28/2001 18:45'!nextEntity	| currentTop |	currentTop _ self top.	[self driver nextEntity isNil		or: [self top ~~ currentTop]] whileTrue.	^entity! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 12/21/2000 14:02'!nextEntityStart	[self driver nextEntity.	self stack isEmpty] whileTrue.	^entity! !!XMLDOMParser methodsFor: 'accessing' stamp: 'mir 1/8/2001 12:05'!incremental	^incremental! !!XMLDOMParser methodsFor: 'accessing' stamp: 'mir 1/8/2001 12:05'!incremental: aBoolean	incremental _ aBoolean! !!XMLDOMParser methodsFor: 'initialize' stamp: 'mir 1/8/2001 12:05'!initialize	super initialize.	stack _ OrderedCollection new.	incremental _ false! !!XMLDOMParser class methodsFor: 'examples' stamp: 'mir 8/14/2000 18:36'!addressBookXMLWithDTD	"XMLDOMParser addressBookXMLWithDTD"	^self parseDocumentFrom: XMLTokenizer addressBookXMLWithDTD readStream! !!XMLDOMParser class methodsFor: 'instance creation' stamp: 'mir 12/7/2000 16:29'!parseDocumentFrom: aStream	^(super parseDocumentFrom: aStream) document! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 11/30/2000 17:48'!dtd	^dtd! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 11/30/2000 17:48'!dtd: aDTD	dtd _ aDTD! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 5/16/2003 14:09'!encoding		^encoding ifNil: ['UTF-8']! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!encoding: aString		encoding _ aString! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!requiredMarkup		^requiredMarkup! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!requiredMarkup: aString		requiredMarkup _ aString! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!version		^version! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!version: aString		version _ aString! !!XMLDocument methodsFor: 'printing' stamp: 'mir 1/17/2002 16:44'!printCanonicalOn: aStream	| writer |	writer _ XMLWriter on: aStream.	writer canonical: true.	self printXMLOn: writer! !!XMLDocument methodsFor: 'printing' stamp: 'mir 5/16/2003 14:08'!printXMLOn: writer	version ifNotNil: [writer xmlDeclaration: self version encoding: self encoding].	super printXMLOn: writer! !!XMLElement methodsFor: 'initialize' stamp: 'mir 8/14/2000 17:58'!addContent: contentString	self contents add: contentString! !!XMLElement methodsFor: 'initialize' stamp: 'mir 1/17/2002 15:24'!name: aString	name _ aString asSymbol! !!XMLElement methodsFor: 'initialize' stamp: 'mir 3/7/2000 16:43'!setAttributes: newAttributes	attributes _ newAttributes! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/18/2001 16:55'!attributeAt: attributeName	^self attributeAt: attributeName ifAbsent: [nil]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/18/2001 16:55'!attributeAt: attributeName ifAbsent: aBlock	^self attributes at: attributeName ifAbsent: [^aBlock value]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:24'!attributeAt: attributeName put: attributeValue	self attributes at: attributeName asSymbol put: attributeValue! !!XMLElement methodsFor: 'accessing' stamp: 'mas 10/15/2003 09:18'!attributes	^attributes ifNil: [attributes _ Dictionary new]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 3/7/2000 16:24'!characterData	^self contentString! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/18/2001 16:27'!contentString	^(self contents size == 1		and: [self contents first isKindOf: XMLStringNode])		ifTrue: [self contents first string]		ifFalse: ['']! !!XMLElement methodsFor: 'accessing' stamp: 'mir 6/18/2003 13:47'!contentStringAt: entityName	^(self elementAt: entityName ifAbsent: [^'']) contentString! !!XMLElement methodsFor: 'accessing' stamp: 'mir 8/14/2000 17:58'!contents	contents ifNil: [contents _ OrderedCollection new].	^contents! !!XMLElement methodsFor: 'accessing' stamp: 'sd 5/25/2003 18:25'!name	^ self qualifiedName! !!XMLElement methodsFor: 'accessing' stamp: 'sd 5/25/2003 18:25'!tag	^ self name asSymbol! !!XMLElement methodsFor: 'accessing' stamp: 'mir 6/5/2003 12:02'!valueFor: aSymbol 	^self valueFor: aSymbol ifAbsent: ['']! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:28'!valueFor: aSymbol ifAbsent: aBlock 	^self attributes at: aSymbol ifAbsent: aBlock! !!XMLElement methodsFor: 'enumerating' stamp: 'mir 10/25/2000 11:15'!contentsDo: aBlock	contents		ifNotNil: [			self contents do: [:each | aBlock value: each]]! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:34'!firstTagNamed: aSymbol 	"Return the first encountered node with the specified tag.	If it is not the receiver, pass the message on"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [^self].	^super firstTagNamed: aSymbol ! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:34'!firstTagNamed: aSymbol with: aBlock	"Return the first encountered node with the specified tag that allows	the block to evaluate to true. Pass the message on"	((self localName == aSymbol		or: [self tag == aSymbol]) 		and: [aBlock value: self])		ifTrue: [^self].	^super firstTagNamed: aSymbol with: aBlock.! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:33'!tagsNamed: aSymbol contentsDo: aBlock	"Evaluate aBlock for all of the contents of the receiver	if the receiver tag equals aSymbol. Pass the message on"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [self contentsDo: aBlock].	super tagsNamed: aSymbol contentsDo: aBlock! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol do: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock	with the receiver. Continue the search"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self].	super tagsNamed: aSymbol do: aOneArgumentBlock! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock with the receiver"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self]! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock	with the receiver. Then recurse through all the children"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self].	super tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol ifReceiverOrChildDo: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock with the receiver.	For each of the receivers children do the same. Do not go beyond direct children"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self].	super tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock! !!XMLElement methodsFor: 'testing' stamp: 'mir 3/6/2002 10:48'!isEmpty	^self elements isEmpty		and: [self contents isEmpty]! !!XMLElement methodsFor: 'testing' stamp: 'mir 1/17/2002 15:26'!isTag	^true! !!XMLElement methodsFor: 'name space' stamp: 'sd 5/25/2003 18:24'!localName	^ name! !!XMLElement methodsFor: 'name space' stamp: 'mir 6/5/2003 15:20'!qualifiedName	^self namespace		ifNil: [self localName]		ifNotNil: [self namespace , ':' , self localName]! !!XMLElement methodsFor: 'printing' stamp: 'mir 1/17/2002 16:58'!printXMLOn: writer	writer startElement: self name attributeList: self attributes.	(writer canonical not		and: [self isEmpty and: [self attributes isEmpty not]])		ifTrue: [writer endEmptyTag: self name]		ifFalse: [			writer endTag.			self contentsDo: [:content | content printXMLOn: writer].			super printXMLOn: writer.			writer endTag: self name]! !!XMLElement class methodsFor: 'instance creation' stamp: 'mir 3/7/2000 16:33'!named: aString	^self new name: aString! !!XMLElement class methodsFor: 'instance creation' stamp: 'mir 8/14/2000 18:01'!named: aString attributes: attributeList	^self new		name: aString;		setAttributes: attributeList! !!XMLElement class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 15:21'!named: aString namespace: ns uri: uri attributes: attributeList	^self new		name: aString;		namespace: ns uri: uri;		setAttributes: attributeList! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/4/2003 15:51'!currentScope	^self scope last! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/4/2003 16:08'!establishLocalBindings	(self currentScope at: 2)		ifNil: [			currentBindings := currentBindings copy.			self currentScope at: 2 put: currentBindings]! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/24/2003 14:25'!initScope	scope := OrderedCollection new: 20.	currentBindings := Dictionary new.	scope addLast: {'http://www.w3.org/TR/REC-xml-names'. currentBindings. nil. }.! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/5/2003 19:32'!namespaceAliases: namespace	"Locate all namespaces that are aliases of the given URI."	| aliases uri |	aliases _ Set new.	uri _ self namespaceURIOf: namespace ifAbsent: [self parseError: 'Attribute refers to undefined namespace ' , namespace asString ].	currentBindings keysAndValuesDo: [:ns :u |		(u = uri			and: [ns ~= namespace])			ifTrue: [aliases add: ns]].	^ aliases! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/24/2003 14:26'!scope	scope ifNil: [self initScope].	^scope! !!XMLNamespaceScope methodsFor: 'scope' stamp: 'mir 6/16/2003 16:37'!declareNamespace: ns uri: uri	"Declare the given name space prefix with the given URL"	ns = 'xmlns'		ifTrue: [^self defaultNamespace: uri].	self establishLocalBindings.	currentBindings removeKey: ns ifAbsent: [].	currentBindings at: ns put: uri! !!XMLNamespaceScope methodsFor: 'scope' stamp: 'mir 6/5/2003 19:28'!enterScope	self scope addLast: { self defaultNamespace. nil. currentBindings. }! !!XMLNamespaceScope methodsFor: 'scope' stamp: 'mir 6/4/2003 16:05'!leaveScope	| leftScope |	leftScope := self scope removeLast.	currentBindings := (self currentScope at: 2) ifNil: [leftScope at: 3]! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/24/2003 14:22'!defaultNamespace	^self currentScope first! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/24/2003 14:23'!defaultNamespace: ns	"Declare the default namespace."	self currentScope at: 1 put: ns! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'sd 5/28/2003 09:33'!namespaceURIOf: ns	"Retrieve the URI of the given namespace prefix, if it is defined. A nil namespace	returns the global namespace"	^ self namespaceURIOf: ns ifAbsent: [ nil ]! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/24/2003 13:33'!namespaceURIOf: ns ifAbsent: aBlock	"Retrieve the URI of the given namespace prefix, if it is defined. 	A nil namespace returns the default namespace. 	If no namespace can be found the value of the block is returned"	^ns		ifNil: [self defaultNamespace]		ifNotNil: [currentBindings at: ns ifAbsent: aBlock]! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/5/2003 19:32'!namespaces	^currentBindings! !!XMLNamespaceScope methodsFor: 'validation' stamp: 'mir 6/5/2003 17:16'!validateAttributes: attributeList	"check all attribute namespaces are defined and not duplicated by aliasing"	| namespace localName |	attributeList keysDo: [:attrName |		self splitName: attrName into: [:ns :ln |			namespace _ ns.			localName _ ln].		namespace ifNotNil: [			(self namespaceAliases: namespace) do: [:alias |				(attributeList includesKey: alias , ':' , localName)					ifTrue: [self parseError: 'Attributes ' , attrName , ' and ' , alias , ':' , localName , ' are aliased to namespace ' , (self namespaceURIOf: namespace) ]]]]! !!XMLNode methodsFor: 'accessing' stamp: 'mir 1/8/2002 18:44'!addContent: contentString	SAXParseException signal: 'Illegal string data.'! !!XMLNode methodsFor: 'enumerating' stamp: 'mir 1/17/2002 14:49'!contentsDo: aBlock! !!XMLNode methodsFor: 'enumerating' stamp: 'mir 3/6/2002 10:56'!elementsDo: aBlock! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:52'!firstTagNamed: aSymbol 	"Return the first encountered node with the specified tag. Pass the message on"	| answer |	self elementsDo: [:node | (answer _ node firstTagNamed: aSymbol) ifNotNil: [^answer]].	^nil! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!firstTagNamed: aSymbol with: aBlock	"Return the first encountered node with the specified tag that	allows the block to evaluate to true. Pass the message on"	| answer |	self elementsDo: [:node |		(answer _ node firstTagNamed: aSymbol with: aBlock) ifNotNil: [^answer]].	^nil! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol childrenDo: aOneArgumentBlock	"Evaluate aOneArgumentBlock for all children who match"	self elementsDo: [:each | 		each tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol childrenDoAndRecurse: aOneArgumentBlock	"Evaluate aOneArgumentBlock for all children who match and recurse"	self elementsDo: [:each | 		each tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol contentsDo: aBlock	"Evaluate aBlock for all of the contents of the receiver.	The receiver has no tag, so pass the message on"	self elementsDo: [:each | each tagsNamed: aSymbol contentsDo: aBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol do: aOneArgumentBlock	"Search for nodes with tag aSymbol. When encountered evaluate aOneArgumentBlock"	self elementsDo: [:each | each tagsNamed: aSymbol do: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'SqR 7/2/2000 15:58'!tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock	"Handled only by XMLTagNode subclass"! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock	"Recurse all children"	self elementsDo: [:each | each tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol ifReceiverOrChildDo: aOneArgumentBlock	"Recurse all children"	self elementsDo: [:each | each tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock]! !!XMLNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:28'!isProcessingInstruction	^false! !!XMLNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:26'!isTag	^false! !!XMLNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:26'!isText	^false! !!XMLNode methodsFor: 'printing' stamp: 'mir 1/17/2002 15:45'!printOn: stream	self printXMLOn: (XMLWriter on: stream)! !!XMLNode methodsFor: 'printing' stamp: 'mir 1/17/2002 15:45'!printXMLOn: writer	self subclassResponsibility! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 11:01'!addElement: element	self elements add: element! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:22'!addEntity: entityName value: entityValue	self entities add: entityName->entityValue! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 10:46'!elementAt: entityName	^self elementAt: entityName ifAbsent: [nil]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 6/25/2003 13:27'!elementAt: entityName ifAbsent: aBlock	elements		ifNil: [^aBlock value].	^self elements detect: [:each | each name = entityName or: [each localName = entityName]] ifNone: [^aBlock value]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 6/16/2003 17:36'!elementUnqualifiedAt: entityName	^self elementUnqualifiedAt: entityName ifAbsent: [nil]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 6/16/2003 17:36'!elementUnqualifiedAt: entityName ifAbsent: aBlock	elements		ifNil: [^aBlock value].	^self elements detect: [:each | each localName = entityName] ifNone: [^aBlock value]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 10:54'!elements	elements ifNil: [elements _ OrderedCollection new].	^elements! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 10:50'!topElement	^self elements first! !!XMLNodeWithElements methodsFor: 'enumerating' stamp: 'mir 3/6/2002 10:45'!elementsDo: aBlock	elements		ifNotNil: [			self elements do: [:each | aBlock value: each]]! !!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/5/2003 15:20'!namespace	^ namespace! !!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/16/2003 16:21'!namespace: ns uri: u	namespace _ ns.	uri _ u! !!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/5/2003 15:20'!namespaceURI	^ uri! !!XMLNodeWithElements methodsFor: 'printing' stamp: 'mir 3/6/2002 10:49'!printXMLOn: writer	self elementsDo: [:element | element printXMLOn: writer]! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!data	^data! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!data: aString	data _ aString! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!target	^target! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!target: aString	target _ aString! !!XMLPI methodsFor: 'testing' stamp: 'mir 1/17/2002 15:28'!isProcessingInstruction	^true! !!XMLPI methodsFor: 'printing' stamp: 'mir 1/17/2002 15:53'!printXMLOn: writer	writer pi: self target data: self data! !!XMLPI class methodsFor: 'instance creation' stamp: 'mir 1/17/2002 13:03'!target: targetName data: aString	^self new		target: targetName;		data: aString! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:51'!attribute: aSymbol value: aString	"This method is called for each attribute/value pair in a start tag"	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!beginStartTag: aSymbol asPI: aBoolean	"This method is called for at the beginning of a start tag.	The asPI parameter defines whether or not the tag is a 'processing	instruction' rather than a 'normal' tag."	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!endStartTag: aSymbol	"This method is called at the end of the start tag after all of the	attributes have been processed"	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!endTag: aSymbol	"This method is called when the parser encounters either an	end tag or the end of a unary tag"	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!text: aString	"This method is called for the blocks of text between tags.	It preserves whitespace, but has all of the enclosed entities expanded"	^self subclassResponsibility! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:27'!handleCData: aString	self text: aString! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:26'!handleEndTag: aString	self endTag: aString! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:27'!handlePCData: aString	self text: aString! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:26'!handleStartTag: tagName attributes: attributes	self beginStartTag: tagName asPI: false.	attributes keysAndValuesDo: [:key :value |		self attribute: key value: value].	self endStartTag: tagName! !!XMLStringNode methodsFor: 'accessing'!characterData	^self string! !!XMLStringNode methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:28'!string	^string ifNil: ['']! !!XMLStringNode methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:28'!string: aString	string _ aString! !!XMLStringNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:27'!isText	^true! !!XMLStringNode methodsFor: 'printing' stamp: 'mir 1/17/2002 15:53'!printXMLOn: writer	writer pcData: self string! !!XMLStringNode class methodsFor: 'instance creation' stamp: 'mir 10/25/2000 11:30'!string: aString	^self new string: aString! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 22:58'!atEnd	nestedStreams == nil		ifTrue: [^peekChar == nil and: [stream atEnd]].	^stream atEnd		ifTrue: [			self popNestingLevel.			self atEnd]		ifFalse: [false]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 22:59'!checkNestedStream	nestedStreams == nil		ifFalse: [(peekChar == nil and: [self stream atEnd])			ifTrue: [				self popNestingLevel.				self checkNestedStream]]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 6/28/2001 16:45'!hasNestedStreams	^nestedStreams notNil! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:04'!next	"Return the next character from the current input stream. If the current stream is at end pop to next nesting level if there is one.	Due to the potential nesting of original document, included documents and replacment texts the streams are held in a stack representing the nested streams. The current stream is the top one."	| nextChar |	peekChar		ifNil: [			nestedStreams ifNotNil: [self checkNestedStream].			^nextChar _ stream next]		ifNotNil: [			nextChar _ peekChar.			peekChar _ nil.			^nextChar].	! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:27'!nextTrimmedBlanksUpTo: delimiter	| resultStream nextChar |	resultStream _ WriteStream on: (String new: 10).	nextChar _ nil.	[peekChar _ self peek.	peekChar		ifNotNil: [			[peekChar == $ 				and: [nextChar == $ ]]				whileTrue: [peekChar _ self next]].	(nextChar _ self next) == delimiter]		whileFalse: [resultStream nextPut: nextChar].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found'].	^resultStream contents! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 5/14/2003 18:44'!nextUpTo: delimiter	| resultStream nextChar |	resultStream _ WriteStream on: (String new: 10).	[self atEnd or: [(nextChar _ self next) == delimiter]]		whileFalse: [resultStream nextPut: nextChar].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found'].	^resultStream contents! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/9/2002 15:29'!nextUpToAll: delimitingString	| string |	self unpeek.	string _ self stream upToAll: delimitingString.	self stream skip: delimitingString size negated.	(self stream next: delimitingString size) = delimitingString		ifFalse: [self parseError: 'XML no delimiting ' , delimitingString printString , ' found'].	^string! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:05'!peek	"Return the next character from the current input stream. If the current stream poop to next nesting level if there is one.	Due to the potential nesting of original document, included documents and replacment texts the streams are held in a stack representing the nested streams. The current stream is the top one."	peekChar		ifNil: [			nestedStreams ifNotNil: [self checkNestedStream].			^peekChar _ stream next]		ifNotNil: [^peekChar]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 6/29/2001 00:36'!popNestingLevel	self hasNestedStreams		ifTrue: [			self stream close.			self stream: self nestedStreams removeLast.			self nestedStreams size > 0				ifFalse: [nestedStreams _ nil]]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/16/2002 10:50'!pushBack: aString	| pushBackString |	pushBackString _ peekChar		ifNil: [aString]		ifNotNil: [peekChar asString , aString].	peekChar _ nil.	self pushStream: (ReadStream on: pushBackString)! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/16/2002 10:54'!pushStream: newStream	"Continue parsing from the new nested stream."	self unpeek.	self nestedStreams addLast: self stream.	self stream: newStream! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 22:54'!skipSeparators	| nextChar |	[((nextChar _ self peek) == nil)		or: [SeparatorTable at: nextChar asciiValue+1]]		whileFalse: [self next].	(nestedStreams == nil or: [self atEnd not])		ifFalse: [			self checkNestedStream.			self skipSeparators]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/16/2002 10:42'!skipUpTo: delimiter	| nextChar |	self unpeek.	[self atEnd or: [(nextChar _ self next) == delimiter]]		whileFalse: [].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found']! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/17/2002 14:31'!topStream	^self hasNestedStreams		ifTrue: [self nestedStreams first]		ifFalse: [self stream]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 5/14/2003 18:45'!unpeek	peekChar		ifNotNil: [			self stream pushBack: (String with: peekChar).			peekChar _ nil]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:12'!checkAndExpandReference: parsingContext	| referenceString nextChar |	nextChar _ self peek.	self validating		ifFalse: [^nil].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [^self pushStream: (ReadStream on: self nextCharReference asString)].			referenceString _ self nextLiteral.			self next == $;				ifFalse: [self errorExpected: ';'].			self handleEntity: referenceString in: parsingContext ]		ifFalse: [			((nextChar == $%				and: [self parsingMarkup])				and: [parsingContext == #entityValue])				ifTrue: [					self skipSeparators.					referenceString _ self nextLiteral.					self handleEntity: referenceString in: parsingContext]].	self atEnd ifTrue: [self errorExpected: 'Character expected.'].	^nextChar! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/16/2000 21:41'!conditionalInclude: conditionalKeyword	conditionalKeyword = 'INCLUDE'		ifTrue: [^true].	conditionalKeyword = 'IGNORE'		ifTrue: [^false].	^self conditionalInclude: (self parameterEntity: conditionalKeyword) value! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 16:32'!nextAttributeInto: attributes namespaces: namespaces	| attrName attrValue |	attrName _ self nextName.	self skipSeparators.	self next == $=		ifFalse: [self errorExpected: '='].	self skipSeparators.	attrValue _ self nextAttributeValue.	(self usesNamespaces		and: [(attrName findString: 'xmlns') = 1])		ifTrue: [attrName size > 6			ifTrue: [namespaces at: (attrName copyFrom: 7 to: attrName size) put: attrValue]			ifFalse: [namespaces at: attrName put: attrValue]]		ifFalse: [attributes at: attrName put: attrValue]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 3/14/2003 23:34'!nextAttributeValue	| delimiterChar attributeValueStream nextChar nextPeek referenceString entity entityValue |	delimiterChar _ self next.	(delimiterChar == $"		or: [delimiterChar == $'])		ifFalse: [self errorExpected: 'Attribute value delimiter expected.'].	attributeValueStream _ attributeBuffer reset.	[	nextPeek _ nextChar _ self next.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self peek == $#				ifTrue: [					nextPeek _ nil.					nextChar _ self nextCharReference]				ifFalse: [					referenceString _ self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity _ self entity: referenceString.					entityValue _ entity valueForContext: #content.					(self class isCharEscape: entityValue)						ifTrue: [							nextPeek _ nil.							nextChar _ entityValue]						ifFalse: [							entityValue _ entityValue asString.							entityValue isEmpty								ifTrue: [nextPeek _ nextChar _ nil]								ifFalse: [									self pushStream: (ReadStream on: entityValue asString).									nextPeek _ nextChar _ self next]]]].	nextPeek == delimiterChar]		whileFalse: [			nextChar ifNotNil: [attributeValueStream nextPut: nextChar]].	^self fastStreamStringContents: attributeValueStream"	^attributeValueStream contents"! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 17:00'!nextCDataContent	| cdata |	"Skip $[ "	self next.	cdata _ self nextUpToAll: ']]>'.	self handleCData: cdata! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 12/6/2000 14:29'!nextCDataOrConditional	| nextChar conditionalKeyword |	"Skip ["	self next.	self skipSeparators.	nextChar _ self peek.	nextChar == $%		ifTrue: [			self checkAndExpandReference: (self parsingMarkup ifTrue: [#dtd] ifFalse: [#content]).			conditionalKeyword _ self nextLiteral.			self skipSeparators.			^self next == $[				ifTrue: [						self skipSeparators.						self nextIncludeSection: (self conditionalInclude: conditionalKeyword)]				ifFalse: [self errorExpected: '[' ]].	nextChar == $C		ifTrue: [			^self nextLiteral = 'CDATA'				ifTrue: [self peek == $[							ifTrue: [self nextCDataContent]							ifFalse: [self errorExpected: '[' ]]				ifFalse: [self errorExpected: 'CData']].	self errorExpected: 'CData or declaration'! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mu 11/14/2005 14:07'!nextCharReference	| base charValue |	self next == $#		ifFalse: [self errorExpected: 'character reference'].	base _ self peek == $x		ifTrue: [			self next.			16]		ifFalse: [10].	charValue _ [self readNumberBase: base] on: Error do: [:ex | self errorExpected: 'Number.'].	(self next) == $;		ifFalse: [self errorExpected: '";"'].	^Unicode value: charValue! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/28/2000 17:54'!nextComment	| string |	"Skip first -"	self next.	self next == $-		ifFalse: [self errorExpected: 'second comment $-'].	string _ self nextUpToAll: '-->'.	self handleComment: string! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 3/14/2003 23:27'!nextEndTag	| string |	"Skip /"	self next.	self skipSeparators.	string _ self nextTrimmedBlanksUpTo: $>.	"string _ (self nextUpTo: $>) withBlanksTrimmed."	self handleEndTag: string! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'cwp 6/17/2003 21:04'!nextEntity	"return the next XMLnode, or nil if there are no more"	"branch, depending on what the first character is"	self nextWhitespace.	self atEnd ifTrue: [self handleEndDocument. ^ nil].	self checkAndExpandReference: (self parsingMarkup ifTrue: [#dtd] ifFalse: [#content]).	^self peek = $<		ifTrue: [self nextNode]		ifFalse: [self nextPCData]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:14'!nextEntityValue	| delimiterChar entityValueStream nextChar nextPeek referenceString entity entityValue |	delimiterChar _ self next.	(delimiterChar == $"		or: [delimiterChar == $'])		ifFalse: [self errorExpected: 'Entity value delimiter expected.'].	entityValueStream _ WriteStream on: (String new).	[	nextPeek _ nextChar _ self peek.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [					nextPeek _ nil.					nextChar _ self nextCharReference]				ifFalse: [					referenceString _ self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity _ self entity: referenceString.					entityValue _ entity valueForContext: #entityValue.					self pushStream: (ReadStream on: entityValue asString).					nextPeek _ nextChar _ self next]]		ifFalse: [			nextChar == $%				ifTrue: [					self skipSeparators.					referenceString _ self nextLiteral.					nextChar _ self handleEntity: referenceString in: #entityValue.					nextPeek _ nextChar _ self next]				ifFalse: [self next]].	nextPeek == delimiterChar]		whileFalse: [			nextChar ifNotNil: [entityValueStream nextPut: nextChar]].	^entityValueStream contents! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/28/2001 16:38'!nextIncludeSection: parseSection	| section |	"Read the file up to the next include section delimiter and parse it if parseSection is true"		section _ self nextUpToAll: ']]>'.	parseSection		ifTrue: [			self pushStream: (ReadStream on: section)]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 3/14/2003 19:56'!nextLiteral	| resultStream nextChar resultString |	resultStream _ (String new: 10) writeStream.	((nextChar _ self peek) isLetter		or: [nextChar == $_])		ifFalse: [self errorExpected: 'Name literal.'].	[nextChar _ self peek.	(LiteralChars at: nextChar asciiValue+1)		ifTrue: [			nextChar == $&				ifTrue: [					nextChar _ self next.					resultStream nextPut: (self peek == $#						ifTrue: [self nextCharReference]						ifFalse: [^resultStream contents])]				ifFalse: [					resultStream nextPut: self next]]		ifFalse: [resultString _ resultStream contents.			resultString isEmpty				ifTrue: [self errorExpected: 'Name literal']				ifFalse: [^resultString]]] repeat! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 3/14/2003 23:10'!nextName	| nextChar |	nameBuffer reset.	self peek == $.		ifTrue: [self malformedError: 'Character expected.'].	[(nextChar _ self peek)		ifNil: [self errorExpected: 'Character expected.'].	NameDelimiters at: nextChar asciiValue] whileFalse: [			nameBuffer nextPut: self next].	^self fastStreamStringContents: nameBuffer"	^nameBuffer contents"! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/28/2000 17:52'!nextNode	| nextChar |	"Skip < "	self next.	nextChar _ self peek.	nextChar == $!! ifTrue: [		"Skip !!"		self next.		nextChar _ self peek.		nextChar == $- ifTrue: [^self nextComment].		nextChar == $[ ifTrue: [^self nextCDataOrConditional].		^self parsingMarkup			ifTrue: [self nextMarkupDeclaration]			ifFalse: [self nextDocType]].	nextChar == $? ifTrue: [^self nextPI].	^self nextTag! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:01'!nextPCData	| resultStream nextChar referenceString entity entityValue nextPeek |	resultStream _ (String new: 10) writeStream.	self validating		ifFalse: [			[self peek == $<]				whileFalse: [resultStream nextPut: self next].			^self handlePCData: resultStream contents].	[	nextPeek _ nextChar _ self peek.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [					nextPeek _ nil.					nextChar _ self nextCharReference]				ifFalse: [					referenceString _ self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity _ self entity: referenceString.					entityValue _ entity valueForContext: #content.					(self class isCharEscape: entityValue)						ifTrue: [							nextPeek _ nil.							nextChar _ entityValue]						ifFalse: [							entityValue _ entityValue asString.							entityValue isEmpty								ifTrue: [nextPeek _ nextChar _ nil]								ifFalse: [									self pushStream: (ReadStream on: entityValue asString).									nextPeek _ nextChar _ self peek]]]]		ifFalse: [nextPeek == $< ifFalse: [self next]].	nextPeek == $<]		whileFalse: [			nextChar ifNotNil: [resultStream nextPut: nextChar]].	self handlePCData: resultStream contents! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 13:00'!nextPI	| piTarget piData |	"Skip ?"	self next.	piTarget _ self nextLiteral.	piTarget asUppercase = 'XML'		ifTrue: [^self nextXMLDecl].	self skipSeparators.	piData _ self nextUpToAll: '?>'.	self handlePI: piTarget data: piData! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 14:25'!nextPubidLiteral	^self nextAttributeValue! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 14:25'!nextSystemLiteral	^self nextAttributeValue! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 22:37'!nextTag	| tagName attributes nextChar namespaces |	(self peek = $/)		ifTrue: [^self nextEndTag].	tagName _ self nextName.	self skipSeparators.	attributes _ Dictionary new: 33.	namespaces _ Dictionary new: 5.	[(nextChar _ self peek) == $> or: [nextChar == $/]] whileFalse: [		self checkAndExpandReference: #content.		self nextAttributeInto: attributes namespaces: namespaces.		self skipSeparators.].	self handleStartTag: tagName attributes: attributes namespaces: namespaces.	self next == $/		ifTrue: [			self handleEndTag: tagName.			self next].	! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mu 11/9/2005 09:43'!nextWhitespace	| nextChar resultStream resultString|	resultStream _ (String new: 10) writeStream.	[((nextChar _ self peek) == nil)		or: [SeparatorTable at: nextChar asciiValue+1 ifAbsent:[true]]]		whileFalse: [resultStream nextPut: nextChar. self next].	(nestedStreams == nil or: [self atEnd not])		ifFalse: [self checkNestedStream.				self nextWhitespace].	resultString _ resultStream contents.	resultString isEmpty ifFalse: [self handleWhitespace: resultString].! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 14:52'!nextXMLDecl	| attributes nextChar namespaces |	self skipSeparators.	attributes _ Dictionary new.	namespaces _ Dictionary new.	[(nextChar _ self peek) == $?] whileFalse: [		self nextAttributeInto: attributes namespaces: namespaces.		self skipSeparators.].	self next.	self next == $>		ifFalse: [self errorExpected: '> expected.'].	self handleXMLDecl: attributes namespaces: namespaces! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 6/29/2001 00:08'!endDocTypeDecl	"Skip ]>"	self next; next.	^nil! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/8/2002 13:54'!nextDocType	| declType |	declType _ self nextLiteral.	declType = 'DOCTYPE'		ifTrue: [			self startParsingMarkup.			^self nextDocTypeDecl].	self errorExpected: 'markup declaration, not ' , declType printString! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 17:29'!nextDocTypeDecl	| nextChar |	self skipSeparators.	self nextLiteral.	self skipSeparators.	self peek == $[		ifFalse: [[nextChar _ self peek.				nextChar == $> or: [nextChar == $[ ]] whileFalse: [self next]].	self peek == $[		ifTrue: [			self next.			[self skipSeparators.			self peek == $]] whileFalse: [				self checkAndExpandReference: #dtd.				self nextNode].			self next == $] 				ifFalse: [self errorExpected: ']' ]].	self skipSeparators.	self next == $>		ifFalse: [self errorExpected: '>' ].	self endParsingMarkup! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 14:24'!nextEntityDeclaration	| entityName entityDef referenceClass reference |	self skipSeparators.	referenceClass _ self peek == $%		ifTrue: [			self next.			self skipSeparators.			DTDParameterEntityDeclaration]		ifFalse: [DTDEntityDeclaration].	entityName _ self nextLiteral.	self skipSeparators.	entityDef _ (self peek == $" or: [self peek == $'])		ifTrue: [self nextEntityValue]		ifFalse: [self nextExternalId].	self skipUpTo: $>.	reference _ referenceClass name: entityName value: entityDef.	reference registerIn: self.	^reference! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'rkris 7/28/2004 12:35'!nextExternalId	| extDefType systemId dir |	extDefType _ self nextLiteral.	extDefType = 'PUBLIC'		ifTrue: [			self skipSeparators.			self nextPubidLiteral.			self skipSeparators.			self peek == $>				ifFalse: [					systemId _ self nextSystemLiteral]].	extDefType = 'SYSTEM'		ifTrue: [			self skipSeparators.			systemId _ self nextSystemLiteral].	systemId		ifNil: [^nil].	"The rest of this method only applies if we're reading aFileStream"	(self topStream isKindOf: FileStream)		ifFalse: [^''].	dir _ self topStream directory.	^(dir fileExists: systemId)		ifTrue: [(dir readOnlyFileNamed: systemId) contentsOfEntireFile]		ifFalse: ['']! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 13:49'!nextMarkupDeclaration	| declType |	declType _ self nextLiteral.	self validating		ifFalse: [^self skipMarkupDeclaration].	declType = 'ENTITY'		ifTrue: [self nextEntityDeclaration]		ifFalse: [self skipMarkupDeclaration]! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/4/2002 11:05'!skipMarkupDeclaration	self skipUpTo: $>! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!endParsingMarkup	parsingMarkup _ false! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 3/14/2003 23:09'!fastStreamStringContents: writeStream	| newSize |	newSize _ writeStream position.	^(String new: newSize)		replaceFrom: 1		to: newSize		with: writeStream originalContents		startingAt: 1! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 12/7/2000 16:46'!log: aString	"Transcript show: aString; cr"! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:54'!nestedStreams	nestedStreams ifNil: [nestedStreams _ OrderedCollection new].	^nestedStreams! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!parsingMarkup	^parsingMarkup! !!XMLTokenizer methodsFor: 'private' stamp: 'mu 11/14/2005 14:12'!readNumberBase: base	"Read a hex number from stream until encountering $; "	| value digit |	base = 10 ifFalse: [	| numberString | 		numberString _ self nextUpTo: $;.		self stream skip: -1.		^Integer readFrom: numberString asUppercase readStream base: base. 	].	value _ 0.	digit _ DigitTable at: self peek asciiValue.	digit < 0		ifTrue: [self error: 'At least one digit expected here'].	self next.	value _ digit.	[digit _ DigitTable at: self peek asciiValue.	digit < 0		ifTrue: [^value]		ifFalse: [			self next.			value _ value * base + digit]		] repeat.	^ value! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!startParsingMarkup	parsingMarkup _ true! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:50'!stream	^stream! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:50'!stream: newStream	"Continue parsing from the new nested stream."	stream _ newStream! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 15:06'!entities	entities ifNil: [entities _ self initEntities].	^entities! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/17/2002 13:53'!entity: refName	^self validating		ifTrue: [self entities			at: refName			ifAbsentPut: [self parseError: 'XML undefined entity ' , refName printString]]		ifFalse: [DTDEntityDeclaration name: refName value: '']! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:43'!entity: refName put: aReference	"Only the first declaration of an entity is valid so if there is already one don't register the new value."	self entities at: refName ifAbsentPut: [aReference]! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 17:59'!externalEntities	externalEntities ifNil: [externalEntities _ Dictionary new].	^externalEntities! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 17:59'!externalEntity: refName	^self entities		at: refName		ifAbsentPut: ['']! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/17/2002 18:12'!handleEntity: referenceString in: parsingContext 	| entity entityValue |	entity _ self entity: referenceString.	entityValue _ entity valueForContext: parsingContext.	(self class isCharEscape: entityValue)		ifTrue: [entityValue _ entity reference].	self pushStream: (ReadStream on: entityValue asString)! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 8/17/2004 16:52'!initEntities	| ents |	ents _ Dictionary new.	ents		at: 'amp' put: (DTDEntityDeclaration name: 'amp' value: $&);		at: 'quot' put: (DTDEntityDeclaration name: 'quot' value: $");		at: 'apos' put: (DTDEntityDeclaration name: 'apos' value: $');		at: 'gt' put: (DTDEntityDeclaration name: 'gt' value: $>);		at: 'lt' put: (DTDEntityDeclaration name: 'lt' value: $<).	^ents! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:20'!parameterEntities	parameterEntities ifNil: [parameterEntities _ Dictionary new].	^parameterEntities! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:40'!parameterEntity: refName	^self parameterEntities		at: refName		ifAbsent: [self parseError: 'XML undefined parameter entity ' , refName printString]! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:42'!parameterEntity: refName put: aReference	"Only the first declaration of an entity is valid so if there is already one don't register the new value."	self parameterEntities at: refName ifAbsentPut: [aReference]! !!XMLTokenizer methodsFor: 'errors' stamp: 'mir 5/14/2003 18:27'!errorExpected: expectedString	| actualString |	actualString := ''.	self atEnd		ifFalse: [			[actualString := self next: 20]				on: Error				do: [:ex | ]].	self parseError: 'XML expected ' , expectedString printString , ': ' , actualString! !!XMLTokenizer methodsFor: 'errors' stamp: 'mir 1/9/2002 15:26'!malformedError: errorString	SAXMalformedException signal: errorString! !!XMLTokenizer methodsFor: 'errors' stamp: 'mir 1/8/2002 15:37'!parseError: errorString	SAXParseException signal: errorString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 11/13/2000 16:04'!handleCData: aString	self log: 'CData: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:37'!handleComment: aString	self log: 'Comment: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 18:27'!handleEndDocument	self log: 'End Doc '! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:38'!handleEndTag: aString	self log: 'End tag: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:38'!handlePCData: aString	self log: 'PCData: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 12/11/2000 16:10'!handlePI: piTarget data: piData	self log: 'PI: ' , piTarget , ' data ' , piData! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 18:26'!handleStartDocument	self log: 'Start Doc'! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:39'!handleStartTag: tagName attributes: attributes	self log: 'Start tag: ' , tagName.	attributes keysAndValuesDo: [:key :value |		self log: key , '->' , value]! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'cwp 6/17/2003 21:08'!handleWhitespace: aString	self log: 'Whitespace: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 6/5/2003 14:53'!handleXMLDecl: attributes namespaces: namespaces	attributes keysAndValuesDo: [:key :value |		self log: key , '->' , value]! !!XMLTokenizer methodsFor: 'initialize' stamp: 'mir 3/14/2003 19:27'!initialize	parsingMarkup _ false.	validating _ false.	attributeBuffer _ WriteStream on: (String new: 128).	nameBuffer _ WriteStream on: (String new: 128)! !!XMLTokenizer methodsFor: 'accessing' stamp: 'mir 6/28/2001 16:51'!parseStream: aStream	self stream: aStream! !!XMLTokenizer methodsFor: 'accessing' stamp: 'mir 1/14/2002 17:51'!validating: aBoolean	validating _ aBoolean! !!XMLTokenizer methodsFor: 'testing' stamp: 'mir 6/5/2003 16:33'!usesNamespaces	^false! !!XMLTokenizer methodsFor: 'testing' stamp: 'mir 1/14/2002 17:51'!validating	^validating! !!XMLTokenizer commentStamp: '<historical>' prior: 0!XMLTokenizerbolot@cc.gatech.edubreaks the stream of characters into a stream of XMLnodes (aka token stream)token stream is used by XMLparser to generate XMLdocument tree!!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 11:41'!addressBookXML	^'<addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 12/19/2005 16:10'!addressBookXMLWithDTD	^'<?xml version="1.0" encoding="UTF-8"?><!!DOCTYPE addressbook SYSTEM "addressbook.dtd"><addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 11:41'!exampleAddressBook	| tokenizer |	"XMLTokenizer exampleAddressBook"	tokenizer _ XMLTokenizer on: self addressBookXML readStream.	[tokenizer next notNil]		whileTrue: []! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 16:23'!exampleAddressBookWithDTD	| tokenizer |	"XMLTokenizer exampleAddressBookWithDTD"	tokenizer _ XMLTokenizer on: self addressBookXMLWithDTD readStream.	[tokenizer next notNil]		whileTrue: []! !!XMLTokenizer class methodsFor: 'class initialization' stamp: 'mir 3/14/2003 22:54'!initialize	"XMLTokenizer initialize"	| nameDelimiters |	CharEscapes _ #( $& $" $' $> $< ) asSet.	SeparatorTable  _ Array new: 256.	SeparatorTable atAllPut: true.	#(9 10 12 13 32) do: [:each | SeparatorTable at: each+1 put: false].	LiteralChars _ Array new: 256.	LiteralChars atAllPut: false.	':-_.' do: [:each | LiteralChars at: each asciiValue put: true].	1 to: 256 do: [:i | ((i-1) asCharacter isDigit or: [(i-1) asCharacter isLetter])		ifTrue: [LiteralChars at: i put: true]].	nameDelimiters _ #(9 10 12 13 32 61 "$= asInteger 61" 62 "$> asInteger" 47 "$/ asInteger").	NameDelimiters _ Array new: 256.	NameDelimiters atAllPut: false.	nameDelimiters do: [:each | NameDelimiters at: each put: true].	DigitTable _ Array new: 256.	DigitTable atAllPut: -1.	($0 to: $9) do: [:each | DigitTable at: each asciiValue put: each digitValue].	($A to: $F) do: [:each | DigitTable at: each asciiValue put: each digitValue].! !!XMLTokenizer class methodsFor: 'accessing' stamp: 'mir 1/15/2002 21:39'!isCharEscape: aChar	^CharEscapes includes: aChar! !!XMLTokenizer class methodsFor: 'instance creation' stamp: 'mir 8/2/2000 19:25'!new	^super new initialize! !!XMLTokenizer class methodsFor: 'instance creation' stamp: 'mir 11/16/2000 07:58'!on: aStream	^self new parseStream: aStream! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:04'!attribute: attributeName value: attributeValue	self stream		space;		nextPutAll: attributeName.	self		eq;		putAsXMLString: attributeValue! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/8/2000 17:55'!cdata: aString	self startCData.	self stream nextPutAll: aString.	self endCData! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/8/2000 17:56'!comment: aString	self startComment.	self stream nextPutAll: aString.	self endComment! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/8/2000 17:56'!endEmptyTag: tagName	self popTag: tagName.	self stream nextPutAll: '/>'.	self canonical		ifFalse: [self stream space]! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 15:25'!endTag	self stream nextPutAll: '>'.	"self canonical		ifFalse: [self stream space]"! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:52'!endTag: tagName	self endTag: tagName xmlns: nil! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 6/24/2003 14:46'!endTag: tagName xmlns: xmlns	self popTag: tagName.	self stream		nextPutAll: '</'.	(xmlns notNil		and: [xmlns ~= self defaultNamespace])		ifTrue: [self stream			nextPutAll: xmlns;			nextPut: $:].	stream nextPutAll: tagName.	self endTag.! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:13'!flush	self stream flush! !!XMLWriter methodsFor: 'writing xml' stamp: 'ar 12/15/2002 15:56'!pcData: aString	| lastIndex nextIndex |	lastIndex := 1.	"Unroll the first search to avoid copying"	nextIndex := String findFirstInString: aString inSet: XMLTranslationMap startingAt: lastIndex.	nextIndex = 0 ifTrue:[^self stream nextPutAll: aString].	[self stream nextPutAll: (aString copyFrom: lastIndex to: nextIndex-1).	self stream nextPutAll: (XMLTranslation at: (aString at: nextIndex)).	lastIndex := nextIndex + 1.	nextIndex := String findFirstInString: aString inSet: XMLTranslationMap startingAt: lastIndex.	nextIndex = 0] whileFalse.	self stream nextPutAll: (aString copyFrom: lastIndex to: aString size).! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/11/2000 16:12'!pi: piTarget data: piData	self startPI: piTarget.	self stream nextPutAll: piData.	self endPI! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 1/17/2002 17:07'!startElement: elementName attributeList: attributeList	self canonical		ifFalse: [self stream cr].	self startTag: elementName.	attributeList keys asSortedCollection do: [:key |		self attribute: key value: (attributeList at: key)]! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:51'!startTag: tagName	self startTag: tagName xmlns: nil! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 6/24/2003 14:10'!startTag: tagName xmlns: xmlns	self stream		nextPut: $<.	(xmlns notNil		and: [xmlns ~= self scope defaultNamespace])		ifTrue: [self stream			nextPutAll: xmlns;			nextPut: $:].	self stream		nextPutAll: tagName.	"self canonical		ifFalse: [self stream space]."	self pushTag: tagName! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 12:17'!xmlDeclaration: versionString encoding: encodingString	self canonical		ifFalse: [			self				startPI: 'xml';				attribute: 'version' value: versionString;				attribute: 'encoding' value: encodingString;				endPI.			self stream flush]! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:54'!canonical	^canonical! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:54'!canonical: aBoolean	canonical _ aBoolean! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:54'!stream	^stream! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:54'!stream: aStream	stream _ aStream! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 15:09'!declareNamespace: ns uri: uri	self scope declareNamespace: ns uri: uri! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 14:23'!defaultNamespace	^self scope defaultNamespace! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 14:23'!defaultNamespace: ns	"Declare the default namespace."	self scope defaultNamespace: ns! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 15:02'!enterScope	self scope enterScope! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 14:47'!leaveScope	self scope leaveScope! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!endCData	self stream nextPutAll: ']]>'! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!endComment	self stream nextPutAll: ' -->'! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 5/20/2003 12:13'!endPI	self stream nextPutAll: ' ?>'! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!startCData	self stream nextPutAll: '<!![CDATA['! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!startComment	self stream nextPutAll: '<-- '! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!startPI: identifier	self stream		nextPutAll: '<?';		nextPutAll: identifier;		space! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 8/8/2000 18:13'!endDecl: type	self endTag! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!endDeclaration	self stream		cr;		nextPut: $].	self endTag! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!startDecl: type	self stream		nextPutAll: '<!!';		nextPutAll: type asUppercase;		space! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!startDecl: type named: aString	self stream		nextPutAll: '<!!';		nextPutAll: type asUppercase;		space;		nextPutAll: aString;		space! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!startDeclaration: dtdName	self startDecl: 'DOCTYPE' named: dtdName.	self stream		nextPut: $[;		cr! !!XMLWriter methodsFor: 'private' stamp: 'mir 12/8/2000 18:00'!eq	self stream nextPut: $=! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/7/2000 16:23'!popTag: tagName	| stackTop |	stackTop _ self stack isEmpty		ifTrue: ['<empty>']		ifFalse: [self stack last].	^stackTop = tagName		ifTrue: [self stack removeLast]		ifFalse: [self error: 'Closing tag "' , tagName , '" does not match "' , stackTop]! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/7/2000 16:18'!pushTag: tagName	self stack add: tagName! !!XMLWriter methodsFor: 'private' stamp: 'mir 12/11/2000 16:24'!putAsXMLString: aValue	self stream nextPut: $".	self pcData: aValue.	self stream nextPut: $"! !!XMLWriter methodsFor: 'private' stamp: 'mir 6/24/2003 14:22'!scope	^scope! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/8/2000 17:02'!stack	^stack! !!XMLWriter methodsFor: 'initialize' stamp: 'mir 6/24/2003 13:41'!initialize	stack _ OrderedCollection new.	canonical _ false.	scope := XMLNamespaceScope new! !!XMLWriter class methodsFor: 'class initialization' stamp: 'ar 12/13/2002 01:04'!initialize	"XMLWriter initialize"	XMLTranslation := Dictionary new.	XMLTranslation		at: Character cr put: '&#13;';		at: Character lf put: '&#10;';		at: Character tab put: '&#9;';		at: $& put: '&amp;';		at: $< put: '&lt;';		at: $> put: '&gt;';"		at: $' put: '&apos;'; "		at: $" put: '&quot;'.	XMLTranslationMap := ByteArray new: 256.	XMLTranslation keysDo:[:ch| XMLTranslationMap at: ch asciiValue+1 put: 1].! !!XMLWriter class methodsFor: 'instance creation' stamp: 'mir 12/8/2000 17:54'!on: aStream	^self basicNew initialize stream: aStream! !Smalltalk condenseChanges!----SNAPSHOT----an Array(5 June 2008 3:23:31 pm) Squeak3.10.2-7179-basic-rc.image priorSource: 1846213!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!Smalltalk garbageCollect!----SNAPSHOT----an Array(5 June 2008 3:30:10 pm) Squeak3.10.2-7179-basic-rc.image priorSource: 1846241!----QUIT----an Array(5 June 2008 3:30:12 pm) Squeak3.10.2-7179-basic-rc.image priorSource: 1846835!----STARTUP----an Array(21 February 2009 2:07:48 am) as /bob/wip/310Build/Squeak3.10.2-7179-basic.image!'From Squeak3.10.2bc-beta of 16 December 2008 [latest update: #7179] on 16 February 2009 at 6:06:39 pm'!!TranscriptStream methodsFor: 'stream extensions' stamp: 'kph 2/16/2009 17:41' prior: 32961406!endEntry	"Display all the characters since the last endEntry, and reset the stream"	self semaphore critical:[		self changed: #appendEntry.		self logEntry.		self reset.	].! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'kph 2/16/2009 18:01'!logEntry	Preferences logTranscriptToFile ifTrue: [		(StandardFileStream fileNamed: 'transcript.log') setToEnd; nextPutAll: self contents; cr; close.	]! !Preferences addPreference: #logTranscriptToFile categories: #(logging) default: false balloonHelp:'Log transcript to a file'!----End fileIn of a stream----!self halt. HTTPSocket httpFileIn: 'installer.pbwiki.com/f/TranscriptToFile.cs'.!self halt. Preferences setPreference: #logTranscriptToFile toValue: true.!Smalltalk removeClassNamed: #Installer!SystemOrganization addCategory: #'Installer-Core'!Object subclass: #Installer	instanceVariableNames: 'answers packages messagesToSuppress'	classVariableNames: 'IsSetToTrapErrors Remembered SkipLoadingTests InstallerBindings ValidationBlock'	poolDictionaries: ''	category: 'Installer-Core'!!Installer commentStamp: 'kph 12/19/2007 14:42' prior: 0!Documentation now available at http://installer.pbwiki.com/Installer !!Installer class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!actionMatch: theLine reportOn: report ifNoMatch: aBlock	| line |		line := theLine withBlanksCondensed.	self allSubclassesDo: [:class |		(class canReportLine: line)		ifTrue: [ ^ class new action: theLine reportOn: report ]].	^ aBlock value! !!Installer class methodsFor: 'mantis' stamp: 'kph 2/15/2009 05:21'!bug: n fix: filename	Transcript cr; show: 'Code script in Mantis:', n asString, ' should read Installer mantis bug: ',n asString, ' fix: ', filename printString,'.'.		^ self mantis bug: n fix: filename! !!Installer class methodsFor: 'monticello' stamp: 'mtf 5/20/2008 22:10'!cache	^ self monticello cache! !!Installer class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!canReportLine: line	^ false! !!Installer class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:20'!cancelSkipLoadingTests	"sets a flag to un-ignore loading of the testing portion of scripts embedded in pages"		SkipLoadingTests := false. ! !!Installer class methodsFor: 'debug' stamp: 'kph 5/9/2007 23:05'!debug	IsSetToTrapErrors := false! !!Installer class methodsFor: 'launcher support' stamp: 'stephane.ducasse 9/30/2008 18:29'!do: webPageName	| rs |	self webSearchPath isEmpty ifTrue: [ ^self error: 'search path not set' ].	rs := webPageName readStream.	[ rs atEnd ] whileFalse: [ self install: (rs upTo: $;) ].! !!Installer class methodsFor: 'custom names' stamp: 'kph 5/28/2007 05:11'!doesNotUnderstand: aMessage	^ self remembered at: aMessage selector ifAbsent: [ super doesNotUnderstand: aMessage ]! !!Installer class methodsFor: 'file' stamp: 'mtf 10/23/2008 15:49'!file	^ InstallerFile new! !!Installer class methodsFor: 'file' stamp: 'mtf 10/23/2008 16:08'!file: fileName 	^ InstallerFile new file: fileName; yourself! !!Installer class methodsFor: 'url' stamp: 'kph 2/11/2009 20:12'!fromUrl: aUrl	"try and pick an Installer appropriate for the Url"		| mci |		mci := Installer mc fromUrl: aUrl.		mci packages ifEmpty: [ ^ Installer url: aUrl ].		^ mci! !!Installer class methodsFor: 'repositories' stamp: 'kph 6/2/2008 20:21'!goran	^ self monticello http: 'squeak.krampe.se'; project: ''! !!Installer class methodsFor: 'repositories' stamp: 'kph 5/10/2007 01:29'!impara	^ self monticello http: 'source.impara.de'! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:24'!install: webPageName	self webSearchPath isEmpty ifTrue: [ ^self error: 'search path not set' ].	^ self web install: webPageName! !!Installer class methodsFor: 'file' stamp: 'mtf 10/23/2008 16:08'!installFile: fileName 	^ (self file: fileName) install.! !!Installer class methodsFor: 'url' stamp: 'stephane.ducasse 9/30/2008 18:24'!installSilentlyUrl: urlString	^ SystemChangeNotifier uniqueInstance doSilently: [ self url url: urlString; install ].! !!Installer class methodsFor: 'url' stamp: 'stephane.ducasse 9/30/2008 18:24'!installUrl: urlString	^ self url url: urlString; install.! !!Installer class methodsFor: 'repositories' stamp: 'kph 12/18/2008 02:06'!keith 	^ self monticello ftp: 'squeak.warwick.st' directory: 'mc' user: 'squeak' password: 'viewpoints'! !!Installer class methodsFor: 'launcher support' stamp: 'kph 2/27/2007 18:57'!launchFrom: launcher	^self launchWith: launcher getParameters! !!Installer class methodsFor: 'launcher support' stamp: 'kph 5/24/2007 19:59'!launchHelp^'path=/dir/*.txt          Specify a search path for the item to installp=/dir1/*.txt;<url2>/    Multiple items delimited by ;                         The page name is typically appended to the path string, or                         if a "*" is present, it will be replaced by the page name.					in,i,install=<page>      Page appended to the path to begin the install processurl,u=<url>              Install using an explicit url from which to obtain a script or filefile=<url>                Install using a local file+debug                   Do not trap errorsview=<page>              Print the script that would have been installed.For more options use Script eval="Installer ... " '! !!Installer class methodsFor: 'launcher support' stamp: 'kph 1/11/2008 07:58'!launchWith: params 	params at: 'P' ifPresent: [ :v | params at: 'PATH' put: v ]. 	params at: 'I' ifPresent: [ :v | params at: 'INSTALL' put: v ]. 	params at: 'IN' ifPresent: [ :v | params at: 'INSTALL' put: v ]. 	params at: 'U' ifPresent: [ :v | params at: 'URL' put: v ].	params at: 'PATH' ifPresent: [ :v | 		self webSearchPathFrom: v.	].	params at: 'USER' ifPresent: [ :v | 		Utilities setAuthorInitials: v	].	params at: 'VERSION' ifPresent: [ :v | 		SystemVersion current version: v	].	params at: 'VIEW' ifPresent: [ :v |		self view: v	].	IsSetToTrapErrors := true.	params at: 'DEBUG' ifPresent: [ :v | IsSetToTrapErrors := (v == true) not ]. 	params at: 'URL' ifPresent: [ :v | 		 self installUrl: v	].	params at: 'FILE' ifPresent: [ :v | 		 self installFile: v	].  	params at: 'INSTALL' ifPresent: [ :v | 		  self do: v	].	params at: 'DO' ifPresent: [ :v | 		  self do: v	]. 	 ^true	! !!Installer class methodsFor: 'repositories' stamp: 'kph 4/24/2008 16:56'!lukas	^ self monticello http: 'source.lukas-renggli.ch'! !!Installer class methodsFor: 'mantis' stamp: 'kph 3/14/2007 21:07'!mantis	^ self mantis: 'http://bugs.squeak.org/'! !!Installer class methodsFor: 'mantis' stamp: 'mtf 10/8/2008 12:00'!mantis: host	^ InstallerMantis host: host! !!Installer class methodsFor: 'monticello' stamp: 'kph 5/10/2007 00:49'!mc	^ self monticello! !!Installer class methodsFor: 'monticello' stamp: 'kph 5/10/2007 00:49'!monticello	^ InstallerMonticello new! !!Installer class methodsFor: 'debug' stamp: 'kph 5/9/2007 23:05'!noDebug	IsSetToTrapErrors := true! !!Installer class methodsFor: 'during' stamp: 'kph 5/21/2008 09:05'!noProgressDuring: block 	[ block value: self ] on: ProgressInitiationException do: [ :note | note resume ]! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:24'!path: aString	"convenience abbreviation"		self webSearchPathFrom: aString! !!Installer class methodsFor: 'custom names' stamp: 'kph 5/28/2007 00:54'!remembered	^	Remembered ifNil: [ Remembered := IdentityDictionary new ]! !!Installer class methodsFor: 'instanciation' stamp: 'kph 12/1/2008 20:12'!repositories	^ self class organization listAtCategoryNamed: 'repositories'.! !!Installer class methodsFor: 'monticello' stamp: 'stephane.ducasse 9/30/2008 18:24'!repository: host  	^self monticello http: host ! !!Installer class methodsFor: 'sake' stamp: 'mtf 10/8/2008 12:00'!sake	^ self sake: InstallerSake sake! !!Installer class methodsFor: 'sake' stamp: 'kph 1/28/2008 10:42'!sake: aSakePackagesClass	^ InstallerSake new sake: aSakePackagesClass! !!Installer class methodsFor: 'repositories' stamp: 'kph 8/18/2008 03:15'!saltypickle	^ self monticello http: 'squeak.saltypickle.com'! !!Installer class methodsFor: 'sake' stamp: 'mtf 10/8/2008 12:00'!setSakeToUse: aClass	InstallerSake sake: aClass! !!Installer class methodsFor: 'documentation' stamp: 'kph 5/10/2007 01:21'!sf	^ self squeakfoundation ! !!Installer class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:21'!skipLoadingTests	"sets a flag to ignore loading of the testing portion of scripts embedded in pages"		SkipLoadingTests := true. ! !!Installer class methodsFor: 'during' stamp: 'kph 5/21/2008 08:53'!skipLoadingTestsDuring: block	| oldValue |	oldValue := SkipLoadingTests.	SkipLoadingTests := true.		[ block value: self ] ensure:[ SkipLoadingTests := oldValue ].! !!Installer class methodsFor: 'squeakmap' stamp: 'kph 5/10/2007 01:19'!sm	^ self squeakmap! !!Installer class methodsFor: 'repositories' stamp: 'kph 12/15/2007 11:08'!sophie	^ self monticello http: 'source.sophieproject.org'	! !!Installer class methodsFor: 'repositories' stamp: 'kph 5/10/2007 01:21'!squeakfoundation	^ self monticello http: 'source.squeakfoundation.org'! !!Installer class methodsFor: 'squeakmap' stamp: 'stephane.ducasse 9/30/2008 18:26'!squeakmap	^ InstallerSqueakMap new sm: true; yourself! !!Installer class methodsFor: 'repositories' stamp: 'kph 5/10/2007 01:19'!squeaksource	^ self monticello http: 'www.squeaksource.com'! !!Installer class methodsFor: 'repositories' stamp: 'kph 5/10/2007 01:19'!ss	^ self squeaksource ! !!Installer class methodsFor: 'universe' stamp: 'mtf 10/14/2008 10:10'!universe	^ InstallerUniverse default! !!Installer class methodsFor: 'instanciation' stamp: 'kph 12/18/2007 11:47'!upgrade	Installer ss project: 'Installer'; installQuietly: 'Installer-Core'.		^ self! !!Installer class methodsFor: 'url' stamp: 'kph 12/9/2008 03:10'!url	^ InstallerUrl new url: ''! !!Installer class methodsFor: 'url' stamp: 'stephane.ducasse 9/30/2008 18:26'!url: urlString	^self url url: urlString; yourself! !!Installer class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:28'!validationBlock	^ ValidationBlock! !!Installer class methodsFor: 'accessing' stamp: 'kph 5/25/2007 01:34'!validationBlock: aBlock	ValidationBlock := aBlock! !!Installer class methodsFor: 'instanciation' stamp: 'stephane.ducasse 9/30/2008 18:26'!view: webPageNameOrUrl	| theReport |	theReport := String streamContents: [ :report | 	(webPageNameOrUrl beginsWith: 'http://') ifTrue: [ 		self actionMatch: ('Installer installUrl: ', (webPageNameOrUrl printString),'.')  				reportOn: report ifNoMatch: []	]	ifFalse: [		self actionMatch: ('Installer install: ', (webPageNameOrUrl printString),'.')  				reportOn: report ifNoMatch: []	]].	Workspace new contents: (theReport contents); openLabel: webPageNameOrUrl.	^theReport contents! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:26'!web 	^ InstallerWeb! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:27'!webInstall: webPageName	self webSearchPath isEmpty ifTrue: [ ^self error: 'search path not set' ].	^ self web install: webPageName! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:22'!webSearchPath	"a search path item, has the following format. prefix*suffix"	^ self web searchPath! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:22'!webSearchPathFrom: string	| reader wsp path |	reader := string readStream.	wsp := self webSearchPath.	[ reader atEnd ] whileFalse: [ 		path := reader upTo: $;.		(wsp includes: wsp) ifFalse: [ wsp addFirst: path ]].	 ! !!Installer class methodsFor: 'websqueakmap' stamp: 'stephane.ducasse 9/30/2008 18:28'!websqueakmap	^ InstallerWebSqueakMap new wsm: 'http://map.squeak.org'; yourself! !!Installer class methodsFor: 'websqueakmap' stamp: 'stephane.ducasse 9/30/2008 18:28'!websqueakmap: host	^ InstallerWebSqueakMap new wsm: host; yourself! !!Installer class methodsFor: 'repositories' stamp: 'kph 5/10/2007 01:30'!wiresong	^ self monticello http: 'source.wiresong.ca'! !!Installer class methodsFor: 'websqueakmap' stamp: 'kph 5/10/2007 01:19'!wsm	^ self websqueakmap! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 18:45'!addPackage: anObject	self packages add: anObject! !!Installer methodsFor: 'auto answering' stamp: 'sd 3/6/2008 18:46'!answer: aString with: anAnswer	^self answers add: ( Array with: aString with: anAnswer )! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:46'!answers	^ answers ifNil: [ answers := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:46'!answers: anObject	answers := anObject! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!availablePackages		^ self basicAvailablePackages! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicAvailablePackages! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicBrowse! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicInstall! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicVersions! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicView! !!Installer methodsFor: 'script bindings' stamp: 'kph 5/8/2007 19:52'!bindingOf: aString 		InstallerBindings isNil ifTrue: [ InstallerBindings := Dictionary new].	(InstallerBindings includesKey: aString)		ifFalse: [InstallerBindings at: aString put: nil].	^ InstallerBindings associationAt: aString.! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!browse	self logErrorDuring: [self basicBrowse]! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 18:45'!browse: packageNameCollectionOrDetectBlock	self package: packageNameCollectionOrDetectBlock.	self browse! !!Installer methodsFor: 'mantis' stamp: 'kph 12/19/2007 12:03'!browse: aFileName from: stream		| mcThing ext browseSelector |		 	self log: ' browsing...'. 		mcThing := self classMCReader ifNotNil: [ self mcThing: aFileName from: stream ].				mcThing 			ifNotNil: [ (mcThing respondsTo: #snapshot) 						ifTrue: [ mcThing browse ]				        	ifFalse: [ (MCSnapshotBrowser forSnapshot: mcThing) showLabelled: 'Browsing ', aFileName ]			]			ifNil: [ 						ext := aFileName copyAfterLast: $..				browseSelector := ('browse', ext asUppercase, ':from:') asSymbol.					(self respondsTo: browseSelector)					ifTrue: [ self perform: browseSelector with: aFileName with: stream ]					ifFalse: [ self browseDefault: aFileName from: stream ].			]! !!Installer methodsFor: 'mantis' stamp: 'kph 12/19/2007 13:49'!browseCS: aFileName from: stream 		| list |		list := self classChangeList new			scanFile: stream from: 1 to: stream size.		 	self classChangeList open: list name: aFileName		multiSelect: true.! !!Installer methodsFor: 'mantis' stamp: 'kph 12/19/2007 12:05'!browseDefault: aFileName from: stream	self view: aFileName from: stream! !!Installer methodsFor: 'mantis' stamp: 'sd 3/6/2008 19:08'!browseGZ: aFileName from: stream 	"FileIn the contents of a gzipped stream"	| zipped unzipped |	zipped := self classGZipReadStream on: stream.	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	ChangeList browseStream: unzipped	! !!Installer methodsFor: 'utils' stamp: 'kph 5/24/2007 19:16'!changeSetNamed: aName	(ChangeSet respondsTo: #named:)		ifTrue: [ ^ChangeSet named: aName ].			^ ChangeSorter changeSetNamed: aName.! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classChangeList	^Smalltalk at: #ChangeList  ifAbsent: [ self error: 'ChangeList not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classChangeSet	^Smalltalk at: #ChangeSet  ifAbsent: [ self error: 'ChangeSet not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classChangeSorter	^Smalltalk at: #ChangeSorter ifAbsent: [ self error: 'ChangeSorter not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classGZipReadStream	^Smalltalk at: #GZipReadStream  ifAbsent: [ self error: 'Compression not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classMCReader	^Smalltalk at: #MCReader ifAbsent: [ nil ]	! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classMczInstaller	^Smalltalk at: #MczInstaller ifAbsent: [ nil ]	! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classMultiByteBinaryOrTextStream	^Smalltalk at: #MultiByteBinaryOrTextStream  ifAbsent: [ self error: 'MultiByteBinaryOrTextStream not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classSARInstaller	^Smalltalk at: #SARInstaller  ifAbsent: [ self error: 'SARInstaller not present' ]! !!Installer methodsFor: 'utils' stamp: 'mtf 7/23/2008 12:00'!ditchOldChangeSetFor: aFileName 	| changeSetName | 	changeSetName := (self validChangeSetName: aFileName) sansPeriodSuffix.	(self changeSetNamed: changeSetName)		ifNotNilDo: [:changeSet |				(self logCR:'Removing old change set ', changeSetName) cr.				self  removeChangeSet: changeSet ].! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!install	self logErrorDuring: [self basicInstall]! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 18:45'!install: packageNameCollectionOrDetectBlock	self addPackage: packageNameCollectionOrDetectBlock.	self install! !!Installer methodsFor: 'mantis' stamp: 'kph 12/9/2008 17:51'!install: aFileName from: stream| ext installSelector mcThing |	 	self log: ' installing...'. 	self withAnswersDo:	[				mcThing := self classMCReader ifNotNil: [ self mcThing: aFileName from: stream ].				mcThing 			ifNotNil: [ (mcThing respondsTo: #install) 						ifTrue: [ mcThing install ]				        	ifFalse: [ (mcThing respondsTo: #load) ifTrue: [ mcThing load ] ]			]			ifNil: [ 						ext := (aFileName copyAfterLast: $/) in: [ :path | path isEmpty ifTrue: [ aFileName ] ifFalse: [ path ] ].				ext :=  ext copyAfterLast: $..				ext = '' ifTrue: [ ext := 'st' ].				installSelector := ('install', ext asUppercase, ':from:') asSymbol.					(self respondsTo: installSelector)					ifTrue: [ self perform: installSelector with: aFileName with: stream ]					ifFalse: [ self installDefault: aFileName from: stream ].			]	]. 	self log: ' done.'! !!Installer methodsFor: 'mantis' stamp: 'kph 5/9/2007 18:14'!installCS: aFileName from: stream 	self ditchOldChangeSetFor: aFileName.	self newChangeSetFromStream: stream named: (self validChangeSetName: aFileName).! !!Installer methodsFor: 'mantis' stamp: 'ar 2/14/2009 22:56'!installDefault: aFileName from: stream	"Check for UTF-8 input before filing it in"	| pos bom |	pos := stream position.	bom := stream next: 3.	(bom size = 3		and:[(bom at: 1) asInteger = 16rEF]		and:[(bom at: 2) asInteger = 16rBB]		and:[(bom at: 3) asInteger = 16rBF]) 			ifTrue:[(RWBinaryOrTextStream on: stream upToEnd utf8ToSqueak) fileIn]			ifFalse:[stream position: pos; fileIn]! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:42'!installGZ: aFileName from: stream 	"FileIn the contents of a gzipped stream"	| zipped unzipped |	 	zipped := self classGZipReadStream on: stream.	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	self  newChangeSetFromStream: unzipped named:aFileName.	! !!Installer methodsFor: 'mantis' stamp: 'kph 5/9/2007 18:17'!installMCZ: aFileName from: stream 	self classMczInstaller ifNotNilDo: [ :reader | ^reader installStream: stream].  	self error: 'no monticello readers available'.  ! !!Installer methodsFor: 'mantis' stamp: 'kph 5/9/2007 18:07'!installMCcs: aFileName from: stream 	| reader |		reader := MCCsReader on: stream.! !!Installer methodsFor: 'public interface' stamp: 'kph 5/16/2008 00:44'!installQuietly   	[ self install ] on: Warning do: [ :ex | ex resume: true ].! !!Installer methodsFor: 'public interface' stamp: 'kph 5/16/2008 00:45'!installQuietly: packageNameCollectionOrDetectBlock	self package: packageNameCollectionOrDetectBlock. 	self installQuietly.! !!Installer methodsFor: 'mantis' stamp: 'kph 5/25/2007 01:09'!installSAR: aFileName from: stream  | newCS |	self classSARInstaller withCurrentChangeSetNamed: aFileName		do: [:cs | newCS := cs. self classSARInstaller new fileInFrom: stream].	newCS isEmpty ifTrue: [ self removeChangeSet: newCS ]! !!Installer methodsFor: 'public interface' stamp: 'kph 6/2/2008 12:17'!installSilently	SystemChangeNotifier uniqueInstance doSilently: [ self install ]	! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!isSkipLoadingTestsSet	^SkipLoadingTests ifNil: [ false ]! !!Installer methodsFor: 'logging' stamp: 'sd 3/6/2008 20:23'!log: text	^Transcript show: text.! !!Installer methodsFor: 'logging' stamp: 'mtf 10/15/2008 08:08'!logCR: text	self validate.	^ Transcript show: text; cr! !!Installer methodsFor: 'logging' stamp: 'kph 9/1/2008 21:39'!logErrorDuring: block	(IsSetToTrapErrors = true) ifFalse: [ ^ block value ].	block on: Error 		do: [ :e |			self halt. 			self logCR: '****', e class name, ': ', (e messageText ifNil: [ '']). 					(e isKindOf: MessageNotUnderstood) 				ifTrue: [ e pass ]				ifFalse: [ e isResumable ifTrue:[ e resume: true ]]]! !!Installer methodsFor: 'searching' stamp: 'kph 1/4/2007 23:59'!match: aMatch	^self packagesMatching: aMatch! !!Installer methodsFor: 'mantis' stamp: 'stephane.ducasse 9/30/2008 18:38'!mcThing: aFileName from: stream			"dont use monticello for .cs or for .st use monticello for .mcs"	| reader |	reader := self classMCReader readerClassForFileNamed: aFileName.	reader name = 'MCStReader' ifTrue: [ ^ nil ].	reader ifNil: [ ^ nil ].	(reader respondsTo: #on:fileName:) 		ifTrue: [ reader := reader on: stream fileName: aFileName.					^ reader version  ]		ifFalse: [ reader := reader on: stream. 				    ^ reader snapshot  ].! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!messagesToSuppress	^ messagesToSuppress ifNil: [ messagesToSuppress := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!messagesToSuppress: anObject	messagesToSuppress := anObject! !!Installer methodsFor: 'mantis' stamp: 'kb 12/18/2006 13:01'!newChangeSetFromStream: aStream named: aName 	"This code is based upon ChangeSet-c-#newChangesFromStream:named: which is in 3.9,	implemented here for previous versions. The second branch is for 3.8, where ChangeSets	are loaded by ChangeSorter. "	| oldChanges newName newSet newStream |	(self classChangeSet respondsTo: #newChangesFromStream:named:) 		ifTrue: [ ^self classChangeSet newChangesFromStream: aStream named:aName ].	(self classChangeSorter respondsTo: #newChangesFromStream:named:)		ifTrue: [ ^self classChangeSorter newChangesFromStream: aStream named: aName ].	oldChanges := ChangeSet current. 	"so a Bumper update can find it"	newName := aName sansPeriodSuffix.	newSet := self classChangeSet basicNewNamed: newName.	[newSet		ifNotNil: [(aStream respondsTo: #converter:)				ifTrue: [newStream := aStream]				ifFalse: [newStream := self classMultiByteBinaryOrTextStream with: aStream contentsOfEntireFile.					newStream reset].			self classChangeSet newChanges: newSet.			newStream setConverterForCode.			newStream fileInAnnouncing: 'Loading ' , newName , '...'.			Transcript cr; show: 'File ' , aName , ' successfully filed in to change set ' , newName].	aStream close]		ensure: [self classChangeSet newChanges: oldChanges].	 	^ newSet! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 18:48'!open! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!package	^ self packages isEmpty ifTrue: [ nil ] ifFalse: [ self packages last ]! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!package: anObject	self addPackage: anObject.! !!Installer methodsFor: 'squeakmap' stamp: 'mtf 10/15/2008 10:14'!packageAndVersionFrom: pkg	| p |	p := ReadStream on: pkg .	^Array with: (p upTo: $() with: (p upTo: $)).! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!packages	 	^ packages ifNil: [ packages := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!packages: aCollection 	packages := aCollection! !!Installer methodsFor: 'searching' stamp: 'mtf 10/8/2008 12:00'!packagesMatching: aMatch	^'search type not supported'! !!Installer methodsFor: 'printing' stamp: 'sd 3/6/2008 19:04'!printOn: s	"I don't feel like fixing this yet"	true ifTrue: [^ super printOn: s]. 	s nextPutAll: '(Installer'.	self sm ifTrue: [ s nextPutAll: ' squeakmap' ].	self ma ifNotNil: [ s nextPutAll: ' mantis' ].	self wsm ifNotNil: [ s nextPutAll: ' websqueakmap' ].	self url ifNotNil: [ s nextPutAll: ' url:''', self url,'''' ].	self mc ifNotNil: [ s nextPutAll: ' repository:''', mc description,'''' ].	s nextPut: $).	self project ifNotNil: [ s nextPutAll: ' project:'; nextPutAll: '''', self project, ''''.						self package ifNotNil: [ s nextPutAll: '; '] ].						self package ifNotNil: [ s nextPutAll: ' package:'; nextPutAll: '''', self package asString, '''' ].						s nextPut: $..! !!Installer methodsFor: 'custom names' stamp: 'kph 5/28/2007 03:42'!rememberAs: symbol	self class remembered at: symbol asSymbol put: self! !!Installer methodsFor: 'utils' stamp: 'kph 5/25/2007 01:15'!removeChangeSet: cs	(self classChangeSet respondsTo: #removeChangeSet:)		ifTrue: [ ^ChangeSet removeChangeSet: cs ].			^ self classChangeSorter removeChangeSet: cs .! !!Installer methodsFor: 'action report' stamp: 'sd 3/6/2008 18:45'!reportFor: theLine page: thePage on: report  		[ thePage atEnd ] whileFalse: [ 		| line |		line := thePage nextLine.		Installer actionMatch: line reportOn: report ifNoMatch: [ report nextPutAll: line; cr. ]].! !!Installer methodsFor: 'action report' stamp: 'sd 3/6/2008 18:45'!reportSection: line on: report		report isEmpty ifFalse: [ report cr ].	report nextPutAll: '">>>> ' ; nextPutAll: (line copyWithout: $"); nextPut: $"; cr.	! !!Installer methodsFor: 'searching' stamp: 'sd 3/6/2008 20:24'!search: aMatch	self sm ifTrue: [ ^ self smSearch: ('*',aMatch,'*') ].	self mc ifNotNil: [ ^ self mcSearch: ('*',aMatch,'*')  ].	self wsm ifNotNil: [ ^ self wsmSearch: ('*',aMatch,'*')  ].	^'search type not supported'! !!Installer methodsFor: 'auto answering' stamp: 'kph 2/5/2008 15:48'!suppress: aMessage	messagesToSuppress add: aMessage! !!Installer methodsFor: 'url' stamp: 'sd 3/6/2008 20:20'!validChangeSetName: aFileName	" dots in the url confuses the changeset loader. I replace them with dashes"	 	(aFileName beginsWith:'http:') ifTrue: [ | asUrl |		asUrl := Url absoluteFromText: aFileName.		^String streamContents: [:stream |			stream nextPutAll: (asUrl authority copyReplaceAll: '.' with: '-').			asUrl path allButLastDo: [:each |				stream					nextPutAll: '/';					nextPutAll: (each copyReplaceAll: '.' with: '-') ].			stream				nextPutAll: '/';				nextPutAll: asUrl path last ] ].	^aFileName! !!Installer methodsFor: 'logging' stamp: 'kph 5/25/2007 01:36'!validate	ValidationBlock value = false ifTrue: [ self error: 'Validation failed' ].! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!versions		^ self basicVersions! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!view	self logErrorDuring: [self basicView]! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 19:06'!view: packageNameCollectionOrDetectBlock	self package: packageNameCollectionOrDetectBlock.	self view! !!Installer methodsFor: 'mantis' stamp: 'kph 5/10/2007 00:21'!view: aFileName from: stream		self log: ' viewing...'. 		Workspace new contents: (stream contents); openLabel: aFileName. 	 				 ! !!Installer methodsFor: 'auto answering' stamp: 'kph 10/21/2006 06:52'!withAnswersDo: aBlock	(aBlock respondsTo: #valueSuppressingMessages:supplyingAnswers: )		ifTrue: [aBlock valueSuppressingMessages: self messagesToSuppress supplyingAnswers: self answers.]		ifFalse: [ aBlock value ]! !Installer subclass: #InstallerCruft	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerCruft commentStamp: 'mtf 10/1/2008 22:24' prior: 0!I am a copy of Installer as of Installer-Core-kph.232. I am being split up.I  am called InstallerCruft because I stand-in for Sake{MC,SM,Mantis,Web,etc}Installer!!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classProjectLauncher	^Smalltalk at: #ProjectLauncher ifAbsent: [ self error: 'ProjectLauncher not present' ]! !!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classSakePackages	^Smalltalk at: #SakePackages  ifAbsent: [ self error: 'Sake Packages code not present' ]! !!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classes	^ Smalltalk! !!InstallerCruft class methodsFor: 'documentation' stamp: 'kph 7/25/2007 13:25'!history"7 Jan 2007  !!Installer fixBug: <aBugNo>aBugNo can now be a number or a string, beginning with a number. This allows the mantis bug report summary to be used verbatim.It also provides more infomarion for Installer to support self documentation.!!Install fix if not already installed Installer ensureFix: <aBugNoOrString> Installer ensureFixes: #(1 2 3 4)Installer now keeps a list of fix <aBugNoOrString> that have been installed up to this point.#ensureFix: will only install the fix if it has not already been loaded.note that only the bugNumber not the description is significant in the check.8 Jan 2007!!Installer view: <webPageNameOrUrl>Provided that web page based scripts follow some simple rules, installer can collate the scripts from web pages into a single workspace where you can manually 'doit' portions as you wish.The report generation is not very clever, it only matches on: 'Installer install:' ,  'Installer installUrl:', and 'Installer mantis fixBug:' note these lines must be properly completed with an ending $. (period).also invoked by commandline option VIEW=<webPageNameOrUrl>10 Jan 2007!!Now matches simpler htmlCheck for an html page, now matches'<!!DOCTYPE HTML' and <html> the allows use of pbwiki's raw=bare option which returns iframe embeddable html without the usual headers.8 May 2007Modified bug:fix:date: so that the fixesApplied history does not contain unnecessary duplicate entries.Fixed changeset naming for mantis bugs.25 July 2007Added Universes  Support"! !!InstallerCruft class methodsFor: 'documentation' stamp: 'kph 5/24/2007 18:54'!mczInstall: urlOrFile	^ self new mczInstall: urlOrFile! !!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:20'!smalltalkImage	^ SmalltalkImage current! !!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:20'!sourceFiles	^ SourceFiles! !!InstallerCruft class methodsFor: 'unload' stamp: 'stephane.ducasse 9/30/2008 18:30'!unload: categoryMatchesString 	^ self error: 'deprecated, use Installer mc unload: ''pkgname''.'! !!InstallerCruft methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classMCMczReader	^Smalltalk at: #MCMczReader ifAbsent: [ nil ]	! !!InstallerCruft methodsFor: 'mantis' stamp: 'edc 4/4/2007 07:56'!createRBforBug: aBugNo 	| aStream  fileList selFile aFileName |	self setBug: aBugNo.fileList := self maFiles keys asOrderedCollection.fileList  addLast: 'none'.ReleaseBuilderFor3dot10 clear.[selFile := UIManager default chooseFrom: fileList title: 'Choose what files load '.selFile = fileList size ifFalse:[aFileName := fileList at: selFile.	self logCR: 'obtaining ', aFileName, '...'.	aStream := self maStreamForFile: aFileName .	ReleaseBuilderFor3dot10 current packagesInfluenced: aStream named: aFileName.		self installCS: aFileName from: aStream].selFile = fileList size]whileFalse.		ReleaseBuilderFor3dot10 current newUpdateFor: aBugNo			! !!InstallerCruft methodsFor: 'mantis' stamp: 'sd 3/6/2008 19:10'!evaluate: stream	stream fileIn.! !!InstallerCruft methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!info	self sm ifTrue: [ ^ self smInfo  ].	self wsm ifNotNil: [ ^ self wsmInfo  ].! !!InstallerCruft methodsFor: 'monticello' stamp: 'kph 5/24/2007 18:56'!mczInstall: urlOrFile	self log: ('Loading ', urlOrFile, ' ...').	(urlOrFile beginsWith: 'http:')		ifTrue: [  MczInstaller installStream: (HTTPSocket httpGet: urlOrFile) ]		ifFalse: [ MczInstaller installFileNamed: urlOrFile ].			self logCR: ' Loaded'.	! !!InstallerCruft methodsFor: 'mantis' stamp: 'kph 12/21/2006 01:28'!skipTests! !!InstallerCruft methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:06'!user	^ user ifNil: [ '' ]! !!InstallerCruft methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:06'!user: anObject	user := anObject! !!InstallerCruft methodsFor: 'utils' stamp: 'kph 5/9/2007 21:49'!viewUrl	^Workspace new contents: (self urlGet contents); openLabel: self urlToDownload.! !Installer subclass: #InstallerFile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerFile methodsFor: 'basic interface' stamp: 'kph 7/28/2007 23:48'!basicBrowse		self browse: self file from:  (FileDirectory readOnlyFileNamed: self file).	! !!InstallerFile methodsFor: 'basic interface' stamp: 'kph 7/28/2007 23:48'!basicInstall		self install: self file from: (FileDirectory default readOnlyFileNamed: self file)	! !!InstallerFile methodsFor: 'basic interface' stamp: 'kph 7/28/2007 23:48'!basicView		self view: self file from:  (FileDirectory readOnlyFileNamed: self file).	! !!InstallerFile methodsFor: 'accessing' stamp: 'mtf 10/23/2008 15:51'!file	^ self package! !!InstallerFile methodsFor: 'accessing' stamp: 'mtf 10/23/2008 15:51'!file: f	self package: f! !Installer subclass: #InstallerInternetBased	instanceVariableNames: 'url pageDataStream markers'	classVariableNames: 'Entities'	poolDictionaries: ''	category: 'Installer-Core'!!InstallerInternetBased class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:20'!entities	^ Entities ifNil: [ Entities := 				"enough entities to be going on with"  				Dictionary new.				Entities at: 'lt' put: '<';				at: 'gt' put: '>';				at: 'amp' put: '&';				at: 'star' put: '*';				at: 'quot' put: '"';				at: 'nbsp' put: ' '; 			yourself] ! !!InstallerInternetBased methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classHTTPSocket	^Smalltalk at: #HTTPSocket ifAbsent: [ self error: 'Network package not present' ]! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:07'!extractFromHtml: html option: allOrLast	|  start stop test in |	start := self markersBegin.	stop :=  self markersEnd.	test := self markersTest.			 	in := ReadWriteStream with: String new.			[ html upToAll: start; atEnd ] 		whileFalse: [			| chunk |			(allOrLast == #last) ifTrue: [ in resetToStart ]. 			chunk := html upToAll: stop.			self isSkipLoadingTestsSet ifTrue: [ chunk := chunk readStream upToAll: test ].			in nextPutAll: chunk. 		 ].	^self removeHtmlMarkupFrom: in reset	 ! !!InstallerInternetBased methodsFor: 'url' stamp: 'kph 10/11/2008 17:02'!hasPage	^ pageDataStream notNil and: [ pageDataStream size > 0 ]			! !!InstallerInternetBased methodsFor: 'utils' stamp: 'sd 3/6/2008 20:15'!httpGet: aUrl	| page |	page := self classHTTPSocket httpGet: aUrl accept: 'application/octet-stream'.   	(page respondsTo: #reset)  ifFalse: [ self error: 'unable to contact web site' ].	^ page	! !!InstallerInternetBased methodsFor: 'url' stamp: 'sd 3/6/2008 20:18'!isHtmlStream: page	"matches  '<!!DOCTYPE HTML', and <html>' "		| first |		first := (page next: 14) asUppercase.	^ (first = '<!!DOCTYPE HTML') | (first beginsWith: '<HTML>')	! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:07'!markers	^ markers ifNil: [ '<code st>..."test ...</code st>' ]! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:07'!markers: anObject	markers := anObject! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:08'!markersBegin		 	 	 ^ self markers copyUpTo: $.! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:08'!markersEnd	"return the third marker or the second if there are only two"		| str  a | 	str := self markers readStream.	a := str upToAll: '...'; upToAll: '...'.	str atEnd  ifTrue: [ ^a ] ifFalse: [ ^str upToEnd ]	! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:08'!markersTest		 	 	^ self markers readStream upToAll: '...'; upToAll: '...'! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:08'!removeHtmlMarkupFrom: in 	| out |	out := ReadWriteStream on: (String new: 100).	[ in atEnd ] whileFalse: [ 		out nextPutAll: (in upTo: $<).		(((in upTo: $>) asLowercase beginsWith: 'br') and: [ (in peek = Character cr) ]) ifTrue: [ in next ].		].		^self replaceEntitiesIn: out reset.! !!InstallerInternetBased methodsFor: 'url' stamp: 'sd 3/6/2008 20:19'!replaceEntitiesIn: in	| out |	out := ReadWriteStream on: (String new: 100).	[ in atEnd ] whileFalse: [ 		out nextPutAll: ((in upTo: $&) replaceAll: Character lf with: Character cr).		in atEnd ifFalse: [ out nextPutAll: (self class entities at: (in upTo: $;) ifAbsent: '?') ].		].	^out reset! !!InstallerInternetBased methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:06'!url	^url! !!InstallerInternetBased methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:06'!url: aUrl 	url := aUrl! !!InstallerInternetBased methodsFor: 'url' stamp: 'sd 3/6/2008 20:19'!urlGet	^ self urlGet: self urlToDownload! !!InstallerInternetBased methodsFor: 'url' stamp: 'kph 12/9/2008 03:17'!urlGet: aUrl	| page |	page := HTTPSocket httpGet: aUrl accept: 'application/octet-stream'.  	(page respondsTo: #reset)  ifFalse: [ ^ nil ].	(self isHtmlStream: page) ifTrue: [ page := self extractFromHtml: page option: nil ].	^ page reset	! !!InstallerInternetBased methodsFor: 'url' stamp: 'kph 10/11/2008 17:02'!wasPbwikiSpeedWarning				^ self hasPage and: [pageDataStream contents includesSubString: 'Please slow down a bit' ]  ! !InstallerInternetBased subclass: #InstallerUrl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerUrl class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!canReportLine: line	^ ((line beginsWith: 'Installer installUrl:') and: 		[ | ext |		 ext :=  (line readStream upToAll: '''.') copyAfterLast: $..		 (#( 'cs' 'st' 'mcz' 'sar') includes: ext) not ])! !!InstallerUrl methodsFor: 'action report' stamp: 'kph 1/8/2007 11:19'!action: line reportOn: report  	url :=  line readStream upTo: $' ; upTo: $'.  		self reportSection: line on: report.	(pageDataStream := self urlGet: self urlToDownload) 		ifNil: [ self error: 'unable to contact host' ].	 		self reportFor: line page: pageDataStream on: report ! !!InstallerUrl methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:19'!basicBrowse 	"(Installer debug url: 'http://installer.pbwiki.com/f/Installer.st') browse.".		self browse: self urlToDownload from: self urlThing.		! !!InstallerUrl methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:19'!basicInstall  	 	self install: self urlToDownload from: self urlThing.	^ pageDataStream ! !!InstallerUrl methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:19'!basicView 	 "(Installer debug url: 'http://installer.pbwiki.com/f/Installer.st') view.".		self view: self urlToDownload from: self urlThing.		! !!InstallerUrl methodsFor: 'url' stamp: 'kph 2/11/2009 20:04'!latest	"for protocol compatability"! !!InstallerUrl methodsFor: 'url' stamp: 'mtf 10/15/2008 08:40'!urlThing 	| retry delay |		self logCR: 'retrieving ', self urlToDownload , ' ...'.		delay := 0.	[ retry := false. pageDataStream := self urlGet: self urlToDownload ] 		doWhileTrue: [  				self wasPbwikiSpeedWarning ifTrue: [retry := true. delay := delay + 5.				self logCR: 'PBWiki speed warning. Retrying in ', delay printString, ' seconds'.				(Delay forSeconds: delay) wait ].														retry ].			pageDataStream ifNil: [ self error: 'unable to contact host' ].	 	^ pageDataStream	! !!InstallerUrl methodsFor: 'url' stamp: 'kph 1/4/2007 23:49'!urlToDownload	^ (self url, (self package ifNil: [ '' ])) asUrl asString.	 ! !InstallerInternetBased subclass: #InstallerWebBased	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!InstallerWebBased subclass: #InstallerMantis	instanceVariableNames: 'ma bug desc date array data status'	classVariableNames: 'Fixes Status'	poolDictionaries: ''	category: 'Installer-Core'!!InstallerMantis commentStamp: 'test 1/14/2009 00:11' prior: 0!Search feature is based upon a custom mantis query ceveloped and maintained by Ken Causey <ken@kencausey.com>Installer mantis bugsAll select: [ :ea | ea status = 'testing' ].!!InstallerMantis class methodsFor: 'instance creation' stamp: 'test 1/12/2009 00:00'!initialize	Status := Dictionary new		at: '10' put: 'new';		at: '20' put: 'feedback';		at: '30' put: 'acknowledged';		at: '40' put: 'confirmed';		at: '50' put: 'assigned';		at: '60' put: 'pending';		at: '70' put: 'testing';		at: '80' put: 'resolved';		at: '90' put: 'closed';		yourself ! !!InstallerMantis class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!canReportLine: line	^ line beginsWith: 'Installer mantis fixBug:'! !!InstallerMantis class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:21'!fixesApplied	^ Fixes ifNil: [ Fixes := OrderedCollection new ].! !!InstallerMantis class methodsFor: 'instance creation' stamp: 'stephane.ducasse 9/30/2008 18:24'!host: host	^self new	ma: host; 			markers: '&quot;fix begin&quot;...&quot;fix test&quot;...&quot;fix end&quot;'; 			yourself.! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:42'!= other	^ array = other array! !!InstallerMantis methodsFor: 'action report' stamp: 'sd 3/6/2008 18:44'!action: line reportOn: report		| param mantis |	mantis := Installer mantis.	param :=  line readStream upTo: $: ; upTo: $..		mantis setBug: ((param readStream upTo: $'; atEnd)		 ifTrue: [  param ]		 ifFalse: [ param readStream upTo: $'; upTo: $' ]).		self reportSection: line on: report.	report nextPutAll: (mantis replaceEntitiesIn: mantis markersBegin readStream).	self reportFor: line page: mantis maScript on: report.	report nextPutAll: (mantis replaceEntitiesIn: mantis markersEnd readStream); cr.	! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:40'!array	^ array! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:25'!browseFile: aFileName	^ self browse: aFileName from: (self maThing: aFileName date: nil)! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:45'!bug		^ bug ifNil: [ 				date := ((self dataAtName: 'Updated') replaceAll: $  with: $T) asDateAndTime. 		desc := (self dataAtName: 'Summary').		bug := (self dataAtName: 'Id'). 		self statusInit. 	]! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/17/2008 10:53'!bug: aBugNo	self setBug: aBugNo.	^ self report! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:26'!bug: aBugNo browse: aFileName	 self setBug: aBugNo.	^ self browseFile: aFileName! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/18/2006 04:11'!bug: aBugNo fix: aFileName	^ self bug: aBugNo fix: aFileName date: nil! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/9/2008 22:46'!bug: aBugNo fix: aFileName date: aDate 	| |	self setBug: aBugNo.	self ditchOldChangeSetFor: aFileName.	self install: aFileName from: (self maThing: aFileName date: aDate).			^ date! !!InstallerMantis methodsFor: 'public interface' stamp: 'sd 3/6/2008 19:09'!bug: aBugNo retrieve: aFileName	 self setBug: aBugNo.	^ (self maStreamForFile: aFileName) contents! !!InstallerMantis methodsFor: 'public interface' stamp: 'sd 3/6/2008 19:09'!bug: aBugNo view: aFileName	"Installer mantis bug: 6089 browse: 'TTFSpeedUp-dgd.1.cs'"		 self setBug: aBugNo.	^ self view: aFileName from: (self maThing: aFileName date: nil)! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:35'!bugFiles: aBugNo 	"provide a list of files associated with the bug in id order"	"	Installer mantis bugFiles: 6660.	"	self setBug: aBugNo; files! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:37'!bugFilesView: aBugNo 	"provide a list of files associated with the bug in id order"	"	Installer mantis bugFiles: 6660.	"	self setBug: aBugNo; viewFiles! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:37'!bugScript: aBugNo	^ (self setBug: aBugNo) script		! !!InstallerMantis methodsFor: 'action report' stamp: 'test 1/13/2009 23:39'!bugsAll	^ array ifNil: [				array := ( self bugsSqueak ,  (self dataGetFrom: '/installer_export.php') ) asSet asSortedCollection: [ :a :b | a date > b date ]			]."Installer mantis bugsAll"	! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/13/2009 23:00'!bugsClosed	^ array ifNil: [ array := self dataGetFrom: '/installer_export.php?closed' ]! !!InstallerMantis methodsFor: 'search' stamp: 'kph 2/15/2009 15:08'!bugsRelease: version	^self bugsAll select: [ :ea | (ea status = 'resolved') and: [ ea fixedIn = version ]]! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/13/2009 22:59'!bugsSqueak	^ array ifNil: [ array := self dataGetFrom: '/installer_export.php?project=Squeak' ]	"Installer mantis bugsSqueak.Installer mantis bugsAll.Installer mantis bugsClosed."! !!InstallerMantis methodsFor: 'search' stamp: 'kph 2/15/2009 15:14'!bugsTesting: version	^self bugsAll select: [ :ea | ea status = 'testing' and: [ ea fixedIn = version ]]! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/11/2009 23:15'!category	^ self dataAtName: 'Category'	 "s bugs collect: [ :ea | ea category ]"! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/11/2009 23:28'!dataAtName: key		^ array at: (self dataNames indexOf: key)! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/13/2009 22:51'!dataAtName: key put: v		^ array at: (self dataNames indexOf: key) put: v! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/12/2009 00:15'!dataClosed	^ array ifNil: [ array := self dataGetFrom: '/installer_export.php?closed' ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'test 1/14/2009 20:35'!dataGetFrom: aPath	| rs line first col row out |			rs := HTTPSocket httpGet: ma, aPath.		first := true.		out := OrderedCollection new.		[ rs atEnd ] whileFalse: [ 				line := rs nextLine readStream.		col := 1.		row := Array new: 9.		[ (line atEnd or: [ col > 9 ]) ] whileFalse: [ row at: col put: (line upTo: $|). col := col + 1 ].			rs next.		[ out add: (self class new in: self row: row) ] ifError: []			 ].			^ out"self reset.self getBugsList "! !!InstallerMantis methodsFor: 'public interface' stamp: 'test 1/11/2009 23:29'!dataNames	^ #(Id Project Category Assigned Updated Status Severity FixedIn Summary)! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 12/17/2008 11:58'!date 	^ date ! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 12/11/2008 14:41'!date: anObject	date := anObject ifNotNilDo: [ :d | d asDate ]! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 1/8/2007 07:22'!desc	 	^ desc! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 1/8/2007 07:22'!desc: anObject	desc := anObject! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:47'!ensureFix	| fixesAppliedNumbers |		fixesAppliedNumbers := self fixesApplied collect: [ :fixDesc | fixDesc asInteger ].	(fixesAppliedNumbers includes: bug) ifFalse: [ self fixBug ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:48'!ensureFix: aBugNo	^self ensureFix: aBugNo date: nil! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:47'!ensureFix: aBugNo date: aDate	self setBug: aBugNo.	self date: aDate..		self ensureFix.! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:45'!ensureFixes: aBugNos	aBugNos do: [ :bugNo | self ensureFix: bugNo ].! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:34'!files 	"provide a list of files associated with the bug in id order"	"	Installer mantis bugFiles: 6660.	"	^ (self maFiles associations asSortedCollection: [ :a :b | a value asInteger < b value asInteger ]) 				collect: [ :a | a key ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/14/2008 18:06'!fixBug 	self install: self maUrl from: self maScript.	self maCheckDateAgainst: date.			self fixesAppliedNumbers in: [ :fixed |		(fixed isEmpty or: [ (fixed includes: bug asInteger) not]) 		ifTrue: [ self fixesApplied add: (bug asString, desc) ]].		! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:48'!fixBug: aBugNo 	^ self fixBug: aBugNo date: nil.	! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:44'!fixBug: aBugNo date: aDate	self setBug: aBugNo. 	self date: aDate.	self fixBug.	! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/14/2009 01:12'!fixedIn	^ self dataAtName: 'FixedIn'! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 10/16/2008 00:04'!fixesApplied	^ Fixes ifNil: [ Fixes := OrderedCollection new ].! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/9/2008 22:48'!fixesAppliedNumbers	^ self fixesApplied collect: [ :fixDesc | fixDesc asInteger ]. ! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 12/10/2008 14:21'!getView	"Installer mantis viewBug: 5639."	| page text | 		page := self maPage. 	text := String streamContents: [ :str |						#('Bug ID' 'Category' 'Severity' 'Reproducibility' 'Date Submitted' 			'Date Updated' 'Reporter' 'View Status' 'Handler' 			'Priority' 'Resolution' 'Status' 'Product Version' 'Summary' 'Description' 'Additional Information' ) 				do: [ :field |						| f |						f := self maRead: page field: field.			str nextPutAll: f key; nextPutAll: ': '; nextPutAll: f value; cr.		].		str nextPutAll: 'Notes: '; cr.		(self maReadNotes: page) do: [ :note | str nextPutAll: note; cr; cr ].				str nextPutAll: 'Files: '; nextPutAll: self maFiles keys asArray printString.	]. 	^ text	! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:41'!hash	^ array hash! !!InstallerMantis methodsFor: 'public interface' stamp: 'test 1/11/2009 23:56'!in: parent row: dataRow	self ma: parent ma.	self markers: parent markers.	self setArray: dataRow.! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 1/4/2007 06:43'!justFixBug: aBugNo	^self class skipLoadingTests: true during: [ self fixBug: aBugNo date: nil ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 1/4/2007 06:43'!justFixBug: aBugNo date: d	^self class skipLoadingTests: true during: [ self fixBug: aBugNo date: d ]! !!InstallerMantis methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!ma	^ ma! !!InstallerMantis methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!ma: aUrl	ma := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!InstallerMantis methodsFor: 'utils' stamp: 'sd 3/6/2008 20:16'!maCheckDateAgainst: okDate	(okDate notNil and: [date < okDate asDate ]) 		ifTrue: [ self notify: 'bug ', self bug asString, ' updated on ', date printString ]. ! !!InstallerMantis methodsFor: 'mantis' stamp: 'stephane.ducasse 9/30/2008 18:37'!maFiles 	| file files bugPage id  |  	files := Dictionary new. 	bugPage := self maPage.	 [ 		id := bugPage upToAll: 'href="file_download.php?file_id='; upTo: $&.  		file := bugPage upToAll: 'amp;type=bug"' ; upTo: $<. 		((file size > 1) and: [file first = $>]) ifTrue: [ files at: file copyWithoutFirst put: id ]. 		id notEmpty ] whileTrue.	^files ! !!InstallerMantis methodsFor: 'mantis' stamp: 'stephane.ducasse 9/30/2008 18:37'!maPage  	"  self mantis bug: 5251."	| page |	page :=  self httpGet: self maUrl. 	date := ((self maRead: page field: 'Date Updated') value copyUpTo: $ ).	date isEmpty ifTrue: [ ^self error: bug, ' not found' ].	date := date asDate. 	^page reset! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 12/17/2008 13:55'!maRead: page field: fieldKey	 | value | 	value := page upToAll: ('!!-- ', fieldKey, ' -->'); upToAll: '<td'; upTo: $>; upToAll: '</td>'.		page upTo: $<.		page peek = $t ifTrue: [ value := page upToAll: 'td'; upTo: $>; upToAll: '</td>' ].	  	^Association key: fieldKey value: (self removeHtmlMarkupFrom: value withBlanksTrimmed readStream) contents! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 12/17/2008 13:51'!maReadNotes: page 	 |  notes note  | 	notes := OrderedCollection new.	[ page upToAll: 'tr class="bugnote"'; upTo: $>.	  page atEnd ]			whileFalse: [ 		note := (self removeHtmlMarkupFrom: (page upToAll: '</tr>') readStream) contents.		note := note withBlanksCondensed.		note replaceAll: Character lf with: Character cr.		notes add: note  	].		^notes! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 1/8/2007 10:01'!maScript 	^self extractFromHtml: self maPage option: #last! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:48'!maStreamForFile: aFileName	| fileId  | 	fileId :=  self maFiles at: aFileName ifAbsent: [ self error: aFileName, ' not found' ]. 	^ self httpGet: (self ma, 'file_download.php?file_id=' , fileId , '&type=bug').	 ! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 5/9/2007 22:31'!maThing: aFileName date: aDate 	self logCR: 'obtaining ', aFileName, '...'.	pageDataStream := self maStreamForFile: aFileName.	self maCheckDateAgainst: aDate.	^ pageDataStream	! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:54'!maUrl 	^ url := self ma, 'view.php?id=', bug asString ! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 12/18/2006 04:08'!maUrlFor: maBugNo 	^ url := self ma, 'view.php?id=', maBugNo asString  ! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 12/9/2008 23:42'!printOn: stream	super printOn: stream.		(array ifNil: [ ^ self ]) printOn: stream.! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/14/2009 01:06'!project	^ self dataAtName: 'Project'! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/17/2008 14:03'!report	"Installer mantis viewBug: 5639."	| page text | 		page := self maPage. 	text := String streamContents: [ :str |						#('Bug ID' 'Category' 'Severity' 'Reproducibility' 'Date Submitted' 			'Date Updated' 'Reporter' 'View Status' 'Handler' 			'Priority' 'Resolution' 'Status' 'Product Version' 'Summary' 'Description' 'Additional Information' ) 				do: [ :field |						| f |						f := self maRead: page field: field.			str nextPutAll: f key; nextPutAll: ': '; nextPutAll: f value; cr.		].		str nextPutAll: 'Notes: '; cr.		(self maReadNotes: page) do: [ :note | str nextPutAll: note; cr; cr ].				str nextPutAll: 'Files: '; nextPutAll: self maFiles keys asArray printString.	]. 	^ text	! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:27'!script 	^ self maScript contents.	 		! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/11/2008 15:30'!selectCategoryCollections	^ self select: [ :ea | ea category = 'Collections' ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'test 1/11/2009 23:57'!setArray: dataRow	(array := dataRow) ifNotNil: [ self bug ].! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 12/9/2008 20:25'!setBug: stringOrNumber	| newBug |		(newBug := stringOrNumber asInteger) = bug ifTrue: [ ^ self ].		self logCR: 'Installer accessing bug: ' , stringOrNumber asString. 	bug := newBug.	 	stringOrNumber = bug ifTrue: [ desc := ''. ^ self ].	desc := stringOrNumber withoutLeadingDigits  ! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/11/2009 23:48'!status 	^ status! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:45'!statusInit	status ifNil: [ status := Status at: (self dataAtName: 'Status').		self dataAtName:'Status' put: status.	].	! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/11/2009 23:15'!summary	^ self dataAtName: 'Summary'! !!InstallerMantis methodsFor: 'action report' stamp: 'kph 2/13/2009 05:50'!validChangeSetName: aFileName	| csn prefix |	csn := super validChangeSetName: aFileName.		prefix := 'M' , self bug asString.		^ (csn beginsWith: prefix) 		ifTrue: [ csn ]		ifFalse: [ prefix, '-', (csn replaceAll: prefix with: '') ].			! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:32'!view		^ Workspace new contents: self report; openLabel: ('Mantis ', bug printString).! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:22'!viewBug: aBugNo	self setBug: aBugNo; view! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:23'!viewFile: aFileName	"Installer mantis bug: 6089 browse: 'TTFSpeedUp-dgd.1.cs'"		^ self view: aFileName from: (self maThing: aFileName date: nil)! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:36'!viewFiles		^ self files do: [ :ea | self viewFile: ea ].! !InstallerWebBased subclass: #InstallerWeb	instanceVariableNames: ''	classVariableNames: 'WebSearchPath'	poolDictionaries: ''	category: 'Installer-Core'!!InstallerWeb class methodsFor: 'instanciation' stamp: 'kph 2/10/2009 16:22'!initialize		WebSearchPath := OrderedCollection 		with:  [ 'http://installer.pbwiki.com/*-', (Smalltalk version copy replaceAll: $. with: $:)  ,'-', Utilities authorInitialsPerSe  ,'?raw=bare' ]		with:  [ 'http://installer.pbwiki.com/*-', (Smalltalk version copy replaceAll: $. with: $:) ]		with:  [ 'http://installer.pbwiki.com/*-', (SystemVersion current majorMinorVersion replaceAll: $. with: $:)  ]		with:  'http://installer.pbwiki.com/*'	  ! !!InstallerWeb class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!canReportLine: line	^ ((line beginsWith: 'Installer install:') | (line beginsWith: 'Installer do:'))! !!InstallerWeb class methodsFor: 'compatability' stamp: 'stephane.ducasse 9/30/2008 18:22'!install: webPageName"This keeps the syntax Installer web install: working"	^ self new install: webPageName! !!InstallerWeb class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:22'!searchPath	"a search path item, has the following format. prefix*suffix"	^ WebSearchPath ifNil: [ WebSearchPath := OrderedCollection new ].! !!InstallerWeb methodsFor: 'action report' stamp: 'kph 10/11/2008 16:48'!action: line reportOn: report		self package: (line readStream upTo: $' ; upTo: $').	self reportSection: line on: report.	 	url := self urlToDownload.		self reportFor: line page: pageDataStream on: report ! !!InstallerWeb methodsFor: 'basic interface' stamp: 'kph 10/11/2008 16:49'!basicBrowse  	 self thing size > 0 		ifTrue: [ self browse: url from: pageDataStream ]		ifFalse: [ self logCR: 'NO DATA ',url,' was empty' ].	 ! !!InstallerWeb methodsFor: 'basic interface' stamp: 'kph 10/11/2008 16:49'!basicInstall  	 self thing size > 0 		ifTrue: [ self install: url from: pageDataStream ]		ifFalse: [ url ifNil: [ ^ self logCR: self package, ' not found on webSearchPath' ].				  self logCR: '...',url,' was empty' ].	 ! !!InstallerWeb methodsFor: 'basic interface' stamp: 'kph 10/11/2008 16:49'!basicView  	 self thing size > 0 		ifTrue: [ self view: url from: pageDataStream ]		ifFalse: [ self logCR: 'NO DATA ',url,' was empty' ].	 ! !!InstallerWeb methodsFor: 'web install' stamp: 'mtf 10/15/2008 09:04'!thing	self logCR: 'searching for web package ''', self package, ''''. 	url := self urlToDownload.	url ifNil: [ self logCR: 'page ', self package, ' not found on path' ]		ifNotNil: [ self logCR: 'found ',  url, ' ...'.   ].	^ pageDataStream! !!InstallerWeb methodsFor: 'web install' stamp: 'mtf 10/15/2008 08:39'!urlToDownload	"while we look for a url which returns what we are looking for, we  get the data anyway"		| delay retry |	delay := 0.	self class webSearchPath do: [ :pathSpec | | potentialUrl readPathSpec  |		readPathSpec := pathSpec value readStream.		potentialUrl := (readPathSpec upTo: $*), self package, (readPathSpec upToEnd ifNil: [ '' ]).		[ retry := false. pageDataStream := self urlGet: potentialUrl ] doWhileTrue: [ 				self wasPbwikiSpeedWarning				ifTrue: [ retry := true. delay := delay + 5. 					self logCR: 'PBWiki speed warning. Retrying in ', delay printString, ' seconds'.					(Delay forSeconds: delay) wait]				ifFalse: [ self hasPage ifTrue: [ pageDataStream reset. ^ potentialUrl ] ].			retry ]].	^nil! !InstallerWebBased subclass: #InstallerWebSqueakMap	instanceVariableNames: 'wsm'	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'squeak 3/31/2008 22:21'!basicAvailablePackages	| html id name pkgs | 	pkgs := Dictionary new.	html := self httpGet: (self wsm, 'packagesbyname').		[ id := html upToAll: '/package/'; upToAll: '">'.	name := html upTo: $<.	(id notEmpty and: [ name notEmpty ])] 		whileTrue: [ pkgs at: name put: id ].	^ pkgs		! !!InstallerWebSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:41'!basicInstall		| it |	it := self wsmThing.	self install: it from: it asUrl retrieveContents contentStream.	! !!InstallerWebSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:42'!basicVersions	| pkgAndVersion packageId packageName packageVersion versions |	pkgAndVersion := self packageAndVersionFrom: self package .	packageName := pkgAndVersion first.	packageVersion := pkgAndVersion last.	packageVersion isEmpty ifTrue: [ packageVersion := #latest ].	packageId := self availablePackages at: packageName.	versions := (self wsmReleasesFor: packageId) keys.	versions remove: #latest.	^ versions collect: [ :version | self copy package: (packageName,'(', version ,')'); yourself ]. ! !!InstallerWebSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:42'!basicView		| it |	it := self wsmThing.	self view: it from: (self httpGet: it).	! !!InstallerWebSqueakMap methodsFor: 'searching' stamp: 'mtf 10/8/2008 12:00'!packagesMatching: aMatch	^ (self availablePackages		select: [ :p | ( aMatch) match: p ]) 		collect: [ :p | self copy package: p ; yourself ]! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:40'!wsm		^ wsm! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:41'!wsm: aUrl 	wsm := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:41'!wsmDownloadUrl 	| pkgAndVersion packageId packageName packageVersion releaseAutoVersion 	downloadPage |	pkgAndVersion := self packageAndVersionFrom: self package.	packageName := pkgAndVersion first.	packageVersion := pkgAndVersion last.	packageVersion isEmpty ifTrue: [ packageVersion := #latest ].	packageId := self availablePackages at: packageName.	releaseAutoVersion := (self wsmReleasesFor: packageId) at: packageVersion.					 	downloadPage := self httpGet: (self wsm,'packagebyname/', packageName,'/autoversion/', releaseAutoVersion,'/downloadurl') asUrl asString.				 		 	^ downloadPage contents	! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:42'!wsmReleasesFor: packageId	| html autoVersion version releases |	releases := Dictionary new.	html := self httpGet: (self wsm, '/package/', packageId ).	[releases at: #latest put: autoVersion.	autoVersion := html upToAll: '/autoversion/'; upTo: $".	version := html upTo: $-; upTo: $<.	(autoVersion notEmpty and: [version notEmpty ])] 		whileTrue: [ releases at: version put: autoVersion ].	^ releases	! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:42'!wsmThing	| downloadUrl |	self logCR: 'finding ', self package, ' from websqueakmap(', self wsm, ') ...'.	downloadUrl := self wsmDownloadUrl.	self logCR: 'found at ', downloadUrl asString, ' ...'.	^ downloadUrl	! !Installer subclass: #InstallerMonticello	instanceVariableNames: 'mc root project'	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerMonticello methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicAvailablePackages	^ self mc allFileNames! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'kph 12/5/2008 02:46'!basicBrowse	 "Installer ss project: 'Installer'; browse: 'Installer-Core'."	| it |	it := self mcThing.		(it class includesSelector: #browse) ifTrue: [ ^ it browse ].		(it instVarNamed: 'versions') do: #browse.! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'kph 10/23/2008 23:09'!basicInstall	 	self withAnswersDo: [ self mcThing load ].	self logCR: 'loaded'.! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:18'!basicVersions	^ (self availablePackages select: [ :p | ( self package,'-*.mcz' ) match: p ]) collect: [ :p | self copy package: p  ; yourself ]. ! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'kph 12/5/2008 02:56'!basicView	 "Installer ss project: 'Installer'; view: 'Installer-Core'. "	| it |		packages isEmptyOrNil ifTrue: [ self mc morphicOpen: nil ].		it := self mcThing. 	(it respondsTo: #open) ifTrue: [ ^ it open ].	"in case an old mc doesnt have #open"		(it instVarNamed: 'versions') do: #open.! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'mtf 5/20/2008 17:38'!cache		mc := self classMCCacheRepository default.	root := mc directory localName ! !!InstallerMonticello methodsFor: 'class references' stamp: 'mtf 5/20/2008 16:43'!classMCCacheRepository	^Smalltalk at: #MCCacheRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 01:01'!classMCDirectoryRepository	^Smalltalk at: #MCDirectoryRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:56'!classMCFtpRepository	^Smalltalk at: #MCFtpRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:59'!classMCGOODSRepository	^Smalltalk at: #MCGOODSRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:56'!classMCHttpRepository	^Smalltalk at: #MCHttpRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:59'!classMCMagmaRepository	^Smalltalk at: #MCMagmaRepository ifAbsent: [ self error: 'Magma not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'mtf 10/25/2008 14:04'!classMCRepositoryGroup	^Smalltalk at: #MCRepositoryGroup ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:56'!classMCSmtpRepository	^Smalltalk at: #MCSmtpRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'stephane.ducasse 9/30/2008 18:34'!classMCVersionLoader	^Smalltalk at: #MCVersionLoader  ifAbsent: [ self error: 'Monticello not present' ]! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 12/19/2007 00:30'!directory: dir	| directory |	directory := dir isString 		ifTrue: [  FileDirectory on: (FileDirectory default fullNameFor: dir) ]		ifFalse: [ dir ].			mc := self classMCDirectoryRepository new directory: directory; yourself. 	root := dir	 ! !!InstallerMonticello methodsFor: 'accessing' stamp: 'kph 12/2/2008 07:43'!fromUrl: aUrl	| url  path |		url := aUrl asUrl.	self http: url authority.		path := url path.		path size = 2 ifTrue: [ 		self project: path first.		path removeFirst. 	].			path size = 1 ifTrue: [ self package: path first ].! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 12/18/2008 02:06'!ftp: host directory: dir user: name password: secret	"Installer mc ftp: 'mc.gjallar.se' directory: '' user: 'gjallar' password: secret."		mc := self classMCFtpRepository host: host directory: dir user: name password: secret.	root :=  dir.	 ! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 5/10/2007 00:58'!goods: host port: aport		mc := (self classMCGOODSRepository new) host: host port: aport; yourself ! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 12/15/2007 11:37'!http: aUrl  		self http: aUrl user: 'squeak' password: 'squeak'		 ! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 5/10/2007 03:45'!http: aUrl user: name password: secret		mc := self classMCHttpRepository location: aUrl user: name password: secret.	root := mc locationWithTrailingSlash	 ! !!InstallerMonticello methodsFor: 'accessing' stamp: 'kph 12/2/2008 07:42'!latest 	| newPackage |	newPackage := self package copyUpToLast: $-.	self packages removeLast.	self package: newPackage	"Installer mc fromUrl: 'http://www.squeaksource.com/Installer/Installer-Core-kph.100.mcz'."! !!InstallerMonticello methodsFor: 'accessing' stamp: 'kph 12/2/2008 07:40'!latestFromUsers: list	| newPackage |	newPackage := self package copyUpToLast: $-.	self packages removeLast.	self package: (list collect: [ :ea | newPackage, '-', ea ])! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 5/10/2007 00:58'!magma: host port: aport		mc := (self classMCMagmaRepository new) host: host port: aport; yourself ! !!InstallerMonticello methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!mc	^ mc! !!InstallerMonticello methodsFor: 'accessing' stamp: 'kph 12/8/2008 03:24'!mc: aRepo	mc := aRepo! !!InstallerMonticello methodsFor: 'monticello' stamp: 'kph 5/24/2007 19:49'!mcDetectFileBlock	self package isString ifTrue: [  ^ [ :aFile | aFile beginsWith: self package ] ].	(self package isKindOf: Array) 			ifTrue: [  ^  [ :aFile | (self package detect: [ :item | aFile beginsWith: item ] ifNone: [ false ]) ~= false ] ].	self package isBlock ifTrue: [ ^ self package ].   ! !!InstallerMonticello methodsFor: 'monticello' stamp: 'stephane.ducasse 9/30/2008 18:39'!mcSortFileBlock	^ [:a :b |         	[(a findBetweenSubStrs: #($.)) allButLast last asInteger > (b findBetweenSubStrs: #($.)) allButLast last asInteger] 				on: Error do: [:ex | false]].! !!InstallerMonticello methodsFor: 'monticello' stamp: 'kph 12/8/2008 03:36'!mcThing	| loader files fileToLoad  version  count |	loader := self classMCVersionLoader new.		1 to: self packages size do: [ :n |		self logCR: 'finding ', self package asString, '...'.		"several attempts to read files - repository readableFileNames sometimes fails"		count := 0. fileToLoad := nil.			[count := count + 1.		 (fileToLoad = nil) and:[ count < 5 ] ] 			whileTrue: [							files := mc readableFileNames asSortedCollection: self mcSortFileBlock.							fileToLoad := files detect: self mcDetectFileBlock ifNone: [ nil ].		].		fileToLoad ifNil: [ Warning signal: 'Package: ', self package ,' not found in repository: ', mc description. ^ nil ].		version := mc versionFromFileNamed: fileToLoad.		(version isKindOf: MCConfiguration) 			ifTrue: [ ^ version ]			ifFalse:[				MCRepositoryGroup default addRepository: self normalizedRepository.				version workingCopy repositoryGroup addRepository: self normalizedRepository.				loader addVersion: version].		self log: ' found ', version fileName, '...'.		packages removeFirst.	].	^ loader! !!InstallerMonticello methodsFor: 'monticello' stamp: 'test 1/15/2009 15:10'!mcUrl	^ self mc description 	! !!InstallerMonticello methodsFor: 'monticello' stamp: 'mtf 10/25/2008 14:04'!normalizedRepository"Find an existing instance of the active repository so that we use whatever name and password the user usually uses. If not found, answer a copy"	self classMCRepositoryGroup default repositoriesDo: [:ea |		mc = ea ifTrue: [^ ea]].	^ mc copy! !!InstallerMonticello methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!open	self mc morphicOpen: nil! !!InstallerMonticello methodsFor: 'searching' stamp: 'mtf 10/8/2008 12:00'!packagesMatching: aMatch	^ (self availablePackages		select: [:p | ( aMatch , '.mcz' ) match: p])		collect: [:p | self copy package: p ; yourself]! !!InstallerMonticello methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:04'!project	^ project! !!InstallerMonticello methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:04'!project: name	project := name.	packages := nil.		(mc respondsTo: #location:) ifTrue:[ mc := mc copy location: root , name ].	(mc respondsTo: #directory:) ifTrue: [ mc := mc copy directory: root ,'/', name ].			^self copy.! !!InstallerMonticello methodsFor: 'public interface' stamp: 'kph 12/8/2008 01:02'!unload 	(MCWorkingCopy allManagers select: [ :wc | self package match: (wc package name) ])		 do: [ :wc |  			 	self logCR: 'Unloading ', wc package asString. 				wc unload.].	self unloadCleanUp! !!InstallerMonticello methodsFor: 'public interface' stamp: 'kph 12/8/2008 01:02'!unload: match 	self addPackage: match.	self unload.! !!InstallerMonticello methodsFor: 'public interface' stamp: 'kph 10/23/2008 20:57'!unloadCleanUp 	SystemOrganization removeEmptyCategories.	"Until Mantis 5718 is addressed" 	Smalltalk at: #PackagePaneBrowser ifPresent: [ :ppbClass | ppbClass allInstancesDo: [ :ppb | ppb updatePackages ]  ]. 	Smalltalk at: #Browser ifPresent: [ :bClass | bClass allInstancesDo: [ :b | b updateSystemCategories ] ].	MCFileBasedRepository freeSomeSpace.	SmalltalkImage current fixObsoleteReferences.! !Installer subclass: #InstallerSake	instanceVariableNames: 'sake'	classVariableNames: 'Sake'	poolDictionaries: ''	category: 'Installer-Core'!!InstallerSake class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classPackages	^Smalltalk at: #Packages  ifAbsent: [ self error: 'Sake Packages code not present' ]! !!InstallerSake class methodsFor: 'accessing' stamp: 'kph 6/30/2008 16:49'!sake	^ Sake ifNil: [ self classPackages current ]! !!InstallerSake class methodsFor: 'accessing' stamp: 'mtf 10/8/2008 12:00'!sake: aClass	Sake := aClass! !!InstallerSake methodsFor: 'basic interface' stamp: 'kph 4/23/2008 22:44'!basicInstall 	self withAnswersDo: [ (self packages collect: [ :packageName | sake named: packageName ]) asTask run ].	! !!InstallerSake methodsFor: 'websqueakmap' stamp: 'kph 1/28/2008 11:27'!sake 	^ sake  ! !!InstallerSake methodsFor: 'websqueakmap' stamp: 'kph 1/28/2008 10:41'!sake: aSakePackagesClass	sake := aSakePackagesClass! !Installer subclass: #InstallerSqueakMap	instanceVariableNames: 'sm'	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:43'!basicAvailablePackages		^self classSMSqueakMap default packagesByName! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'kph 5/10/2007 00:29'!basicBrowse	self smThing explore! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:42'!basicInstall 	self log: ' installing '. 	self withAnswersDo: [ self smThing install ].	self log: ' done'.! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:43'!basicVersions 	^ (self smReleasesForPackage: self package) 			collect: [ :v | self copy package: (v package name,'(',v version,')'); yourself. ]  ! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'kph 5/10/2007 00:25'!basicView	self smThing explore! !!InstallerSqueakMap methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classSMLoader	^Smalltalk at: #SMLoader  ifAbsent: [ self error: 'SqueakMap Loader not present' ]! !!InstallerSqueakMap methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classSMSqueakMap	^Smalltalk at: #SMSqueakMap  ifAbsent: [ self error: 'SqueakMap not present' ]! !!InstallerSqueakMap methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!open	self classSMLoader open! !!InstallerSqueakMap methodsFor: 'searching' stamp: 'mtf 10/8/2008 12:00'!packagesMatching: aMatch	^ (self availablePackages		select: [ :p | aMatch match: p name ]) 		collect: [ :p | self copy package: p name; yourself ]! !!InstallerSqueakMap methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:05'!sm	^ sm ifNil: [ false ]! !!InstallerSqueakMap methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:05'!sm: anObject	sm := anObject! !!InstallerSqueakMap methodsFor: 'squeakmap' stamp: 'kph 4/24/2008 23:03'!smPackageAndVersion	| p |	p := ReadStream on: self package .	^Array with: (p upTo: $() with: (p upTo: $)).! !!InstallerSqueakMap methodsFor: 'squeakmap' stamp: 'sd 3/6/2008 20:43'!smReleasesForPackage: name 	^(self classSMSqueakMap default packageWithName: name) releases! !!InstallerSqueakMap methodsFor: 'searching' stamp: 'sd 3/6/2008 20:25'!smSearch: aMatch  	| results |	results := Set new.	self availablePackages do: [ :pkg |		({ 'name:',pkg name.		   'summary:', pkg summary.		   'description:', pkg description.		   'author:', pkg author. } anySatisfy: [ :field | aMatch match: field ])		 ifTrue: [ results add: (self copy package: pkg name) ]. 	].	^results! !!InstallerSqueakMap methodsFor: 'squeakmap' stamp: 'sd 3/6/2008 20:43'!smThing 	| pkgAndVersion releases release |	pkgAndVersion := self packageAndVersionFrom: self package.	self logCR: 'retrieving ', self package, ' from SqueakMap...'.	releases := self smReleasesForPackage: pkgAndVersion first.	release := pkgAndVersion last isEmpty 				ifTrue: [ releases last ]				ifFalse:[ releases detect: [ :rel | rel version = pkgAndVersion last ] ]. 	^ release			! !!InstallerSqueakMap methodsFor: 'squeakmap' stamp: 'stephane.ducasse 9/30/2008 18:41'!update"Updates the local map for SqueakMap, upgrading SqueakMap to the latest version if necessary.When SqueakMap is old and needs to be upgraded, it does four things that mostly make sense in the interactive world SM was built for, but are totally evil here in the world of automatic scripting:1. It asks the user if she wants to upgrade, in the form of a pop-up (see SMSqueakMap >> #checkVersion:).2. It terminates its own process.3. It creates a new UI process.(see the last line of the SqueakMap upgrade file-in: ''Project spawnNewProcessAndTerminateOld: true'', from http://map.squeak.org/accountbyid/9bdedc18-1525-44a6-9b79-db5d4a87f6f8/files/SqueakMap8.st4. It opens a SqueakMap windowWe work around these three problems seperately:1. We use #answer:with: and #withAnswersDo: to automatically answer ''Yes'' when asked if we want to upgrade2. We don't want this process to be terminated, so we run the update in a forked process and wait for it to finish, using #fork, #ensure:, and a Semaphore3. We keep track of the UI process before updating, and if it changes, we terminate the new UI process and reinstall the old one using Project >> #resumeProcess:4. We don't bother with the newly opened window. The other three problems are much worse.We do all this in a new process, since it is not unlikely that this method is executing in the UI process"	| oldUIProcess newUIProcess doneSema |	self answer: 'You need to upgrade the SqueakMap package' with: true.	oldUIProcess := Project uiProcess.	doneSema := Semaphore new.	[[self withAnswersDo: [self classSMSqueakMap default loadUpdates]] 		ensure: [newUIProcess := Project uiProcess.		(oldUIProcess ~~ newUIProcess				and: [oldUIProcess notNil]					and: [oldUIProcess isTerminated not])					 ifTrue: [							newUIProcess ifNotNil: [newUIProcess terminate].							oldUIProcess suspend.							Project resumeProcess: oldUIProcess.].	doneSema signal]] fork.	doneSema wait! !Installer subclass: #InstallerUniverse	instanceVariableNames: 'universe'	classVariableNames: 'LastUniUpdate'	poolDictionaries: ''	category: 'Installer-Core'!!InstallerUniverse class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classUGlobalInstaller	^Smalltalk at: #UGlobalInstaller  ifAbsent: [ self error: 'Universes code not present' ]! !!InstallerUniverse class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classUUniverse	^Smalltalk at: #UUniverse  ifAbsent: [ self error: 'Universes code not present' ]! !!InstallerUniverse class methodsFor: 'instance creation' stamp: 'mtf 10/14/2008 10:09'!default	^ self universe: (self classUGlobalInstaller universe: self classUUniverse systemUniverse)! !!InstallerUniverse class methodsFor: 'instance creation' stamp: 'mtf 10/14/2008 10:10'!universe: u	^ self new universe: u! !!InstallerUniverse methodsFor: 'basic interface' stamp: 'sd 3/6/2008 19:05'!basicInstall	| pkgAndVersion pkg version potentials |	self packages do: [ :packageName |			pkgAndVersion := self packageAndVersionFrom: packageName.		pkg := pkgAndVersion first.		version := pkgAndVersion last.			potentials := universe packageVersionsForPackage: pkg.			pkg := version isEmpty 			ifTrue: [ potentials last ]			ifFalse: [ 				version := self classUVersion readFrom: version readStream.  				potentials detect:[ :p | p version = version] ifNone: [ ^ self error: 'version not found']			].			universe planToInstallPackage: pkg.	].	self uniDoInstall! !!InstallerUniverse methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classUVersion	^Smalltalk at: #UVersion  ifAbsent: [ self error: 'Universes code not present' ]! !!InstallerUniverse methodsFor: 'universes' stamp: 'kph 7/25/2007 13:46'!uniDoInstall	self withAnswersDo: [ self universe doInstall ] ! !!InstallerUniverse methodsFor: 'universes' stamp: 'kph 7/25/2007 12:52'!universe	^ universe! !!InstallerUniverse methodsFor: 'universes' stamp: 'squeak 7/26/2007 18:12'!universe: u	universe := u.	self update.! !!InstallerUniverse methodsFor: 'public interface' stamp: 'stephane.ducasse 9/30/2008 18:41'!update	(LastUniUpdate isNil or:[ (DateAndTime now - LastUniUpdate) > 600 seconds  ])		ifTrue: [universe requestPackageList.				LastUniUpdate := DateAndTime now]! !Installer subclass: #InstallerUpdateStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/6/2008 20:40'!changesetNamesFromUpdates: startNumber through: stopNumber	"Answer the concatenation of summary strings for updates numbered in the given range"	"self new changesetNamesFromUpdates: 7059 through: 7061"		^ String streamContents: [:aStream |		((ChangeSet changeSetsNamedSuchThat:			[:aName | aName first isDigit and:						[aName initialIntegerOrNil >= startNumber] and:						[aName initialIntegerOrNil <= stopNumber]]) asSortedCollection:				[:a :b | a name < b name]) do:					[:aChangeSet | aStream cr; nextPutAll: aChangeSet summaryString]]! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/8/2008 21:15'!loadUpdatesFromDisk		| updateDirectory updateNumbers |	updateDirectory := self updateDirectoryOrNil.	updateDirectory ifNil: [^ self].	updateNumbers := updateDirectory fileNames						collect: [:fn | fn initialIntegerOrNil]						thenSelect: [:fn | fn notNil].		self loadUpdatesFromDiskToUpdateNumber: updateNumbers max		stopIfGap: false			! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/9/2008 11:30'!loadUpdatesFromDiskToUpdateNumber: lastUpdateNumber stopIfGap: stopIfGapFlag 	"To use this mechanism, be sure all updates you want to have considered 	are in a folder named 'updates' which resides in the same directory as  	your image. Having done that, simply evaluate:  	 	Installer new loadUpdatesFromDiskToUpdateNumber: 100020 stopIfGap: false  	 	and all numbered updates <= lastUpdateNumber not yet in the image will 	be loaded in numerical order."		"apparently does not use the updatelist too bad!! and to rewrite - sd 7 March 2008"	| previousHighest currentUpdateNumber done fileNames aMessage updateDirectory loaded |	updateDirectory := self updateDirectoryOrNil.	updateDirectory ifNil: [^ self].	previousHighest := SystemVersion current highestUpdate.	currentUpdateNumber := previousHighest.	done := false.	loaded := 0.	[done]		whileFalse: [currentUpdateNumber := currentUpdateNumber + 1.			currentUpdateNumber > lastUpdateNumber				ifTrue: [done := true]				ifFalse: [fileNames := updateDirectory fileNamesMatching: currentUpdateNumber printString , '*'.					fileNames size > 1						ifTrue: [^ self inform: 'ambiguity -- two files both start with ' , currentUpdateNumber printString , '(at this point it is probably best to remedythe situation on disk, then try again.)'].					fileNames size == 0						ifTrue: [Transcript cr; show: 'gap in updates from disk for update number '; print: currentUpdateNumber; show: ' found...'.							done := stopIfGapFlag]						ifFalse: [ChangeSet								newChangesFromStream: (updateDirectory readOnlyFileNamed: fileNames first)								named: fileNames first.							SystemVersion current registerUpdate: currentUpdateNumber.							loaded := loaded + 1]]].	aMessage := loaded = 0				ifTrue: ['No new updates found.']				ifFalse: [loaded printString , ' update(s) loaded.'].	self inform: aMessage , 'Highest numbered update is now ' , (currentUpdateNumber - 1) printString , '.'! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/3/2008 10:37'!parseUpdateListContents: listContentString	"Parse the contents of an updates.list into {{releaseTag. {fileNames*}}*}, and return it."	| sections releaseTag strm line fileNames |	sections := OrderedCollection new.	fileNames := OrderedCollection new: 1000.	releaseTag := nil.	strm := ReadStream on: listContentString.	[strm atEnd] whileFalse:		[line := strm upTo: Character cr.		line size > 0 ifTrue:			[line first = $#				ifTrue: [releaseTag ifNotNil: [sections addLast: {releaseTag. fileNames asArray}].						releaseTag := line allButFirst.						fileNames resetTo: 1]				ifFalse: [line first = $* ifFalse: [fileNames addLast: line]]]].	releaseTag ifNotNil: [sections addLast: {releaseTag. fileNames asArray}].	^ sections asArray! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/8/2008 21:13'!updateDirectoryOrNil	^ (FileDirectory default directoryNames includes: 'updates')		ifTrue: [FileDirectory default directoryNamed: 'updates']		ifFalse: [self inform: 'Error: cannot find "updates" folder'.				nil]! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/3/2008 10:52'!writeList: listContents toStream: strm	"Write a parsed updates.list out as text.	This is the inverse of parseUpdateListContents:"	| fileNames releaseTag |	strm reset.	listContents do:		[:pair | 		releaseTag := pair first.  		fileNames := pair last.		strm nextPut: $#; nextPutAll: releaseTag; cr.		fileNames do: [:fileName | strm nextPutAll: fileName; cr]].	strm close! !InstallerMantis initialize!InstallerWeb initialize!----End fileIn of a stream----!"This script prepares Squeak 3.7, 3.8.1(and 3.8), 3.9, and 3.10 to be able to 
run Installer scripts on the http://installer.pbwiki.com site.

If used as the first squeak argument, subsequent arguments are processed by Launcher. 
This allows a desired result to be obtained in one hit, given a virgin image

e.g.
squeak Squeak3.8.1-6747-basic.image http://installer.pbwiki.com/f/LPF.st   \
 Installer url=''http: ...'' SmaltalkImage save=test.image +quit
"
| version wc |

Transcript open.

"First we obtain a reasonable version of Installer"
Transcript show: 'Installer bootstrap - Loading http://installer.pbwiki.com/f/Installer.st'; cr.

wc := Smalltalk at: #MCWorkingCopy ifAbsent: [ nil ].


wc ifNotNil: [ 
	(wc allManagers select:  [:each | each packageName = 'Installer-Core' ]) 
		do: [ :ea | ea unregister ] 
].

"uninstall previous version"
SystemOrganization removeSystemCategory: #'Installer-Core'.
(HTTPSocket httpGet: 'installer.pbwiki.com/f/Installer.st') readStream fileIn!'From Croquet1.0beta of 11 April 2006 [latest update: #2] on 21 July 2008 at 8:46 pm'!!SyntaxError methodsFor: 'other' stamp: 'mtf 7/21/2008 20:44' prior: 31434855!contents: aString notifying: aController	"Compile the code in aString and proceed. Do not notify anybody of errors, because nobody would have been notified of errors if this syntax error had not arisen"	doitFlag		ifTrue: [Compiler new evaluate: aString]		ifFalse: [class compile: aString classified: category].	aController hasUnacceptedEdits: false.	self proceed! !----End fileIn of a stream----!Installer mantis bug: 7131 fix: 'SyntaxErrorUsesNonInteractiveParser-M7131.1.cs'.!----End fileIn of a stream----!'From etoys3.0 of 24 February 2008 [latest update: #2159] on 4 October 2008 at 9:56:38 pm'!"Change Set:		MethodReference-categoryDate:			4 October 2008Author:			Matthew FulmerI add the instance variable 'category' to MethodReference. This allows Monticello snapshotting to be about 25% faster"!Object subclass: #MethodReference	instanceVariableNames: 'classSymbol classIsMeta methodSymbol stringVersion category '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!MethodReference methodsFor: 'queries' stamp: 'mtf 10/4/2008 01:18' prior: 24484369!category	^ category ifNil: [category := self actualClass organization categoryOfElement: methodSymbol]! !!MethodReference methodsFor: 'setting' stamp: 'mtf 10/4/2008 00:52'!category: aSymbol	category := aSymbol! !Object subclass: #MethodReference	instanceVariableNames: 'classSymbol classIsMeta methodSymbol stringVersion category'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!----End fileIn of a stream----!Installer mantis bug: 7205 fix: 'MethodReference-category-M7205.2.cs'.!----End fileIn of a stream----!'From Croquet1.0beta of 11 April 2006 [latest update: #2] on 19 January 2009 at 3:18:03 pm'!!Categorizer methodsFor: 'accessing' stamp: 'mtf 1/19/2009 15:00' prior: 18081202!categories: anArray	"Reorder my categories to be in order of the argument, anArray. If the 	resulting organization does not include all elements, then give an error."	| newCategories newStops newElements catName list runningTotal | 		anArray size < 2 ifTrue: [ ^ self ].		newCategories := Array new: anArray size.	newStops := Array new: anArray size.	newElements := Array new: 0.	runningTotal := 0.	1 to: anArray size do:		[:i |		catName := (anArray at: i) asSymbol.		list := self listAtCategoryNamed: catName.				newElements := newElements, list.				newCategories at: i put: catName.				newStops at: i put: (runningTotal := runningTotal + list size)].	elementArray do:		[:element | "check to be sure all elements are included"		(newElements includes: element)			ifFalse: [^self error: 'New categories must match old ones']].	"Everything is good, now update my three arrays."	categoryArray := newCategories.	categoryStops := newStops.	elementArray := newElements! !----End fileIn of a stream----!Installer mantis bug: 7218 fix: 'EmptyCategoryList-M7218.2.cs'.!----End fileIn of a stream----!'From Pharo0.1 of 16 May 2008 [latest update: #10074] on 28 September 2008 at 6:26:08 pm'!!Behavior methodsFor: 'accessing method dictionary' stamp: 'kph 8/27/2008 22:31' prior: 17328318!allSelectors	"Answer all selectors understood by instances of the receiver"	^ self allSelectorsBelow: nil! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'dc 9/28/2008 15:54'!allSelectorsBelow: topClass 	| coll |	coll := IdentitySet new.	self withAllSuperclassesDo: 			[:aClass | 			aClass = topClass				ifTrue: [^ coll ]				ifFalse: [aClass selectorsDo: [ :sel | coll add: sel ]]].	^ coll	! !!BehaviorTest methodsFor: 'tests' stamp: 'dc 9/28/2008 16:46'!testAllSelectors	self assert: ProtoObject allSelectors = ProtoObject selectors.	self assert: Object allSelectors = (Object selectors union: ProtoObject selectors).	self assert: (Object allSelectorsBelow: ProtoObject) = (Object selectors).! !----End fileIn of a stream----!Installer mantis bug: 7166 fix: 'Speedup-AllSelectors-M7166.1.cs'.!----End fileIn of a stream----!'From Pharo0.1 of 16 May 2008 [Latest update: #10234] on 17 February 2009 at 10:32:42 am'!!HTTPSocket class methodsFor: 'get the page' stamp: 'damiencassou 2/17/2009 10:27' prior: 21679198!httpGet: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| document |	document := self httpGetDocument: url  args: args  accept: mimeType request: requestString.	(document isString) ifTrue: [		"strings indicate errors"		^ document ].	^ (RWBinaryOrTextStream with: document content) reset! !!HTTPSocket class methodsFor: 'get the page' stamp: 'damiencassou 2/17/2009 09:55' prior: 21679868!httpGet: url args: args user: user passwd: passwd	| authorization result |	authorization := (Base64MimeConverter mimeEncode: (user , ':' , passwd) readStream) contents.	result := self 		httpGet: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , String crlf.	result isString ifFalse: [^result].	authorization := self digestFor: result method: 'GET' url: url user: user password: passwd.	authorization ifNil: [^result].	^self 		httpGet: url args: args accept: '*/*' 		request: 'Authorization: Digest ' , authorization , String crlf.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'damiencassou 2/17/2009 10:11' prior: 21691993!httpPost: url args: args user: user passwd: passwd	| authorization result |	authorization := (Base64MimeConverter mimeEncode: (user , ':' , passwd) readStream) contents.	result := self 		httpPostDocument: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , String crlf.	result isString ifFalse: [^result].	authorization := self digestFor: result method: 'POST' url: url user: user password: passwd.	authorization ifNil: [^result].	^self 		httpPostDocument: url args: args accept: '*/*' 		request: 'Authorization: Digest ' , authorization , String crlf.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'damiencassou 2/17/2009 10:14' prior: 21692352!httpPut: contents to: url user: user passwd: passwd	"Upload the contents of the stream to a file on the server"	| bare serverName specifiedServer port page serverAddr authorization s list header firstData length aStream command digest |	Socket initializeNetwork. 	"parse url"	bare := (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName := bare copyUpTo: $/.	specifiedServer := serverName.	(serverName includes: $:) ifFalse: [ port := self defaultPort ] ifTrue: [		port := (serverName copyFrom: (serverName indexOf: $:) + 1 				to: serverName size) asNumber.		serverName := serverName copyUpTo: $:.	].	page := bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page := '/'].	(self shouldUseProxy: serverName) ifTrue: [ 		page := 'http://', serverName, ':', port printString, page.		"put back together"		serverName := self httpProxyServer.		port := self httpProxyPort].  	"make the request"		serverAddr := NetNameResolver addressForName: serverName timeout: 20.	serverAddr ifNil: [		^ 'Could not resolve the server named: ', serverName].	authorization := ' Basic ', (Base64MimeConverter mimeEncode: (user , ':' , passwd) readStream) contents.[	s := HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: url; cr.	command := 		'PUT ', page, ' HTTP/1.0', String crlf, 		self userAgentString, String crlf,		'Host: ', specifiedServer, String crlf, 		'ACCEPT: */*', String crlf,		HTTPProxyCredentials,		'Authorization: ' , authorization , String crlf , 		'Content-length: ', contents size printString, String crlf , String crlf , 		contents.	s sendCommand: command.	"get the header of the reply"	list := s getResponseUpTo: String crlf, String crlf ignoring: String cr.	"list = header, CrLf, CrLf, beginningOfData"	header := list at: 1.	"Transcript show: page; cr; show: argsStream contents; cr; show: header; cr."	firstData := list at: 3.	"dig out some headers"	s header: header.(authorization beginsWith: 'Digest ') notand: [(digest := self digestFrom: s method: 'PUT' url: url user: user password: passwd) notNil]]	whileTrue: [authorization :=  'Digest ', digest].	length := s getHeader: 'content-length'.	length ifNotNil: [ length := length asNumber ].	aStream := s getRestOfBuffer: firstData totalLength: length.	s destroy.	"Always OK to destroy!!"	^ header, aStream contents! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'damiencassou 2/17/2009 10:09' prior: 21673255!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index connectToHost connectToPort type newUrl |	Socket initializeNetwork.	bare := (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare := bare copyUpTo: $#.  "remove fragment, if specified"	serverName := bare copyUpTo: $/.	page := bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index := serverName indexOf: $:.			port := (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName := serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port := self defaultPort ].	page size = 0 ifTrue: [page := '/'].	"add arguments"	args ifNotNil: [page := page, (self argString: args) ].	(self shouldUseProxy: serverName)		ifFalse: [ 			connectToHost := serverName.			connectToPort := port ]		ifTrue:  [			page := 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost := self httpProxyServer.			connectToPort := self httpProxyPort].		serverAddr := NetNameResolver addressForName: connectToHost timeout: 20.	serverAddr ifNil: [		^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [	sock := HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	"Transcript cr;show: url; cr.	Transcript show: page; cr."	sock sendCommand: 'GET ', page, ' HTTP/1.0', String crlf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, String crlf] ifNil: ['']),		'ACCEPT: text/html', String crlf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		self userAgentString, String crlf,		'Host: ', serverName, ':', port printString, String crlf.	"blank line automatically added"	list := sock getResponseUpTo: String crlf, String crlf ignoring: String cr.	"list = header, CrLf, CrLf, beginningOfData"	header := list at: 1.	"Transcript show: page; cr; show: header; cr."	firstData := list at: 3.	header isEmpty 		ifTrue: [aStream := 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length := sock getHeader: 'content-length'.			length ifNotNil: [ length := length asNumber ].			type := sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl := sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					newUrl := self expandUrl: newUrl ip: serverAddr port: connectToPort.					^self httpGetDocument: newUrl args: args  accept: mimeType request: requestString] ].			aStream := sock getRestOfBuffer: firstData totalLength: length.			"a 400-series error"			sock responseCode first = $4 ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifTrue: [ ^aStream ].	].{'HTTPSocket class>>httpGetDocument:args:accept:request:'. aStream. url} inspect.	^'some other bad thing happened!!'! !!HTTPSocket class methodsFor: 'digest' stamp: 'damiencassou 2/17/2009 09:53'!digestFor: serverText method: method url: url user: user password: password	"RFC2069"	| sock |	sock := HTTPSocket new. "header decoder is on instance side"	sock header: (serverText readStream upToAll: String crlf, String crlf).	^self digestFrom: sock method: method url: url user: user password: password! !!HTTPSocket class methodsFor: 'digest' stamp: 'damiencassou 2/17/2009 09:54'!digestFrom: sock method: method url: url user: user password: password	"RFC2069"	| auth fields realm nonce uri a1 a2 response |	sock responseCode = '401' ifFalse: [^nil].	auth := sock getHeader: 'www-authenticate'.	(auth asLowercase beginsWith: 'digest') ifFalse: [^nil].	fields := (((auth allButFirst: 6) findTokens: ', 	') collect: [:ea |		(ea copyUpTo: $=) asLowercase -> (ea copyAfter: $=) withoutQuoting]) as: Dictionary.	realm := fields at: 'realm'.	nonce := fields at: 'nonce'.	uri := url readStream upToAll: '://'; skipTo: $/; skip: -1; upTo: $#.	a1 := self md5Hash: user, ':', realm, ':', password.	a2 := self md5Hash: method, ':', uri.	a1 ifNil: [^nil "no MD5 support"].	response := self md5Hash: a1, ':', nonce, ':', a2.	^String streamContents: [:digest |		digest			nextPutAll: 'username="', user, '"';			nextPutAll: ', realm="', realm, '"';			nextPutAll: ', nonce="', nonce, '"';			nextPutAll: ', uri="', uri, '"';			nextPutAll: ', response="', response, '"'.		fields at: 'opaque' ifPresent: [:opaque |			digest nextPutAll: ', opaque="', opaque, '"'].	]! !!HTTPSocket class methodsFor: 'digest' stamp: 'damiencassou 2/17/2009 10:15'!md5Hash: aString	"Answer hash of aString as lowercase 32 digit hex String.	There are several providers of MD5 hash ..."	"(self md5Hash: 'user:realm:passwd') =  '007e68e539ed680c24f6d9a370f3bcb1'"	| hash |	hash := Smalltalk at: #CMD5Hasher ifPresent: [:cls |		cls hashMessage: aString].	hash ifNil: [		hash := Smalltalk at: #TCryptoRandom ifPresent: [:cls |			(cls basicNew md5HashMessage: aString) asInteger]].	hash ifNotNil: [		hash := hash hex asLowercase.		(hash beginsWith: '16r') ifTrue: [hash := hash allButFirst: 3].		hash := hash padded: #left to: 32 with: $0].	^hash! !----End fileIn of a stream----!Installer mantis bug: 7291 fix: 'MergingMonticello15OverridesOnHTTPSocket-M7291.1.cs'.!----End fileIn of a stream----!Transcript show: 'Preamble found:'. Installer mantis ensureFix: 7131. Installer mantis ensureFix: 7205. Installer mantis ensureFix: 7218. Installer mantis ensureFix: 7166. Installer mantis ensureFix: 7291.!----End fileIn of a stream----!!String methodsFor: '*packageinfo-base' stamp: 'ab 5/31/2003 17:13' prior: 31262515!escapeEntities	^ String streamContents: [:s | self do: [:c | s nextPutAll: c escapeEntities]]! !!PositionableStream methodsFor: '*packageinfo-base' stamp: 'nk 6/17/2003 07:45' prior: 27646484!untilEnd: aBlock displayingProgress: aString	aString		displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:			[:bar |			[self atEnd] whileFalse:				[bar value: self position.				aBlock value]].! !!ReadStream methodsFor: '*packageinfo-base' stamp: 'ab 5/24/2003 14:28' prior: 28419427!untilEnd: aBlock displayingProgress: aString	aString		displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:			[:bar |			[self atEnd] whileFalse:				[bar value: self position.				aBlock value]].! !!PackageInfo commentStamp: 'kph 12/7/2008 03:10' prior: 26250789!Subclass this class to create new specialised packages, and make sure that #isResponsibleForName: is correctly defined.We have a number of useful default package types defined. If you use the appropriate suffix for the package name you add, then it will select the correct PacakgeInfo subclass.Package types for selective platform specific code exporting are available as an addon package. I.e. you can have a single package, and have a Seaside.vw Seaside.squeak etc providing different exports of the same codebase.External Files Support================The default implementation of the two methods below considers all files and directories (with their contents) matching the package name to be part of the package.#externalFiles#externalFilesMatchese.g. package name 'Release'.files matching would include:Release.textRelease/Introduction.textRelease/Tutorial/ch1.textExternal Files Support - Monticello========================================*Only file based repositories (i.e. .mcz files) are supported at presentSince your external files will change far less than your code, it is recommended that youuse a separate package to manage files in order to save space and time.Files are included in the .mcz (which is a standard zip archive)as files/* according to the pattern files/<uuid>/<path>/<to>/<file>*note: the uuid will change with every snapshot, it is unique to that file in that snapshot*note: in changes browsers the file is considered to be changed if the fileSize has changed.Snapshotting a package with files uses a temporary directory in package-cache/filesThe #flushCachedVersions menu item deletes this directory.OSProcess!!PackageInfo class methodsFor: 'packages access' stamp: 'kph 10/26/2008 00:43' prior: 26263260!allPackages	^ self organizer packages! !!PackageInfo class methodsFor: 'class selection' stamp: 'kph 9/3/2008 20:14'!classResponsibleForName: aString 	PackageInfo allSubclassesDo: [ :class |		(class isResponsibleForName: aString) ifTrue: [ ^ class ].		].	^ PackageInfo! !!PackageInfo class methodsFor: 'class selection' stamp: 'kph 5/15/2008 18:48'!isResponsibleForName: aString^ false! !!PackageInfo class methodsFor: 'packages access' stamp: 'kph 8/3/2008 05:01' prior: 26263392!named: aString	^ PackageOrganizer default packageNamed: aString ifAbsent: [(self newForName: aString) register]! !!PackageInfo class methodsFor: 'private' stamp: 'kph 5/15/2008 18:31'!newForName: aString	^ (self classResponsibleForName: aString) basicNew 		packageName: aString; 		initialize; 		yourself! !!PackageInfo class methodsFor: 'packages access' stamp: 'kph 10/26/2008 00:42'!organizer	^PackageOrganizer default! !!PackageInfo class methodsFor: 'as yet unclassified' stamp: 'ab 11/14/2002 15:05'!registerPackage: aString	"for compatibility with old fileOuts"	^ Smalltalk at: #FilePackageManager ifPresent: [:p | p registerPackage: aString]! !!PackageInfo class methodsFor: 'packages access' stamp: 'avi 11/11/2003 17:19' prior: 26263594!registerPackageName: aString	^ PackageOrganizer default registerPackageNamed: aString! !!PackageInfo methodsFor: 'comparing' stamp: 'avi 10/11/2003 00:09' prior: 26251001!= other	^ other species = self species and: [other packageName = self packageName]! !!PackageInfo methodsFor: 'modifying' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26255281!addCoreMethod: aMethodReference	| category |	category := self baseCategoryOfMethod: aMethodReference.	aMethodReference actualClass organization		classify: aMethodReference methodSymbol		under: category		suppressIfDefault: false! !!PackageInfo methodsFor: 'modifying' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26255597!addExtensionMethod: aMethodReference	| category |	category := self baseCategoryOfMethod: aMethodReference.	aMethodReference actualClass organization		classify: aMethodReference methodSymbol		under: self methodCategoryPrefix, '-', category! !!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/11/2003 15:16' prior: 26255913!addMethod: aMethodReference	(self includesClass: aMethodReference class)		ifTrue: [self addCoreMethod: aMethodReference]		ifFalse: [self addExtensionMethod: aMethodReference]! !!PackageInfo methodsFor: 'testing' stamp: 'kph 2/7/2009 16:40'!allMethodsForAuthor: anAuthorInitials	"Browse uncommented methods whose initials (in the time-stamp, as logged to disk) match the given initials.  Present them in chronological order.  CAUTION: It will take several minutes for this to complete."	"Time millisecondsToRun: [SystemNavigation default browseUncommentedMethodsWithInitials: 'jm']"	| initials timeStamp methodReferences cm classes targetInitials |	methodReferences _ OrderedCollection new.	classes		do: [:aClass | aClass selectors do: [:sel |			cm _ aClass compiledMethodAt: sel.			timeStamp _ Utilities timeStampForMethod: cm.			timeStamp isEmpty ifFalse:				[initials _ timeStamp substrings first.				initials first isDigit ifFalse:					[(initials = targetInitials)						ifTrue:							[methodReferences add: (MethodReference new								setStandardClass: aClass 								methodSymbol: sel)]]]]].	ToolSet		browseMessageSet: methodReferences 		name: 'Uncommented methods with initials ', targetInitials		autoSelect: nil		 ! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/2/2008 23:30'!allMethodsForClass: aClass	^ aClass localSelectors collect: [ :sel | self referenceForMethod: sel ofClass: aClass ]		 ! !!PackageInfo methodsFor: 'listing' stamp: 'bf 5/4/2005 16:33'!allOverridenMethods	"search classes and meta classes"	^ Array streamContents: [:stream |		self allOverridenMethodsDo: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'enumerating' stamp: 'bf 5/4/2005 16:23'!allOverridenMethodsDo: aBlock	"search classes and meta classes"	^ ProtoObject withAllSubclassesDo: [:class | 		self overriddenMethodsInClass: class do: aBlock]! !!PackageInfo methodsFor: 'listing' stamp: 'kph 2/7/2009 17:17'!authors	"	(PackageInfo named: 'Monticello.impl') authors	"	| timeStamp aClass authors |		authors := Set new.		self classesDo: [:c | aClass := c ] methodsDo: [ :m | 				timeStamp := m timeStamp.			timeStamp isEmpty ifFalse:				[ authors add: timeStamp substrings first ].	].		^ authors! !!PackageInfo methodsFor: 'modifying' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26256173!baseCategoryOfMethod: aMethodReference	| oldCat oldPrefix tokens | 	oldCat := aMethodReference category.	({ 'as yet unclassified'. 'all' } includes: oldCat) ifTrue: [ oldCat := '' ].	tokens := oldCat findTokens: '*-' keep: '*'.	"Strip off any old prefixes"	((tokens at: 1 ifAbsent: [ '' ]) = '*') ifTrue: [		[ ((tokens at: 1 ifAbsent: [ '' ]) = '*') ]			whileTrue: [ tokens removeFirst ].		oldPrefix := tokens removeFirst asLowercase.		[ (tokens at: 1 ifAbsent: [ '' ]) asLowercase = oldPrefix ]			whileTrue: [ tokens removeFirst ].	].	tokens isEmpty ifTrue: [^ 'as yet unclassified'].	^ String streamContents:		[ :s |		tokens			do: [ :tok | s nextPutAll: tok ]			separatedBy: [ s nextPut: $- ]]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 21:37'!behaviorsNamed: aSymbol do: aBlock"Enumerates all behaviors with the given name"	| class traitClass |	class := Smalltalk at: aSymbol ifAbsent: [^ self].	class isBehavior ifTrue: [aBlock value: class. aBlock value: class class. ^ self].	traitClass := Smalltalk at: #Trait ifAbsent: [^ self].	(class isKindOf: traitClass) ifTrue: [aBlock value: class. ^ self].! !!PackageInfo methodsFor: 'modifying' stamp: 'kph 2/7/2009 17:15'!browseMethodsForAuthorInitials: authorInitials	| mr |	ToolSet		browseMessageSet: (mr := self methodsForAuthorInitials: authorInitials)		name: (self packageName, ' methods with initials ', authorInitials, '(', mr size asString ,')')		autoSelect: nil	! !!PackageInfo methodsFor: 'testing' stamp: 'pmm 1/6/2007 18:09' prior: 26258585!category: categoryName matches: prefix	| prefixSize catSize |	categoryName ifNil: [ ^false ].	catSize := categoryName size.	prefixSize := prefix size.	catSize < prefixSize ifTrue: [ ^false ].	(categoryName findString: prefix startingAt: 1 caseSensitive: false) = 1		ifFalse: [ ^false ].	^(categoryName at: prefix size + 1 ifAbsent: [ ^true ]) = $-! !!PackageInfo methodsFor: 'naming' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26257560!categoryName	|category|	category := self class category.	^ (category endsWith: '-Info')		ifTrue: [category copyUpToLast: $-]		ifFalse: [category]! !!PackageInfo methodsFor: 'testing' stamp: 'mtf 6/9/2008 20:50'!changeRecordForOverriddenMethod: aMethodReference	| position prevPos prevFileIndex thePreamble tokens sourceFilesCopy stamp method file methodCategory |	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [thePreamble := file nextChunk].		"thePreamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(thePreamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: thePreamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !!PackageInfo methodsFor: 'listing' stamp: 'kph 6/2/2008 14:55' prior: 26253087!classes 	^ self loadedClasses! !!PackageInfo methodsFor: 'listing' stamp: 'al 12/14/2005 18:06' prior: 26253357!classesAndMetaClasses	| baseClasses |	baseClasses := self classes.	^baseClasses , (baseClasses collect: [:c | c classSide])! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/15/2008 20:55'!classesAsDefinitions	^ self classes collect: [ :c | c asClassDefinition ]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 20:45'!classesDo: classBlock methodsDo: methodBlock"Enumerates all non-meta classes and all methods in the package"	self		includedClassesDo: [:class |			class isMeta ifFalse: [classBlock value: class].			self methodsInIncludedClass: class do: methodBlock]		excludedClassesDo: [:class |			self methodsInExcludedClass: class do: methodBlock]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 23:18'!classesDo: classBlock methodsDo: methodBlock displayingProgress: aString"Enumerates all non-meta classes and all methods in the package, and displays a progress bar"	| classes methods i |	(1 to: 2) do: [:ignored | ] displayingProgress: 'Collecting...'.	classes := OrderedCollection new.	methods := OrderedCollection new.	self		classesDo: [:class | classes add: class]		methodsDo: [:method | methods add: method].	aString displayProgressAt: Sensor cursorPoint		from: 1 to: classes size + methods size		during: [:bar | i := 0.			classes do: [:class | bar value: (i := i + 1). classBlock value: class].			methods do: [:method | bar value: (i := i + 1). methodBlock value: method]]! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:18' prior: 26258788!coreCategoriesForClass: aClass	^ aClass organization categories select: [:cat | (self isForeignClassExtension: cat) not]! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/15/2007 02:28' prior: 26253553!coreMethods	^ self classesAndMetaClasses gather: [:class |  self coreMethodsForClass: class]! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 14:32' prior: 26258979!coreMethodsForClass: aClass	^ (self allMethodsForClass: aClass)		difference: (self foreignExtensionMethodsForClass: aClass)  ! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:20' prior: 26259266!extensionCategoriesForClass: aClass	^ aClass organization categories select: [:cat | self isYourClassExtension: cat]! !!PackageInfo methodsFor: 'testing' stamp: 'mtf 10/3/2008 17:58'!extensionCategoriesForClass: aClass do: aBlock	^ aClass organization categories		do: [:cat | (self isYourClassExtension: cat) ifTrue: [aBlock value]]! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/10/2007 05:38' prior: 26253713!extensionClasses		"The classes that have extensions from this package"		^ self externalBehaviors reject: [:classOrTrait | (self extensionCategoriesForClass: classOrTrait) isEmpty]	 ! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/10/2007 05:39' prior: 26253906!extensionMethods	"The methods from this package which are extending other classes"		^ self externalBehaviors gather: [:classOrTrait | self extensionMethodsForClass: classOrTrait]! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/10/2004 18:28' prior: 26259452!extensionMethodsForClass: aClass	^ (self extensionCategoriesForClass: aClass)		gather: [:cat | self methodsInCategory: cat ofClass: aClass ]! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 10/18/2002 23:22' prior: 26259752!extensionMethodsFromClasses: classes	^classes		gather: [:class | self extensionMethodsForClass: class]! !!PackageInfo methodsFor: 'modifying' stamp: 'al 3/1/2006 21:42' prior: 26256958!externalBehaviors	^self externalClasses , self externalTraits! !!PackageInfo methodsFor: 'dependencies' stamp: 'ab 11/18/2002 01:16' prior: 26251160!externalCallers	^ self 		externalRefsSelect: [:literal | literal isKindOf: Symbol] 		thenCollect: [:l | l].! !!PackageInfo methodsFor: 'dependencies' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26251356!externalClasses	| myClasses |	myClasses := self classesAndMetaClasses.	^ Array streamContents:		[:s |		ProtoObject withAllSubclassesDo:			[:class |			(myClasses includes: class) ifFalse: [s nextPut: class]]]! !!PackageInfo methodsFor: 'naming' stamp: 'kph 12/7/2008 01:24'!externalFiles		| matches entries |		matches := self externalFilesMatches.		entries := (FileDirectory default entriesAsFDs) select: [ :aFD | matches anySatisfy: [ :match | match match: aFD localName ] ].	entries addAll: (entries gather: [ :aFD | aFD allEntriesAsFDs ]).	^ entries ! !!PackageInfo methodsFor: 'naming' stamp: 'kph 12/8/2008 18:58'!externalFilesExclude	^ #( '*.image' '*.changes' '*.sources' 'prefs' 'sm' 'package-cache' )! !!PackageInfo methodsFor: 'naming' stamp: 'kph 12/5/2008 23:53'!externalFilesMatches	^ self systemCategoryPrefix in: [ :prefix | 	 	{ prefix. (prefix , '.*'). (prefix , '-*'). } ]! !!PackageInfo methodsFor: 'naming' stamp: 'ab 10/16/2002 21:22' prior: 26257779!externalName	^ self packageName! !!PackageInfo methodsFor: 'dependencies' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26251656!externalRefsSelect: selBlock thenCollect: colBlock	| pkgMethods dependents refs extMethods otherClasses otherMethods classNames |	classNames := self classes collect: [:c | c name].	extMethods := self extensionMethods collect: [:mr | mr methodSymbol].	otherClasses := self externalClasses difference: self externalSubclasses.	otherMethods :=  otherClasses gather: [:c | c selectors].	pkgMethods := self methods asSet collect: [:mr | mr methodSymbol].	pkgMethods removeAllFoundIn: otherMethods.	dependents := Set new.	otherClasses do: [:c |		c selectorsAndMethodsDo:			[:sel :compiled |			(extMethods includes: sel) ifFalse: 				[refs := compiled literals select: selBlock thenCollect: colBlock.				refs do: [:ea |					((classNames includes: ea) or: [pkgMethods includes: ea])							ifTrue: [dependents add: (self referenceForMethod: sel ofClass: c) -> ea]]]]].	^ dependents! !!PackageInfo methodsFor: 'dependencies' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26252633!externalSubclasses	| pkgClasses subClasses |	pkgClasses := self classes.	subClasses := Set new.	pkgClasses do: [:c | subClasses addAll: (c allSubclasses)].	^ subClasses difference: pkgClasses! !!PackageInfo methodsFor: 'modifying' stamp: 'al 3/1/2006 22:08' prior: 26257090!externalTraits	| behaviors |		^ Array streamContents: [:s |		behaviors := self classesAndMetaClasses.		Smalltalk allTraits do: [:trait |			(behaviors includes: trait) ifFalse: [s nextPut: trait].			(behaviors includes: trait classSide) ifFalse: [s nextPut: trait classSide]]].			! !!PackageInfo methodsFor: 'dependencies' stamp: 'ab 11/18/2002 01:15' prior: 26252905!externalUsers	^ self 		externalRefsSelect: [:literal | literal isVariableBinding] 		thenCollect: [:l | l key]! !!PackageInfo methodsFor: 'listing' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26254099!foreignClasses	| s |	s := IdentitySet new.	self foreignSystemCategories		do: [:c | (SystemOrganization listAtCategoryNamed: c)				do: [:cl | 					| cls | 					cls := Smalltalk at: cl. 					s add: cls;					  add: cls class]].	^ s! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:22' prior: 26259926!foreignExtensionCategoriesForClass: aClass	^ aClass organization categories select: [:cat | self isForeignClassExtension: cat]! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:23' prior: 26260123!foreignExtensionMethodsForClass: aClass	^ (self foreignExtensionCategoriesForClass: aClass)		gather: [:cat | (aClass organization listAtCategoryNamed: cat)						  collect: [:sel | self referenceForMethod: sel ofClass: aClass]]! !!PackageInfo methodsFor: 'listing' stamp: 'ab 12/3/2002 14:34' prior: 26254406!foreignSystemCategories	^ SystemOrganization categories		reject: [:cat | self includesSystemCategory: cat] ! !!PackageInfo methodsFor: 'comparing' stamp: 'avi 10/11/2003 14:20' prior: 26250904!hash	^ packageName hash! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 14:55'!ignoreSystemCategory: categoryName	^ false! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 20:22'!includedClassesDo: includedBlock excludedClassesDo: excludedBlock"Enumerates behaviors, dividing them into included and excluded"	self		includedSystemCategoriesDo: [:cat |			(SystemOrganization listAtCategoryNamed: cat) do: [:name |				self behaviorsNamed: name do: includedBlock]]		excludedSystemCategoriesDo: [:cat |			(SystemOrganization listAtCategoryNamed: cat) do: [:name |				self behaviorsNamed: name do: excludedBlock]]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 21:37'!includedSystemCategoriesDo: includedBlock excludedSystemCategoriesDo: excludedBlock"Enumerate all system categories, dividing them into included and excluded"	SystemOrganization categories do: [:ea | (self includesSystemCategory: ea)		ifTrue: [includedBlock value: ea]		ifFalse: [excludedBlock value: ea]]! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/14/2004 13:34'!includesChangeRecord: aChangeRecord	^ aChangeRecord methodClass notNil and:		[self			includesMethodCategory: aChangeRecord category			ofClass: aChangeRecord methodClass]! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:23' prior: 26260623!includesClass: aClass	^ self includesSystemCategory: aClass theNonMetaClass category! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 7/23/2003 14:08' prior: 26260422!includesClassNamed: aClassName	^ self includesSystemCategory: ((SystemOrganization categoryOfElement: aClassName) ifNil: [^false])! !!PackageInfo methodsFor: 'testing' stamp: 'ab 12/5/2002 00:16' prior: 26261500!includesMethod: aSymbol ofClass: aClass	aClass ifNil: [^ false].	^ self		includesMethodCategory: ((aClass organization categoryOfElement: aSymbol)										ifNil: [' '])		ofClass: aClass! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 9/17/2002 00:18' prior: 26261052!includesMethodCategory: categoryName ofClass: aClass	^ (self isYourClassExtension: categoryName)		or: [(self includesClass: aClass)				and: [(self isForeignClassExtension: categoryName) not]]! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 7/23/2003 14:06' prior: 26260778!includesMethodCategory: categoryName ofClassNamed: aClass	^ (self isYourClassExtension: categoryName)		or: [(self includesClassNamed: aClass)				and: [(self isForeignClassExtension: categoryName) not]]! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/14/2002 18:06' prior: 26261316!includesMethodReference: aMethodRef	^ self includesMethod: aMethodRef methodSymbol ofClass: aMethodRef actualClass! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 14:56' prior: 26261761!includesSystemCategory: categoryName	^ (categoryName notNil and: [ self isCategory: categoryName prefixed: self systemCategoryPrefix ]) and: [ (self ignoreSystemCategory: categoryName) not ]! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 13:09'!initialize	methodCategoryPrefix := nil! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 12:40'!isCategory: categoryName matchingAny: matches 		^ matches anySatisfy: [ :match |  match match: categoryName ]! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 12:38'!isCategory: categoryName prefixed: prefix	| prefixSize catSize | 	catSize := categoryName size.	prefixSize := prefix size.	catSize < prefixSize ifTrue: [ ^false ].	(categoryName findString: prefix startingAt: 1 caseSensitive: false) = 1		ifFalse: [ ^false ].	^(categoryName at: prefix size + 1 ifAbsent: [ ^true ]) = $-! !!PackageInfo methodsFor: 'testing' stamp: 'kph 8/7/2007 16:36' prior: 26261933!isForeignClassExtension: categoryNamecategoryName isEmpty ifTrue: [ ^ false ].	^ categoryName first = $* and: [(self isYourClassExtension: categoryName) not]! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/10/2004 18:27'!isOverrideCategory: aString	^ aString endsWith: '-override'! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/10/2004 18:27' prior: 26262121!isOverrideMethod: aMethodReference	^ self isOverrideCategory: aMethodReference category! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/14/2004 13:35'!isOverrideOfYourMethod: aMethodReference	^ (self isYourClassExtension: aMethodReference category) not and:		[(self changeRecordForOverriddenMethod: aMethodReference) notNil]! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 12:37' prior: 26262276!isYourClassExtension: categoryName	^ categoryName notNil and: [self isCategory: categoryName prefixed: self methodCategoryPrefix]! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/14/2007 16:57'!loadedClasses	^(self systemCategories gather:		[:cat |		(SystemOrganization listAtCategoryNamed: cat)			collect: [:className | Smalltalk at: className]])				sortBy: [:a :b | a className <= b className]! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/14/2007 16:57'!loadedClassesAsDefinitions	^ self loadedClasses collect: [ :c | c asClassDefinition ]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 20:58'!methodCategoriesInClass: aClasscoreDo: coreBlockextensionDo: extensionBlockoverrideDo: overrideBlock"Enumerates all interesting categories in aClass. Core categories go to coreBlock. My extension categories and override categories go to extensionBlock. Foreign override categories go to overrideBlock. Foreign extension categories are ignored"	aClass organization categories do: [:cat |		(self isYourClassExtension: cat) ifTrue: [extensionBlock value: cat]			ifFalse: [(self isOverrideCategory: cat) ifTrue: [overrideBlock value: cat]				ifFalse: [(self isForeignClassExtension: cat) ifFalse: [coreBlock value: cat]]]]! !!PackageInfo methodsFor: 'naming' stamp: 'kph 6/5/2008 22:43' prior: 26257891!methodCategoryPrefix	^ methodCategoryPrefix ifNil: [methodCategoryPrefix := '*', self packageName asLowercase]! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/15/2007 02:29' prior: 26254584!methods	^ (self extensionMethods, self coreMethods) 		select: [:method | method isValid and: [(#(DoIt DoItIn:) includes: method methodSymbol) not]]! !!PackageInfo methodsFor: 'modifying' stamp: 'kph 2/7/2009 17:15'!methodsForAuthorInitials: authorInitials	"	(PackageInfo named: 'Monticello.impl') methodsForAuthorInitials: 'test'.  	"	| initials timeStamp methodReferences aClass |		methodReferences _ OrderedCollection new.		self classesDo: [:c | aClass := c ] methodsDo: [ :m | 					timeStamp := m timeStamp.			timeStamp isEmpty ifFalse:				[initials := timeStamp substrings first.				(initials = authorInitials)						ifTrue:							[ methodReferences add: m]]].		^ methodReferences	! !!PackageInfo methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 14:30'!methodsForClass: aClass pragma: pragma 	^ (Pragma allNamed: pragma in: aClass) collect: [ :each | self referenceForMethod: each selector ofClass: aClass ]! !!PackageInfo methodsFor: 'testing' stamp: 'bf 5/4/2005 16:41'!methodsInCategory: aString ofClass: aClass 	^Array streamContents: [:stream |		self methodsInCategory: aString ofClass: aClass 			do: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'enumerating' stamp: 'kph 6/2/2008 23:43'!methodsInCategory: aString ofClass: aClass do: aBlock	((aClass organization listAtCategoryNamed: aString) ifNil: [^self])		select: [ :sel | aClass includesLocalSelector: sel ]		thenDo: [:sel | aBlock value: (self referenceForMethod: sel ofClass: aClass)]			 ! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/4/2008 00:54'!methodsInClass: aClass category: aCategory do: aBlock"Enumerate the methods in the given class and category"	(aClass organization listAtCategoryNamed: aCategory) do: [:selector |		aBlock value: ((self referenceForMethod: selector ofClass: aClass) category: aCategory)]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 21:37'!methodsInExcludedClass: aClass do: aBlock"Enumerate my methods in excluded class aClass"	self methodCategoriesInClass: aClass		coreDo: 		[:cat | "nothing"]		extensionDo:	[:cat | self methodsInClass: aClass category: cat do: aBlock]		overrideDo:	[:cat | self overriddenMethodsInClass: aClass category: cat do: aBlock]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 21:37'!methodsInIncludedClass: aClass do: aBlock"Enumerate my methods in included class aClass"	self methodCategoriesInClass: aClass		coreDo: 		[:cat | self methodsInClass: aClass category: cat do: aBlock]		extensionDo:	[:cat | self methodsInClass: aClass category: cat do: aBlock]		overrideDo:	[:cat | self overriddenMethodsInClass: aClass category: cat do: aBlock]! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/17/2005 12:55'!name^ self packageName! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 10/18/2002 23:22' prior: 26262486!outsideClasses	^ProtoObject withAllSubclasses difference: self classesAndMetaClasses! !!PackageInfo methodsFor: 'listing' stamp: 'bf 5/4/2005 17:40'!overriddenMethods	^ Array streamContents: [:stream |		self overriddenMethodsDo: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'enumerating' stamp: 'bf 5/4/2005 17:39'!overriddenMethodsDo: aBlock	^ self allOverridenMethodsDo: [:ea |		(self isOverrideOfYourMethod: ea)			ifTrue: [aBlock value: ea]]! !!PackageInfo methodsFor: 'listing' stamp: 'bf 5/4/2005 16:43'!overriddenMethodsInClass: aClass	^Array streamContents: [:stream |		self overriddenMethodsInClass: aClass			do: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 21:46'!overriddenMethodsInClass: aClass category: aCategory do: aBlock"Enumerate the methods in the given class and category"	self methodsInClass: aClass category: aCategory do: [:methodRef |		(self changeRecordForOverriddenMethod: methodRef)			ifNotNilDo: [:changeRecord | aBlock value: changeRecord]]! !!PackageInfo methodsFor: 'enumerating' stamp: 'bf 5/4/2005 16:27'!overriddenMethodsInClass: aClass do: aBlock	^ self overrideCategoriesForClass: aClass do: [:cat |		self methodsInCategory: cat ofClass: aClass do: aBlock]! !!PackageInfo methodsFor: 'testing' stamp: 'bf 5/4/2005 16:44'!overrideCategoriesForClass: aClass	^Array streamContents: [:stream |		self overrideCategoriesForClass: aClass			do: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'enumerating' stamp: 'bf 5/4/2005 16:25'!overrideCategoriesForClass: aClass do: aBlock	^ aClass organization categories do: [:cat |		(self isOverrideCategory: cat) ifTrue: [aBlock value: cat]]! !!PackageInfo methodsFor: 'listing' stamp: 'nk 5/1/2004 08:40' prior: 26254818!overrideMethods	^ self extensionMethods select: [:ea | self isOverrideMethod: ea]! !!PackageInfo methodsFor: 'naming' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26258082!packageName	^ packageName ifNil: [packageName := self categoryName]! !!PackageInfo methodsFor: 'naming' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26258230!packageName: aString	packageName := aString! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 02:56'!postscriptDefault	^ StringHolder new contents:  '"below, add code to be run after the loading of this package"'  ! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 02:56'!postscriptOfRemovalDefault	^ StringHolder new contents:'"below, add code to clean up after the unloading of this package"' ! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 02:56'!preambleDefault		^ StringHolder new contents: '"below, add code to be run before the loading of this package"' ! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 02:56'!preambleOfRemovalDefault	^ StringHolder new contents: '"below, add code to prepare for the unloading of this package"'! !!PackageInfo methodsFor: 'listing' stamp: 'kph 8/3/2008 04:25'!printOn: str	super printOn: str.	str nextPut: $(; nextPutAll: self packageName; nextPut: $)! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 03:17'!propertyAt: key	properties ifNil:[ ^ nil ].		^ properties at: key ifAbsent: [ nil ]! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 03:36'!propertyAt: key ifAbsentPut: valBlock	properties ifNil:[ ^ self propertyAt: key put: valBlock ].		^ properties at: key ifAbsent: [ self propertyAt: key put: valBlock ]! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 02:41'!propertyAt: key put: value	properties ifNil:[ properties := IdentityDictionary new ].		^ properties at: key put: value! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 2/17/2009 12:01'!propertyDefaultAt: key	 | defaultSelector value |		 	defaultSelector := (key, 'Default') asSymbol.		value :=  (self respondsTo: defaultSelector) ifTrue: [ self perform: defaultSelector ] ifFalse: [ ^ nil ].				 ! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 03:20'!propertyOrDefaultAt: key	 | defaultSelector value |		(self propertyAt: key) ifNotNilDo: [ :v | ^ v ].	 	defaultSelector := (key, 'Default') asSymbol.		value :=  (self respondsTo: defaultSelector) ifTrue: [ self perform: defaultSelector ] ifFalse: [ ^ nil ].		^ self propertyAt: key put: value				 ! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:25' prior: 26262641!referenceForMethod: aSymbol ofClass: aClass	^ MethodReference new setStandardClass: aClass methodSymbol: aSymbol! !!PackageInfo methodsFor: 'registering' stamp: 'avi 11/12/2003 23:12' prior: 26258459!register	PackageOrganizer default registerPackage: self! !!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/11/2003 15:14' prior: 26257449!removeMethod: aMethodReference! !!PackageInfo methodsFor: 'listing' stamp: 'ab 11/14/2002 18:39' prior: 26254970!selectors	^ self methods collect: [:ea | ea methodSymbol]! !!PackageInfo methodsFor: 'listing' stamp: 'ab 11/11/2002 21:51' prior: 26255098!systemCategories	^ SystemOrganization categories select: [:cat | self includesSystemCategory: cat]! !!PackageInfo methodsFor: 'naming' stamp: 'ab 10/28/2002 10:38' prior: 26258343!systemCategoryPrefix	^ self packageName! !!PackageInfo methodsFor: 'modifying' stamp: 'kph 12/8/2008 02:46'!testsPackageName	^ self packageName, 'Tests'! !!PackageInfoImpl commentStamp: 'kph 6/1/2008 11:35' prior: 0!Packages named MyPackage.implIncludes Categories Except those included in PackageInfoTests:!!PackageInfoImpl class methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 14:25'!isResponsibleForName: aString^ aString endsWith: '.impl'! !!PackageInfoImpl class methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 13:04'!testCategoryMatches^ PackageInfoTests testCategoryMatches! !!PackageInfoImpl methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 13:04'!includesSystemCategory: categoryName 	^ (super includesSystemCategory: categoryName) and: [  (self isCategory: categoryName matchingAny: self class testCategoryMatches) not ]  ! !!PackageInfoImpl methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 12:56'!isYourClassExtension: categoryName	^ (super isYourClassExtension: categoryName) and: [ (self isCategory: categoryName matchingAny: self class testCategoryMatches) not  ]! !!PackageInfoImpl methodsFor: 'as yet unclassified' stamp: 'kph 6/5/2008 22:44'!methodCategoryPrefix	^ methodCategoryPrefix ifNil: [methodCategoryPrefix := '*', self systemCategoryPrefix asLowercase]! !!PackageInfoImpl methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 14:16'!systemCategoryPrefix	^ self packageName copyUpToLast: $.! !!PackageInfoImpl methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 03:52'!testsPackageName	^ self systemCategoryPrefix , '.test'! !!PackageInfoKernel commentStamp: 'kph 6/1/2008 12:18' prior: 0!Packages named MyPackage.kernelEnables the definition of a package being a subset of any other packagecontent is marked by the pragma <kernel>!!PackageInfoKernel class methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 11:50'!isResponsibleForName: aString^ aString endsWith: '.kernel'! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 14:51'!chosenMethodsForClass: aClass	^ aClass isKernelClass 		ifFalse: [ self methodsForClass: aClass pragma: #kernel ]		ifTrue: [ (self allMethodsForClass: aClass) difference: ( self methodsForClass: aClass pragma: #excludeFromKernel) ]! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 14:46'!classes ^ self loadedClasses select: [ :ea | (self chosenMethodsForClass: ea) notEmpty ]! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 14:44'!coreMethodsForClass: aClass 	^ (self chosenMethodsForClass: aClass)		difference: (self foreignExtensionMethodsForClass: aClass)  	   ! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 14:45'!extensionMethodsForClass: aClass 	^ (super extensionMethodsForClass: aClass) intersection: (self chosenMethodsForClass: aClass)! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 12:14'!kernelMethodsForClass: aClass	^ (Pragma allNamed: #kernel in: aClass) collect: [ :pragma | self referenceForMethod: pragma selector ofClass: aClass ]	 	 ! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 6/5/2008 22:44'!methodCategoryPrefix	^ methodCategoryPrefix ifNil: [methodCategoryPrefix := '*', self systemCategoryPrefix asLowercase]! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 14:01'!systemCategoryPrefix	^ self packageName copyUpToLast: $.! !!PackageInfoTests class methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 15:31'!isResponsibleForName: aString^ aString endsWith: '.test'! !!PackageInfoTests class methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 13:03'!testCategoryMatches^ #('*-Tests-*' '*-Tests') ! !!PackageInfoTests methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 12:47'!includesSystemCategory: categoryName	^ (super includesSystemCategory: categoryName) and: [ self isCategory: categoryName matchingAny: self class testCategoryMatches  ]! !!PackageInfoTests methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 12:56'!isYourClassExtension: categoryName	^ (super isYourClassExtension: categoryName) and: [ self isCategory: categoryName matchingAny: self class testCategoryMatches  ]! !!PackageInfoTests methodsFor: 'as yet unclassified' stamp: 'kph 6/5/2008 22:44'!methodCategoryPrefix	^ methodCategoryPrefix ifNil: [methodCategoryPrefix := '*', self systemCategoryPrefix asLowercase]! !!PackageInfoTests methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 14:07'!systemCategoryPrefix	^ self packageName copyUpToLast: $.! !!PackageInfoTests methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 03:35'!testsPackageName	^ nil! !!PackageInfo class methodsFor: 'packages access' stamp: 'kph 10/26/2008 00:47'!unload	self organizer unregisterPackageInfoClass: self  ! !!PackageList class methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 14:43'!initialize	TheWorldMenu registerOpenCommand: {'Package List'. {self. #open}}! !!PackageList class methodsFor: 'as yet unclassified' stamp: 'avi 10/10/2003 22:38'!open	^ self new openInWorld! !!PackageList methodsFor: 'actions' stamp: 'mtf 6/9/2008 20:53'!addPackage	| packageName |	packageName := FillInTheBlank request: 'Package name:'.	packageName isEmpty ifFalse:		[selectedPackage := self packageOrganizer registerPackageNamed: packageName.		self changed: #packageSelection]! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/10/2003 22:37'!buildList	^ PluggableListMorph		on: self		list: #packageList		selected: #packageSelection		changeSelected: #packageSelection:		menu: #packageMenu:! !!PackageList methodsFor: 'morphic' stamp: 'mtf 6/9/2008 20:54'!buildWindow	| window |	window := SystemWindow labelled: self label.	window model: self.	window addMorph: self buildList fullFrame: (LayoutFrame fractions: (0@0 corner: 1@1)).	^ window! !!PackageList methodsFor: 'morphic' stamp: 'avi 2/18/2004 00:28'!defaultBackgroundColor 	^ Color white! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 00:28'!defaultExtent	^ 200@200! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/10/2003 22:36'!label	^ 'Packages'! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 00:24'!openInWorld	self packageOrganizer addDependent: self.	self buildWindow openInWorldExtent: self defaultExtent! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 13:09'!packageContextMenu: aMenu	aMenu		addLine;		add: 'remove package' action: #removePackage;		addServices: PackageServices allServices for: selectedPackage extraLines: #()! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 00:10'!packageList	^ self packages collect: [:ea | ea packageName]! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 00:24'!packageMenu: aMenu	aMenu		defaultTarget: self;		add: 'add package' action: #addPackage.	selectedPackage ifNotNil: [self packageContextMenu: aMenu].	^ aMenu! !!PackageList methodsFor: 'actions' stamp: 'avi 10/11/2003 00:17'!packageOrganizer	^ PackageOrganizer default! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/10/2003 22:41'!packageSelection	^ self packages indexOf: selectedPackage! !!PackageList methodsFor: 'morphic' stamp: 'mtf 6/9/2008 20:54'!packageSelection: aNumber	selectedPackage := self packages at: aNumber ifAbsent: [].	self changed: #packageSelection! !!PackageList methodsFor: 'as yet unclassified' stamp: 'mtf 6/9/2008 20:55'!packages	^ packages ifNil: [packages := self packageOrganizer packageInfos asSortedCollection:									[:a :b | a packageName <= b packageName]]! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 00:15'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!PackageList methodsFor: 'actions' stamp: 'avi 10/11/2003 00:24'!removePackage	self packageOrganizer unregisterPackage: selectedPackage! !!PackageList methodsFor: 'actions' stamp: 'mtf 6/9/2008 20:55'!update: aSymbol	aSymbol = #packages ifTrue:		[packages := nil.		self changed: #packageList; changed: #packageSelection]! !!PackageOrganizer commentStamp: 'kph 12/7/2008 01:38' prior: 0!PacakgeOrganizer default explore!!PackageOrganizer class methodsFor: 'clean up' stamp: 'kph 10/25/2008 23:58'!cleanUp	self default packages copy keysAndValuesDo: [ :k :v | v class isObsolete ifTrue: [ self default packages removeKey: k ] ].	self default packageInfos do: [ :pi | 		| resp |				resp := PackageInfo classResponsibleForName: pi packageName.			(((resp = PackageInfo) not and: [ pi class ~= resp ]) or: [ pi class isObsolete ])		ifTrue: [ 			PackageOrganizer default unregisterPackageNamed: pi packageName.		].		].! !!PackageOrganizer class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26266237!default	^ default ifNil: [default := self new]! !!PackageOrganizer class methodsFor: 'as yet unclassified' stamp: 'mtf 6/3/2008 10:07'!forcefullyClearCache	"Clear out the cache dangerously. Forgets any preambles that have been defined"	default := nil! !!PackageOrganizer class methodsFor: 'as yet unclassified' stamp: 'avi 10/13/2003 15:25' prior: 26266378!new	^ self basicNew initialize! !!PackageOrganizer methodsFor: 'initializing' stamp: 'kph 10/25/2008 02:15'!clearCacheButPreservePreambles	"Remove every PI from the cache which does not have either a preamble or postscript"	| keep |	keep := self packageInfos select: [:package | (((package hasPreamble			or: [package hasPostscript])			or: [package hasPreambleOfRemoval])			or: [package hasPostscriptOfRemoval]) ].			packages := Dictionary new.		keep do: [ :p | self registerPackage: p ]! !!PackageOrganizer methodsFor: 'searching' stamp: 'kph 12/8/2008 05:46'!includesPackageNamed: aString	^ (packages at: aString ifAbsent: [ nil ]) notNil! !!PackageOrganizer methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26264131!initialize	packages := Dictionary new! !!PackageOrganizer methodsFor: 'private' stamp: 'stephane.ducasse 9/4/2008 12:51'!mostSpecificPackageIn: aCollection ifNone: aBlock	aCollection isEmpty		ifTrue: [ ^ aBlock value ].	^ (aCollection asArray		sort: [ :a :b | a packageName size > b packageName size ])		first! !!PackageOrganizer methodsFor: 'searching' stamp: 'stephane.ducasse 9/4/2008 12:50'!mostSpecificPackageOfClass: aClass	^ self mostSpecificPackageOfClass: aClass ifNone: [self noPackageFound]! !!PackageOrganizer methodsFor: 'searching' stamp: 'stephane.ducasse 9/4/2008 12:51'!mostSpecificPackageOfClass: aClass ifNone: aBlock		^ self 		mostSpecificPackageIn: (self packages select: [ :each | each includesClass: aClass ])		ifNone: aBlock! !!PackageOrganizer methodsFor: 'searching' stamp: 'stephane.ducasse 9/4/2008 12:50'!mostSpecificPackageOfMethod: aMethodReference	^ self mostSpecificPackageOfMethod: aMethodReference ifNone: [self noPackageFound]! !!PackageOrganizer methodsFor: 'searching' stamp: 'stephane.ducasse 9/4/2008 12:52'!mostSpecificPackageOfMethod: aMethodReference ifNone: aBlock	^ self  		mostSpecificPackageIn: (self packages select: [ :each | each includesMethodReference: aMethodReference ])		ifNone: aBlock! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 10/11/2003 14:21' prior: 26265037!noPackageFound	self error: 'No package found'! !!PackageOrganizer methodsFor: 'accessing' stamp: 'kph 5/30/2008 20:44'!packageInfos	^ packages values! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 11/12/2003 23:08' prior: 26265161!packageNamed: aString ifAbsent: errorBlock	^ packages at: aString ifAbsent: errorBlock! !!PackageOrganizer methodsFor: 'accessing' stamp: 'avi 11/12/2003 23:01' prior: 26263905!packageNames	^ packages keys! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 10/11/2003 14:21' prior: 26265326!packageOfClass: aClass	^ self packageOfClass: aClass ifNone: [self noPackageFound]! !!PackageOrganizer methodsFor: 'searching' stamp: 'kph 5/30/2008 20:47' prior: 26265487!packageOfClass: aClass ifNone: errorBlock	^ self packageInfos detect: [:ea | ea includesClass: aClass] ifNone: errorBlock! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 10/11/2003 14:21' prior: 26265683!packageOfMethod: aMethodReference	^ self packageOfMethod: aMethodReference ifNone: [self noPackageFound]! !!PackageOrganizer methodsFor: 'searching' stamp: 'kph 5/30/2008 20:47' prior: 26265866!packageOfMethod: aMethodReference ifNone: errorBlock	^ self packageInfos detect: [:ea | ea includesMethodReference: aMethodReference] ifNone: errorBlock! !!PackageOrganizer methodsFor: 'searching' stamp: 'nk 6/24/2004 16:02'!packageOfMethodCategory: categoryName ofClass: aClass	^self packageOfMethodCategory: categoryName ofClass: aClass ifNone: [ self noPackageFound ]! !!PackageOrganizer methodsFor: 'searching' stamp: 'kph 5/30/2008 20:47'!packageOfMethodCategory: categoryName ofClass: aClass ifNone: errorBlock	^ self packageInfos detect: [:ea | ea includesMethodCategory: categoryName ofClassNamed: aClass] ifNone: errorBlock		! !!PackageOrganizer methodsFor: 'searching' stamp: 'nk 6/24/2004 15:55'!packageOfSystemCategory: aSystemCategory	^ self packageOfSystemCategory: aSystemCategory ifNone: [ self noPackageFound ]! !!PackageOrganizer methodsFor: 'searching' stamp: 'kph 5/30/2008 20:47'!packageOfSystemCategory: aSystemCategory ifNone: errorBlock	^ self packageInfos detect: [:ea | ea includesSystemCategory: aSystemCategory] ifNone: errorBlock! !!PackageOrganizer methodsFor: 'accessing' stamp: 'kph 9/2/2008 04:53' prior: 26264012!packages	^ packages! !!PackageOrganizer methodsFor: 'registering' stamp: 'avi 11/12/2003 23:01' prior: 26264250!registerPackage: aPackageInfo	packages at: aPackageInfo packageName put: aPackageInfo.	self changed: #packages; changed: #packageNames.! !!PackageOrganizer methodsFor: 'registering' stamp: 'avi 11/12/2003 21:08' prior: 26264468!registerPackageNamed: aString	^ self registerPackage: (PackageInfo named: aString)! !!PackageOrganizer methodsFor: 'registering' stamp: 'avi 11/12/2003 23:08' prior: 26264631!unregisterPackage: aPackageInfo	packages removeKey: aPackageInfo packageName ifAbsent: [].		self changed: #packages; changed: #packageNames.! !!PackageOrganizer methodsFor: 'registering' stamp: 'kph 10/26/2008 00:46'!unregisterPackageInfoClass: aClass	self packages copy keysAndValuesDo: [ :k :v | v class = aClass ifTrue: [ self packages removeKey: k ] ]! !!PackageOrganizer methodsFor: 'registering' stamp: 'kph 5/31/2008 01:19' prior: 26264854!unregisterPackageNamed: packageName	packages removeKey: packageName ifAbsent: [].		self changed: #packages; changed: #packageNames. ! !!PackageServices class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26280764!initialize	ServiceClasses := Set new! !!PackageServices class methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 13:01' prior: 26280604!allServices	^ ServiceClasses gather: [:ea | ea services]! !!PackageServices class methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 12:59' prior: 26280894!register: aClass	ServiceClasses add: aClass! !!PackageServices class methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 12:59' prior: 26281031!unregister: aClass	ServiceClasses remove: aClass! !!PackageServices methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 14:06' prior: 26280389!seeClassSide! !!Collection methodsFor: '*packageinfo-base' stamp: 'ab 9/30/2002 19:26' prior: 18856447!gather: aBlock	^ Array streamContents:		[:stream |		self do: [:ea | stream nextPutAll: (aBlock value: ea)]]! !!Class methodsFor: '*packageinfo-base' stamp: 'kph 6/1/2008 14:18'!isKernelClass^ false ! !!Class methodsFor: '*packageinfo-base' stamp: 'kph 6/1/2008 14:48'!isSqueakOnlyClass^ false ! !!Character methodsFor: '*packageinfo-base' stamp: 'ab 5/31/2003 17:15' prior: 18447622!escapeEntities	#($< '&lt;' $> '&gt;' $& '&amp;') pairsDo:		[:k :v |		self = k ifTrue: [^ v]].	^ String with: self! !!FileDirectory methodsFor: '*packageinfo-base' stamp: 'kph 12/6/2008 02:45'!allEntriesAsFDs	^ self entriesRecursive: true on: OrderedCollection new ! !!FileDirectory methodsFor: '*packageinfo-base' stamp: 'kph 12/6/2008 02:44'!entriesAsFDs	^ self entriesRecursive: false on: OrderedCollection new ! !!FileDirectory methodsFor: '*packageinfo-base' stamp: 'kph 12/6/2008 05:47'!entriesRecursive: isRecursive on: aCollection		| aFD |			self entries do: [ :dirEntry | 			aFD := self fullNameFor: dirEntry name.		dirEntry isDirectory 			ifTrue: [ isRecursive ifTrue: [ (FileDirectory on: aFD) entriesRecursive: isRecursive on: aCollection ] ]			ifFalse: [ aCollection add: (FileDirectory on: aFD) ]	]. 	^ aCollection! !----End fileIn of a stream----!!String methodsFor: '*monticello' stamp: 'kph 5/26/2007 10:52'!displayProgress: existingBarOrNil at: aPoint from: minVal to: maxVal during: workBlock   	existingBarOrNil ifNil: [		self displayProgressAt: Sensor cursorPoint			from: minVal to: maxVal			during: workBlock.		]	ifNotNil: [ 		existingBarOrNil value: (existingBarOrNil value: #setMax) + (maxVal - minVal). 		existingBarOrNil value: self.		workBlock value: existingBarOrNil.	].! !!String methodsFor: '*monticello' stamp: 'avi 2/4/2004 14:14' prior: 31262173!extractNumber	^ ('0', self select: [:ea | ea isDigit]) asNumber! !!TimeStamp class methodsFor: '*monticello-instance creation' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 32765618!fromMethodTimeStamp: aString	| stream |	stream := ReadStream on: aString.	stream skipSeparators.	stream skipTo: Character space.	^self readFrom: stream.! !!TimeStamp class methodsFor: '*monticello-instance creation' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 32766151!readFrom: stream	| date time |	stream skipSeparators.	date := Date readFrom: stream.	stream skipSeparators.	time := Time readFrom: stream.	^self 		date: date		time: time! !!Stream methodsFor: '*monticello' stamp: 'cwp 8/9/2003 12:02' prior: 31023110!isMessageStream	^ false! !!Class methodsFor: '*monticello' stamp: 'al 3/26/2006 21:31' prior: 18548632!asClassDefinition	^ MCClassDefinition		name: self name		superclassName: self superclass name		traitComposition: self traitCompositionString		classTraitComposition: self class traitCompositionString		category: self category 		instVarNames: self instVarNames		classVarNames: self classVarNames		poolDictionaryNames: self poolDictionaryNames		classInstVarNames: self class instVarNames		type: self typeOfClass		comment: self organization classComment	 asString		commentStamp: self organization commentStamp	! !!Class methodsFor: '*monticello' stamp: 'avi 3/10/2004 13:32' prior: 18549217!classDefinitions	^ Array with: self asClassDefinition! !!Class methodsFor: '*monticello' stamp: 'ab 4/14/2003 22:30' prior: 18549338!poolDictionaryNames	^ self sharedPools collect: [:ea | self environment keyAtIdentityValue: ea]! !!Trait methodsFor: '*monticello' stamp: 'al 3/26/2006 21:44' prior: 32868047!asClassDefinition	^ MCTraitDefinition		name: self name		traitComposition: self traitCompositionString		category: self category 		comment: self organization classComment asString		commentStamp: self organization commentStamp.! !!Trait methodsFor: '*monticello' stamp: 'al 3/26/2006 21:45' prior: 32868344!classDefinitions	| definitions |	definitions := OrderedCollection with: self asClassDefinition.	(self hasClassTrait		and: [self classTrait hasTraitComposition]		and: [self classTrait traitComposition isEmpty not])			ifTrue: [definitions add: self classTrait asMCDefinition].	^definitions asArray! !!MethodReference methodsFor: '*monticello' stamp: 'ab 8/22/2003 17:55' prior: 24484227!asMethodDefinition	^ MCMethodDefinition forMethodReference: self! !!MethodReference methodsFor: '*monticello' stamp: 'ab 8/22/2003 17:58' prior: 24484519!compiledMethod	^ self actualClass compiledMethodAt: methodSymbol! !!MethodReference methodsFor: '*monticello' stamp: 'ab 8/22/2003 17:59' prior: 24484815!source	^ (self actualClass sourceCodeAt: methodSymbol) asString withSqueakLineEndings! !!MethodReference methodsFor: '*monticello' stamp: 'ab 8/22/2003 17:58' prior: 24484978!timeStamp	^ self compiledMethod timeStamp! !!PseudoClass methodsFor: '*monticello' stamp: 'bf 7/25/2005 15:50' prior: 28351178!asClassDefinition	^ MCClassDefinition		name: self name		superclassName: self superclass name		category: self category 		instVarNames: self instVarNames		classVarNames: self classVarNames asSortedCollection		poolDictionaryNames: self poolDictionaryNames		classInstVarNames: self class instVarNames		type: self typeOfClass		comment: self organization classComment	 asString		commentStamp: self organization commentStamp	! !!PseudoClass methodsFor: '*monticello-override' stamp: 'nk 2/18/2004 18:30' prior: 28351690!isMeta	^false! !!CrLfFileStream methodsFor: '*monticello' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 19355351!lineEndingConvention: aSymbol		lineEndConvention := aSymbol! !!ClassTrait methodsFor: '*monticello' stamp: 'al 3/26/2006 21:31' prior: 18700810!asMCDefinition	^MCClassTraitDefinition		baseTraitName: self baseTrait name		classTraitComposition: self traitCompositionString			! !!PseudoMetaclass methodsFor: '*monticello-override' stamp: 'nk 2/18/2004 18:30' prior: 28356678!isMeta	^true! !!MCAncestry commentStamp: '<historical>' prior: 23200497!Abstract superclass of records of ancestry.!!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:57' prior: 23200609!allAncestorsDo: aBlock	self ancestors do:		[:ea |		aBlock value: ea.		ea allAncestorsDo: aBlock]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:57' prior: 23200779!allAncestorsOnPathTo: aVersionInfo	^ MCFilteredVersionSorter new		target: aVersionInfo;		addAllVersionInfos: self ancestors;		sortedVersionInfos! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:57' prior: 23200997!ancestorString	^ String streamContents:		[:s | self ancestors do: [:ea | s nextPutAll: ea name] separatedBy: [s nextPutAll: ', ']]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:57' prior: 23201199!ancestors	^ ancestors ifNil: [#()]! !!MCAncestry methodsFor: 'ancestry' stamp: 'bf 12/22/2004 21:55' prior: 23201304!ancestorsDoWhileTrue: aBlock	self ancestors do:		[:ea |		(aBlock value: ea) ifTrue: 			[ea ancestorsDoWhileTrue: aBlock]]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 9/17/2005 16:03' prior: 23201499!breadthFirstAncestors	^ Array streamContents: [:s | self breadthFirstAncestorsDo: [:ea | s nextPut: ea]]! !!MCAncestry methodsFor: 'ancestry' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23201685!breadthFirstAncestorsDo: aBlock	| seen todo next |	seen := Set with: self.	todo := OrderedCollection with: self.	[todo isEmpty] whileFalse:		[next := todo removeFirst.		next ancestors do:			[:ea |			(seen includes: ea) ifFalse:				[aBlock value: ea.				seen add: ea.				todo add: ea]]]! !!MCAncestry methodsFor: 'ancestry' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23202518!commonAncestorWith: aNode	| commonAncestors |	commonAncestors := self commonAncestorsWith: aNode.	^ commonAncestors at: 1 ifAbsent: [nil]! !!MCAncestry methodsFor: 'ancestry' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23202062!commonAncestorsWith: aVersionInfo	| sharedAncestors mergedOrder sorter |	sorter := MCVersionSorter new						addVersionInfo: self;						addVersionInfo: aVersionInfo.	mergedOrder := sorter sortedVersionInfos.	sharedAncestors := (sorter allAncestorsOf: self) intersection: (sorter allAncestorsOf: aVersionInfo).	^ mergedOrder select: [:ea | sharedAncestors includes: ea]! !!MCAncestry methodsFor: 'ancestry' stamp: 'jrp 7/12/2004 08:16' prior: 23202728!hasAncestor: aVersionInfo	^ self		hasAncestor: aVersionInfo		alreadySeen: OrderedCollection new! !!MCAncestry methodsFor: 'ancestry' stamp: 'jrp 7/12/2004 08:16' prior: 23202896!hasAncestor: aVersionInfo alreadySeen: aList	(aList includes: self) ifTrue: [^ false].	aList add: self.	^ self = aVersionInfo or: [self ancestors anySatisfy: [:ea | ea hasAncestor: aVersionInfo alreadySeen: aList]]! !!MCAncestry methodsFor: 'initializing' stamp: 'kph 5/17/2007 05:50' prior: 23204181!initialize ! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:58' prior: 23203185!isRelatedTo: aVersionInfo	^ aVersionInfo timeStamp < self timeStamp		ifTrue: [self hasAncestor: aVersionInfo]		ifFalse: [aVersionInfo hasAncestor: self]! !!MCAncestry methodsFor: 'ancestry' stamp: 'kph 5/30/2008 21:01'!size^ self ancestors size! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 9/11/2004 15:08' prior: 23203410!stepChildren	^ stepChildren ifNil: [#()]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 9/14/2004 15:21' prior: 23203521!stepChildrenString	^ String streamContents:		[:s | self stepChildren do: [:ea | s nextPutAll: ea name] separatedBy: [s nextPutAll: ', ']]! !!MCAncestry methodsFor: 'ancestry' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23203741!topologicalAncestors	| frontier f |	^ Array streamContents:		[:s |		frontier := MCFrontier frontierOn: self.		[f := frontier frontier.		s nextPutAll: f.		frontier removeAll: f.		f isEmpty] whileFalse] ! !!MCAncestry methodsFor: 'ancestry' stamp: 'mtf 6/9/2008 20:03'!trimAfterVersionInfo: aVersionInfo	aVersionInfo = self		ifTrue: [ancestors := #()]		ifFalse:			[aVersionInfo date <= self date ifTrue:				[self ancestors do: [:ea | ea trimAfterVersionInfo: aVersionInfo]]		]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 9/17/2005 16:03' prior: 23204020!withBreadthFirstAncestors	^ (Array with: self), self breadthFirstAncestors! !!MCVersionInfo commentStamp: 'kph 6/2/2008 14:11' prior: 23590049!I am used as a handle for the UI to reference persisted versions and to obtain the relationships between versions.Some repositories only supply a filename as an initial handle, and so to realise thefull data from the repository, use #realizeFrom: aRepositoryAdds to the record of ancestry, other identifying details.Names:The defining point in the name is the 'firstDot' after the first $- (i.e. in some cases it may not actually be the first dot overall), all parts in the name are parsed relative to this. My-Package-kph.234.mcz is split into 'My-Package-kph' and '234.mcz' first. The #namePreFirstDot is split on the last $- to obtain the packgeName/author. The version is obtained upTo the last $( or $. in the second #postFirstDot portion,  this may be a uuid or, it may even contain $. as in traditional version numbering schemes.   VersionInfo does not have any notion of a file extn, whereas VersionInfoFilename does, and this is taken to be everything after the last $. PackageName - any characters including $- .Author - any characters except $- or $.Version - any characters including $- or $.Any older packages which have $- in the author/version suffix must be renamedUUID's are valid versionnumbers if $- is replcaed by $.!!MCSystemChangeSetVersionInfo class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 13:51'!on: cs	^ (self new) initializeFromCS: cs! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 14:04'!= other	^ other species = self species		and: [other csName = self csName]! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:36'!author	^ Utilities authorInitials! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:33'!csName	"Answer the value of csName"	^ csName! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:33'!csName: anObject	"Set the value of csName"	csName := anObject! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 14:03'!hash^ csName hash! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:45'!initializeFromCS: cs	csName := cs name.		message := 'System Change Set'.! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:43'!name	^ csName, '-', self author! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:37'!packageName	^ csName! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:36'!version	^ '1'! !!MCVersionInfo class methodsFor: 'as yet unclassified' stamp: 'kph 6/29/2007 03:47'!firstVersionForPackage: packageName	^ (self new) name: (packageName, '-', Utilities authorInitials, '.1')! !!MCVersionInfo class methodsFor: 'as yet unclassified' stamp: 'kph 8/1/2007 01:40'!name: vName id: id author: author 	^ self new		name: vName		id: id 		author: author	 ! !!MCVersionInfo class methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:44' prior: 23593117!name: vName id: id message: message date: date time: time author: author ancestors: ancestors	^ self 		name: vName		id: id		message: message		date: date		time: time		author: author		ancestors: ancestors		stepChildren: #()! !!MCVersionInfo class methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:43' prior: 23593437!name: vName id: id message: message date: date time: time author: author ancestors: ancestors stepChildren: stepChildren	^ self new		initializeWithName: vName		id: id		message: message		date: date		time: time		author: author		ancestors: ancestors		stepChildren: stepChildren! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'mtf 6/27/2008 22:53'!<= otherInfo	^ (self versionNumbers copyWithFirst: self packageName)		mcLessThan: (otherInfo versionNumbers copyWithFirst: otherInfo packageName)		ifEqual: [self name <= otherInfo name]! !!MCVersionInfo methodsFor: 'comparing' stamp: 'ab 7/5/2003 14:23' prior: 23591509!= other	^ other species = self species		and: [other hasID: id]! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'mtf 6/27/2008 23:08'!> otherInfo	^ (self <= otherInfo) not! !!MCVersionInfo methodsFor: 'converting' stamp: 'kph 5/17/2007 13:40' prior: 23591648!asDictionary	^ Dictionary new		at: #name put: self name;		at: #id put: self id;		at: #message put: self message;		at: #date put: self date;		at: #time put: self time;		at: #author put: self author;		at: #ancestors put: (self ancestors collect: [:a | a asDictionary]);		yourself! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 5/17/2007 03:01' prior: 23592382!author	^ author ifNil: [ self authorFromName ]		 ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 2/7/2009 18:25'!authorFromName 	 	| authorTokens out |		authorTokens := OrderedCollection new.		self nameAfterLastDashAsTokens do: [ : token |		token first isDigit ifFalse: [ authorTokens add: token ].		].	out := String streamContents: [:str | 	   authorTokens do: [ :ea | str nextPutAll: ea ; nextPut: $. ]	].	^ out allButLast ! !!MCVersionInfo methodsFor: '' stamp: 'kph 8/1/2007 12:24'!browseVersionFrom: repository	(repository versionWithInfo: self) browseFrom: repository		! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'cwp 8/1/2003 00:26' prior: 23592471!date	^ date! !!MCVersionInfo methodsFor: 'printing' stamp: 'kph 11/16/2007 23:23'!description^ self name! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 6/29/2007 06:50'!extractLeastSignificantVersionNumberPartFrom: v	| foundDigits first num |	foundDigits := nil.	first := nil.	v size to: 1 by: -1 do: [ :i | 		first ifNil: [ (v at: i) isDigit ifTrue: [ foundDigits := i	]						ifFalse: [ foundDigits ifNotNil: [ first := foundDigits ] ] ]	].	first ifNil: [ first := 1 ].	^ Array 		with: (first > 1 ifTrue: [ v copyFrom: 1 to: first -1  ] ifFalse: [ '' ])		with: (num := (v copyFrom: first to: v size) asNumber)		with: (((num := first + num asString size) > v size) ifTrue: ['']				ifFalse: [ v copyFrom: num to: v size ])  ! !!MCVersionInfo methodsFor: 'private' stamp: 'ab 7/5/2003 14:10' prior: 23592893!hasID: aUUID	^ id = aUUID! !!MCVersionInfo methodsFor: '' stamp: 'kph 8/1/2007 12:30'!hasSnapshot	^ true! !!MCVersionInfo methodsFor: 'comparing' stamp: 'ab 7/5/2003 14:09' prior: 23591422!hash	^ id hash! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'cwp 8/1/2003 00:24' prior: 23592556!id	^ id ! !!MCVersionInfo methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23591999!initializeWithName: vName id: aUUID message: aString date: aDate time: aTime author: initials ancestors: aCollection stepChildren: stepCollection	name := vName.	id := aUUID.	message := aString.	date := aDate.	time := aTime.	author := initials.	ancestors :=  aCollection.	stepChildren := stepCollection! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 5/17/2007 05:52'!isFilename	^ false! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 6/28/2008 09:39'!isUIDVersion  	self versionTokens reverse 		in: [ :vn |			((vn size > 2 and: [ vn third size = 8]) and: [ vn second size = 9 ]) ifFalse: [ ^ false ]	].	^ true! !!MCVersionInfo methodsFor: '' stamp: 'kph 12/8/2008 10:00'!loadVersionFrom: repository	(version := repository versionWithInfo: self) loadFrom: repository.		version package packageInfo propertyAt: #repository put: repository description! !!MCVersionInfo methodsFor: '' stamp: 'kph 8/1/2007 12:52'!mergeVersionFrom: repository	(repository versionWithInfo: self) mergeFrom: repository		! !!MCVersionInfo methodsFor: 'accessing' stamp: 'ab 7/12/2003 00:04' prior: 23590179!message	^ message ifNil: ['']! !!MCVersionInfo methodsFor: 'accessing' stamp: 'ab 7/11/2003 23:33' prior: 23590282!name	^ name ifNil: ['<working copy>']! !!MCVersionInfo methodsFor: 'accessing' stamp: 'kph 6/29/2007 02:44'!name: aName		name := aName! !!MCVersionInfo methodsFor: '' stamp: 'kph 8/1/2007 01:41'!name: vName id: anId author: anAuthor 	self name: vName.	id := anId.	author := anAuthor.! !!MCVersionInfo methodsFor: 'accessing' stamp: 'kph 6/2/2008 13:27'!nameAfterLastDash	^ name copyAfterLast: $- ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 6/28/2008 08:02'!nameAfterLastDashAsTokens	| stream tokens |	stream := self nameAfterLastDashUpToBracket readStream.	tokens := OrderedCollection new.	[stream atEnd] whileFalse: [				tokens add: (stream upTo: $.)	].	^ tokens! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 6/28/2008 07:38'!nameAfterLastDashUpToBracket		"version string includes the author initials and the version numbers" 		^ self nameAfterLastDash copyUpTo: $(! !!MCVersionInfo methodsFor: 'accessing' stamp: 'kph 6/2/2008 13:29'!nameBeforeLastDash	^ name copyUpToLast: $- ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 2/7/2009 18:24'!nextUIDBasedVersion		^ self class new name: (self packageName, '-', Utilities authorInitials, '.' , (self versionStringFrom: self nextUIDBasedVersionTokens)); yourself ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 2/7/2009 18:24'!nextUIDBasedVersionTokens		"The Universal ID is not a true GUID but a simpler sortable timestamp based equivalent."	 	| t count tokens |		"copyReplaceAll is more backwards compatible than replacing:with: "		tokens := self versionTokens.		count := tokens last asNumber.		t := DateAndTime now.	tokens at: (tokens size - 2) put: (t asDate printFormat: #(3 2 1 0 1 1 2)).	t := t asTime.	tokens at: (tokens size - 1) put: (t print24 reject: [ :ea | ea = $: ]), 	(t milliSecond asString padded: #left to: 3	with: $0).	tokens at: tokens size put: (count + 1) asString.		^ tokens	! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 6/28/2008 07:45'!nextVersion	|v num newVersion result  |	self isUIDVersion		ifTrue: [ ^self nextUIDBasedVersion ].	"we hunt backwards through the version string, starting at the first number we constuce thatnumber until we find a non digit. e.g. from 4.1.13b we would obtain 13."	v := self versionString.	 	result := 	self extractLeastSignificantVersionNumberPartFrom: v.		num := result second.	num = 0 ifTrue: [ " no number found"  self error: 'no version number found' ].	newVersion := result first , (num + 1) asString , result last.  	^ self copy name: (self packageName, '-', Utilities authorInitials, '.', newVersion)	 ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 7/11/2007 07:44'!nextVersionConsidering: ancestry	| v  myParts ancestorParts num | 	v := self versionString.	myParts := self extractLeastSignificantVersionNumberPartFrom: v.	num := myParts second.	ancestry ancestors do: [ :each | 			ancestorParts := each extractLeastSignificantVersionNumberPartFrom: v.			((myParts first = ancestorParts first) and: [ myParts last = ancestorParts last ]) 		ifTrue: [ num := num max: ancestorParts second ].	].  	^ self copy name: (self packageName, '-', Utilities authorInitials, '.', myParts first , (num + 1) asString , myParts last). ! !!MCVersionInfo methodsFor: 'accessing' stamp: 'kph 6/2/2008 13:29'!packageName	^ self nameBeforeLastDash! !!MCVersionInfo methodsFor: 'printing' stamp: 'ab 7/5/2003 18:00' prior: 23592722!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self name; nextPut: $)	! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 5/17/2007 05:54'!realizeFrom: aRepository	^ self ! !!MCVersionInfo methodsFor: 'accessing' stamp: 'avi 1/20/2004 16:08' prior: 23590394!summary	^ String streamContents:		[:s |		s			nextPutAll: self summaryHeader; cr; cr;			nextPutAll: self message.		]! !!MCVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:42' prior: 23590589!summaryHeader	^ String streamContents:		[:s |		s			nextPutAll: 'Name: '; nextPutAll: self name; cr.		date ifNotNil:			[s				nextPutAll: 'Author: '; nextPutAll: self author; cr;				nextPutAll: 'Time: '; nextPutAll:  self date asString, ', ', self time asString; cr].		id ifNotNil:			[s nextPutAll: 'UUID: '; nextPutAll: self id asString; cr].		s			nextPutAll: 'Ancestors: '; nextPutAll: self ancestorString.		self stepChildren isEmpty ifFalse:			[s cr; nextPutAll: 'Backported From: '; nextPutAll: self stepChildrenString].		]! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'cwp 8/1/2003 00:26' prior: 23592638!time	^ time! !!MCVersionInfo methodsFor: 'accessing' stamp: 'avi 1/22/2004 16:45' prior: 23591183!timeStamp	^ TimeStamp date: date time: time! !!MCVersionInfo methodsFor: 'accessing' stamp: 'avi 9/17/2003 11:24' prior: 23591301!timeString	^ date asString, ', ', time asString! !!MCVersionInfo methodsFor: 'accessing' stamp: 'kph 8/16/2007 18:14'!versionName	^ name! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'mtf 6/28/2008 11:02'!versionNumbers"To enable a smooth transition to more informative version numbers, we cause old, single-digit version numbers to sort prior to newer version numbers, by sorting as if old versions are 0.0.x"	| array |	array := self versionTokens collect: [ :ea | ea asInteger ].	^ array size <= 1		ifTrue: [#(0 0), array]		ifFalse: [array]	 ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 2/7/2009 18:24'!versionString		^ self versionStringFrom: self versionTokens	 ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 2/7/2009 18:24'!versionStringFrom: tokens	 	"version string includes the author initials and the version numbers" 		^ String streamContents: [:stream | tokens		do: [:ea | stream nextPutAll: ea]		separatedBy: [stream nextPut: $.]]! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'mtf 7/21/2008 21:52'!versionTokens	^ self nameAfterLastDashAsTokens select: [ :ea | ea notEmpty and: [ ea first isDigit ] ]  ! !!MCVersionInfoFilename commentStamp: 'kph 6/28/2007 23:55' prior: 0!For filenamesProject-Subcategory-author.123.mczEverything after the first $. is the version string, this allows for more variation, and is more flexible in the case of different file types and conventions, e.g. .mcm!!MCVersionInfoFilename class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 05:51'!filename: filename	"using MCVersionInfo to represent a filename"		^ (self new) 		setFilename: filename; yourself		! !!MCVersionInfoFilename methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 06:16'!= other	^ other species = self species		and: [other name = name]! !!MCVersionInfoFilename methodsFor: '' stamp: 'kph 9/28/2007 11:13'!ext 	^ name  copyAfterLast: $.! !!MCVersionInfoFilename methodsFor: '' stamp: 'kph 9/28/2007 11:13'!hasSnapshot	^ self ext = 'mcz'! !!MCVersionInfoFilename methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 06:43'!hash	^ name hash! !!MCVersionInfoFilename methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 05:53'!isFilename	^ true! !!MCVersionInfoFilename methodsFor: 'accessing' stamp: 'mtf 6/27/2008 01:18'!nameAfterLastDash	"we strip the extension and everyone else should be happy"	^ super nameAfterLastDash copyUpToLast: $. ! !!MCVersionInfoFilename methodsFor: 'accessing' stamp: 'kph 2/7/2009 18:24'!nextUIDBasedVersion		^ self class new name: (self packageName, '-', Utilities authorInitials, '.' , (self versionStringFrom: self nextUIDBasedVersionTokens), '.', self ext); yourself ! !!MCVersionInfoFilename methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 05:54'!realizeFrom: aRepository	^ aRepository realizeFullVersionInfo: self ! !!MCVersionInfoFilename methodsFor: 'accessing' stamp: 'kph 5/17/2007 05:55'!setFilename: n	name := n. ! !!MCVersionInfoFilename methodsFor: 'accessing' stamp: 'kph 1/28/2008 02:09'!versionName	"we probably dont need to but..."	^ versionName ifNil: [versionName := name copyUpToLast: $.  ] ! !!MCWorkingAncestry commentStamp: '<historical>' prior: 23620895!The interim record of ancestry for a working copy, gets merged version added to the ancestry, and is used to create the VersionInfo when the working copy becomes a version. !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'bf 11/7/2005 11:37' prior: 23621166!addAncestor: aNode	"Add aNode, remove ancestors of it, preserve original order"	| writeNode |	writeNode := true.	"Write aNode only once, replacing the first of its ancestors, or add last"	ancestors := Array streamContents: [:newAncestors |		self ancestors do: [:each |			(aNode hasAncestor: each)				ifTrue: [writeNode ifTrue: [newAncestors nextPut: aNode. writeNode := false]]				ifFalse: [newAncestors nextPut: each]].		writeNode ifTrue: [newAncestors nextPut: aNode. writeNode := false]].! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'abc 7/3/2007 22:07' prior: 23621374!addStepChild: aVersionInfo	stepChildren := self stepChildren copyWith: aVersionInfo! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'avi 10/22/2005 19:58'!date	^ Date today! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'ul 6/8/2007 01:31' prior: 23621541!infoWithName: nameString message: messageString	^ MCVersionInfo		name: nameString		id: UUID new		message: messageString		date: Date today		time: Time now		author: Utilities authorInitials		ancestors: (ancestors ifNil: [ #() ]) asArray		stepChildren: self stepChildren asArray! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:14' prior: 23621896!name	^ '<working copy>'! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:14' prior: 23622008!summary	^ 'Ancestors: ', self ancestorString! !!MCConfiguration class methodsFor: 'class initialization' stamp: 'bf 4/20/2005 17:20' prior: 23260439!initialize	"MCConfiguration initialize"	Preferences addPreference: #upgradeIsMerge		categories: #('updates') default: false 		balloonHelp: 'When upgrading packages, use merge instead of load'.! !!MCConfiguration class methodsFor: 'accessing' stamp: 'ar 5/27/2005 17:27' prior: 23260122!defaultLog	"Answer the default configuration log"	^DefaultLog! !!MCConfiguration class methodsFor: 'accessing' stamp: 'ar 5/27/2005 17:27' prior: 23260266!defaultLog: aStream	"Set the default configuration log"	DefaultLog := aStream.! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 3/24/2005 01:43' prior: 23260719!dependencyFromArray: anArray	^MCVersionDependency		package: (MCPackage named: anArray first)		info: (			MCVersionInfo			name: anArray second			id: (UUID fromString: anArray third)			message: nil			date: nil			time: nil			author: nil			ancestors: nil)! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 3/24/2005 01:44' prior: 23261062!dependencyToArray: aDependency	^ {		aDependency package name . 		aDependency versionInfo name . 		aDependency versionInfo id asString }! !!MCConfiguration class methodsFor: 'instance creation' stamp: 'bf 3/24/2005 01:51' prior: 23261727!fromArray: anArray	| configuration |	configuration := self new.	anArray pairsDo: [:key :value |		key = #repository			ifTrue: [configuration repositories add: (self repositoryFromArray: value)].		key = #dependency			ifTrue: [configuration dependencies add: (self dependencyFromArray: value)].	].	^configuration! !!MCConfiguration class methodsFor: 'converting' stamp: 'djr 7/1/2008 16:51' prior: 23261282!repositoryFromArray: anArray 	^ MCRepositoryGroup default repositories		detect: [:repo | repo description = anArray first]		ifNone: [(self seeIfRelativeDirectory: anArray first)				ifNil: [MCHttpRepository						location: anArray first						user: ''						password: '']]! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 3/24/2005 01:51' prior: 23261578!repositoryToArray: aRepository	^ {aRepository description}! !!MCConfiguration class methodsFor: 'converting' stamp: 'djr 7/1/2008 16:52'!seeIfRelativeDirectory: aPath 	| possiblePath |	possiblePath := FileDirectory				on: (FileDirectory default fullNameFor: aPath).	^ possiblePath exists		ifTrue: [MCDirectoryRepository new directory: possiblePath]		ifFalse: [ nil ]! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 3/22/2005 22:09' prior: 23253114!browse	(MCConfigurationBrowser new configuration: self) show! !!MCConfiguration methodsFor: 'faking' stamp: 'bf 3/24/2005 01:19' prior: 23254276!changes	^MCPatch operations: #()! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/21/2005 16:32' prior: 23251731!dependencies	^dependencies ifNil: [dependencies := OrderedCollection new]! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/21/2005 18:40' prior: 23251880!dependencies: aCollection	dependencies := aCollection! !!MCConfiguration methodsFor: 'private' stamp: 'kph 8/2/2007 00:01' prior: 23256157!depsSatisfying: selectBlock versionDo: verBlock displayingProgress: progressString	| repoMap count |	repoMap := Dictionary new. 	self repositories do: [:repo |		MCRepositoryGroup default addRepository: repo.		repo allVersionNames			ifEmpty: [self logWarning: 'cannot read from ', repo description]			ifNotEmptyDo: [:all | all do: [:ver | repoMap at: ver put: repo]]].	count := 0.	self dependencies do: [:dep |		| ver repo |		ver := dep versionInfo.		repo := repoMap at: ver versionName ifAbsent: [			self logError: 'Version ', ver name, ' not found in any repository'.			self logError: 'Aborting'.			^count].		(selectBlock value: dep) ifTrue: [			| new |			new := self versionNamed: ver for: dep from: repo.			new ifNil: [					self logError: 'Could not download version ', ver name, ' from ', repo description.					self logError: 'Aborting'.					^count]				ifNotNil: [					self logUpdate: dep package with: new.					ProgressNotification signal: '' extra: 'Installing ', ver name.					verBlock value: new.					count := count + 1.				]		].		dep package workingCopy repositoryGroup addRepository: repo.	] displayingProgress: progressString.	^count! !!MCConfiguration methodsFor: 'private' stamp: 'kph 8/1/2007 15:23'!diffVersionInfoFor: aDependency	| wc |	aDependency package hasWorkingCopy  ifFalse: [^nil].	wc := aDependency package workingCopy.	wc ancestors ifEmpty: [^nil].	^wc ancestors first  ! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 18:22' prior: 23252009!fileName	^ self name, '.', self writerClass extension! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 3/22/2005 10:51' prior: 23253248!fileOutOn: aStream	self writerClass fileOut: self on: aStream! !!MCConfiguration methodsFor: 'faking' stamp: 'bf 3/24/2005 01:17' prior: 23254381!info	^MCVersionInfo new! !!MCConfiguration methodsFor: 'initialize' stamp: 'ar 5/27/2005 17:28' prior: 23254482!initialize	super initialize.	log := DefaultLog.! !!MCConfiguration methodsFor: 'testing' stamp: 'bf 3/22/2005 22:56' prior: 23254605!isCacheable	^false! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 4/22/2005 17:19' prior: 23253383!load	^self depsSatisfying: [:dep | dep isCurrent not]		versionDo: [:ver | ver load]		displayingProgress: 'loading packages'! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 6/9/2005 15:58' prior: 23252138!log	^log ifNil: [Transcript]! !!MCConfiguration methodsFor: 'accessing' stamp: 'ar 4/28/2005 11:55' prior: 23252242!log: aStream	log := aStream.! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 16:07' prior: 23257638!logError: aString	self log		cr; nextPutAll: 'ERROR: ';		nextPutAll: aString; cr;		flush.! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 15:59' prior: 23257803!logUpdate: aPackage with: aVersion	self log		cr; nextPutAll: '========== ', aVersion info name, ' =========='; cr;		cr; nextPutAll: aVersion info message asString; cr;		flush.	aPackage hasWorkingCopy ifFalse: [^self].	aPackage workingCopy ancestors do: [:each |		(aVersion info hasAncestor: each)			ifTrue: [(aVersion info allAncestorsOnPathTo: each)				do: [:ver | self log cr; nextPutAll: '>>> ', ver name, ' <<<'; cr;							nextPutAll: ver message; cr; flush]]]! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 16:08' prior: 23258351!logWarning: aString	self log		cr; nextPutAll: 'WARNING: ';		nextPutAll: aString; cr;		flush.! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 4/22/2005 17:19' prior: 23253583!merge	^self depsSatisfying: [:dep | dep isFulfilledByAncestors not]		versionDo: [:ver | ver merge]		displayingProgress: 'merging packages'! !!MCConfiguration methodsFor: 'private' stamp: 'bf 5/23/2005 14:47' prior: 23258521!mustMerge: aVersion	"answer true if we have to do a full merge and false if we can simply load instead"		| pkg wc current |	(pkg := aVersion package) hasWorkingCopy ifFalse: [^false "no wc -> load"].	(wc := pkg workingCopy) modified ifTrue: [^true "modified -> merge"].	wc ancestors isEmpty ifTrue: [^true "no ancestor info -> merge"].	current := wc ancestors first.	(aVersion info hasAncestor: current) ifTrue: [^false "direct descendant of wc -> load"].	"new branch -> merge"	^true! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 18:23' prior: 23252346!name	^name! !!MCConfiguration methodsFor: 'accessing' stamp: 'kph 8/1/2007 15:01' prior: 23252432!name: aString	(aString endsWith: self writerClass extension) 		ifTrue: [ ^ name := aString allButLast: self writerClass extension size + 1 ].	name := aString! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/23/2005 17:35' prior: 23252537!repositories	^repositories ifNil: [repositories := OrderedCollection new]! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/23/2005 17:36' prior: 23252686!repositories: aCollection	repositories := aCollection! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/23/2005 00:44' prior: 23252815!summary	^String streamContents: [:stream |		self dependencies			do: [:ea | stream nextPutAll: ea versionInfo name; cr ]]! !!MCConfiguration methodsFor: 'updating' stamp: 'bf 5/23/2005 17:43' prior: 23254699!updateFromImage	self dependencies: (self dependencies collect: [:dep |		dep package hasWorkingCopy			ifTrue: [				dep package workingCopy in: [:wc |					MCVersionDependency package: wc package info: wc ancestors first]]			ifFalse: [dep]]).! !!MCConfiguration methodsFor: 'updating' stamp: 'mtf 6/28/2008 12:00' prior: 23255019!updateFromRepositories	| oldInfos newNames sortedNames newDeps |	oldInfos := self dependencies collect: [:dep | dep versionInfo].	newNames := Dictionary new.	self repositories		do: [:repo | 			ProgressNotification signal: '' extra: 'Checking ', repo description.			(repo possiblyNewerVersionsOfAnyOf: oldInfos)				do: [:newName | newNames at: newName put: repo]]		displayingProgress: 'Searching new versions'.	sortedNames := newNames keys asSortedCollection:		[:a :b | a > b ].	newDeps := OrderedCollection new.	self dependencies do: [:dep |		| newName |		newName := sortedNames			detect: [:each | each packageName = dep versionInfo packageName]			ifNone: [nil].		newDeps add: (newName			ifNil: [dep]			ifNotNil: [				| repo ver  |				repo := newNames at: newName.				ver := self versionNamed: newName for: dep from: repo.				ver ifNil: [dep]					ifNotNil: [MCVersionDependency package: ver package info: ver info]			])	] displayingProgress: 'downloading new versions'.	self dependencies: newDeps.! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 5/23/2005 15:40' prior: 23253798!upgrade	^self depsSatisfying: [:dep | dep isFulfilledByAncestors not]		versionDo: [:ver | 			(Preferences upgradeIsMerge and: [self mustMerge: ver])				ifFalse: [ver load]				ifTrue: [[ver merge]					on: MCMergeResolutionRequest do: [:request |						request merger conflicts isEmpty							ifTrue: [request resume: true]							ifFalse: [request pass]]]]		displayingProgress: 'upgrading packages'! !!MCConfiguration methodsFor: 'private' stamp: 'kph 8/2/2007 00:05' prior: 23259087!versionNamed: verInfo for: aDependency from: repo 	|  fileName ver depVersionInfo |	(repo filterFileNames: repo cachedFileNames forVersionNamed: verInfo name) ifNotEmptyDo: [:cachedNames |		fileName := cachedNames anyOne.		ProgressNotification signal: '' extra: 'Using cached ', fileName.		ver := repo versionFromFileNamed: fileName].	ver ifNil: [	 		depVersionInfo := self diffVersionInfoFor: aDependency.		(depVersionInfo notNil and: [depVersionInfo versionName ~= verInfo versionName and: [repo includesVersionNamed: depVersionInfo versionName]]) ifTrue: [			fileName := (MCDiffyVersion nameForVer: verInfo versionName  base: depVersionInfo versionName ), '.mcd'.			(repo includesVersionNamed: fileName)  			ifTrue:[ 				ProgressNotification signal: '' extra: 'Downloading ', fileName.				ver := repo versionFromFileNamed: fileName			]	]].	ver ifNil: [	 		ProgressNotification signal: '' extra: 'Downloading ', verInfo name.		ver := repo versionWithInfo: verInfo].	^ver! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 10:50' prior: 23253013!writerClass	^ MCMcmWriter ! !!MCConflict class methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:07' prior: 23283305!operation: anOperation	^ self new operation: anOperation	! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 11/10/2003 21:57' prior: 23279893!annotations	^operation ifNotNilDo: [ :op | op annotations ]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:04' prior: 23280032!applyTo: anObject	self isResolved ifFalse: [self error: 'Cannot continue until this conflict has been resolved'].	self remoteChosen ifTrue: [operation applyTo: anObject].! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23280296!chooseLocal	chooseRemote := false! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:16' prior: 23280411!chooseNewer	self isLocalNewer ifTrue: [ self chooseLocal ]		ifFalse: [ self isRemoteNewer ifTrue: [ self chooseRemote ]]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:22' prior: 23280614!chooseOlder	self isRemoteNewer ifTrue: [ self chooseLocal ]		ifFalse: [ self isLocalNewer ifTrue: [ self chooseRemote ]]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23280828!chooseRemote	chooseRemote := true! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23280954!clearChoice	chooseRemote := nil! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 11/10/2003 21:58' prior: 23281067!definition	^operation ifNotNilDo: [ :op | op definition ]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'dvf 8/10/2004 23:24' prior: 23281206!isConflict	^true! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:11' prior: 23281304!isLocalNewer	^ self localDefinition fullTimeStamp > self remoteDefinition fullTimeStamp! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:15' prior: 23281473!isRemoteNewer	^ self localDefinition fullTimeStamp < self remoteDefinition fullTimeStamp! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:02' prior: 23281641!isResolved	^ chooseRemote notNil! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:45' prior: 23281753!localChosen	^ chooseRemote notNil and: [chooseRemote not]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:10' prior: 23281890!localDefinition	^ operation baseDefinition! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:19' prior: 23282014!operation	^ operation! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23282128!operation: anOperation	operation := anOperation! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:45' prior: 23282255!remoteChosen	^ chooseRemote notNil and: [chooseRemote]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:10' prior: 23282389!remoteDefinition	^ operation targetDefinition! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 16:47' prior: 23282515!source	^ self localChosen		ifTrue: [operation fromSource]		ifFalse: [operation source]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:48' prior: 23282683!status	^ self isResolved		ifFalse: ['']		ifTrue: [self remoteChosen					ifFalse: ['L']					ifTrue: ['R']]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23282885!summary	| attribute |	attribute := 		self isResolved			ifTrue: [self remoteChosen ifTrue: [#underlined] ifFalse: [#struckOut]]			ifFalse: [#bold].	^ Text string: operation summary attribute: (TextEmphasis perform: attribute)! !!MCDefinition commentStamp: 'kph 8/1/2007 10:10' prior: 0!Notes:Given that monticello uses a binary fileOut, it is not possible to add instance vars to MCDefinition or its subclasses. With the benefit of hindsight this is a slight oversight by the original developers. It makes it almost impossible to improve this heirarchy without breaking compatibility.First of all we implement a flag which enables us to enforce MC compatibility #storeAsMC1CompatibleBinary.MCDefinition's #storeDataOn: defers to #storeMC1DataOn: which enforces a fixed number of instVars (defined in #storeMaxInstVarsForMC1 and a fixed output class even for specialized subclasses, which old MC's may not recognize.This ensures that our packages can be viewed in repositoryies by old MC implementations.For the future.1) We remove ignore any restriction upon the number of inst vars that we save, unless a class wants to imlement a specific policy of its own (MCMethodDefinition has a number of instVars which are not worth persisting). 2) We implement a properties interface in each class as best we can, we cannot implement it in MCDefinition because the format comatability has to be preserved with older MCs. So we place the instance var in subclasses of MCDefinition after their own inst vars.3) we change the loading code to not-care if when loading if finds extra instance variables. It puts the extra instance varables in the properties dictionary under #extraInstVars. Then when storing we write those extraInstVars so as to preseve the format that we were given.4) New subclasses save themselves as a known superclass with extra variables and their class name stored in property #class.Accessors to properties can be placed in MCDefinition to acceive the same effect as a local instVar. For an example see #because, used in #orphanedBecause:Other Monticellos need to implement the more tolerant #instVarAt: anInteger put: anObject in order to read our 'relaxed' format. At present I can see no other way of moving forward than to force all other monticellos to patch up!! !!MCDefinition class methodsFor: '' stamp: 'mtf 12/15/2007 03:06'!initialize	"MCDefinition initialize""for the future"	"	Preferences addPreference: #storeMC1CompatibleBinary		categories: #('monticello') default: true		balloonHelp: 'Save using MC1 compatibility, readable by older Monticello versions, but not extensible'			"	self clearInstances! !!MCClassDefinition commentStamp: 'kph 5/15/2007 19:25' prior: 0!The strategy for loading is to preload a class definiton is to merge the variables wanted by both the new and the old classes, and load this 'union' class definition.This should allow old code to continue running, and new code to be compiled.Since variable order is significant, the original order is preserved for the #preload, and changed on the #install.In the atomic #install phase, the new traitComposition and comment is switched in.In the atomic #postinstall phase the #initialize methods are run (note they have access to both the old and new class variables etc. In the postload phase the new class definition is loaded, eliminating the now redundant parts.!!MCClassDefinition class methodsFor: 'obsolete' stamp: 'ab 4/1/2003 01:22' prior: 23230506!name: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraycomment: commentString	^ self	name: nameString			superclassName: superclassString			category: categoryString 			instVarNames: ivarArray			classVarNames: cvarArray			poolDictionaryNames: poolArray			classInstVarNames: civarArray			type: #normal			comment: commentString! !!MCClassDefinition class methodsFor: 'obsolete' stamp: 'cwp 8/10/2003 16:33' prior: 23231053!name: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentString	^ self 		name: nameString		superclassName: superclassString		category: categoryString 		instVarNames: ivarArray		classVarNames: cvarArray		poolDictionaryNames: poolArray		classInstVarNames: civarArray		type: typeSymbol		comment: commentString		commentStamp: nil! !!MCClassDefinition class methodsFor: 'instance creation' stamp: 'al 10/9/2005 19:16' prior: 23228881!name: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampString	^ self instanceLike:		(self new initializeWithName: nameString					superclassName: superclassString					traitComposition: '{}'					classTraitComposition: '{}'					category: categoryString 					instVarNames: ivarArray					classVarNames: cvarArray					poolDictionaryNames: poolArray					classInstVarNames: civarArray					type: typeSymbol					comment: commentString					commentStamp: stampString)! !!MCClassDefinition class methodsFor: 'obsolete' stamp: 'ab 4/1/2003 01:22' prior: 23231632!name: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArraycomment: commentString	^ self	name: nameString			superclassName: superclassString			category: categoryString 			instVarNames: ivarArray			classVarNames: #()			poolDictionaryNames: #()			classInstVarNames: #()			comment: commentString! !!MCClassDefinition class methodsFor: 'instance creation' stamp: 'al 10/10/2005 13:58' prior: 23229631!name: nameStringsuperclassName: superclassStringtraitComposition: traitCompositionStringclassTraitComposition: classTraitCompositionStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampString		^ self instanceLike:		(self new initializeWithName: nameString					superclassName: superclassString					traitComposition: traitCompositionString					classTraitComposition: classTraitCompositionString					category: categoryString 					instVarNames: ivarArray					classVarNames: cvarArray					poolDictionaryNames: poolArray					classInstVarNames: civarArray					type: typeSymbol					comment: commentString					commentStamp: stampString)! !!MCClassDefinition methodsFor: 'visiting' stamp: 'kph 10/25/2008 02:10' prior: 23228269!= aDefinition	super = aDefinition ifFalse: [ ^ false ].	superclassName = aDefinition superclassName ifFalse: [ ^ false ].	self traitCompositionString = aDefinition traitCompositionString ifFalse: [ ^ false ].	self classTraitCompositionString = aDefinition classTraitCompositionString ifFalse: [ ^ false ].	category = aDefinition category ifFalse: [ ^ false ].	type = aDefinition type ifFalse: [ ^false ].	(variables = aDefinition variables			or: [self sortedVariables = aDefinition sortedVariables]) ifFalse: [ ^false ].	comment = aDefinition comment ifFalse: [ ^ false ].		^ true		! !!MCClassDefinition methodsFor: 'visiting' stamp: 'al 10/9/2005 19:33' prior: 23226802!accept: aVisitor	aVisitor visitClassDefinition: self.	(self hasClassInstanceVariables or: [self hasClassTraitComposition])		ifTrue: [aVisitor visitMetaclassDefinition: self].! !!MCClassDefinition methodsFor: 'accessing' stamp: 'nk 2/25/2005 09:49' prior: 23216896!actualClass	^Smalltalk classNamed: self className! !!MCClassDefinition methodsFor: 'visiting' stamp: 'kph 5/13/2007 05:13'!actualSuperclass	^Smalltalk at: self superclassName ifAbsent: [ ^self orphanedBecause: 'Missing superclass  ', self superclassName]! !!MCClassDefinition methodsFor: 'accessing' stamp: 'kph 5/13/2007 02:43'!actualThing 		^ self actualClass! !!MCClassDefinition methodsFor: 'initializing' stamp: 'cwp 7/7/2003 23:19' prior: 23220608!addVariables: aCollection ofType: aClass	variables addAll: (aCollection collect: [:var | aClass name: var asString]).! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 11/24/2002 06:23' prior: 23217025!category	^ category! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:32' prior: 23217122!classInstVarNames	^ self selectVariables: #isClassInstanceVariable! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/7/2003 23:35' prior: 23222481!classInstanceVariablesString	^ self stringForVariablesOfType: #isClassInstanceVariable! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 11/13/2002 01:52' prior: 23217267!className	^ name! !!MCClassDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:07' prior: 23217361!classTraitComposition	^classTraitComposition! !!MCClassDefinition methodsFor: 'testing' stamp: 'kph 6/5/2008 02:04'!classTraitComposition: aString	aString = '{}' ifTrue: [ ^ self ].	classTraitComposition := aString! !!MCClassDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 21:55' prior: 23217483!classTraitCompositionString	^self classTraitComposition ifNil: ['{}'].! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:33' prior: 23217631!classVarNames	^ self selectVariables: #isClassVariable! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/7/2003 23:36' prior: 23222644!classVariablesString	^ self stringForVariablesOfType: #isClassVariable! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 1/15/2003 13:42' prior: 23217763!comment	^ comment! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 8/10/2003 16:40' prior: 23217859!commentStamp	^ commentStamp! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 6/7/2008 01:35'!createUnionClassWith: obsDefinition	| newClass |		newClass :=  (MCClassBuilder new)			name: name 			inEnvironment: self actualSuperclass environment 			subclassOf: self actualSuperclass			type: type 			instanceVariableNames: (self stringForVariablesOfType: #isInstanceVariable plus: obsDefinition) 			classVariableNames:   (self stringForVariablesOfType: #isClassVariable plus: obsDefinition) 			poolDictionaries:  (self stringForVariablesOfType: #isPoolImport plus: obsDefinition) 			category: category.							newClass 		ifNotNil: [ newClass class instanceVariableNames: 						(self stringForVariablesOfType: #isClassInstanceVariable plus: obsDefinition) ].			^ newClass! !!MCClassDefinition methodsFor: 'initializing' stamp: 'cwp 8/10/2003 17:39' prior: 23220807!defaultCommentStamp	^ String new	"The version below avoids stomping on stamps already in the image	^ (Smalltalk at: name ifPresent: [:c | c organization commentStamp])		ifNil: ['']	"! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 8/2/2003 02:03' prior: 23222791!definitionString	^ String streamContents: [:stream | self printDefinitionOn: stream]! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 12/5/2002 21:24' prior: 23217964!description	^ Array with: name! !!MCClassDefinition methodsFor: 'system editor' stamp: 'mtf 10/24/2008 20:40'!edLoad: editor	| theClass |	theClass := (editor at: superclassName) subclass: name		instanceVariableNames: (self stringForVariablesOfType: #isInstanceVariable)		classVariableNames: (self stringForVariablesOfType: #isClassVariable)		poolDictionaries: (self stringForVariablesOfType: #isPoolImport)		category: category.	self hasTraitComposition ifTrue: [theClass setTraitCompositionFrom:		(Compiler evaluate: self traitCompositionString for: editor doItHost logged: false)].	theClass typeOfClass: type.	theClass class instanceVariableNames: (self stringForVariablesOfType: #isClassInstanceVariable). 	theClass classComment: comment stamp: commentStamp.	^ false "we dont need an edPostload"! !!MCClassDefinition methodsFor: 'system editor' stamp: 'mtf 6/9/2008 20:14'!edUnload: editor	(editor at: name) removeFromSystem.		^ false  "we dont need an edPostload"! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 6/5/2008 23:05'!extensions	^ self propertyAt: #tmpExtensions ifAbsent: [ self propertyAt: #tmpExtensions put: OrderedCollection new  ]! !!MCClassDefinition methodsFor: 'converting' stamp: 'mtf 10/7/2008 12:14'!fromImage	^ self actualClass ifNotNil: [self actualClass asClassDefinition]! !!MCClassDefinition methodsFor: 'testing' stamp: 'cwp 8/2/2003 02:54' prior: 23226050!hasClassInstanceVariables	^ (self selectVariables: #isClassInstanceVariable) isEmpty not! !!MCClassDefinition methodsFor: 'testing' stamp: 'kph 6/5/2008 02:40' prior: 23226214!hasClassTraitComposition	^ classTraitComposition notNil! !!MCClassDefinition methodsFor: 'testing' stamp: 'al 10/9/2005 20:13' prior: 23226356!hasComment	^ comment isEmptyOrNil not! !!MCClassDefinition methodsFor: 'testing' stamp: 'kph 6/5/2008 02:40' prior: 23226469!hasTraitComposition	^ traitComposition notNil! !!MCClassDefinition methodsFor: 'comparing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23219779!hash	| hash |	hash := String stringHash: name initialHash: 0.	hash := String stringHash: superclassName initialHash: hash.	hash := String stringHash: self traitCompositionString initialHash: hash.	hash := String stringHash: self classTraitComposition asString initialHash: hash.	hash := String stringHash: (category ifNil: ['']) initialHash: hash.	hash := String stringHash: type initialHash: hash.	variables do: [		:v |		hash := String stringHash: v name initialHash: hash.	].	^ hash! !!MCClassDefinition methodsFor: 'initializing' stamp: 'kph 5/11/2007 01:34' prior: 23224621!initializeWithName: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampStringOrNil	name := nameString asSymbol.	self setSuperclassName: superclassString.	category := categoryString.	name = #CompiledMethod ifTrue: [type := #compiledMethod] ifFalse: [type := typeSymbol].	comment := commentString withSqueakLineEndings.	commentStamp := stampStringOrNil ifNil: [self defaultCommentStamp].	variables := OrderedCollection  new.	self addVariables: ivarArray ofType: MCInstanceVariableDefinition.	self addVariables: cvarArray ofType: MCClassVariableDefinition.	self addVariables: poolArray ofType: MCPoolImportDefinition.	self addVariables: civarArray ofType: MCClassInstanceVariableDefinition.! !!MCClassDefinition methodsFor: 'initializing' stamp: 'kph 6/5/2008 02:04' prior: 23227068!initializeWithName: nameStringsuperclassName: superclassStringtraitComposition: traitCompositionStringclassTraitComposition: classTraitCompositionStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampStringOrNil	name := nameString asSymbol.	self setSuperclassName: superclassString.	self traitComposition: traitCompositionString.	self classTraitComposition:  classTraitCompositionString.	category := categoryString.	name = #CompiledMethod ifTrue: [type := #compiledMethod] ifFalse: [type := typeSymbol].	comment := commentString withSqueakLineEndings.	commentStamp := stampStringOrNil ifNil: [self defaultCommentStamp].	variables := OrderedCollection  new.	self addVariables: ivarArray ofType: MCInstanceVariableDefinition.	self addVariables: cvarArray ofType: MCClassVariableDefinition.	self addVariables: poolArray ofType: MCPoolImportDefinition.	self addVariables: civarArray ofType: MCClassInstanceVariableDefinition.! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:33' prior: 23218073!instVarNames	^ self selectVariables: #isInstanceVariable! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/7/2003 23:35' prior: 23222952!instanceVariablesString	^ self stringForVariablesOfType: #isInstanceVariable! !!MCClassDefinition methodsFor: 'testing' stamp: 'ab 12/4/2002 21:52' prior: 23226601!isClassDefinition	^ true! !!MCClassDefinition methodsFor: 'testing' stamp: 'ab 5/24/2003 13:49' prior: 23226701!isCodeDefinition	^ true! !!MCClassDefinition methodsFor: 'accessing' stamp: 'kph 5/15/2007 01:11'!isPartOfPackage: aPackageInfo or: orphanage	^ aPackageInfo includesSystemCategory: self category! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 11/24/2002 22:16' prior: 23223107!kindOfSubclass	type = #normal ifTrue: [^ ' subclass: '].	type = #words ifTrue: [^ ' variableWordSubclass: '].	type = #variable ifTrue: [^ ' variableSubclass: '].	type = #bytes ifTrue: [^ ' variableByteSubclass: '].	type = #weak ifTrue: [^ ' weakSubclass: ' ].	type = #compiledMethod ifTrue: [^ ' variableByteSubclass: ' ].	self error: 'Unrecognized class type'! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:53' prior: 23218207!poolDictionaries	^ self selectVariables: #isPoolImport! !!MCClassDefinition methodsFor: 'installing' stamp: 'mtf 6/10/2008 19:27'!postinstall 			(self createUnionClassWith: nil) 			ifNotNilDo: [ :newClass |	 					self hasTraitComposition ifTrue: [					newClass setTraitComposition: (Compiler					evaluate: self traitComposition) asTraitComposition ].			self hasClassTraitComposition ifTrue: [				newClass class setTraitComposition: (Compiler				evaluate: self classTraitComposition) asTraitComposition ].						self hasComment				ifTrue: [newClass classComment: comment stamp: commentStamp]				ifFalse: [newClass classComment: ''].				].		self extensions do: [ :ext | 		ext ensuredCreateCompiledMethod.		ext installMethod  ]! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 6/7/2008 02:58'!postloadOver: obs			self extensions do: [ :ext |  (ext postloadOver: nil).  ext compiledMethod ifNil: [ self error: 'class extension has been obsoleted' ]].  	self propertyRemoveKey: #tmpExtensions.		MCClassBuilder new doneCompiling: self actualClass.! !!MCClassDefinition methodsFor: 'installing' stamp: 'mtf 8/23/2008 15:19'!preloadOver: obsDefinition	| |		super preloadOver: obsDefinition.		obsDefinition ifNotNil: [ self removeExtensionsFrom: obsDefinition ].			"we ignore syntax errors on the first time around, postinstall should sort them out"	[ (self createUnionClassWith: obsDefinition).	   ] on: SyntaxErrorNotification	do: [ :ex |   ex isResumable ifTrue: [ ex resume: false] ]			! !!MCClassDefinition methodsFor: 'annotations' stamp: 'nk 7/24/2003 16:05' prior: 23219175!printAnnotations: requests on: aStream	"Add a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	requests do: [ :aRequest |		aRequest == #requirements ifTrue: [			self requirements do: [ :req | aStream nextPutAll: req ] separatedBy: [ aStream space ]]	] separatedBy: [ aStream space ].! !!MCClassDefinition methodsFor: 'printing' stamp: 'kph 5/21/2007 16:29'!printDefinitionAndCommentOn: stream		self printDefinitionOn: stream.		stream cr; cr; nextPutAll: 'comment:'; cr.		stream nextPutAll: self comment! !!MCClassDefinition methodsFor: 'printing' stamp: 'al 3/28/2006 23:42' prior: 23223550!printDefinitionOn: stream		stream 			nextPutAll: self superclassName;			nextPutAll: self kindOfSubclass;			nextPut: $# ;			nextPutAll: self className;			cr; tab.		self hasTraitComposition ifTrue: [			stream 				nextPutAll: 'uses: ';		 		nextPutAll: self traitCompositionString;				cr; tab ].		stream			nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString;			cr; tab;			nextPutAll: 'classVariableNames: ';			store: self classVariablesString;			cr; tab;			nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString;			cr; tab;			nextPutAll: 'category: ';			store: self category asString! !!MCClassDefinition methodsFor: 'comparing' stamp: 'ab 5/24/2003 14:12' prior: 23220352!provisions	^ Array with: name! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 10/1/2007 20:04'!removeExtensionsFrom: obsDefinition 	"For any Obsoleted Class Definitions, take all of the extension methods (in this and subclasses) and make them	into MethodAdditions to be applied later"			| cat |	obsDefinition actualClass withAllSubclassesDo: [ :theClass |	(Array with: theClass with: theClass classSide ) do: [ :behavior |		behavior selectorsAndMethodsDo: [ :selector :method |			cat := behavior organization categoryOfElement: selector.						cat ifNotNil: [ 				(cat beginsWith: '*')					ifTrue: [ self extensions add: method methodReference asMethodDefinition ] 				]			]		]	].		self extensions do:[ :each |  each unload ].! !!MCClassDefinition methodsFor: 'orphanage' stamp: 'kph 5/10/2007 23:24'!removeFromOrphanage: theOrphanage	super removeFromOrphanage: theOrphanage.		theOrphanage orphans removeAllSuchThat: [ :defn | 		defn isMethodDefinition and: [ defn className = self className ] ]! !!MCClassDefinition methodsFor: 'comparing' stamp: 'avi 2/17/2004 03:13' prior: 23220460!requirements	^ (Array with: superclassName), self poolDictionaries! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:28' prior: 23218339!selectVariables: aSelector	^ variables select: [:v | v perform: aSelector] thenCollect: [:v | v name]! !!MCClassDefinition methodsFor: 'initializing' stamp: 'kph 5/11/2007 01:32'!setSuperclassName: theName	superclassName := theName.		(theName beginsWith: 'AnObsolete') ifTrue: [ superclassName := superclassName allButFirst: 10 ].		superclassName := superclassName ifNil: ['nil'] ifNotNil: [superclassName asSymbol].! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/7/2003 23:54' prior: 23224264!sharedPoolsString	^ self stringForVariablesOfType: #isPoolImport! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 7/19/2003 18:00' prior: 23218518!sortKey	^ self className! !!MCClassDefinition methodsFor: 'accessing' stamp: 'bf 8/29/2006 11:45'!sortedVariables	"sort variables for comparison purposes"	| sorted |	sorted := variables select: [:var | var isOrderDependend].	sorted addAll: ((variables reject: [:var | var isOrderDependend])		asSortedCollection: [:a :b | a name <= b name]).	^sorted! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/10/2003 01:29' prior: 23224406!source	^ self definitionString! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 5/11/2007 14:44' prior: 23222109!stringForVariablesOfType: typeSymbol  	^ self stringForVariablesOfType: typeSymbol plus: nil! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 5/23/2007 02:58'!stringForVariablesOfType: typeSymbol plus: addToMe		| vars diff orig |		vars := self selectVariables: typeSymbol.		addToMe ifNotNil: [ 		orig := addToMe selectVariables: typeSymbol.		diff := vars difference: orig. 		vars := orig , diff.		vars := vars difference: (self superclassesExistingVariablesOfType: typeSymbol).	].	^ String streamContents:		[:stream |			vars				do: [:ea | stream nextPutAll: ea]				separatedBy: [stream space]]! !!MCClassDefinition methodsFor: 'printing' stamp: 'ab 11/16/2002 17:33' prior: 23224514!summary	^ name! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 11/13/2002 17:41' prior: 23218621!superclassName	^ superclassName! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 5/22/2007 17:27'!superclassesExistingVariablesOfType: typeSymbol  			typeSymbol = #isInstanceVariable ifTrue: [ 		^ self actualSuperclass withAllSuperclasses gather: [:cl | cl instVarNames ] 	].	 	typeSymbol = #isClassVariable ifTrue: [ 		^ self actualSuperclass withAllSuperclasses gather: [:cl | cl classVarNames ] 	].	typeSymbol = #isClassInstanceVariable ifTrue: [ 		^ self actualSuperclass withAllSuperclasses gather: [:cl | cl class instVarNames ] 	].	 	typeSymbol = #isPoolImport ifTrue: [ 		^ self actualSuperclass withAllSuperclasses gather: [:cl | cl poolDictionaryNames ] 	].  	^ Set new! !!MCClassDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:16' prior: 23218730!traitComposition	^traitComposition! !!MCClassDefinition methodsFor: 'testing' stamp: 'kph 6/5/2008 02:03'!traitComposition: aString	aString = '{}' ifTrue: [ ^ self ].	traitComposition := aString! !!MCClassDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 21:55' prior: 23218842!traitCompositionString	^self traitComposition ifNil: ['{}'].! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 11/24/2002 22:35' prior: 23218982!type	^ type! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 5/11/2007 03:10' prior: 23222364!unload	Smalltalk removeClassNamed: name.! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 11/25/2002 06:51' prior: 23219073!variables	^ variables! !!MCTraitDefinition class methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 20:28' prior: 23574164!name: classNameString traitComposition:  traitCompositionString category:  categoryString comment:  commentString commentStamp:   commentStamp	^ self instanceLike:		(self new initializeWithName: classNameString 			traitComposition:  traitCompositionString			category:  categoryString			comment:  commentString  			commentStamp:   commentStamp)! !!MCTraitDefinition methodsFor: 'visiting' stamp: 'kph 10/25/2008 02:11' prior: 23573634!= aDefinition	self flag: #traits. "Ugly we harcoded the super superclass method.  We will have to refactor the definition hierarchy"		(self isRevisionOf: aDefinition) ifFalse: [ ^ false ].	self traitCompositionString = aDefinition traitCompositionString  ifFalse: [ ^ false ].	category = aDefinition category ifFalse: [ ^ false ].	comment = aDefinition comment ifFalse: [ ^ false ].		^ true! !!MCTraitDefinition methodsFor: 'visiting' stamp: 'al 10/9/2005 20:28' prior: 23573312!accept: aVisitor	^ aVisitor visitTraitDefinition: self! !!MCTraitDefinition methodsFor: 'visiting' stamp: 'kph 5/1/2008 19:18'!classTrait	^ Smalltalk at: #Trait ifAbsent: [ self error: 'Trait''s are not available in this image' ].! !!MCTraitDefinition methodsFor: 'accessing' stamp: 'al 6/5/2006 14:05' prior: 23571023!classTraitCompositionString	^self traitComposition ifNil: ['{}'].! !!MCTraitDefinition methodsFor: 'visiting' stamp: 'kph 5/1/2008 19:17'!createTrait	^self classTrait		named: name		uses: (Compiler evaluate: self traitCompositionString)		category: category		! !!MCTraitDefinition methodsFor: 'system editor' stamp: 'mtf 10/13/2008 21:26'!edLoad: aSystemEditor	(aSystemEditor at: #Trait) named: self className		uses: (Compiler evaluate: self traitCompositionString for: aSystemEditor doItHost logged: false)		category: self category.	^ false.! !!MCTraitDefinition methodsFor: 'testing' stamp: 'al 10/9/2005 20:28' prior: 23573068!hasClassInstanceVariables	^ false! !!MCTraitDefinition methodsFor: 'testing' stamp: 'al 6/5/2006 14:13' prior: 23573178!hasTraitComposition	^self traitCompositionString ~= '{}'! !!MCTraitDefinition methodsFor: 'comparing' stamp: 'al 6/5/2006 14:14' prior: 23571278!hash	| hash |	hash := String stringHash: name initialHash: 0.	hash := String stringHash: self traitCompositionString initialHash: hash.	hash := String stringHash: (category ifNil: ['']) initialHash: hash.	^ hash! !!MCTraitDefinition methodsFor: 'initializing' stamp: 'kph 6/5/2008 02:02' prior: 23572060!initializeWithName: classNameString 	traitComposition:  traitCompositionString	category:  categoryString	comment:  commentString  	commentStamp:   commentStampString							name := classNameString asSymbol.		self traitComposition: traitCompositionString.	     category := categoryString.		comment := commentString withSqueakLineEndings.		commentStamp :=  commentStampString ifNil: [self defaultCommentStamp]! !!MCTraitDefinition methodsFor: 'installing' stamp: 'kph 8/1/2007 09:57'!install	! !!MCTraitDefinition methodsFor: 'installing' stamp: 'kph 5/13/2007 02:48'!obsoletion	^ nil! !!MCTraitDefinition methodsFor: '' stamp: 'kph 8/1/2007 09:55'!postinstall	 ! !!MCTraitDefinition methodsFor: '' stamp: 'kph 6/5/2008 22:58'!postloadOver: obs! !!MCTraitDefinition methodsFor: '' stamp: 'kph 8/1/2007 09:57'!preloadOver: obsDefinition 	self createTrait ifNotNilDo: [:trait |		self hasComment ifTrue: [trait classComment: comment stamp: commentStamp]]! !!MCTraitDefinition methodsFor: 'printing' stamp: 'al 6/5/2006 14:15' prior: 23572751!printDefinitionOn: stream	stream nextPutAll: 'Trait named: #', self className;		 cr;		 tab;		 nextPutAll: 'uses: ';		 nextPutAll: self traitCompositionString;		 cr;		 tab;		 nextPutAll: 'category: ';		 store: self category asString! !!MCTraitDefinition methodsFor: 'comparing' stamp: 'al 6/5/2006 14:13' prior: 23571571!requirements	"Assuming that traits in a composition can be identified by	testing for the first character beeing an uppercase character	(and thus not a special character such as {, # etc.)"	| tokens traitNames |	self hasTraitComposition ifFalse: [ ^Array new ].	tokens := Scanner new scanTokens: self traitComposition.	traitNames := tokens select: [:each | each first isUppercase].	^traitNames asArray! !!MCTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:29' prior: 23571166!traitComposition	^traitComposition! !!MCClassTraitDefinition class methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 20:22' prior: 23240292!baseTraitName: aString classTraitComposition: classTraitCompositionString	^self instanceLike: (		self new			initializeWithBaseTraitName: aString			classTraitComposition: classTraitCompositionString).! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 21:59' prior: 23239386!= aDefinition	^ (super = aDefinition)		and: [baseTrait = aDefinition baseTrait]		and: [self classTraitCompositionString = aDefinition classTraitCompositionString]! !!MCClassTraitDefinition methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 20:23' prior: 23239646!accept: aVisitor	^ aVisitor visitClassTraitDefinition: self.! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:23' prior: 23237845!baseTrait	^baseTrait! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 12/15/2005 11:31' prior: 23237950!className	^self baseTrait! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:23' prior: 23238058!classTraitComposition	^classTraitComposition! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/10/2005 10:12' prior: 23238188!classTraitCompositionString	^self classTraitComposition ifNil: ['{}'].! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 21:59' prior: 23238343!definitionString	^self baseTrait , ' classTrait	uses: ' , self classTraitCompositionString.! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:24' prior: 23238519!description	^Array		with: baseTrait		with: classTraitComposition! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 6/5/2006 14:04' prior: 23238667!hash	| hash |	hash := String stringHash: baseTrait initialHash: 0.	hash := String stringHash: self classTraitCompositionString initialHash: hash.	^hash! !!MCClassTraitDefinition methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23239946!initializeWithBaseTraitName: aTraitName classTraitComposition: aString	baseTrait := aTraitName.	classTraitComposition := aString.! !!MCClassTraitDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 19:47'!preloadOver: obs	super preloadOver: obs.		Compiler evaluate: self definitionString! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:24' prior: 23238905!requirements	^Array with: baseTrait! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:25' prior: 23239023!sortKey	^ self baseTrait name , '.classTrait'! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:25' prior: 23239151!source	^self definitionString! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:25' prior: 23239263!summary	^self baseTrait , ' classTrait'! !!MCDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 03:32'!cleanUp^ self clearInstances! !!MCDefinition class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23287056!clearInstances	WeakArray removeWeakDependent: Instances.	Instances := nil! !!MCDefinition class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23287231!instanceLike: aDefinition	Instances ifNil: [Instances := WeakSet new].	^ (Instances like: aDefinition) ifNil: [Instances add: aDefinition]! !!MCDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 5/19/2007 01:45'!storeAsClassForMC1^ self! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 17:59' prior: 23285490!<= other	^ self sortKey <= other sortKey! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:24' prior: 23285603!= aDefinition	^ self isRevisionOf: aDefinition! !!MCDefinition methodsFor: 'accessing' stamp: 'gvc 10/26/2006 12:17'!actualClass	"Since the targetClass call on a patch operation will fail	otherwise."		^nil! !!MCDefinition methodsFor: 'annotations' stamp: 'nk 7/24/2003 12:27' prior: 23283761!annotations	^self annotations: Preferences defaultAnnotationRequests! !!MCDefinition methodsFor: 'annotations' stamp: 'nk 7/24/2003 12:26' prior: 23283904!annotations: requests	"Answer a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	^String streamContents: [ :s | self printAnnotations: requests on: s ].! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 2/7/2009 21:12'!authorInitials		^ nil! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:30'!because	^ self propertyAt: #because ifAbsent: [ nil ]! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:31'!because: value		value ifNil: [ ^ self propertyRemoveKey: #because  ].	^ self propertyAt: #because put: value! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:14' prior: 23284796!description	self subclassResponsibility! !!MCDefinition methodsFor: 'system editor' stamp: 'kph 5/25/2007 07:13'!edLoad: editor	^ false! !!MCDefinition methodsFor: 'system editor' stamp: 'kph 12/12/2008 19:32'!edLoadFor: loader into: anEditor	^ self edLoad: anEditor! !!MCDefinition methodsFor: 'system editor' stamp: 'mtf 12/11/2008 21:16'!edPostload! !!MCDefinition methodsFor: 'system editor' stamp: 'kph 12/12/2008 19:31'!edPostloadFor: loader	^ self edPostload! !!MCDefinition methodsFor: 'system editor' stamp: 'mtf 12/11/2008 21:17'!edPostunload! !!MCDefinition methodsFor: 'system editor' stamp: 'kph 5/25/2007 09:09'!edUnload: editor	^ false! !!MCDefinition methodsFor: 'converting' stamp: 'mtf 10/7/2008 12:12'!fromImage"Answer a copy of myself, but at the version that exists in the image. Answers nil if no such version exists"	^ nil! !!MCDefinition methodsFor: 'comparing' stamp: 'nk 10/21/2003 23:18' prior: 23284909!fullTimeStamp	^TimeStamp current! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:14' prior: 23285014!hash	^ self description hash! !!MCDefinition methodsFor: 'annotations' stamp: 'kph 6/5/2008 01:39'!instVarAt: anInteger put: anObject 	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables. 	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	| |		<primitive: 74>	"Access beyond fixed fields"	"When loading in any definition classes we get called if #instVarAt:put: fails which will occur if in a future version if extra instVars have been added to theses classes, ok, so we dont know what to do with this extra data, so we can slap it into our properties dictionary just in case!!"	 'extra', anInteger asString in: [ :newName |			self class addInstVarName: newName. 	 		self instVarNamed: newName put: anObject. 	 ].		 ! !!MCDefinition methodsFor: 'installing' stamp: 'kph 5/11/2007 11:17'!install	! !!MCDefinition methodsFor: 'testing' stamp: 'ab 12/4/2002 21:51' prior: 23286449!isClassDefinition	^false! !!MCDefinition methodsFor: 'testing' stamp: 'bf 11/12/2004 14:46' prior: 23286545!isClassDefinitionExtension	"Answer true if this definition extends the regular class definition"	^false! !!MCDefinition methodsFor: 'testing' stamp: 'kph 12/6/2008 23:10'!isFileDefinition	^ false! !!MCDefinition methodsFor: 'testing' stamp: 'ab 12/4/2002 21:51' prior: 23286720!isMethodDefinition	^false! !!MCDefinition methodsFor: 'testing' stamp: 'cwp 7/11/2003 01:32' prior: 23286817!isOrganizationDefinition	^false! !!MCDefinition methodsFor: 'comparing' stamp: 'kph 5/15/2007 01:12'!isPartOfPackage: aPackageInfo or: orphanage	self subclassResponsibility	! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 12/5/2002 21:24' prior: 23285115!isRevisionOf: aDefinition	^ aDefinition description = self description! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:25' prior: 23285258!isSameRevisionAs: aDefinition	^ self = aDefinition! !!MCDefinition methodsFor: 'testing' stamp: 'kph 5/11/2007 13:23'!isUnlinkedClassDefinition	 	^false! !!MCDefinition methodsFor: 'installing' stamp: 'kph 2/7/2009 18:25' prior: 23285724!load	self preloadOver: nil.	self install.	self postinstall.	self postloadOver: nil.! !!MCDefinition methodsFor: 'installing' stamp: 'kph 5/13/2007 02:53'!manuallyObsoleted 	 	^ nil! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 5/10/2007 21:06'!orphanage	^ MCOrphanage current! !!MCDefinition methodsFor: 'orphanage' stamp: 'kph 5/15/2007 13:05'!orphanedBecause: explanation	"During installation anticipated errors result in the definiton becoming orphaned"		self because: explanation.		^ MCOrphanedNotification orphan: self signal: explanation! !!MCDefinition methodsFor: 'installing' stamp: 'kph 5/11/2007 12:43'!postinstall	! !!MCDefinition methodsFor: 'installing' stamp: 'kph 2/15/2009 23:05' prior: 23285993!postloadOver: aDefinition	! !!MCDefinition methodsFor: 'installing' stamp: 'kph 5/15/2007 19:22'!preloadOver: aDefinition	self because: nil. "clear out any previous" 	! !!MCDefinition methodsFor: 'annotations' stamp: 'nk 11/10/2003 21:46' prior: 23284359!printAnnotations: requests on: aStream	"Add a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	aStream nextPutAll: 'not yet implemented'! !!MCDefinition methodsFor: 'printing' stamp: 'kph 5/13/2007 05:43' prior: 23286185!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(', self summary, ') ' ! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:26'!propertiesInitialize	^ self instVarNamed: 'properties' put: IdentityDictionary new! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:28'!propertiesPrivate	^ self instVarNamed: 'properties'! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:29'!propertyAt: key ifAbsent: aBlock	self propertiesPrivate ifNil: [ ^ aBlock value ].	^ self propertiesPrivate at: key ifAbsent: aBlock! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:29'!propertyAt: key put: value	self propertiesPrivate ifNil: [ self propertiesInitialize ].	^ self propertiesPrivate at: key put: value.! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 22:03'!propertyRemoveKey: key	self propertiesPrivate ifNotNilDo: [ :p | p removeKey: key ifAbsent: nil. 		p isEmpty ifTrue: [ self instVarNamed: 'properties' put: nil ].	].! !!MCDefinition methodsFor: 'accessing' stamp: 'ab 5/24/2003 14:12' prior: 23283578!provisions	^ #()! !!MCDefinition methodsFor: 'testing' stamp: 'kph 6/5/2008 23:02'!readDataFrom: aDataStream size: varsOnDisk	| read theClass |		read := super readDataFrom: aDataStream size: varsOnDisk.			theClass := read propertyAt: #class ifAbsent: [ ^ read ].		theClass := Smalltalk at: theClass ifAbsent: [ ^ read ]. 		^ theClass basicNew copyFrom: read! !!MCDefinition methodsFor: 'orphanage' stamp: 'kph 5/10/2007 23:05'!removeFromOrphanage: theOrphanage	theOrphanage orphans remove: self ifAbsent: []! !!MCDefinition methodsFor: 'accessing' stamp: 'ab 5/24/2003 14:12' prior: 23283667!requirements	^ #()! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:26'!setProperties	^ self instVarNamed: 'properties'! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:04' prior: 23285381!sortKey	self subclassResponsibility ! !!MCDefinition methodsFor: 'annotations' stamp: 'kph 6/19/2008 17:31'!storeDataOn: aDataStream	"we only ignore trailing instVars that are nil" 	| lastNotNil |	self class ~= self class storeAsClassForMC1 ifTrue: [ self propertyAt: #class put: self class name ].	self propertyRemoveKey: #because.	lastNotNil := (self storeMaxInstVars to: 1 by: -1) detect: [ :n |  (self instVarAt: n) notNil ].	 	aDataStream		beginInstance: self class storeAsClassForMC1		size: lastNotNil.	1 to: lastNotNil do:		[:i | aDataStream nextPut: (self instVarAt: i)].! !!MCDefinition methodsFor: '' stamp: 'kph 6/5/2008 02:18'!storeMaxInstVars ^ self class instSize! !!MCDefinition methodsFor: 'printing' stamp: 'ab 7/19/2003 18:23' prior: 23286341!summary	self subclassResponsibility ! !!MCDefinition methodsFor: 'installing' stamp: 'ab 11/14/2002 00:08' prior: 23286107!unload! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/15/2007 09:24' prior: 23388527!initialize	self cleanUp.	Smalltalk addToShutDownList: self! !!MCMethodAfterRemovalActionDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 22:09'!isModelFor: selectorString	^ selectorString beginsWith: 'mcAfterRemoval'  ! !!MCMethodAfterRemovalActionDefinition methodsFor: 'as yet unclassified' stamp: 'kph 11/18/2007 03:55'!edPostunload 	"	this hackish method, takes our method source and evaluates it	"	| return code |		return := super edPostunload.		code :=  (source copyAfter: $  ) 	 	self class compilerClass evaluate:  code.			^ return! !!MCMethodAfterRemovalActionDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/26/2007 07:11'!edUnload 	super edUnload.		^ true! !!MCMethodAfterRemovalActionDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/26/2007 07:13'!sortKey	^ '!!', super sortKey "force to the beginning so it gets run last when unloading"! !!MCMethodAfterRemovalActionDefinition methodsFor: 'as yet unclassified' stamp: 'kph 11/18/2007 03:45'!unload 	"	this hackish method, takes our method source and evaluates it	"	| return code |		return := super unload.		code :=  (source copyAfter: $  ) 	 	self class compilerClass evaluate:  code.			^ return! !!MCMethodBeforeCommitLoadDefinition commentStamp: 'kph 5/30/2007 16:20' prior: 0!MCMethodSpecialActionDefinition !!MCMethodBeforeCommitLoadDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 22:10'!isModelFor: selectorString	^ selectorString beginsWith: 'mcOnInstall'  ! !!MCMethodBeforeCommitLoadDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2007 16:23'!edLoad: theEditor	"this hackish method, takes our method source, munges it into an anonymous block.	to which we evaluate feeding the classEditor as a parameter, enabling the package	the ability to add changes anywhere, before this method or even its class has been installed!!	"	| return code ourClassEditor |		return := super edLoad: theEditor.		ourClassEditor := theEditor at: className.		code := '[ :', (source copyAfter: $: ), ' ]'.	code at: (code indexOf: (Character cr)) put: $|.		(self class compilerClass evaluate:  code) value: ourClassEditor.			^ return! !!MCMethodBeforeCommitLoadDefinition methodsFor: 'as yet unclassified' stamp: 'kph 11/18/2007 03:42'!preloadOver: thePrevious	"this hackish method, takes our method source, munges it into an anonymous block.	to which we evaluate feeding the Class as a parameter, enabling the package	the ability to add changes anywhere,  	"	| return code ourClassEditor |		return := super preLoadOver: thePrevious.		ourClassEditor := Smalltalk at: className.		code := '[ :', (source copyAfter: $: ), ' ]'.	code at: (code indexOf: (Character cr)) put: $|.		(self class compilerClass evaluate:  code) value: ourClassEditor.			^ return! !!MCMethodBeforeCommitLoadDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/26/2007 05:20'!sortKey	^ 'zzz', super sortKey "force to the end so it gets loaded last"! !!MCMethodBeforeCommitUnloadDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 22:10'!isModelFor: selectorString	^ selectorString beginsWith: 'mcOnUninstall'  ! !!MCMethodBeforeCommitUnloadDefinition methodsFor: 'as yet unclassified' stamp: 'kph 11/18/2007 03:52'!edUnload: theEditor	"this hackish method, takes our method source, munges it into an anonymous block.	to which we evaluate feeding the classEditor as a parameter, enabling the package	the ability to add changes anywhere, before this method or even its class has been installed!!	"	| return code ourClassEditor |		return := super edUnload: theEditor.		ourClassEditor := theEditor at: className.		code := '[ :', (source copyAfter: $: ), ' ]'.	code at: (code indexOf: (Character cr)) put: $|.		(self class compilerClass evaluate:  code) value: ourClassEditor.			^ return! !!MCMethodBeforeCommitUnloadDefinition methodsFor: 'as yet unclassified' stamp: 'kph 11/18/2007 03:55'!sortKey	^ 'aaa', super sortKey "force to the beginning so it gets unloaded last"! !!MCMethodBeforeCommitUnloadDefinition methodsFor: 'as yet unclassified' stamp: 'kph 11/18/2007 03:52'!unload	"this hackish method, takes our method source, munges it into an anonymous block.	to which we evaluate feeding the Class as a parameter, enabling the package	the ability to add changes anywhere,  	"	| return code ourClassEditor |		return := super unload.		ourClassEditor := Smalltalk at: className.		code := '[ :', (source copyAfter: $: ), ' ]'.	code at: (code indexOf: (Character cr)) put: $|.		(self class compilerClass evaluate:  code) value: ourClassEditor.			^ return! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 8/2/2007 15:02' prior: 23386605!cachedDefinitions	Definitions ifNil: [Definitions := WeakIdentityKeyDictionary new.   "WeakArray addWeakDependent: Definitions" "instead we call tidyCache on (un)loading a package" ].	^ Definitions! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 18:35'!classForSelector: selectorString meta: isMeta	isMeta ifFalse: [ ^ self ].		^ self subclasses detect: [ :ea | ea isModelFor: selectorString ] ifNone: [ self ]	 ! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 17:05' prior: 23386841!className: classStringclassIsMeta: metaBooleanselector: selectorStringcategory: catStringtimeStamp: timeStringsource: sourceString	^ self instanceLike:		((self classForSelector: selectorString meta: metaBoolean) new					initializeWithClassName: classString					classIsMeta: metaBoolean					selector: selectorString					category: catString					timeStamp: timeString					source: sourceString)! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'ab 4/1/2003 01:40' prior: 23387279!className: classStringselector: selectorStringcategory: catStringtimeStamp: timeStringsource: sourceString	^ self	className: classString			classIsMeta: false			selector: selectorString			category: catString			timeStamp: timeString			source: sourceString! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 8/2/2007 15:19' prior: 23387636!forMethodReference: aMethodReference	| definition | 	definition := self cachedDefinitions at: aMethodReference compiledMethod ifAbsent: [].	(definition isNil		or: [definition selector ~= aMethodReference methodSymbol]		or: [definition className ~= aMethodReference classSymbol]		or: [definition classIsMeta ~= aMethodReference classIsMeta]		or: [definition category ~= aMethodReference category])			ifTrue: [definition := self 						className: aMethodReference classSymbol						classIsMeta: aMethodReference classIsMeta						selector: aMethodReference methodSymbol						category: aMethodReference category						timeStamp: aMethodReference timeStamp						source: aMethodReference source.					self cachedDefinitions at: aMethodReference compiledMethod put: definition].	^ definition	! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 6/2/2008 17:26'!freeSomeSpace	Definitions := nil! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 7/4/2007 16:38' prior: 23388678!shutDown		Definitions := nil.! !!MCMethodDefinition class methodsFor: 'file format' stamp: 'kph 5/19/2007 04:46'!storeAsClassForMC1^ MCMethodDefinition! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'mtf 5/8/2008 10:01'!tidyCache	Smalltalk garbageCollect.	self cachedDefinitions finalizeValues.! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'kph 10/25/2008 02:10' prior: 23381151!= aDefinition	super = aDefinition ifFalse: [ ^ false ].	aDefinition source = self source ifFalse: [ ^ false ].	aDefinition category = self category ifFalse: [ ^ false ].	aDefinition timeStamp = self timeStamp ifFalse: [ ^ false ].		^ true! !!MCMethodDefinition methodsFor: 'visiting' stamp: 'ab 7/18/2003 21:47' prior: 23386330!accept: aVisitor	^ aVisitor visitMethodDefinition: self! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'mtf 6/12/2008 23:05' prior: 23378612!actualClass	^ self actualClassIn: Smalltalk! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'mtf 6/12/2008 23:04'!actualClassIn: anEnvironment	^ theClass := anEnvironment at: className 		ifPresent: [:class | classIsMeta ifTrue: [class classSide] ifFalse: [class]]! !!MCMethodDefinition methodsFor: 'obsolete' stamp: 'kph 8/1/2007 01:02' prior: 34174410!addMethodAdditionTo: a	"dummy to enable loading into 3.10"! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'kph 2/7/2009 21:12'!authorInitials	^ self timeStamp upTo: $ .! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 11/13/2002 01:59' prior: 23378807!category	^ category! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'cwp 11/25/2002 07:26' prior: 23378907!classIsMeta	^ classIsMeta! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 11/15/2002 01:12' prior: 23379012!className	^className! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'mtf 10/8/2008 01:17'!compileMethod	methodAndNode := self actualClass 							compile: self source 							classified: self category 							notifying: requestor							trailer: self actualClass defaultMethodTrailer ifFail: [^nil].	compiledSelector := methodAndNode selector.	compiledMethod := methodAndNode method.	  ! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'kph 8/2/2007 11:19'!compiledMethod	^ compiledMethod! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'kph 10/24/2007 14:30'!compiledMethod: aCM 	compiledSelector := aCM selector.	compiledMethod := aCM.	  ! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'kph 8/2/2007 11:19'!compiledSelector	^ compiledSelector! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'kph 10/24/2007 14:33'!createCompiledMethod	"compiledSelector and selector should not be different, but just in case we use a searate instVar" 	self actualClass 		ifNil: [ ^self orphanedBecause: ('class {1} not present' format: {className}) ].			defnToInstall := self.		((self isOverrideCategory: priorMethodCategory) and: [ (self isOverrideCategory: category) not ])		ifTrue: [ "if we have been overriden, compile and add our source, then set defnToInstall to be the original"		  			defnToInstall := priorMethodOrNil.			self compileMethod ].		defnToInstall actualClass; compileMethod.						 	 ! !!MCMethodDefinition methodsFor: 'printing' stamp: 'kph 5/23/2007 00:46' prior: 23384903!description	^ Array			with: className		with: selector		with: classIsMeta! !!MCMethodDefinition methodsFor: 'system editor' stamp: 'mtf 6/12/2008 23:06'!edLoad: editor	"priorMethodOrNil := self actualClass compiledMethodAt: selector ifAbsent: [nil]."	methodAndNode := (self actualClassIn: editor)							compile: self source 							classified: self category							withStamp: timeStamp							notifying: requestor.							 	^ false "dont ask for edPostLoad, switch our notifications off not sure if needed with SystemEditor-#commit" ! !!MCMethodDefinition methodsFor: 'system editor' stamp: 'kph 10/24/2007 14:34'!edPostload		compiledMethod := self actualClass compiledMethodAt: selector ifAbsent: [ ^nil]. 	SystemChangeNotifier uniqueInstance 		doSilently: [self actualClass organization classify: selector under: category].		priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: compiledMethod selector: selector inProtocol: category class: self actualClass requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil compiledMethod to: compiledMethod selector: selector inClass: self actualClass requestor: requestor].	"The following code doesn't seem to do anything."	self actualClass instanceSide noteCompilationOf: selector meta: self actualClass isClassSide.! !!MCMethodDefinition methodsFor: 'system editor' stamp: 'mtf 6/12/2008 23:18'!edUnload: editor	(self actualClassIn: editor) removeSelector: selector.					 	^ false   "we dont need an edPostUnload"! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'mtf 6/10/2008 20:21'!ensuredCreateCompiledMethod	"Create the compiled method from my source, or from user-provided source in the event of a syntax error"	[ self createCompiledMethod ] on: SyntaxErrorNotification do: [ :ex |		"Let the user install the fixed code into the system"		ex defaultAction.		"Now fetch and use that code instead"		source := theClass sourceCodeAt: self selector ifAbsent: [^ nil].		self createCompiledMethod]! !!MCMethodDefinition methodsFor: 'converting' stamp: 'mtf 10/7/2008 12:38'!fromImage	| class |	class := self actualClass ifNil: [^ nil].	(class includesLocalSelector: selector) ifFalse: [^ nil].	^(MethodReference new setStandardClass: class methodSymbol: selector) asMethodDefinition! !!MCMethodDefinition methodsFor: 'printing' stamp: 'kph 5/24/2007 01:10' prior: 23385056!fullClassName	"Using #class selector for classes for backwards compatibility"	"The old implementation assumed that the definition is installed and refers to an existing class. This is not always the case, so we have to rely upon our self knowledge.Note if we are a trait's method we probably need more state!!"		^ self classIsMeta		ifFalse: [self className]		ifTrue: [ self isTraitMethod 					ifFalse: [ self className, ' class']					ifTrue: [ self className, ' classSide' ] ].! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'nk 10/21/2003 23:08' prior: 23379112!fullTimeStamp	^TimeStamp fromMethodTimeStamp: timeStamp! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23380518!hash	| hash |	hash := String stringHash: classIsMeta asString initialHash: 0.	hash := String stringHash: source initialHash: hash.	hash := String stringHash: category initialHash: hash.	hash := String stringHash: className initialHash: hash.	^ hash! !!MCMethodDefinition methodsFor: 'serializing' stamp: 'mtf 6/10/2008 21:48' prior: 23385556!initializeWithClassName: classStringclassIsMeta: metaBooleanselector: selectorStringcategory: catStringtimeStamp: timeStringsource: sourceString	className := classString asSymbol.	selector := selectorString asSymbol.	category :=  (catString ifNil: [ '' ]) asSymbol.	timeStamp := timeString.	classIsMeta := metaBoolean.	source := sourceString withSqueakLineEndings.	requestor := nil. "Always handle syntax errors thru SyntaxErrorNotification, never directly"! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'kph 10/24/2007 14:20'!install	compiledMethod ifNil: [ 	self protectedCreateCompiledMethod ].		compiledMethod ifNotNil: [ self installMethod ].! !!MCMethodDefinition methodsFor: 'installing' stamp: 'kph 8/6/2007 15:08'!installCompiledMethod	compiledMethod ifNil: [ ^ false ].		self actualClass addSelectorSilently: compiledSelector withMethod: compiledMethod.	 	^ true! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'kph 8/6/2007 15:10'!installMethod 	self writeSourceToLog.	self installCompiledMethod.	defnToInstall ifNil: [ ^ nil ].	self ~= defnToInstall ifTrue: [ 			defnToInstall writeSourceToLog.			defnToInstall installCompiledMethod ]! !!MCMethodDefinition methodsFor: 'testing' stamp: 'ab 5/24/2003 13:49' prior: 23385992!isCodeDefinition	^ true! !!MCMethodDefinition methodsFor: 'installing' stamp: 'avi 9/17/2003 22:27' prior: 23381405!isExtensionMethod	^ category beginsWith: '*'! !!MCMethodDefinition methodsFor: 'testing' stamp: 'kph 5/15/2007 17:19' prior: 23386091!isInitializer	^ false! !!MCMethodDefinition methodsFor: 'testing' stamp: 'ab 12/4/2002 21:52' prior: 23386227!isMethodDefinition	^true! !!MCMethodDefinition methodsFor: 'testing' stamp: 'kph 8/2/2007 13:28'!isOverrideCategory: cat 	^ cat notNil and: [ (cat beginsWith: '*') and: [cat endsWith: '-override'] ]! !!MCMethodDefinition methodsFor: 'installing' stamp: 'kph 8/2/2007 13:29' prior: 23381531!isOverrideMethod	"this oughta check the package"	^ self isOverrideCategory: category ! !!MCMethodDefinition methodsFor: 'testing' stamp: 'kph 10/25/2008 01:34'!isPartOfPackage: aPackageInfo or: orphanage	| myOrphanedClassDefiniton |	 	(aPackageInfo isYourClassExtension: self category) ifTrue: [ ^ true ].		myOrphanedClassDefiniton := orphanage orphans				detect: [ :c | c isClassDefinition and: [ c className = self className ] ] ifNone: [ ^ false ].		^ aPackageInfo includesSystemCategory: myOrphanedClassDefiniton category		! !!MCMethodDefinition methodsFor: 'printing' stamp: 'kph 5/24/2007 01:10'!isTraitMethod	"TODO support traits properly"	^ false			 ! !!MCMethodDefinition methodsFor: 'testing' stamp: 'kph 1/18/2008 10:30'!isUnloader	^ false! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'kph 5/11/2007 16:49'!logSource	 ^ true! !!MCMethodDefinition methodsFor: 'installing' stamp: 'kph 10/24/2007 14:40'!notifyObservers	SystemChangeNotifier uniqueInstance 		doSilently: [self actualClass organization classify: selector under: category].	priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: compiledMethod selector: selector inProtocol: category class: self actualClass requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil compiledMethod to: compiledMethod selector: selector inClass: self actualClass requestor: requestor].	"The following code doesn't seem to do anything."	self actualClass instanceSide noteCompilationOf: compiledSelector meta: self actualClass isClassSide.! !!MCMethodDefinition methodsFor: 'serializing' stamp: 'kph 8/2/2007 14:55'!objectForDataStream: refStrm    "nil out any compiled methods"	methodAndNode := requestor := compiledMethod := priorMethodCategory := priorMethodOrNil := compiledSelector := isInstalled := theClass := defnToInstall :=  nil.	    ^ self! !!MCMethodDefinition methodsFor: 'installing' stamp: 'mtf 6/10/2008 19:25'!postloadOver: obs	compiledMethod ifNil: [ 		  self ensuredCreateCompiledMethod.	  self installMethod	].	defnToInstall ifNotNil: [ defnToInstall notifyObservers ].! !!MCMethodDefinition methodsFor: 'installing' stamp: 'kph 10/24/2007 14:32'!preloadOver: obs	| | 	"we trap errors the first time and retry later"	super preloadOver: obs.				(obs notNil & self actualClass notNil) ifTrue: [ 			theClass := self actualClass.							priorMethodOrNil :=  self priorMethod.						priorMethodCategory := theClass organization categoryOfElement: selector  .			theClass removeSelector: obs selector 				 ].					self protectedCreateCompiledMethod.	 ! !!MCMethodDefinition methodsFor: 'annotations' stamp: 'nk 7/24/2003 16:06' prior: 23379757!printAnnotations: requests on: aStream	"Add a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	requests do: [ :aRequest |		aRequest == #timeStamp ifTrue: [ aStream nextPutAll: self timeStamp ].		aRequest == #messageCategory ifTrue: [ aStream nextPutAll: self category ].		aRequest == #requirements ifTrue: [			self requirements do: [ :req |				aStream nextPutAll: req ] separatedBy: [ aStream space ]].	] separatedBy: [ aStream space ].! !!MCMethodDefinition methodsFor: 'installing' stamp: 'kph 10/24/2007 14:28'!priorMethod	| comp |		comp :=	theClass compiledMethodAt: selector ifAbsent: [ ^nil ].			^ (comp methodReference asMethodDefinition)		compiledMethod: comp;		yourself! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'kph 5/23/2007 00:55'!protectedCreateCompiledMethod	[ self createCompiledMethod ] on: Error, SyntaxErrorNotification do: [ :ex | ]. ! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'kph 4/14/2008 14:29'!readDataFrom: aDataStream size: varsOnDisk	| read leClass |		read := super readDataFrom: aDataStream size: varsOnDisk.		read classIsMeta ifFalse: [ ^ read ].		leClass := self class classForSelector: read selector meta: true.	^ leClass new copyFrom: read	 ! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'kph 5/16/2007 05:13'!requestor	^ requestor! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'ab 5/24/2003 14:11' prior: 23380850!requirements	^ Array with: className! !!MCMethodDefinition methodsFor: 'installing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23381938!scanForPreviousVersion	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp method file methodCategory |	method := self actualClass compiledMethodAt: selector ifAbsent: [^ nil].	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		methodCategory = category ifFalse:			[methodCategory = (Smalltalk 									at: #Categorizer 									ifAbsent: [Smalltalk at: #ClassOrganizer]) 										default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: className category: methodCategory meta: classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 11/15/2002 01:11' prior: 23379462!selector	^selector! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'kph 5/10/2007 04:55' prior: 23380965!sortKey	^ self className, '.', (self classIsMeta ifTrue: ['meta'] ifFalse: ['nonmeta']), '.', self selector, '.' , self category! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 11/13/2002 01:59' prior: 23379560!source	^ source! !!MCMethodDefinition methodsFor: 'visiting' stamp: 'kph 6/19/2008 17:33'!storeDataOn: aDataStream	"we only ignore trailing instVars that are nil" 	| lastNotNil |	self propertyRemoveKey: #because.	lastNotNil := (self storeMaxInstVars to: 1 by: -1) detect: [ :n |  (self instVarAt: n) notNil ].	 	aDataStream		beginInstance: self class storeAsClassForMC1		size: lastNotNil.	1 to: lastNotNil do:		[:i | aDataStream nextPut: (self instVarAt: i)].! !!MCMethodDefinition methodsFor: 'serializing' stamp: 'kph 6/5/2008 02:43'!storeMaxInstVars^ 9! !!MCMethodDefinition methodsFor: 'printing' stamp: 'kph 8/2/2007 12:08' prior: 23385416!summary	^ self fullClassName , '>>' , selector, '{',category,'}' ! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 1/15/2003 13:42' prior: 23379654!timeStamp	^ timeStamp! !!MCMethodDefinition methodsFor: 'installing' stamp: 'kph 5/10/2007 21:15' prior: 23384580!unload	| previousVersion | 		self isOverrideMethod ifTrue: [previousVersion := self scanForPreviousVersion].	previousVersion		ifNil: [self actualClass ifNotNilDo: [:class | class removeSelector: selector]]		ifNotNil: [previousVersion fileIn] ! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'kph 8/6/2007 15:10'!writeSourceToLog	self logSource ifTrue: [		self actualClass logMethodSource: self source forMethodWithNode: methodAndNode 			inCategory: self category withStamp: timeStamp notifying: self requestor.	].! !!MCMethodExternalFieldDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 22:10'!isModelFor: selectorString	^ selectorString = 'fields'! !!MCMethodExternalFieldDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/23/2007 00:58'!postinstall 	super postinstall.		(Smalltalk at: #ExternalStructure ifPresent: [:externalStructure |			self actualClass theNonMetaClass inheritsFrom: externalStructure]) == true				 ifTrue: [ self actualClass theNonMetaClass compileFields ]				! !!MCMethodInitializerDefinition commentStamp: 'kph 1/16/2008 09:39' prior: 0!MCMethodInitializerDefinition 	is loaded as a normal method.	at #postloadOver:, it runs itself.	!!MCMethodInitializerDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 22:10'!isModelFor: selectorString	^ selectorString = 'initialize' or: [ selectorString beginsWith: 'mcAfterInstall' ] ! !!MCMethodInitializerDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/26/2007 04:51'!edLoad: editor	super edLoad: editor.		^ true		 ! !!MCMethodInitializerDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/26/2007 04:57'!edPostload		super edPostload.		self actualClass isTrait ifTrue: [ ^ self ].	 	self actualClass theNonMetaClass perform: selector.! !!MCMethodInitializerDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 17:19'!isInitializer		^ true! !!MCMethodInitializerDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 18:29'!postloadOver: old	super postloadOver: old.		self actualClass isTrait ifTrue: [ ^ self ].	 	self actualClass theNonMetaClass perform: selector.! !!MCMethodInitializerDefinition methodsFor: '' stamp: 'kph 8/2/2007 01:10'!sortKey	^ '!!!!!!initialize'   ! !!MCMethodUnloaderDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 22:10'!isModelFor: selectorString	^ selectorString = 'unload' ! !!MCMethodUnloaderDefinition methodsFor: 'as yet unclassified' stamp: 'kph 1/18/2008 10:31'!isUnloader		^ true! !!MCMethodUnloaderDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 02:53'!sortKey	^ 'ÞÞÞunload'   ! !!MCMethodUnloaderDefinition methodsFor: 'as yet unclassified' stamp: 'kph 1/18/2008 10:55'!unload	self actualClass soleInstance unload.	super unload.! !!MCFileDefinition commentStamp: 'kph 12/6/2008 02:59' prior: 0!Although we are not strictly a Script, we have similar loading behaviour!!MCFileDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:56'!cacheDir	^ FileDirectory default directoryNamed: 'package-cache'! !!MCFileDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 03:54'!freeSomeSpace	| dir |	dir := self cacheDir directoryNamed: 'files'.	dir exists ifTrue: [ dir recursiveDelete ].! !!MCFileDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 01:31'!from: aPackageInfo addTo: definitions		| trim |		trim := FileDirectory default fullName size + 1.		^ aPackageInfo externalFiles collect: [ :aFD | 		definitions add: (self path: (aFD fullName allButFirst: trim) packageName: aPackageInfo name) realize ].	! !!MCFileDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:56'!path: aString packageName: packageString	^ self instanceLike: (self new initializeWithPath: aString packageName: packageString)! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:37'!description	^ Array with: self fileSize with: self path! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/14/2008 00:31'!edLoad: editor	FileDirectory default copyFileNamed: self pathToSnapshotFull toFileNamed: self pathToOriginalFull.		^ false! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 03:02'!evaluate	self error! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:36'!fileSize	^ self propertyAt: #fileSize ifAbsent: [ ]! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:36'!fileSize: n 	^ self propertyAt: #fileSize put: n! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:55'!initializeWithPath: aString packageName: packageString	self path:aString.	"packageName := packageString"! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 2/13/2009 04:48'!install	| file |	file := self pathToOriginalFull.	(FileDirectory on: file) containingDirectory assureExistence.	FileDirectory default copyFileNamed: self pathToSnapshotFull toFileNamed: file.! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 03:00'!installScript	self error! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:09'!isFileDefinition	^ true! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:58'!path	^ self propertyAt: #path ifAbsent: [ ]! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 03:42'!path: p 	^ self propertyAt: #path put: p! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:05'!pathToOriginalFull	^ FileDirectory default fullNameFor: self path! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:04'!pathToSnapshot	^ 'files/' , self uuid asString, '/', self path.	! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:04'!pathToSnapshotFull	^ self class cacheDir fullNameFor: self pathToSnapshot ! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:40'!realize		| f1 f2 |	f1 := self pathToOriginalFull.		self fileSize: (FileDirectory on: f1) directoryEntry fileSize.		f2 := self pathToSnapshotFull.	(FileDirectory on: f2) containingDirectory assureExistence.		FileDirectory default deleteFileNamed: f2.	 	FileDirectory default copyFileNamed: f1						 toFileNamed: f2.! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 03:03'!script	self error! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 22:44'!sortKey	^ self summary! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 22:50'!source	| fs |		fs := self class cacheDir oldFileNamed: self pathToSnapshot.			[ ^ fs next: 1000 ] ensure: [ fs close ]! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:48'!summary	^ ':FILE: ', self path , ' (' , self fileSize asString , ' bytes)'! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:50'!unload		FileDirectory default deleteFileNamed: self pathToOriginalFull ! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 00:52'!uuid	^ self propertyAt: #uuid ifAbsent: [ self uuid: UUID new ]! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 00:52'!uuid: id	^ self propertyAt: #uuid put: id! !!MCMiscDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 22:31'!accept: writer! !!MCOrganizationDefinition class methodsFor: 'as yet unclassified' stamp: 'ab 7/26/2003 02:06' prior: 23409731!categories: anArray	^ self instanceLike: (self new categories: anArray)! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 18:25' prior: 23409429!= aDefinition	^ (super = aDefinition)		and: [categories = aDefinition categories]! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 21:47' prior: 23407161!accept: aVisitor	^ aVisitor visitOrganizationDefinition: self! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 5/24/2003 13:51' prior: 23407317!categories	^ categories! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23407447!categories: anArray	categories := anArray! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'kph 10/23/2008 23:00' prior: 23407595!commonPrefix	| stream |	categories isEmpty ifTrue: [^ ''].		stream := String new writeStream.	categories first keysAndValuesDo:		[:i :c |		categories do:			[:ea |			(ea at: i ifAbsent: []) = c ifFalse: [^ stream contents]].		stream nextPut: c].	^ stream contents! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'avi 9/28/2004 14:53' prior: 23407958!description	^ Array with: #organization with: self commonPrefix! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'mtf 12/11/2008 20:47'!edLoad: editor	"editor organization categories: categories."	^ true! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/12/2008 19:31'!edPostloadFor: loader	self postloadOver: (loader obsoletionFor: self)! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 7/11/2003 01:33' prior: 23408117!isOrganizationDefinition	^ true! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/22/2004 13:46' prior: 23408244!postloadOver: oldDefinition	SystemOrganization categories:		(self			reorderCategories: SystemOrganization categories			original: (oldDefinition ifNil: [#()] ifNotNil: [oldDefinition categories]))! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23408549!reorderCategories: allCategories original: oldCategories	| first |	first := allCategories detect: [:ea | categories includes: ea] ifNone: [^ allCategories].	^ 	((allCategories copyUpTo: first) copyWithoutAll: oldCategories, categories),		categories,		((allCategories copyAfter: first) copyWithoutAll: oldCategories, categories)! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 18:01' prior: 23408976!sortKey	^ '<organization>'! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/22/2003 01:14' prior: 23409097!source	^ String streamContents:		[:s |		categories do: [:ea | s nextPutAll: ea] separatedBy: [s cr]]! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 5/24/2003 13:55' prior: 23409294!summary	^ categories asArray printString! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'kph 2/17/2009 12:18'!unload	Smalltalk organization removeEmptyCategories! !!MCPostscriptDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04' prior: 23446800!scriptSelector	^ #postscript! !!MCPostscriptDefinition methodsFor: 'as yet unclassified' stamp: 'kph 2/15/2009 23:06'!postloadOver: obs	super postloadOver: obs.	self evaluate! !!MCPostscriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:16' prior: 23446526!sortKey	^ 'zzz' "force to the end so it gets loaded late"! !!MCPreambleDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04' prior: 23447322!scriptSelector	^ #preamble! !!MCPreambleDefinition methodsFor: 'as yet unclassified' stamp: 'kph 2/15/2009 23:17'!preloadOver: obs	super preloadOver: obs.	self evaluate ! !!MCRemovalPostscriptDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04' prior: 23451909!scriptSelector	^ #postscriptOfRemoval ! !!MCRemovalPostscriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:15' prior: 23451643!unload	super unload.	self evaluate! !!MCRemovalPreambleDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04' prior: 23452632!scriptSelector	^ #preambleOfRemoval! !!MCRemovalPreambleDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:14' prior: 23452211!sortKey	^ 'zzz' "force to the end so it gets unloaded early"! !!MCRemovalPreambleDefinition methodsFor: 'as yet unclassified' stamp: 'kph 2/17/2009 12:32' prior: 23452370!unload	self evaluate	super unload.! !!MCScriptDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 2/17/2009 12:12'!from: aPackageInfo addTo: definitions		| script default |	(aPackageInfo respondsTo: #propertyAt:) ifFalse: [ ^ self ].		script := (aPackageInfo propertyAt: self scriptSelector) ifNil: [ ^ self ].	default := aPackageInfo propertyDefaultAt: self scriptSelector.		script contents ~= default contents 		ifTrue: [ definitions add: (self script: script contents asString packageName: aPackageInfo name) ]! !!MCScriptDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 16:59' prior: 23484109!script: aString packageName: packageString	^ self instanceLike: (self new initializeWithScript: aString packageName: packageString)! !!MCScriptDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:00' prior: 23483971!scriptSelector	self subclassResponsibility! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 16:55' prior: 23483468!= aDefinition	^ (super = aDefinition)		and: [script = aDefinition script]! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:19' prior: 23481410!accept: aVisitor	"do nothing for now - this means it won't appear in the .st file"! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:12' prior: 23481582!description	^ Array with: packageName with: self scriptSelector! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:03' prior: 23481735!evaluate	Compiler evaluate: script! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23481870!initializeWithScript: aString packageName: packageString	script := aString.	packageName := packageString! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:11' prior: 23482065!installScript	self installScript: script! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'kph 2/15/2009 23:23' prior: 23482195!installScript: aString		self packageInfo propertyAt: self scriptSelector put: (StringHolder new contents: aString).	! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:22' prior: 23482565!packageInfo	^ PackageInfo named: packageName! !!MCScriptDefinition methodsFor: '' stamp: 'kph 2/7/2009 18:25'!preloadOver: aDefinition 	super preloadOver: aDefinition.	self installScript! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 16:54' prior: 23482699!script	^ script! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:10' prior: 23482804!scriptSelector	^ self class scriptSelector! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'bf 10/25/2005 19:05' prior: 23482936!sortKey	^ '!!', self scriptSelector "force to the front so it gets loaded first"! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04' prior: 23483106!source	^ script! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:12' prior: 23483211!summary	^ packageName, ' ', self scriptSelector! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:12' prior: 23483348!unload	self installScript: nil! !!MCUnlinkedClassDefinition commentStamp: 'kph 5/11/2007 04:32' prior: 0!When a class has its super class removed, this definition is placed in the orphanage with the responsibility of relinking the class with its superclass if it is loaded.!!MCUnlinkedClassDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:56'!class: unlinkedClass 	^ self new class: unlinkedClass name superclass: unlinkedClass superclass name	! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:27'!actualClass	^Smalltalk classNamed: self className! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/4/2008 15:07'!category	^( self actualClass ifNil: [ ^ '' ])category ifNil: [ '' ]! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:05'!class: className superclass: scName	name :=  className.	superclassName := scName! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:27'!className	^ name! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:24'!description	^ Array with: name! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:26'!hash	| hash |		hash := String stringHash: name initialHash: 0.	hash := String stringHash: superclassName initialHash: hash.	 	hash := String stringHash: self category initialHash: hash.	 	^ hash! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:33'!isClassDefinitionExtension	"Answer true if this definition extends the regular class definition"	^true! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 01:12'!isPartOfPackage: aPackageInfo or: orphanage	^ aPackageInfo includesSystemCategory: self category! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 13:22'!isUnlinkedClassDefinition	 	^true! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:35'!kindOfSubclass	^ ' subclass: '! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2008 01:23'!preloadOver: obs	super preloadOver: obs.	self actualClass superclass: ((Smalltalk classNamed: self superclassName) ifNil: [ self error: 'not ready yet']).	self actualClass superclass addSubclass: self actualClass.	self actualClass class superclass: ((Smalltalk classNamed: self superclassName) class ifNil: [ self error: 'not ready yet']).		self actualClass class superclass addSubclass: self actualClass class.		(SystemNavigation default obsoleteBehaviors	detect: [ :obsClass | 						([ obsClass nonObsoleteClass ] ifError: [ nil ]) = self actualClass ] ifNone: [ ^self ])	in: [ :obsClass | 		| metaClass |		metaClass := obsClass metaclass.		self actualClass updateInstancesFrom: obsClass. 		obsClass becomeForward: self actualClass.		metaClass becomeForward: self actualClass class ].	(SystemNavigation default obsoleteBehaviors select: [ :c | c isMeta not ])	do: [ :obsClass | 		| metaClass |		metaClass := obsClass metaclass.		self actualClass updateInstancesFrom: obsClass. 		obsClass becomeForward: self actualClass.		metaClass becomeForward: self actualClass class ]		 ! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/22/2007 01:52'!printDefinitionAndCommentOn: stream		self printDefinitionOn: stream.	  ! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:40'!printDefinitionOn: stream		stream 			nextPutAll: '"Class has an obsolete superclass, will relink..."';			cr; cr;			nextPutAll: self superclassName;			nextPutAll: self kindOfSubclass;			nextPut: $# ;			nextPutAll: self className			 ! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:55'!requirements	^ (Array with: superclassName) ! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:27'!sortKey	^ self className! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:29'!summary	^ name! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:37'!superclassName	^ superclassName! !!MCDefinitionIndex class methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:29' prior: 23288788!definitions: aCollection	^ self new addAll: aCollection! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:38' prior: 23287754!add: aDefinition	definitions at: aDefinition description put: aDefinition! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:38' prior: 23287611!addAll: aCollection	aCollection do: [:ea | self add: ea]! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23287927!definitionLike: aDefinition ifPresent: foundBlock ifAbsent: errorBlock	| definition |	definition := definitions at: aDefinition description ifAbsent: [].	^ definition		ifNil: errorBlock		ifNotNil: [foundBlock value: definition]! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:42' prior: 23288245!definitions	^ definitions values! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23288377!initialize	definitions := Dictionary new! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:40' prior: 23288504!remove: aDefinition	definitions removeKey: aDefinition description ifAbsent: []! !!MCImageBackedDefinitionIndex commentStamp: '<historical>' prior: 0!When using definitionLike: ... I go to the image before giving up!!MCImageBackedDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'mtf 10/7/2008 13:43'!definitionLike: aDefinition ifPresent: foundBlock ifAbsent: errorBlock	| definition |	^ super definitionLike: aDefinition ifPresent: foundBlock ifAbsent: [		definition := aDefinition fromImage.		definition			ifNil: [errorBlock value]			ifNotNil: [foundBlock value: definition]]! !!MCDependencySorter commentStamp: 'kph 5/3/2007 18:46' prior: 0!MCDependencySorter   * #orderedItems     has an OrderedCollection of the item Definitions that have                   all of their requirements when added.   * #required         A dictionary of Sets, keyed on the 'required' item, the Set                   containing the items which require that item   * #provided         A set of provided items, i.e. those which might be required.As each item is added using #add, or #addAll, it obtains the items requirements, subtracting those items which it already has listed as #provided. Items with all of their requirements are added to the #orderedItems. In doing so each of those items is added to the #provided set. When adding to the provided set, a check is made in the #required items to see if the newly provided item is required. If so, it is cleared out of the required list and those items that were waiting for that requirement are then added via #add:/#addAll:Finally you have:   * #orderedItems                         - the collection of items which should load.   * #itemsWithMissingRequirements     - the collection of items that will not yet load.   * #externalRequirements             - the list of requirements still needed after                                         all the internal provisions are accounted for.Typical use (e.g. MCPackageLoader-#analyse) is to instantiate via #items, which adds all of the items and sorts them as they are added. Then calling #addExternalProvisions: with the set of class keys avalable in the image. This gives the ready to load result.The #sortItems: instanciation method sorts the items as above, it assumes that all of the #externalProvisions are available so as to get the complete sorted order. This is used when writing the definitions.!!MCDependencySorter class methodsFor: 'as yet unclassified' stamp: 'ab 5/23/2003 14:17' prior: 23291887!items: aCollection	^ self new addAll: aCollection! !!MCDependencySorter class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23292169!sortItems: aCollection	| sorter |	sorter := self items: aCollection.	sorter externalRequirements do: [:req  | sorter addProvision: req].	^ sorter orderedItems.! !!MCDependencySorter methodsFor: 'building' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23290095!add: anItem	| requirements |	requirements := self unresolvedRequirementsFor: anItem.	requirements isEmpty		ifTrue: [self addToOrder: anItem]		ifFalse: [self addRequirements: requirements for: anItem]! !!MCDependencySorter methodsFor: 'building' stamp: 'bf 11/12/2004 14:50' prior: 23289733!addAll: aCollection	aCollection asArray sort do: [:ea | self add: ea]! !!MCDependencySorter methodsFor: 'building' stamp: 'avi 10/7/2004 22:47' prior: 23289881!addExternalProvisions: aCollection	(aCollection intersection: self externalRequirements)		do: [:ea | self addProvision: ea]! !!MCDependencySorter methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23290694!addProvision: anObject	| newlySatisfied |	provided add: anObject.	newlySatisfied := required removeKey: anObject ifAbsent: [#()].	self addAll: newlySatisfied.! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:24' prior: 23291113!addRequirement: reqObject for: itemObject	(self itemsRequiring: reqObject) add: itemObject! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:23' prior: 23290932!addRequirements: aCollection for: anObject	aCollection do: [:ea | self addRequirement: ea for: anObject]! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:15' prior: 23291280!addToOrder: anItem	orderedItems add: anItem.	anItem provisions do: [:ea | self addProvision: ea].! !!MCDependencySorter methodsFor: 'accessing' stamp: 'dvf 9/8/2004 00:49' prior: 23289220!externalRequirements	| unloaded providedByUnloaded |	unloaded := self itemsWithMissingRequirements.	providedByUnloaded := (unloaded gather: [:e | e provisions]) asSet.	^ required keys reject: [:ea | providedByUnloaded includes: ea ]! !!MCDependencySorter methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23290399!initialize	provided := Set new.	required := Dictionary new.	orderedItems := OrderedCollection new.! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:24' prior: 23291455!itemsRequiring: anObject	^ required at: anObject ifAbsentPut: [Set new]! !!MCDependencySorter methodsFor: 'accessing' stamp: 'kph 5/15/2007 13:13' prior: 23289546!itemsWithMissingRequirements	| items |	items := Set new.	required keysAndValuesDo: [ :ea :waiting | 		waiting do: [ :eaWaiting | eaWaiting because: ' needs ', ea  ]. 		items addAll: waiting	].	^ items! !!MCDependencySorter methodsFor: 'sorting' stamp: 'ab 5/22/2003 23:25' prior: 23290577!orderedItems	^ orderedItems! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:22' prior: 23291603!unresolvedRequirementsFor: anItem	^ anItem requirements difference: provided! !!MCClassTraitParser class methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 20:43' prior: 23241321!pattern	^ '*classTrait*uses:*'! !!MCClassTraitParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23240745!addDefinitionsTo: aCollection	| tokens  definition traitCompositionString |	tokens := Scanner new scanTokens: source.	traitCompositionString := ((ReadStream on: source)		match: 'uses:';		upToEnd) withBlanksTrimmed.	definition := MCClassTraitDefinition		baseTraitName: (tokens at: 1) 		classTraitComposition: traitCompositionString.	aCollection add: definition! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:29' prior: 23309209!concreteSubclasses	^ self allSubclasses reject: [:c | c isAbstract]! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:40' prior: 23309366!forDoit: aString	^ (self subclassForDoit: aString) ifNotNilDo: [:c | c new source: aString]! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:51' prior: 23309547!isAbstract	^ self pattern isNil! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:30' prior: 23309668!pattern	^ nil! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:30' prior: 23309771!subclassForDoit: aString	^ self concreteSubclasses detect: [:ea | ea pattern match: aString] ifNone: []! !!MCDoItParser methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:40' prior: 23308727!addDefinitionsTo: aCollection	self subclassResponsibility ! !!MCDoItParser methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:40' prior: 23308869!source	^ source! !!MCDoItParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23308979!source: aString	source := aString! !!MCSystemCategoryParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:41' prior: 23544948!pattern	^ 'SystemOrganization*'! !!MCSystemCategoryParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23544211!addDefinitionsTo: aCollection	| definition |	definition := aCollection detect: [:ea | ea isOrganizationDefinition ] ifNone: [aCollection add: (MCOrganizationDefinition categories: #())].	definition categories: (definition categories copyWith: self category).! !!MCSystemCategoryParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23544576!category	| tokens  |	tokens := Scanner new scanTokens: source.	tokens size = 3 ifFalse: [self error: 'Unrecognized category definition'].	^ tokens at: 3! !!MCTraitParser class methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 21:09' prior: 23575377!pattern	^ 'Trait named:*'! !!MCTraitParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23574754!addDefinitionsTo: aCollection	| tokens  definition traitCompositionString |	tokens := Scanner new scanTokens: source.	traitCompositionString := ((ReadStream on: source)		match: 'uses:';		upToAll: 'category:') withBlanksTrimmed.	definition := MCTraitDefinition		name: (tokens at: 3) 		traitComposition: traitCompositionString		category:  tokens last		comment:  ''  		commentStamp:   ''.	aCollection add: definition.! !!MCDocumentation commentStamp: 'kph 5/3/2007 18:52' prior: 0!Pulling MC enhancements together:source.wiresong.ca/mv avi.276 !!MCDocumentation methodsFor: 'as yet unclassified' stamp: 'kph 6/29/2007 00:37'!releaseNotes! !!MCDocumentation methodsFor: 'as yet unclassified' stamp: 'kph 6/29/2007 02:56'!releaseNotes28062007"Clarified the parsing of the package name into its constituent parts, aiming to make things more resilient, and flexible.also ensured more flexibility to version numbersMonticelloTest-xxx.1.mcz - standard mcMonticelloTest1.2.3-xxx.1.mcz - standard mc with dots in package name (must occur before first $-)MonticelloTest-xxx.1.3.4b.mcz - traditional sw (note numberic #versionNumber only gives 1.3)MonticelloTest-xxx.1bd9def2-25d1-11dc-909f-000a95edb42a.mcz - uuid version"! !!MCFrontier class methodsFor: 'instance creation' stamp: 'avi 9/17/2005 22:07' prior: 23330959!frontierOn: aVersionInfo	^ self frontierOnAll: (Array with: aVersionInfo)! !!MCFrontier class methodsFor: 'instance creation' stamp: 'avi 9/17/2005 22:07' prior: 23331118!frontierOn: aVersionInfo and: otherVersionInfo	^ self frontierOnAll: (Array with: aVersionInfo with: otherVersionInfo)! !!MCFrontier class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23330610!frontierOnAll: aCollection	| remaining  allVersions |	remaining := Bag new.	allVersions := (aCollection gather: [:ea | ea withBreadthFirstAncestors]) asSet.	allVersions do: [:ea | remaining addAll: ea ancestors].	^self new frontier: aCollection bag: remaining! !!MCFrontier methodsFor: 'accessing' stamp: 'avi 9/17/2005 22:02' prior: 23329817!frontier	^frontier! !!MCFrontier methodsFor: 'initialization' stamp: 'avi 9/17/2005 22:11' prior: 23330329!frontier: f bag: remaining	frontier := f asOrderedCollection.	bag := remaining! !!MCFrontier methodsFor: 'advancing' stamp: 'avi 9/17/2005 22:13' prior: 23330039!remove: aVersionInfo	frontier remove: aVersionInfo.	aVersionInfo ancestors  do:		[ :ancestor |			bag remove: ancestor.			(bag occurrencesOf: ancestor) = 0				ifTrue: [frontier add: ancestor]].	^aVersionInfo! !!MCFrontier methodsFor: 'advancing' stamp: 'avi 9/17/2005 22:02' prior: 23329908!removeAll: collection	collection do: [ :n | self remove: n]! !!MCMergeRecord class methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 15:52' prior: 23370124!version: aVersion	^ self basicNew initializeWithVersion: aVersion! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23368067!ancestorInfo	^ ancestorInfo ifNil: [ancestorInfo := version info commonAncestorWith: version workingCopy ancestry]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23368277!ancestorSnapshot	^ ancestorSnapshot ifNil: [ancestorSnapshot := version workingCopy findSnapshotWithVersionInfo: self ancestorInfo]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23368504!imageIsClean	| ancestors |	ancestors := version workingCopy ancestors.	^ ancestors size = 1		and: [ancestors first = self ancestorInfo]			and: [self imagePatch isEmpty]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23368772!imagePatch	^ imagePatch ifNil: [imagePatch := self packageSnapshot patchRelativeToBase: self ancestorSnapshot]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23368978!initializeWithVersion: aVersion	version := aVersion! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 17:14' prior: 23369114!isAncestorMerge	^ version workingCopy ancestry hasAncestor: version info! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23369282!mergePatch	^ mergePatch ifNil: [mergePatch := version snapshot patchRelativeToBase: self ancestorSnapshot]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23369484!packageSnapshot	^ packageSnapshot ifNil: [packageSnapshot := version package snapshot]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 17:14' prior: 23369655!updateWorkingCopy	self isAncestorMerge ifFalse:		[self imageIsClean			ifTrue: [version workingCopy loaded: version]			ifFalse: [version workingCopy merged: version]]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 15:52' prior: 23369908!version	^ version! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:10' prior: 23371124!addConflictWithOperation: anOperation	self conflicts add: (MCConflict operation: anOperation)! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:01' prior: 23371295!applyTo: anObject	self isMerged ifFalse: [self error: 'You must resolve all the conflicts first'].	conflicts do: [:ea | ea applyTo: anObject]! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23371528!conflicts	^ conflicts ifNil: [conflicts := OrderedCollection new]! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/5/2003 19:09' prior: 23371671!isMerged	^ self conflicts allSatisfy: [:ea | ea isResolved]! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:29' prior: 23371821!load	| loader |	loader := MCPackageLoader newCurrent.	loader provisions addAll: self provisions.	self applyTo: loader.	loader load! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:29' prior: 23372039!loadWithNameLike: baseName	| loader |	loader := MCPackageLoader newCurrent.	loader provisions addAll: self provisions.	self applyTo: loader.	loader loadWithNameLike: baseName! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:11' prior: 23372288!mergedSnapshot	^ MCPatcher apply: self to: self baseSnapshot! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 16:34' prior: 23372427!operations	^ #()! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 15:19' prior: 23372523!provisions	^ #()! !!MCThreeWayMerger class methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:53' prior: 23555866!base: aSnapshot patch: aPatch	aPatch isEmpty ifTrue: [MCNoChangesException signal].	^ self new		addBaseSnapshot: aSnapshot;		applyPatch: aPatch;		yourself		! !!MCThreeWayMerger class methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:09' prior: 23556119!base: aSnapshot target: targetSnapshot ancestor: ancestorSnapshot	^ self base: aSnapshot patch: (targetSnapshot patchRelativeToBase: ancestorSnapshot)! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 15:18' prior: 23551748!addBaseSnapshot: aSnapshot	aSnapshot definitions do:		[:ea |		index add: ea.		provisions addAll: ea provisions]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'mtf 10/7/2008 14:40' prior: 23551950!addDefinition: aDefinition	index		definitionLike: aDefinition		ifPresent: [:other |			(self removalForDefinition: aDefinition)				ifNotNilDo:					[:op |					self addOperation: (MCModification of: other to: aDefinition).					self removeOperation: op.					^ self].			other = aDefinition				ifFalse: [(aDefinition isMethodDefinition and: [aDefinition isOverrideMethod])					ifTrue: [self addOperation: (MCModification of: other to: aDefinition)]					ifFalse: [self addConflictWithOperation: (MCModification of: other to: aDefinition)]]				ifTrue: [self redundantAdds add: aDefinition]]		ifAbsent: [self addOperation: (MCAddition of: aDefinition)]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:30' prior: 23552531!addOperation: anOperation	self operations add: anOperation! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:52' prior: 23552677!applyPatch: aPatch	aPatch applyTo: self! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:32' prior: 23552802!applyTo: anObject	super applyTo: anObject.	self operations do: [:ea | ea applyTo: anObject]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:49' prior: 23552982!baseSnapshot	^ (MCSnapshot fromDefinitions: index definitions)! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'mtf 10/7/2008 14:12' prior: 23553143!initialize	index := MCImageBackedDefinitionIndex new.	provisions := Set new! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:22' prior: 23553296!modificationConflictForDefinition: aDefinition	^ conflicts ifNotNil:		[conflicts detect:			[:ea | (ea definition isRevisionOf: aDefinition) and:				[ea operation isModification]] ifNone: []]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:34' prior: 23553575!modifyDefinition: baseDefinition to: targetDefinition	index		definitionLike: baseDefinition		ifPresent: [:other | other = baseDefinition								ifTrue: [self addOperation: (MCModification of:  baseDefinition to: targetDefinition)]								ifFalse: [other = targetDefinition											ifFalse: [self addConflictWithOperation:														(MCModification of: other to: targetDefinition)]]]		ifAbsent: [self addConflictWithOperation: (MCAddition of: targetDefinition)]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23554146!operations	^ operations ifNil: [operations := OrderedCollection new]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 15:19' prior: 23554302!provisions	^ provisions! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23554424!redundantAdds	^ redundantAdds ifNil: [redundantAdds := Set new]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:40' prior: 23554575!removalForDefinition: aDefinition	^ operations ifNotNil:		[operations			detect: [:ea | (ea definition isRevisionOf: aDefinition) and: [ea isRemoval]]			ifNone: []]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:40' prior: 23554829!removeConflict: aConflict	conflicts remove: aConflict! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 03:23' prior: 23554970!removeDefinition: aDefinition	index		definitionLike: aDefinition		ifPresent: [:other | other = aDefinition								ifTrue:									[(self modificationConflictForDefinition: aDefinition)										ifNotNilDo:											[:c |											self addOperation: c operation.											self removeConflict: c.											^ self]. 									(self redundantAdds includes: aDefinition)										ifFalse: [self addOperation: (MCRemoval of: aDefinition)]]								ifFalse:									[self addConflictWithOperation: (MCRemoval of: other)]]		ifAbsent: []! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:40' prior: 23555602!removeOperation: anOperation	operations remove: anOperation! !!MCOrphanage commentStamp: 'kph 5/15/2007 01:16' prior: 0!MCOrphanage. supports out-of-order loading of packages, and safe unloading.This enables a package to 'extend', and 'override' methods in not-yet-loaded packages. Not yet actually loaded ('orphaned') extensions should also save with the package so as not to be lost. For Detailed Specification: OrphanageTest1 class comment, available in the OrphanageTest-Test1 package. Hooks:MCPackageLoader calls #loading: before loading a package, and #loadComplete afterwards.Orphans are added to the package prior to loading and afterwards.#onClassRemoved: theClass is called by the environment notification system. Orphaned class extension methods are mopped up into the orphanage, and each subclass is given a MCUnlinkedClassDefinition poised to await the reloading of that class. (there may be a better way, but it is a good idicator of any unlinked classes having obsolete superclasses)Each definition that is loaded without error sends us #successfullyLoaded: so we can remove that defn from the orphanage.Design decision: packageInfo collates its info via #orphansFor: aPackage, which use polyMorphism to call #isPartOfPackage or: orphanage , which doesnt use any packageInfo 'monticello-orphanage' methods which call orphansFor: (think infinite loop).!!MCOrphanage class methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 20:10'!current 	^ Current ifNil: [ self initializeTheOrphanage ].! !!MCOrphanage class methodsFor: 'as yet unclassified' stamp: 'kph 9/2/2008 03:50'!initializeTheOrphanage	Current := self named: '.Orphanage'.	 	MCWorkingOrphanage forPackage: Current.		^ Current! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 5/9/2007 06:24'!addOrphans: some	some ifNil: [ ^self ].	orphans addAll: some! !!MCOrphanage methodsFor: 'ui actions' stamp: 'kph 5/10/2007 17:24'!clearOrphans	self initialize! !!MCOrphanage methodsFor: 'initialize-release' stamp: 'kph 7/16/2008 16:16'!initialize 	orphans := Set new.	unlinkedCount := nil.! !!MCOrphanage methodsFor: 'events' stamp: 'kph 5/11/2007 13:26'!loadComplete	unlinkedCount := nil! !!MCOrphanage methodsFor: 'loading' stamp: 'kph 5/10/2007 23:42'!loading: aPackageLoader	"when the package loader is about to do a load the orphanage applys ALL orphans"		self orphans do: [ :orphanDefn | (MCAddition of: orphanDefn) applyTo: aPackageLoader ].! !!MCOrphanage methodsFor: 'events' stamp: 'kph 1/18/2008 10:10'!onClassRemoved: theClass		| cat |	orphans := orphans reject: [ :defn | defn className = theClass name ].				theClass subclasses do: [ :aSubclass | orphans add: (MCUnlinkedClassDefinition class: aSubclass) ]. 	(Array with: theClass with: theClass classSide ) do: [ :behavior |		behavior selectorsAndMethodsDo: [ :selector :method |			cat := behavior organization categoryOfElement: selector.						cat ifNotNil: [ 				(cat beginsWith: '*')					ifTrue: [ orphans add: method methodReference asMethodDefinition ]			]		]	].	unlinkedCount := nil.! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 10/25/2008 01:34'!orphanClasses	^ self orphans asOrderedCollection select: [ :o | o isClassDefinition ].	 ! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 5/15/2007 01:31'!orphanMethods	^ self orphans select: [ :o | o isMethodDefinition ].! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 4/30/2007 00:48'!orphans	"Answer the value of orphans, an MCPackageLoader"	^ orphans! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 5/15/2007 01:13'!orphansFor: packageInfo 	^ self orphans select: [ :defn  | defn isPartOfPackage: packageInfo or: self  ]! !!MCOrphanage methodsFor: 'events' stamp: 'kph 5/15/2007 16:39'!packageUnloaded: aPackageInfo 	"while an unlinked class exists the power to relink it remains"	((self orphansFor: aPackageInfo) difference: self unlinkedClasses)		do: [ :ea | ea removeFromOrphanage: self ]! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 4/30/2007 01:21'!snapshot		^ MCSnapshot fromDefinitions: self orphans! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 4/30/2007 01:07'!storeOn: aStream	self halt. "when is this used?"	aStream		nextPutAll: self class name;		space; nextPutAll: 'named: '; store: name.! !!MCOrphanage methodsFor: 'events' stamp: 'kph 5/10/2007 17:54'!successfullyLoaded: aDefinition	self orphans remove: aDefinition ifAbsent: [ ^ self ].	 ! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 5/15/2007 01:18'!unlinkedClasses     ^ orphans select: [ :orphan | orphan isUnlinkedClassDefinition ] ! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 5/15/2007 01:18'!unlinkedCount	^ unlinkedCount ifNil: [ unlinkedCount := self unlinkedClasses size ] ! !!MCPackage class methodsFor: 'as yet unclassified' stamp: 'ab 7/10/2003 01:17' prior: 23415305!named: aString	^ self new name: aString! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ar 4/26/2005 21:57' prior: 23415046!= other	^ other species = self species and: [other name sameAs: name]! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'kph 8/3/2008 04:16' prior: 23412639!hasWorkingCopy	MCWorkingCopy organizer packageNamed: self name ifAbsent: [ ^ false ].		^ true! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ar 4/26/2005 21:57' prior: 23412531!hash	^ name asLowercase hash! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 00:57' prior: 23412775!name	^ name! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23412878!name: aString	name := aString! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'kph 5/10/2007 05:36'!orphanage	^ MCOrphanage current! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'kph 8/3/2008 03:26' prior: 23412986!packageInfo	^ PackageInfo named: name ! !!MCPackage methodsFor: 'patching' stamp: 'mtf 10/7/2008 14:04'!patchSnapshot	^ self snapshot asPatchSnapshot! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'nk 7/28/2003 13:30' prior: 23413103!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: name;		nextPut: $)! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 03:31' prior: 23413281!snapshot	| definitions categories packageInfo | 	packageInfo := self packageInfo.	definitions := OrderedCollection new.	categories := packageInfo systemCategories.		definitions addAll: (self orphanage orphansFor: packageInfo). 	definitions removeAllFoundIn: self orphanage unlinkedClasses.	   	categories isEmpty ifFalse: [ definitions add: (MCOrganizationDefinition categories: categories) ].	packageInfo		classesDo: [:ea | definitions addAll: ea classDefinitions]		methodsDo: [:ea | definitions add: ea asMethodDefinition]		displayingProgress: 'Snapshotting...'.		MCScriptDefinition subclassesDo: [ :ea | ea from: packageInfo addTo: definitions ].	MCFileDefinition from: packageInfo addTo: definitions.		^ MCSnapshot fromDefinitions: definitions 	! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ab 7/10/2003 01:13' prior: 23414629!storeOn: aStream	aStream		nextPutAll: 'MCPackage';		space; nextPutAll: 'named: '; store: name.! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'cwp 11/13/2003 13:32' prior: 23414807!unload	^ self workingCopy unload! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'cwp 11/13/2003 13:33' prior: 23414921!workingCopy	^ MCWorkingCopy forPackage: self.! !!MCPackageCache class methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:12' prior: 23416248!new	^ self basicNew initialize! !!MCPackageCache methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23415601!initialize	sorter := MCVersionSorter new.	fileNames := Dictionary new.! !!MCPackageCache methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:25' prior: 23415758!recordVersionInfo: aVersionInfo forFileNamed: aString	Transcript cr; show: aString.	fileNames at: aVersionInfo put: aString.	sorter addVersionInfo: aVersionInfo! !!MCPackageCache methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:21' prior: 23416006!versionInfos	^ sorter sortedVersionInfos ! !!MCPackageLoader commentStamp: 'kph 5/26/2007 04:22' prior: 34176772!This loader is the old MC1 code essentially untouched, thoug this class is now obsolete.This is kept here so that when loading this new version of mc into a system with an older version of mc it is running this code and so we do not wish to disturb it. In loading this version, the class #new method is updated to switch future instanciations to the new package loader, this old one being obsolete.This loader remains potentially usable but does not know about the orphanage. #installOrphanage is implemented here as a unused noop, just in case someone wants to revert to using this loader.!!MCPackageLoader class methodsFor: 'as yet unclassified' stamp: 'mtf 10/8/2008 00:36'!initialize	"MCPackageLoader initialize"	Preferences addPreference: #useMonticelloAtomicLoader categories: #(monticello) default: false balloonHelp:	'Use the experimental atomic loader for Monticello. You must have SystemEditor for this to work'! !!MCPackageLoader class methodsFor: 'as yet unclassified' stamp: 'kph 5/26/2007 01:18' prior: 23423385!new	^ (self theChosenLoaderClass basicNew) initialize; yourself! !!MCPackageLoader class methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:29'!newCurrent	^ (self theChosenLoaderClass basicNew) initialize; yourself! !!MCPackageLoader class methodsFor: 'as yet unclassified' stamp: 'mtf 6/17/2008 09:21'!theChosenLoaderClass	^ (Preferences useMonticelloAtomicLoader and: [Smalltalk includesKey: #SystemEditor])		ifTrue: [MCPackageLoader2]		ifFalse: [MCPackageLoader1b]! !!MCPackageLoader1b commentStamp: 'kph 5/25/2007 04:43' prior: 0!MCPackageLoader1b - Attempt to improve loading with a number of tricksIn #basicLoad the loading process starts with a collection of definitions in #additions, and another in #removals. #analyse should have sorted these so that dependencies shouldnt cause errors.The load sequence sent to each addidion is: #preLoadOver: [ #install #postinstall ] #postloadOver:The load sequence sent to each removal is                    [ #unload ]The brackets above mark the fact that the 'load' itself which is perfromed by #install/#postinstall and #unload are performed in a tight loop and this is our attempt at atomicity.For methods, #preloadOver:, and #postloadOver: obsoletions are supplied, being the original item being overwritten.InstVar #defn is the currently loading definition. This allows error handlers to know what was being processed when the error occured.-----Note that to support loading this Monicello over a version which does not support atomic loading, soe things have to remain in place that are otherwise obsolete.MCDefinition-#loadOver:MCPackageLoader instVar's errorDefinitions, addtions, removals cant be renamed.!!MCPackageLoader1b class methodsFor: 'as yet unclassified' stamp: 'kph 5/25/2007 04:26'!new	^ self basicNew initialize! !!MCPackageLoader1b methodsFor: 'patch ops' stamp: 'kph 5/25/2007 04:26'!addDefinition: aDefinition	additions add: aDefinition! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 6/12/2007 09:36'!analyze	| sorter |		self isMultiplePackage ifTrue: [ self analyzeMulti ].		sorter := self sorterForItems: additions.	additions := sorter orderedItems.	requirements := sorter externalRequirements.	unloadableDefinitions := sorter itemsWithMissingRequirements asSortedCollection.		sorter := self sorterForItems: removals.	removals := sorter orderedItems reversed.! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 6/12/2007 09:35'!analyzeMulti	| index |	index := MCDefinitionIndex definitions: additions.	removals removeAllSuchThat: [:removal |		(index definitionLike: removal			ifPresent: [:addition | obsoletions at: addition put: removal]			ifAbsent: []) notNil].! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 4/14/2008 13:18'!basicLoad  	additions do: [:ea | ea preloadOver: (self obsoletionFor: ea).   ] displayingProgress: 'Loading...'.			self shouldWarnAboutErrors ifTrue: [ self warnAboutErrors: errorDefinitions ].	(1 to: 2) do: [:ea |  ] displayingProgress: (self isUnloading ifFalse: [ 'Installing...' ] 																ifTrue: [ 'Unloading...' ]).	"begin the psuedo atomic bit"				removals do: [:ea | ea unload ].	additions do: [:ea | ea install ].	additions do: [:ea | ea postinstall ].	"end the psuedo atomic bit" 	 additions reverse do: [:ea | 				ea postloadOver: (self obsoletionFor: ea).		self successfullyLoaded: ea.	] displayingProgress: 'Integration...'.! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 6/12/2007 09:33'!beMultiplePackage	isMultiplePackage := true! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 5/25/2007 04:26'!beUnloading	isUnloading := true! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!dependencyWarning	^ String streamContents:		[:s |		s nextPutAll: 'This package, or the orphanage is looking for the following classes:'; cr.		requirements do: [:ea | s space; space; nextPutAll: ea; cr].		s nextPutAll: 'These definitions will be orphaned until the classes are loaded: '; cr.		unloadableDefinitions do: [:ea | s space; space; nextPutAll: (ea summary, ea because); cr]] ! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!errorDefinitionWarning: erroredDefns	^ String streamContents:		[:s |		s nextPutAll: 'The following definitions had errors while loading.  Press Proceed to try to load them again (they may work on a second pass):'; cr.		erroredDefns do: [:ea | 			s space; space; 			  nextPutAll: ea summary;			  space; 			  nextPutAll: (ea because ifNil: [ '' ]); cr]] ! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!flushChangesFile	"The changes file is second in the SourceFiles array"	(SourceFiles at: 2) flush! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/26/2007 00:29'!initialize	additions := OrderedCollection new.	removals := OrderedCollection new.	obsoletions := Dictionary new. ! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!installOrphanage	self orphanage loading: self.! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 5/25/2007 04:26'!installSnapshot: aSnapshot	| patch |	patch := aSnapshot patchRelativeToBase: MCSnapshot empty.	patch applyTo: self.	 ! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 6/12/2007 09:33'!isMultiplePackage	^ isMultiplePackage == true! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 5/25/2007 04:26'!isUnloading 	^ isUnloading ifNil: [ false ]! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 5/25/2007 04:26'!load	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useNewChangeSetDuring: [self protectedLoad].	self loadComplete.! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 12/6/2008 02:49'!loadComplete	MCMethodDefinition tidyCache.	self orphanage 		addOrphans: unloadableDefinitions;	 	addOrphans: errorDefinitions;		loadComplete.	Behavior flushObsoleteSubclasses.	self loadFiles.! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 12/6/2008 02:50'!loadFiles! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 5/25/2007 04:26'!loadWithName: baseName 	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useChangeSetNamed: baseName during: [self protectedLoad].	self loadComplete.! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 5/25/2007 04:26'!loadWithNameLike: baseName 	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useNewChangeSetNamedLike: baseName during: [self protectedLoad].	self loadComplete.! !!MCPackageLoader1b methodsFor: 'patch ops' stamp: 'kph 5/25/2007 04:26'!modifyDefinition: old to: new	self addDefinition: new.	obsoletions at: new put: old.! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!obsoletionFor: aDefinition	^ obsoletions at: aDefinition ifAbsent: [nil]! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!orderedAdditions	^ additions! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!orphanage	^ MCOrphanage current! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 12/18/2007 01:05'!protectedLoad		errorDefinitions := OrderedCollection new. 		[			[				[ self basicLoad ] on: InMidstOfFileinNotification do: [:n |  n resume: true]			] ensure: [self flushChangesFile].				]  on: MCOrphanedNotification do: [ :ex | additions remove: ex orphan ifAbsent: [].											errorDefinitions add: ex orphan. 									 		ex resume.					  		] ! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!provisions	^ provisions ifNil: [provisions := Set withAll: Smalltalk keys]! !!MCPackageLoader1b methodsFor: 'patch ops' stamp: 'kph 5/25/2007 04:26'!removeDefinition: aDefinition	removals add: aDefinition! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!shouldWarnAboutErrors	^ false "should make this a preference"! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!sorterForItems: aCollection	| sorter |	sorter := MCDependencySorter items: aCollection.	sorter addExternalProvisions: self provisions.	^ sorter! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!successfullyLoaded: aDefinition	self orphanage successfullyLoaded: aDefinition! !!MCPackageLoader1b methodsFor: 'obsolete' stamp: 'kph 5/25/2007 04:26'!tryToLoad: aDefinition errors: errs 	self tryToLoad: aDefinition errors: errorDefinitions ! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/26/2007 10:02'!unloadPackage: aPackage 	(self 		updatePackage: aPackage withSnapshot: MCSnapshot empty;		beUnloading;		loadWithNameLike: aPackage name, '-unload';		yourself)		orphanage packageUnloaded: aPackage packageInfo.	! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 8/2/2007 14:45'!updatePackage: aPackage withSnapshot: aSnapshot	|  patch packageSnap |	packageSnap := aPackage snapshot.	patch := aSnapshot patchRelativeToBase: packageSnap.	patch applyTo: self.	packageSnap definitions do: [:ea | self provisions addAll: ea provisions]! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!useChangeSetNamed: baseName during: aBlock	"Use the named change set, or create one with the given name."	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := (ChangeSorter changeSetNamed: baseName) ifNil: [ ChangeSet new name: baseName ].	changeHolder newChanges: newChanges.	[aBlock value] ensure: [changeHolder newChanges: oldChanges].! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!useNewChangeSetDuring: aBlock	^self useNewChangeSetNamedLike: 'MC' during: aBlock! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!useNewChangeSetNamedLike: baseName during: aBlock	^self useChangeSetNamed: (ChangeSet uniqueNameLike: baseName) during: aBlock! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 8/2/2007 00:22'!warnAboutDependencies 	"self notify: self dependencyWarning"! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!warnAboutErrors: errors	errors isEmpty ifFalse: [ self notify: (self errorDefinitionWarning: errors) ]! !!MCPackageLoader2 commentStamp: 'kph 5/26/2007 09:32' prior: 0!MCPackageLoader2ProgressBar has great improvements.#setProgressBar: is used for clients to control how progress is displayed.If no one indicates a preference we display our own progress bar.Otherwise we use the one passed to us.To not have any progress bar displayed give us an empty block.#setProgressBar: [:v |  ] !!MCMultiPackageLoader commentStamp: '<historical>' prior: 0!A PackageLoader doing some additional cross-package checks!!MCMultiPackageLoader methodsFor: 'private' stamp: 'bf 3/17/2006 15:51'!analyze	| index |	index := MCDefinitionIndex definitions: additions.	removals removeAllSuchThat: [:removal |		(index definitionLike: removal			ifPresent: [:addition | obsoletions at: addition put: removal]			ifAbsent: []) notNil].	super analyze! !!MCPackageLoader2 class methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 18:03'!new	^ self basicNew initialize! !!MCPackageLoader2 methodsFor: 'patch ops' stamp: 'ab 5/24/2003 16:13'!addDefinition: aDefinition	additions add: aDefinition! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 6/12/2007 09:36'!analyze	| sorter |		self isMultiplePackage ifTrue: [ self analyzeMulti ].		sorter := self sorterForItems: additions.	additions := sorter orderedItems.	requirements := sorter externalRequirements.	unloadableDefinitions := sorter itemsWithMissingRequirements asSortedCollection.		sorter := self sorterForItems: removals.	removals := sorter orderedItems reversed.! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 6/12/2007 09:35'!analyzeMulti	| index |	index := MCDefinitionIndex definitions: additions.	removals removeAllSuchThat: [:removal |		(index definitionLike: removal			ifPresent: [:addition | obsoletions at: addition put: removal]			ifAbsent: []) notNil].! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 12/12/2008 23:22'!basicLoad	| postloads postunloads |	editor := SystemEditor new.	postloads := OrderedCollection new.	postunloads := OrderedCollection new.	additions do: [:defn |		(defn edLoadFor: self into: editor)			ifTrue: [postloads add: defn]]		displayingProgress: 'Assembling Changes...'.	removals do: [:defn |		(defn edUnload: editor)			ifTrue: [postunloads add: defn]]		displayingProgress: 'Assembling Removals...'.	"the business"	editor commitWithProgress.	postloads do: [:ea | ea edPostloadFor: self ] displayingProgress: 'Running post-load scripts...'.	postunloads do: [ :ea |  ea edPostunload] displayingProgress: 'Running post-unload scripts...'.! !!MCPackageLoader2 methodsFor: 'patch ops' stamp: 'kph 6/12/2007 09:32'!beMultiplePackage	isMultiplePackage := true! !!MCPackageLoader2 methodsFor: 'public' stamp: 'kph 5/15/2007 15:38'!beUnloading	isUnloading := true! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/15/2007 13:38'!dependencyWarning	^ String streamContents:		[:s |		s nextPutAll: 'This package, or the orphanage is looking for the following classes:'; cr.		requirements do: [:ea | s space; space; nextPutAll: ea; cr].		s nextPutAll: 'These definitions will be orphaned until the classes are loaded: '; cr.		unloadableDefinitions do: [:ea | s space; space; nextPutAll: (ea summary, ea because); cr]] ! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/15/2007 12:53'!errorDefinitionWarning: erroredDefns	^ String streamContents:		[:s |		s nextPutAll: 'The following definitions had errors while loading.  Press Proceed to try to load them again (they may work on a second pass):'; cr.		erroredDefns do: [:ea | 			s space; space; 			  nextPutAll: ea summary;			  space; 			  nextPutAll: (ea because ifNil: [ '' ]); cr]] ! !!MCPackageLoader2 methodsFor: 'private' stamp: 'cwp 11/13/2003 02:01'!flushChangesFile	"The changes file is second in the SourceFiles array"	(SourceFiles at: 2) flush! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 7/4/2007 05:28'!initialize	additions := OrderedCollection new.	removals := OrderedCollection new.	obsoletions := Dictionary new.! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/15/2007 12:12'!installOrphanage	self orphanage loading: self.! !!MCPackageLoader2 methodsFor: 'public' stamp: 'kph 5/11/2007 07:28'!installSnapshot: aSnapshot	| patch |	patch := aSnapshot patchRelativeToBase: MCSnapshot empty.	patch applyTo: self.	 ! !!MCPackageLoader2 methodsFor: 'patch ops' stamp: 'kph 6/12/2007 09:33'!isMultiplePackage	^ isMultiplePackage == true! !!MCPackageLoader2 methodsFor: 'public' stamp: 'kph 5/15/2007 15:39'!isUnloading 	^ isUnloading ifNil: [ false ]! !!MCPackageLoader2 methodsFor: 'public' stamp: 'kph 5/15/2007 12:13'!load	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useNewChangeSetDuring: [self protectedLoad].	self loadComplete.! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 12/6/2008 02:50'!loadComplete	MCMethodDefinition tidyCache.	self orphanage 		addOrphans: unloadableDefinitions;	 	addOrphans: errorDefinitions;		loadComplete.	self loadFiles.! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 12/6/2008 02:49'!loadFiles	MCMethodDefinition tidyCache.	self orphanage 		addOrphans: unloadableDefinitions;	 	addOrphans: errorDefinitions;		loadComplete.! !!MCPackageLoader2 methodsFor: 'public' stamp: 'kph 5/15/2007 12:26'!loadWithName: baseName 	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useChangeSetNamed: baseName during: [self protectedLoad].	self loadComplete.! !!MCPackageLoader2 methodsFor: 'public' stamp: 'kph 5/15/2007 12:26'!loadWithNameLike: baseName 	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useNewChangeSetNamedLike: baseName during: [self protectedLoad].	self loadComplete.! !!MCPackageLoader2 methodsFor: 'patch ops' stamp: 'avi 2/17/2004 13:14'!modifyDefinition: old to: new	self addDefinition: new.	obsoletions at: new put: old.! !!MCPackageLoader2 methodsFor: 'private' stamp: 'avi 2/17/2004 13:15'!obsoletionFor: aDefinition	^ obsoletions at: aDefinition ifAbsent: [nil]! !!MCPackageLoader2 methodsFor: 'private' stamp: 'ab 5/24/2003 16:52'!orderedAdditions	^ additions! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 4/30/2007 00:39'!orphanage	^ MCOrphanage current! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/26/2007 10:06'!progressBar	^ progressBar ! !!MCPackageLoader2 methodsFor: 'private' stamp: 'mtf 8/6/2008 01:13'!protectedLoad 		[			[				[ self basicLoad ] on: InMidstOfFileinNotification do: [:n | n resume: true]			] ensure: [self flushChangesFile].				]  on: MCOrphanedNotification do: [ :ex | additions remove: ex orphan ifAbsent: [].											errorDefinitions add: ex orphan. 									 		ex resume.					  		] ! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/25/2007 03:43'!provisions	^ provisions ifNil: [provisions := Set withAll: Smalltalk keys]! !!MCPackageLoader2 methodsFor: 'patch ops' stamp: 'ab 5/24/2003 16:14'!removeDefinition: aDefinition	removals add: aDefinition! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/26/2007 09:22'!setProgressBar: aBar	progressBar := aBar! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/4/2007 00:24'!shouldWarnAboutErrors	^ false "should make this a preference"! !!MCPackageLoader2 methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!sorterForItems: aCollection	| sorter |	sorter := MCDependencySorter items: aCollection.	sorter addExternalProvisions: self provisions.	^ sorter! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/10/2007 17:30'!successfullyLoaded: aDefinition	self orphanage successfullyLoaded: aDefinition! !!MCPackageLoader2 methodsFor: 'obsolete' stamp: 'kph 5/22/2007 18:45'!tryToLoad: aDefinition errors: errs 	self tryToLoad: aDefinition errors: errorDefinitions ! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/26/2007 10:02'!unloadPackage: aPackage 	(self 		updatePackage: aPackage withSnapshot: MCSnapshot empty;		beUnloading;		loadWithNameLike: aPackage name, '-unload';		yourself)		orphanage packageUnloaded: aPackage packageInfo.	! !!MCPackageLoader2 methodsFor: 'public' stamp: 'stephaneducasse 2/4/2006 20:47'!updatePackage: aPackage withSnapshot: aSnapshot	|  patch packageSnap |	packageSnap := aPackage snapshot.	patch := aSnapshot patchRelativeToBase: packageSnap.	patch applyTo: self.	packageSnap definitions do: [:ea | self provisions addAll: ea provisions]! !!MCPackageLoader2 methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!useChangeSetNamed: baseName during: aBlock	"Use the named change set, or create one with the given name."	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := (ChangeSorter changeSetNamed: baseName) ifNil: [ ChangeSet new name: baseName ].	changeHolder newChanges: newChanges.	[aBlock value] ensure: [changeHolder newChanges: oldChanges].! !!MCPackageLoader2 methodsFor: 'private' stamp: 'nk 8/30/2004 08:38'!useNewChangeSetDuring: aBlock	^self useNewChangeSetNamedLike: 'MC' during: aBlock! !!MCPackageLoader2 methodsFor: 'private' stamp: 'nk 2/23/2005 07:50'!useNewChangeSetNamedLike: baseName during: aBlock	^self useChangeSetNamed: (ChangeSet uniqueNameLike: baseName) during: aBlock! !!MCPackageLoader2 methodsFor: 'private' stamp: 'ab 5/25/2003 01:22'!warnAboutDependencies 	self notify: self dependencyWarning! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/4/2007 00:23'!warnAboutErrors: errors	errors isEmpty ifFalse: [ self notify: (self errorDefinitionWarning: errors) ]! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'kph 8/3/2008 04:43' prior: 23427178!allManagers	^ self packageInfos collect:[ :pi | pi manager ifNil: [ self forPackage: (MCPackage named: pi name) ] ]! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/27/2005 14:28' prior: 23427995!classModified: anEvent	self managersForClass: anEvent item do:[:mgr| mgr modified: true].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 21:31' prior: 23428172!classMoved: anEvent	self classModified: anEvent.	self managersForCategory: anEvent oldCategory do:[:mgr| mgr modified: true].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'kph 5/11/2007 03:17' prior: 23428386!classRemoved: anEvent	MCOrphanage current onClassRemoved: anEvent item.	self classModified: anEvent! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'kph 8/3/2008 04:02' prior: 23427317!forPackage: aPackage	^ (PackageInfo named: aPackage name) in: [ :pi | 				pi manager ifNil: [ pi manager: (self new initializeWithPackage: aPackage).							self changed: #allManagers.							pi manager ]				] ! !!MCPackageManager class methodsFor: 'system changes' stamp: 'kph 9/2/2008 04:33' prior: 23428523!managersForCategory: aSystemCategory do: aBlock	"Got to be careful here - we might get method categories where capitalization is problematic."	| cat foundOne index |	foundOne := false.	cat := aSystemCategory ifNil:[^nil]. "yes this happens; for example in eToy projects"	"first ask PackageInfos, their package name might not match the category"	self packageInfos do: [:pi | 		((pi includesSystemCategory: aSystemCategory) and: [ pi manager notNil ])	ifTrue: [			aBlock value: pi manager.			foundOne := true.		]	].	foundOne ifTrue: [^self].	["Loop over categories until we found a matching one"		(self organizer packageNamed: cat ifAbsent: nil) ifNotNilDo:[:pi |		aBlock value: pi manager.		foundOne := true.	].	index := cat lastIndexOf: $-.	index > 0]whileTrue:[		"Step up to next level package"		cat := cat copyFrom: 1 to: index-1.	].	foundOne ifFalse:[		"Create a new (but only top-level)"		aBlock value: (MCWorkingCopy forPackage: (MCPackage named: (aSystemCategory copyUpTo: $-) capitalized)).	].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/27/2005 14:11' prior: 23429593!managersForClass: aClass category: methodCategory do: aBlock	(methodCategory isEmptyOrNil or:[methodCategory first ~= $*]) ifTrue:[		"Not an extension method"		^self managersForClass: aClass do: aBlock.	].	self managersForCategory: methodCategory allButFirst do: aBlock.! !!MCPackageManager class methodsFor: 'system changes' stamp: 'kph 9/2/2008 04:34' prior: 23429955!managersForClass: aClass do: aBlock	self packageInfos do: [:pi |		((pi includesClass: aClass) and: [ pi manager notNil ])			ifTrue: [aBlock value: pi manager]]! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 21:40' prior: 23430179!managersForClass: aClass selector: aSelector do: aBlock	^self managersForClass: aClass category: (aClass organization categoryOfElement: aSelector) do: aBlock! !!MCPackageManager class methodsFor: 'system changes' stamp: 'kph 2/7/2009 18:25' prior: 23430425!methodModified: anEvent	^ self managersForClass: anEvent itemClass selector: anEvent itemSelector do:[:mgr| mgr modified: true].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 21:40' prior: 23430640!methodMoved: anEvent	self managersForClass: anEvent itemClass category: anEvent oldCategory do:[:mgr| mgr modified: true].	self methodModified: anEvent.! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:12' prior: 23430881!methodRemoved: anEvent	self managersForClass: anEvent itemClass category: anEvent itemProtocol do:[:mgr| mgr modified: true].! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'kph 8/3/2008 04:07'!organizer	^ PackageOrganizer default  ! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'kph 8/3/2008 04:07'!packageInfos	^ self organizer packageInfos! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:18' prior: 23431095!registerForNotifications	Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|	(cls uniqueInstance)		noMoreNotificationsFor: self;		notify: self ofSystemChangesOfItem: #class change: #Added using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Modified using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Renamed using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Commented using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Recategorized using: #classMoved:;		notify: self ofSystemChangesOfItem: #class change: #Removed using: #classRemoved:;		notify: self ofSystemChangesOfItem: #method change: #Added using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Modified using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Recategorized using: #methodMoved:;		notify: self ofSystemChangesOfItem: #method change: #Removed using: #methodRemoved:	].! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'kph 9/2/2008 04:05' prior: 23427851!registry	 	"if we have a registry migrate to using PackageOrganizer" 	^ registry	! !!MCPackageManager methodsFor: 'initialize-release' stamp: 'kph 5/10/2007 18:01' prior: 23425008!initialize	modified := false.	 ! !!MCPackageManager methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23425167!initializeWithPackage: aPackage	package := aPackage.	self initialize.! !!MCPackageManager methodsFor: 'accessing' stamp: 'cwp 11/13/2003 14:12' prior: 23424055!modified	^ modified! !!MCPackageManager methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23424163!modified: aBoolean     modified = aBoolean ifTrue: [^ self].	modified := aBoolean.	self changed: #modified.		modified ifFalse:		[(((Smalltalk classNamed: 'SmalltalkImage') ifNotNilDo: [:si | si current]) ifNil: [Smalltalk])			logChange: '"', self packageName, '"'].! !!MCPackageManager methodsFor: 'accessing' stamp: 'ab 7/7/2003 16:47' prior: 23424510!package	^ package! !!MCPackageManager methodsFor: 'accessing' stamp: 'ab 7/7/2003 13:33' prior: 23424603!packageInfo	^ package packageInfo! !!MCPackageManager methodsFor: 'accessing' stamp: 'ab 7/7/2003 12:18' prior: 23424712!packageName	^ package name! !!MCPackageManager methodsFor: 'accessing' stamp: 'ab 7/5/2003 23:18' prior: 23424814!packageNameWithStar	^ modified		ifTrue: ['* ', self packageName]		ifFalse: [self packageName]! !!MCPackageManager methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:17' prior: 23426578!systemChange: anEvent	"obsolete - remove this later"! !!MCPackageManager methodsFor: 'operations' stamp: 'kph 8/3/2008 04:18' prior: 23425316!unregister	self class organizer unregisterPackageNamed: self package name.	self class changed: #allManagers! !!MCPackageManager methodsFor: 'system changes' stamp: 'avi 11/11/2003 12:06' prior: 23426714!update: aSymbol	InMidstOfFileinNotification signal ifFalse: [	[((aSymbol = #recentMethodSubmissions)		and: [self packageInfo				includesMethodReference: Utilities recentMethodSubmissions last])					ifTrue: [self modified: true]]		on: Error do: []]! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'kph 9/3/2008 15:41' prior: 23631985!initialize	Smalltalk 		at: #MczInstaller		ifPresent: [:installer | self adoptVersionInfoFrom: installer].	registry ifNotNil:[registry rehash]. "changed #="	self allInstancesDo:[:each| "moved notifications"		Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			cls uniqueInstance noMoreNotificationsFor: each.		].	].	self registerForNotifications.		registry ifNotNil: [ 		PackageOrganizer forcefullyClearCache.		registry values collect: [ :mgr | mgr package packageInfo manager: mgr  ].		registry := nil.	].! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'kph 11/13/2007 22:55' prior: 23630824!adoptVersionInfoFrom: anInstaller	|viCache|	viCache := Dictionary new.	anInstaller versionInfo keysAndValuesDo: [:packageName :info |			[(self forPackage: (MCPackage named: packageName))			versionInfo: (self infoFromDictionary:  info cache: viCache) ] ifError: ["backwards compat"] ].					[anInstaller clearVersionInfo] on: Error do: ["backwards compat"].! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 01:23' prior: 23631236!ancestorsFromArray: anArray cache: aDictionary	^ anArray ifNotNil: [anArray collect: [:dict | self infoFromDictionary: dict cache: aDictionary]]! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23631482!infoFromDictionary: aDictionary cache: cache	| id |	id := aDictionary at: #id.	^ cache at: id ifAbsentPut:		[MCVersionInfo			name: (aDictionary at: #name)			id: (aDictionary at: #id)			message: (aDictionary at: #message)			date: (aDictionary at: #date)			time: (aDictionary at: #time)			author: (aDictionary at: #author)			ancestors: (self ancestorsFromArray: (aDictionary at: #ancestors) cache: cache)]! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 02:36' prior: 23632500!updateInstVars	self allInstances do: [:ea | ea updateInstVars]! !!MCWorkingCopy methodsFor: 'operations' stamp: 'avi 2/13/2004 01:07' prior: 23624121!adopt: aVersion	ancestry addAncestor: aVersion info.	self changed.! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 01:07' prior: 23622451!ancestors	^ ancestry ancestors! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 01:13' prior: 23622556!ancestry	^ ancestry! !!MCWorkingCopy methodsFor: 'operations' stamp: 'kph 12/7/2008 02:31' prior: 23624264!backportChangesTo: aVersionInfo	| baseVersion fullPatch currentVersionInfo currentVersion newSnapshot newAncestry |	currentVersionInfo := self currentVersionInfo.	baseVersion := self repositoryGroup versionWithInfo: aVersionInfo.	currentVersion := self repositoryGroup versionWithInfo: currentVersionInfo.	fullPatch := currentVersion snapshot patchRelativeToBase: baseVersion snapshot.	(MCChangeSelectionRequest new		patch: fullPatch;		label: 'Changes to Backport';		signal ) ifNotNilDo:		[:partialPatch |		newSnapshot := MCPatcher apply: partialPatch to: baseVersion snapshot.		newAncestry := MCWorkingAncestry new							addAncestor: aVersionInfo;							addStepChild: currentVersionInfo;							yourself.		(MCPackageLoader newCurrent) 			updatePackage: package withSnapshot: newSnapshot;			installOrphanage.					ancestry := newAncestry.		self modified: false; modified: true]! !!MCWorkingCopy methodsFor: 'operations' stamp: 'kph 5/11/2007 05:08'!canBackport	^ true! !!MCWorkingCopy methodsFor: 'operations' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23625204!changesRelativeToRepository: aRepository	| ancestorVersion ancestorSnapshot |	ancestorVersion := aRepository closestAncestorVersionFor: ancestry ifNone: [].	ancestorSnapshot := ancestorVersion ifNil: [MCSnapshot empty] ifNotNil: [ancestorVersion snapshot].	^ package snapshot patchRelativeToBase: ancestorSnapshot! !!MCWorkingCopy methodsFor: 'obsolete' stamp: 'kph 5/19/2007 14:14'!classModified: aMethod	"this is a dummy to enable MC to be loaded in by older MC's who have Working copies registered for events for some reason"	 Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			self class allInstances do: [ :i | 			(cls uniqueInstance) noMoreNotificationsFor: i.		].	].! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23622661!clearRequiredPackages	requiredPackages := nil! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 20:01' prior: 23622781!currentVersionInfo	^ (self needsSaving or: [ancestry ancestors isEmpty])		ifTrue: [self newVersion info]		ifFalse: [ancestry ancestors first]! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 01:05' prior: 23622999!description	^ self packageNameWithStar, ' (', ancestry ancestorString, ')'! !!MCWorkingCopy methodsFor: 'private' stamp: 'avi 9/24/2004 12:15' prior: 23628724!findSnapshotWithVersionInfo: aVersionInfo	^ aVersionInfo		ifNil: [MCSnapshot empty]		ifNotNil: [(self repositoryGroup versionWithInfo: aVersionInfo) snapshot]! !!MCWorkingCopy methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23628968!initialize	super initialize.	ancestry := MCWorkingAncestry new! !!MCWorkingCopy methodsFor: 'testing' stamp: 'kph 5/13/2007 01:05'!isOrphanage	^ false! !!MCWorkingCopy methodsFor: 'operations' stamp: 'kph 12/13/2008 17:38' prior: 23625607!loaded: aVersion	ancestry := MCWorkingAncestry new addAncestor: aVersion info.	requiredPackages := OrderedCollection withAll: (aVersion dependencies collect: [:ea | ea package]).	self setMyRepositoryFromLastAdded.	self modified: false.	self changed! !!MCWorkingCopy methodsFor: 'operations' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23626053!merge: targetVersion	| ancestorInfo merger ancestorSnapshot packageSnapshot |	targetVersion dependencies do: [:ea | ea resolve merge].	ancestorInfo := targetVersion info commonAncestorWith: ancestry.		ancestorInfo = targetVersion info ifTrue: [^ MCNoChangesException signal].		packageSnapshot := package snapshot.	ancestorSnapshot := ancestorInfo							ifNotNil: [(self findSnapshotWithVersionInfo: ancestorInfo)]							ifNil: [self notifyNoCommonAncestorWith: targetVersion.  MCSnapshot empty].		(ancestry ancestors size = 1		and: [ancestry ancestors first = ancestorInfo]		and: [(packageSnapshot patchRelativeToBase: ancestorSnapshot) isEmpty])				ifTrue: [^ targetVersion load].		merger := MCThreeWayMerger 				base: packageSnapshot				target: targetVersion snapshot				ancestor: ancestorSnapshot.	((MCMergeResolutionRequest new merger: merger)		signal: 'Merging ', targetVersion info name) = true ifTrue:			[merger loadWithNameLike: targetVersion info name.			ancestry addAncestor: targetVersion info].	self changed! !!MCWorkingCopy methodsFor: 'operations' stamp: 'abc 2/13/2004 15:57' prior: 23625899!merged: aVersion	ancestry addAncestor: aVersion info.	self changed! !!MCWorkingCopy methodsFor: 'obsolete' stamp: 'kph 5/19/2007 14:14'!methodModified: aMethod	"this is a dummy to enable MC to be loaded in by older MC's who have Working copies registered for events for some reason"		Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			self class allInstances do: [ :i | 			(cls uniqueInstance) noMoreNotificationsFor: i.		].	].! !!MCWorkingCopy methodsFor: 'obsolete' stamp: 'kph 5/19/2007 14:14'!methodRemoved: aMethod	"this is a dummy to enable MC to be loaded in by older MC's who have Working copies registered for events for some reason"		Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			self class allInstances do: [ :i | 			(cls uniqueInstance) noMoreNotificationsFor: i.		].	].! !!MCWorkingCopy methodsFor: 'menu' stamp: 'kph 2/12/2009 00:39'!myMenu: aMenu inBrowser: browser 	"note these actions are sent to the browser"		browser fillMenu: aMenu fromSpecs:		#(			('add required package' #addRequiredPackage)			('clear required packages' #clearRequiredPackages)			('add repository...' #addPackageRepository)			"('browse package' #browseWorkingCopy)			('view changes' #viewChanges)			('view history' #viewHistory)"			('recompile package' #recompilePackage)			('recompile all packages' #recompileAllPackages)					('memory use for all packages' #viewMemoryUseAll)					('memory use' #viewMemoryUse)					('revert package...' #revertPackage)			('unload package code' #unloadPackage)			('trim ancestry' #trimAncestry)			('ancestry go back one' #ancestryGoBackOne)			('remove package name from list' #deleteWorkingCopy)			('explore working copy' #exploreWorkingCopy)		).	self class selectors select: [ :sel | (sel beginsWith: #myMenu) and: [ sel ~= #myMenu:inBrowser: ]]		thenDo: [ :ea | self perform: ea with: aMenu ].	^ aMenu! !!MCWorkingCopy methodsFor: 'menu' stamp: 'kph 12/11/2008 23:59'!myMenuForSARDumper: aMenu	(Smalltalk classNamed: 'SARMCPackageDumper') ifNotNil: [		aMenu add: 'make SAR' target: self selector: #fileOutAsSAR	].		! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 20:02' prior: 23623148!needsSaving	^ self modified or: [self requiredPackages anySatisfy: [:ea | ea workingCopy needsSaving]]! !!MCWorkingCopy methodsFor: 'private' stamp: 'kph 6/29/2007 04:12'!newMcFilenameUUID	| uuid |	uuid := (UUID new asString copyFrom: 1 to: 18) copyWithout: $-! !!MCWorkingCopy methodsFor: 'operations' stamp: 'avi 1/19/2004 16:18' prior: 23627172!newVersion	^ (self requestVersionNameAndMessageWithSuggestion: self uniqueVersionName) ifNotNilDo:		[:pair |		self newVersionWithName: pair first message: pair last].! !!MCWorkingCopy methodsFor: 'operations' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23627428!newVersionWithName: nameString message: messageString	| info deps |	info := ancestry infoWithName: nameString message: messageString.	ancestry := MCWorkingAncestry new addAncestor: info.	self modified: true; modified: false.		deps := self requiredPackages collect:		[:ea | 		MCVersionDependency			package: ea			info: ea workingCopy currentVersionInfo].	^ MCVersion		package: package		info: info		snapshot: package snapshot		dependencies: deps! !!MCWorkingCopy methodsFor: 'private' stamp: 'kph 6/29/2007 03:49'!nextVersionNameHaveAlreadyTried: previousAttempt	 	previousAttempt ifNotNil:[ ^ previousAttempt nextVersion ].	ancestry ancestors isEmpty		ifTrue: [ ^ MCVersionInfo firstVersionForPackage: package name ].	^ ancestry ancestors first nextVersionConsidering: ancestry. ! !!MCWorkingCopy methodsFor: 'operations' stamp: 'avi 2/13/2004 01:07' prior: 23627961!notifyNoCommonAncestorWith: aVersion	self notify:'Could not find a common ancestor between (',aVersion info name,') and (',ancestry ancestorString, ').Proceeding with this merge may cause spurious conflicts.'! !!MCWorkingCopy methodsFor: 'private' stamp: 'bf 9/8/2005 10:58' prior: 23629758!possiblyNewerVersions	^Array streamContents: [:strm |		self repositoryGroup repositories do: [:repo |			strm nextPutAll: (self possiblyNewerVersionsIn: repo)]]! !!MCWorkingCopy methodsFor: 'private' stamp: 'bf 9/8/2005 10:58' prior: 23629991!possiblyNewerVersionsIn: aRepository	^aRepository possiblyNewerVersionsOfAnyOf: self ancestors! !!MCWorkingCopy methodsFor: 'printing' stamp: 'kph 2/14/2007 11:54'!printOn: streamsuper printOn: stream.stream space.self description printOn: stream.! !!MCWorkingCopy methodsFor: 'operations' stamp: 'kph 5/12/2007 01:22'!recompilePackage	self packageInfo methods		do: [:ea | ea actualClass recompile: ea methodSymbol]		displayingProgress: 'Recompiling...'! !!MCWorkingCopy methodsFor: 'repositories' stamp: 'kph 12/8/2008 04:46'!repository	^ repository! !!MCWorkingCopy methodsFor: 'repositories' stamp: 'kph 12/13/2008 17:58'!repository: aRepo	aRepo ifNil: [ ^ self ].	self packageInfo propertyAt: #repository put: aRepo description.			repository := aRepo! !!MCWorkingCopy methodsFor: 'repositories' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23628409!repositoryGroup	^ repositoryGroup ifNil: [repositoryGroup := MCRepositoryGroup new]! !!MCWorkingCopy methodsFor: 'repositories' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23628581!repositoryGroup: aRepositoryGroup	repositoryGroup := aRepositoryGroup! !!MCWorkingCopy methodsFor: 'private' stamp: 'ab 8/24/2003 20:38' prior: 23630158!requestVersionNameAndMessageWithSuggestion: aString	^ (MCVersionNameAndMessageRequest new suggestedName: aString) signal! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 1/20/2004 16:04' prior: 23623497!requirePackage: aPackage	(self requiredPackages includes: aPackage) ifFalse: [requiredPackages add: aPackage]! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23623336!requiredPackages	^ requiredPackages ifNil: [requiredPackages := OrderedCollection new]! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'kph 12/13/2008 18:05'!setMyRepositoryFromLastAdded	self repository: self repositoryGroup lastAdded.! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'kph 2/12/2009 00:48'!trimAncestry	 	self ancestry ancestors do: [ :ea | ea trimAfterVersionInfo: ea ]! !!MCWorkingCopy methodsFor: 'private' stamp: 'kph 1/28/2008 02:23' prior: 23630362!uniqueVersionName	|version | 	 	version := nil.	[version  := self nextVersionNameHaveAlreadyTried: version .	self repositoryGroup includesVersionNamed: version name ] whileTrue.	^ version name! !!MCWorkingCopy methodsFor: 'operations' stamp: 'kph 12/7/2008 02:31' prior: 23628250!unload	MCPackageLoader newCurrent unloadPackage: self package.	self unregister.! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23623692!versionInfo: aVersionInfo	ancestry := MCWorkingAncestry new addAncestor: aVersionInfo! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 05:04'!adopt: aVersion! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 05:03'!backportChangesTo: aVersionInfo! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 05:08'!canBackport	^ false! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 15:40'!description	^ self packageNameWithStar, ' ( ', self package orphans size printString, ' orphans ', (self package unlinkedCount > 0 ifTrue: [ self package unlinkedCount printString, ' unlinked )' ] ifFalse: [ ')' ])! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/13/2007 01:05'!isOrphanage	^ true! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 05:05'!merge: targetVersion! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2007 07:19'!myMenu: aMenu inBrowser: browser	 		browser fillMenu: aMenu fromSpecs:		#(			 			('browse orphans' #browseWorkingCopy) 			('reload orphans' #recompilePackage)			('clearOrphans' 	  #clearOrphans)			('explore orphans' #exploreWorkingCopy)			('recompile all packages' #recompileAllPackages)			('fix all obsolete references' #fixAllObsoleteReferences )).				 	^ aMenu! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/13/2007 00:57'!recompilePackage		"for the orphanage this means attempt to re-home them"		 	self package snapshot install.! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 05:04'!unload! !!MCPasswordManager commentStamp: '<historical>' prior: 0!Simple password manager to avoid storing passwords in the image.!!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 15:23'!default	^Default ifNil:[Default := self new]! !!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 16:53'!editPasswords	^self default editPasswords! !!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 16:14'!passwordAt: location user: user	^self default passwordAt: location user: user! !!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 16:14'!passwordAt: location user: user put: password	^self default passwordAt: location user: user put: password! !!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 16:37'!queryPasswordAt: location user: user	^self default queryPasswordAt: location user: user! !!MCPasswordManager methodsFor: 'accessing' stamp: 'bf 11/7/2005 14:58'!directory	"Answer the directory in which to find the passwords"	^directory ifNil:[ExternalSettings assuredPreferenceDirectory]! !!MCPasswordManager methodsFor: 'accessing' stamp: 'ar 11/4/2005 15:01'!directory: aDirectory	"Indicate the directory in which to find the passwords"	directory := aDirectory! !!MCPasswordManager methodsFor: 'editing' stamp: 'ar 11/4/2005 16:48'!editPasswords	"Edit the passwords"	(self directory fileNamesMatching: '*.pwd') do:[:fName|		self editPasswordsIn: (self directory fullNameFor: fName).	].! !!MCPasswordManager methodsFor: 'editing' stamp: 'ar 11/4/2005 16:53'!editPasswordsIn: pwdFile	"Edit the passwords"	| file data |	file := FileStream readOnlyFileNamed: pwdFile.	data := file contents.	file close.	UIManager default edit: data label: pwdFile accept:[:text|		file := FileStream forceNewFileNamed: pwdFile.		file nextPutAll: text asString.		file close.	].! !!MCPasswordManager methodsFor: 'queries' stamp: 'ar 11/4/2005 17:14'!passwordAt: location user: user	"Answer the password stored under the given key, or nil if none can be found"	| file stream tokens pwdFile |	(location indexOf: Character space) = 0 		ifFalse:[^self error: 'Location must not contain spaces'].	(user indexOf: Character space) = 0 		ifFalse:[^self error: 'User name must not contain spaces'].	pwdFile := user,'.pwd'.	file := [self directory readOnlyFileNamed: pwdFile] on: Error do:[:ex| ex return: nil].	file ifNil:[^nil].	[stream := file contents readStream] ensure:[file close].	[stream atEnd] whileFalse:[		tokens := stream nextLine findTokens: ' '.		(tokens size = 2 and:[tokens first match: location]) ifTrue:[			^(Base64MimeConverter mimeDecode: tokens last as: String)		].	].	^nil! !!MCPasswordManager methodsFor: 'queries' stamp: 'kph 6/3/2008 11:36'!passwordAt: location user: user put: password	"Store the password under the given key"	| file tokens pwd in out done sz pwdFile |	user ifNil:[ ^ self ].	(location indexOf: Character space) = 0 		ifFalse:[^self error: 'Key must not contain spaces'].	(user indexOf: Character space) = 0 		ifFalse:[^self error: 'Key must not contain spaces'].	password ifNotNil:[		pwd := (Base64MimeConverter mimeEncode: password readStream) contents.	].	pwdFile := user,'.pwd'.	file := [self directory readOnlyFileNamed: pwdFile] on: Error do:[:ex| ex return: nil].	file ifNotNil:[		[in := file contents readStream] ensure:[file close].	] ifNil:[in := String new readStream].	out := WriteStream on: (String new: 1000).	done := pwd == nil. "if clearing passwords, we're done already"	[in atEnd] whileFalse:[		tokens := in nextLine findTokens: ' '.		tokens size = 2 ifTrue:[			(tokens first match: location) 				ifTrue:[pwd ifNotNil:[out nextPutAll: location; space; nextPutAll: pwd; cr. done := true]]				ifFalse:[out nextPutAll: tokens first; space; nextPutAll: tokens last; cr]]].	done ifFalse:[out nextPutAll: location; space; nextPutAll: pwd; cr].	file := [self directory forceNewFileNamed: pwdFile] on: Error do:[:ex| ex return: nil].	file ifNil:[^nil].	[file nextPutAll: out contents.	sz := file size] ensure:[file close].	sz = 0 ifTrue:[self directory deleteFileNamed: pwdFile ifAbsent:[]].! !!MCPasswordManager methodsFor: 'queries' stamp: 'kph 12/19/2007 00:18'!queryPasswordAt: location user: user	"Answer the password for the given user/location. 	If the password is absent, query the user if interactive."	| pwd |	"search for existing password" 	pwd := self passwordAt: location user: user.	pwd ifNotNil:[^pwd].	user = 'squeak' ifTrue: [ ^ 'squeak' ].	user = '' ifTrue: [ ^ 'squeak' ].	pwd := FillInTheBlank requestPassword: 'Password for "', user, '" at ', location.	pwd isEmptyOrNil ifTrue:[^nil].	(self confirm: 'Remember password for "', user, '" at ', location,'?') ifTrue:[		self passwordAt: location user: user put: pwd.	].	^pwd	 ! !!MCPatch class methodsFor: 'as yet unclassified' stamp: 'mtf 10/7/2008 13:01' prior: 23434440!fromBase: baseSnapshot target: targetSnapshot	^ self new initializeWithBase: baseSnapshot definitionIndex		target: targetSnapshot definitionIndex! !!MCPatch class methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 15:50' prior: 23434637!operations: aCollection	^ self basicNew initializeWithOperations: aCollection! !!MCPatch methodsFor: 'applying' stamp: 'ab 5/24/2003 16:12' prior: 23433129!applyTo: anObject	operations do: [:ea | ea applyTo: anObject].! !!MCPatch methodsFor: 'ui' stamp: 'cwp 8/2/2003 13:34' prior: 23434208!browse	^ (MCPatchBrowser forPatch: self) show! !!MCPatch methodsFor: 'intializing' stamp: 'mtf 10/7/2008 11:39' prior: 23433275!initializeWithBase: base target: target"Generates operation from the given MCDefinitionIndexes"	operations := OrderedCollection new.		target definitions do:		[:t |		base			definitionLike: t			ifPresent: [:b | (b isSameRevisionAs: t) ifFalse: [operations add: (MCModification of: b to: t)]]			ifAbsent: [operations add: (MCAddition of: t)]]		displayingProgress: 'Diffing...'.			base definitions do:		[:b |		target			definitionLike: b			ifPresent: [:t]			ifAbsent: [operations add: (MCRemoval of: b)]]		! !!MCPatch methodsFor: 'intializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23433987!initializeWithOperations: aCollection	operations := aCollection! !!MCPatch methodsFor: 'querying' stamp: 'cwp 6/9/2003 11:53' prior: 23434118!isEmpty	^ operations isEmpty! !!MCPatch methodsFor: 'accessing' stamp: 'ab 5/13/2003 12:18' prior: 23433038!operations	^ operations! !!MCAddition class methodsFor: 'as yet unclassified' stamp: 'cwp 11/27/2002 10:03' prior: 23200218!of: aDefinition	^ self new intializeWithDefinition: aDefinition! !!MCAddition methodsFor: 'accessing' stamp: 'ab 5/24/2003 16:11' prior: 23198670!applyTo: anObject	anObject addDefinition: definition! !!MCAddition methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:09' prior: 23198792!baseDefinition	^ nil! !!MCAddition methodsFor: 'accessing' stamp: 'cwp 11/27/2002 09:32' prior: 23198885!definition	^ definition! !!MCAddition methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:45' prior: 23198979!fromSource	^ ''! !!MCAddition methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23199873!intializeWithDefinition: aDefinition	definition := aDefinition! !!MCAddition methodsFor: 'as yet unclassified' stamp: 'ab 8/22/2003 02:26' prior: 23199629!inverse	^ MCRemoval of: definition! !!MCAddition methodsFor: 'testing' stamp: 'cwp 11/28/2002 07:22' prior: 23200007!isAddition	^ true! !!MCAddition methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 17:28' prior: 23199744!isClassPatch	^definition isClassDefinition! !!MCAddition methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:39' prior: 23199065!sourceString	^(self toSource asText)		addAttribute: TextColor red;		yourself! !!MCAddition methodsFor: 'accessing' stamp: 'ab 5/13/2003 12:18' prior: 23199214!summary	^ definition summary! !!MCAddition methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:17' prior: 23199313!targetClass	^definition actualClass ! !!MCAddition methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:09' prior: 23199419!targetDefinition	^ definition! !!MCAddition methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:45' prior: 23199519!toSource	^ definition source! !!MCModification class methodsFor: 'as yet unclassified' stamp: 'cwp 11/28/2002 07:19' prior: 23406434!of: base to: target	^ self new initializeWithBase: base target: target! !!MCModification methodsFor: 'accessing' stamp: 'ab 5/24/2003 16:12' prior: 23404290!applyTo: anObject	anObject modifyDefinition: obsoletion to: modification! !!MCModification methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:10' prior: 23404436!baseDefinition	^ obsoletion! !!MCModification methodsFor: 'accessing' stamp: 'cwp 11/28/2002 06:55' prior: 23404540!definition	^ modification! !!MCModification methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:44' prior: 23404640!fromSource	^ obsoletion source! !!MCModification methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23406051!initializeWithBase: base target: target	obsoletion := base.	modification := target.! !!MCModification methodsFor: 'as yet unclassified' stamp: 'ab 8/22/2003 02:27' prior: 23405478!inverse	^ MCModification of: modification to: obsoletion! !!MCModification methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 17:29' prior: 23405619!isClassPatch	^obsoletion isClassDefinition! !!MCModification methodsFor: 'testing' stamp: 'cwp 11/28/2002 07:23' prior: 23406211!isModification	^ true! !!MCModification methodsFor: 'accessing' stamp: 'cwp 11/27/2002 09:46' prior: 23404747!modification	^ modification! !!MCModification methodsFor: 'accessing' stamp: 'cwp 11/27/2002 09:48' prior: 23404851!obsoletion	^ obsoletion! !!MCModification methodsFor: 'as yet unclassified' stamp: 'nk 11/10/2003 21:44' prior: 23405747!printAnnotations: request on: aStream	aStream nextPutAll: 'old: '.	obsoletion printAnnotations: request on: aStream.	aStream cr.	aStream nextPutAll: 'new: '.	modification printAnnotations: request on: aStream.! !!MCModification methodsFor: 'accessing' stamp: 'nk 10/21/2003 22:54' prior: 23404950!summarySuffix	^self fromSource = self toSource		ifTrue: [ ' (source same but rev changed)' ]		ifFalse: [ ' (changed)' ]! !!MCModification methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:18' prior: 23405146!targetClass	^ obsoletion actualClass! !!MCModification methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:10' prior: 23405256!targetDefinition	^ modification! !!MCModification methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:44' prior: 23405362!toSource	^ modification source! !!MCPatchOperation methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:11' prior: 23442772!<= other	^ self definition <= other definition! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 11/10/2003 21:38' prior: 23440183!annotations	^self annotations: Preferences defaultAnnotationRequests! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 11/10/2003 21:39' prior: 23440329!annotations: requests	"Answer a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	^String streamContents: [ :s | self printAnnotations: requests on: s ].! !!MCPatchOperation methodsFor: 'accessing' stamp: 'cwp 11/28/2002 06:59' prior: 23440787!definition	^ self subclassResponsibility ! !!MCPatchOperation methodsFor: 'accessing' stamp: 'cwp 11/27/2002 09:26' prior: 23440907!inverse	self subclassResponsibility! !!MCPatchOperation methodsFor: 'testing' stamp: 'cwp 11/27/2002 09:30' prior: 23442896!isAddition	^ false! !!MCPatchOperation methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 17:28' prior: 23442548!isClassPatch	^false! !!MCPatchOperation methodsFor: 'testing' stamp: 'cwp 11/27/2002 09:30' prior: 23442991!isModification	^ false! !!MCPatchOperation methodsFor: 'testing' stamp: 'cwp 11/27/2002 09:30' prior: 23443090!isRemoval	^ false! !!MCPatchOperation methodsFor: 'accessing' stamp: 'avi 8/31/2003 17:53' prior: 23441020!prefixForOperation: aSymbol	aSymbol == #insert ifTrue: [^ '+'].	aSymbol == #remove ifTrue: [^ '-'].	^ ' '! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 11/10/2003 21:40' prior: 23441205!printAnnotations: requests on: aStream	"Add a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	self definition printAnnotations: requests on: aStream.! !!MCPatchOperation methodsFor: 'accessing' stamp: 'avi 8/31/2003 17:55' prior: 23441660!source	^ self sourceText! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 2/25/2005 17:26' prior: 23441761!sourceString	^self sourceText asString! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 2/25/2005 17:29' prior: 23441876!sourceText	| builder |	builder := (Preferences diffsWithPrettyPrint and: [ self targetClass notNil and: [ self isClassPatch not ] ])				ifTrue: 					[PrettyTextDiffBuilder 						from: self fromSource						to: self toSource						inClass: self targetClass]				ifFalse: [TextDiffBuilder from: self fromSource to: self toSource].	^builder buildDisplayPatch.! !!MCPatchOperation methodsFor: 'accessing' stamp: 'ab 7/6/2003 00:06' prior: 23442313!summary	^ self definition summary, self summarySuffix! !!MCPatchOperation methodsFor: 'accessing' stamp: 'ab 7/6/2003 00:06' prior: 23442442!summarySuffix	^ ''! !!MCPatchOperation methodsFor: 'as yet unclassified' stamp: 'nk 2/23/2005 18:17' prior: 23442654!targetClass	self subclassResponsibility.! !!MCRemoval class methodsFor: 'as yet unclassified' stamp: 'cwp 11/27/2002 10:03' prior: 23451312!of: aDefinition	^ self new intializeWithDefinition: aDefinition! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 5/24/2003 16:11' prior: 23449623!applyTo: anObject	anObject removeDefinition: definition! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:10' prior: 23449747!baseDefinition	^ definition! !!MCRemoval methodsFor: 'accessing' stamp: 'cwp 11/27/2002 10:02' prior: 23449846!definition	^ definition! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:44' prior: 23449939!fromSource	^ definition source! !!MCRemoval methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23450971!intializeWithDefinition: aDefinition	definition := aDefinition! !!MCRemoval methodsFor: 'as yet unclassified' stamp: 'ab 8/22/2003 02:26' prior: 23450728!inverse	^ MCAddition of: definition! !!MCRemoval methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 17:28' prior: 23450843!isClassPatch	^definition isClassDefinition! !!MCRemoval methodsFor: 'testing' stamp: 'cwp 11/28/2002 07:24' prior: 23451104!isRemoval	^ true! !!MCRemoval methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:38' prior: 23450039!sourceString	^self fromSource asText		addAttribute: TextEmphasis struckOut;		addAttribute: TextColor blue;		yourself! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 5/13/2003 12:22' prior: 23450228!summary	^ definition summary, ' (removed)'! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 7/6/2003 00:05' prior: 23450339!summarySuffix	^ ' (removed)'! !!MCRemoval methodsFor: 'accessing' stamp: 'nk 2/25/2005 17:23' prior: 23450437!targetClass	^ definition actualClass! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:10' prior: 23450542!targetDefinition	^ nil! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:44' prior: 23450634!toSource	^ ''! !!MCPatcher class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23445269!apply: aPatch to: aSnapshot	| loader |	loader := self snapshot: aSnapshot.	aPatch applyTo: loader.	^ loader patchedSnapshot! !!MCPatcher class methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 14:22' prior: 23445480!snapshot: aSnapshot	^ self new initializeWithSnapshot: aSnapshot! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:46' prior: 23444362!addDefinition: aDefinition	definitions add: aDefinition! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23444509!initializeWithSnapshot: aSnapshot	definitions := MCDefinitionIndex definitions: aSnapshot definitions! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 14:23' prior: 23444689!modifyDefinition: baseDefinition to: targetDefinition	self addDefinition: targetDefinition! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'ab 7/6/2003 23:48' prior: 23444858!patchedSnapshot	^ MCSnapshot fromDefinitions: definitions definitions! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:46' prior: 23445006!removeDefinition: aDefinition	definitions remove: aDefinition! !!MCReader class methodsFor: 'testing' stamp: 'avi 1/21/2004 19:00' prior: 23448878!canReadFileNamed: fileName	^ (fileName endsWith: self extension)! !!MCReader class methodsFor: 'testing' stamp: 'avi 1/21/2004 19:01' prior: 23449016!concreteSubclasses	^ self allSubclasses reject: [:c | c isAbstract]! !!MCReader class methodsFor: 'testing' stamp: 'avi 1/21/2004 19:01' prior: 23449157!isAbstract	^ (self respondsTo: #extension) not! !!MCReader class methodsFor: 'instance creation' stamp: 'avi 1/21/2004 19:02' prior: 23448484!on: aStream	^ self new stream: aStream! !!MCReader class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23448617!on: aStream name: aFileName	| class |	class := self readerClassForFileNamed: aFileName.	^ class		ifNil: [self error: 'Unsupported format: ', aFileName]		ifNotNil: [class on: aStream]! !!MCReader class methodsFor: 'testing' stamp: 'avi 1/21/2004 19:03' prior: 23449277!readerClassForFileNamed: fileName	^ self concreteSubclasses		detect: [:c | c canReadFileNamed: fileName]		ifNone: [nil]! !!MCReader methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23448070!stream: aStream	stream := aStream! !!MCSnapshotReader class methodsFor: 'as yet unclassified' stamp: 'avi 1/21/2004 22:56' prior: 23515630!snapshotFromStream: aStream	^ (self on: aStream) snapshot! !!MCSnapshotReader methodsFor: 'as yet unclassified' stamp: 'avi 1/21/2004 23:09' prior: 23515213!definitions	definitions ifNil: [self loadDefinitions].	^ definitions! !!MCSnapshotReader methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:21' prior: 23515370!snapshot	snapshot ifNil: [self loadSnapshot].	^ snapshot! !!MCCsReader commentStamp: 'abc 7/4/2007 01:25' prior: 0!In order to designate a changeset for loading with Monticello use the extension .mcs Monticello does not execute preambles or postscripts.!!MCCsReader class methodsFor: 'as yet unclassified' stamp: 'abc 7/4/2007 01:17'!extension	^ 'mcs'! !!MCStReader class methodsFor: 'as yet unclassified' stamp: 'avi 1/20/2004 00:17' prior: 23525402!extension	^ 'st'! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:52' prior: 23520676!addDefinitionsFromDoit: aString	(MCDoItParser forDoit: aString) ifNotNilDo:		[:parser |		parser addDefinitionsTo: definitions]! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23520897!categoryFromDoIt: aString	| tokens  |	tokens := Scanner new scanTokens: aString.	tokens size = 3 ifFalse: [self error: 'Unrecognized category definition'].	^ tokens at: 3! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23521163!classDefinitionFrom: aPseudoClass	| tokens traitCompositionString lastIndex classTraitCompositionString |	tokens := Scanner new scanTokens: aPseudoClass definition.	traitCompositionString := ((ReadStream on: aPseudoClass definition)		match: 'uses:';		upToAll: 'instanceVariableNames:') withBlanksTrimmed.	classTraitCompositionString := ((ReadStream on: aPseudoClass metaClass definition asString)		match: 'uses:';		upToAll: 'instanceVariableNames:') withBlanksTrimmed.	traitCompositionString isEmpty ifTrue: [traitCompositionString := '{}'].	classTraitCompositionString isEmpty ifTrue: [classTraitCompositionString := '{}'].	lastIndex := tokens size.	^ MCClassDefinition		name: (tokens at: 3)		superclassName: (tokens at: 1)		traitComposition: traitCompositionString		classTraitComposition: classTraitCompositionString		category: (tokens at: lastIndex)		instVarNames: ((tokens at: lastIndex - 6) findTokens: ' ')		classVarNames: ((tokens at: lastIndex - 4) findTokens: ' ')		poolDictionaryNames: ((tokens at: lastIndex - 2) findTokens: ' ')		classInstVarNames: (self classInstVarNamesFor: aPseudoClass)		type: (self typeOfSubclass: (tokens at: 2))		comment: (self commentFor: aPseudoClass)		commentStamp: (self commentStampFor: aPseudoClass)! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23522520!classInstVarNamesFor: aPseudoClass	| tokens |		self flag: #traits.	aPseudoClass metaClass hasDefinition ifFalse: [^ #()].	tokens := Scanner new scanTokens: aPseudoClass metaClass definition.	"tokens size = 4 ifFalse: [self error: 'Unrecognized metaclass definition']."	^ tokens last findTokens: ' '! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23522917!commentFor: aPseudoClass	| comment |	comment := aPseudoClass organization classComment.	^ comment asString = ''		ifTrue: [comment]		ifFalse: [comment string]! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23523171!commentStampFor: aPseudoClass	| comment |	comment := aPseudoClass organization classComment.	^  [comment stamp] on: MessageNotUnderstood do: [nil]! !!MCStReader methodsFor: 'evaluating' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23524559!loadDefinitions	| filePackage |	filePackage :=		FilePackage new			fullName: 'ReadStream';			fileInFrom: self readStream.	definitions := OrderedCollection new.	filePackage classes do:		[:pseudoClass |		pseudoClass hasDefinition			ifTrue: [definitions add:					(self classDefinitionFrom: pseudoClass)].		definitions addAll: (self methodDefinitionsFor: pseudoClass).		definitions addAll: (self methodDefinitionsFor: pseudoClass metaClass)].	filePackage doIts do:		[:ea |		self addDefinitionsFromDoit: ea string].	! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'avi 3/3/2004 15:23' prior: 23523400!methodDefinitionsFor: aPseudoClass	^ aPseudoClass selectors collect: 		[:ea |		 MCMethodDefinition			className: aPseudoClass name			classIsMeta: aPseudoClass isMeta			selector: ea			category: (aPseudoClass organization categoryOfElement: ea)			timeStamp: (aPseudoClass stampAt: ea)			source: (aPseudoClass sourceCodeAt: ea)]! !!MCStReader methodsFor: 'evaluating' stamp: 'avi 1/21/2004 14:21' prior: 23525158!readStream	^ ('!!!!', stream contents) readStream! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23523825!systemOrganizationFromRecords: changeRecords	| categories |	categories := changeRecords					select: [:ea | 'SystemOrganization*' match: ea string]					thenCollect: [:ea | (self categoryFromDoIt: ea string)].	^ categories isEmpty ifFalse: [MCOrganizationDefinition categories: categories asArray]! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'avi 1/19/2004 21:56' prior: 23524206!typeOfSubclass: aSymbol	#(		(subclass: normal)		(variableSubclass: variable)		(variableByteSubclass: bytes)		(variableWordSubclass: words)		(weakSubclass: weak)		) do: [:ea | ea first = aSymbol ifTrue: [^ ea second]].	self error: 'Unrecognized class definition'! !!MCVersionReader class methodsFor: 'file services' stamp: 'kph 2/11/2009 16:12' prior: 23610001!initialize	"MCVersionReader initialize"	Smalltalk 		at: #MczInstaller		ifPresent: [:installer | FileList unregisterFileReader: installer].	self freeSomeSpace.! !!MCMcmReader class methodsFor: 'instance creation' stamp: 'kph 2/11/2009 18:50'!initialize	self register! !!MCMcmReader class methodsFor: 'accessing' stamp: 'bf 3/22/2005 10:47' prior: 23350425!extension	^ 'mcm'! !!MCMcmReader class methodsFor: 'instance creation' stamp: 'kph 8/2/2007 02:38'!loadVersionFile: fileName 	(self versionFromFile: fileName) load! !!MCMcmReader class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23350541!on: aStream fileName: aFileName	| reader |	reader := self on: aStream.	reader fileName: aFileName.	^reader! !!MCMcmReader class methodsFor: 'instance creation' stamp: 'kph 8/2/2007 02:22'!versionFromFile: fileName	^ self file: fileName streamDo: [:aStream | (self on: aStream fileName: fileName) version ]! !!MCMcmReader methodsFor: 'accessing' stamp: 'kph 8/1/2007 12:25'!browseVersionFrom: aRepository	self version browse! !!MCMcmReader methodsFor: 'accessing' stamp: 'bf 3/23/2005 01:17' prior: 23349813!configurationName	^fileName ifNotNil: [(fileName findTokens: '/\:') last copyUpToLast: $.]! !!MCMcmReader methodsFor: 'accessing' stamp: 'bf 3/23/2005 01:17' prior: 23349975!fileName: aString	fileName := aString! !!MCMcmReader methodsFor: 'accessing' stamp: 'kph 8/1/2007 02:11'!info	^ self  ! !!MCMcmReader methodsFor: 'accessing' stamp: 'kph 8/1/2007 12:16'!loadVersionFrom: aRepository	self version load! !!MCMcmReader methodsFor: 'accessing' stamp: 'kph 8/1/2007 12:54'!mergeVersionFrom: aRepository	self version merge! !!MCMcmReader methodsFor: 'accessing' stamp: 'kph 8/1/2007 02:13'!summary	| s |		s := 'Monticello Configuration: ', fileName, '', (self version summary).	stream reset.	^ s! !!MCMcmReader methodsFor: 'accessing' stamp: 'kph 8/1/2007 02:06' prior: 23350084!version	| configuration |	stream reset.	configuration := MCConfiguration fromArray: (MCScanner scan: stream).	configuration name: self configurationName.	^configuration! !!MCMcmReader methodsFor: 'MonticelloConfigurations' stamp: 'mtf 10/8/2008 00:16'!versionFromFile: fileName	^ self file: fileName streamDo: [:aStream | (self on: aStream fileName: fileName) version ]! !!MCMczReader class methodsFor: 'accessing' stamp: 'kph 2/11/2009 18:50'!initialize		self register! !!MCMcdReader class methodsFor: 'as yet unclassified' stamp: 'kph 2/11/2009 18:50'!initialize		self register! !!MCMcdReader class methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:09' prior: 23347816!extension	^ 'mcd'! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'avi 2/14/2004 21:33' prior: 23346191!baseInfo	^ baseInfo ifNil: [self loadBaseInfo]! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:41' prior: 23346320!basicVersion	^ MCDiffyVersion		package: self package		info: self info		dependencies: self dependencies		baseInfo: self baseInfo		patch: self patch! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'avi 2/14/2004 21:37' prior: 23346554!buildPatchFrom: oldDefinitions to: newDefinitions	^ MCPatch		fromBase: (MCSnapshot fromDefinitions: oldDefinitions)		target: (MCSnapshot fromDefinitions: newDefinitions)! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23346819!loadBaseInfo	^ baseInfo := self extractInfoFrom: (self parseMember: 'base')! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23346988!loadPatch	| old new |	(self zip memberNamed: 'patch.bin') ifNotNilDo:		[:m | [^ patch := (DataStream on: m contentStream) next ]			on: Error do: [:fallThrough ]].	definitions := OrderedCollection new.	(self zip membersMatching: 'old/*')		do: [:m | self extractDefinitionsFrom: m].	old := definitions asArray.	definitions := OrderedCollection new.	(self zip membersMatching: 'new/*')		do: [:m | self extractDefinitionsFrom: m].	new := definitions asArray.	^ patch := self buildPatchFrom: old to: new.	! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'avi 2/14/2004 21:34' prior: 23347584!patch	^ patch ifNil: [self loadPatch]! !!MCMczReader class methodsFor: 'accessing' stamp: 'cwp 8/1/2003 14:59' prior: 23358315!extension	^ 'mcz'! !!MCMczReader class methodsFor: 'testing' stamp: 'avi 1/19/2004 14:48' prior: 23358410!supportsDependencies	^ true! !!MCMczReader class methodsFor: 'testing' stamp: 'cwp 8/1/2003 12:19' prior: 23358513!supportsVersions	^ true! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23354947!associate: tokens	| result |	result := Dictionary new.	tokens pairsDo: [:key :value | 					value isString ifFalse: [value := value collect: [:ea | self associate: ea]].					result at: key put: value].	^ result! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 02:25'!basicVersion	| v |		v := super basicVersion.		self loadFiles.		^ v ! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 1/16/2009 13:36' prior: 23355255!extractDefinitionsFrom: member	| reader |	(MCSnapshotReader readerClassForFileNamed: member fileName)		ifNotNilDo: [:rc | reader := rc on: member contentStream text.					snapshot definitions addAll: reader definitions]! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'avi 1/19/2004 16:11' prior: 23355551!extractDependencyFrom: zipMember	^ MCVersionDependency		package: (MCPackage named: (zipMember fileName copyAfterLast: $/))		info: (self extractInfoFrom: (self parseMember: zipMember fileName))! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 00:54'!extractFileFrom: member	definitions add: (MCFileDefinition new 		path: member fileName;		uuid: ((member fileName readStream upTo: $/; yourself) upTo: $/);		fileSize: member uncompressedSize;		yourself)! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'mtf 1/18/2008 10:11' prior: 23355828!extractInfoFrom: dict	^ self infoCache at: (dict at: #id) ifAbsentPut:		[MCVersionInfo			name: (dict at: #name ifAbsent: [''])			id: (UUID fromString: (dict at: #id))			message: (dict at: #message ifAbsent: [''])			date: ([Date fromString: (dict at: #date) ] on: Error do: [ :ex | ex return: nil ])			time: ([ Time fromString:(dict at: #time)] on: Error do: [ :ex | ex return: nil ])			author: (dict at: #author ifAbsent: [''])			ancestors: (dict at: #ancestors ifPresent: [:ancestors |				ancestors collect: [:ea | self extractInfoFrom: ea]])			stepChildren: ((dict at: #stepChildren ifAbsent: [#()]) collect: [:ea | self extractInfoFrom: ea])]! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23356539!infoCache	^ infoCache ifNil: [infoCache := Dictionary new]! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 00:56' prior: 23356691!loadDefinitions	definitions := self snapshot definitions! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23357103!loadDependencies	dependencies := (self zip membersMatching: 'dependencies/*') collect: [:m | self extractDependencyFrom: m].	dependencies := dependencies asArray.! !!MCMczReader methodsFor: 'files' stamp: 'kph 12/7/2008 01:00'!loadFiles	| dir |	dir := MCFileDefinition cacheDir.		^ (self zip membersMatching: 'files/*') collect: [:m | m extractInDirectory: dir. m localFileName ].! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 00:01' prior: 23357361!loadPackage	| dict |	dict := self parseMember: 'package'.	package := MCPackage named: (dict at: #name)! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 1/16/2009 13:36'!loadSnapshot 	(self zip memberNamed: 'snapshot.bin') ifNotNilDo:		[:m | [^ snapshot := (DataStream on: m contentStream) next ] 			on: Error do: [:fallThrough |  self halt ]].		snapshot := MCSnapshot empty.		"otherwise"	(self zip membersMatching: 'snapshot/*')		do: [:m | self extractDefinitionsFrom: m].	(self zip membersMatching: 'files/*')		do: [:m | self extractFileFrom: m].! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23357559!loadVersionInfo	info := self extractInfoFrom: (self parseMember: 'version')! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23357728!parseMember: fileName	| tokens |	tokens := (self scanner scanTokens: (self zip contentsOf: fileName)) first.	^ self associate: tokens! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:33' prior: 23357946!scanner	^ MCScanner! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:24'!snapshot	snapshot ifNil: [self loadSnapshot].	^ snapshot! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23358059!zip	zip ifNil:		[zip := ZipArchive new.		zip readFrom: stream].	^ zip! !!MCVersionReader class methodsFor: 'reading' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23611479!file: fileName streamDo: aBlock	| file |	^ 	[file := FileStream readOnlyFileNamed: fileName.		aBlock value: file]			ensure: [file close]! !!MCVersionReader class methodsFor: 'file services' stamp: 'avi 10/15/2003 02:01' prior: 23609724!fileReaderServicesForFile: fullName suffix: suffix	self isAbstract ifTrue: [^ #()].	^ ((suffix = self extension) or: [ suffix = '*' ])		ifTrue: [self services]		ifFalse: [Array new: 0]		! !!MCVersionReader class methodsFor: 'file services' stamp: 'kph 2/11/2009 16:11'!freeSomeSpace	"get rid of AnObsoleteMCMcReader and AnObsoleteMCMcvReader"	(FileList registeredFileReaderClasses  select: [ :ea | ea isObsolete ]) do: 		[ :ea | FileList unregisterFileReader: ea ]! !!MCVersionReader class methodsFor: 'file services' stamp: 'kph 8/16/2007 17:43'!installFileNamed: filename "this method makes invocation of MczInstaller and MczReader similar" "fix for mc < 1.5" ^ self loadVersionFile: filename! !!MCVersionReader class methodsFor: 'file services' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23610505!loadVersionFile: fileName	| version |	version := self versionFromFile: fileName.	version workingCopy repositoryGroup addRepository:		(MCDirectoryRepository new directory:			(FileDirectory on: (FileDirectory dirPathFor: fileName))).	version load.! !!MCVersionReader class methodsFor: 'file services' stamp: 'cwp 8/1/2003 14:46' prior: 23610842!mergeVersionFile: fileName	(self versionFromFile: fileName) merge! !!MCVersionReader class methodsFor: 'reading' stamp: 'bf 3/23/2005 01:20' prior: 23611698!on: s fileName: f	^ self on: s! !!MCVersionReader class methodsFor: 'file services' stamp: 'cwp 8/1/2003 14:46' prior: 23610993!openVersionFile: fileName	(self versionFromFile: fileName) open! !!MCVersionReader class methodsFor: 'reading' stamp: 'kph 2/11/2009 18:50'!register	FileList unregisterFileReader: self; registerFileReader: self.! !!MCVersionReader class methodsFor: 'file services' stamp: 'BEL 2/8/2009 12:59' prior: 23613152!serviceLoadVersion	^ (SimpleServiceEntry		provider: self		label: 'load version'		selector: #loadVersionFile:		description: 'load a package version'		buttonLabel: 'load')! !!MCVersionReader class methodsFor: 'file services' stamp: 'BEL 2/8/2009 13:12' prior: 23613541!serviceMergeVersion	^ (SimpleServiceEntry		provider: self		label: 'merge version'		selector: #mergeVersionFile:		description: 'merge a package version into the image'		buttonLabel: 'merge')! !!MCVersionReader class methodsFor: 'file services' stamp: 'BEL 2/8/2009 13:12' prior: 23613911!serviceOpenVersion	^ (SimpleServiceEntry		provider: self		label: 'open version'		selector: #openVersionFile:		description: 'open a package version'		buttonLabel: 'open')! !!MCVersionReader class methodsFor: 'file services' stamp: 'avi 1/21/2004 22:55' prior: 23611143!services	^ Array 		with: self serviceLoadVersion		with: self serviceMergeVersion		with: self serviceOpenVersion! !!MCVersionReader class methodsFor: 'reading' stamp: 'cwp 7/31/2003 23:03' prior: 23611809!versionFromFile: fileName	^ self file: fileName streamDo: [:stream | self versionFromStream: stream]! !!MCVersionReader class methodsFor: 'reading' stamp: 'avi 1/21/2004 22:58' prior: 23611990!versionFromStream: aStream	^ (self on: aStream) version! !!MCVersionReader class methodsFor: 'reading' stamp: 'avi 1/21/2004 22:59' prior: 23612126!versionInfoFromStream: aStream	^ (self on: aStream) info! !!MCVersionReader methodsFor: 'accessing' stamp: 'avi 1/19/2004 16:52' prior: 23608060!basicVersion	^ MCVersion		package: self package		info: self info		snapshot: self snapshot		dependencies: self dependencies! !!MCVersionReader methodsFor: 'accessing' stamp: 'avi 1/21/2004 23:10' prior: 23608263!definitions	definitions ifNil: [self loadDefinitions].	^ definitions! !!MCVersionReader methodsFor: 'accessing' stamp: 'avi 1/19/2004 14:50' prior: 23608409!dependencies	dependencies ifNil: [self loadDependencies].	^ dependencies! !!MCVersionReader methodsFor: 'accessing' stamp: 'ab 8/20/2003 19:53' prior: 23608558!info	info ifNil: [self loadVersionInfo].	^ info! !!MCVersionReader methodsFor: 'loading' stamp: 'ab 8/20/2003 19:54' prior: 23609131!loadDefinitions	self subclassResponsibility ! !!MCVersionReader methodsFor: 'loading' stamp: 'avi 1/19/2004 14:50' prior: 23609250!loadDependencies	self subclassResponsibility ! !!MCVersionReader methodsFor: 'loading' stamp: 'ab 8/20/2003 19:54' prior: 23609369!loadPackage	self subclassResponsibility ! !!MCVersionReader methodsFor: 'loading' stamp: 'ab 8/20/2003 19:54' prior: 23609483!loadVersionInfo	self subclassResponsibility! !!MCVersionReader methodsFor: 'accessing' stamp: 'ab 8/20/2003 19:53' prior: 23608682!package	package ifNil: [self loadPackage].	^ package! !!MCVersionReader methodsFor: 'accessing' stamp: 'kph 8/2/2007 15:21' prior: 23608811!snapshot 	^ MCSnapshot fromDefinitions: self definitions! !!MCVersionReader methodsFor: 'accessing' stamp: 'avi 10/9/2003 12:38' prior: 23608943!version	^ self basicVersion! !!MCVersionReader class methodsFor: 'file services' stamp: 'cwp 8/1/2003 14:33' prior: 23611343!unload	FileList unregisterFileReader: self ! !!MCRepository commentStamp: 'kph 5/17/2007 14:31' prior: 0!MCRepository subclasses appear in the UI list of avaiable repository types if they return #description.!!MCRepository class methodsFor: 'class initialization' stamp: 'ar 11/4/2005 17:30' prior: 23458808!initialize	"self initialize"	ExternalSettings registeredClients remove: self ifAbsent:[].! !!MCDictionaryRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 12:29'!description^ 'In Memory Cache'! !!MCDictionaryRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 12:44'!morphicConfigure	| nameIt |	nameIt := FillInTheBlankMorph request: 'Name this cache:'.	^ nameIt isEmpty ifFalse: [self new description: nameIt]! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 12:56' prior: 23299114!= other	^ self == other! !!MCDictionaryRepository methodsFor: 'baseclass required' stamp: 'kph 5/16/2007 22:18' prior: 23296733!basicStoreVersion: aVersion	dictionary at: aVersion info put: aVersion! !!MCDictionaryRepository methodsFor: 'baseclass overrides' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23296902!closestAncestorVersionFor: anAncestry ifNone: errorBlock	| info |	info := anAncestry breadthFirstAncestors			detect: [:ea | self includesVersionWithInfo: ea]			ifNone: [^ errorBlock value].	^ self versionWithInfo: info! !!MCDictionaryRepository methodsFor: 'accessing' stamp: 'kph 5/16/2007 12:28' prior: 23297217!description	^ description ifNil: [ self class description ]! !!MCDictionaryRepository methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23297365!description: aString	description := aString ! !!MCDictionaryRepository methodsFor: 'baseclass overrides' stamp: 'kph 5/16/2007 22:51'!descriptionDisplay	^ 'In Memory: ', self description! !!MCDictionaryRepository methodsFor: 'accessing' stamp: 'kph 5/16/2007 22:17' prior: 23297503!dictionary	^ dictionary! !!MCDictionaryRepository methodsFor: 'accessing' stamp: 'kph 5/16/2007 22:17' prior: 23297626!dictionary: aDictionary	dictionary := aDictionary! !!MCDictionaryRepository methodsFor: 'baseclass overrides' stamp: 'kph 5/17/2007 00:23'!heldVersionInfos	^ dictionary keys! !!MCDictionaryRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 00:20'!heldVersions 	^ dictionary values! !!MCDictionaryRepository methodsFor: 'baseclass overrides' stamp: 'kph 5/16/2007 23:12' prior: 23297935!includesVersionWithInfo: aVersionInfo	"quicker implementation than inherited"	^ dictionary includesKey: aVersionInfo! !!MCDictionaryRepository methodsFor: 'initialization' stamp: 'kph 5/16/2007 22:42' prior: 23298110!initialize	dictionary := Dictionary new.! !!MCDictionaryRepository methodsFor: 'initialization' stamp: 'kph 5/16/2007 12:55'!openAndEditTemplateCopy 	| nameIt |	nameIt := FillInTheBlankMorph request: 'Rename In Memory Cache: ' initialAnswer: self description.	^ nameIt isEmpty ifFalse: [self class new description: nameIt]! !!MCDictionaryRepository methodsFor: 'baseclass required' stamp: 'kph 6/12/2008 23:01'!storeVersion: aVersion	aVersion info name: aVersion info name withBlanksTrimmed.	aVersion info allAncestorsDo: [ :each | each name: each name withBlanksTrimmed ].	^ super storeVersion: aVersion! !!MCDictionaryRepository methodsFor: 'baseclass required' stamp: 'kph 5/16/2007 22:20' prior: 23298926!versionWithInfo: aVersionInfo ifAbsent: errorBlock	^ dictionary at: aVersionInfo ifAbsent: errorBlock! !!MCSystemChangeSetsRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 14:30'!description	^ " 'System Change Sets'" nil! !!MCSystemChangeSetsRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 13:21'!ignoreMonticelloChangeSets	^ true! !!MCSystemChangeSetsRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 15:06'!isValid^ false! !!MCSystemChangeSetsRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 11:45'!morphicConfigure	 	^ self new! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 14:04'!addCSFrom: cs 		|   info |	  	info := MCSystemChangeSetVersionInfo on: cs.		dictionary 	at: info 				put: info 	 ! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 13:55'!addMCVersionFrom: cs 		| filename wc info |		self class ignoreMonticelloChangeSets ifTrue: [ ^self ].		filename := MCVersionInfoFilename filename: cs name.		wc := (MCPackage named: filename packageName) workingCopy.	info := wc ancestry infoWithName: cs name message: 'testing'.		dictionary 	at: (wc ancestry infoWithName: cs name message: 'testing') 				put: (MCVersion package: wc package info: info) 	 ! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 12:49'!initialize 	self loadFromChangeSet.	! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 12:51'!isChangeSetAMonticelloPackage: name	| number pa author |		number := name copyAfterLast: $..		number isEmpty ifTrue: [ ^ false ].		(number allSatisfy: [ :n | n isDigit ]) ifFalse: [ ^ false ].		pa := name copyUpToLast: $..		author := pa copyAfterLast: $-.		(author allSatisfy: [ :n | n isLetter ]) ifFalse: [ ^ false ].		^ true! !!MCSystemChangeSetsRepository methodsFor: 'testing' stamp: 'kph 5/17/2007 15:06'!isValid	^ false! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 13:56'!loadFromChangeSet	| |	dictionary := Dictionary new.		ChangeSet allChangeSets do: [ :cs |	 		( self isChangeSetAMonticelloPackage: cs name )				ifTrue: [ self addMCVersionFrom: cs ]				ifFalse: [ self addCSFrom: cs ]		]	! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 12:40'!loadFromChangeSetTmp	| |	dictionary := Dictionary new.		ChangeSet allChangeSets do: [ :cs |				(self isChangeSetAMonticelloPackage: cs name)						ifTrue: [ self addMCVersionFrom: cs name ]								ifFalse: [ 		 					dictionary at: (MCVersionInfo 								name: (self createMCNameFromCSName: cs name) 								id: nil "id added on copy into a proper repository" 								message: 'System Change Set: ', (cs name) 								date: Date today 								time: Time now								author: 'system' 								ancestors: #() 							 )						put: MCSystemChangeSetVersion new ]	]	! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 11:43'!openAndEditTemplateCopy! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'mtf 6/27/2008 23:22'!sortedHeldVersionInfos	^ self heldVersionInfos asSortedCollection: [ :a :b | a > b ]! !!MCFileBasedRepository commentStamp: 'kph 5/17/2007 04:42' prior: 0!For the FileBased repository we use versionInfo's as before, but they are based on only what info we can obtain from the file system and fileName. We are using instances of MCVersionInfo to represent fileNames in order that the UIdoesnt see anything special about a file based repository. This saves us special UI implementations for File based repositories."	!!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/19/2007 00:27' prior: 23211074!initialize	default := nil! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:46' prior: 23210357!cacheDirectory	^ (FileDirectory default directoryNamed: 'package-cache')		assureExistence;		yourself! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23210565!checkCacheDirectory	default notNil and: [default directory exists ifFalse: [default := nil]]! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 12:38'!creationTemplate	^'In Memory Cache'! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23210763!default	self checkCacheDirectory.	^ default ifNil: [default := self new directory: self cacheDirectory]! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:56' prior: 23210962!description	^ nil! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'bf 3/23/2005 00:52' prior: 23208623!basicStoreVersion: aVersion	(aVersion isCacheable and: [self allFileNames includes: aVersion fileName])		ifFalse: [super basicStoreVersion: aVersion]! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23208874!cacheForPackage: aPackage	packageCaches ifNil: [packageCaches := Dictionary new].	^ packageCaches at: aPackage ifAbsentPut: [MCPackageCache new]! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:15' prior: 23209108!newFileNames 	^ self allFileNames difference: self seenFileNames! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 15:13' prior: 23209261!packageForFileNamed: aString	^ self packageCache at: aString ifAbsentPut: [self versionReaderForFileNamed: aString do: [:r | r package]]! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:29' prior: 23209486!rescan	self newFileNames do:		[:ea |		self versionReaderForFileNamed: ea do:			[:reader |			(self cacheForPackage: reader package)				recordVersionInfo: reader info				forFileNamed: ea.			self seenFileNames add: ea]]		displayingProgress: 'Scanning cache...'! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23209851!seenFileNames	^ seenFiles ifNil: [seenFiles := OrderedCollection new]! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 15:05' prior: 23210009!versionInfoForFileNamed: aString	^ self infoCache at: aString ifAbsentPut: [self versionReaderForFileNamed: aString do: [:r | r info]]! !!MCDirectoryRepository class methodsFor: 'instance creation' stamp: 'ab 7/24/2003 21:20' prior: 23306122!description	^ 'directory'! !!MCDirectoryRepository class methodsFor: 'instance creation' stamp: 'ab 7/24/2003 21:01' prior: 23306243!morphicConfigure	^ FileList2 modalFolderSelector ifNotNilDo:		[:directory |		self new directory: directory]! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/31/2003 15:28' prior: 23304388!allFileNames	^ (directory entries sortBy: [:a :b | a modificationTime >= b modificationTime]) collect: [:ea | ea name]! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'mtf 6/28/2008 12:32'!creationTemplate	^ self class name, ' new directory: (FileDirectory on: ''', self description, ''')'.! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/14/2007 15:27'!delete: versionFileName		[ self directory deleteFileNamed: versionFileName ifAbsent: [ ^false ] ]		 on: Error do: [ :ex | ^ false ].		^ true! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:57' prior: 23304599!description	^ directory pathName! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'ab 7/6/2003 17:49' prior: 23304722!directory	^ directory! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23304847!directory: aDirectory	directory := aDirectory! !!MCDirectoryRepository methodsFor: 'comparing' stamp: 'ab 7/19/2003 21:40' prior: 23305880!hash	^ directory pathName hash! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'mtf 6/28/2008 13:52'!heldVersionInfos	" If you manipulate the underlying file system the caching will get you. If for example, you store your Monticello repo in a Git repo"	^ heldVersionInfos := self getHeldVersionInfos! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23304996!initialize	directory := FileDirectory default! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/14/2007 14:17'!isDeletingAllowed	^ true! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'nk 11/2/2003 10:55' prior: 23305133!isValid	^directory exists! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23305262!readStreamForFileNamed: aString do: aBlock	| file val |	file := FileStream readOnlyFileNamed: (directory fullNameFor: aString).	val := aBlock value: file.	file close.	^ val! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23305542!writeStreamForFileNamed: aString replace: aBoolean do: aBlock	| file sel |	sel := aBoolean ifTrue: [#forceNewFileNamed:] ifFalse: [#newFileNamed:].	file := FileStream perform: sel with: (directory fullNameFor: aString).	aBlock value: file.	file close.! !!MCSubDirectoryRepository commentStamp: 'nk 6/11/2004 18:56' prior: 23540269!A MCDirectoryRepository that looks in subdirectories too.!!MCSubDirectoryRepository class methodsFor: 'user interface' stamp: 'nk 6/11/2004 18:48' prior: 23543903!description	^ 'directory with subdirectories'! !!MCSubDirectoryRepository methodsFor: 'enumeration' stamp: 'nk 6/11/2004 18:55' prior: 23542775!allDirectories	| remaining dir dirs |	remaining := OrderedCollection new.	dirs := OrderedCollection new.	remaining addLast: directory.	[remaining isEmpty]		whileFalse: [dir := remaining removeFirst.			dirs add: dir.			dir entries				do: [:ent | ent isDirectory						ifTrue: [remaining								addLast: (dir directoryNamed: ent name)]]].	^ dirs! !!MCSubDirectoryRepository methodsFor: 'enumeration' stamp: 'nk 6/11/2004 20:25' prior: 23543215!allFileNames	"sorting {entry. dirName. name}"	| sorted |	sorted := SortedCollection sortBlock: [:a :b |		a first modificationTime >= b first modificationTime ].	self allDirectories		do: [:dir | dir entries				do: [:ent | ent isDirectory						ifFalse: [sorted add: {ent. dir fullName. ent name}]]].	^ sorted		collect: [:ea | ea third ]! !!MCSubDirectoryRepository methodsFor: 'user interface' stamp: 'nk 6/11/2004 18:23' prior: 23543650!description	^ directory pathName, '/*'! !!MCSubDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23540431!findFullNameForReading: aBaseName	"Answer the latest version of aBaseName"	| possible |	possible := SortedCollection sortBlock: [ :a :b | b first modificationTime < a first modificationTime ].	self allDirectories		do: [:dir | dir entries				do: [:ent | ent isDirectory						ifFalse: [							(ent name = aBaseName) ifTrue: [ possible add: {ent. dir fullNameFor: ent name}]]]].	^(possible at: 1 ifAbsent: [ ^nil ]) second! !!MCSubDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23540966!findFullNameForWriting: aBaseName	| possible split dirScore fileScore prefix fpattern parts now |	split := directory splitNameVersionExtensionFor: aBaseName.	fpattern := split first, '*'.	possible := SortedCollection sortBlock: [ :a :b |		a first = b first			ifTrue: [ a second = b second					ifFalse: [ a second < b second ]					ifTrue: [ a third fullName size < b third fullName size ]]			ifFalse: [ a first > b first ] ].	now := Time totalSeconds.	prefix := directory pathParts size.	self allDirectories do: [:dir |		parts := dir pathParts allButFirst: prefix.		dirScore := (parts select: [ :part | fpattern match: part ]) size.		fileScore := (dir entries collect: [ :ent |			(ent isDirectory not and: [ fpattern match: ent name ])				ifFalse: [ SmallInteger maxVal ]				ifTrue: [ now - ent modificationTime ]]).	"minimum age"		fileScore := fileScore isEmpty ifTrue: [ SmallInteger maxVal  ]			ifFalse: [ fileScore min ].		possible add: { dirScore. fileScore. dir } ].	^ (possible first third) fullNameFor: aBaseName! !!MCSubDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23542113!readStreamForFileNamed: aString do: aBlock	| file val |	file := FileStream readOnlyFileNamed: (self findFullNameForReading: aString).	val := aBlock value: file.	file close.	^ val! !!MCSubDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'nk 6/11/2004 20:34' prior: 23542390!writeStreamForFileNamed: aString replace: aBoolean do: aBlock 	| file |	file := aBoolean				ifTrue: [FileStream						forceNewFileNamed: (self findFullNameForReading: aString)]				ifFalse: [FileStream						newFileNamed: (self findFullNameForWriting: aString)].	aBlock value: file.	file close! !!MCFileBasedRepository class methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:58' prior: 23317369!flushAllCaches	self allSubInstancesDo: [:ea | ea flushCache].	MCFileDefinition freeSomeSpace.! !!MCFileBasedRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 12:35'!freeSomeSpace	"system request for memory cleanup (e.g. prior to an image publication)"	self flushAllCaches! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'ab 8/21/2003 00:35' prior: 23311003!allFileNames	self subclassResponsibility! !!MCFileBasedRepository methodsFor: 'filesystem' stamp: 'ab 8/21/2003 20:01' prior: 23311135!allFileNamesForVersionNamed: aString	^ self filterFileNames: self readableFileNames forVersionNamed: aString! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'kph 9/28/2007 10:29' prior: 23311336!allFileNamesOrCache	^ allFileNames ifNil: [ self allFileNames]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 02:30' prior: 23311683!basicStoreVersion: aVersion	self		writeStreamForFileNamed: aVersion fileName		do: [:s | aVersion fileOutOn: s].	aVersion isCacheable ifTrue: [ self cache at: aVersion fileName put: aVersion].! !!MCFileBasedRepository methodsFor: 'cache' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23312021!cache	^ cache ifNil: [cache := Dictionary new]! !!MCFileBasedRepository methodsFor: 'cache' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23312171!cacheAllFileNamesDuring: aBlock	allFileNames := self allFileNames.	^ aBlock ensure: [allFileNames := nil]! !!MCFileBasedRepository methodsFor: 'cache' stamp: 'bf 6/9/2005 15:47' prior: 23312368!cachedFileNames	^cache == nil		ifTrue: [#()]		ifFalse: [cache keys]! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23312541!canReadFileNamed: aString	| reader |	reader := MCVersionReader readerClassForFileNamed: aString.	^ reader notNil! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 16:40' prior: 23312748!closestAncestorVersionFor: anAncestry ifNone: errorBlock	^ self cacheAllFileNamesDuring:		[super closestAncestorVersionFor: anAncestry ifNone: errorBlock]! !!MCFileBasedRepository methodsFor: 'filesystem' stamp: 'ab 8/21/2003 20:01' prior: 23312995!filterFileNames: aCollection forVersionNamed: aString	^ aCollection select: [:ea | (self versionNameFromFileName: ea) = aString] ! !!MCFileBasedRepository methodsFor: 'cache' stamp: 'kph 9/28/2007 10:53' prior: 23313228!flushCache	cache := nil.	heldVersionInfos := nil! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 9/28/2007 10:30'!getHeldVersionInfos	^ self readableFileNames collect: [:ea | MCVersionInfoFilename filename: ea]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 9/28/2007 10:43'!heldVersionInfos	^ heldVersionInfos ifNil: [ heldVersionInfos := self getHeldVersionInfos ]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 9/28/2007 10:31'!heldVersionInfosClearCacheheldVersionInfos := nil! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 02:32'!heldVersions	self error: 'I dont plan to load every version in from disk'! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 06:03' prior: 23313343!includesVersionNamed: aString	^ self heldVersionNames includes: aString! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'avi 1/22/2004 13:34' prior: 23313506!loadVersionFromFileNamed: aString	^ self versionReaderForFileNamed: aString do: [:r | r version]! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'mtf 10/29/2008 19:17' prior: 23313695!loadVersionInfoFromFileNamed: aString	^ [ self versionReaderForFileNamed: aString do: [:r | r info]	 	] on: Error 			do: [ :ex | self error: 'Could not read ', aString. 		].! !!MCFileBasedRepository methodsFor: 'cache' stamp: 'avi 9/17/2005 16:52' prior: 23313887!maxCacheSize	^ 8! !!MCFileBasedRepository methodsFor: 'notify' stamp: 'avi 8/26/2004 14:34' prior: 23314192!notifyList	| list |	(self allFileNames includes: 'notify') ifFalse: [^ #()].	^ self readStreamForFileNamed: 'notify' do:		[:s |		s upToEnd withSqueakLineEndings findTokens: (String with: Character cr)]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'mtf 6/27/2008 23:17' prior: 23314489!possiblyNewerVersionsOfAnyOf: someVersions	| pkgs |	pkgs := Dictionary new.	someVersions do: [:aVersionInfo |		pkgs at: aVersionInfo packageName			put: aVersionInfo]. 	^[self heldVersionInfos select: [:got |		pkgs at: (got packageName) ifPresent: [:verInfo | got > verInfo]			]] on: Error do: [:ex | ex return: #()]! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'avi 9/17/2005 16:39' prior: 23315117!readableFileNames	| all cached new |	all := self allFileNamesOrCache.	"from repository"	cached := self cachedFileNames.	"in memory"	new := all difference: cached.	^ (cached asArray, new)		select: [:ea | self canReadFileNamed: ea]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 03:15'!realizeFullVersionInfo: aStubVersionInfoInstance	^ self versionInfoFromFileNamed: aStubVersionInfoInstance name! !!MCFileBasedRepository methodsFor: 'cache' stamp: 'avi 9/18/2005 22:43' prior: 23315444!resizeCache: aDictionary	[aDictionary size <= self maxCacheSize] whileFalse:		[aDictionary removeKey: aDictionary keys atRandom]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'mtf 6/27/2008 23:22'!sortedHeldVersionInfos	^ self heldVersionInfos asSortedCollection: [ :a :b | a > b ]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'mtf 6/27/2008 23:22'!sortedVersionInfosAvailableForPackageNamed: aPackageName	^ (self versionInfosAvailableForPackageNamed: aPackageName) asSortedCollection: [ :a :b | a > b ]! !!MCFileBasedRepository methodsFor: 'filesystem' stamp: 'avi 9/17/2005 23:09' prior: 23315666!versionFromFileNamed: aString	| v |	v := self cache at: aString ifAbsent: [self loadVersionFromFileNamed: aString].	self resizeCache: cache.	(v notNil and: [v isCacheable]) ifTrue: [cache at: aString put: v].	^ v! !!MCFileBasedRepository methodsFor: 'filesystem' stamp: 'avi 9/17/2005 18:37' prior: 23315975!versionInfoFromFileNamed: aString	self cache at: aString ifPresent: [:v | ^ v info].	^ self loadVersionInfoFromFileNamed: aString! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'bf 5/30/2005 22:52' prior: 23316197!versionNameFromFileName: aString	^ (aString copyUpToLast: $.) copyUpTo: $(! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'kph 8/1/2007 01:50' prior: 23316363!versionReaderForFileNamed: aString do: aBlock	^ self		readStreamForFileNamed: aString		do: [:s |			(MCVersionReader readerClassForFileNamed: aString) 				ifNil:  [ MCNoVersionInfoAvailable signal ]				ifNotNilDo: [:class | aBlock value: (class on: s fileName: aString)]]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 04:56' prior: 23316694!versionWithInfo: aStubOrRealVersionInfo ifAbsent: errorBlock	| realVersionInfo version |	 	"aVersionInfo could be a real one or a stub"		realVersionInfo := aStubOrRealVersionInfo realizeFrom: self.		(self allFileNamesForVersionNamed: realVersionInfo name) do:		[:fileName |		version := self versionFromFileNamed: fileName.		version info = realVersionInfo ifTrue: [^ version]].	^ errorBlock value! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'avi 10/31/2003 14:32' prior: 23317046!writeStreamForFileNamed: aString do: aBlock	^ self writeStreamForFileNamed: aString replace: false do: aBlock! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'avi 9/16/2003 13:57' prior: 23333848!creationTemplate	^'MCFtpRepository	host: ''modules.squeakfoundation.org''	directory: ''mc''	user: ''squeak''	password: ''squeak'''	! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'avi 9/16/2003 13:57' prior: 23334078!description	^ 'FTP'! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:02' prior: 23334190!fillInTheBlankRequest	^ 'FTP Repository:'	! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'avi 9/16/2003 13:57' prior: 23334327!host: host directory: directory user: user password: password	^ self new		host: host;		directory: directory;		user: user;		password: password! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:02' prior: 23334565!morphicConfigure	^ self fillInTheBlankConfigure! !!MCFtpRepository methodsFor: 'required' stamp: 'avi 9/16/2003 14:04' prior: 23332762!allFileNames	^ self clientDo:		[:client |		self parseDirectoryListing: client getDirectory]! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/10/2007 01:52' prior: 23331533!clientDo: aBlock	| client |	client := FTPClient openOnHostNamed: host.	client loginUser: user password: self password.	directory isEmpty ifFalse: [client changeDirectoryTo: directory].	^ [aBlock value: client] ensure: [client close]! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/14/2007 15:13'!delete: versionFileName	self clientDo: [ :ftp |					 [ ftp deleteFileNamed: versionFileName ] on: Error do: [ :ex | ^ false ].	].	^ true! !!MCFtpRepository methodsFor: 'required' stamp: 'avi 9/17/2003 12:52' prior: 23332931!description	^ 'ftp://', user, '@', host, '/', directory! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23331862!directory: dirPath	directory := dirPath! !!MCFtpRepository methodsFor: 'required' stamp: 'ar 11/4/2005 17:26'!flushPasswords	MCPasswordManager default passwordAt: 'ftp://',host user: user put: nil.! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23331999!host: hostname	host := hostname! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'kph 12/19/2007 00:14'!isDeletingAllowed	| p |	p := self password.	^ p notEmpty and: [ p ~= 'squeak' ].! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'kph 12/1/2008 20:26'!locationHost	^ host! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23332128!parseDirectoryListing: aString	| stream files line tokens |	stream := aString readStream.	files := OrderedCollection new.	[stream atEnd] whileFalse:		[line := stream nextLine.		tokens := line findTokens: ' '.		tokens size > 2 ifTrue: [files add: tokens last]].	^ files! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!password	^(MCPasswordManager default queryPasswordAt: 'ftp://',host user: user) ifNil:[^''].! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26' prior: 23332501!password: passwordString	| pwd |	passwordString isEmpty ifTrue:[pwd := nil] ifFalse:[pwd := passwordString].	MCPasswordManager default passwordAt: 'ftp://',host user: user put: pwd.! !!MCFtpRepository methodsFor: 'required' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23333073!readStreamForFileNamed: aString do: aBlock	| stream |	^ self clientDo:		[:client |		client binary.		stream := RWBinaryOrTextStream on: String new.		stream nextPutAll: (client getFileNamed: aString).		aBlock value: stream reset]! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23332650!user: userString	user := userString! !!MCFtpRepository methodsFor: 'required' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23333393!writeStreamForFileNamed: aString replace: ignoreBoolean do: aBlock	| stream |	stream := RWBinaryOrTextStream on: String new.	aBlock value: stream.	self clientDo:		[:client |		client binary.		client putFileStreamContents: stream reset as: aString]! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'mtf 7/21/2008 18:13' prior: 23343372!creationTemplate	^self creationTemplateLocation: 'http://www.squeaksource.com/mc'		user: ''		password: ''! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'bf 4/14/2005 15:27' prior: 23343573!creationTemplateLocation: location user: user password: password	^'MCHttpRepository	location: {1}	user: {2}	password: {3}' format: {location printString. user printString. password printString}! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'ab 7/24/2003 21:20' prior: 23343863!description	^ 'HTTP'! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:00' prior: 23343977!fillInTheBlankRequest	^ 'HTTP Repository:'			! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'ab 7/24/2003 21:32' prior: 23344116!location: location user: user password: password	^ self new		location: location;		user: user;		password: password! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:01' prior: 23344326!morphicConfigure	^ self fillInTheBlankConfigure! !!MCHttpRepository methodsFor: 'required' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23341830!allFileNames	| index |	index := HTTPSocket httpGet: self locationWithTrailingSlash, '?C=M;O=D' args: nil user: self user passwd: self password.	index isString ifTrue: [self error: 'Could not access ', location].	^ self parseFileNamesFromStream: index	! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26' prior: 23337841!asCreationTemplate	^self class creationTemplateLocation: location user: user password: (		(MCPasswordManager default passwordAt: location user: user) ifNil:['']	)! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'bf 11/7/2005 17:28'!creationTemplate	^ self asCreationTemplate! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/10/2007 02:17'!creationTemplate: ignored	creationTemplate := nil.! !!MCHttpRepository methodsFor: 'required' stamp: 'ab 7/24/2003 21:10' prior: 23342160!description	^ location! !!MCHttpRepository methodsFor: 'required' stamp: 'al 12/12/2005 11:06' prior: 23342259!flushCache	super flushCache.	readerCache := nil.! !!MCHttpRepository methodsFor: 'required' stamp: 'kph 5/10/2007 03:43'!flushPasswords	MCPasswordManager default passwordAt: self locationHost user: user put: nil.! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 07:49' prior: 23338222!location: aUrlString	location := (aUrlString beginsWith: 'http://') 		ifTrue: [ aUrlString ]		ifFalse: [ 'http://', aUrlString ]! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 07:50'!locationHost	| end |		(end := (location lastIndexOf: $/) - 1) < 9 ifTrue: [ ^ location ].  		^ location copyFrom: 1 to: end.! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ab 7/24/2003 22:17' prior: 23338023!locationWithTrailingSlash	^ (location endsWith: '/')		ifTrue: [location]		ifFalse: [location, '/']! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23338364!parseFileNamesFromStream: aStream	| names fullName |	names := OrderedCollection new.	[aStream atEnd] whileFalse:		[[aStream upTo: $<. {$a. $A. nil} includes: aStream next] whileFalse.		aStream upTo: $".		aStream atEnd ifFalse: [			fullName := aStream upTo: $".			names add: fullName unescapePercents]].	^ names! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'kph 4/25/2008 00:42' prior: 23338781!password	self user isEmpty ifTrue: [^''].	^(MCPasswordManager default queryPasswordAt: self locationHost user: self user) ifNil:[^'']! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/10/2007 03:42' prior: 23339380!password: passwordString	| pwd |	passwordString isEmpty ifTrue:[pwd := nil] ifFalse:[pwd := passwordString].	MCPasswordManager default passwordAt: self locationHost user: self user put: pwd.! !!MCHttpRepository methodsFor: 'required' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23342396!readStreamForFileNamed: aString do: aBlock	| contents |	contents := HTTPSocket httpGet: (self urlForFileNamed: aString) args: nil user: self user passwd: self password.	^ contents isString ifFalse: [aBlock value: contents]! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 13:08' prior: 23339518!urlForFileNamed: aString	^ self locationWithTrailingSlash, aString encodeForHTTP! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'kph 4/25/2008 00:42' prior: 23339685!user	^user ifNil: [ '' ]! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'mtf 6/9/2008 20:56' prior: 23341146!user: userString	user := userString! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23341280!versionReaderForFileNamed: aString	readerCache ifNil: [readerCache := Dictionary new].	^ readerCache at: aString ifAbsent:		[self resizeCache: readerCache.		super versionReaderForFileNamed: aString do:			[:r |			r ifNotNil: [readerCache at: aString put: r]]]	! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 23:06' prior: 23341633!versionReaderForFileNamed: aString do: aBlock	^ (self versionReaderForFileNamed: aString) ifNotNilDo: aBlock! !!MCHttpRepository methodsFor: 'required' stamp: 'kph 2/8/2009 03:05' prior: 23342708!writeStreamForFileNamed: aString replace: ignoreBoolean do: aBlock	| stream response statusLine code |	stream := RWBinaryOrTextStream on: String new.	aBlock value: stream.	response := HTTPSocket					httpPut: stream contents					to: (self urlForFileNamed: aString)					user: self user					passwd: self password.	statusLine := response copyUpTo: Character cr.	code := statusLine findTokens: ' '. 	code := code second asInteger.	(code >= 200 and: [code < 300])			ifFalse: [self error: response].			! !!MCSMCacheRepository commentStamp: 'nk 1/23/2004 09:57' prior: 23470135!I am a Monticello repository that reflects the caching of SqueakMap v2.I refer write attempts to the default MCCacheRepository.!!MCSMCacheRepository class methodsFor: 'instance creation' stamp: 'nk 1/23/2004 10:04' prior: 23472933!description	^ 'SqueakMap Cache'! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:46' prior: 23470342!allFileNames	^self allFullFileNames collect: [ :ea | self directory localNameFor: ea ]! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23470520!allFullFileNames	| cachedPackages |	cachedPackages := smCache map installedPackages select: [ :ea | ea isCached ].	^Array streamContents: [ :s |		cachedPackages do: [ :ea | | d |			d := ea cacheDirectory.			(d fileNamesMatching: '*.mcz') do: [ :fn | s nextPut: (d fullNameFor: fn) ]]]! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:40' prior: 23470889!description	^ smCache directory pathName! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:40' prior: 23471009!directory	^ smCache directory! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:40' prior: 23471118!directory: aDirectory! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:55' prior: 23471219!fullNameFor: aFileName	^self allFullFileNames detect: [ :ffn | (self directory localNameFor: ffn) = aFileName ] ifNone: []! !!MCSMCacheRepository methodsFor: 'comparing' stamp: 'nk 1/23/2004 09:55' prior: 23471691!hash	^ smCache hash! !!MCSMCacheRepository methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23472525!initialize	super initialize.	smCache := SMSqueakMap default cache.! !!MCSMCacheRepository methodsFor: 'testing' stamp: 'nk 1/23/2004 09:47' prior: 23472671!isValid	^smCache notNil and: [ self directory exists ]! !!MCSMCacheRepository methodsFor: 'file streaming' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23471808!readStreamForFileNamed: aString do: aBlock	| file fileName |	fileName := self fullNameFor: aString.	fileName ifNil: [		"assume that this will come from the cache."		^MCCacheRepository default readStreamForFileNamed: aString do: aBlock ].	file := FileStream readOnlyFileNamed: fileName.	^[ aBlock value: file ] ensure: [ file close ].! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:37' prior: 23471421!smCache	^smCache! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:45' prior: 23471517!smCache: aSMFileCache	| |	smCache := aSMFileCache.	self directory: aSMFileCache directory.! !!MCSMCacheRepository methodsFor: 'file streaming' stamp: 'nk 1/23/2004 09:57' prior: 23472233!writeStreamForFileNamed: aString replace: aBoolean do: aBlock	"Can't write into the SM cache, so..."	^MCCacheRepository default writeStreamForFileNamed: aString replace: aBoolean do: aBlock! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:36' prior: 23336918!creationTemplate	^'MCGOODSRepository	host: ''localhost''	port: 6100'! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 14:33' prior: 23337084!description	^ 'GOODS'! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:33' prior: 23337200!fillInTheBlankRequest	^ 'GOODS Repository:'! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:36' prior: 23337338!host: hostname port: portNumber	^ self new		host: hostname;		port: portNumber! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:35' prior: 23337512!morphicConfigure	^ self fillInTheBlankConfigure! !!MCGOODSRepository methodsFor: 'baseclass required' stamp: 'avi 8/26/2004 14:20' prior: 23335029!basicStoreVersion: aVersion	self root at: aVersion info put: aVersion.	self db commit.! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'mtf 6/9/2008 20:57' prior: 23335203!db	Smalltalk at: #KKDatabase ifPresent: [:classKKDatabase |	(connection isNil or: [connection isConnected not]) ifTrue: [		connection := classKKDatabase onHost:hostname port: port].	].	^ connection! !!MCGOODSRepository methodsFor: 'baseclass overides' stamp: 'avi 2/28/2004 20:35' prior: 23335473!description	^ 'goods://', hostname asString, ':', port asString! !!MCGOODSRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 01:44'!heldVersionInfos	^ self root keys  ! !!MCGOODSRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 00:23'!heldVersions	^ self root asArray  ! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23335636!host: aString	hostname := aString! !!MCGOODSRepository methodsFor: 'baseclass overides' stamp: 'avi 2/28/2004 20:17' prior: 23335944!packages	^ (self root collect: [:ea | ea package]) asSet asSortedCollection! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23336119!port: aNumber	port := aNumber! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 14:35' prior: 23336237!root	self db root ifNil: [self db root: Dictionary new].	^ self db root! !!MCGOODSRepository methodsFor: 'baseclass required' stamp: 'avi 2/28/2004 20:21' prior: 23336611!versionWithInfo: aVersionInfo ifAbsent: errorBlock	^ self root at: aVersionInfo ifAbsent: errorBlock! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 00:30' prior: 23457192!allConcreteSubclasses	^ self withAllSubclasses reject: [:ea | ea isAbstract]! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/3/2007 20:22'!clearPasswords	self allSubInstancesDo: [:ea | (ea respondsTo: #flushPasswords) ifTrue:[ ea flushPasswords ] ].! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 20:59' prior: 23457358!creationTemplate	self subclassResponsibility.! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 00:29' prior: 23457492!description	^ nil! !!MCRepository class methodsFor: 'obsolete' stamp: 'kph 5/15/2007 20:16' prior: 23458978!fetchExternalSettingsIn: dir	"no longer used"! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:05' prior: 23457599!fillInTheBlankConfigure	^ self fillInTheBlankConfigure: self creationTemplate			! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23457781!fillInTheBlankConfigure: aTemplateString	| chunk repo |		aTemplateString ifNil: [ ^ false ].	chunk := FillInTheBlankMorph 			request: self fillInTheBlankRequest			initialAnswer: aTemplateString			centerAt: Sensor cursorPoint			inWorld: World			onCancelReturn: nil			acceptOnCR: false			answerExtent: 400@120.				chunk 		ifNotNil: [ 			repo := self readFrom: chunk readStream.			repo creationTemplate: chunk. 	].	^ repo! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 20:58' prior: 23458307!fillInTheBlankRequest	self subclassResponsibility.! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 12:59' prior: 23458446!isAbstract	^ self description isNil! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'ab 7/24/2003 21:01' prior: 23458570!morphicConfigure	^ self new! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 09:04'!uiClass	^ ui ifNil: [ MCRepositoryPackagesVersionsInspector ]! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 09:05'!uiClassUseOneColumn	^ ui := MCRepositoryVersionsInspector ! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 09:05'!uiClassUseTwoColumn	^ ui := nil! !!MCRepository methodsFor: 'testing' stamp: 'ab 8/21/2003 12:36' prior: 23455987!= other	^ other species = self species and: [other description = self description]! !!MCRepository methodsFor: '' stamp: 'kph 8/1/2007 12:47'!allVersionNames 	"method for comapibility with MCConfigurations"	^ self heldVersionNames! !!MCRepository methodsFor: 'accessing' stamp: 'avi 8/31/2004 01:08' prior: 23452928!alwaysStoreDiffs	^ storeDiffs ifNil: [false]! !!MCRepository methodsFor: 'initialization' stamp: 'bkv 2/18/2004 20:48' prior: 23453056!asCreationTemplate	^ self creationTemplate! !!MCRepository methodsFor: 'required in subclasses' stamp: 'avi 8/26/2004 14:20' prior: 23453182!basicStoreVersion: aVersion	self subclassResponsibility! !!MCRepository methodsFor: 'misc' stamp: 'kph 5/16/2007 23:31'!cacheAllFileNamesDuring: aBlock 	^ aBlock value! !!MCRepository methodsFor: 'storing' stamp: 'avi 9/17/2005 16:12' prior: 23453321!closestAncestorVersionFor: anAncestry ifNone: errorBlock	anAncestry breadthFirstAncestorsDo:		[:ancestorInfo |		(self versionWithInfo: ancestorInfo) ifNotNilDo: [:v | ^ v]].	^ errorBlock value! !!MCRepository methodsFor: 'initialization' stamp: 'bkv 2/18/2004 20:46' prior: 23453600!creationTemplate	^ creationTemplate! !!MCRepository methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23453730!creationTemplate: aString	self creationTemplate ifNotNil: [ self error: 'Creation template already set for this MCRepository instance.' ].		creationTemplate := aString.! !!MCRepository methodsFor: 'accessing' stamp: 'avi 10/9/2003 12:53' prior: 23453984!description	^ self class name! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/16/2007 22:48'!descriptionDisplay	^ self description! !!MCRepository methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23454108!doAlwaysStoreDiffs	storeDiffs := true! !!MCRepository methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23454240!doNotAlwaysStoreDiffs	storeDiffs := false! !!MCRepository methodsFor: 'actions' stamp: 'ar 11/4/2005 16:58'!flushPasswords! !!MCRepository methodsFor: 'testing' stamp: 'ab 8/21/2003 12:36' prior: 23454364!hash	^ self description hash! !!MCRepository methodsFor: 'required in subclasses' stamp: 'kph 5/17/2007 00:21'!heldVersionInfos	^ self heldVersions collect: [ :ver | ver info ]! !!MCRepository methodsFor: '' stamp: 'kph 6/2/2008 19:35'!heldVersionInfosClearCache! !!MCRepository methodsFor: '' stamp: 'kph 8/1/2007 12:46'!heldVersionNames	^ self heldVersionInfos collect: [:v |  v versionName ]! !!MCRepository methodsFor: 'required in subclasses' stamp: 'kph 5/17/2007 00:22'!heldVersions	self subclassResponsibility! !!MCRepository methodsFor: 'required in subclasses' stamp: 'kph 1/28/2008 02:17' prior: 23456143!includesVersionNamed: aString	^ self heldVersionInfos anySatisfy: [:ea | ea versionName = aString]! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 00:21'!includesVersionWithInfo: aVersionInfo	^ self heldVersionInfos includes: aVersionInfo! !!MCRepository methodsFor: 'testing' stamp: 'kph 5/14/2007 13:56'!isDeletingAllowed	^ false! !!MCRepository methodsFor: 'testing' stamp: 'nk 11/2/2003 10:55' prior: 23456983!isValid	^true! !!MCRepository methodsFor: 'interface' stamp: 'lr 9/26/2003 20:03' prior: 23456273!morphicOpen	self morphicOpen: nil! !!MCRepository methodsFor: 'required in subclasses' stamp: 'mtf 6/7/2008 12:28' prior: 23456379!morphicOpen: aWorkingCopy	(self class uiClass 		repository: self 		selectedPackage: (aWorkingCopy ifNotNilDo: [ :wc |  wc package ]) 		selectedVersion: nil ) show! !!MCRepository methodsFor: 'notifications' stamp: 'avi 8/26/2004 14:27' prior: 23454568!notificationForVersion: aVersion	^ MCVersionNotification version: aVersion repository: self! !!MCRepository methodsFor: 'notifications' stamp: 'avi 8/26/2004 14:23' prior: 23454743!notifyList	^ #()! !!MCRepository methodsFor: 'initialization' stamp: 'bf 4/14/2005 17:30' prior: 23456506!openAndEditTemplateCopy	^ self class fillInTheBlankConfigure: (self asCreationTemplate ifNil: [^nil])! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 01:50'!packageNames	^ (self heldVersionInfos collect: [:ea | ea packageName]) asSet asSortedCollection! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 00:21'!packages	^ (self heldVersions collect: [:ea | ea package]) asSet asSortedCollection! !!MCRepository methodsFor: 'storing' stamp: 'bf 3/10/2005 23:01' prior: 23454842!possiblyNewerVersionsOfAnyOf: someVersions	^#()! !!MCRepository methodsFor: 'storing' stamp: 'avi 8/31/2004 01:06' prior: 23454973!prepareVersionForStorage: aVersion	^ self alwaysStoreDiffs		ifTrue: [aVersion asDiffAgainst:				 (self closestAncestorVersionFor: aVersion info ifNone: [^ aVersion])]		ifFalse: [aVersion]! !!MCRepository methodsFor: 'printing' stamp: 'mas 9/24/2003 04:21' prior: 23455247!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self description;		nextPut: $).! !!MCRepository methodsFor: 'required in subclasses' stamp: 'kph 5/17/2007 03:14'!realizeFullVersionInfo: aStubVersionInfoInstance	"we use full versionInfos anyway"		^ aStubVersionInfoInstance! !!MCRepository methodsFor: 'notifications' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23455453!sendNotificationsForVersion: aVersion	| notification notifyList |	notifyList := self notifyList.	notifyList isEmpty ifFalse:		[notification := self notificationForVersion: aVersion.		notifyList do: [:ea | notification notify: ea]]! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 00:28'!sortedHeldVersionInfos 	 	^ self sortedVersionInfos select: [:ea | self heldVersionInfos includes: ea]! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 03:51'!sortedVersionInfos 	| sorter |	sorter := MCVersionSorter new.	self heldVersionInfos do: [:ea | sorter addVersionInfo: ea].	^ sorter sortedVersionInfos! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 02:03'!sortedVersionInfosAvailableForPackageNamed: aPackageName 	 	^ self sortedVersionInfos 		select: [:ea | (self versionInfosAvailableForPackageNamed: aPackageName)  includes: ea]! !!MCRepository methodsFor: 'storing' stamp: 'avi 8/31/2004 01:05' prior: 23455771!storeVersion: aVersion	self basicStoreVersion: (self prepareVersionForStorage: aVersion).	self sendNotificationsForVersion: aVersion! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 02:02'!versionInfosAvailableForPackageNamed: aPackageName	^ self heldVersionInfos select: [:ea | ea packageName = aPackageName] ! !!MCRepository methodsFor: 'interface' stamp: 'avi 10/9/2003 12:42' prior: 23456681!versionWithInfo: aVersionInfo	^ self versionWithInfo: aVersionInfo ifAbsent: [nil]! !!MCRepository methodsFor: 'required in subclasses' stamp: 'ab 8/16/2003 18:22' prior: 23456836!versionWithInfo: aVersionInfo ifAbsent: aBlock	self subclassResponsibility ! !!MCRepository methodsFor: 'required in subclasses' stamp: 'kph 5/16/2007 22:56'!versions	self subclassResponsibility! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 14:15' prior: 23475670!creationTemplate	^'MCSMReleaseRepository	package: ''mypackage''	user: ''squeak''	password: ''squeak'''	! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 13:42' prior: 23475877!description	^ 'SqueakMap Release'! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:03' prior: 23476009!fillInTheBlankRequest	^  'SqueakMap Release Repository:'		! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:03' prior: 23476167!morphicConfigure	^ self fillInTheBlankConfigure! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 14:14' prior: 23476313!package: packageString user: userString password: passString	^ self basicNew initializeWithPackage: packageString user: userString password: passString! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23473379!basicStoreVersion: aVersion	| url |	url := self uploadVersion: aVersion.	self releaseVersion: aVersion url: url! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 14:11' prior: 23473585!checkResult: resultString(#( 'HTTP/1.1 201 ' 'HTTP/1.1 200 ' 'HTTP/1.0 201 ' 'HTTP/1.0 200 ')		anySatisfy: [:code | resultString beginsWith: code ])			ifFalse: [self error: resultString].! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 14:15' prior: 23473868!description	^ 'sm://', packageName! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!flushPasswords	MCPasswordManager default passwordAt: self squeakMapUrl user: user put: nil! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/3/2007 19:56' prior: 23474006!initializeWithPackage: packageString user: userString password: passString	packageName := packageString.	user := userString.	self password: passString.! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!password	^(MCPasswordManager default queryPasswordAt: self squeakMapUrl user: user) ifNil:[^''].! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!password: passwordString	| pwd |	passwordString isEmpty ifTrue:[pwd := nil] ifFalse:[pwd := passwordString].	MCPasswordManager default passwordAt: self squeakMapUrl user: user put: pwd.! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/3/2007 19:55' prior: 23474261!releaseVersion: aVersion url: urlString	| result |	result := HTTPSocket		httpPost: self squeakMapUrl, '/packagebyname/', packageName, '/newrelease'		args: {'version' -> {(aVersion info name copyAfter: $.) extractNumber asString}.			   'note' -> {aVersion info message}.			   'downloadURL' -> {urlString}}		user: user		passwd: self password.	result contents size > 4 ifTrue: [self error: result contents]! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'kph 6/9/2008 00:46' prior: 23474761!squeakMapUrl 	^ 'http://map.squeak.org/sm' ! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23474908!stringForVersion: aVersion	| stream |	stream := RWBinaryOrTextStream on: String new.	aVersion fileOutOn: stream.	^ stream contents! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/3/2007 19:55' prior: 23475145!uploadVersion: aVersion	| result stream |	result := HTTPSocket		httpPut: (self stringForVersion: aVersion)		to: self squeakMapUrl, '/upload/', aVersion fileName		user: user		passwd: self password.	self checkResult: result.	stream := result readStream.	stream upToAll: 'http://'.	^ 'http://', stream upToEnd! !!MCSmtpRepository class methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:56' prior: 23489979!description	^ 'SMTP'! !!MCSmtpRepository class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23490104!morphicConfigure	| address |	address := FillInTheBlankMorph request: 'Email address:'.	^ address isEmpty ifFalse: [self new emailAddress: address]! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 14:21' prior: 23488412!basicStoreVersion: aVersion	MailSender sendMessage: (self messageForVersion: aVersion)! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 13:11' prior: 23488586!bodyForVersion: aVersion	^ String streamContents:		[ :s |		s nextPutAll: 'from version info:'; cr; cr.		s nextPutAll:  aVersion info summary]! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:56' prior: 23488818!description	^ 'mailto://', email! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23488949!emailAddress: aString	email := aString	! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23489087!messageForVersion: aVersion	| message data |	message := MailMessage empty.	message setField: 'from' toString: MailSender userName.	message setField: 'to' toString: email.	message setField: 'subject' toString: (self subjectForVersion: aVersion). 	message body:		(MIMEDocument			contentType: 'text/plain'			content: (self bodyForVersion: aVersion)).	"Prepare the gzipped data"	data := RWBinaryOrTextStream on: String new.	aVersion fileOutOn: data.	message addAttachmentFrom: data reset withName: aVersion fileName.	^ message! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 13:14' prior: 23489712!subjectForVersion: aVersion	^ '[Package] ', aVersion info name! !!MCWriteOnlyRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:52' prior: 23663450!includesVersionNamed: aString	^ false! !!MCWriteOnlyRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:53' prior: 23663580!morphicOpen: aWorkingCopy	self inform: 'This repository is write-only'! !!MCWriteOnlyRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:52' prior: 23663743!versionWithInfo: aVersionInfo ifAbsent: aBlock	^ aBlock value! !!MCRepositoryGroup commentStamp: '<historical>' prior: 23459848!A singleton class, holds the list of repositories. Can look for a requested VersionInfo among its repositories.!!MCRepositoryGroup class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23462084!default	^ default ifNil: [default := self new]! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'mtf 2/7/2009 12:27' prior: 23460046!addRepository: aRepository	aRepository ifNil: [ ^ self ].	lastAdded := aRepository.		aRepository == MCCacheRepository default ifTrue: [ ^ self ].	(repositories includes: aRepository)		ifFalse: [repositories add: aRepository.				self class default addRepository: aRepository]		ifTrue: [ 			repositories remove: aRepository.			repositories add: aRepository.		].		self changed: #repositories! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'NorbertHartl 6/20/2008 10:11'!disableCache	useCache := false! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2003 00:20' prior: 23460581!includes: aRepository	^ self repositories includes: aRepository! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'abc 11/6/2004 20:32' prior: 23460371!includesVersionNamed: aString	self repositoriesDo: [:ea | (ea includesVersionNamed: aString) ifTrue: [^ true]].	^ false	! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23460744!initialize	repositories := OrderedCollection new! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'kph 12/13/2008 17:34'!lastAdded	^ lastAdded! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'ab 7/22/2003 00:11' prior: 23460880!removeRepository: aRepository	repositories remove: aRepository ifAbsent: [].	self changed: #repositories! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'mtf 2/7/2009 12:23' prior: 23461073!repositories	| r |	r := repositories select: [ :ea | ea isValid ].	self useCache ifFalse: [ ^ r ].		r size > 0 		ifTrue: [ r addFirst: MCCacheRepository default ]		ifFalse: [ r := Array with: MCCacheRepository default ].			^ r	! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2003 00:51' prior: 23461261!repositoriesDo: aBlock	self repositories do: [:ea | [aBlock value: ea] on: Error do: []]! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'abc 6/20/2008 10:02'!useCache	^ useCache ifNil: [		useCache := true	]! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'dvf 8/10/2004 23:02' prior: 34177533!versionWithInfo: aVersionInfo	^self versionWithInfo: aVersionInfo ifNone: [ self error: 'Could not find version ', aVersionInfo name printString,'. Maybe you need to add a repository?' ]! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'nk 1/23/2004 18:15' prior: 23461712!versionWithInfo: aVersionInfo ifNone: aBlock	self repositoriesDo: [:ea | (ea versionWithInfo: aVersionInfo) ifNotNilDo: [:v | ^ v]].	^aBlock value! !!MCScanner class methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:14' prior: 23479968!scan: aStream	^ (self new stream: aStream) next! !!MCScanner class methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:32' prior: 23479799!scanTokens: aString	"compatibility"	^ Array with: (self scan: aString readStream)! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23478604!next	| c |	stream skipSeparators.	c := stream peek.	c = $# ifTrue: [c := stream next; peek].	c = $' ifTrue: [^ self nextString].	c = $( ifTrue: [^ self nextArray].	c isAlphaNumeric ifTrue: [^ self nextSymbol].	self error: 'Unknown token type'.	! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:27' prior: 23478936!nextArray	stream next. "("	^ Array streamContents:		[:s |		[stream skipSeparators.		(stream peek = $)) or: [stream atEnd]] whileFalse: [s nextPut: self next].		stream next = $) ifFalse: [self error: 'Unclosed array']]! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:09' prior: 23479239!nextString	^ stream nextDelimited: $'! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:16' prior: 23479357!nextSymbol	^ (String streamContents:		[:s |		[stream peek isAlphaNumeric] whileTrue: [s nextPut: stream next]]) asSymbol			! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23479575!stream: aStream	stream := aStream! !!MCImageBackedSnapshot methodsFor: 'as yet unclassified' stamp: 'mtf 10/7/2008 17:05'!asPatchSnapshot	^ self! !!MCImageBackedSnapshot methodsFor: 'as yet unclassified' stamp: 'mtf 10/7/2008 12:58'!definitionIndex	^ MCImageBackedDefinitionIndex definitions: definitions! !!MCSnapshot class methodsFor: 'as yet unclassified' stamp: 'kph 1/16/2009 13:36' prior: 23491472!empty	^ self fromDefinitions: OrderedCollection new! !!MCSnapshot class methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 01:43' prior: 23491591!fromDefinitions: aCollection 	^ self new initializeWithDefinitions: aCollection! !!MCSnapshot methodsFor: 'accessing' stamp: 'ab 7/10/2003 01:05' prior: 23490664!= other	^ definitions asArray = other definitions asArray! !!MCSnapshot methodsFor: 'patching' stamp: 'mtf 10/7/2008 14:02'!asPatchSnapshot	^ MCImageBackedSnapshot fromDefinitions: definitions! !!MCSnapshot methodsFor: 'authorship' stamp: 'kph 2/7/2009 20:57'!authorInitials	| authors |	authors := Set new.		self definitions do: [ :ea | ea authorInitials ifNotNilDo: [ :a | authors add: a ]].			^ authors! !!MCSnapshot methodsFor: 'patching' stamp: 'mtf 10/7/2008 12:57'!definitionIndex	^ MCDefinitionIndex definitions: definitions! !!MCSnapshot methodsFor: 'accessing' stamp: 'ab 12/4/2002 18:09' prior: 23490466!definitions	^ definitions! !!MCSnapshot methodsFor: 'authorship' stamp: 'kph 2/8/2009 00:13'!definitionsWithAnyAuthor: initialsList		^ self definitions select: [ :ea | initialsList anySatisfy: [ :init | init = ea authorInitials ]]! !!MCSnapshot methodsFor: 'accessing' stamp: 'ab 7/10/2003 01:05' prior: 23490562!hash	^ definitions asArray hash! !!MCSnapshot methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23490808!initializeWithDefinitions: aCollection	definitions := aCollection.! !!MCSnapshot methodsFor: 'loading' stamp: 'kph 12/7/2008 02:30' prior: 23490943!install	(MCPackageLoader newCurrent)		installSnapshot: self;		installOrphanage;		load! !!MCSnapshot methodsFor: 'accessing' stamp: 'kph 5/10/2007 18:10'!isEmpty	^ definitions isEmpty! !!MCSnapshot methodsFor: 'patching' stamp: 'ab 7/7/2003 00:37' prior: 23491208!patchRelativeToBase: aSnapshot	^ MCPatch fromBase: aSnapshot target: self! !!MCSnapshot methodsFor: 'loading' stamp: 'kph 12/7/2008 02:30' prior: 23491056!updatePackage: aPackage	(MCPackageLoader newCurrent)		updatePackage: aPackage withSnapshot: self;		installOrphanage;		load		! !!MCCodeTool commentStamp: 'nk 11/10/2003 22:00' prior: 23242067!MCCodeTool is an abstract superclass for those Monticello browsers that display code.It contains copies of the various CodeHolder methods that perform the various menu operations in the method list.!!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 21:00' prior: 23242333!adoptMessageInCurrentChangeset	"Add the receiver's method to the current change set if not already there"	self selectedClassOrMetaClass ifNotNilDo: [ :cl |		self selectedMessageName ifNotNilDo: [ :sel |			ChangeSet current adoptSelector: sel forClass: cl.			self changed: #annotations ]]! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:01' prior: 23250552!annotations	"Build an annotations string for the various browsers"	^''! !!MCCodeTool methodsFor: 'menus' stamp: 'sd 5/10/2008 17:31' prior: 23242705!browseFullProtocol	"Open up a protocol-category browser on the value of the	receiver's current selection."		^ self spawnFullProtocol! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 21:26' prior: 23243325!browseMessages	"Present a menu of the currently selected message, as well as all messages sent by it.  Open a message set browser of all implementors of the selector chosen."	self systemNavigation browseAllImplementorsOf: (self selectedMessageName ifNil: [ ^nil ])! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23243670!browseMethodFull	"Create and schedule a full Browser and then select the current class and message."	| myClass |	(myClass := self selectedClassOrMetaClass) ifNotNil:		[Browser fullOnClass: myClass selector: self selectedMessageName]! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 20:54' prior: 23243974!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all messages sent by it.  Open a message set browser of all senders of the selector chosen."	self systemNavigation browseAllCallsOn: (self selectedMessageName ifNil: [ ^nil ])! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23244316!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector compiledMethod |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	compiledMethod := class compiledMethodAt: selector ifAbsent: [ ^self ].	VersionsBrowser		browseVersionsOf: compiledMethod		class: class theNonMetaClass		meta: class isMeta		category: self selectedMessageCategoryName		selector: selector! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 7/30/2004 17:56' prior: 23244862!classHierarchy	"Create and schedule a class list browser on the receiver's hierarchy."	self systemNavigation  spawnHierarchyForClass: self selectedClassOrMetaClass		selector: self selectedMessageName	"OK if nil"! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 6/12/2004 14:01' prior: 23245143!classListMenu: aMenu 	aMenu addList: #(		-		('browse full (b)'			browseMethodFull)		('browse hierarchy (h)'		classHierarchy)		('browse protocol (p)'		browseFullProtocol)"		-		('printOut'					printOutClass)		('fileOut'					fileOutClass)"		-		('show hierarchy'			methodHierarchy)"		('show definition'			editClass)		('show comment'			editComment)""		-		('inst var refs...'			browseInstVarRefs)		('inst var defs...'			browseInstVarDefs)		-		('class var refs...'			browseClassVarRefs)		('class vars'					browseClassVariables)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class'				copyClass)		('remove class (x)'			removeClass)"		-		('find method...'				findMethodInChangeSets)).								^aMenu! !!MCCodeTool methodsFor: 'menus' stamp: 'jl 11/1/2006 10:40'!copyClassAndSelector	"Copy the selected selector to the clipboard"	Clipboard clipboardText: '',self selectedClassOrMetaClass,'>>',self selectedMessageName! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23245980!copySelector	"Copy the selected selector to the clipboard"	| selector |	(selector := self selectedMessageName) ifNotNil:		[Clipboard clipboardText: selector asString]! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 20:55' prior: 23246218!fileOutMessage	"Put a description of the selected message on a file"	self selectedMessageName ifNotNil:		[Cursor write showWhile:			[self selectedClassOrMetaClass fileOutMethod: self selectedMessageName]]! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23246505!findMethodInChangeSets	"Find and open a changeSet containing the current method."	| aName |	(aName := self selectedMessageName) ifNotNil: [		ChangeSorter browseChangeSetsWithClass: self selectedClassOrMetaClass					selector: aName]! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 7/30/2004 17:56' prior: 23246808!methodHierarchy	"Create and schedule a method browser on the hierarchy of implementors."	self systemNavigation methodHierarchyBrowserForClass: self selectedClassOrMetaClass		selector: self selectedMessageName! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 2/16/2004 17:00' prior: 23247086!methodListKey: aKeystroke from: aListMorph 	aKeystroke caseOf: {		[$b] -> [self browseMethodFull].		[$h] -> [self classHierarchy].		[$O] -> [self openSingleMessageBrowser].		[$p] -> [self browseFullProtocol].		[$o] -> [self fileOutMessage].		[$c] -> [self copySelector].		[$n] -> [self browseSendersOfMessages].		[$m] -> [self browseMessages].		[$i] -> [self methodHierarchy].		[$v] -> [self browseVersions]}		 otherwise: []! !!MCCodeTool methodsFor: 'menus' stamp: 'md 4/30/2008 15:39' prior: 23247589!methodListMenu: aMenu	"Build the menu for the selected method, if any."		self selectedMessageName ifNotNil: [	aMenu addList:#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('copy selector (c)'						copySelector)).		aMenu addList: #(			-			('browse senders (n)'						browseSendersOfMessages)			('browse implementors (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)		('change sets with this method'			findMethodInChangeSets)"		('x revert to previous version'				revertToPreviousVersion)"		('remove from current change set'		removeFromCurrentChanges)"		('x revert & remove from changes'		revertAndForget)"		('add to current change set'				adoptMessageInCurrentChangeset)"		('x copy up or copy down...'				copyUpOrCopyDown)""		('x remove method (x)'					removeMessage)"		"-"		).	]."	aMenu addList: #(			('x inst var refs...'						browseInstVarRefs)			('x inst var defs...'						browseInstVarDefs)			('x class var refs...'						browseClassVarRefs)			('x class variables'						browseClassVariables)			('x class refs (N)'							browseClassRefs)	)."	^ aMenu! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23249044!openSingleMessageBrowser	| msgName mr |	"Create and schedule a message list browser populated only by the currently selected message"	(msgName := self selectedMessageName) ifNil: [^ self].	mr := MethodReference new		setStandardClass: self selectedClassOrMetaClass		methodSymbol: msgName.	self systemNavigation 		browseMessageList: (Array with: mr)		name: mr asStringOrText		autoSelect: nil! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 20:55' prior: 23249513!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 21:00' prior: 23250237!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	ChangeSet current removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.	self changed: #annotations! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:02' prior: 23250708!selectedClass	"Answer the class that is selected, or nil"	self subclassResponsibility! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:02' prior: 23250879!selectedClassOrMetaClass	"Answer the class that is selected, or nil"	self subclassResponsibility! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:02' prior: 23251061!selectedMessageCategoryName	"Answer the method category of the method that is selected, or nil"	self subclassResponsibility! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:02' prior: 23251270!selectedMessageName	"Answer the name of the selected message"	self subclassResponsibility! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:07' prior: 23214199!buttonSpecs	^ #((Select select 'Select these changes')		 (Cancel cancel 'Cancel the operation')		)! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:26' prior: 23214387!cancel	self answer: nil! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/14/2004 15:01' prior: 23214498!defaultLabel	^ 'Change Selector'! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:13' prior: 23214618!innerButtonRow	^ self buttonRow:		#(('Select All' selectAll 'select all changes')		  ('Select None' selectNone 'select no changes'))! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23214851!kept	^ kept ifNil: [kept := Set new]! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:22' prior: 23214975!listSelectionAt: aNumber	^ self kept includes: (self items at: aNumber)! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23215145!listSelectionAt: aNumber put: aBoolean	| item |	item := self items at: aNumber.	aBoolean		ifTrue: [self kept add: item ]		ifFalse: [self kept remove: item ifAbsent: []]! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:26' prior: 23215405!select	self answer: (MCPatch operations: kept)! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/14/2004 15:00' prior: 23215539!selectAll	kept addAll: self items.	self changed: #list! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23215693!selectNone	kept := Set new.	self changed: #list! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:25' prior: 23215829!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((buttonRow) (0 0 1 0) (0 0 0 30))		((multiListMorph:selection:listSelection:menu: list selection listSelectionAt: methodListMenu:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: text) (0 0.4 1 1) (0 30 0 0))		)].	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((multiListMorph:selection:listSelection:menu: list selection listSelectionAt: methodListMenu:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: annotations) (0 0.4 1 0.4) (0 30 0 60))		((textMorph: text) (0 0.4 1 1) (0 60 0 0))		)! !!MCMergeBrowser class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23367634!resolveConflictsInMerger: aMerger	| inst |	inst := self new merger: aMerger.	^ inst showModally ifNil: [false]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:35' prior: 23362658!buttonSpecs	^ #((Merge merge 'Proceed with the merge' canMerge)		 (Cancel cancel 'Cancel the merge')		('All Newer' chooseAllNewerConflicts 'Choose all newer conflict versions')		('All Older' chooseAllOlderConflicts 'Choose all older conflict versions')		('Rest Local' chooseAllUnchosenLocal 'Choose local versions of all remaining conflicts')		('Rest Remote' chooseAllUnchosenRemote 'Choose remote versions of all remaining conflicts'))! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/22/2003 00:51' prior: 23363295!canMerge	^ merger isMerged! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 17:52' prior: 23363185!cancel	self answer: false! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:21' prior: 23363407!chooseAllNewerConflicts	conflicts do: [ :ea | ea chooseNewer ].	self changed: #text; changed: #list.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:22' prior: 23363594!chooseAllOlderConflicts	conflicts do: [ :ea | ea chooseOlder ].	self changed: #text; changed: #list.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:34' prior: 23363781!chooseAllUnchosenLocal	conflicts do: [ :ea | ea isResolved ifFalse: [ ea chooseLocal ] ].	self changed: #text; changed: #list.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:34' prior: 23363994!chooseAllUnchosenRemote	conflicts do: [ :ea | ea isResolved ifFalse: [ ea chooseRemote ] ].	self changed: #text; changed: #list.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:41' prior: 23364208!chooseLocal	self conflictSelectionDo:		[selection chooseLocal.		self changed: #text; changed: #list]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:41' prior: 23364395!chooseRemote	self conflictSelectionDo:		[selection chooseRemote.		self changed: #text; changed: #list]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:41' prior: 23364584!clearChoice	self conflictSelectionDo:		[selection clearChoice.		self changed: #text; changed: #list]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:42' prior: 23364771!conflictSelectionDo: aBlock	self selectionIsConflicted		ifTrue: aBlock		ifFalse: [self inform: 'You must have a conflict selected']! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 21:31' prior: 23364989!defaultLabel	^ 'Merge Browser'! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:04' prior: 23365104!getConflictMenu: aMenu	selection remoteChosen		ifTrue: [aMenu add: 'undo keep change' target: self selector: #clearChoice]		ifFalse: [aMenu add: 'keep change' target: self selector: #chooseRemote].	selection localChosen		ifTrue: [aMenu add: 'undo reject change' target: self selector: #clearChoice]			ifFalse: [aMenu add: 'reject change' target: self selector: #chooseLocal].	^ aMenu! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:07' prior: 23365578!getMenu: aMenu	selection ifNil: [^ aMenu].	^ self selectionIsConflicted		ifTrue: [self getConflictMenu: aMenu]		ifFalse: [self getOperationMenu: aMenu]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 16:37' prior: 23365817!getOperationMenu: aMenu	^ aMenu! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/22/2003 00:49' prior: 23365933!innerButtonRow	^ self buttonRow:		#((Keep chooseRemote 'keep the selected change' selectionIsConflicted)		  (Reject chooseLocal 'reject the selected change' selectionIsConflicted))! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 16:32' prior: 23366200!items	^ conflicts, items! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 17:52' prior: 23366309!merge	merger isMerged		ifFalse: [self inform: 'You must resolve all the conflicts first']		ifTrue: [self answer: true] ! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23366527!merger: aMerger	merger := aMerger.	items := aMerger operations asSortedCollection.	conflicts := aMerger conflicts.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:07' prior: 23366728!selectionIsConflicted	^ selection isKindOf: MCConflict! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 11/10/2003 22:08' prior: 23366868!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph:selection:menu: list selection methodListMenu:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: text) (0 0.4 1 1) (0 30 0 0))		)].	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph:selection:menu: list selection methodListMenu:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: annotations) (0 0.4 1 0.4) (0 30 0 60))		((textMorph: text) (0 0.4 1 1) (0 60 0 0))		)! !!MCPatchBrowser class methodsFor: 'as yet unclassified' stamp: 'ab 7/16/2003 14:35' prior: 23439922!forPatch: aPatch	^ self new patch: aPatch! !!MCPatchBrowser methodsFor: 'as yet unclassified' stamp: 'nk 11/10/2003 21:41' prior: 23435302!annotations	^selection ifNil: [ super annotations ]		ifNotNil: [ selection annotations ]! !!MCPatchBrowser methodsFor: 'morphic ui' stamp: 'ab 8/22/2003 02:21' prior: 23436530!buttonSpecs	^ #((Invert invert 'Show the reverse set of changes')		 (Export export 'Export the changes as a change set'))! !!MCPatchBrowser methodsFor: 'as yet unclassified' stamp: 'nk 2/23/2005 08:04' prior: 23435476!changeSetNameForInstall	"Answer the name of the change set into which my selection will be installed.	Derive this from my label.	If I have no label, use the current change set."	| tokens |	label ifNil: [ ^ChangeSet current name ].	tokens := label findTokens: ' '.	tokens removeAllFoundIn: { 'changes'. 'between'. 'and' }.	(tokens size = 3 and: [ tokens second = '<working' ]) ifTrue: [ ^tokens first, '-to-working' ].	tokens size = 2 ifFalse: [ ^'InstalledPatches' ].	^'{1}-to-{2}' format: tokens ! !!MCPatchBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 21:31' prior: 23436728!defaultLabel	^ 'Patch Browser'! !!MCPatchBrowser methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:30' prior: 23436080!installSelection	| loader |	selection ifNotNil:		[loader := MCPackageLoader newCurrent.		selection applyTo: loader.		loader loadWithName: self changeSetNameForInstall ]! !!MCPatchBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23437796!invert	items := items collect: [:ea | ea inverse].	self changed: #list; changed: #text; changed: #selection! !!MCPatchBrowser methodsFor: 'accessing' stamp: 'ab 7/16/2003 14:36' prior: 23434936!items	^ items! !!MCPatchBrowser methodsFor: 'accessing' stamp: 'ab 7/16/2003 14:39' prior: 23435024!list	^ self items collect: [:ea | ea summary]! !!MCPatchBrowser methodsFor: 'menus' stamp: 'bf 3/5/2006 14:10' prior: 23436318!methodListMenu: aMenu	selection ifNotNil:		[aMenu addList:#(			('install'	 installSelection)			('revert'	 revertSelection)			-)].	super methodListMenu: aMenu.	^ aMenu! !!MCPatchBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23435156!patch: aPatch	items := aPatch operations asSortedCollection! !!MCPatchBrowser methodsFor: 'morphic ui' stamp: 'nk 11/10/2003 20:55' prior: 23436835!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!MCPatchBrowser methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:30'!revertSelection	| loader |	selection ifNotNil:		[loader := MCPackageLoader newCurrent.		selection inverse applyTo: loader.		loader loadWithName: self changeSetNameForInstall ]! !!MCPatchBrowser methodsFor: 'subclassResponsibility' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23438389!selectedClass	| definition |	selection ifNil: [ ^nil ].	(definition := selection definition) ifNil: [ ^nil ].	definition isMethodDefinition ifFalse: [ ^nil ].	^Smalltalk at: definition className ifAbsent: [ ]! !!MCPatchBrowser methodsFor: 'subclassResponsibility' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23438701!selectedClassOrMetaClass	| definition |	selection ifNil: [ ^nil ].	(definition := selection definition) ifNil: [ ^nil ].	definition isMethodDefinition ifFalse: [ ^nil ].	^definition actualClass! !!MCPatchBrowser methodsFor: 'subclassResponsibility' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23438998!selectedMessageCategoryName	| definition |	selection ifNil: [ ^nil ].	(definition := selection definition) ifNil: [ ^nil ].	definition isMethodDefinition ifFalse: [ ^nil ].	^definition category! !!MCPatchBrowser methodsFor: 'subclassResponsibility' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23439295!selectedMessageName	| definition |	selection ifNil: [ ^nil ].	(definition := selection definition) ifNil: [ ^nil ].	definition isMethodDefinition ifFalse: [ ^nil ].	^definition  selector! !!MCPatchBrowser methodsFor: 'selecting' stamp: 'ab 7/16/2003 14:30' prior: 23437979!selection	^ selection 		ifNil: [0]		ifNotNil: [self items indexOf: selection]! !!MCPatchBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23438145!selection: aNumber	selection := aNumber = 0 ifFalse: [self items at: aNumber].	self changed: #selection; changed: #text; changed: #annotations! !!MCPatchBrowser methodsFor: 'text' stamp: 'ab 7/16/2003 14:40' prior: 23439556!text	^ selection ifNil: [''] ifNotNil: [selection source]! !!MCPatchBrowser methodsFor: 'text' stamp: 'ab 7/16/2003 14:27' prior: 23439683!text: aTextOrString	self changed: #text! !!MCPatchBrowser methodsFor: 'morphic ui' stamp: 'mtf 10/7/2008 18:32' prior: 23437245!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((listMorph:selection:menu:keystroke: list selection methodListMenu: methodListKey:from: ) (0 0 1 0.4) (0 0 0 0))		((textMorph: text) (0 0.4 1 1))		) ].	^ {		#((listMorph:selection:menu:keystroke: list selection methodListMenu: methodListKey:from: ) (0 0 1 0.4) (0 0 0 0)).		{ #(textMorph: annotations). #(0 0.4 1 0.4). { 0. 0. 0. self defaultAnnotationPaneHeight. } }.		{ #(textMorph: text). #(0 0.4 1 1). { 0. self defaultAnnotationPaneHeight. 0. 0. } }.		}! !!MCSnapshotBrowser class methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 18:03' prior: 23504206!forSnapshot: aSnapshot	^ self new snapshot: aSnapshot! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 12/6/2008 23:29' prior: 23491961!allClassNames	^ (items 		select: [:ea | ea isOrganizationDefinition not and: [ ea isFileDefinition not ]] 		thenCollect: [:ea | ea className]) asSet.! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'nk 7/24/2003 13:40' prior: 23502738!annotations	methodSelection ifNotNil: [^ methodSelection annotations ].	^ ''! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'nk 7/24/2003 13:41' prior: 23502888!annotations: stuff	self changed: #annotations! !!MCSnapshotBrowser methodsFor: 'morphic ui' stamp: 'bf 5/27/2005 19:33' prior: 23498262!buttonSpecs	^ #(('instance' switchBeInstance 'show instance' buttonEnabled switchIsInstance)		('?' switchBeComment 'show comment' buttonEnabled switchIsComment)		('class' switchBeClass 'show class' buttonEnabled switchIsClass))! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/10/2003 18:33' prior: 23494614!categoryList	^ self visibleCategories! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'nk 4/17/2004 09:52' prior: 23496135!categoryListMenu: aMenu 	categorySelection		ifNotNil: [aMenu				add: (categorySelection = '*Extensions'						ifTrue: ['load all extension methods' translated]						ifFalse: ['load class category {1}' translated format: {categorySelection}])				action: #loadCategorySelection].	^ aMenu! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'cwp 7/10/2003 18:33' prior: 23499684!categorySelection	^ categorySelection ifNil: [0] ifNotNil: [self visibleCategories indexOf: categorySelection]! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23499884!categorySelection: aNumber	categorySelection := aNumber = 0 ifFalse: [self visibleCategories at: aNumber].	self classSelection: 0.	self changed: #categorySelection;		changed: #annotations;		changed: #classList.! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'ab 7/18/2003 15:48' prior: 23503006!classCommentString	^ (items 		detect: [:ea | ea isClassDefinition and: [ea className = classSelection]]		ifNone: [^ '']) comment.! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'kph 12/7/2008 04:15' prior: 23503222!classDefinitionString	| def |	def := self packageClasses 			detect: [ : ea | ea className = classSelection] ifNone: [ ^ 'This class is defined elsewhere.' ].	^ String streamContents: [:stream | 		def printDefinitionAndCommentOn: stream	].! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/10/2003 20:20' prior: 23494728!classList	^ self visibleClasses! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 5/13/2007 04:29' prior: 23496499!classListMenu: aMenu 	classSelection ifNil: [ ^aMenu ].	super classListMenu: aMenu.	aMenu		addLine;				add: ('load class {1} (all)' translated format: {classSelection})				action: #loadClassSelection;				add: ('load class {1} (defn only) '  format: {classSelection})				action: #loadClassSelectionDefinition.	^ aMenu! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'cwp 7/10/2003 18:28' prior: 23500178!classSelection	^ classSelection ifNil: [0] ifNotNil: [self visibleClasses indexOf: classSelection]! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23500366!classSelection: aNumber	classSelection := aNumber = 0 ifFalse: [self visibleClasses at: aNumber].	self protocolSelection: 0.	self changed: #classSelection; 		changed: #protocolList;		changed: #annotations;		changed: #methodList.! !!MCSnapshotBrowser methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:29' prior: 23498570!defaultExtent	^ 650@400.! !!MCSnapshotBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 21:31' prior: 23498673!defaultLabel	^ 'Snapshot Browser'! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'kph 5/13/2007 04:29'!definitionsForSelectedClassCategory	| visibleClasses |	visibleClasses := self visibleClasses.	^ items select: [:ea | visibleClasses includes: ea className ]								! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 5/11/2007 04:45' prior: 23492159!extensionClassNames 	^ (self allClassNames difference: self packageClassNames) asSortedCollection! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'ab 7/5/2003 23:41' prior: 23492332!extensionsCategory	^ '*Extensions'! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 12/6/2008 23:09'!fileDefinitions	^ items select: [:ea | ea isFileDefinition ]! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 12/6/2008 23:05'!filesCategory	^ ':FILES'! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'cwp 7/10/2003 18:03' prior: 23496784!inspectSelection	^ self methodSelection inspect! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'kph 5/13/2007 04:13' prior: 23496905!loadCategorySelection 	categorySelection ifNil: [ ^self ]. 	(MCSnapshot fromDefinitions: self definitionsForSelectedClassCategory ) install! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'kph 5/15/2007 11:59' prior: 23497132!loadClassSelection	| defns |	classSelection ifNil: [ ^self ].		"defns := self methodsForSelectedClass.		defns add: (self packageClasses 						detect: [ :ea | ea className = classSelection ] 						ifNone: [ ^self ])."	"easier implementation"		defns := items select: [ :d | (d respondsTo: #className) and: [ d className = classSelection ] ].		(MCSnapshot fromDefinitions: defns) install! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'kph 12/7/2008 02:30'!loadClassSelectionDefinition	| classDefinition |		classSelection ifNil: [ ^self ].	classDefinition := items 		detect: [ :defn | defn isClassDefinition and: [ defn className = classSelection ] ].		(MCPackageLoader newCurrent) 		addDefinition: classDefinition;		load	! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'kph 2/7/2009 18:24' prior: 23497403!loadMethodSelection	methodSelection ifNil: [ ^self ].	(MCPackageLoader1b new) 		addDefinition: methodSelection;		load ! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'kph 5/13/2007 04:07' prior: 23497553!loadProtocolSelection	protocolSelection ifNil: [ ^self ].		(MCSnapshot fromDefinitions: self methodsForSelectedProtocol) install! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/13/2003 02:11' prior: 23494836!methodList	^ self visibleMethods collect: [:ea | ea selector]! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'kph 5/13/2007 04:23' prior: 23497738!methodListMenu: aMenu 	super methodListMenu: aMenu.	self selectedMessageName		ifNotNilDo: [:msgName | aMenu addLine; add: 'debug/load method' translated action: #loadMethodSelection].	^ aMenu! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'cwp 7/10/2003 20:26' prior: 23500679!methodSelection	^ methodSelection			ifNil: [0] 			ifNotNil: [self visibleMethods indexOf: methodSelection]! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23500877!methodSelection: aNumber	methodSelection := aNumber = 0 ifFalse: [self visibleMethods at: aNumber].	self changed: #methodSelection; changed: #text; changed: #annotations! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 5/3/2007 19:17' prior: 23492444!methodsForSelectedClass 	^ items select: [:ea | (ea className = classSelection) 									and: [ea isMethodDefinition] ].! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 5/3/2007 19:17'!methodsForSelectedClassSide 	^  self methodsForSelectedClass select: [:ea | ea classIsMeta = self switchIsClass ].! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 5/3/2007 19:17' prior: 23493042!methodsForSelectedProtocol	| methods |	protocolSelection ifNil: [^ Array new].	methods := self methodsForSelectedClassSide asOrderedCollection.	(protocolSelection = '-- all --') 		ifFalse: [methods removeAllSuchThat: [:ea | ea category ~= protocolSelection]].	^ methods 									! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'ab 7/18/2003 15:48' prior: 23493539!packageClassNames	^ self packageClasses collect: [:ea | ea className]! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 5/11/2007 04:47' prior: 23493402!packageClasses	^ items select: [:ea | (ea isClassDefinition or: [ea isClassDefinitionExtension]) ]! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/10/2003 19:07' prior: 23494974!protocolList	^ self visibleProtocols! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'nk 4/17/2004 09:43' prior: 23498000!protocolListMenu: aMenu 	protocolSelection		ifNotNil: [aMenu				add: ('load protocol ''{1}''' translated format: {protocolSelection})				action: #loadProtocolSelection ].	^ aMenu! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'cwp 7/10/2003 19:35' prior: 23501126!protocolSelection	^ protocolSelection 		ifNil: [0]		ifNotNil: [self visibleProtocols indexOf: protocolSelection]! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23501330!protocolSelection: anInteger	protocolSelection := (anInteger = 0 ifFalse: [self visibleProtocols at: anInteger]).	self methodSelection: 0.	self changed: #protocolSelection;		changed: #methodList;			changed: #annotations! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'nk 10/11/2003 16:53' prior: 23493687!selectedClass	classSelection ifNil: [ ^nil ].	^Smalltalk at: classSelection ifAbsent: [ nil ].! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23493873!selectedClassOrMetaClass	| class |	classSelection ifNil: [ ^nil ].	class := Smalltalk at: classSelection ifAbsent: [ ^nil ].	^self switchIsClass ifTrue: [ class class ]		ifFalse: [ class ].! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'kph 12/6/2008 23:26'!selectedFileSource 		^ (self fileDefinitions detect: [ :ea | ea path = classSelection ] ifNone: [ ^ 'file?' ]) source! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'nk 11/10/2003 21:29' prior: 23494145!selectedMessageCategoryName	^protocolSelection! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'nk 10/11/2003 16:45' prior: 23494270!selectedMessageName	^methodSelection ifNotNil: [^ methodSelection selector ].! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'cwp 7/12/2003 18:57' prior: 23501630!signalSwitchChanged	self protocolSelection: 0.	self 		changed: #switchIsInstance;		changed: #switchIsComment;		changed: #switchIsClass;		changed: #protocolList;		changed: #methodList;		changed: #text.! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23494438!snapshot: aSnapshot	items := aSnapshot definitions asSortedCollection.	self categorySelection: 0.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23501924!switchBeClass	switch := #class.	self signalSwitchChanged.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23502069!switchBeComment	switch := #comment.	self signalSwitchChanged.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23502218!switchBeInstance	switch := #instance.	self signalSwitchChanged.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'cwp 7/12/2003 18:05' prior: 23502358!switchIsClass	^ switch = #class! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'cwp 7/12/2003 18:04' prior: 23502465!switchIsComment	^ switch = #comment.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23502588!switchIsInstance	switch ifNil: [switch := #instance].	^ switch = #instance.! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'kph 12/6/2008 23:22' prior: 23503669!text	self switchIsComment ifTrue: [^ self classCommentString].	methodSelection ifNotNil: [^ methodSelection source].	protocolSelection ifNotNil: [^ ''].	categorySelection = self filesCategory ifTrue: [ ^ self selectedFileSource ].	classSelection ifNotNil: [^ self classDefinitionString].		^ ''! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'cwp 7/11/2003 00:30' prior: 23503961!text: aTextOrString	self changed: #text! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'kph 12/6/2008 23:24' prior: 23495086!visibleCategories	| cl |	cl := (self packageClasses collect: [:ea | ea category]) 			asSet asSortedCollection 			add: self extensionsCategory;			yourself.				self fileDefinitions size > 0 ifTrue: [ cl add: self filesCategory ].		^ cl! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'kph 2/15/2009 16:08' prior: 23495301!visibleClasses	categorySelection = self filesCategory ifTrue: [ 		^ self fileDefinitions collect: [:f | f path]	].	^ categorySelection = self extensionsCategory		ifTrue: [self extensionClassNames]		ifFalse: [self packageClasses					select: [:ea | ea category = categorySelection]					thenCollect: [:ea | ea className]].! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/10/2003 19:46' prior: 23495601!visibleMethods	^ classSelection 		ifNil: [#()]		ifNotNil: [self methodsForSelectedProtocol]! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'kph 5/3/2007 19:18' prior: 23495782!visibleProtocols	| methods protocols |	self switchIsComment ifTrue: [^ Array new].	methods := self methodsForSelectedClassSide.	protocols := (methods collect: [:ea | ea category]) asSet asSortedCollection.	(protocols size > 1) ifTrue: [protocols add: '-- all --'].	^ protocols ! !!MCSnapshotBrowser methodsFor: 'morphic ui' stamp: 'bf 5/27/2005 19:13' prior: 23498785!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((listMorph: category) (0 0 0.25 0.4))		((listMorph: class) (0.25 0 0.50 0.4) (0 0 0 -30))		((listMorph: protocol) (0.50 0 0.75 0.4))		((listMorph:selection:menu:keystroke:  methodList methodSelection methodListMenu: methodListKey:from:) (0.75 0 1 0.4))		((buttonRow) (0.25 0.4 0.5 0.4) (0 -30 0 0))		((textMorph: text) (0 0.4 1 1))		) ].	^#(		((listMorph: category) (0 0 0.25 0.4))		((listMorph: class) (0.25 0 0.50 0.4) (0 0 0 -30))		((listMorph: protocol) (0.50 0 0.75 0.4))		((listMorph:selection:menu:keystroke:  methodList methodSelection methodListMenu: methodListKey:from:) (0.75 0 1 0.4))		((buttonRow) (0.25 0.4 0.5 0.4) (0 -30 0 0))		((textMorph: annotations) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: text) (0 0.4 1 1) (0 30 0 0))		)! !!MCConfigurationBrowser class methodsFor: 'class initialization' stamp: 'bf 3/21/2005 19:46' prior: 23279415!initialize	TheWorldMenu registerOpenCommand: { 'Monticello Configurations' . { self . #open }. 'Monticello Configuration Browser' }.! !!MCConfigurationBrowser class methodsFor: 'opening' stamp: 'bf 3/21/2005 19:50' prior: 23279635!open	^self new show! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 22:08' prior: 23263247!add	(self pickWorkingCopiesSatisfying: [:each | (self includesPackage: each package) not])		do: [:wc |			wc ancestors isEmpty				ifTrue: [self inform: 'You must save ', wc packageName, ' first!!Skipping this package']				ifFalse: [					self dependencies add: (MCVersionDependency						package: wc package						info: wc ancestors first)]].	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 3/23/2005 22:08' prior: 23267810!addDependency	(self pickWorkingCopiesSatisfying: [:each | (self includesPackage: each package) not])		do: [:wc |			wc ancestors isEmpty				ifTrue: [self inform: 'You must save ', wc packageName, ' first!!Skipping this package']				ifFalse: [					self dependencies add: (MCVersionDependency						package: wc package						info: wc ancestors first)]].	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'djr 6/27/2008 18:41' prior: 23274190!addRepository	(self pickRepositorySatisfying: [:ea | (self repositories includes: ea) not])		ifNotNilDo: [:repo |			((repo isKindOf: MCHttpRepository) | (repo isKindOf: MCDirectoryRepository))				ifFalse: [^self inform: 'Only HTTP or Directory repositories are supported'].			self repositories add: repo.			self changed: #repositoryList.		]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 6/22/2005 12:26' prior: 23271159!buttonSpecs	^ #(('Add' add 'Add a dependency')		('Update' updateMenu 'Update dependencies')		('Install' installMenu 'Load/Merge/Upgrade into image')		('Up' up 'Move item up in list' canMoveUp)		('Down' down 'Move item down in list' canMoveDown)		('Remove' remove 'Remove item' canRemove)		('Store' store 'store configuration')		('Post' post 'Post this configuration to an update stream')		)! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/23/2005 20:44' prior: 23278366!canMoveDown	^self index between: 1 and: self maxIndex - 1 ! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/23/2005 20:44' prior: 23278505!canMoveUp	^self index > 1! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/23/2005 20:45' prior: 23278611!canRemove	^self index > 0! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 5/27/2005 19:54' prior: 23275873!changedButtons	self changed: #canMoveDown.	self changed: #canMoveUp.	self changed: #canRemove.! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:55' prior: 23276052!changedList	self dependencyIndex > 0 ifTrue: [^self changed: #dependencyList].	self repositoryIndex > 0 ifTrue: [^self changed: #repositoryList].	self error: 'nothing selected'! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:36' prior: 23268306!checkDependencies	^self checkModified and: [self checkMissing]! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:35' prior: 23268454!checkMissing	| missing |	missing := (self dependencies collect: [:ea | ea versionInfo name]) asSet.	self repositories		do: [:repo |			repo allVersionNames				do: [:found | missing remove: found ifAbsent: []]]		displayingProgress: 'searching versions'.	^missing isEmpty or: [		self selectDependency: missing anyOne.		self confirm: (String streamContents: [:strm |			strm nextPutAll: 'No repository found for'; cr.			missing do: [:r | strm nextPutAll: r; cr].			strm nextPutAll: 'Do you still want to store?'])]	! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:37' prior: 23269065!checkModified	| modified |	modified := self dependencies select: [:dep |		dep isFulfilled and: [dep package workingCopy modified]].		^modified isEmpty or: [		self selectDependency: modified anyOne.		self confirm: (String streamContents: [:strm |			strm nextPutAll: 'These packages are modified:'; cr.			modified do: [:dep | strm nextPutAll: dep package name; cr].			strm nextPutAll: 'Do you still want to store?'])]	! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'djr 6/27/2008 18:41' prior: 23274566!checkRepositories	| bad |	bad := self repositories reject: [:repo | (repo isKindOf: MCHttpRepository) | (repo isKindOf: MCDirectoryRepository)].	^bad isEmpty or: [		self selectRepository: bad first.		self inform: (String streamContents: [:strm |			strm nextPutAll: 'Please remove these repositories:'; cr.			bad do: [:r | strm nextPutAll: r description; cr].			strm nextPutAll: '(only HTTP or Directory repositories are supported)']).		false].! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/24/2005 00:47' prior: 23275048!checkRepositoryTemplates	"unused for now - we only do HTTP"	| bad |	bad := self repositories select: [:repo | repo creationTemplate isNil].	^bad isEmpty or: [		self selectRepository: bad first.		self inform: (String streamContents: [:strm |			strm nextPutAll: 'Creation template missing for'; cr.			bad do: [:r | strm nextPutAll: r description; cr].			strm nextPutAll: 'Please fill in the details first!!']).		false].! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/21/2005 16:03' prior: 23262325!configuration	^configuration ifNil: [configuration := MCConfiguration new]! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/21/2005 14:56' prior: 23262482!configuration: aConfiguration	configuration := aConfiguration! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 4/19/2005 16:51' prior: 23271641!defaultExtent	^ 350@500! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/21/2005 16:35' prior: 23262626!dependencies	^self configuration dependencies! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 4/19/2005 16:02' prior: 23262755!dependencies: aCollection	self configuration dependencies: aCollection.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 17:56' prior: 23276313!dependencyIndex	^dependencyIndex ifNil: [0]! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 5/27/2005 19:55' prior: 23276439!dependencyIndex: anInteger	dependencyIndex := anInteger.	dependencyIndex > 0		ifTrue: [self repositoryIndex: 0].	self changed: #dependencyIndex; changed: #description.	self changedButtons.! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:28' prior: 23269577!dependencyList	^self dependencies collect: [:dep | 		Text string: dep versionInfo name			attributes: (Array streamContents: [:attr |				dep isFulfilledByAncestors					ifFalse: [attr nextPut: TextEmphasis bold]					ifTrue: [dep isCurrent ifFalse: [attr nextPut: TextEmphasis italic]].			])]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/24/2005 00:20' prior: 23271748!dependencyMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add dependency...' addDependency)).	self selectedDependency ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove dependency...' remove))].	^aMenu! !!MCConfigurationBrowser methodsFor: 'description' stamp: 'bf 4/14/2005 15:37' prior: 23270281!description	self selectedDependency ifNotNilDo: [:dep | ^ ('Package: ', dep package name, String cr,		dep versionInfo summary) asText].	self selectedRepository ifNotNilDo: [:repo | ^repo creationTemplate		ifNotNil: [repo creationTemplate asText]		ifNil: [repo asCreationTemplate asText addAttribute: TextColor red]].	^ ''! !!MCConfigurationBrowser methodsFor: 'description' stamp: 'bf 3/23/2005 22:49' prior: 23270693!description: aText	self selectedRepository ifNotNilDo: [:repo | 		| new | 		new := MCRepository readFrom: aText asString.		(new class = repo class 			and: [new description = repo description])				ifTrue: [					repo creationTemplate: aText asString.					self changed: #description]				ifFalse: [					self inform: 'This does not match the previous definition!!'				]	].! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 21:01' prior: 23263728!down	self canMoveDown ifTrue: [		self list swap: self index with: self index + 1.		self index: self index + 1.		self changedList.	].! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/21/2005 17:15' prior: 23278717!includesPackage: aPackage	^self dependencies anySatisfy: [:each | each package = aPackage]! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:43' prior: 23276714!index	^self dependencyIndex max: self repositoryIndex! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 21:00' prior: 23276850!index: anInteger	self dependencyIndex > 0 ifTrue: [^self dependencyIndex: anInteger].	self repositoryIndex > 0 ifTrue: [^self repositoryIndex: anInteger].	anInteger > 0 ifTrue: [self error: 'cannot select']! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23263958!installMenu	| menu |	menu := MenuMorph new defaultTarget: self.	menu add: 'load packages' action: #load.	menu add: 'merge packages' action: #merge.	menu add: 'upgrade packages' action: #upgrade.	menu popUpInWorld.! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:51' prior: 23277141!list	self dependencyIndex > 0 ifTrue: [^self dependencies].	self repositoryIndex > 0 ifTrue: [^self repositories].	^#()! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 17:42' prior: 23264258!load	self configuration load.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23264435!loadMenu	| menu |	menu := MenuMorph new defaultTarget: self.	menu add: 'update from image' action: #updateFromImage.	menu add: 'update from repositories' action: #updateFromRepositories.	menu popUpInWorld.! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:52' prior: 23277345!maxIndex	^ self list size! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 17:42' prior: 23264727!merge	self configuration merge.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/22/2005 22:01' prior: 23272042!pickName	| name |	name := FillInTheBlank		request: 'Name (.', self configuration writerClass extension, ' will be appended):'		initialAnswer: (self configuration name ifNil: ['']).	^ name isEmpty ifFalse: [name]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/23/2005 21:11' prior: 23272341!pickRepository	^self pickRepositorySatisfying: [:ea | true]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23272497!pickRepositorySatisfying: aBlock	| index list |	list := MCRepositoryGroup default repositories select: aBlock.	index := (PopUpMenu labelArray: (list collect: [:ea | ea description]))		startUpWithCaption: 'Repository:'.	^ index = 0 ifFalse: [list at: index]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23272853!pickWorkingCopiesSatisfying: aBlock	| copies item |	copies := (MCWorkingCopy allManagers select: aBlock)		asSortedCollection: [:a :b | a packageName <= b packageName].	item := (PopUpMenu labelArray: #('match ...'),(copies collect: [:ea | ea packageName]) lines: #(1))				startUpWithCaption: 'Package:'.	item = 1 ifTrue: [		| pattern |		pattern := FillInTheBlank request: 'Packages matching:' initialAnswer: '*'.		^pattern isEmptyOrNil			ifTrue: [#()]			ifFalse: [				(pattern includes: $*) ifFalse: [pattern := '*', pattern, '*'].				copies select: [:ea | pattern match: ea packageName]]	].	^ item = 0		ifTrue: [#()]		ifFalse: [{copies at: item - 1}]! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23264906!post	"Take the current configuration and post an update"	| name update managers names choice |	(self checkRepositories and: [self checkDependencies]) ifFalse: [^self].	name := FillInTheBlank		request: 'Update name (.cs) will be appended):'		initialAnswer: (self configuration name ifNil: ['']).	name isEmpty ifTrue:[^self].	self configuration name: name.	update := MCPseudoFileStream on: (String new: 100).	update localName: name, '.cs'.	update nextPutAll: '"Change Set:		', name.	update cr; nextPutAll: 'Date:			', Date today printString.	update cr; nextPutAll: 'Author:			Posted by Monticello'.	update cr; cr; nextPutAll: 'This is a configuration map created by Monticello."'.	update cr; cr; nextPutAll: '(MCConfiguration fromArray: #'.	self configuration fileOutOn: update.	update nextPutAll: ') upgrade.'.	update position: 0.	managers := Smalltalk at: #UpdateManager ifPresent:[:mgr| mgr allRegisteredManagers].	managers ifNil:[managers := #()].	managers size > 0 ifTrue:[		| servers index |		servers := ServerDirectory groupNames asSortedArray.		names := (managers collect:[:each| each packageVersion]), servers.		index := UIManager default chooseFrom: names lines: {managers size}.		index = 0 ifTrue:[^self].		index <= managers size ifTrue:[			| mgr |			mgr := managers at: index.			^mgr publishUpdate: update.		].		choice := names at: index.	] ifFalse:[		names := ServerDirectory groupNames asSortedArray.		choice := (SelectionMenu labelList: names selections: names) startUp.		choice == nil ifTrue: [^ self].	].	(ServerDirectory serverInGroupNamed: choice) putUpdate: update.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 21:05' prior: 23266609!remove	self canRemove ifTrue: [		self list removeAt: self index.		self changedList.		self updateIndex.	].! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/23/2005 17:41' prior: 23262964!repositories	^ self configuration repositories! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/23/2005 21:15' prior: 23263093!repositories: aCollection	^self configuration repositories: aCollection! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 17:57' prior: 23277453!repositoryIndex	^repositoryIndex ifNil: [0]! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 5/27/2005 19:55' prior: 23277579!repositoryIndex: anInteger	repositoryIndex := anInteger.	repositoryIndex > 0		ifTrue: [self dependencyIndex: 0].	self changed: #repositoryIndex; changed: #description.	self changedButtons.! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/23/2005 21:15' prior: 23275561!repositoryList	^self repositories collect: [:ea | ea description]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/23/2005 21:27' prior: 23273603!repositoryMenu: aMenu	^self fillMenu: aMenu fromSpecs: #(		('add repository...' addRepository)	)! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 23:16' prior: 23277854!selectDependency: aDependency	self dependencyIndex: (self dependencies indexOf: aDependency)! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 23:15' prior: 23278029!selectRepository: aRepository	self repositoryIndex: (self repositories indexOf: aRepository)! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 3/23/2005 17:56' prior: 23269959!selectedDependency	^ self dependencies at: self dependencyIndex ifAbsent: []! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 3/21/2005 16:30' prior: 23270121!selectedPackage	^ self selectedDependency ifNotNilDo: [:dep | dep package]! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/23/2005 17:58' prior: 23275713!selectedRepository	^ self repositories at: self repositoryIndex ifAbsent: []! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 23:38' prior: 23266800!store	(self checkRepositories and: [self checkDependencies]) ifFalse: [^self].	self pickName ifNotNilDo: [:name |		self configuration name: name.		self pickRepository ifNotNilDo: [:repo |			repo storeVersion: self configuration]].! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 20:53' prior: 23267115!up	self canMoveUp ifTrue: [		self list swap: self index with: self index - 1.		self index: self index - 1.		self changedList.	].! !!MCConfigurationBrowser methodsFor: 'updating' stamp: 'bf 5/23/2005 17:44' prior: 23278890!updateFromImage	self configuration updateFromImage.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'updating' stamp: 'bf 5/23/2005 17:44' prior: 23279078!updateFromRepositories	self configuration updateFromRepositories.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 21:00' prior: 23278204!updateIndex	self index > 0 ifTrue: [self index: (self index min: self maxIndex)]! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23267340!updateMenu	| menu |	menu := MenuMorph new defaultTarget: self.	menu add: 'update from image' action: #updateFromImage.	menu add: 'update from repositories' action: #updateFromRepositories.	menu popUpInWorld.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 17:43' prior: 23267633!upgrade	self configuration upgrade.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/23/2005 22:01' prior: 23273785!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph:selection:menu: dependencyList dependencyIndex dependencyMenu:) (0 0 1 1) (0 30 0 -180))		((listMorph:selection:menu: repositoryList repositoryIndex repositoryMenu:) (0 1 1 1) (0 -180 0 -120))		((textMorph: description) (0 1 1 1) (0 -120 0 0))	 	)! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 8/1/2008 12:17' prior: 23476705!accept	self addAsLastComment: (self findTextMorph: #logMessage) text asString.	self answer:		(Array			with: (self findTextMorph: #versionName) text asString			with: (self findTextMorph: #logMessage) text asString)	! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 8/1/2008 12:22'!addAsLastComment: aString	((self lastComments size > 0) and: [self lastComments first = aString])		ifTrue: [ ^ self ].			self lastComments addFirst: aString.	(self lastComments size > self maxCommentHistory)		ifTrue: [LastComments := LastComments copyFrom: 1 to: self maxCommentHistory]! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 8/1/2008 11:59' prior: 23476941!buttonSpecs	^ #((Accept accept 'accept version name and log message')		(Cancel cancel 'cancel saving version')		('Comments...' comment 'use previous comment')		) ! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:41' prior: 23477147!cancel	self answer: nil! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'mtf 12/11/2008 20:25'!comment	| list index |	list := self lastComments collect: [:s | s copyFrom: 1 to: (s size min: 20)].	list ifEmpty: [UIManager default inform: 'No previous comments was entered'. ^ self].	index := UIManager default chooseFrom: list.		"no comment was selected"	index isZero ifTrue: [ ^ self ].		message := self lastComments at: index.	self changed: #logMessage! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:07' prior: 23477260!defaultExtent 	^ 400@300! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:43' prior: 23477374!defaultLabel	^ 'Edit Version Name and Message:'! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 8/1/2008 12:01'!lastComments	LastComments ifNil: [ LastComments := OrderedCollection new].	^ LastComments! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'mtf 12/11/2008 20:24' prior: 23477511!logMessage	^ message ifNil: ['']! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'mtf 7/22/2008 11:00' prior: 23477662!logMessage: aString	message := aString.	self changed: #logMessage.	self accept.! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 8/1/2008 12:21'!maxCommentHistory	^ 15! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:37' prior: 23477818!versionName	^ name! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'kph 6/2/2008 19:41' prior: 23477938!versionName: aString	name := aString withBlanksTrimmed.	self changed: #versionName! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'jrp 7/2/2005 10:33' prior: 23478093!widgetSpecs	^ #(			((textMorph: versionName) (0 0 1 0) (0 0 0 30))		((textMorph: logMessage) (0 0 1 1) (0 30 0 -30))		((buttonRow) (0 1 1 1) (0 -40 0 0))		)! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23556627!answer: anObject	modalValue := anObject.	self close.! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 2/16/2004 16:50' prior: 23556748!arrowKey: aCharacter from: aPluggableListMorph 	"backstop"! !!MCTool methodsFor: 'morphic ui' stamp: 'kph 5/19/2007 00:29'!buildPanelWith: builder	|  panelBuilder |	panelBuilder := MCToolWindowBuilder builder: builder tool: self.	panelBuilder startWithWindow.	self widgetSpecs do:		[:spec | | send fractions offsets origin corner |		send := spec first.		fractions := spec at: 2 ifAbsent: [#(0 0 1 1)].		offsets := spec at: 3 ifAbsent: [#(0 0 0 0)].		origin := (offsets first @ offsets second) 			/ self defaultExtent asFloatPoint			+ (fractions first @ fractions second).		corner := (offsets third @ offsets fourth) 			/ self defaultExtent asFloatPoint			+ (fractions third @ fractions fourth).		panelBuilder frame: (origin corner: corner).		panelBuilder perform: send first withArguments: send allButFirst].	^ panelBuilder build submorphs! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23556886!buildWindow	| window |	window := SystemWindow labelled: self label.	window model: self.	self widgetSpecs do:		[:pair | |send fractions offsets|		send := pair first.		fractions := pair at: 2 ifAbsent: [#(0 0 1 1)].		offsets := pair at: 3 ifAbsent: [#(0 0 0 0)].		window			addMorph: (self perform: send first withArguments: send allButFirst )			fullFrame:				(LayoutFrame					fractions: 					((fractions first)@(fractions second) corner: 						(fractions third)@(fractions fourth))					offsets:						((offsets first)@(offsets second)  corner:							(offsets third)@(offsets fourth)))].	^ window! !!MCTool methodsFor: 'morphic ui' stamp: 'kph 5/18/2007 12:49' prior: 23557576!buildWith: builder	|  windowBuilder |	windowBuilder := MCToolWindowBuilder builder: builder tool: self.	windowBuilder startWithWindow.	self widgetSpecs do:		[:spec | | send fractions offsets origin corner |		send := spec first.		fractions := spec at: 2 ifAbsent: [#(0 0 1 1)].		offsets := spec at: 3 ifAbsent: [#(0 0 0 0)].		origin := (offsets first @ offsets second) 			/ self defaultExtent asFloatPoint			+ (fractions first @ fractions second).		corner := (offsets third @ offsets fourth) 			/ self defaultExtent asFloatPoint			+ (fractions third @ fractions fourth).		windowBuilder frame: (origin corner: corner).		windowBuilder perform: send first withArguments: send allButFirst]. 	^ windowBuilder build! !!MCTool methodsFor: 'morphic ui' stamp: 'bf 5/27/2005 19:19' prior: 23558338!buttonEnabled	^ true! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 18:34' prior: 23558426!buttonRow	^ self buttonRow: self buttonSpecs! !!MCTool methodsFor: 'morphic ui' stamp: 'al 6/21/2008 23:45' prior: 23558550!buttonRow: specArray	| aRow aButton state |	aRow := AlignmentMorph newRow.	aRow 		color: (Display depth <= 8 ifTrue: [Color transparent] ifFalse: [Color gray alpha: 0.2]);		borderWidth: 0.	aRow hResizing: #spaceFill; vResizing: #spaceFill; rubberBandCells: true.	aRow clipSubmorphs: true.	aRow layoutInset: 2@2; cellInset: 1; color: Color white.	aRow wrapCentering: #center; cellPositioning: #leftCenter.	specArray do:		[:triplet |			state := triplet at: 5 ifAbsent: [#buttonState].			aButton := PluggableButtonMorph				on: self				getState: state				action: #performButtonAction:enabled:.			aButton				hResizing: #spaceFill;				vResizing: #spaceFill;				label: triplet first asString;				arguments: (Array with: triplet second with: (triplet at: 4 ifAbsent: [#buttonEnabled])); 				onColor: Color white offColor: Color white.			aRow addMorphBack: aButton.			aButton setBalloonText: triplet third].	^ aRow! !!MCTool methodsFor: 'morphic ui' stamp: 'bf 5/27/2005 19:22' prior: 23559511!buttonSelected	^ false! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:23' prior: 23559601!buttonSpecs	^ #()! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/22/2003 00:45' prior: 23559686!buttonState	^ true! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:42' prior: 23559772!close	self window delete! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 7/24/2003 13:31' prior: 23559864!defaultAnnotationPaneHeight 	"Answer the receiver's preferred default height for new annotation panes."	^ Preferences parameterAt: #defaultAnnotationPaneHeight ifAbsentPut: [25]! !!MCTool methodsFor: 'morphic ui' stamp: 'avi 2/18/2004 19:56' prior: 23560111!defaultBackgroundColor 	^ (Color r: 0.627 g: 0.69 b: 0.976)! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:22' prior: 23560238!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:10' prior: 23560468!defaultExtent	^ 500@500! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:11' prior: 23560559!defaultLabel	^ self class name! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 22:33' prior: 23560657!fillMenu: aMenu fromSpecs: anArray	anArray do:		[:pair |		aMenu add: pair first target: self selector: pair second].	^ aMenu! !!MCTool methodsFor: 'morphic ui' stamp: 'bf 3/16/2005 14:48' prior: 23560852!findListMorph: aSymbol	^ morph submorphs detect: [:ea | (ea respondsTo: #getListSelector) and: [ea getListSelector = aSymbol]] ifNone: []! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 8/24/2003 20:15' prior: 23561057!findTextMorph: aSymbol	^ morph submorphs detect: [:ea | (ea respondsTo: #getTextSelector) and: [ea getTextSelector = aSymbol]] ifNone: []! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:23' prior: 23561262!getMenu: aMenu	^aMenu! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:36' prior: 23561351!label	^ label ifNil: [self defaultLabel]! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23561471!label: aString	label := aString! !!MCTool methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 17:30' prior: 23561570!listMorph: listSymbol	^ self		listMorph: (listSymbol, 'List') asSymbol		selection: (listSymbol, 'Selection') asSymbol		menu: (listSymbol, 'ListMenu:') asSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 2/16/2004 17:03' prior: 23561800!listMorph: listSymbol keystroke: keystrokeSymbol	^ (self		listMorph: (listSymbol, 'List') asSymbol		selection: (listSymbol, 'Selection') asSymbol		menu: (listSymbol, 'ListMenu:') asSymbol)		keystrokeActionSelector: keystrokeSymbol;		yourself! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:46' prior: 23562114!listMorph: listSymbol selection: selectionSymbol	^ PluggableListMorph		on: self		list: listSymbol		selected: selectionSymbol		changeSelected: (selectionSymbol, ':') asSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:46' prior: 23562359!listMorph: listSymbol selection: selectionSymbol menu: menuSymbol	^ PluggableListMorph		on: self		list: listSymbol		selected: selectionSymbol		changeSelected: (selectionSymbol, ':') asSymbol		menu: menuSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 2/16/2004 16:50' prior: 23562640!listMorph: listSymbol selection: selectionSymbol menu: menuSymbol keystroke: keystrokeSymbol	^ (PluggableListMorph		on: self		list: listSymbol		selected: selectionSymbol		changeSelected: (selectionSymbol, ':') asSymbol		menu: menuSymbol)		keystrokeActionSelector: keystrokeSymbol;		yourself! !!MCTool methodsFor: 'morphic ui' stamp: 'avi 9/11/2004 16:19' prior: 23563006!multiListMorph: listSymbol selection: selectionSymbol listSelection: listSelectionSymbol menu: menuSymbol	^ PluggableListMorphOfMany		on: self		list: listSymbol		primarySelection: selectionSymbol		changePrimarySelection: (selectionSymbol, ':') asSymbol		listSelection: listSelectionSymbol		changeListSelection: (listSelectionSymbol, 'put:') asSymbol		menu: menuSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:18' prior: 23563660!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!MCTool methodsFor: 'morphic ui' stamp: 'lr 10/5/2003 09:09' prior: 23563448!performButtonAction: anActionSelector enabled: anEnabledSelector	(self perform: anEnabledSelector) 		ifTrue: [ self perform: anActionSelector ]! !!MCTool methodsFor: 'morphic ui' stamp: 'kph 5/13/2007 16:53' prior: 23564074!show	modal := false.	Smalltalk at: #ToolBuilder ifPresent: [:tb |   ^ tb open: self.  ].	^self window openInWorldExtent: self defaultExtent; yourself! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23564306!showLabelled: labelString	modal := false.	self label: labelString.	^(self window)		openInWorldExtent: self defaultExtent;		yourself! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23564521!showModally	modal := true.	self window openInWorldExtent: (400@400).	[self window world notNil] whileTrue: [		self window outermostWorldMorph doOneCycle.	].	morph := nil.	^ modalValue! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 6/12/2004 14:11' prior: 23564778!step! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:36' prior: 23564850!textMorph: aSymbol	^ PluggableTextMorph on: self text: aSymbol accept: (aSymbol, ':') asSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'kph 5/21/2007 12:58'!toolPanel: selectorForTool	| subTool |		subTool := self perform: selectorForTool.		subTool ifNil:[ ^#() ].		^ subTool buildPanelWith: ToolBuilder default. ! !!MCTool methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:27' prior: 23565012!treeMorph: listSymbol	^ self		treeMorph: (listSymbol, 'Tree') asSymbol		selection: (listSymbol, 'SelectionWrapper') asSymbol		menu: (listSymbol, 'TreeMenu:') asSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:43' prior: 23565249!treeMorph: listSymbol selection: selectionSymbol menu: menuSymbol	^ SimpleHierarchicalListMorph		on: self		list: listSymbol		selected: selectionSymbol		changeSelected: (selectionSymbol, ':') asSymbol		menu: menuSymbol		keystroke: nil! !!MCTool methodsFor: 'morphic ui' stamp: 'avi 3/6/2005 22:31' prior: 23565556!treeOrListMorph: aSymbol	^ self treeMorph: aSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:40' prior: 23565674!widgetSpecs	^ #()! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23565771!window	^ morph ifNil: [morph := self buildWindow]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23586340!ancestry: anAncestry	ancestry := anAncestry! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'avi 2/13/2004 01:10' prior: 23586468!baseSnapshot	^ self snapshotForInfo: ancestry! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:41' prior: 23588389!defaultExtent	^ 440@169.	! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'avi 2/13/2004 01:09' prior: 23588501!defaultLabel	^ ancestry name, ' History'! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'avi 2/13/2004 01:09' prior: 23588627!getMenu: aMenu	index < 2 ifTrue: [^ aMenu].	self fillMenu: aMenu fromSpecs: 		(Array			with: (Array with: 'view changes -> ', ancestry name with: #viewChanges)			with: #('spawn history' spawnHistory)).	^ aMenu! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 8/22/2003 01:41' prior: 23586597!index	"Answer the value of index"	^ index! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23586736!index: anObject	"Set the value of index"	index := anObject! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23586892!infos	^ infos ifNil: [infos := ancestry withBreadthFirstAncestors]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'avi 9/17/2005 16:10' prior: 23587043!list	^ self infos collect: [:ea | ea name]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23587181!package: aMCPackage	package := aMCPackage! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 8/7/2003 21:27' prior: 23587305!repositoryGroup	^ MCRepositoryGroup default! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'avi 9/17/2005 16:09' prior: 23587433!selectedInfo	^ self infos at: self selection ifAbsent: [nil]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 8/22/2003 01:39' prior: 23587577!selectedSnapshot	^ self snapshotForInfo: self selectedInfo! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 7/11/2003 23:24' prior: 23587719!selection	^ index ifNil: [0]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23587843!selection: aNumber	index := aNumber.	self changed: #selection; changed: #summary! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 8/22/2003 01:38' prior: 23588008!snapshotForInfo: aVersionInfo	^ (self repositoryGroup versionWithInfo: aVersionInfo) snapshot! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'avi 2/13/2004 01:10' prior: 23588927!spawnHistory	MCVersionHistoryBrowser new		ancestry: self selectedInfo;		package: package;		show! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23588197!summary	| selInfo |	selInfo := self selectedInfo.	^ selInfo 		ifNil: ['']		ifNotNil: [selInfo summary]! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23589122!viewChanges	"Note that the patchLabel will be parsed in MCPatchBrowser>>installSelection, so don't translate it!!"	| patch patchLabel |	patchLabel := 'changes between {1} and {2}' format: { self selectedInfo name. ancestry name }.	patch := self baseSnapshot patchRelativeToBase: self selectedSnapshot.	(MCPatchBrowser forPatch: patch) label: patchLabel; show! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'nk 7/28/2003 18:05' prior: 23589569!widgetSpecs	^ #(		((listMorph:selection:menu: list selection getMenu:) (0 0 0.3 1))		((textMorph: summary) (0.3 0 1 1))	 	)! !!MCWorkingHistoryBrowser methodsFor: 'as yet unclassified' stamp: 'ab 8/22/2003 01:37' prior: 23663051!baseSnapshot	^ package snapshot! !!MCChangeLogEntry class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 10:36'!forVersion: aVersion in: repository	^self basicNew		version: aVersion;		repository: repository;		show;		yourself.		! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 2/8/2009 03:26'!ancestors	^ancestors ifNil: [ |  infosOfAncestors |		infosOfAncestors := self version info ancestors.		ancestors := infosOfAncestors collect: [:each | self versionForName: each name ] ]	! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 2/8/2009 03:26'!changesAccordingTo: anAncestor	^ anAncestor snapshot patchRelativeToBase: version snapshot! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 2/8/2009 03:26'!fileNameForVersionName: aVersionName	| fileNames |	fileNames := [(repository allFileNamesForVersionNamed: aVersionName)]		on: Error do: [self error: 'No such version in this repository'].	(fileNames size = 0) ifTrue: [self error: 'No file for this version'].	(fileNames size = 1) ifFalse: [self error: 'What to do with multiple files?' ].	^fileNames first	! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 10:54'!report	^ String streamContents: [ :str | self writeOn: str ].! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 2/8/2009 03:26'!repository: aRepository	repository := aRepository! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 10:43'!versionForName: aVersionName	^ repository versionFromFileNamed: (self fileNameForVersionName: aVersionName)! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 10:56'!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((textMorph: summary) (0 0 1 0.5) (0 30 0 0))		((textMorph: report) (0 0.5 1 1) (0 0 0 0))		)! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 10:39'!writeChanges: anMCPatch  on: aStream	anMCPatch operations asSortedCollection do: [:each |		aStream nextPutAll: each summary; cr ]! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 10:57'!writeOn: aStream	"aStream 		nextPutAll: version info summary; cr."	self ancestors do: [:each |		aStream 			cr; 			nextPutAll: 'Changes from: ';			nextPutAll: each info name;			cr.		self writeChanges: (self changesAccordingTo: each) on: aStream]! !!MCRepositoryVersionsInspector commentStamp: 'kph 5/16/2007 23:22' prior: 0!Customize the MCVersionInspector to show a list of versions from a repository.!!MCDictionaryRepositoryInspector class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:44'!initialOpenOnLeft: aDictRepository right: aWorkingCopy	 	^ (self new) initialSetLeft: aDictRepository andRight: (self workingCopyRepositoryWith: aWorkingCopy)! !!MCDictionaryRepositoryInspector class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:49'!workingCopyRepositoryWith: aWorkingCopy 	| dict |		dict :=  (MCDictionaryRepository new)		 		description: 'Working Copy (In Memory)'.					aWorkingCopy ifNotNil: [ 			dict	 at: aWorkingCopy name put: aWorkingCopy 	].	^ dict! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:45'!defaultLabel	^'Compare: ' , repositories first description, ' vs ', repositories second description! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:23'!initialSetLeft: l andRight: rrepositories := Array with: l with: r ! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 15:21'!sortedAndHighlightedVersions: someVersions	 	^ (self sortedVersions: (someVersions)) collect: [ :each | self versionHighlight: each fourth ]! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 15:23'!sortedVersions: someVersions	| sorter |	sorter := MCVersionSorter new.	sorter addAllVersionInfos: someVersions.	^ sorter sortedVersionInfos select: [:ea | someVersions includes: ea]! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:40'!swapSides	repositories := repositories reverse.	! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 00:20'!versionsLeftList	 	^ self sortedAndHighlightedVersions: repositories first heldVersions! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 00:20'!versionsRightList	 	^ self sortedAndHighlightedVersions: repositories last heldVersions! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:34'!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph: versionsLeft) (0 0 0.30 0.6) (0 30 0 0))		((listMorph: middle) (0.30 0 0.70 1) (0 30 0 0))		((textMorph: versionsRight) (0.70 0 1 0.6) (0 30 0 0)) )			! !!MCRepositoryDualVersionsInspector commentStamp: 'kph 6/4/2008 14:42' prior: 0!Known IssuesSome crosstalk between the two versions list... very mystifying!!MCRepositoryDualVersionsInspector class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 15:18'!repository: r repository2: r2 	^(self new) setRepository: r  repository2: r2;				yourself! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 16:36'!adopt2	(self confirm:'Modifying ancestry can be dangerous unless you knowwhat you are doing.  Are you sure you want to adopt',self version info name, ' as an ancestor of your working copy?')		ifTrue: [self version2 adopt]! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 17:41'!browse2	^ self version2 browse ! !!MCRepositoryDualVersionsInspector methodsFor: 'THE BUSINESS' stamp: 'kph 5/18/2007 13:51'!browseDiffAB 	| diff |		diff := self version asDiffAgainst: self version2.     centerPanelModel := MCSnapshotBrowser forSnapshot: diff snapshot.	 	self changed: #buildCenterPanel.! !!MCRepositoryDualVersionsInspector methodsFor: 'panel' stamp: 'kph 5/18/2007 13:35'!buildCenterPanel	centerPanelModel ifNil:[ ^#() ].		^ centerPanelModel buildPanelWith: ToolBuilder default. ! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 13:47'!buttonSpecs	^#(			('Refresh' refresh 'refresh the version-list')          		 ('Browse A' browse 'Browse this version' hasVersion)           		 ('Changes A-B' changesAB 'Browse Changes From A to B' hasVersions)			 ('Diff A-B' diffAB 'Diff From A to B' hasVersions)			 ('Browse A-B' browseDiffAB 'Browse Diff From A to B' hasVersions)			 ('Stages A..B' stagesAB 'Browse Steps from A to B' hasVersions	)	 	          		('Browse B' browse2 'Browse the second version' hasVersion2)         	)			"	 (Changes changes 'Browse the changes F' hasVersion)                           (Merge merge 'Merge this version into the image' hasVersion)              (Adopt adopt 'Adopt this version as an ancestor of your working copy'hasVersion)               (Copy copy 'Copy this version to another repository' hasVersion)              (Diff diff 'Create an equivalent version based on an earlier release'hasVersion)" 	 	! !!MCRepositoryDualVersionsInspector methodsFor: 'panel' stamp: 'kph 5/17/2007 19:37'!centerPanelSpecs	^ centerPanelModel widgetSpecs	! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 16:30'!changes2	(MCPatchBrowser forPatch: self version2 changes)		showLabelled: 'Changes from ', self version2 info name! !!MCRepositoryDualVersionsInspector methodsFor: 'THE BUSINESS' stamp: 'kph 5/18/2007 13:32'!changesAB 	thePatch := MCPatch fromBase: (self version snapshot) target: (self version2 snapshot).	centerPanelModel := MCPatchBrowser forPatch: thePatch.	self changed: #buildCenterPanel.! !!MCRepositoryDualVersionsInspector methodsFor: 'panel' stamp: 'kph 5/17/2007 19:05'!changesPanel! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 18:27'!copy2	self pickRepository ifNotNilDo:		[:ea |		ea storeVersion: self version2]! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 10:48'!defaultExtent	^550@350! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 10:50'!defaultLabel	^'Dual Change Log:  ' , repository description , ' & ',  repository2 description! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 14:34'!delete2	self isVersionDeletable ifFalse: [ ^ self ].		(self confirm: 'Are you sure you wish to delete ', selectedVersionInfo2 name, 'from ', repository description)		ifFalse: [ ^ self ].	 (repository delete: selectedVersionInfo2)		ifTrue: [ self inform: ('Successfully deleted ', selectedVersionInfo2 name) ]		ifFalse: [ self inform: ('Sorry, could not delete, ', selectedVersionInfo2 name) ].! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 16:35'!diff2	| ancestorVersion |	self pickAncestor ifNotNilDo:		[:ancestor |		ancestorVersion := self version2 workingCopy repositoryGroup versionWithInfo: ancestor.		(self version2 asDiffAgainst: ancestorVersion) open]! !!MCRepositoryDualVersionsInspector methodsFor: 'THE BUSINESS' stamp: 'kph 5/18/2007 13:49'!diffAB 	| diff |		diff := self version asDiffAgainst: self version2.     centerPanelModel :=   (MCVersionInspector new version: diff)  .	self changed: #buildCenterPanel.! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 13:19'!hasVersion2 	^ selectedVersionInfo2 notNil! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 13:19'!hasVersions 	^ self hasVersion and: [ self hasVersion2 ]! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 13:33'!initialize! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 14:36'!isVersionDeletable2"disable version deleting until sure its ok"	^ false 	"^ self repository2 ifNotNilDo:[ :r | r isDeletingAllowed ] ifNil: [ false ]"! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 04:42'!load2 	self version2 isCacheable			ifTrue: [ self version2 workingCopy repositoryGroup addRepository: repository2].			Cursor wait showWhile: [ self version2 load]		self refresh	! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 18:20'!merge2	self version2 merge.	self refresh.! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 12:54'!obtainPatch	^ MCPatch operations: #()! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 10:45'!order2: anInteger 	order2 := anInteger.	self refresh! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 10:48'!order2String: anIndex	^ self order: order2 string: anIndex! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'mtf 6/27/2008 23:18'!orderSpecs	^{		'unchanged' -> nil.		'order by package' -> [ :x :y | x <= y ].		}! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'mtf 6/27/2008 23:18'!orderSpecs2	^{		'unchanged' -> nil.		'order by package' -> [ :x :y | x <= y ].		}! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 14:39'!refresh	self versionListObtain.	self version2ListObtain.	self versionListSort.	self version2ListSort.	 	self collateHighlightingData.	self changed: #versionList.	self changed: #version2List. ! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 10:42'!repository	^ repository ! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'mtf 10/12/2008 22:40'!repository2	^ repository2! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 15:13'!setRepository: r1 repository2: r2   	order := order2 := self class order.	repository := r1.	repository2 := r2.    	self refresh! !!MCRepositoryDualVersionsInspector methodsFor: 'THE BUSINESS' stamp: 'kph 5/17/2007 16:37'!stagesAB! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 17:42'!summary2	^self hasVersion2		ifTrue: [ self version2Summary ]		ifFalse: [ String new ]! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 17:33'!version2 	^ self repository2 versionWithInfo: selectedVersionInfo2! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 6/4/2008 14:44'!version2List	^ versionInfos2 collect: [:ea | self versionHighlight: ea ]! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 18:25'!version2ListMenu: aMenu	 		self hasVersion ifNotNil: [		self fillMenu: aMenu fromSpecs:			#(			('changes B to image' #changes2)			('merge B to image' #merge2)			('load B into image' #load2)			('adopt B' #adopt2)			('copy B' #copy2)			('diff B to image' #diff2)  			('change log entry' #openChangeLogEntry2)						).		aMenu add:  'copy all' target: self selector: #copyAll2.		aMenu add:  'copy all (forked)' target: self selector: #copyAllFork2.		aMenu addLine.		self isVersionDeletable ifTrue: [   			aMenu add: 'delete' target: self selector: #delete2.		].		 	].	aMenu addLine.		self version2ListOrderMenu: aMenu.		^ aMenu! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 15:19'!version2ListObtain 	 versionInfos2 := self repository2 sortedHeldVersionInfos.	! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 6/4/2008 14:18'!version2ListOrderMenu: aMenu 	1 to: self orderSpecs2 size do: [ :index |		aMenu addUpdating: #order2String: target: self selector: #order2: argumentList: { index } ].	 	^aMenu! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 6/4/2008 14:46'!version2ListSort	 ^ self version2SortBlock ifNotNilDo: [ :sb | sb fixTemps. versionInfos2 := versionInfos2 asSortedCollection: [:b :a | [sb value: a value: b] on: Error do: [true]]].		 ! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 14:46'!version2Selection  	^ versionInfos2 indexOf: selectedVersionInfo2! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/19/2007 01:05'!version2Selection: aNumber	aNumber isZero 		ifTrue: [ selectedVersionInfo2 := nil ]		ifFalse: [ 			selectedVersionInfo2 := versionInfos2 at: aNumber].	self changed:#version2Selection; 		changed: #summary2 ;		changed: #hasVersion2;		changed: #hasVersions.! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 6/4/2008 14:17'!version2SortBlock	^ (self orderSpecs2 at: order2) value ! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 15:28'!version2Summary	selectedVersionInfo2 ifNil: [ ^ '' ].	^ (inherited detect: [ :info | info versionName = selectedVersionInfo2 versionName ] ifNone: [ self version2 ]) summary! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 18:24'!versionListMenu: aMenu	 		self hasVersion ifNotNil: [		self fillMenu: aMenu fromSpecs:			#(			('changes A to image' #changes)			('merge A to image' #merge)			('load A into image' #load)			('adopt A' #adopt)			('copy A' #copy)				('diff A to image' #diff)  			('change log entry' #openChangeLogEntry)			('spawn dual changes browser' #openDual)						).		aMenu add:  'copy all' target: self selector: #copyAll.		aMenu add:  'copy all (forked)' target: self selector: #copyAllFork.		aMenu addLine.		self isVersionDeletable ifTrue: [   			aMenu add: 'delete' target: self selector: #delete.		].		 	].	aMenu addLine.		self versionListOrderMenu: aMenu.	(self class = MCRepositoryVersionsInspector) 		ifTrue: [			aMenu addLine.			aMenu add: 'open two column display' target: self selector: #twoColumnOpen.			aMenu add: 'always use two column display' target: self selector: #twoColumnAlways.		].		^ aMenu! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 13:20'!versionSelection: aNumber	super versionSelection: aNumber.	self changed: #hasVersions.! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/21/2007 13:02'!widgetSpecs"left top right bottom"	^#(	((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph: version ) (0 0 0.25 0.6) (0 30 0 0))		((textMorph: summary) (0 0.6 0.25 1) (0 0 0 0)) 				((panel: buildCenterPanel) (0.25 0 0.75 1) (0 30 0 0))		((textMorph: summary2) (0.75 0.6 1 1) (0 0 0 0)) 		((listMorph: version2 ) (0.75 0 1 0.6) (0 30 0 0))													)! !!MCRepositoryPackagesVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 08:41'!hasPackage	^ selectedPackageName notNil! !!MCRepositoryPackagesVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:09'!menuItem900SwitchToTwoColumnInspector: aMenu	"null"! !!MCRepositoryPackagesVersionsInspector methodsFor: 'actions' stamp: 'kph 5/17/2007 10:12'!oneColumnAlways	repository class uiClassUseOneColumn. ! !!MCRepositoryPackagesVersionsInspector methodsFor: 'actions' stamp: 'kph 5/17/2007 10:20'!oneColumnOpen	| newUI |		newUI := MCRepositoryVersionsInspector				repository: repository 				selectedPackage: selectedPackageName	 			selectedVersion: selectedVersionInfo.		 newUI show.! !!MCRepositoryPackagesVersionsInspector methodsFor: 'actions' stamp: 'kph 5/17/2007 10:11'!oneColumnSwitch	| newUI newWindow |		newUI := repository class uiClassUseOneColumn 				repository: repository 				selectedPackage: selectedPackageName	 			selectedVersion: selectedVersionInfo.		Smalltalk at: #ToolBuilder ifPresent: [:tb |  		newWindow := (tb default build: newUI)		 	].		newWindow ifNil: [ 		newWindow := self window  openInWorldExtent: self defaultExtent; yourself 			].	"newWindow bounds: self window fullBounds.."	 	newWindow openInWorldExtent: self window extent; yourself. 		 	self  window closeBoxHit..! !!MCRepositoryPackagesVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 08:35'!packageHighlight: aPackageName	newer ifNil: [newer := #()].		^(loaded anySatisfy: [:each | each packageName = aPackageName])		ifTrue: [			Text string: (MCPackage named: aPackageName)					workingCopy packageNameWithStar				attribute: (TextEmphasis new emphasisCode: (					((newer includes: aPackageName)						ifTrue: [5] ifFalse: [4])))]		ifFalse: [aPackageName]! !!MCRepositoryPackagesVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 08:38'!packageList	^ packageNames collect: [ :n | self packageHighlight: n ]! !!MCRepositoryPackagesVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 10:18'!packageListMenu: aMenu			aMenu add: 'open to one column display' target: self selector: #oneColumnOpen.			aMenu add: 'always use one column display' target: self selector: #oneColumnAlways.		^ aMenu! !!MCRepositoryPackagesVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/17/2007 01:55'!packageListObtain	^ packageNames := repository packageNames ! !!MCRepositoryPackagesVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 01:54'!packageSelection	^ packageNames indexOf: selectedPackageName! !!MCRepositoryPackagesVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 9/28/2007 10:39'!packageSelection: aNumber	selectedPackageName := aNumber isZero ifFalse: [ packageNames at: aNumber ].	selectedVersionInfo := nil.	self update.	self changed: #packageSelection; changed: #versionList ; changed: #versionSelection ; changed: #summary	! !!MCRepositoryPackagesVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 01:53'!packagesNames	^  packageNames! !!MCRepositoryPackagesVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/17/2007 04:25'!setSelectedPackage: aPackage	selectedPackageName := aPackage name! !!MCRepositoryPackagesVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2007 10:38'!update	self packageListObtain.	self changed: #packageList. 		super update.  	! !!MCRepositoryPackagesVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/17/2007 02:03'!versionListObtain	^ versionInfos := self repository 		sortedVersionInfosAvailableForPackageNamed: selectedPackageName! !!MCRepositoryPackagesVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/17/2007 01:57'!widgetSpecs	^#(	((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph: package) (0 0 0.5 0.6) (0 30 0 0))		((listMorph: version) (0.5 0 1 0.6) (0 30 0 0))		((textMorph: summary) (0 0.6 1 1) (0 0 0 0)) )! !!MCRepositoryVersionsInspector class methodsFor: 'as yet unclassified' stamp: 'mtf 6/7/2008 11:34'!order	Order isNil		ifTrue: [ Order := 2 ].	^Order! !!MCRepositoryVersionsInspector class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 03:46'!order: anInteger	Order := anInteger! !!MCRepositoryVersionsInspector class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 08:56'!repository: r selectedPackage: p selectedVersion: v	^(self new) setRepository: r selectedPackage: p selectedVersion: v! !!MCRepositoryVersionsInspector class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:13'!repository: r workingCopy: wc	^(self new) setRepository: r workingCopy: wc! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/7/2009 21:16'!authorNameFor: init	^ ((Smalltalk classNamed: 'Authorship') ifNil: [ ^ '-' ]) nameFor: init! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/7/2009 21:33'!authors	(self authorsPrint: (self authorsForVersionInfo: selectedVersionInfo on: Set new)) explore! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/7/2009 21:36'!authorsAll	 | authors |	 authors := Set new.		 [versionInfos do: [ :ea | 		Transcript cr show: 'inspecting ', ea description.		self authorsForVersionInfo: ea on: authors ].		self authorsPrint: authors.	authors explore ] fork! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/8/2009 01:56'!authorsFind	(self authorsFindIn: (Array with: selectedVersionInfo)) ifEmpty:[ self inform: 'nothing found' ]! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'test 2/8/2009 02:09'!authorsFindAll	 [		self authorsFindIn: versionInfos. 		self inform: 'search complete'	] fork! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/8/2009 01:55'!authorsFindIn: vis	| list defns snap string |	string := FillInTheBlank request: 'Please enter authors'.	list := string findTokens: ','.	(string includesSubString: ',,') ifTrue: [ list add: '' ].	vis do: [ :ea |		Transcript cr; show: 'inspecting ', ea description.		version := repository versionWithInfo: ea. 		defns := version snapshot definitionsWithAnyAuthor: list.		defns ifNotEmpty: [			snap := MCSnapshot fromDefinitions: defns.			  ((MCPatchBrowser forPatch: (snap patchRelativeToBase: (MCSnapshot empty)))				label: version description;				yourself) show.		]	].	^ defns! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/7/2009 22:39'!authorsForVersionInfo: versionInfo on: aCollection 					| authors |	authors :=  [		(repository versionWithInfo: versionInfo) snapshot authorInitials 	] on: Error do: [ :ex | self notify: 'Could not read ', versionInfo description. #() ]	.		 	aCollection addAll: authors.	^ aCollection	! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/7/2009 21:33'!authorsPrint: authors	authors do: [ :init |		Transcript cr show: (init printString, ' -> ', (self authorNameFor: init) printString), '.'.	].	  	^ authors! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 8/2/2007 15:37'!browse	self hasVersion ifTrue: [ self versionInfo browseVersionFrom: repository ].	 	self refresh	! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 5/14/2007 14:47'!buttonSpecs	^#(('Refresh' refresh 'refresh the version-list')) , super buttonSpecs! !!MCRepositoryVersionsInspector methodsFor: 'highlighting' stamp: 'mtf 6/27/2008 23:20'!collateHighlightingDataloaded := Set new.inherited := Set new.newer := Set new.loadedNames := nil.inheritedNames := nil.	(MCWorkingCopy allManagers 	   	"select: [ :each | self packageNames includes: each packageName]")			do: [:each |				each ancestors do: [ :ancestor |					loaded add: ancestor  .					ancestor ancestorsDoWhileTrue: [:heir | 						(inherited includes: heir )							ifTrue: [false]							ifFalse: [inherited add: heir . true]]].									latest := (versionInfos select: [:v | v packageName = each package name])						detectMax: [:v | v ].									(latest notNil and: [					each ancestors allSatisfy: [:ancestor | latest > ancestor]])					ifTrue: [newer add: each package name ]			].		"self changed: #packageList; changed: #versionList"	 ! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 6/2/2008 19:31'!copyAll		| versionsToCopy   aVersion gotAlready | 	self pickRepository ifNotNilDo: [:aRepository |.		gotAlready := aRepository heldVersionInfos collect: [ :v | v versionName ].	versionsToCopy := versionInfos removeAllSuchThat: [ :v | gotAlready includes: v versionName ].				 		Transcript cr; show: 'versions: ', versionsToCopy asArray printString.		Cursor wait showWhile: [			versionsToCopy do: [:each |				[ aVersion := repository versionWithInfo: each.				Transcript cr; show: '',aRepository description,' storeVersion: ', aVersion description. 		aVersion info name: aVersion info name withBlanksTrimmed.		aVersion info allAncestorsDo: [ :ea | ea name: ea name withBlanksTrimmed ]. 				aRepository storeVersion: aVersion ] ifError: [ Transcript cr; show: each description, ' not readable'. ]						]		]	]! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 11/16/2007 23:24'!copyAllFork		| versionsToCopy   aVersion gotAlready | 	self pickRepository ifNotNilDo: [:aRepository |.		gotAlready := aRepository heldVersionInfos collect: [ :v | v versionName ].	versionsToCopy := versionInfos removeAllSuchThat: [ :v | gotAlready includes: v versionName ].		Transcript cr; show: 'versions: ', versionsToCopy asArray printString.	[   [		versionsToCopy do: [:each |						 [ aVersion := repository versionWithInfo: each. 				Transcript cr; show: '',aRepository description,' storeVersion: ', aVersion printString.				aRepository storeVersion: aVersion ] ifError: [ Transcript cr; show: each description, ' not readable'. ]						]		] on: Notification do: [ :ex | ex resume ].	] forkAt: Processor userBackgroundPriority.]	! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/14/2007 14:46'!defaultExtent	^450@300! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/14/2007 14:48'!defaultLabel	^'Repository: ' , repository description! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 5/14/2007 15:06'!delete	self isVersionDeletable ifFalse: [ ^ self ].		(self confirm: 'Are you sure you wish to delete ', selectedVersion, 'from ', repository description)		ifFalse: [ ^ self ].	 (repository delete: selectedVersion)		ifTrue: [ self inform: ('Successfully deleted ', selectedVersion) ]		ifFalse: [ self inform: ('Sorry, could not delete, ', selectedVersion) ].			! !!MCRepositoryVersionsInspector methodsFor: 'testing' stamp: 'kph 8/7/2007 14:09'!hasSnapshot	 	^ selectedVersionInfo notNil and: [ selectedVersionInfo hasSnapshot ]! !!MCRepositoryVersionsInspector methodsFor: 'testing' stamp: 'kph 5/17/2007 00:09'!hasVersion	^ selectedVersionInfo notNil! !!MCRepositoryVersionsInspector methodsFor: 'highlighting' stamp: 'kph 5/17/2007 07:24'!inheritedNames	^ inheritedNames ifNil: [ inheritedNames := inherited collect: [ :v | v name ]] ! !!MCRepositoryVersionsInspector methodsFor: 'testing' stamp: 'kph 5/14/2007 16:21'!isVersionDeletable"disable version deleting until sure its ok"	^ false 	"^ self repository ifNotNilDo:[ :r | r isDeletingAllowed ] ifNil: [ false ]"! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 8/1/2007 12:11'!load 	self hasVersion ifTrue: [ self versionInfo loadVersionFrom: repository ].	 	self refresh	! !!MCRepositoryVersionsInspector methodsFor: 'highlighting' stamp: 'kph 5/17/2007 07:24'!loadedNames	^ loadedNames ifNil: [ loadedNames := loaded collect: [ :v | v name ]] ! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 16:45'!menuItem010Adopt: aMenu	 		self hasSnapshot ifTrue: [ aMenu add:  'adopt' target: self selector: #adopt ].	! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 16:46'!menuItem020Diff: aMenu	 		self hasSnapshot ifTrue: [ aMenu add:  'diff' target: self selector: #diff ].	! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 16:47'!menuItem030ChangeLogEntry: aMenu	 		self hasSnapshot ifTrue: [ aMenu add:  'change log entry' target: self selector: #openChangeLogEntry ].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 16:48'!menuItem040DualChangesBrowser: aMenu	 		self hasSnapshot ifTrue: [ aMenu add: 'open dual changes browser' target: self selector: #openDual ].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 16:55'!menuItem050CopyAll: aMenu	 		aMenu add:  'copy all' target: self selector: #copyAll.! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 16:56'!menuItem051CopyAllForked: aMenu	 			aMenu add:  'copy all (forked)' target: self selector: #copyAllFork.! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:04'!menuItem060FindAuthors: aMenu	 		self hasSnapshot ifTrue: [ aMenu add:  'find authors'' code' target: self selector: #authorsFind ].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:00'!menuItem061ExploreAuthors: aMenu	 		self hasSnapshot ifTrue: [ aMenu add:  'explore authors' target: self selector: #authors. ].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:05'!menuItem070ExploreAllAuthors: aMenu	 		self hasSnapshot ifFalse: [ 		aMenu add:  'explore all authors (forked)' target: self selector: #authorsAll.	].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:04'!menuItem071FindAuthorsCode: aMenu	 		self hasSnapshot ifFalse: [ 		aMenu add:  'find authors'' code (forked)' target: self selector: #authorsFindAll.		].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:01'!menuItem100Delete: aMenu	 		self isVersionDeletable ifTrue: [ aMenu add: 'delete' target: self selector: #delete ].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:09'!menuItem200ListOrderOptions: aMenu	 		aMenu addLine.	self versionListOrderMenu: aMenu.	! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:09'!menuItem900SwitchToTwoColumnInspector: aMenu	 		aMenu addLine.	aMenu add: 'open two column display' target: self selector: #twoColumnOpen.	aMenu add: 'always use two column display' target: self selector: #twoColumnAlways.! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 8/1/2007 12:51'!merge 	self hasVersion ifTrue: [ self versionInfo mergeVersionFrom: repository ].	 	self refresh	! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 5/16/2007 21:02'!openChangeLogEntry	(MCChangeLogEntry new version: self version; repository: repository) show.! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 5/17/2007 15:23'!openDual   |  dual r2 |	r2 := self pickRepository.		dual :=	MCRepositoryDualVersionsInspector repository: self repository repository2: r2.			dual versionSelection: self versionSelection.		dual show.! !!MCRepositoryVersionsInspector methodsFor: 'ordering' stamp: 'kph 5/17/2007 06:18'!order: anInteger	self class order: (order := anInteger).	self refresh! !!MCRepositoryVersionsInspector methodsFor: 'ordering' stamp: 'kph 5/17/2007 10:46'!order: setting string: anIndex	^String streamContents: [ :stream |		setting = anIndex			ifTrue: [ stream nextPutAll: '<yes>' ]			ifFalse: [ stream nextPutAll: '<no>' ].		stream nextPutAll: (self orderSpecs at: anIndex) key ]! !!MCRepositoryVersionsInspector methodsFor: 'ordering' stamp: 'mtf 6/27/2008 23:20'!orderSpecs	^{		'unchanged' -> nil.		'order by package' -> [ :x :y | x <= y ].		}! !!MCRepositoryVersionsInspector methodsFor: 'ordering' stamp: 'kph 5/17/2007 10:47'!orderString: anIndex	^ self order: order string: anIndex! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 9/28/2007 11:02'!refresh	self repository heldVersionInfosClearCache. 	self update  	! !!MCRepositoryVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/16/2007 23:38'!repository	^ repository ! !!MCRepositoryVersionsInspector methodsFor: 'initialize-release' stamp: 'mtf 6/7/2008 12:27'!setRepository: aRepository selectedPackage: package selectedVersion: versionInfo	order := self class order.	repository := aRepository.     package isNil ifFalse: [ self setSelectedPackage: package].	self refresh! !!MCRepositoryVersionsInspector methodsFor: 'initialize-release' stamp: 'kph 5/17/2007 04:24'!setRepository: aRepository workingCopy: aWorkingCopy	order := self class order.	repository := aRepository.     aWorkingCopy isNil ifFalse: [ self setSelectedPackage: aWorkingCopy package].	self refresh! !!MCRepositoryVersionsInspector methodsFor: 'initialize-release' stamp: 'kph 5/17/2007 04:25'!setSelectedPackage: aPackage! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 5/17/2007 10:20'!twoColumnOpen	| newUI |		newUI := MCRepositoryPackagesVersionsInspector				repository: repository 				selectedPackage: nil	 			selectedVersion: selectedVersionInfo.		 newUI show.	! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 5/17/2007 10:15'!twoColumnSwitch	 ! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 5/17/2007 09:28'!twoColumnsAlways	repository class uiClassUseTwoColumn.	self twoColumnSwitch! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 9/28/2007 10:41'!update	self versionListObtain.	self versionListSort.	 	self collateHighlightingData.	self changed: #versionList. ! !!MCRepositoryVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/17/2007 00:55'!version 	^ self repository versionWithInfo: selectedVersionInfo! !!MCRepositoryVersionsInspector methodsFor: 'highlighting' stamp: 'kph 5/17/2007 07:26'!versionHighlight: anInfo	^Text		string: anInfo name		attribute: (TextEmphasis new emphasisCode: (			(self loadedNames includes: anInfo versionName) ifTrue: [ 4 "underlined" ]				ifFalse: [ (self inheritedNames includes: anInfo versionName)					ifTrue: [ 0 ]					ifFalse: [ 1 "bold" ] ]))							! !!MCRepositoryVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/22/2007 16:56'!versionInfo 	^ selectedVersionInfo realizeFrom: repository! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 16:18'!versionList	^ versionInfos collect: [:ea | (self versionHighlight: ea) ]! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 2/11/2009 17:13'!versionListMenu: aMenu		((self class allSelectorsBelow: MCTool) 		select: [ :sel | (sel beginsWith: #menuItem) ]) asSortedCollection		do: [ :ea | self perform: ea with: aMenu ].	^ aMenu! !!MCRepositoryVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/17/2007 08:08'!versionListObtain 	 versionInfos := self repository sortedHeldVersionInfos.	! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 03:43'!versionListOrderMenu: aMenu 	1 to: self orderSpecs size do: [ :index |		aMenu addUpdating: #orderString: target: self selector: #order: argumentList: { index } ].	 	^aMenu! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 6/4/2008 14:46'!versionListSort	 self versionsSortBlock ifNotNilDo: [ :sb | versionInfos := versionInfos asSortedCollection: [:b :a | [sb value: a value: b] on: Error do: [true]]].		 ! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 06:17'!versionSelection  	^ versionInfos indexOf: selectedVersionInfo! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 8/1/2007 13:18'!versionSelection: aNumber	aNumber isZero 		ifTrue: [ selectedVersionInfo := nil ]		ifFalse: [ 			selectedVersionInfo := versionInfos at: aNumber].				 	self changed:#versionSelection; changed: #summary ; changed: #hasVersion; changed: #hasSnapshot.! !!MCRepositoryVersionsInspector methodsFor: 'highlighting' stamp: 'kph 5/22/2007 16:48'!versionSummary	^ (inherited detect: [ :info | info versionName = selectedVersionInfo versionName ] ifNone: [ self versionInfo ]) summary! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 6/4/2008 14:06'!versionsSortBlock	^ (self orderSpecs at: order) value ! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/16/2007 23:23'!widgetSpecs	^#(	((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph: version) (0 0 1 0.6) (0 30 0 0))		((textMorph: summary) (0 0.6 1 1) (0 0 0 0)) )! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:19' prior: 23595372!adopt	(self confirm:'Modifying ancestry can be dangerous unless you knowwhat you are doing.  Are you sure you want to adopt',self version info name, ' as an ancestor of your working copy?')		ifTrue: [self version adopt]! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 8/2/2007 15:22' prior: 23595684!browse 	self version browse! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'kph 8/7/2007 14:10' prior: 23597666!buttonSpecs       ^ #((Browse browse 'Browse this version' hasVersion)               (History history 'Browse the history of this version' hasVersion)               (Changes changes 'Browse the changes this version would make to theimage' hasVersion)               (Load load 'Load this version into the image' hasVersion)               (Merge merge 'Merge this version into the image' hasVersion)             "  (Adopt adopt 'Adopt this version as an ancestor of your working copy'hasVersion)"               (Copy copy 'Copy this version to another repository' hasVersion)            "   (Diff diff 'Create an equivalent version based on an earlier release'hasVersion)" )! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 8/7/2007 14:13' prior: 23595799!changes 	(MCPatchBrowser forPatch: self version changes)		showLabelled: 'Changes from ', self version info name! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 6/12/2008 23:02'!copy 	self pickRepository ifNotNilDo: [:ea | ea storeVersion: self version ]	  ! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 6/2/2008 19:38'!copyAll	self halt.! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'avi 8/31/2003 00:45' prior: 23598424!defaultExtent	^ 400@200! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'avi 2/28/2004 20:18' prior: 23598528!defaultLabel	^ 'Version: ', self version info name! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23596011!diff	| ancestorVersion |	self pickAncestor ifNotNilDo:		[:ancestor |		ancestorVersion := self version workingCopy repositoryGroup versionWithInfo: ancestor.		(self version asDiffAgainst: ancestorVersion) open]! !!MCVersionInspector methodsFor: '' stamp: 'kph 8/7/2007 14:08'!hasSnapshot	^ self version notNil! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 00:07' prior: 23596313!hasVersion	^ self version notNil! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 17:14' prior: 23596429!history	(MCVersionHistoryBrowser new ancestry: self versionInfo) show! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 15:46' prior: 23596587!load	Cursor wait showWhile: [ self version load]! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 18:19' prior: 23596724!merge	self version merge.	self refresh.! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23598670!pickAncestor	| index versions |	versions := self version info breadthFirstAncestors.	index := (PopUpMenu labelArray: (versions collect: [:ea | ea name]))				startUpWithCaption: 'Ancestor:'.	^ index = 0 ifFalse: [versions at: index]! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23598997!pickRepository	| index |	index := (PopUpMenu labelArray: (self repositories collect: [:ea | ea description]))				startUpWithCaption: 'Repository:'.	^ index = 0 ifFalse: [self repositories at: index]! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'avi 8/31/2003 00:44' prior: 23599279!repositories	^ MCRepositoryGroup default repositories! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/14/2007 14:32'!repository 	^ nil! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 17:16' prior: 23597006!summary	^self hasVersion		ifTrue: [ self versionSummary ]		ifFalse: [ String new ]! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:19' prior: 23597180!version	^ version! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23597546!version: aVersion	version := aVersion! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 17:16' prior: 23597287!versionInfo	^ self version info! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 17:16' prior: 23597408!versionSummary	^ self version summary! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 18:43' prior: 23599412!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((textMorph: summary) (0 0 1 1) (0 30 0 0))		)! !!MCWorkingCopyBrowser class methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 23:38' prior: 23651307!initialize	 (TheWorldMenu respondsTo: #registerOpenCommand:)         ifTrue: [TheWorldMenu registerOpenCommand: {'Monticello Browser'. {self. #open}}]! !!MCWorkingCopyBrowser class methodsFor: 'as yet unclassified' stamp: 'kph 5/13/2007 16:47' prior: 23651683!open	^ self new show! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 11/4/2005 17:46'!addPackageRepository	workingCopy ifNotNil:		[		(self pickRepositorySatisfying: [ :repos | (workingCopy repositoryGroup includes: repos) not ])			ifNotNilDo:				[:repos |					workingCopy repositoryGroup addRepository: repos.					self repository: repos.						self						changed: #repositoryList;						changed: #repositorySelection.					self changedButtons]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bkv 2/18/2004 21:22' prior: 23632832!addRepository	self newRepository ifNotNilDo:		[:repos | self addRepository: repos ].! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/21/2005 15:58' prior: 23633828!addRepository: aRepository	self repository: aRepository.	self repositoryGroup addRepository: aRepository.	self changed: #repositoryList; changed: #repositorySelection.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23633009!addRepositoryToPackage	self repository ifNotNilDo:		[:repos |		(self pickWorkingCopySatisfying: [ :p | (p repositoryGroup includes: repos) not ]) ifNotNilDo:			[:wc |			workingCopy := wc.			workingCopy repositoryGroup addRepository: repos.			self repository: repos.				self				changed: #workingCopySelection;				changed: #repositoryList;				changed: #repositorySelection.			self changedButtons]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 6/28/2007 22:58'!addRepositoryToPackagesMatching	| result |	result := FillInTheBlank request: 'packages matching: ' initialAnswer: 'My*'.	result size > 0 ifTrue: [		self addRepositoryToPackagesMatching: result.	]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 5/17/2007 00:34'!addRepositoryToPackagesMatching: aString	self repository ifNotNilDo:  		[:repos |			(self workingCopies select: [:each | aString match: each package name ]) 				do: [ :wc | 					Transcript cr; show: 'add ', wc package name, ' to ', repos description.					wc repositoryGroup addRepository: repos]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/21/2005 15:57' prior: 23633494!addRepositoryToWorkingCopy	workingCopy ifNotNilDo:		[:wc |			workingCopy repositoryGroup addRepository: self repository.			self				changed: #workingCopySelection;				changed: #repositoryList;				changed: #repositorySelection.			self changedButtons]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'AlexandreBergel 7/30/2008 13:47'!addRequiredDirtyPackage	| dirtyPackages |	dirtyPackages := self workingCopies select: [:copy | copy needsSaving].	workingCopy ifNotNilDo:		[:wc |		dirtyPackages do:			[:required |			wc requirePackage: required package]].		self workingCopyListChanged! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 2/14/2004 02:45' prior: 23634098!addRequiredPackage	workingCopy ifNotNilDo:		[:wc |		self pickWorkingCopy ifNotNilDo:			[:required |			wc requirePackage: required package.			self workingCopyListChanged]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23634364!addWorkingCopy	|name|	name := FillInTheBlankMorph request: 'Name of package:'.	name isEmptyOrNil ifFalse:		[PackageInfo registerPackageName: name.		workingCopy := MCWorkingCopy forPackage: (MCPackage new name: name).		workingCopyWrapper := nil.		self repositorySelection: 0].	self workingCopyListChanged; changed: #workingCopySelection; changed: #repositoryList.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 12/7/2008 03:51'!ancestryGoBackOne	(self notify: 'are you sure you want to discard the most recent history entry').	 		workingCopy ancestry ancestors in: [ :a | a at: 1 put: a first ancestors first ].			self workingCopyListChanged.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/21/2005 15:38' prior: 23634834!backportChanges	self canBackport ifFalse: [^self].	workingCopy ifNotNil:		[workingCopy needsSaving ifTrue: [^ self inform: 'You must save the working copy before backporting.'].		self pickAncestorVersionInfo ifNotNilDo:			[:baseVersionInfo |			workingCopy backportChangesTo: baseVersionInfo]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ab 7/19/2003 22:58' prior: 23635210!browseWorkingCopy	workingCopy ifNotNil:		[(MCSnapshotBrowser forSnapshot: workingCopy package snapshot)			label: 'Snapshot Browser: ', workingCopy packageName;			show]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 2/28/2005 16:28' prior: 23641113!buttonSpecs       ^ #(               ('+Package' addWorkingCopy 'Add a new package and make it the working copy')               (Browse browseWorkingCopy 'Browse the working copy of the selected package' hasWorkingCopy)               (Scripts editLoadScripts 'Edit the load/unload scripts of this package' hasWorkingCopy)               (History viewHistory 'View the working copy''s history' hasWorkingCopy)               (Changes viewChanges 'View the working copy''s changes relative to the installed version from the repository' canSave)               (Backport backportChanges 'Backport the working copy''s changes to an ancestor' canBackport)               (Save saveVersion 'Save the working copy as a new version to the selected repository' canSave)             ('+Repository' addRepository 'Add an existing repository to the list of those visible')               (Open openRepository 'Open a browser on the selected repository' hasRepository)               )! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 5/11/2007 05:07' prior: 23635460!canBackport	^ self hasWorkingCopy and: [ workingCopy canBackport ]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 8/7/2003 21:22' prior: 23642170!canSave	^ self hasWorkingCopy and: [self hasRepository]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'bf 6/21/2005 15:50' prior: 23642307!changedButtons	self changed: #hasWorkingCopy.	self changed: #canSave.	self changed: #canBackport.	self changed: #hasRepository.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 8/1/2007 11:42' prior: 23635619!checkForNewerVersions	| newer | 	newer := workingCopy possiblyNewerVersionsIn: self repository.	^ newer isEmpty or: [		self confirm: 'CAUTION!! These versions in the repository may be newer:', 			String cr, newer asString, String cr,			'Do you really want to save this version?'].! !!MCWorkingCopyBrowser methodsFor: 'orphanage' stamp: 'kph 5/10/2007 17:24'!clearOrphans	self orphanage clearOrphans.	self workingCopyListChanged.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 2/14/2004 02:46' prior: 23635982!clearRequiredPackages	workingCopy ifNotNilDo:		[:wc |		wc clearRequiredPackages.		self workingCopyListChanged]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 2/7/2009 18:27' prior: 23642521!defaultExtent	^ 620@400! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 23:38' prior: 23642626!defaultLabel	^ 'Monticello Browser'! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23642755!defaults	^ defaults ifNil: [defaults := Dictionary new]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 2/14/2004 02:46' prior: 23636174!deleteWorkingCopy	workingCopy unregister.	self workingCopySelection: 0.	self workingCopyListChanged.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23642904!editLoadScripts	| menu |	self hasWorkingCopy ifFalse: [^self].	menu := MenuMorph new defaultTarget: self.	menu add: 'edit preamble' selector: #editScript: argument: #preamble.	menu add: 'edit postscript' selector: #editScript: argument: #postscript.	menu add: 'edit preambleOfRemoval' selector: #editScript: argument: #preambleOfRemoval.	menu add: 'edit postscriptOfRemoval' selector: #editScript: argument: #postscriptOfRemoval.	menu popUpInWorld.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 5/16/2007 12:53' prior: 23636355!editRepository	| newRepo |		newRepo := self repository openAndEditTemplateCopy.	newRepo ifNotNil: [ 		newRepo class = self repository class			ifTrue: [self repository copyFrom: newRepo]			ifFalse: [self inform: 'Must not change repository type!!']].	self changed: #repositoryList.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 2/17/2009 12:05' prior: 23643454!editScript: scriptSymbol	| script |		workingCopy packageInfo in: [ :pi |		 script := (pi propertyAt: scriptSymbol) ifNil: [ pi propertyDefaultAt: scriptSymbol ].	].	script openLabel: scriptSymbol asString, ' of the Package ', workingCopy package name.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 5/14/2007 13:14'!exploreWorkingCopy	workingCopy ifNotNil: [workingCopy explore]! !!MCWorkingCopyBrowser methodsFor: 'orphanage' stamp: 'kph 10/2/2007 18:40'!fixAllObsoleteReferences"self fixAllObsoleteReferences"(SystemNavigation default obsoleteBehaviors select: [ :c | c isMeta not ])	do: [ :obsClass | 				([obsClass nonObsoleteClass] ifError: [ nil]) ifNotNilDo: 			[ :actualClass |								actualClass updateInstancesFrom: obsClass. 				obsClass becomeForward: actualClass.								([obsClass metaclass] ifError:[nil]) ifNotNilDo:					[:metaClass |						metaClass becomeForward: actualClass class ]]].					SmalltalkImage current fixObsoleteReferences! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/3/2005 15:08' prior: 23636688!flushAllCaches	| beforeBytes afterBytes beforeVersions afterVersions |	Cursor wait showWhile: [		beforeBytes := Smalltalk garbageCollect.		beforeVersions := MCVersion allSubInstances size.		MCFileBasedRepository flushAllCaches.		afterBytes := Smalltalk garbageCollect.		afterVersions := MCVersion allSubInstances size.	].	^self inform: (beforeVersions - afterVersions) asString, ' versions flushed', String cr, 		(afterBytes - beforeBytes) asStringWithCommas, ' bytes reclaimed'! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 11/4/2005 16:57'!flushPasswords	MCRepository allSubInstancesDo:[:repo| repo flushPasswords].! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/22/2003 02:21' prior: 23643715!hasRepository	^ self repository notNil! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/22/2003 00:46' prior: 23643835!hasWorkingCopy	^ workingCopy notNil! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 11/16/2003 20:21' prior: 23643954!initialize	MCWorkingCopy addDependent: self.	self workingCopies do: [:ea | ea addDependent: self].! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/21/2005 15:58' prior: 23637396!loadRepositories	FileStream fileIn: 'MCRepositories.st'.	self changed: #repositoryList.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23637598!newRepository	| types index |	types := MCRepository allConcreteSubclasses asArray.	index := (PopUpMenu labelArray: (types collect: [:ea | ea description]))				startUpWithCaption: 'Repository type:'.	^ index = 0 ifFalse: [(types at: index) morphicConfigure]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 17:15'!openDual   |  dual r2 |	r2 := self pickRepositorySatisfying: [:ea | true].		dual :=	MCRepositoryDualVersionsInspector repository: self repository repository2: r2.	 	dual show.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 4/25/2008 00:48' prior: 23637937!openRepository	 	[ self repository ifNotNilDo: [:repos | repos morphicOpen: workingCopy ] ] fork! !!MCWorkingCopyBrowser methodsFor: 'orphanage' stamp: 'kph 5/5/2007 04:00'!orphanage	^ MCOrphanage current! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23644147!pickAncestorVersionInfo	| ancestors index |	ancestors := workingCopy ancestry breadthFirstAncestors.	index := (PopUpMenu labelArray: (ancestors collect: [:ea | ea name]))				startUpWithCaption: 'Ancestor:'.	^ index = 0 ifFalse: [ ancestors at: index]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'mtf 6/9/2008 20:58'!pickRepositorySatisfying: aBlock	| repos index |	repos := MCRepositoryGroup default repositories select: aBlock.	index := (PopUpMenu labelArray: (repos collect: [:ea | ea descriptionDisplay ]))				startUpWithCaption: 'Repository:'.	^ index = 0 ifFalse: [repos at: index]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'nk 3/9/2004 14:39' prior: 23644482!pickWorkingCopy	^self pickWorkingCopySatisfying: [ :c | true ]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23644638!pickWorkingCopySatisfying: aBlock	| copies index |	copies := self workingCopies select: aBlock.	copies isEmpty ifTrue: [ ^nil ].	index := (PopUpMenu labelArray: (copies collect: [:ea | ea packageName]))				startUpWithCaption: 'Package:'.	^ index = 0 ifFalse: [ copies at: index]! !!MCWorkingCopyBrowser methodsFor: 'orphanage' stamp: 'kph 4/24/2008 01:07'!recompileAllPackages	self workingCopies do: [ :each | self log monticello recompilingPackage: each packageName. each recompilePackage. ]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 5/13/2007 01:43' prior: 23638101!recompilePackage 	workingCopy recompilePackage! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/21/2005 15:58' prior: 23638331!removeRepository	self repository ifNotNilDo:		[:repos |		self repositoryGroup removeRepository: repos.		self repositorySelection: (1 min: self repositories size)].	self changed: #repositoryList.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 6/28/2007 22:59'!removeRepositoryFromPackagesMatching	| result |	result := FillInTheBlank request: 'packages matching: ' initialAnswer: 'My*'.	result size > 0 ifTrue: [		self removeRepositoryFromPackagesMatching: result.	]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 5/17/2007 00:37'!removeRepositoryFromPackagesMatching: aString	self repository ifNotNilDo:		[:repos |			(self workingCopies select: [:each | aString match: each package name ]) 				do: [ :wc | 					Transcript cr; show: 'remove ', repos description, ' from ', wc package name.					wc repositoryGroup removeRepository: repos]]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 8/7/2003 21:32' prior: 23645002!repositories	^ self repositoryGroup repositories! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23638643!repository	workingCopy ifNotNil: [repository := self defaults at: workingCopy ifAbsent: []].	^ repository! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23638840!repository: aRepository	repository := aRepository.	workingCopy ifNotNil: [self defaults at: workingCopy put: aRepository]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 8/7/2003 21:32' prior: 23645131!repositoryGroup	^ workingCopy		ifNil: [MCRepositoryGroup default]		ifNotNil: [workingCopy repositoryGroup]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 5/16/2007 22:48' prior: 23645321!repositoryList	^ self repositories collect: [:ea | ea descriptionDisplay]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 17:14' prior: 23645468!repositoryListMenu: aMenu	self repository ifNil: [^ aMenu].	self fillMenu: aMenu fromSpecs:		#(('open repository' #openRepository)		    ('edit repository info' #editRepository)		   ('add to package...' #addRepositoryToPackage)		   ('add to packages matching...' #addRepositoryToPackagesMatching)		   ('remove from packages matching...' #removeRepositoryFromPackagesMatching)		   ('show feed' #showFeed)		   ('remove repository' #removeRepository)			   ('load repositories' #loadRepositories)			   ('save repositories' #saveRepositories)		   ('flush cached versions' #flushAllCaches)			   ('flush passwords' #flushPasswords)			   ('open dual changes browser' #openDual)			).		aMenu		add: (self repository alwaysStoreDiffs					ifTrue: ['store full versions']					ifFalse: ['store diffs'])		target: self		selector: #toggleDiffs.	^ aMenu				! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/22/2003 02:22' prior: 23646142!repositorySelection	^ self repositories indexOf: self repository! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'bf 6/21/2005 15:56' prior: 23646288!repositorySelection: aNumber	aNumber = 0		ifTrue: [self repository: nil]		ifFalse: [self repository: (self repositories at: aNumber)].	self changed: #repositorySelection.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 5/11/2005 15:20' prior: 23639041!revertPackage	self pickAncestorVersionInfo ifNotNilDo: [:info |		(self repositoryGroup versionWithInfo: info			ifNone: [^self inform: 'No repository found for ', info name]		) load]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'avi 9/10/2004 17:46' prior: 23639305!saveRepositories	| f |	f := FileStream forceNewFileNamed: 'MCRepositories.st'.	MCRepositoryGroup default repositoriesDo: [:r |		f nextPutAll: 'MCRepositoryGroup default addRepository: (', r asCreationTemplate, ')!!'; cr.]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 12/8/2008 04:34' prior: 34178190!saveVersion	| repo |		self canSave ifFalse: [^self].	self checkForNewerVersions ifFalse: [^self].	repo := self repository.	workingCopy newVersion ifNotNilDo: [:v |		'Saving package' displayProgressAt: Sensor cursorPoint		from: 0 to:100		during:[:bar|			bar value: 10.			repo storeVersion: v.			bar value: 80.						MCCacheRepository default cacheAllFileNamesDuring: 			[ repo cacheAllFileNamesDuring: [				v allAvailableDependenciesDo:					[:dep |					(repo includesVersionNamed: dep info name)						ifFalse: [repo storeVersion: dep]].			]].			bar value: 100.		].		workingCopy repositoryGroup addRepository: repository.	]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 1/27/2006 18:31'!showFeed	| parser xml text |	parser := Smalltalk at: #XMLDOMParser		ifAbsent: [^self inform: 'Yaxo not installed'].	Cursor wait showWhile: [		xml := self repository readStreamForFileNamed: 'feed.rss'			do: [:stream | parser parseDocumentFrom: stream ]].	xml ifNil: [^self inform: 'feed.rss not found'].	text := Text streamContents: [:stream |		xml tagsNamed: #item do: [:item |			#(title bold author italic pubDate normal description normal) pairsDo: [:tag :attr |				stream withAttribute: (TextEmphasis perform: attr) do: [					item tagsNamed: tag do: [:element | 						stream nextPutAll: (element contentString							copyReplaceAll: '<br/>' with: String cr) ; space]].				attr = #normal ifTrue: [stream cr]]]].	UIManager default edit: text label: 'Feed: ', self repository description! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 8/31/2004 01:14' prior: 23646567!toggleDiffs	self repository alwaysStoreDiffs		ifTrue: [self repository doNotAlwaysStoreDiffs]		ifFalse: [self repository doAlwaysStoreDiffs]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'avi 10/22/2005 19:34'!trimAncestry	self pickAncestorVersionInfo ifNotNilDo:		[:ancestor |		workingCopy ancestry trimAfterVersionInfo: ancestor]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 2/12/2009 00:42'!trimAncestryAll	self workingCopies do: [ :ea | ea  trimAncestry ]			 ! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 12/7/2008 03:38'!trimOldestAncestry	self pickAncestorVersionInfo ifNotNilDo:		[:ancestor |		workingCopy ancestry trimAfterVersionInfo: ancestor]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 2/14/2004 02:46' prior: 23640176!unloadPackage	workingCopy unload.	self workingCopySelection: 0.	self workingCopyListChanged.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 9/10/2004 17:54' prior: 23646792!unsortedWorkingCopies	^ MCWorkingCopy allManagers ! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 9/10/2004 17:54' prior: 23646925!update: aSymbol	self unsortedWorkingCopies do: [:ea | ea addDependent: self].	self workingCopyListChanged.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'mtf 6/9/2008 20:58' prior: 23640361!viewChanges	| patch |	'Finding changes' displayProgressAt: Sensor cursorPoint from: 0 to: 10 during:[:bar|		self canSave ifTrue:[		bar value: 1.		patch := workingCopy changesRelativeToRepository: self repository].		patch isNil ifTrue: [^ self].		bar value:3.		patch isEmpty			ifTrue: [ workingCopy modified: false.				bar value: 10.				self inform: 'No changes' ]			ifFalse:				[ workingCopy modified: true.				bar value: 5.				(MCPatchBrowser forPatch: patch)					label: 'Patch Browser: ', workingCopy description;					show]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'avi 2/13/2004 01:13' prior: 23640827!viewHistory	workingCopy ifNotNil:		[(MCWorkingHistoryBrowser new				ancestry: workingCopy ancestry;				package: workingCopy package)			label:  'Version History: ',  workingCopy packageName;			show]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 4/24/2008 04:33'!viewMemoryUse	| total sizeCalc classes  |		total := 0.        	sizeCalc := [ :roots | (ImageSegment new 							copyFromRoots: 								(roots reject: [:aRoot | 										aRoot isNil or: 										[ aRoot indexIfCompact > 0]]) 								sizeHint: 100000) segment byteSize ].                    classes :=                 ((workingCopy packageInfo classes collect: [ :cls |                | size  | 			size := sizeCalc value: ((cls classPool values asOrderedCollection) add: cls ; add: cls class; yourself).                                   	        		total := total + size.			cls name -> size.                     ]) asSortedCollection: [ :a :b | b value <= a value ]) asOrderedCollection.        classes addFirst: 'Total' -> total.                 classes explore.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 4/24/2008 04:23'!viewMemoryUseAll	| total sizeCalc packages globals  |		total := 0.        	sizeCalc := [ :roots | (ImageSegment new 							copyFromRoots: 								(roots reject: [:aRoot | 										aRoot isNil or: 										[ aRoot indexIfCompact > 0]]) 								sizeHint: 100000) segment byteSize ].                    packages :=                 ((MCWorkingCopy allManagers collect: [ :each |                | size  | 			size := sizeCalc value:			                                         (each packageInfo classes in: [ :cls |                        (cls , (cls collect: [ :c | c class ]), (cls gather: [ :c | c classPool ]))                         ]).               	        		total := total + size.		     each package name -> size.                     ]) asSortedCollection: [ :a :b | b value <= a value ]) asOrderedCollection.	   globals := Smalltalk globals collect: [ :assoc |				| size | 				size := (sizeCalc value: (Array with: assoc value)).		total := total + size.		assoc key -> size.				].		   packages addFirst: (#Globals -> globals).        packages addFirst: 'Total' -> total.                 packages explore.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 2/7/2009 18:27' prior: 23647114!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 29))		((treeOrListMorph: workingCopy) (0 0 0.5 1) (0 30 0 0))		((listMorph: repository) (0.5 0 1 1) (0 30 0 0))		)! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'mtf 7/21/2008 18:41' prior: 23647363!workingCopies"List the working copies with the changed packages at the top"	| c |	c := MCWorkingCopy allManagers asSortedCollection:		[ :a :b | a package name <= b package name ].	^ (c select: [:mc| mc needsSaving]) asOrderedCollection, (c reject: [:mc| mc needsSaving]) asOrderedCollection.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23650947!workingCopy: wc	workingCopy := wc.	self changed: #workingCopyList; changed: #workingCopySelection; changed: #repositoryList.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 2/12/2009 00:28'!workingCopyAllMenu: aMenu 	aMenu add: 'trim ALL ancestry' target: self selector: #trimAncestryAll.	^aMenu! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 1/19/2004 16:41' prior: 23647554!workingCopyList	^ self workingCopies collect:		[:ea |		(workingCopy notNil and: [workingCopy requiredPackages includes: ea package])			ifTrue: [Text string: ea description emphasis: (Array with: TextEmphasis bold)]			ifFalse: [ea description]]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/23/2006 18:30' prior: 23647883!workingCopyListChanged	self changed: #workingCopyList.	self changed: #workingCopyTree.	self changed: #workingCopyTreeRoots.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 2/12/2009 00:32' prior: 23648075!workingCopyListMenu: aMenu 	workingCopy ifNil: [ ^ self workingCopyAllMenu: aMenu ] ifNotNilDo: [ :wc | wc myMenu: aMenu inBrowser: self  ].		^ aMenu! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 23:11' prior: 23648753!workingCopyListMorph	^ PluggableMultiColumnListMorph		on: self		list: #workingCopyList		selected: #workingCopySelection		changeSelected: #workingCopySelection:		menu: #workingCopyListMenu:! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 22:05' prior: 23649028!workingCopySelection	^ self workingCopies indexOf: workingCopy! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:48' prior: 23649552!workingCopySelection: aNumber	self workingCopy: 		(aNumber = 0 			ifTrue:[nil]			ifFalse:[self workingCopies at: aNumber]).	! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:38' prior: 23649172!workingCopySelectionWrapper	^workingCopyWrapper! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:57' prior: 23649301!workingCopySelectionWrapper: aWrapper	workingCopyWrapper := aWrapper.	self changed: #workingCopySelectionWrapper.	self workingCopy: (aWrapper ifNotNil:[aWrapper item])! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:30' prior: 23649761!workingCopyTree	^ self workingCopies collect:[:each| MCDependentsWrapper with: each model: self].! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/23/2006 18:10'!workingCopyTreeChildrenOf: aWorkingCopy	| workingCopies |	workingCopies := self unsortedWorkingCopies.	^aWorkingCopy requiredPackages collect:[:each | 			workingCopies detect: [:wc | wc package = each] ifNone: [nil]]			thenSelect: [:x | x notNil].! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/23/2006 18:15'!workingCopyTreeLabelOf: aWorkingCopy	^aWorkingCopy description! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 2/12/2009 00:40' prior: 23649940!workingCopyTreeMenu: aMenu 	workingCopy ifNil: [ ^ self workingCopyAllMenu: aMenu ] ifNotNilDo: [ :wc | wc myMenu: aMenu inBrowser: self  ].		^ aMenu! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:24' prior: 23650666!workingCopyTreeMorph	^ SimpleHierarchicalListMorph		on: self		list: #workingCopyTree		selected: #workingCopyWrapper		changeSelected: #workingCopyWrapper:		menu: #workingCopyListMenu:! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/23/2006 18:18'!workingCopyTreeRoots	^self workingCopies! !!MCToolWindowBuilder class methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:02' prior: 23570703!builder: aBuilder tool: aTool	^ self basicNew initializeWithBuilder: aBuilder tool: aTool! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:03' prior: 23566183!build	^ builder build: window! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:04' prior: 23566303!buttonRow	^ self buttonRow: tool buttonSpecs! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23566449!buttonRow: specArray	| panel button |	panel := builder pluggablePanelSpec new.	panel children: OrderedCollection new.	specArray do:		[:spec |				button := builder pluggableButtonSpec new.		button model: tool.		button label: spec first asString.		button action: spec second.		button help: spec third.		button enabled: (spec at: 4 ifAbsent: [#buttonEnabled]).		button state: (spec at: 5 ifAbsent: [#buttonSelected]).		panel children add: button].	panel layout: #horizontal.	panel frame: currentFrame.	window children add: panel! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23567092!frame: aLayoutFrame	currentFrame := aLayoutFrame! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 12:46' prior: 23567242!initializeWithBuilder: aBuilder tool: aTool	builder := aBuilder.	tool := aTool.! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:04' prior: 23567591!listMorph: listSymbol	^ self		listMorph: (listSymbol, 'List') asSymbol		selection: (listSymbol, 'Selection') asSymbol		menu: (listSymbol, 'ListMenu:') asSymbol! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:04' prior: 23567844!listMorph: listSymbol keystroke: keystrokeSymbol	^ (self		listMorph: (listSymbol, 'List') asSymbol		selection: (listSymbol, 'Selection') asSymbol		menu: (listSymbol, 'ListMenu:') asSymbol)		keystrokeActionSelector: keystrokeSymbol;		yourself! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:15' prior: 23568181!listMorph: listSymbol selection: selectionSymbol	self listMorph: listSymbol selection: selectionSymbol menu: nil! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:16' prior: 23568384!listMorph: listSymbol selection: selectionSymbol menu: menuSymbol	self listMorph: listSymbol selection: selectionSymbol menu: menuSymbol keystroke: nil! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2005 17:51' prior: 23568626!listMorph: listSymbol selection: selectionSymbol menu: menuSymbol keystroke: keystrokeSymbol	| list |	list := builder pluggableListSpec new.	list 		model: tool;		list: listSymbol; 		getIndex: selectionSymbol; 		setIndex: (selectionSymbol, ':') asSymbol;		frame: currentFrame.	menuSymbol ifNotNil: [list menu: menuSymbol].	keystrokeSymbol ifNotNil: [list keyPress: keystrokeSymbol].	window children add: list! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2005 17:52' prior: 23569135!multiListMorph: listSymbol selection: selectionSymbol listSelection: listSelectionSymbol menu: menuSymbol	| list |	list := builder pluggableMultiSelectionListSpec new.	list 		model: tool;		list: listSymbol; 		getIndex: selectionSymbol; 		setIndex: (selectionSymbol, ':') asSymbol;		getSelectionList: listSelectionSymbol;		setSelectionList: (listSelectionSymbol, 'put:') asSymbol;		frame: currentFrame.	menuSymbol ifNotNil: [list menu: menuSymbol].	window children add: list! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'kph 5/21/2007 13:01'!panel: getChildrenSelector 	| panel |	panel := builder pluggablePanelSpec new.	panel children: getChildrenSelector.	panel model: tool.	panel frame: currentFrame.	window children add: panel! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 12:58'!startWithPanel	window := builder pluggablePanelSpec new.	window children: OrderedCollection new.	window model: tool.! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 12:47'!startWithWindow 	window := builder pluggableWindowSpec new.	window children: OrderedCollection new.	window label: tool label asString.	window model: tool.	window extent: tool defaultExtent.! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2005 17:52' prior: 23569711!textMorph: aSymbol	| text |	text := builder pluggableTextSpec new.	text 		model: tool;		getText: aSymbol; 		setText: (aSymbol, ':') asSymbol;		frame: currentFrame.	window children add: text! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2006 18:24' prior: 23569998!treeMorph: listSymbol	^ self		treeMorph: listSymbol		selection: listSymbol		menu: (listSymbol, 'TreeMenu:') asSymbol! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2006 17:46' prior: 23570258!treeMorph: listSymbol selection: selectionSymbol menu: menuSymbol	^self treeMorph: listSymbol selection: selectionSymbol menu: menuSymbol keystroke: nil! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2006 18:25'!treeMorph: treeSymbol selection: selectionSymbol menu: menuSymbol keystroke: keystrokeSymbol	| tree |	tree := builder pluggableTreeSpec new.	tree 		model: tool;		roots: (treeSymbol, 'TreeRoots') asSymbol;		setSelected: (selectionSymbol, ':') asSymbol;		getChildren: (treeSymbol,'TreeChildrenOf:') asSymbol;		label: (treeSymbol,'TreeLabelOf:') asSymbol;		frame: currentFrame.	menuSymbol ifNotNil: [tree menu: menuSymbol].	keystrokeSymbol ifNotNil: [tree keyPress: keystrokeSymbol].	window children add: tree! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2006 17:46' prior: 23570436!treeOrListMorph: listSymbol	^self treeMorph: listSymbol! !!MCClassInstanceVariableDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 22:59' prior: 23237556!type	^ #classInstance! !!MCClassInstanceVariableDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 23:31' prior: 23237288!isClassInstanceVariable	^ true! !!MCClassVariableDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 22:58' prior: 23241856!type	^ #class! !!MCClassVariableDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 23:32' prior: 23241612!isClassVariable	^ true! !!MCClassVariableDefinition methodsFor: 'as yet unclassified' stamp: 'bf 8/29/2006 11:41'!isOrderDependend	^false! !!MCInstanceVariableDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 22:59' prior: 23345937!type	^ #instance! !!MCInstanceVariableDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 23:32' prior: 23345684!isInstanceVariable	^ true! !!MCPoolImportDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 22:59' prior: 23446022!type	^ #pool! !!MCPoolImportDefinition methodsFor: 'testing' stamp: 'bf 8/29/2006 11:41'!isOrderDependend	^false! !!MCPoolImportDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:51' prior: 23445787!isPoolImport	^ true! !!MCVariableDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 23:18' prior: 23577072!name: aString	^ self new name: aString	! !!MCVariableDefinition methodsFor: 'comparing' stamp: 'cwp 7/7/2003 23:02' prior: 23576136!= other	^ (self species = other species)		and: [self name = other name]! !!MCVariableDefinition methodsFor: 'comparing' stamp: 'cwp 7/7/2003 23:02' prior: 23576039!hash	^ name hash! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:31' prior: 23576288!isClassInstanceVariable	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:08' prior: 23576398!isClassInstanceVariableDefinition	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:30' prior: 23576518!isClassVariable	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:31' prior: 23576620!isInstanceVariable	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:10' prior: 23576725!isInstanceVariableDefinition	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'bf 8/29/2006 11:41'!isOrderDependend	^true! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:51' prior: 23576840!isPoolImport	^ false! !!MCVariableDefinition methodsFor: 'accessing' stamp: 'cwp 11/25/2002 05:57' prior: 23575635!name	^ name! !!MCVariableDefinition methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23575739!name: aString	name := aString! !!MCVariableDefinition methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 14:56' prior: 23575860!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self name; nextPut: $)! !!MCDiffyVersion class methodsFor: 'name utilities' stamp: 'bf 5/30/2005 18:45' prior: 23302983!baseNameFrom: diffName	| baseId verName |	baseId := (diffName copyAfter: $() copyUpTo: $).	baseId ifEmpty: [^baseId].	(baseId beginsWith: '@')		ifTrue: [^baseId copyAfter: $@].	verName := self verNameFrom: diffName.	^(baseId includes: $.)		ifTrue: [(verName copyUpToLast: $-), '-', baseId]		ifFalse: [(verName copyUpToLast: $.), '.', baseId]! !!MCDiffyVersion class methodsFor: 'name utilities' stamp: 'bf 5/30/2005 18:58' prior: 23303419!canonicalNameFor: aFileName	^(self nameForVer: (self verNameFrom: aFileName)		base: (self baseNameFrom: aFileName))			, '.', MCMcdReader extension! !!MCDiffyVersion class methodsFor: 'name utilities' stamp: 'bf 5/30/2005 17:39' prior: 23303654!nameForVer: versionName base: baseName	| baseId |	baseId := (versionName copyUpToLast: $.) = (baseName copyUpToLast: $.)		ifTrue: [baseName copyAfterLast: $.]		ifFalse: [(versionName copyUpToLast: $-) = (baseName copyUpToLast: $-)			ifTrue: [baseName copyAfterLast: $-]			ifFalse: ['@', baseName]].	^ versionName, '(', baseId, ')'! !!MCDiffyVersion class methodsFor: 'instance creation' stamp: 'avi 2/13/2004 23:07' prior: 23302304!package: aPackage info: aVersionInfo dependencies: aCollection baseInfo: baseVersionInfo patch:aPatch	^ self basicNew initializeWithPackage: aPackage info: aVersionInfo dependencies: aCollection baseInfo: baseVersionInfo patch:aPatch! !!MCDiffyVersion class methodsFor: 'instance creation' stamp: 'avi 2/13/2004 23:06' prior: 23302629!package: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection baseVersion: aVersion	^ self 		package: aPackage		info: aVersionInfo		dependencies: aCollection		baseInfo: aVersion info		patch: (aSnapshot patchRelativeToBase: aVersion snapshot)! !!MCDiffyVersion class methodsFor: 'name utilities' stamp: 'bf 5/30/2005 18:19' prior: 23304076!verNameFrom: diffName	^diffName copyUpTo: $(! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:17' prior: 23300411!baseInfo	^ base! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:39' prior: 23300512!baseSnapshot	^ (self workingCopy repositoryGroup versionWithInfo: base) snapshot! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'bf 5/23/2005 15:42' prior: 23300677!canOptimizeLoading	"Answer wether I can provide a patch for the working copy without the usual diff pass"	^ package hasWorkingCopy		and: [package workingCopy modified not			and: [package workingCopy ancestors includes: self baseInfo]]! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'bf 5/30/2005 17:39' prior: 23300999!fileName	^ (self class nameForVer: info name base: base name), '.', self writerClass extension! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23301190!initializeWithPackage: aPackage info: aVersionInfo dependencies: aCollection baseInfo: baseVersionInfo patch: aPatch	patch := aPatch.	base := baseVersionInfo.	super initializeWithPackage: aPackage info: aVersionInfo snapshot: nil dependencies: aCollection.! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:24' prior: 23301535!isDiffy	^ true! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:17' prior: 23301635!patch	^ patch! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23301745!snapshot	^ snapshot ifNil: [snapshot := MCPatcher apply: patch to: self baseSnapshot]! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/19/2004 22:03' prior: 23301916!summary	^ '(Diff against ', self baseInfo name, ')', String cr, super summary! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:17' prior: 23302079!writerClass	^ MCMcdWriter ! !!MCVersion class methodsFor: 'instance creation' stamp: 'ab 7/7/2003 16:13' prior: 23582610!package: aPackage	^ self package: aPackage info: MCVersionInfo new! !!MCVersion class methodsFor: 'instance creation' stamp: 'kph 12/6/2008 03:27' prior: 23582759!package: aPackage info: aVersionInfo	^ self package: aPackage info: aVersionInfo snapshot: (aPackage snapshotFor: aVersionInfo)! !!MCVersion class methodsFor: 'instance creation' stamp: 'cwp 11/7/2004 13:02' prior: 23582952!package: aPackage info: aVersionInfo snapshot: aSnapshot	^ self package: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: #()! !!MCVersion class methodsFor: 'instance creation' stamp: 'avi 1/19/2004 13:11' prior: 23583175!package: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection	^ self new initializeWithPackage: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection! !!MCVersion methodsFor: 'actions' stamp: 'kph 5/16/2007 11:44' prior: 23578565!addToCache	| repository |	MCCacheRepository default storeVersion: self.	 ! !!MCVersion methodsFor: 'actions' stamp: 'avi 2/12/2004 19:37' prior: 23578689!adopt	self workingCopy adopt: self! !!MCVersion methodsFor: 'enumerating' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23579755!allAvailableDependenciesDo: aBlock	| version |	self dependencies do:		[:ea |		[version := ea resolve.		version allAvailableDependenciesDo: aBlock.		aBlock value: version]			on: Error do: []]! !!MCVersion methodsFor: 'enumerating' stamp: 'cwp 11/7/2004 11:58' prior: 23580024!allDependenciesDo: aBlock	self allDependenciesDo: aBlock ifUnresolved: [:ignored | true]! !!MCVersion methodsFor: 'enumerating' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23580196!allDependenciesDo: aBlock ifUnresolved: failBlock	| dict |	dict := Dictionary new.	self allDependenciesNotIn: dict do: aBlock ifUnresolved: failBlock! !!MCVersion methodsFor: 'enumerating' stamp: 'cwp 11/7/2004 14:24' prior: 23580420!allDependenciesNotIn: aDictionary do: aBlock ifUnresolved: failBlock	| version |	self dependencies do: 		[:ea | 		version := aDictionary at: ea ifAbsent: [ea resolve].		version 			ifNil: [failBlock value: ea]			ifNotNil: [(aDictionary includes: version) ifFalse:						[aDictionary at: ea put: version.						version 							allDependenciesNotIn: aDictionary 							do: aBlock							ifUnresolved: failBlock.						aBlock value: version]]]! !!MCVersion methodsFor: 'converting' stamp: 'avi 2/19/2004 21:00' prior: 23579425!asDiffAgainst: aVersion	aVersion info = self info ifTrue: [self error: 'Cannot diff against self!!'].	^ MCDiffyVersion		package: self package		info: self info		snapshot: self snapshot		dependencies: self dependencies		baseVersion: aVersion! !!MCVersion methodsFor: 'actions' stamp: 'bf 3/22/2005 22:12' prior: 23578791!browse	(MCSnapshotBrowser forSnapshot: self snapshot)		showLabelled: 'Snapshot of ', self fileName! !!MCVersion methodsFor: '' stamp: 'kph 8/1/2007 12:25'!browseFrom: repository	 	self browse! !!MCVersion methodsFor: 'testing' stamp: 'bf 5/23/2005 15:43' prior: 23582141!canOptimizeLoading	"Answer wether I can provide a patch for the working copy without the usual diff pass"	^false! !!MCVersion methodsFor: 'accessing' stamp: 'mtf 10/7/2008 13:29' prior: 23577354!changes	^ self snapshot patchRelativeToBase: package patchSnapshot! !!MCVersion methodsFor: 'accessing' stamp: 'avi 1/22/2004 00:24' prior: 23577486!dependencies	^ dependencies ifNil: [#()]! !!MCVersion methodsFor: 'printing' stamp: 'kph 5/6/2007 03:05'!description	^ self info name 	 ! !!MCVersion methodsFor: 'accessing' stamp: 'avi 1/22/2004 12:44' prior: 23577597!fileName	^ info name, '.', self writerClass extension! !!MCVersion methodsFor: 'actions' stamp: 'avi 1/22/2004 12:44' prior: 23578959!fileOutOn: aStream	self writerClass fileOut: self on: aStream! !!MCVersion methodsFor: 'accessing' stamp: 'ab 7/7/2003 14:28' prior: 23577719!info	^ info! !!MCVersion methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23581397!initializeWithPackage: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection	package := aPackage.	info := aVersionInfo.	snapshot := aSnapshot.	dependencies := aCollection.	self addToCache.! !!MCVersion methodsFor: 'actions' stamp: 'kph 5/9/2007 18:41'!install	^ self load! !!MCVersion methodsFor: 'testing' stamp: 'bf 3/22/2005 23:00' prior: 23582322!isCacheable	^true! !!MCVersion methodsFor: 'testing' stamp: 'avi 2/13/2004 23:24' prior: 23582408!isDiffy	^ false! !!MCVersion methodsFor: 'actions' stamp: 'avi 1/24/2004 20:13' prior: 23579089!load	MCVersionLoader loadVersion: self! !!MCVersion methodsFor: '' stamp: 'kph 12/13/2008 17:38'!loadFrom: repository	self isCacheable			ifTrue: [ self workingCopy repositoryGroup addRepository: repository ].	 	self load.! !!MCVersion methodsFor: 'actions' stamp: 'abc 2/13/2004 15:58' prior: 23579196!merge	MCVersionMerger mergeVersion: self! !!MCVersion methodsFor: '' stamp: 'kph 12/13/2008 17:39'!mergeFrom: repository	self isCacheable			ifTrue: [ 					self workingCopy repositoryGroup addRepository: repository.				  	 .].	 	self merge.! !!MCVersion methodsFor: 'actions' stamp: 'kph 5/13/2007 16:48' prior: 23579304!open	^ (MCVersionInspector new version: self) show! !!MCVersion methodsFor: 'accessing' stamp: 'ab 7/7/2003 14:19' prior: 23577799!package	^ package! !!MCVersion methodsFor: 'printing' stamp: 'kph 5/6/2007 03:06' prior: 23581951!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self description.	aStream nextPut: $).! !!MCVersion methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23581700!setPackage: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection	package := aPackage.	info := aVersionInfo.	snapshot := aSnapshot.	dependencies := aCollection! !!MCVersion methodsFor: 'accessing' stamp: 'ab 7/7/2003 14:10' prior: 23577885!snapshot	^ snapshot! !!MCVersion methodsFor: 'accessing' stamp: 'avi 1/20/2004 16:07' prior: 23577975!summary	^ String streamContents:		[:s |		s nextPutAll: info summaryHeader.		(dependencies isNil or: [dependencies isEmpty]) ifFalse:			[s cr; nextPutAll: 'Dependencies: '.			dependencies				do: [:ea | s nextPutAll: ea versionInfo name]				separatedBy: [s nextPutAll: ', ']].		s cr; cr; nextPutAll: info message]! !!MCVersion methodsFor: 'enumerating' stamp: 'cwp 11/7/2004 14:24' prior: 23580939!withAllDependenciesDo: aBlock	self allDependenciesDo: aBlock ifUnresolved: [:ignored].	aBlock value: self! !!MCVersion methodsFor: 'enumerating' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23581129!withAllDependenciesDo: aBlock ifUnresolved: failBlock	| dict |	dict := Dictionary new.	self allDependenciesNotIn: dict do: aBlock ifUnresolved: failBlock.	aBlock value: self! !!MCVersion methodsFor: 'accessing' stamp: 'avi 2/12/2004 19:38' prior: 23578365!workingCopy	^ package workingCopy! !!MCVersion methodsFor: 'accessing' stamp: 'avi 1/22/2004 12:44' prior: 23578469!writerClass	^ MCMczWriter ! !!MCVersionDependency class methodsFor: 'as yet unclassified' stamp: 'avi 1/19/2004 13:13' prior: 23585954!package: aPackage info: aVersionInfo	^ self basicNew initializeWithPackage: aPackage info: aVersionInfo! !!MCVersionDependency methodsFor: 'comparing' stamp: 'avi 1/19/2004 16:12' prior: 23584060!= other	^ other species = self species		and: [other versionInfo = versionInfo				and: [other package = package]]! !!MCVersionDependency methodsFor: 'comparing' stamp: 'avi 1/19/2004 16:06' prior: 23583956!hash	^ versionInfo hash! !!MCVersionDependency methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23584276!initializeWithPackage: aPackage info: aVersionInfo	package := aPackage.	versionInfo := aVersionInfo! !!MCVersionDependency methodsFor: 'testing' stamp: 'bf 4/19/2005 16:29' prior: 23584676!isCurrent	^ package hasWorkingCopy		and: [self isFulfilled			and: [package workingCopy modified not]]! !!MCVersionDependency methodsFor: 'testing' stamp: 'bf 4/19/2005 16:29' prior: 23584857!isFulfilled	^package hasWorkingCopy		and: [self isFulfilledBy: package workingCopy ancestry]! !!MCVersionDependency methodsFor: 'testing' stamp: 'avi 3/4/2004 00:34' prior: 23585374!isFulfilledBy: anAncestry	^ anAncestry ancestors includes: versionInfo! !!MCVersionDependency methodsFor: 'testing' stamp: 'bf 4/19/2005 16:29' prior: 23585028!isFulfilledByAncestors	^ package hasWorkingCopy		and: [self isFulfilledByAncestorsOf: package workingCopy ancestry]! !!MCVersionDependency methodsFor: 'testing' stamp: 'nk 7/13/2004 08:45' prior: 23585222!isFulfilledByAncestorsOf: anAncestry	^ anAncestry hasAncestor: versionInfo! !!MCVersionDependency methodsFor: 'testing' stamp: 'bf 4/19/2005 16:29' prior: 23585522!isOlder	"Answer true if I represent an older version of a package that is loaded."	^ package hasWorkingCopy		and: [self isFulfilled not			and: [ self isFulfilledByAncestors				and: [package workingCopy modified not]]]! !!MCVersionDependency methodsFor: 'accessing' stamp: 'avi 1/19/2004 15:40' prior: 23583612!package	^ package! !!MCVersionDependency methodsFor: 'accessing' stamp: 'avi 2/12/2004 19:38' prior: 23583710!repositoryGroup	^ self package workingCopy repositoryGroup! !!MCVersionDependency methodsFor: 'resolving' stamp: 'nk 6/13/2004 19:21' prior: 23584457!resolve	^ self repositoryGroup		versionWithInfo: versionInfo		ifNone: [ MCRepositoryGroup default versionWithInfo: versionInfo ifNone: []]! !!MCVersionDependency methodsFor: 'accessing' stamp: 'avi 1/19/2004 15:40' prior: 23583849!versionInfo	^ versionInfo! !!MCVersionLoader class methodsFor: 'as yet unclassified' stamp: 'avi 1/24/2004 20:06' prior: 23602490!loadVersion: aVersion	self new		addVersion: aVersion;		load! !!MCVersionLoader methodsFor: 'loading' stamp: 'cwp 11/7/2004 17:06' prior: 23601402!addDependency: aDependency	| dep |	aDependency isCurrent ifTrue: [^ self].	(self depAgeIsOk: aDependency) ifFalse: [^ self].	dep := aDependency resolve.	dep		ifNil: [self confirmMissingDependency: aDependency]		ifNotNil: [(versions includes: dep) ifFalse: [self addVersion: dep]]! !!MCVersionLoader methodsFor: 'loading' stamp: 'cwp 11/7/2004 17:04' prior: 23601762!addVersion: aVersion	aVersion dependencies do: [ :ea | self addDependency: ea].	versions add: aVersion.! !!MCVersionLoader methodsFor: 'loading' stamp: 'kph 12/3/2008 17:27'!browse	^ versions do: #browse! !!MCVersionLoader methodsFor: 'checking' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23599863!checkForModifications	| modifications |	modifications := versions select: [:ea | ea package workingCopy modified].	modifications isEmpty ifFalse: [self warnAboutLosingChangesTo: modifications].! !!MCVersionLoader methodsFor: 'checking' stamp: 'cwp 11/7/2004 17:00' prior: 23600134!checkIfDepIsOlder: aDependency	^ aDependency isOlder not 		or: [self confirm: 'load older dependency ', aDependency versionInfo name , '?']! !!MCVersionLoader methodsFor: 'checking' stamp: 'cwp 11/7/2004 17:06' prior: 23600350!confirmMissingDependency: aDependency	| name |	name := aDependency versionInfo name.	(self confirm: 'Can''t find dependency ', name, '. ignore?')		ifFalse: [self error: 'Can''t find dependency ', name]! !!MCVersionLoader methodsFor: 'checking' stamp: 'cwp 11/7/2004 17:02' prior: 23600630!depAgeIsOk: aDependency	^ aDependency isOlder not 		or: [self confirm: 'load older dependency ', aDependency versionInfo name , '?']! !!MCVersionLoader methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23601282!initialize	versions := OrderedCollection new! !!MCVersionLoader methodsFor: 'loading' stamp: 'bf 3/16/2006 19:03' prior: 23601953!load	self loadWithNameLike: versions first info name.! !!MCVersionLoader methodsFor: 'loading' stamp: 'kph 12/7/2008 02:30'!loadWithNameLike: aString	| loader |	self checkForModifications.	loader := MCPackageLoader newCurrent.	versions size > 1 ifTrue: [ loader beMultiplePackage ].	 	versions do: [:ea |		ea canOptimizeLoading			ifTrue: [ea patch applyTo: loader]			ifFalse: [loader updatePackage: ea package withSnapshot: ea snapshot			]	].	loader 	installOrphanage;			loadWithNameLike: aString.	versions do: [:ea | ea workingCopy loaded: ea]! !!MCVersionLoader methodsFor: 'loading' stamp: 'kph 12/2/2008 20:13'!open	^ versions do: #open! !!MCVersionLoader methodsFor: 'checking' stamp: 'avi 1/24/2004 20:17' prior: 23600839!warnAboutLosingChangesTo: versionCollection	self notify: (String streamContents: [:s |		s nextPutAll: 'You are about to load new versions of the following packages that have unsaved changes in the image.  If you continue, you will lose these changes.'; cr.		versionCollection do:			[:ea |			s cr; space; space; nextPutAll: ea package name]])! !!MCVersionMerger class methodsFor: 'as yet unclassified' stamp: 'bf 12/5/2004 12:35' prior: 23604480!mergeVersion: aVersion	self new		addVersion: aVersion;		mergeWithNameLike: aVersion info name! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23602929!addVersion: aVersion	| dep |	records add: (MCMergeRecord version: aVersion).	aVersion dependencies do:		[:ea |		dep := ea resolve.		(records anySatisfy: [:r | r version = dep]) ifFalse: [self addVersion: dep]]! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23603241!initialize	records := OrderedCollection new.	merger := MCThreeWayMerger new.! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 17:15' prior: 23603405!merge	records do: [:ea | merger addBaseSnapshot: ea packageSnapshot].	records do: [:ea | merger applyPatch: ea mergePatch].	self resolveConflicts ifTrue:		[merger load.		records do: [:ea | ea updateWorkingCopy]].! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'bf 12/5/2004 12:32' prior: 23603707!mergeWithNameLike: baseName	records do: [:ea | merger addBaseSnapshot: ea packageSnapshot].	records do: [:ea | merger applyPatch: ea mergePatch].	self resolveConflicts ifTrue:		[merger loadWithNameLike: baseName.		records do: [:ea | ea updateWorkingCopy]].! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'bf 4/26/2005 14:29' prior: 23604053!resolveConflicts	(records allSatisfy: [:ea | ea isAncestorMerge]) ifTrue: [MCNoChangesException signal. ^ false].	^ ((MCMergeResolutionRequest new merger: merger)		signal: 'Merging ', records first version info name) = true! !!MCVersionNotification class methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 14:27' prior: 23607678!version: aVersion repository: aRepository	^ self basicNew initializeWithVersion: aVersion repository: aRepository! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 15:13' prior: 23605741!fromAddress	^ 'monticello@beta4.com'! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23605881!initializeWithVersion: aVersion repository: aRepository	version := aVersion.	repository := aRepository.	ancestor := repository closestAncestorVersionFor: version info ifNone: []. 	changes := ancestor				ifNil: [#()]				ifNotNil: [(version snapshot patchRelativeToBase: ancestor snapshot) 							operations asSortedCollection]! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 15:12' prior: 23606304!messageText	^ String streamContents:		[:s |		s nextPutAll: 'Committed to repository: ', repository description; cr; cr.		s nextPutAll: version summary.		changes isEmpty ifFalse:			[s cr; cr.			s nextPutAll: '-----------------------------------------------------'; cr.			s nextPutAll: 'Changes since ', ancestor info name, ':'; cr.			changes do:			[:ea |			s cr; nextPutAll: ea summary; cr.			s nextPutAll: ea sourceString]]]! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23606843!messageTo: aString	| message |	message := MailMessage empty.	message setField: 'from' toString: self fromAddress.	message setField: 'to' toString: aString.	message setField: 'subject' toString: '[MC] ', version info name.	message body: (MIMEDocument contentType: 'text/plain' content: self messageText).	^ message! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23607266!notify: aString	| message |	message := self messageTo: aString.	SMTPClient		deliverMailFrom: message from		to: (Array with: message to)		text: message text		usingServer: MailSender smtpServer! !!MCVersionSorter commentStamp: 'kph 5/16/2007 19:47' prior: 0!For sorting versions.MCFileRepositories use their own scheme for sorting versions.!!MCFilteredVersionSorter methodsFor: 'as yet unclassified' stamp: 'bf 5/28/2005 01:14' prior: 23328821!addVersionInfo: aVersionInfo	(aVersionInfo hasAncestor: target)		ifTrue: [super addVersionInfo: aVersionInfo]! !!MCFilteredVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23329038!processVersionInfo: aVersionInfo	| success |	aVersionInfo = target ifTrue: [^ true].	self pushLayer.	success := (self knownAncestorsOf: aVersionInfo) anySatisfy:				[:ea | self processVersionInfo: ea].	self popLayer.	success ifTrue: [self addToCurrentLayer: aVersionInfo].	^ success	! !!MCFilteredVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23329434!target: aVersionInfo	target := aVersionInfo! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 14:19' prior: 23614421!addAllAncestorsOf: aVersionInfo to: aSet	(aSet includes: aVersionInfo) ifTrue: [^ self].	aSet add: aVersionInfo.	(self knownAncestorsOf: aVersionInfo) do:		[:ea |		self addAllAncestorsOf: ea to: aSet]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 8/31/2003 21:30' prior: 23614712!addAllVersionInfos: aCollection	aCollection do: [:ea | self addVersionInfo: ea]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 20:06'!addAllVersions: aCollection	aCollection do: [:ea | self addVersionInfo: ea info]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23614889!addToCurrentLayer: aVersionInfo	| layer |	layer := layers at: depthIndex.	(layer includes: aVersionInfo) ifFalse:		[depths at: aVersionInfo ifPresent:			[:i |			i < depthIndex				ifTrue: [(layers at: i) remove: aVersionInfo]				ifFalse: [^ false]].		layer add: aVersionInfo.		depths at: aVersionInfo put: depthIndex.		^ true].	^ false ! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:49' prior: 23615322!addVersionInfo: aVersionInfo	roots add: aVersionInfo.	self registerStepChildrenOf: aVersionInfo seen: Set new! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23615530!allAncestorsOf: aVersionInfo	| all |	all := Set new.	self addAllAncestorsOf: aVersionInfo to: all.	^ all! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23615735!initialize	stepparents := Dictionary new.	roots := OrderedCollection new.! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 14:37' prior: 23615896!knownAncestorsOf: aVersionInfo	^ aVersionInfo ancestors, (self stepParentsOf: aVersionInfo) asArray! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'ab 8/17/2003 15:53' prior: 23616081!layers	^ layers! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23616194!popLayer	depthIndex := depthIndex - 1! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:39' prior: 23616318!processVersionInfo: aVersionInfo	(self addToCurrentLayer: aVersionInfo) ifTrue:		[self pushLayer.		(self knownAncestorsOf: aVersionInfo) do: [:ea | self processVersionInfo: ea].		self popLayer]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23616613!pushLayer	depthIndex := depthIndex + 1.	depthIndex > layers size ifTrue: [layers add: OrderedCollection new].	! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 14:34' prior: 23616812!registerStepChildrenOf: aVersionInfo seen: aSet	(aSet includes: aVersionInfo) ifTrue: [^ self].	aSet add: aVersionInfo.	aVersionInfo stepChildren do: [:ea | (self stepParentsOf: ea) add: aVersionInfo].	aVersionInfo ancestors do: [:ea | self registerStepChildrenOf: ea seen: aSet].! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23617193!sortedVersionInfos	layers := OrderedCollection with: OrderedCollection new.	depthIndex := 1.	depths := Dictionary new.	roots do: [:ea | self processVersionInfo: ea].	^ layers gather: [:ea | ea]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:40' prior: 23617477!stepParentsOf: aVersionInfo	^ (stepparents at: aVersionInfo ifAbsentPut: [Set new])! !!MCMcmWriter class methodsFor: 'writing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23351669!fileOut: aConfiguration on: aStream	| inst |	inst := self on: aStream.	inst writeConfiguration: aConfiguration.	inst close.	! !!MCMcmWriter class methodsFor: 'accessing' stamp: 'bf 3/22/2005 10:49' prior: 23351555!readerClass	^ MCMcmReader! !!MCMcmWriter methodsFor: 'writing' stamp: 'bf 3/22/2005 18:00' prior: 23350864!close	stream close! !!MCMcmWriter methodsFor: 'writing' stamp: 'bf 3/24/2005 01:50' prior: 23350952!writeConfiguration: aConfiguration	stream nextPut: $(.	aConfiguration repositories do: [:ea | 		stream cr.		stream nextPutAll: 'repository '.		(MCConfiguration repositoryToArray: ea) printElementsOn: stream].	aConfiguration dependencies do: [:ea | 		stream cr.		stream nextPutAll: 'dependency '.		(MCConfiguration dependencyToArray: ea) printElementsOn: stream].	stream cr.	stream nextPut: $).	stream cr.! !!MCMcdWriter class methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:09' prior: 23349557!readerClass	^ MCMcdReader! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23348068!writeBaseInfo: aVersionInfo	| string |	string := self serializeVersionInfo: aVersionInfo.	self addString: string at: 'base'.! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 01:48' prior: 23348278!writeDefinitions: aVersion	self writeBaseInfo: aVersion baseInfo.	self writePatch: aVersion patch.! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 02:07' prior: 23348460!writeNewDefinitions: aCollection	self addString: (self serializeDefinitions: aCollection) at: 'new/source.', self snapshotWriterClass extension.! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 02:07' prior: 23348687!writeOldDefinitions: aCollection	self addString: (self serializeDefinitions: aCollection) at: 'old/source.', self snapshotWriterClass extension.! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23348925!writePatch: aPatch	| old new |	old := OrderedCollection new.	new := OrderedCollection new.	aPatch operations do:		[:ea |		ea isRemoval ifTrue: [old add: ea definition].		ea isAddition ifTrue: [new add: ea definition].		ea isModification ifTrue: [old add: ea baseDefinition. new add: ea definition]].	self writeOldDefinitions: old.	self writeNewDefinitions: new.	self addString: (self serializeInBinary: aPatch) at: 'patch.bin'.! !!MCMczWriter class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23362068!fileOut: aVersion on: aStream	| inst |	inst := self on: aStream.	inst writeVersion: aVersion.	inst flush.	! !!MCMczWriter class methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 12:35' prior: 23362386!readerClass	^ MCMczReader! !!MCMczWriter methodsFor: 'writing' stamp: 'kph 12/6/2008 00:09'!addFile: aFile at: path	(zip addFile: aFile as: path) desiredCompressionMethod: ZipArchive compressionDeflated 	! !!MCMczWriter methodsFor: 'writing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23361603!addString: string at: path	| member |	member := zip addString: string as: path.	member desiredCompressionMethod: ZipArchive compressionDeflated 	! !!MCMczWriter methodsFor: 'writing' stamp: 'avi 2/17/2004 02:17' prior: 23361822!flush	zip writeTo: stream.	stream close! !!MCMczWriter methodsFor: 'accessing' stamp: 'avi 2/17/2004 01:54' prior: 23358761!format	^ '1'! !!MCMczWriter methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23359047!initialize	zip := ZipArchive new.! !!MCMczWriter methodsFor: 'serializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23359168!serializeDefinitions: aCollection	| writer s |	s := RWBinaryOrTextStream on: String new.	writer := self snapshotWriterClass on: s.	writer writeDefinitions: aCollection.	^ s contents! !!MCMczWriter methodsFor: 'serializing' stamp: 'kph 12/7/2008 03:27' prior: 23359439!serializeInBinary: anObject	| writer s |	s := RWBinaryOrTextStream on: String new.	writer := DataStream on: s.	writer nextPut: anObject.	^ s contents! !!MCMczWriter methodsFor: 'serializing' stamp: 'cwp 8/13/2003 01:06' prior: 23359669!serializePackage: aPackage	^ '(name ''', aPackage name, ''')'! !!MCMczWriter methodsFor: 'serializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23359816!serializeVersionInfo: aVersionInfo	infoWriter ifNil: [infoWriter := MCVersionInfoWriter new].	^ String streamContents:		[:s |		infoWriter stream: s.		infoWriter writeVersionInfo: aVersionInfo]! !!MCMczWriter methodsFor: 'accessing' stamp: 'avi 2/17/2004 02:07' prior: 23358846!snapshotWriterClass	^ MCStWriter! !!MCMczWriter methodsFor: 'visiting' stamp: 'kph 12/6/2008 04:48' prior: 23360085!writeDefinitions: aVersion	self writeSnapshot: aVersion snapshot.	! !!MCMczWriter methodsFor: 'files' stamp: 'kph 12/6/2008 05:37'!writeFile: definition	self addFile: definition pathToSnapshotFull at: definition pathToSnapshot	 ! !!MCMczWriter methodsFor: 'writing' stamp: 'kph 12/7/2008 03:33'!writeFiles: definitions	definitions ifNil: [ ^ self ].	definitions ifEmpty: [ ^self ]. 	definitions do: [ :ea | self writeFile: ea ].! !!MCMczWriter methodsFor: 'visiting' stamp: 'avi 2/17/2004 01:56' prior: 23360221!writeFormat"	self addString: self format at: 'format'."! !!MCMczWriter methodsFor: 'visiting' stamp: 'avi 2/17/2004 01:48' prior: 23360348!writePackage: aPackage	self addString: (self serializePackage: aPackage) at: 'package'! !!MCMczWriter methodsFor: 'visiting' stamp: 'avi 9/28/2004 14:26' prior: 23360506!writeSnapshot: aSnapshot	self addString: (self serializeDefinitions: aSnapshot definitions) at: 'snapshot/source.', self snapshotWriterClass extension.	self addString: (self serializeInBinary: aSnapshot) at: 'snapshot.bin'! !!MCMczWriter methodsFor: 'visiting' stamp: 'kph 12/7/2008 03:33' prior: 23361302!writeVersion: aVersion	self writeFormat.	self writePackage: aVersion package.	self writeVersionInfo: aVersion info.	self writeDefinitions: aVersion.	aVersion dependencies do: [:ea | self writeVersionDependency: ea].	self writeFiles: (aVersion snapshot definitions select: [ :ea | ea isFileDefinition ]).! !!MCMczWriter methodsFor: 'visiting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23360812!writeVersionDependency: aVersionDependency	| string |	string := (self serializeVersionInfo: aVersionDependency versionInfo).	self addString: string at: 'dependencies/', aVersionDependency package name! !!MCMczWriter methodsFor: 'visiting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23361097!writeVersionInfo: aVersionInfo	| string |	string := self serializeVersionInfo: aVersionInfo.	self addString: string at: 'version'.! !!MCMczWriter methodsFor: 'accessing' stamp: 'cwp 8/1/2003 00:06' prior: 23358950!zip	^ zip! !!MCStWriter class methodsFor: 'as yet unclassified' stamp: 'avi 1/20/2004 00:16' prior: 23532904!readerClass	^ MCStReader! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/2/2003 02:34' prior: 23530129!chunkContents: aBlock	stream cr; nextChunkPut: (String streamContents: aBlock); cr! !!MCStWriter methodsFor: 'visiting' stamp: 'cwp 8/2/2003 11:02' prior: 23528752!visitClassDefinition: definition	self writeClassDefinition: definition.	definition hasClassInstanceVariables ifTrue: [self writeMetaclassDefinition: definition].	definition hasComment ifTrue: [self writeClassComment: definition].! !!MCStWriter methodsFor: 'visiting' stamp: 'al 10/9/2005 19:52' prior: 23529053!visitClassTraitDefinition: definition	self chunkContents: [:s | s		nextPutAll: definition baseTrait;		nextPutAll: ' classTrait';		cr; tab;		nextPutAll: 'uses: ';		nextPutAll: (definition classTraitComposition ifNil: ['{}'])]! !!MCStWriter methodsFor: 'visiting' stamp: 'al 10/9/2005 19:40' prior: 23529353!visitMetaclassDefinition: definition	self writeMetaclassDefinition: definition! !!MCStWriter methodsFor: 'visiting' stamp: 'avi 2/17/2004 02:23' prior: 23529502!visitMethodDefinition: definition	self writeMethodPreamble: definition.	self writeMethodSource: definition.	self writeMethodPostscript.	self writeMethodInitializer: definition.! !!MCStWriter methodsFor: 'visiting' stamp: 'cwp 8/2/2003 11:02' prior: 23529751!visitOrganizationDefinition: defintion	defintion categories do: [:cat | self writeCategory: cat].! !!MCStWriter methodsFor: 'visiting' stamp: 'al 10/9/2005 19:40' prior: 23529919!visitTraitDefinition: definition	self writeClassDefinition: definition.	definition hasComment ifTrue: [self writeClassComment: definition].! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/2/2003 01:46' prior: 23530280!writeCategory: categoryName	stream		nextChunkPut: 'SystemOrganization addCategory: ', categoryName printString;		cr! !!MCStWriter methodsFor: 'writing' stamp: 'ab 8/17/2003 17:09' prior: 23530466!writeClassComment: definition	stream		cr;		nextPut: $!!;		nextPutAll: definition className;		nextPutAll: ' commentStamp: ';		store: definition commentStamp;		nextPutAll: ' prior: 0!!';		cr;		nextChunkPut: definition comment;		cr.! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/2/2003 02:16' prior: 23530773!writeClassDefinition: definition	self chunkContents: [:s | definition printDefinitionOn: stream]! !!MCStWriter methodsFor: 'writing' stamp: 'dvf 9/8/2004 10:28' prior: 23530938!writeDefinitions: aCollection	"initStream is an ugly hack until we have proper init defs"	initStream := String new writeStream.	(MCDependencySorter sortItems: aCollection)		do: [:ea | ea accept: self]		displayingProgress: 'Writing definitions...'.		stream nextPutAll: initStream contents.! !!MCStWriter methodsFor: 'writing' stamp: 'al 12/2/2005 15:17' prior: 23531302!writeMetaclassDefinition: definition	self chunkContents: [:str |		str	nextPutAll: definition className;			nextPutAll: ' class';			cr; tab.			definition hasClassTraitComposition ifTrue: [				str	nextPutAll: 'uses: ';					nextPutAll: definition classTraitCompositionString;					cr; tab].			str	nextPutAll: 'instanceVariableNames: ''';				nextPutAll: definition classInstanceVariablesString;				nextPut: $']! !!MCStWriter methodsFor: 'writing' stamp: 'avi 2/17/2004 02:24' prior: 23531786!writeMethodInitializer: aMethodDefinition	aMethodDefinition isInitializer ifTrue:		[initStream nextChunkPut: aMethodDefinition className, ' initialize'; cr]! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/2/2003 12:43' prior: 23532012!writeMethodPostscript	stream		space;		nextPut: $!!;		cr! !!MCStWriter methodsFor: 'writing' stamp: 'avi 9/23/2003 17:42' prior: 23532140!writeMethodPreamble: definition	stream		cr;		nextPut: $!!;		nextPutAll: definition fullClassName;		nextPutAll: ' methodsFor: ';		nextPutAll: definition category asString printString;		nextPutAll: ' stamp: ';		nextPutAll: definition timeStamp asString printString;		nextPutAll: '!!';		cr! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/4/2003 01:35' prior: 23532504!writeMethodSource: definition	stream nextChunkPut: definition source! !!MCStWriter methodsFor: 'writing' stamp: 'avi 2/17/2004 02:25' prior: 23532642!writeSnapshot: aSnapshot	self writeDefinitions: aSnapshot definitions! !!MCVersionInfoWriter methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 21:10' prior: 23593963!isWritten: aVersionInfo	^ self written includes: aVersionInfo! !!MCVersionInfoWriter methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 16:53' prior: 23594115!writeVersionInfo: aVersionInfo	(self isWritten: aVersionInfo)		ifTrue: [^ stream nextPutAll: '(id ', aVersionInfo id asString printString, ')'].	stream nextPut: $(.	#(name message id date time author) 		do: [:sel | 			stream nextPutAll: sel.			stream nextPut: $ .			((aVersionInfo perform: sel) ifNil: ['']) asString printOn: stream.			stream nextPut: $ ].	stream nextPutAll: 'ancestors ('.	aVersionInfo ancestors do: [:ea | self writeVersionInfo: ea].	stream nextPutAll: ') stepChildren ('.	aVersionInfo stepChildren do: [:ea | self writeVersionInfo: ea].	stream nextPutAll: '))'.	self wrote: aVersionInfo! !!MCVersionInfoWriter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23594837!written	^ written ifNil: [written := Set new]! !!MCVersionInfoWriter methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 21:10' prior: 23594973!wrote: aVersionInfo	self written add: aVersionInfo! !!MCWriter class methodsFor: 'accessing' stamp: 'cwp 8/1/2003 15:00' prior: 23664455!extension	^ self readerClass extension! !!MCWriter class methodsFor: 'writing' stamp: 'cwp 8/1/2003 01:16' prior: 23664685!on: aStream	^ self new stream: aStream! !!MCWriter class methodsFor: 'accessing' stamp: 'cwp 7/28/2003 23:46' prior: 23664569!readerClass	^ self subclassResponsibility ! !!MCWriter methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 01:14' prior: 23664138!stream	^ stream! !!MCWriter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23664244!stream: aStream	stream := aStream! !!Object methodsFor: '*monticello' stamp: 'dvf 8/10/2004 23:25' prior: 25830784!isConflict	^false! !!FilePackage methodsFor: '*monticello' stamp: 'al 12/2/2005 13:58' prior: 20718545!classDefinition: string with: chgRec	| tokens theClass |		self flag: #traits.			tokens := Scanner new scanTokens: string.	"tokens size = 11 ifFalse:[^doIts add: chgRec]."	theClass := self getClass: (tokens at: 3).	theClass definition: string.	classOrder add: theClass.! !!FilePackage methodsFor: '*monticello' stamp: 'avi 1/19/2004 23:47' prior: 20718898!doIts	^ doIts! !!MCDependentsWrapper methodsFor: 'as yet unclassified' stamp: 'ar 2/14/2004 02:31' prior: 23295555!asString	^item description! !!MCDependentsWrapper methodsFor: 'as yet unclassified' stamp: 'avi 9/10/2004 17:54' prior: 23295672!contents	| list workingCopies |	workingCopies := model unsortedWorkingCopies.	list := item requiredPackages collect: 					[:each | 					workingCopies detect: [:wc | wc package = each] ifNone: [nil]]				thenSelect: [:x | x notNil].	^list collect: [:each | self class with: each model: model]! !!MCDependentsWrapper methodsFor: 'as yet unclassified' stamp: 'ar 2/14/2004 02:31' prior: 23296058!hasContents	^item requiredPackages isEmpty not! !!MCDependentsWrapper methodsFor: 'as yet unclassified' stamp: 'ar 2/14/2004 02:41' prior: 23296194!item	^item! !!MCPseudoFileStream commentStamp: '<historical>' prior: 23447584!A pseudo file stream which can be used for updates.!!MCPseudoFileStream methodsFor: 'accessing' stamp: 'ar 4/14/2005 19:54' prior: 23447712!localName	^localName! !!MCPseudoFileStream methodsFor: 'accessing' stamp: 'ar 4/14/2005 19:54' prior: 23447811!localName: aString	localName := aString! !!ChangeList class methodsFor: '*monticello' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 18224817!recent: charCount on: origChangesFile 	"Opens a changeList on the end of the specified changes log file"	| changeList end changesFile |	changesFile := origChangesFile readOnlyCopy.	end := changesFile size.	Cursor read		showWhile: [changeList := self new						scanFile: changesFile						from: (0 max: end - charCount)						to: end].	changesFile close.	^changeList! !!ChangeList class methodsFor: '*monticello' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 18223710!recentLogOn: origChangesFile startingFrom: initialPos 	"Prompt with a menu of how far back to go when browsing a changes file."	| end banners positions pos chunk i changesFile |	changesFile := origChangesFile readOnlyCopy.	banners := OrderedCollection new.	positions := OrderedCollection new.	end := changesFile size.	pos := initialPos.	[pos = 0		or: [banners size > 20]]		whileFalse: [changesFile position: pos.			chunk := changesFile nextChunk.			i := chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.			i > 0				ifTrue: [positions addLast: pos.					banners						addLast: (chunk copyFrom: 5 to: i - 2).					pos := Number								readFrom: (chunk copyFrom: i + 13 to: chunk size)]				ifFalse: [pos := 0]].	changesFile close.	banners size == 0 ifTrue: [^self recent: end on: origChangesFile].	pos := (SelectionMenu labelList: banners selections: positions)				startUpWithCaption: 'Browse as far back as...'.	pos == nil		ifTrue: [^ self].	^self recent: end - pos on: origChangesFile! !!ChangeList methodsFor: '*monticello' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 18210804!changeTo: changeSubset	| newList newChangeList |	newChangeList := OrderedCollection new.	newList := OrderedCollection new.	1 to: changeList size do:		[:i | (changeSubset includes: (changeList at: i)) ifTrue:			[newChangeList add: (changeList at: i).			newList add: (list at: i)]].	newChangeList size < changeList size		ifTrue:			[changeList := newChangeList.			list := newList.			listIndex := 0.			listSelections := Array new: list size withAll: false].	self changed: #list	! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'avi 9/14/2004 15:01' prior: 23213275!defaultAction	^ (MCChangeSelector new patch: patch; label: label) showModally! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'avi 9/14/2004 15:02' prior: 23213448!label	^ label! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23213568!label: aString	label := aString! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 15:12' prior: 23213695!patch	^ patch! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23213815!patch: aPatch	patch := aPatch! !!MCMergeResolutionRequest methodsFor: 'as yet unclassified' stamp: 'bf 4/26/2005 14:25' prior: 23370448!defaultAction	^ (MCMergeBrowser new		merger: merger;		label: messageText) showModally! !!MCMergeResolutionRequest methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:19' prior: 23370630!merger	^ merger! !!MCMergeResolutionRequest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23370752!merger: aMerger	merger := aMerger! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:39' prior: 23604973!defaultAction	^ MCSaveVersionDialog new		versionName: suggestion;		showModally! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'ab 7/10/2003 01:07' prior: 23605154!suggestedName	^ suggestion! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23605293!suggestedName: aString	suggestion := aString! !!MCOrphanedNotification class methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 13:05'!orphan: aDefinition signal: reason		^(self new)		orphan: aDefinition;		signal: reason		yourself! !!MCOrphanedNotification methodsFor: 'accessing' stamp: 'kph 5/13/2007 04:53'!orphan	"Answer the value of orphan"	^ orphan! !!MCOrphanedNotification methodsFor: 'accessing' stamp: 'kph 5/13/2007 04:53'!orphan: anObject	"Set the value of orphan"	orphan := anObject! !!PackageInfo class methodsFor: '*monticello-orphanage' stamp: 'kph 5/14/2007 13:28'!orphanage	^ MCOrphanage current! !!PackageInfo methodsFor: '*monticello-orphanage' stamp: 'kph 5/14/2007 16:58'!allClassesAsDefinitions	^ self loadedClassesAsDefinitions , self orphanedClassesAsDefinitons! !!PackageInfo methodsFor: '*monticello-base' stamp: 'kph 8/3/2008 03:57'!manager	^ self propertyAt: #mc! !!PackageInfo methodsFor: '*monticello-base' stamp: 'kph 8/3/2008 03:58'!manager: mcPackageManager	^ self propertyAt: #mc put: mcPackageManager! !!PackageInfo methodsFor: '*monticello-orphanage' stamp: 'kph 5/14/2007 13:36'!orphanedClassesAsDefinitons	  "convenience method implemented here to enable users of packageInfo to be aware that there are additional classes in the orphanage which belong to this package."		^ (self class orphanage orphansFor: self) select: [ :m | m isClassDefinition ]  ! !!PackageInfo methodsFor: '*monticello-orphanage' stamp: 'kph 5/14/2007 13:31'!orphanedMethodsAsDefinitons	  "convenience method implemented here to enable users of packageInfo to be aware that there are additional methods in the orphanage which belong to this package."		^ (self class orphanage orphansFor: self) select: [ :m | m isMethodDefinition ]  ! !!ChangeRecord methodsFor: '*monticello' stamp: 'avi 9/14/2004 14:27' prior: 18234082!asMethodDefinition	^ MCMethodDefinition 		className: class		classIsMeta: meta		selector: self methodSelector		category: category		timeStamp: stamp		source: self string! !!Encoder methodsFor: '*monticello-override' stamp: 'mtf 6/9/2008 20:43' prior: 20176268!undeclared: name	| sym | 	requestor interactive ifTrue: [		requestor requestor == #error: ifTrue: [requestor error: 'Undeclared'].		^ self notify: 'Undeclared'].	"Transcript show: ' (' , name , ' is Undeclared) '."	sym := name asSymbol.	Undeclared at: sym put: nil.	^self global: (Undeclared associationAt: sym) name: sym! !!SequenceableCollection methodsFor: '*monticello' stamp: 'mtf 6/27/2008 23:03'!mcLessThan: otherCollection ifEqual: aBlock	| a b |	1 to: (self size min: otherCollection size) do: [:index |		a := self at: index. b := otherCollection at: index.		a ~= b ifTrue: [ ^ a <= b ]].	^ self size ~= otherCollection size		ifTrue: [self size <= otherCollection size]		ifFalse: [aBlock value]! !!MCNoChangesException methodsFor: 'as yet unclassified' stamp: 'jf 8/21/2003 19:49' prior: 23406746!defaultAction	self inform: 'No changes'! !!MCClassBuilder methodsFor: 'as yet unclassified' stamp: 'kph 6/7/2008 03:28'!doneCompiling: aClass	"The receiver has finished modifying the class hierarchy.	Do any necessary cleanup."	aClass doneCompiling.	! !!MCClassBuilder methodsFor: 'as yet unclassified' stamp: 'kph 6/7/2008 01:31'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class in the given environment.	If unsafe is true do not run any validation checks.	This facility is provided to implement important system changes."	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory | 	environ := env.	instVars := Scanner new scanFieldNames: instVarString.	classVars := (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass := env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse: [oldClass := nil]  "Already checked in #validateClassName:"		ifTrue: [			copyOfOldClass := oldClass copy.			copyOfOldClass superclass addSubclass: copyOfOldClass].			[unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"See if we need a new subclass"	needNew := self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.	needNew == nil ifTrue:[^nil]. "some error"	(needNew and:[unsafe not]) ifTrue:[		"Make sure we don't redefine any dangerous classes"		(self tooDangerousClasses includes: oldClass name) ifTrue:[			self error: oldClass name, ' cannot be changed'.		].		"Check if the receiver should not be redefined"		(oldClass ~~ nil and:[oldClass shouldNotBeRedefined]) ifTrue:[			self notify: oldClass name asText allBold, 						' should not be redefined. \Proceed to store over it.' withCRs]].	needNew ifTrue:[		"Create the new class"		newClass := self 			newSubclassOf: newSuper 			type: type 			instanceVariables: instVars			from: oldClass.		newClass == nil ifTrue:[^nil]. "Some error"		newClass setName: className.	] ifFalse:[		"Reuse the old class"		newClass := oldClass.	].	"Install the class variables and pool dictionaries... "	force := (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	newCategory := category asSymbol.	organization := environ ifNotNil:[environ organization].	oldClass isNil ifFalse: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].	organization classify: newClass name under: newCategory.	newClass environment: environ.	"... recompile ..."	newClass := self recompile: force from: oldClass to: newClass mutate: false.	"... export if not yet done ..."	(environ at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		[environ at: newClass name put: newClass]			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].		Smalltalk flushClassNameCache.	].	"... notify interested clients ..."	oldClass isNil ifTrue: [		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.		^ newClass].	newCategory ~= oldCategory 		ifTrue: [SystemChangeNotifier uniqueInstance class: newClass recategorizedFrom: oldCategory to: category]		ifFalse: [SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.].] ensure: 		[copyOfOldClass ifNotNil: [copyOfOldClass superclass removeSubclass: copyOfOldClass].		Behavior flushObsoleteSubclasses.		].	^newClass! !----End fileIn of a stream----!MCAncestry class removeSelector: #new!MCVersionMerger class removeSelector: #new!MCMethodDefinition removeSelector: #postload!MCMethodDefinition removeSelector: #load!MCWorkingCopyBrowser removeSelector: #inspectWorkingCopy!MCWorkingCopyBrowser class removeSelector: #new!MCRepository removeSelector: #initialize!MCRepository class removeSelector: #settingsFileName!MCRepository class removeSelector: #releaseExternalSettings!MCRepository class removeSelector: #new!MCReader removeSelector: #initialize!MCReader class removeSelector: #new!MCPreambleDefinition removeSelector: #load!MCSnapshotBrowser removeSelector: #methodsForSelectedClassCategory!MCClassDefinition removeSelector: #storeDataOn:!MCClassDefinition removeSelector: #load!MCClassDefinition removeSelector: #createClass!MCClassTraitDefinition removeSelector: #load!MCPackageLoader removeSelector: #warnAboutErrors!MCPackageLoader removeSelector: #warnAboutDependencies!MCPackageLoader removeSelector: #useNewChangeSetNamedLike:during:!MCPackageLoader removeSelector: #useNewChangeSetDuring:!MCPackageLoader removeSelector: #useChangeSetNamed:during:!MCPackageLoader removeSelector: #updatePackage:withSnapshot:!MCPackageLoader removeSelector: #unloadPackage:!MCPackageLoader removeSelector: #tryToLoad:!MCPackageLoader removeSelector: #sorterForItems:!MCPackageLoader removeSelector: #shouldWarnAboutErrors!MCPackageLoader removeSelector: #removeDefinition:!MCPackageLoader removeSelector: #provisions!MCPackageLoader removeSelector: #orderedAdditions!MCPackageLoader removeSelector: #orderDefinitionsForLoading:!MCPackageLoader removeSelector: #obsoletionFor:!MCPackageLoader removeSelector: #modifyDefinition:to:!MCPackageLoader removeSelector: #loadWithNameLike:!MCPackageLoader removeSelector: #loadWithName:!MCPackageLoader removeSelector: #load!MCPackageLoader removeSelector: #installSnapshot:!MCPackageLoader removeSelector: #initialize!MCPackageLoader removeSelector: #flushChangesFile!MCPackageLoader removeSelector: #errorDefinitionWarning!MCPackageLoader removeSelector: #dependencyWarning!MCPackageLoader removeSelector: #basicLoad!MCPackageLoader removeSelector: #analyze!MCPackageLoader removeSelector: #addDefinition:!MCPackageLoader class removeSelector: #updatePackage:withSnapshot:!MCPackageLoader class removeSelector: #unloadPackage:!MCPackageLoader class removeSelector: #installSnapshot:!MCMockPackageInfo removeSelector: #systemCategories!MCMockPackageInfo removeSelector: #packageName!MCMockPackageInfo removeSelector: #includesSystemCategory:!MCMockPackageInfo removeSelector: #includesClass:!MCMockPackageInfo removeSelector: #extensionMethods!MCMockPackageInfo removeSelector: #classes!MCMockPackageInfo removeSelector: #classNames!MCMockPackageInfo class removeSelector: #initialize!Smalltalk removeClassNamed: #MCMockPackageInfo!MCEmptyPackageInfo removeSelector: #packageName!MCEmptyPackageInfo removeSelector: #methods!MCEmptyPackageInfo removeSelector: #classes!MCEmptyPackageInfo class removeSelector: #wantsChangeSetLogging!MCEmptyPackageInfo class removeSelector: #initialize!Smalltalk removeClassNamed: #MCEmptyPackageInfo!MCDirtyPackageInfo removeSelector: #packageName!MCDirtyPackageInfo removeSelector: #methods!MCDirtyPackageInfo removeSelector: #classes!MCDirtyPackageInfo class removeSelector: #wantsChangeSetLogging!MCDirtyPackageInfo class removeSelector: #initialize!Smalltalk removeClassNamed: #MCDirtyPackageInfo!MethodAddition removeSelector: #writeSourceToLog!MethodAddition removeSelector: #notifyObservers!MethodAddition removeSelector: #installMethod!MethodAddition removeSelector: #createCompiledMethod!MethodAddition removeSelector: #compile:classified:withStamp:notifying:logSource:inClass:!MethodAddition removeSelector: #compile!Smalltalk removeClassNamed: #MethodAddition!MCMockDependency removeSelector: #uuidForName:!MCMockDependency removeSelector: #resolve!MCMockDependency removeSelector: #name!MCMockDependency removeSelector: #mockVersionInfo!MCMockDependency removeSelector: #initializeWithTree:!MCMockDependency removeSelector: #hash!MCMockDependency removeSelector: #hasResolution!MCMockDependency removeSelector: #children!MCMockDependency removeSelector: #=!MCMockDependency class removeSelector: #fromTree:!Smalltalk removeClassNamed: #MCMockDependency!Smalltalk removeClassNamed: #MCMockClassI!Smalltalk removeClassNamed: #MCMockClassH!Smalltalk removeClassNamed: #MCMockClassG!Smalltalk removeClassNamed: #MCMockClassF!MCMockClassE class removeSelector: #two!Smalltalk removeClassNamed: #MCMockClassE!MCMockClassD removeSelector: #one!Smalltalk removeClassNamed: #MCMockClassD!MCMockDependentItem removeSelector: #requires:!MCMockDependentItem removeSelector: #requirements!MCMockDependentItem removeSelector: #provisions!MCMockDependentItem removeSelector: #provides:!MCMockDependentItem removeSelector: #name:!MCMockDependentItem removeSelector: #name!MCMockDependentItem removeSelector: #<=!Smalltalk removeClassNamed: #MCMockDependentItem!MCMockClassB removeSelector: #two!Smalltalk removeClassNamed: #MCMockClassB!MCMockClassA removeSelector: #two!MCMockClassA removeSelector: #truth!MCMockClassA removeSelector: #q!MCMockClassA removeSelector: #one!MCMockClassA removeSelector: #moreTruth!MCMockClassA removeSelector: #falsehood!MCMockClassA removeSelector: #d!MCMockClassA removeSelector: #c!MCMockClassA removeSelector: #b!MCMockClassA removeSelector: #a!MCMockClassA class removeSelector: #touchCVar!MCMockClassA class removeSelector: #one!MCMockClassA class removeSelector: #cVar!MCMockASubclass removeSelector: #variables2!MCMockASubclass removeSelector: #variables!Smalltalk removeClassNamed: #MCMockASubclass!MCMockClassA class removeSelector: #initialize!Smalltalk removeClassNamed: #MCMockClassA!MCMock class removeSelector: #wantsChangeSetLogging!Smalltalk removeClassNamed: #MCMock!MCSMCacheRepository class removeSelector: #morphicConfigure!MethodReference removeSelector: #isLocalSelector!MCMockDefinition removeSelector: #token:!MCMockDefinition removeSelector: #token!MCMockDefinition removeSelector: #summary!MCMockDefinition removeSelector: #printString!MCMockDefinition removeSelector: #hash!MCMockDefinition removeSelector: #description!MCMockDefinition removeSelector: #asString!MCMockDefinition removeSelector: #=!MCMockDefinition class removeSelector: #wantsChangeSetLogging!MCMockDefinition class removeSelector: #token:!Smalltalk removeClassNamed: #MCMockDefinition!MCDefinition removeSelector: #postload!MCDefinition removeSelector: #loadOver:!MCDefinition removeSelector: #addMethodAdditionTo:!Smalltalk removeClassNamed: #MCMockAPoolDictionary!MCPostscriptDefinition removeSelector: #postload!MCPostscriptDefinition removeSelector: #accept:!MCVersionReader removeSelector: #initialize!MCVersionReader class removeSelector: #openVersionFromStream:!MCVersionReader class removeSelector: #mergeVersionStream:!MCVersionReader class removeSelector: #loadVersionStream:fromDirectory:!MCVersionReader class removeSelector: #canReadFileNamed:!MCWorkingCopy removeSelector: #versionSeparator!MCWorkingCopy removeSelector: #updateInstVars!MCWorkingCopy removeSelector: #nextVersionName!MCVersionSorter class removeSelector: #new!MCThreeWayMerger class removeSelector: #new!MCSnapshotTest removeSelector: #mockClassExtension!MCDictionaryRepository removeSelector: #sortedVersionInfos!MCDictionaryRepository removeSelector: #morphicOpen:!MCDictionaryRepository removeSelector: #includesVersionNamed:!MCDictionaryRepository removeSelector: #allVersionInfos!MCFtpRepository class removeSelector: #templateCreationSelector!MCConfiguration removeSelector: #diffBaseFor:!MCRepositoryGroup class removeSelector: #new!MCDependencySorter class removeSelector: #new!MCTraitDefinition removeSelector: #load!MCTraitDefinition removeSelector: #createClass!MCHttpRepository removeSelector: #userAndPasswordFromSettingsDo:!MCHttpRepository class removeSelector: #clearPasswords!MCFileBasedRepository removeSelector: #morphicOpen:!MCFileBasedRepository removeSelector: #allVersionNames!MCGOODSRepository removeSelector: #versionsAvailableForPackage:!MCGOODSRepository removeSelector: #morphicOpen:!MCScriptDefinition removeSelector: #load!MCScriptDefinition class removeSelector: #from:!MCDefinitionIndex class removeSelector: #new!MCPackageManager removeSelector: #registerForNotificationsFrom:!MCPackageManager removeSelector: #registerForNotifications!MCPackageManager removeSelector: #methodRemoved:!MCPackageManager removeSelector: #methodMoved:!MCPackageManager removeSelector: #methodModified:!MCPackageManager removeSelector: #classRemoved:!MCPackageManager removeSelector: #classMoved:!MCPackageManager removeSelector: #classModified:!MCPackageManager class removeSelector: #initialize!MCVersionLoader class removeSelector: #new!TimeStamp class removeSelector: #fromString:!MCMczWriter class removeSelector: #new!MCCodeTool removeSelector: #printOutMessage!MCVersionInspector removeSelector: #save!MCRepositoryInspector removeSelector: #widgetSpecs!MCRepositoryInspector removeSelector: #versionSelection:!MCRepositoryInspector removeSelector: #versionSelection!MCRepositoryInspector removeSelector: #versionListMenu:!MCRepositoryInspector removeSelector: #versionList!MCRepositoryInspector removeSelector: #version!MCRepositoryInspector removeSelector: #summary!MCRepositoryInspector removeSelector: #sortedVersions!MCRepositoryInspector removeSelector: #setRepository:workingCopy:!MCRepositoryInspector removeSelector: #refresh!MCRepositoryInspector removeSelector: #packageSelection:!MCRepositoryInspector removeSelector: #packageSelection!MCRepositoryInspector removeSelector: #packageListMenu:!MCRepositoryInspector removeSelector: #packageList!MCRepositoryInspector removeSelector: #load!MCRepositoryInspector removeSelector: #hasVersion!MCRepositoryInspector removeSelector: #defaultLabel!MCRepositoryInspector removeSelector: #defaultExtent!MCRepositoryInspector removeSelector: #buttonSpecs!MCRepositoryInspector class removeSelector: #repository:workingCopy:!Smalltalk removeClassNamed: #MCRepositoryInspector!MCFileRepositoryInspector removeSelector: #widgetSpecs!MCFileRepositoryInspector removeSelector: #versionSummary!MCFileRepositoryInspector removeSelector: #versionSelection:!MCFileRepositoryInspector removeSelector: #versionSelection!MCFileRepositoryInspector removeSelector: #versionListMenu:!MCFileRepositoryInspector removeSelector: #versionList!MCFileRepositoryInspector removeSelector: #versionInfo!MCFileRepositoryInspector removeSelector: #versionHighlight:!MCFileRepositoryInspector removeSelector: #version!MCFileRepositoryInspector removeSelector: #setRepository:workingCopy:!MCFileRepositoryInspector removeSelector: #refresh!MCFileRepositoryInspector removeSelector: #packageSelection:!MCFileRepositoryInspector removeSelector: #packageSelection!MCFileRepositoryInspector removeSelector: #packageListMenu:!MCFileRepositoryInspector removeSelector: #packageList!MCFileRepositoryInspector removeSelector: #packageHighlight:!MCFileRepositoryInspector removeSelector: #orderString:!MCFileRepositoryInspector removeSelector: #orderSpecs!MCFileRepositoryInspector removeSelector: #order:!MCFileRepositoryInspector removeSelector: #merge!MCFileRepositoryInspector removeSelector: #load!MCFileRepositoryInspector removeSelector: #hasVersion!MCFileRepositoryInspector removeSelector: #defaultLabel!MCFileRepositoryInspector removeSelector: #defaultExtent!MCFileRepositoryInspector removeSelector: #buttonSpecs!MCFileRepositoryInspector class removeSelector: #repository:workingCopy:!MCFileRepositoryInspector class removeSelector: #order:!MCFileRepositoryInspector class removeSelector: #order!MCFileRepositoryInspector class removeSelector: #migrateInstances!MCFileRepositoryInspector class removeSelector: #initialize!Smalltalk removeClassNamed: #MCFileRepositoryInspector!Time class removeSelector: #fromString:!"Monticello.impl"!PackageInfo removeSelector: #propertyDefaultAt:!MethodReference removeSelector: #sourceCode!PackageInfo class removeSelector: #default!PackageInfo class removeSelector: #initialize!!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 2/17/2009 17:05'!propertyDefaultAt: key	 | defaultSelector |		 	defaultSelector := (key, 'Default') asSymbol.		^ (self respondsTo: defaultSelector) ifTrue: [ self perform: defaultSelector ] ifFalse: [ ^ nil ].				 ! !"PackageInfo-Base"!Installer installSilentlyUrl: 'http://installer.pbwiki.com/f/PackageInfo-Base-kph.67.st'. Installer installSilentlyUrl: 'http://installer.pbwiki.com/f/Monticello.impl-kph.635.st'.  ((SequenceableCollection organization categoryOfElement: #do:displayingProgress:) beginsWith: '*')     ifTrue: [SequenceableCollection organization classify: #do:displayingProgress: under: #enumerating].  Installer ss project:'mc';      installQuietly: 'Monticello.impl-kph.635';      installQuietly: 'PackageInfo-Base'.!----End fileIn of a stream----!Installer install:'LevelPlayingField-Monticello15'.!----End fileIn of a stream----!Installer removeSelector: #printOn:!Installer removeSelector: #search:!InstallerSqueakMap removeSelector: #smSearch:!!InstallerSqueakMap class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:42'!label	^ 'squeakmap'! !!InstallerSqueakMap methodsFor: 'searching' stamp: 'damiencassou 2/20/2009 19:30'!search: aMatch  	| results |	results := Set new.	self availablePackages do: [ :pkg |		({ 'name:',pkg name.		   'summary:', pkg summary.		   'description:', pkg description.		   'author:', pkg author. } anySatisfy: [ :field | aMatch match: field ])		 ifTrue: [ results add: (self copy package: pkg name) ]. 	].	^results! !!InstallerSake class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:42'!label	^ 'sake'! !!InstallerMonticello class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:41'!label	^ 'monticello'! !!InstallerMonticello methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:42'!label	^ 'repository:''', mc description, ''''! !!InstallerMonticello methodsFor: 'Installer-Core' stamp: 'damiencassou 2/20/2009 20:30'!printConfigurationOn: stream	self project		ifNotNilDo: [:projectName | stream							nextPutAll: ' project:''';							nextPutAll: projectName;							nextPut: $']! !!InstallerWebSqueakMap class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:40'!label	^ 'websqueammap'! !!InstallerWeb class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:40'!label	^ 'web'! !!InstallerUpdateStream class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:43'!label	^ 'updatestream'! !!Installer class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 20:29'!label	^ ''! !!Installer methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:37'!label	^ self class label! !!Installer methodsFor: 'printing' stamp: 'damiencassou 2/20/2009 20:30'!printConfigurationOn: stream	! !!Installer methodsFor: 'printing' stamp: 'damiencassou 2/20/2009 20:30'!printOn: s	s		nextPutAll: '(Installer ';		nextPutAll: self label;		nextPut: $).	"lf project ifNotNil: [ s nextPutAll: ' project:'; nextPutAll: '''', self project, ''''.						self package ifNotNil: [ s nextPutAll: '; '] ]."	self package ifNotNil: [ s nextPutAll: ' package:'; nextPutAll: '''', self package asString, '''' ].	self printConfigurationOn: s.	s nextPut: $..! !!Installer methodsFor: 'searching' stamp: 'damiencassou 2/20/2009 19:29'!search: aMatch	^'search type not supported'! !!InstallerUniverse class methodsFor: 'as yet unclassified' stamp: 'damiencassou 2/20/2009 19:42'!label	^ 'universe'! !!InstallerFile class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:39'!label	^ 'file'! !!InstallerMantis class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:40'!label	^ 'mantis'! !!InstallerUrl class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:39'!label	^ 'url'! !!InstallerUrl methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:44'!label	^ 'url:''', url, ''''! !!InstallerCruft class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:38'!label	^ 'cruft'! !"Installer-Core"!Smalltalk removeClassNamed: #MCWorkingCopyTest!Smalltalk removeClassNamed: #MCVersionTest!Smalltalk removeClassNamed: #MCStWriterTest!Smalltalk removeClassNamed: #MCStReaderTest!Smalltalk removeClassNamed: #MCSnapshotTest!Smalltalk removeClassNamed: #MCSnapshotBrowserTest!Smalltalk removeClassNamed: #MCSerializationTest!Smalltalk removeClassNamed: #MCScannerTest!Smalltalk removeClassNamed: #MCDirectoryRepositoryTest!Smalltalk removeClassNamed: #MCDictionaryRepositoryTest!Smalltalk removeClassNamed: #MCRepositoryTest!Smalltalk removeClassNamed: #MCPatchTest!Smalltalk removeClassNamed: #MCPackageTest!Smalltalk removeClassNamed: #MCOrganizationTest!Smalltalk removeClassNamed: #MCMethodDefinitionTest!Smalltalk removeClassNamed: #MCMergingTest!Smalltalk removeClassNamed: #MCMczInstallerTest!Smalltalk removeClassNamed: #MCInitializationTest!Smalltalk removeClassNamed: #MCFileInTest!Smalltalk removeClassNamed: #MCClassDefinitionTest!Smalltalk removeClassNamed: #MCChangeNotificationTest!Smalltalk removeClassNamed: #MCAncestryTest!Smalltalk removeClassNamed: #MCTestCase!Smalltalk removeClassNamed: #MCSortingTest!Smalltalk removeClassNamed: #MCSnapshotResource!Smalltalk removeClassNamed: #MCDependencySorterTest!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 20 February 2009 at 10:11:31 pm'!----End fileIn of a stream----!'From Croquet1.0beta of 11 April 2006 [latest update: #2] on 19 January 2009 at 3:07:50 pm'!!MultiByteFileStream methodsFor: 'open/close' stamp: 'kph 2/15/2007 03:18' prior: 25234559!open: fileName forWrite: writeMode 	| result |	result := super open: fileName forWrite: writeMode.	result ifNotNil: [			converter ifNil: [converter := UTF8TextConverter new].			lineEndConvention ifNil: [ self detectLineEndConvention ]	].	^result! !!MultiByteFileStream methodsFor: 'remnant' stamp: 'mtf 1/19/2009 15:06' prior: 25229646!wantsLineEndConversion: aBooleanOrLineEndConvention		wantsLineEndConversion :=  aBooleanOrLineEndConvention ~= false.	aBooleanOrLineEndConvention isSymbol ifTrue: [ lineEndConvention := aBooleanOrLineEndConvention ]						 		  ifFalse: [ self detectLineEndConvention ]. ! !----End fileIn of a stream----!Installer mantis bug: 6086 fix: 'MultiByteFileStream-M6086.2.cs'.!----End fileIn of a stream----!!SmalltalkImage class methodsFor: '*installer-launcher' stamp: 'kph 2/27/2007 18:57'!launchFrom: launcher ^self launchWith: launcher getParameters! !!SmalltalkImage class methodsFor: '*installer-launcher' stamp: 'kph 2/16/2007 10:05'!launchHelp^'+save                    Save imagesave=name.image          Save image with given file name+quit                    Quit squeak'! !!SmalltalkImage class methodsFor: '*installer-launcher' stamp: 'kph 1/18/2008 07:51'!launchWith: params	| saveAs quit resuming |	saveAs := params at: 'SAVE' ifAbsent: false.	quit := params at: 'QUIT' ifAbsent: false.	(saveAs isKindOf: Boolean) 		ifFalse: [				saveAs = 'AUTO' ifTrue: [ saveAs := SystemVersion current version ,'-', Date today yyyymmdd ].							  (saveAs endsWith: FileDirectory imageSuffix) ifFalse: [ saveAs := saveAs, '.', FileDirectory imageSuffix ]. 				  resuming := self current saveAs: saveAs.				  resuming ifTrue: [ ^false ].				  saveAs := false ].		 	resuming := self current snapshot: saveAs andQuit: (quit == true).	 	resuming ifTrue: [ ^false ].	"returning false, stops evaluation of further commandline parameters	 this will be beneficial for image restart"	^ true	! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'testReporter 3/1/2007 16:09'!initialize 	Smalltalk addToStartUpList: self after: SecurityManager.! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'testReporter 3/1/2007 16:20'!launchFrom: launcher	^self launchWith: launcher getParameters			! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'testReporter 3/1/2007 16:20'!launchHelp"Launcher testLaunch: #('+help')."^'+help,h                  Prints this help text.scripts="<sc.st> <sc2.st>"   Execute smalltalk scripts given by urls.'! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'klc 8/14/2008 14:17'!launchWith: params	params at: 'H' ifPresent: [:v | params at: 'HELP' put: v ].	params at: 'S' ifPresent: [ :v | params at: 'SCRIPTS' put: v ].	params at: 'HELP' ifPresent: [ :v | Script new writeHelp ].	params at: 'SCRIPTS' ifPresent: [:v |		CodeLoader new loadSourceFiles: (Array withAll: (v findTokens: ' ')) ;			installSourceFiles].	^true! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'testReporter 3/1/2007 19:09'!newLaunchWith: arrayOrImage 	^ (self new) 		actionSelector: #launchFrom: ;		image: arrayOrImage;		commandLineClass: self;		begin;		yourself			! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'testReporter 3/1/2007 19:09'!newStartWith: arrayOrImage 	^ (self new) 		actionSelector: #startFrom: ;		image: arrayOrImage;		commandLineClass: self;		begin;		yourself		! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'kph 2/28/2007 01:05'!startFrom: starter	^self startWith: starter getParameters! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:04'!startUp: resuming"we are sent this when starting as an image startup item before autostart"	^ self newStartWith: SmalltalkImage current ! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'kph 9/1/2008 20:22'!startWith: params	params at: 'START' ifPresent: [:v | 		CodeLoader new loadSourceFiles: (Array withAll: (v findTokens: ' ')) ;			installSourceFiles ].	^true! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:05'!actionSelector: aSelector	actionSelector := aSelector! !!Launcher methodsFor: 'public' stamp: 'kph 2/27/2007 18:13'!beFirstTime nextParameterIndex := 3. ! !!Launcher methodsFor: 'as yet unclassified' stamp: 'kph 3/2/2007 16:50'!begin 	nextCommandLineDocument := nil. 		[ self launch: commandLineClass ] 		whileTrue: [ 			commandLineClass := self nextCommandLineClass.			commandLineClass ifNil: [ ^self ] ].		  												! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:05'!classes	^ Smalltalk! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:05'!commandLineClass: aClass	commandLineClass := aClass. 						! !!Launcher methodsFor: 'public' stamp: 'testReporter 3/1/2007 17:28'!getParameters 	"this utility extracts the unprocessed parameters into a dictionary from the typical form:		param1=true param2=''hello world'' +param3 -param4	i.e. items with an = are parameters,	+ gives param3=true	- give param4=false	items without +=- are considered to refer to the next Launch Class or document.	"	| key value parameters item |		parameters := Dictionary new.		parameters at: #document put: commandLineClass. 	[ (item := image getSystemAttribute: nextParameterIndex) isEmptyOrNil] 		whileFalse:[			nextParameterIndex := nextParameterIndex + 1.			item := item readStream.			value := nil.			(item peek = $-) ifTrue: [ value := false. item next  ].			(item peek = $+) ifTrue: [ value := true.  item next  ].			key := item upTo: $=.			value isNil & item atEnd not ifTrue: [ value := item upToEnd ].			value 				ifNotNil: [ parameters at: key asUppercase put: value ] 				ifNil: [ nextCommandLineDocument  := key. 					    ^parameters ].	].		nextCommandLineDocument := nil.	^parameters												! !!Launcher methodsFor: 'public' stamp: 'testReporter 3/1/2007 17:28'!getParametersOldStyle	"this utility extracts the unprocessed parameters into a dictionary from the typical old style form:		KEY value Key2 Value Key3 Value :NextLauncherClass KEY value Key2 value etc.		the ability to specify the next launcher class by beginning a parameter 	with a non letter character has been added.	"	| key value parameters |		parameters := Dictionary new.		parameters at: #document put: commandLineClass. 	[ (key := image getSystemAttribute: nextParameterIndex) isEmptyOrNil] 		whileFalse:[			nextParameterIndex := nextParameterIndex + 1.			key first isLetter ifFalse: [ 				nextCommandLineDocument :=  key copyWithoutFirst. 				^ parameters ].						value := image getSystemAttribute: nextParameterIndex.			nextParameterIndex := nextParameterIndex + 1.						parameters at: key asUppercase put: value. 	].	^parameters												! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:05'!getSystemAttribute: n"this provides the ability for us to be a mock image with startup parameters in our array."	^ mock at: n - 1 ifAbsent: nil! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:06'!image: imageOrMock	image := imageOrMock isCollection  		ifTrue: [ mock := imageOrMock. self ]		ifFalse: [ imageOrMock ] . ! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:06'!initialize	nextParameterIndex := 2! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:06'!launch: aClass	^ (aClass respondsTo: actionSelector) 		ifTrue: [ aClass perform: actionSelector with: self ]		ifFalse: [ false ]! !!Launcher methodsFor: 'as yet unclassified' stamp: 'kph 2/27/2007 18:47'!nextCommandLineClass				^nextCommandLineDocument ifNotNilDo: [:l | self classes at: l asSymbol ifAbsent: [ nil ] ]	 ! !!Launcher methodsFor: 'reporting' stamp: 'mtf 7/3/2008 15:08'!report: reportSelector for: item on: stream	(item respondsTo: reportSelector) ifFalse: [ ^ stream nextPutAll: 'REPORT UNAVAILABLE'; cr ].	(reportSelector last = $:) ifTrue: [ ^item perform: reportSelector with: stream ].	(item perform: reportSelector) ifNotNilDo: [ :result | 		^result isString			ifTrue: [ stream nextPutAll: result ] 			ifFalse: [ result do: [ :each | stream nextPutAll: each asString; cr ] ] ]! !!Launcher methodsFor: 'reporting' stamp: 'mtf 7/3/2008 15:08'!reportFor: target  	^ self reportFor: target with: self getParameters! !!Launcher methodsFor: 'reporting' stamp: 'mtf 7/3/2008 15:10'!reportFor: target with: params 	| reports dest scriptIO quit |	reports := params at: 'REPORT' ifAbsent: [ ^ self error: 'no report requested' ].	reports := reports findTokens: ' '.	dest := params at: 'TO' ifAbsent: nil.	scriptIO := Script new writeTo: (params at: 'TO' ifAbsent: nil) in: (params at: 'DIR' ifAbsent: '').	reports do: [ : reportSelector |		scriptIO := Script new 			writeTo: (dest ifNotNil: [ dest copyReplaceAll:'*' with: reportSelector]) 			in: (params at: 'DIR' ifAbsent: '').		scriptIO printWith: [ :out | self report: reportSelector asSymbol for: target on: out ] ]. 	quit := params at: 'QUIT' ifAbsent: [ false ].	quit ~= false ifTrue: [ SmalltalkImage current snapshot: false andQuit: true ].	^true! !!Script class methodsFor: 'as yet unclassified' stamp: 'kph 2/27/2007 18:57'!launchFrom: launcher	^self launchWith: launcher getParameters! !!Script class methodsFor: 'as yet unclassified' stamp: 'kph 2/22/2007 16:00'!launchHelp^'eval, e="2+2"            Evaluate code and quit.print, p="2+2"           Evaluate and print result to stdout and quit.-quit                    Remain open after evaluating code'! !!Script class methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:01'!launchWith: params	| script quit |	params at: 'E' ifPresent: [:v | params at: 'EVAL' put: v ].	params at: 'P' ifPresent: [:v | params at: 'PRINT' put: v ].	script := self new.	params at: 'TO' ifPresent: [ :v | script writeTo: v in: (params at: 'DIR' ifAbsent: '')].	params at: 'HELP' ifPresent: [ :v | script writeHelp ].	params at: 'EVAL' ifPresent: [ :v | script evaluate: v ].	params at: 'PRINT' ifPresent: [ :v | script evaluateAndPrint: v ].	quit := params at: 'QUIT' ifAbsent: true.	quit ~= false ifTrue: [ SmalltalkImage current snapshot: false andQuit: true ].	^true! !!Script class methodsFor: 'as yet unclassified' stamp: 'testReporter 3/1/2007 16:23'!startFrom: launcher	^self startWith: launcher getParameters! !!Script class methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:03'!startWith: params	| script |	script := self new.	params at: 'TO' ifPresent: [ :v | script writeTo: v in: (params at: 'DIR' ifAbsent: '')].	params at: 'INIT' ifPresent: [ :v | script evaluate: v ].	params at: 'INITP' ifPresent: [ :v | script evaluateAndPrint: v ].	^true! !!Script methodsFor: 'as yet unclassified' stamp: 'kph 2/15/2007 04:09'!evaluate: code	^Compiler new evaluate: code in: nil to: self.! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 14:49'!evaluateAndPrint: code	self printWith: [ :output | output nextPutAll: (self evaluate: code) asString; cr ]	 ! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 14:50'!initialize	stdout := (MultiByteFileStream new) 		wantsLineEndConversion: #crlf; 		open: '/dev/stdout' forWrite: true.			stderr :=  (MultiByteFileStream new) 		wantsLineEndConversion: #crlf; 		open: '/dev/stderr' forWrite: true. 	 	stdin  := AsyncFile new open: '/dev/stdin' forWrite: false.! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 14:50'!printWith: aBlock	fileout ifNil: [ ^aBlock value: stdout ].	FileStream detectFile: [ dir forceNewFileNamed: fileout ] do: aBlock ! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 14:50'!stderr	^stderr! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 14:51'!stdout	^stdout! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:10'!writeHelp	| helps |	helps := SystemNavigation default allImplementorsOf: #launchHelp.	self printWith: [ :output |			helps do: [ :mr | 			output nextPutAll: mr classSymbol; cr; cr.			output nextPutAll: (mr actualClass soleInstance launchHelp); cr; cr ] ]! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 14:56'!writeTo: fileName in: directory	fileout := fileName.	dir := FileDirectory on: (FileDirectory default fullNameFor: directory).	dir assureExistence.! !!ProjectLauncher methodsFor: '*installer-launcher' stamp: 'kph 6/6/2008 23:42' prior: 28228354!startUpAfterLogin	| scriptName loader isUrl |	self setupFlaps.	Preferences readDocumentAtStartup ifTrue: [		HTTPClient isRunningInBrowser ifTrue:[			self setupFromParameters.			scriptName := self parameterAt: 'src'.			CodeLoader defaultBaseURL: (self parameterAt: 'Base').		] ifFalse:[			scriptName := (SmalltalkImage current getSystemAttribute: 2) ifNil:[''].			scriptName := [ scriptName convertFromSystemString ] ifError: [ scriptName asString ].			scriptName isEmpty ifFalse:[				"figure out if script name is a URL by itself"				isUrl := (scriptName asLowercase beginsWith:'http://') or:[						(scriptName asLowercase beginsWith:'file://') or:[						(scriptName asLowercase beginsWith:'ftp://')]].				isUrl ifFalse:[					Smalltalk at: scriptName asSymbol					ifPresent: [:launchClass | ^ Launcher newLaunchWith: SmalltalkImage current ].										scriptName := 'file:', (FileDirectory default fullNameFor: scriptName) ]				].		]. ]	ifFalse: [ scriptName := '' ].	scriptName isEmptyOrNil		ifTrue:[^Preferences eToyFriendly ifTrue: [self currentWorld addGlobalFlaps]].	loader := CodeLoader new.	loader loadSourceFiles: (Array with: scriptName).	(scriptName asLowercase endsWith: '.pr') 		ifTrue:[self installProjectFrom: loader]		ifFalse:[loader installSourceFiles].! !!SystemNavigation class methodsFor: '*installer-launcher' stamp: 'kph 2/27/2007 19:00'!launchFrom: launcher^launcher reportFor: self default! !!SystemNavigation class methodsFor: '*installer-launcher' stamp: 'kph 2/16/2007 10:01'!launchHelp^'report=method            Execute the query method and print the results to stdout or file.to="*.txt"               Filename or pattern to write report to (default is stdout).'! !!Launcher commentStamp: 'testReporter 3/1/2007 19:06' prior: 0!A Launcher provides squeak with a range of capabilities that are intended to be used from the command line.As a design goal, the startup process can invoke Launcher several times at several points in the startup sequence. In particular 1) below aims to provide a mechanism for getting in to images that are broken in some form, so as to enable a script to be run before morphic has attempted to startup.1) Launcher is registered to handle startup notification after Security managerany class which wishes to provide a service to be usable at this time implements startFrom:2) Launcher is wired in to ProjectLauncher to handle startup notification when squeak is fully initialized. Any class wishing to provide a service to be usable at this time implements launchFrom:#startFrom: and #launchFrom: are called providing a handle to the launcher which may be used to obtain parameters using the desired scheme. a) launcher getParameters . key=value +yes -nob) launcher getParametersOldStyle . key value key2 value2Instance Variables	actionSelector: #startFrom: #launchFrom:	commandLineClass: aClass	image:	the smalltalk image or self if being a mock	mock: the mock array of startup parameters	nextCommandLineDocument: aString	nextParameterIndex:	 anInteger !"Installer-Launcher"!'From Squeak3.10 of 22 July 2007 [latest update: #7159] on 9 June 2008 at 9:29:57 pm'!!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'kph 1/29/2007 00:52' prior: 30260240!saveAs	"Put up the 'saveAs' prompt, obtain a name, and save the image  under that new name."	self saveAs: self getFileNameFromUser! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'kph 2/14/2007 11:06'!saveAs: newName	newName ifNil: [ ^self ].		(SourceFiles at: 2) ifNotNil:		[self closeSourceFiles; "so copying the changes file will always work"			 saveChangesInFileNamed: (self fullNameForChangesNamed: newName)].	^self saveImageInFileNamed: (self fullNameForImageNamed: newName)! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'kph 2/14/2007 11:07' prior: 30262237!saveAsNewVersion	"Save the image/changes using the next available version number."	"SmalltalkImage current saveAsNewVersion"		| newName changesName aName anIndex |	aName := FileDirectory baseNameFor: (FileDirectory default localNameFor: self imageName).	anIndex := aName lastIndexOf: FileDirectory dot asCharacter ifAbsent: [nil].	(anIndex notNil and: [(aName copyFrom: anIndex + 1 to: aName size) isAllDigits])		ifTrue:			[aName := aName copyFrom: 1 to: anIndex - 1].	newName := FileDirectory default nextNameFor: aName extension: FileDirectory imageSuffix.	changesName := self fullNameForChangesNamed: newName.	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"	(FileDirectory default fileOrDirectoryExists: changesName)		ifTrue:			[^ self inform:'There is already .changes file of the desired name,', newName, 'curiously already present, even though there isno corresponding .image file.   Please remedymanually and then repeat your request.'].	^self saveAs: newName! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'mtf 6/9/2008 21:29' prior: 30264102!saveImageInFileNamed: aString	| fullImageName |	fullImageName := (FileDirectory default fullNameFor: aString).	(FileDirectory default directoryNamed:(FileDirectory dirPathFor: fullImageName )) assureExistence.	^self		changeImageNameTo: fullImageName;		closeSourceFiles;		openSourceFiles;  "so SNAPSHOT appears in new changes file"		saveImageSegments;		snapshot: true andQuit: false! !----End fileIn of a stream----!Installer mantis bug: 5851 fix: 'SmalltalkImage-M5851.3.cs'.!----End fileIn of a stream----!Installer mantis fixBug: '6086 Improved Line End Convention Specification'.  Installer squeaksource project:'Installer';        install:  'Installer-Launcher'.  Installer mantis fixBug: '5851 Refactor SmalltalkImage saveAs'.  Transcript cr; cr; show:'You now have a level playing field.'. Transcript cr; cr; show:'Launcher now processing additional commandline parameters...'. (Smalltalk at: #Launcher) new 		actionSelector: #launchFrom: ; 		image: SmalltalkImage current; 		commandLineClass: Launcher; 		beFirstTime; 		begin; 		yourself.!----End fileIn of a stream----!Installer upgrade.  Smalltalk organization removeSystemCategory: 'Monticello-Tests'. (MCPackage named: 'Monticello') workingCopy unregister. (MCPackage named: 'PackageInfo') workingCopy unregister. (MCPackage named: 'MonticelloConfigurations') workingCopy unregister.  SystemOrganization removeEmptyCategories.  MCMethodDefinition freeSomeSpace. MCFileBasedRepository freeSomeSpace. DataStream initialize.  Transcript show: 'Postscript: Squeakmap Update '.  [ Installer sm update ] ifError: [ Transcript show: '(Squeakmap not installed)'.].  Installer install:'LevelPlayingField-LauncherLaunch'. (Delay forSeconds: 2) wait.!----End fileIn of a stream----!Transcript show: 'Installer bootstrap - Loaded '.

Transcript show: 'Begin "Operation Level Playing Field"...'.

Installer install: 'LevelPlayingField-Preamble'.
Installer install: 'LevelPlayingField'. 
Installer install: 'LevelPlayingField-Postscript'. 

!----End fileIn of a stream----!self halt. HTTPSocket httpFileIn: 'installer.pbwiki.com/f/LPF.st'.!'From Squeak3.10 of 22 July 2007 [latest update: #7159] on 6 November 2008 at 4:43:56 pm'!!Magnitude methodsFor: 'streaming' stamp: 'kph 9/27/2007 22:10'!putOn: aStream	(aStream isBinary ifTrue: [ self asByteArray ] ifFalse: [ self asString]) putOn: aStream	 ! !!SequenceableCollection methodsFor: 'streaming' stamp: 'kph 9/27/2007 21:18'!putOn: aStream	self do: [ :each | each putOn: aStream ]! !!SocketStream methodsFor: 'private' stamp: 'kph 11/6/2008 16:43'!<< items 	items putOn: self.		^ self! !!Stream methodsFor: 'readability' stamp: 'kph 9/27/2007 21:53'!<< items 	items putOn: self.		^ self! !!ByteArray methodsFor: 'streaming' stamp: 'kph 9/27/2007 21:53'!putOn: aStream	aStream nextPutAll: self! !!WriteStream methodsFor: 'printing' stamp: 'kph 11/2/2008 01:16'!<< aCollection	"we want a readable version of nextPutAll however it may be difficult to fully recreate nextPutAll:	for all the different types of stream. Rather then simply send to nextPutAll:	we handle the String (or ByteArray) argument	as fast as possible - the rest we delegate to putOn: This means that we handle single characters and bytes 	whereas nextPutAll: is only for sequencable collections.	.	Note this may not work in every case that nextPutAll: does subject to extensive testing, 	but it should work in the important cases"	| newEnd |	collection class == aCollection class ifFalse:		[ aCollection putOn: self. ^ self ].	newEnd := position + aCollection size.	newEnd > writeLimit ifTrue:		[self growTo: newEnd + 10].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.	position := newEnd.! !----End fileIn of a stream----!Installer mantis bug: 7219 fix: 'Stream-Readability.4.cs'.!----End fileIn of a stream----!'From Squeak3.10.2bc-beta of 16 December 2008 [latest update: #7179] on 21 January 2009 at 3:33:21 pm'!!BlockContext methodsFor: 'testing' stamp: 'kph 1/21/2009 15:33'!= other	self class == other class ifFalse: [^ false].	self home receiver == other home receiver ifFalse: [^ false].	self home selector == other home selector ifFalse: [^ false].	^ self startpc == other startpc! !!BlockContext methodsFor: 'testing' stamp: 'kph 1/21/2009 15:33'!hash	^ self method hash! !----End fileIn of a stream----!Installer mantis bug: 7272 fix: 'Block equality testing.1.cs'.!----End fileIn of a stream----!!SakeSignal class methodsFor: 'as yet unclassified' stamp: 'kph 10/1/2008 04:54'!context: context during: aBlock	^ aBlock on: SakeSignal do: [ :ex | ex resume: (context perform: ex lookup with: ex argument) ]! !!SakeSignal methodsFor: 'accessing' stamp: 'kph 10/1/2008 04:54'!argument	^ self messageText ifNil: [ self tag ]! !!SakeSignal methodsFor: 'accessing' stamp: 'kph 10/1/2008 05:03'!defaultAction	^ tag perform: self lookup with: self argument! !!SakeSignal methodsFor: 'accessing' stamp: 'kph 10/1/2008 04:30'!lookup	"Answer the value of lookup"	^ lookup! !!SakeSignal methodsFor: 'as yet unclassified' stamp: 'kph 10/1/2008 04:30'!lookup: aSymbol	lookup := aSymbol! !!MCWorkingCopy methodsFor: '*sake-core' stamp: 'kph 12/14/2008 01:50'!taskAdoptHistoryFrom: repo saveWithComment: message 	"The repo is the one we are maintaining. If there are no changes then adopt the one in the repo as the master"		| closest |	^ SakeTask define: [ :task | 		task if: [ self needsSaving ]. 						task action: [ self repositoryGroup addRepository: repo.			self setMyRepositoryFromLastAdded.			closest := repo closestAncestorVersionFor: ancestry ifNone:[nil].			closest ifNotNil: [ ancestry := MCWorkingAncestry new addAncestor: closest info ].					(self changesRelativeToRepository: repo) isEmpty 				ifTrue: [  						 self modified: false.						 ] 				ifFalse: [					message ifNotNil: [  						repo storeVersion: (self newVersionWithName: self uniqueVersionName message: message)]				] 	  	]	] ! !!MCWorkingCopy methodsFor: '*sake-core' stamp: 'kph 12/14/2008 01:55'!taskSaveWithComment: message 	^ (self taskAdoptHistoryFrom: self repository saveWithComment: message) defined ! !!BlockContext methodsFor: '*sake-core' stamp: 'kph 12/10/2008 02:57'!asTask	^ SakeTask action: self! !!Collection methodsFor: '*sake-core' stamp: 'kph 12/29/2007 02:32'!asTask	"make a collection of tasks into a task depending upon each of the contained tasks"	^ SakeTask collection: self! !!Class class methodsFor: '*sake-core' stamp: 'kph 8/18/2008 18:29'!ensureClass: aClassName hasSubclass: bClassName	^ SakeTask define: [ :task |		task dependsOn: { Class exists: aClassName }.		task if: [ :t | (Class exists: bClassName) fails ].		task action: [ 						| c |						c := Smalltalk at: aClassName asSymbol.   			c	subclass: bClassName asSymbol				instanceVariableNames: ''				classVariableNames: ''				poolDictionaries: ''				category: c category. 		]	]! !!Class class methodsFor: '*sake-core' stamp: 'kph 4/22/2008 21:34'!exists: aClassName	^ SakeTask define: [ :task |		task action: [ 			Smalltalk 				at: aClassName asSymbol 				ifAbsent: [ task stop: 'Class named ', aClassName , ' does not exist.' ]  				]	]! !!Class class methodsFor: '*sake-core' stamp: 'kph 4/22/2008 21:34'!named: aClassName cleanMethodCategory: cat		^ SakeTask define: [ :task |				task dependsOn: { Class exists: aClassName. }.				task action: [ 			| theClass |						theClass := Smalltalk at: aClassName.			(theClass organization listAtCategoryNamed: cat)				do: [ :each | theClass removeSelector: each ].				theClass organization removeEmptyCategories.		 			]	]! !!SakeCompiler methodsFor: 'as yet unclassified' stamp: 'mtf 10/1/2008 10:27'!from: textOrStream class: aClass classified: aCategory context: aContext notifying: req	super from: (textOrStream readStream upToAll: (String cr,'""""""'))		class: aClass		classified: aCategory		context: aContext		notifying: req! !!BlockClosure methodsFor: '*sake-core' stamp: 'kph 12/10/2008 02:57'!asTask	^ SakeTask action: self! !!DateAndTime methodsFor: '*sake-core' stamp: 'kph 12/14/2008 00:23'!printYYMMDDHHSS: sep 	^ (self asDate printFormat: #(3 2 1 0  1 2 2)), sep, self asTime hhmm24.	! !!Object methodsFor: '*sake-core' stamp: 'kph 9/1/2008 16:32'!asTask	^ SakeTask define: [ :t | t action: [ self ] ]! !!SakeClassTask class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 05:53'!category: aCategory classes: classes	| c |		c := classes isSymbol ifTrue: [ Array with: classes ] ifFalse: [ classes ].	 	^ self dependingOn: (c collect: [ :ea | (self class: ea) setCategory: aCategory ])! !!SakeClassTask class methodsFor: 'instance creation' stamp: 'damiencassou 12/23/2008 08:17'!class: aClassOrName	^ self new		theClassName: aClassOrName;		initialize;		yourself		! !!SakeClassTask class methodsFor: 'instance creation' stamp: 'kph 11/11/2008 14:30'!class: aClassName subclass: bClassName	^ (self class: aClassName) subclass: bClassName! !!SakeClassTask class methodsFor: 'instance creation' stamp: 'kph 4/22/2008 22:13'!exists: aClassName 	^ (SakeClassTask class: aClassName) exists! !!SakeClassTask class methodsFor: 'testing tasks' stamp: 'kph 4/22/2008 22:18'!isMeta: aClassName 	^ (self class: aClassName) isMeta! !!SakeClassTask class methodsFor: 'testing tasks' stamp: 'kph 4/22/2008 22:15'!nonMeta: aClassName 	^ (self class: aClassName) nonMeta! !!SakeClassTask class methodsFor: 'as yet unclassified' stamp: 'damiencassou 12/23/2008 08:18'!remove: theClassName	^ (self class: theClassName) remove! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 4/22/2008 21:00'!= other	^ (super = other) and: [ theClassName = other theClassName ]! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 8/18/2008 08:38'!defaultAction	^ context ifNil: [ self stop: 'SakeTask class: ''someTask'' , is not a complete task' ] ifNotNil: [ nil ]! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 8/18/2008 23:40'!do: doBlockOrTaskList		self error: 'is this used? ifExistsDo: is probably better'.		^ self define: [:task |				task if: [ task theClass notNil ].		(doBlockOrTaskList isBlock and: [ doBlockOrTaskList numArgs = 1 ]) 			ifTrue: [ task action: [ doBlockOrTaskList value: task theClass ] ]			ifFalse: [ task action: doBlockOrTaskList ].	].	 ! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 10/1/2008 05:15'!doActionEnd	 super doActionEnd.		"ensure the result has nothing that references the class, incase the class is removed later"	 result isLiteral ifTrue: [ ^ result ].		result := self.! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 4/22/2008 22:14'!exists	^ self define: [ :task |		task action: [ 			task theClass ifNotNil: [ true ] ifNil: [ task stop: 'Class named ', theClassName , ' does not exist.' ] ] 			]! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 4/22/2008 21:00'!hash	^  super hash bitXor: theClassName hash! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 4/22/2008 22:17'!ifExistsDo: doBlockOrTaskList	^ self define: [:task |				task if: [ task theClass notNil ].		(doBlockOrTaskList isBlock and: [ doBlockOrTaskList numArgs = 1 ]) 			ifTrue: [ task action: [ doBlockOrTaskList value: task theClass ] ]			ifFalse: [ task action: doBlockOrTaskList ].	].	 ! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 4/22/2008 22:16'!isMeta	^ self define: [ :task |			task dependsOn: { SakeClassTask exists: theClassName }.			task action: [ task theClass isMeta ifFalse: [ task stop: 'Class named ', theClassName , ' is not a metaclass.' ]  ] 			]! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 1/21/2009 14:05'!missing	^ self define: [ :task |		task action: [ 			task theClass ifNotNil: [ task stop: 'Class named ', theClassName , ' does exist.'  ] ifNil: [ true  ] ]		]! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 4/22/2008 22:36'!nonMeta	^ self define: [ :task |			task dependsOn: { SakeClassTask exists: theClassName }.			task action: [ task theClass isMeta ifTrue: [ task stop: 'Class named ', theClassName , ' is a metaclass.' ]  ] 			]! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 4/22/2008 21:44'!remove 	^ self define: [ :task |				task dependsOn: { (SakeTask class: theClassName) removeSubclasses }.		task if: [ (Smalltalk classNamed: theClassName) notNil ].		task action: [ task theClass removeFromSystem ].	]! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 9/2/2008 14:30'!removeSelector: aMethodSelector	^ self define: [ :task |				task if: [ (Smalltalk classNamed: theClassName) notNil ].		task action: [ 			task theClass removeSelector: aMethodSelector.			task theClass organization removeEmptyCategories. 		]	]! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 4/24/2008 02:03'!removeSelectors: aMethodSelectorOrList	^ self define: [ :task |				task if: [ (Smalltalk classNamed: theClassName) notNil ].		task action: [ 			 aMethodSelectorOrList do: [ :each | 				 task theClass removeSelector: each ].	 			task theClass organization removeEmptyCategories.			]	]! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 12/8/2008 00:03'!removeSelectorsCategory: aCategory	^ self define: [ :task |			task if: [ (Smalltalk classNamed: theClassName) notNil ].			task action: [ 		 				(task theClass organization listAtCategoryNamed: aCategory) do: [ :each | self theClass removeSelector: each].								task theClass organization removeEmptyCategories.					] 			]! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 4/22/2008 21:44'!removeSelectorsMatching: aMethodSelectorMatch	^ self define: [ :task |			task if: [ (Smalltalk classNamed: theClassName) notNil ].			task action: [ 		 				task theClass selectors do: [ :each | (aMethodSelectorMatch match: each) 					ifTrue: [ self theClass removeSelector: each ] ].								task theClass organization removeEmptyCategories.					] 			]! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 4/22/2008 21:44'!removeSubclasses 	^ self define: [ :task |				task if: [ (Smalltalk classNamed: theClassName) notNil ].		task action: [ 			task theClass allSubclassesDo: [:cls | 						cls isSystemDefined							ifFalse: [cls removeFromSystem].						cls := nil].		]	]! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 12/7/2008 22:49'!setCategory: aNewCategory	^ self define: [ :task |				task if: [ (Smalltalk classNamed: theClassName) notNil ].		task action: [ 			task theClass category: aNewCategory. 		]	]! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 11/11/2008 14:30'!subclass: bClassName  	^ self subclass: bClassName category: nil ; defined! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 11/11/2008 14:29'!subclass: bClassName category: aCat	^ self define: [ :task |			task dependsOn: { (SakeClassTask nonMeta: theClassName)  }.			task if: [ (Smalltalk classNamed: bClassName) isNil ].			task action: [ 							task theClass subclass: bClassName asSymbol					instanceVariableNames: ''					classVariableNames: ''					poolDictionaries: ''					category: (aCat ifNil: [ task theClass category ]). 			]	] ! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 9/2/2008 14:09'!theClass	^  Smalltalk classNamed: theClassName! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 4/22/2008 20:59'!theClassName 		^ theClassName  ! !!SakeClassTask methodsFor: 'accessing' stamp: 'kph 4/18/2008 01:11'!theClassName: aClassOrName	aClassOrName isBehavior ifTrue: [ theClass := aClassOrName.									  ^ theClassName := aClassOrName name ].		theClassName := aClassOrName asSymbol! !!SakeTask class methodsFor: 'instance creation' stamp: 'damiencassou 12/23/2008 08:15'!action: actionsOrBlock	^ self define: [ :task |				task action: actionsOrBlock 	]! !!SakeTask class methodsFor: 'as yet unclassified' stamp: 'test 1/10/2009 19:51'!at: selector category: cat putMethod: code doc: content	"only replace the method source if it has changed, return true/false to indicate whether a change occurred"		| s source changed |		source := (s := selector asLegalSelector asSymbol) , String cr, code  ,String cr, '""""""', String cr, content.	(changed := (self sourceCodeAt: s ifAbsent: nil) ~= source) ifTrue: [								 		self compile: source classified: cat notifying: nil.	].	^ changed! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 12/7/2008 23:10'!category: c classes: cs	^  SakeClassTask category: c classes: cs! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 12/9/2008 17:25'!check: key eval: aBlock onChanged: aTaskOrBlock	^ self define: [ :task |		task	 if: [ task statusAt: key hasChanged: aBlock value ].		task action: aTaskOrBlock. 	]! !!SakeTask class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 04:01'!checkUrl: url onChanged: aTask	^ (self check: url eval: [ (HTTPSocket httpGet: url) contents hash ] onChanged: aTask)	       defined;		  yourself		"self checkUrl: 'http://www.squeaksource.com/Sake/feed.rss' onChanged: [ self beep ]."! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 4/18/2008 01:02'!class: aClassOrName	^  SakeClassTask class: aClassOrName ! !!SakeTask class methodsFor: 'clean up' stamp: 'kph 12/9/2008 17:10'!cleanUp	status := nil! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 12/11/2008 22:44'!collection: collectionOfTasks	collectionOfTasks size = 1 ifTrue: [ ^ self action: collectionOfTasks ].		^ (self dependingOn: collectionOfTasks) sort		! !!SakeTask class methodsFor: 'doc methods support' stamp: 'mtf 10/1/2008 10:30'!compilerClass	^ SakeCompiler! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 8/19/2008 18:51'!create: aRioable 			^ (self file: aRioable) define: [ :task |		task if: [ task target exists not ].		task action: [ task target touch ].			]"""""""The equivalent of rake's FileCreationTask	A file task that when used as a dependency will be needed if and only if the file has not been created. Once created, it is not re-triggered if any of its dependencies are newer, Nor does it trigger any rebuilds of tasks that depend on it whenever it is updated.	Default action is to create the file empty."		! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 8/18/2008 22:12'!define: aBlock	^ self new 		in: aBlock; 		defined;		yourself 	 ! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 12/13/2008 04:23'!dependingOn: aList	^ (self define: [ :task | task dependsOn: aList ]) defined! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 11/12/2008 20:18'!dir: aDirectoryAble 			^ self define: [ :task |		task target: aDirectoryAble asDirectory.		task if: [ task target exists not ].		task action: [ task target mkpath ].			]! !!SakeTask class methodsFor: 'doc methods support' stamp: 'kph 7/4/2008 18:59'!docAt: selector	^	(self sourceCodeAt: selector ifAbsent: [ ^ nil ]) 			readStream upToAll: ('""""""', String cr) ; upToEnd! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 4/22/2008 21:37'!ensureClass: aClassName hasSubclass: bClassName	^ SakeTask define: [ :task |		task dependsOn: { [ (self class: aClassName) exists ]  }.		task if: [ (self class: bClassName) exists not ].		task action: [ 			Smalltalk 				at: aClassName asSymbol 				ifAbsent: [ task stop: 'Class named ', aClassName , ' does not exist.' ]  				]	]! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 11/12/2008 20:18'!file: aFileAble	^ self define: [ :task |		task target: aFileAble asFile.		task if: [ :prerequisites | task target exists not or: [ prerequisites anySatisfy: [ :each | each target mTime > self target mTime ]] ].		task action: [ task target ]		].! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 8/19/2008 18:51'!fileList: aString	^ self define: [ :task |		task target: aString.		task action: [ task target ]		].! !!SakeTask class methodsFor: 'launcher' stamp: 'kph 9/1/2008 20:23'!launchFrom: launcher	^self launchWith: launcher getParameters			! !!SakeTask class methodsFor: 'launcher' stamp: 'kph 9/1/2008 20:25'!launchHelp^'run, r=taskDoSomething            run a SakeTask.'! !!SakeTask class methodsFor: 'launcher' stamp: 'kph 9/1/2008 21:01'!launchWith: params	| rs |	 	params at: 'R' ifPresent: [:v | params at: 'RUN' put: v ]. 	params at: 'RUN' ifPresent: [:v |					rs := v readStream.				[ rs atEnd ] whileFalse: [ (self perform: (rs upTo: $;) asSymbol) launch: params ].			 ].	^ true! !!SakeTask class methodsFor: 'as yet unclassified' stamp: 'kph 7/4/2008 11:07'!loopTrap		"if you instanciate lots of tasks without running them you might hit this"			(Count := (Count ifNil: [ 0 ]) + 1) > 50000 ifTrue: [ Count := 0. self error: 'dependency loop' ].! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 8/18/2008 22:10'!new	self loopTrap.			^ self basicNew initialize	"	self new id.self noop id.SakeTaskTest ruleA id."! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 4/22/2008 22:20'!noop	^ SakeTask define: [:task | ]"	self noop context"! !!SakeTask class methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 19:38'!status	^	status ifNil:[ status := Dictionary new ]! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 8/19/2008 18:51'!string: aString	(aString includes: $*) ifTrue: [ ^ self fileList: aString ].		^ aString last = $/ 		ifTrue: [ self dir: aString ]		ifFalse: [ self file: aString ]		 ! !!SakeTask class methodsFor: 'instance creation' stamp: 'kph 12/12/2008 04:10'!waypoint: aTask		"protected from being repeated by a waypoint"	^ self define: [ :task |							task if: [ ((self status at: #waypoints ifAbsentPut: [ Set new ]) includes: aTask hashParts) not ].		task action: {			aTask.						[ (self status at: #waypoints) add:  aTask hashParts  ].			 		}.		 	].! !!SakeTask methodsFor: 'comparing' stamp: 'kph 12/11/2008 15:51'!= other 	^  self class = other class and: [ self hashParts = other hashParts ]! !!SakeTask methodsFor: 'accessing' stamp: 'kph 8/19/2008 00:04'!action 	^ actionBlock ifNil: [ self defaultAction ]! !!SakeTask methodsFor: 'accessing' stamp: 'kph 8/18/2008 22:05'!action: block	actionBlock := block.! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 8/18/2008 22:06'!addAction: anAction		actionBlock isBlock ifTrue: [ actionBlock := OrderedCollection with: actionBlock ].		actionBlock add: anAction.	! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/24/2007 00:45'!addDependency: dep	priors := self dependsOn copyWith: dep! !!SakeTask methodsFor: 'ordering algorithm' stamp: 'kph 12/12/2008 05:10'!allPriorTasksInOrder	"return a collection of the dependent tasks such that when possible any dependencies of a task are ordered before that task"	"The present algorithm is simple but slow..."	| remainingTasks orderedTasks tasksToAdd |	remainingTasks := self allPriorTasksOn: Set new down: Set new. 	orderedTasks := OrderedCollection new.		"each time through this loop, add to orderedTasks any tasks whose dependencies are not in remainingTasks"	[	tasksToAdd := remainingTasks select: [ :t | t priorTasks noneSatisfy: [ :dep | (remainingTasks like: dep) ~= nil  ] ].		tasksToAdd isEmpty not	] whileTrue: [		orderedTasks addAll: tasksToAdd.		remainingTasks := remainingTasks difference: tasksToAdd ].		orderedTasks addAll: remainingTasks.	^orderedTasks! !!SakeTask methodsFor: 'ordering algorithm' stamp: 'kph 12/12/2008 05:18'!allPriorTasksOn: aCollection down: downstream 	"recusively add to collection of all the dependant tasks "				self priorTasks do: [ :task |				(downstream includes: task) ifTrue: [ self error: 'loop' ].				aCollection add: task.				task allPriorTasksOn: aCollection down: ((downstream copy) add: task; yourself).	]. 	^ aCollection! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/23/2007 17:26'!allTasksOn: aSet	aSet add: self.			self priorTasks do: [ :task |				task allTasksOn: aSet 	]. 	^ aSet! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 1/28/2008 03:01'!answer: aString with: anAnswer	answers ifNil: [ answers := OrderedCollection new ].		answers add:  ( Array with: aString with: anAnswer )! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/22/2007 12:24'!answers	^ answers ifNil: [ #() ]! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/23/2007 15:09'!args	^ args! !!SakeTask methodsFor: 'coercion' stamp: 'kph 4/9/2008 18:56'!asTask^ self! !!SakeTask methodsFor: 'accessing' stamp: 'kph 12/7/2008 22:11'!author	^ author! !!SakeTask methodsFor: 'accessing' stamp: 'kph 12/7/2008 21:58'!author: initials	author := initials! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 1/21/2009 14:44'!author: initials during: aBlock	| tmp |		[ 			tmp := Utilities authorInitialsPerSe.		author ifNotNil: [ Utilities setAuthorInitials: initials ].		^ aBlock value.	] ensure: [ Utilities setAuthorInitials: tmp ]		! !!SakeTask methodsFor: 'signals' stamp: 'kph 4/10/2008 08:40'!confirm: aString 	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed."	SakeConfirm signal: aString! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/23/2007 13:46'!context	^ context! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 8/18/2008 08:37'!defaultAction	"nil for none"		^ nil! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 8/18/2008 22:13'!define: aBlock	^ self in: aBlock; defined; yourself	 ! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 10/2/2008 15:33'!defined	self setContext: thisContext sender sender ! !!SakeTask methodsFor: 'accessing' stamp: 'kph 12/23/2007 04:20'!dependsOn	^ priors ifNil: [ #() ]! !!SakeTask methodsFor: 'accessing' stamp: 'kph 4/10/2008 09:12'!dependsOn: aList	priors := (aList reject: [ :ea | ea isNil ]) asArray! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/14/2008 02:09'!doAction: priorTasks 	Count := 0. "reset loop trap"			self doActionStep.		result := nil.		self action isBlock ifTrue: [ 				result := self author: author during: [ self action valueWithPossibleArgument: priorTasks ].			].		(self action isKindOf: Collection) ifTrue: [ self doTasks: self action ].	self doActionEnd.	! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 8/18/2008 07:58'!doActionEnd	 self log: result. ! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 8/18/2008 00:46'!doActionStep	self step: 'Action for task: ', self name printString .! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 8/18/2008 05:14'!doTasks: list	(self tasksFromList: list) do: [ :task | result := task perform: runLevel ].	 ! !!SakeTask methodsFor: 'running' stamp: 'test 12/23/2008 15:56'!fails	 [ self run ] on: SakeStop do: [ :ex | ^ true ].		^ false! !!SakeTask methodsFor: 'being a block' stamp: 'kph 8/18/2008 23:30'!fixTemps! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/23/2007 17:31'!hasRun	^ hasRun ifNil: [ false ]! !!SakeTask methodsFor: 'comparing' stamp: 'kph 12/8/2008 22:05'!hash	^ self hashParts hash! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 22:05'!hashParts	^ { context receiver class. context selector. args }	 ! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 2/14/2009 14:28'!if: block	block isBlock ifTrue: [ block fixTemps ].	ifBlock := block.! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/22/2007 12:10'!info	^ info ifNil: [ info := SakeMeta new ]! !!SakeTask methodsFor: 'being a block' stamp: 'kph 8/18/2008 05:06'!isBlock	^ true! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 8/19/2008 18:00'!isNeeded: runPriorTasks	ifBlock ifNil: [ ^true ].		ifBlock isBlock ifTrue: [ ^ ifBlock valueWithPossibleArgument: runPriorTasks ].		"actionBlock can be a list of tasks, if they all complete, then yes its needed"	[ self doTasks: ifBlock ] on: SakeStop do: [ :ex | ^ false ].	^ true	! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 8/19/2008 02:46'!isNewerThan: timeStamp		"used for file tasks"	^ false! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 22:02'!key	^ args! !!SakeTask methodsFor: 'launcher' stamp: 'kph 9/1/2008 23:58'!launch: params	params at: 'R' ifPresent: [:v | params at: 'RUN' put: v ].	params at: 'S' ifPresent: [ :v | params at: 'STEPPING' put: v ]. 	params at: 'I' ifPresent: [ :v | params at: 'INTERACTIVELY' put: v ]. 	params at: 'Q' ifPresent: [ :v | params at: 'QUIETLY' put: v ].	params at: 'STEPPING' ifPresent: [ :v | 		v ifTrue: [ ^ self runStepping ].	].	params at: 'QUIETLY' ifPresent: [ :v | 		v ifTrue: [ ^ self runQuietly ].	].	params at: 'INTERACTIVELY' ifPresent: [ :v | 		v ifTrue: [ ^ self runInteractively ].	]. 	params at: 'LOG' ifPresent: [ :v | 		v ifTrue: [ ^ self runLogging ].	].		^ self run ! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 2/14/2009 20:07'!log: aString 	(self respondsTo: #log) ifFalse: [ ^ self ].		self log sake << aString printString << ' ' << self class name << '>>' <<< self context method selector! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 10/1/2008 04:52'!lookup: aSymbol	^ self lookup: aSymbol with: nil! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 10/1/2008 04:51'!lookup: aSymbol with: value	^ (SakeSignal new tag: self; lookup: aSymbol; yourself) signal: value! !!SakeTask methodsFor: 'accessing' stamp: 'kph 1/21/2009 15:10'!not	| r |	^ self class define: [ :task |		task action: [ 						r := false.						[ self perform: task runLevel ] on: SakeStop do: [r := true ].					r ifFalse: [ SakeStop signal: '"not" task succeeded' ].						r			].	].! !!SakeTask methodsFor: 'printing' stamp: 'kph 4/10/2008 03:17'!printOn: stream		stream  		nextPutAll: context asString;		print: args		 ! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/23/2007 04:21'!priorTasks	^ self dependsOn collect: [ :prior | (self taskFrom: prior) withExtensions ]! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 6/3/2008 19:46'!priorTasksNilForErrors	^ self dependsOn collect: [ :prior | [(self taskFrom: prior) withExtensions ] ifError: [ nil ] ]! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 2/14/2009 17:51'!privateRun: setOfTasks 	"this is the way that Rake orders tasks"		"we ensure that we obtain the task to run from the overall set of tasks"	| priorTasks |		self hasRun ifTrue: [ ^ result ].			priorTasks := self dependsOn collect: [ :prior | setOfTasks like: (self taskFrom: prior) ].		priorTasks collect: [ :each | 		each ifNotNil: [ each runLevel: runLevel. 		each privateRun: setOfTasks ]].		(self isNeeded: priorTasks) 		ifTrue: [ 			self trace. 			self doAction: priorTasks.			hasRun := true.			 			^ result.		].		^ false! !!SakeTask methodsFor: 'accessing' stamp: 'kph 10/1/2008 05:30'!result	^ result! !!SakeTask methodsFor: 'running' stamp: 'kph 4/20/2008 03:39'!run	runLevel ifNil: [ runLevel := #run ].		^ [ self runStepping ] on: SakeStep do: [ :ex | ex resume: true ]! !!SakeTask methodsFor: 'running' stamp: 'kph 2/14/2009 17:53'!runInteractively	runLevel ifNil: [ runLevel := #runInteractively ].	^ self privateRun: (self withAllPriorTasks)! !!SakeTask methodsFor: 'accessing' stamp: 'kph 1/21/2009 14:28'!runLevel	^ runLevel! !!SakeTask methodsFor: 'accessing' stamp: 'kph 4/20/2008 05:19'!runLevel: runSelector 	runLevel := runSelector! !!SakeTask methodsFor: 'running' stamp: 'kph 8/18/2008 07:57'!runLogging	runLevel ifNil: [ runLevel := #runLogging ].	^ [ self runQuietly ] on: SakeStop, Warning do: [ :ex | self log: ex printString ] ! !!SakeTask methodsFor: 'running' stamp: 'kph 7/8/2008 18:04'!runLoggingErrors	runLevel ifNil: [ runLevel := #runLoggingErrors ].	^ [ self runQuietly ] on: SakeStop, Warning, Error do: [ :ex | self log sake <<< ex ] ! !!SakeTask methodsFor: 'running' stamp: 'kph 4/20/2008 03:40'!runQuietly	runLevel ifNil: [ runLevel := #runQuietly ].	^ [ self run ] on: SakeConfirm do: [ :ex | ex resume: true  ] ! !!SakeTask methodsFor: 'running' stamp: 'kph 4/22/2008 19:40'!runStepping	runLevel ifNil: [ runLevel := #runStepping ].	^  self withAnswersDo: [ self runInteractively ]! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/23/2007 15:05'!setContext: definingMethodContext	context := definingMethodContext.	args := Array new: context method numArgs.	1 to: args size do: [ :i | args at: i put: (context tempAt: i) ].! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/12/2008 05:16'!sort	"if your top level is a collection of tasks we presort them"			actionBlock ifNotNil: [ self error: 'no need to presort' ].	actionBlock := self allPriorTasksInOrder.	priors := nil.		^ self! !!SakeTask methodsFor: 'signals' stamp: 'kph 12/9/2008 17:10'!statusAt: key hasChanged: val	^ self class status in: [ :s | (s at: key ifAbsent: nil) ~= (s at: key put: val) ]! !!SakeTask methodsFor: 'signals' stamp: 'kph 4/10/2008 08:39'!step: aString 	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed."	SakeStep signal: aString! !!SakeTask methodsFor: 'signals' stamp: 'kph 12/24/2007 01:17'!stop: reason	^ SakeStop signal: 'Sake stop: ', reason! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 8/19/2008 18:50'!target	 	^ target! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 8/19/2008 18:48'!target: t	 	target := t! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 22:10'!taskFrom: aDependent	| task |		task := aDependent isString 		ifTrue: [ self class string: aDependent ]		ifFalse: [ aDependent asTask ].			task author ifNil: [ task author: self author ].		^ task! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 21:55'!tasksFromList: list 			 	^ (list ifNil: [ ^ #()]) collect: [ :task | (self taskFrom: task) withExtensions ]	 	 ! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 10/1/2008 05:10'!trace	^ self trace: context asString! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 10/1/2008 05:04'!trace: aMessage	^ (SakeSignal new tag: self; lookup: #traceAction: ; yourself) signal: aMessage ! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 10/1/2008 05:04'!traceAction: aMessage	"default behaviour"! !!SakeTask methodsFor: 'being a block' stamp: 'kph 8/18/2008 05:06'!value	^ self run! !!SakeTask methodsFor: 'being a block' stamp: 'kph 8/19/2008 18:07'!valueWithPossibleArgument: arg	^ self run! !!SakeTask methodsFor: 'coercion' stamp: 'kph 8/18/2008 23:57'!what	| what |	what := SakeWhat new.		what task: self.		ifBlock ifNotNil: [		( ifBlock isBlock ) 			ifTrue: [ what if: ifBlock decompileString ]			ifFalse: [ 				what if: ((self tasksFromList: ifBlock) collect: [ :ea | ea what ]).			]. 	]. 	what prior: (self priorTasks collect: [ :ea | ea what ]).	(self action respondsTo: #decompileString) 		ifTrue: [ what action: self action decompileString ]		ifFalse: [ 			what action: ((self tasksFromList: self action) collect: [ :ea | ea what ]).		].		^ what! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 6/7/2008 00:39'!withAllPriorTasks	| tasks |		tasks := Set new.		self withAllPriorTasksDo: [ :each | tasks add: each ].		^ tasks! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 6/3/2008 18:49'!withAllPriorTasksDo: aBlock	aBlock value: self.			self priorTasks do: [ :task |				task withAllPriorTasksDo: aBlock 	]. ! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 6/3/2008 19:47'!withAllPriorTasksIgnoringErrorsDo: aBlock	aBlock value: self.			self priorTasksNilForErrors do: [ :task |		task ifNotNil: [ task withAllPriorTasksIgnoringErrorsDo: aBlock ]	]. ! !!SakeTask methodsFor: 'accessing' stamp: 'kph 12/24/2007 02:24'!withAnswersDo: aBlock 	(aBlock respondsTo: #valueSuppressingMessages:supplyingAnswers: )		ifTrue: [ ^ aBlock valueSuppressingMessages: #() supplyingAnswers: self answers.]		ifFalse: [ ^ aBlock value ]! !!SakeTask methodsFor: 'as yet unclassified' stamp: 'kph 12/23/2007 15:06'!withExtensions	"extensions ruleA can have extenstions #ruleAMyPackageExt: #ruleBYourPackageExt; i.e. same selector prefix taking one argument.	ruleCopy: a to: b can have extensions #ruleCopy: a to: b myPackageExt: task and #ruleCopy: a to: b yourPackageExt: task"	| extensions prefix |	"are we class side"	context receiver class isMeta ifFalse: [ ^ self ].	prefix := context selector copyUpTo: $:.		extensions := (context receiver class allSelectorsBelow: ProtoObject class) 		select: [ :selector | (selector beginsWith: prefix) and: [ #('ext:' 'Ext:') includes: (selector last: 4) ] ].  	^ extensions inject: self into: [ :task :each |  		context receiver perform: each withArguments: (args copyWith: task) ]! !!SakeWhat methodsFor: 'accessing' stamp: 'damiencassou 12/23/2008 08:25'!action	^ action! !!SakeWhat methodsFor: 'accessing' stamp: 'damiencassou 12/23/2008 08:24'!action: anObject	action := anObject! !!SakeWhat methodsFor: 'accessing' stamp: 'damiencassou 12/23/2008 08:25'!if	^ if! !!SakeWhat methodsFor: 'accessing' stamp: 'damiencassou 12/23/2008 08:24'!if: anObject	if := anObject! !!SakeWhat methodsFor: 'printing' stamp: 'kph 4/24/2008 18:33'!printOn: stream	task printOn: stream! !!SakeWhat methodsFor: 'accessing' stamp: 'damiencassou 12/23/2008 08:25'!prior	^ prior ! !!SakeWhat methodsFor: 'accessing' stamp: 'damiencassou 12/23/2008 08:24'!prior: anObject	prior := anObject! !!SakeWhat methodsFor: 'accessing' stamp: 'damiencassou 12/23/2008 08:25'!task	^ task! !!SakeWhat methodsFor: 'accessing' stamp: 'damiencassou 12/23/2008 08:24'!task: anObject	task := anObject! !!SakeMeta methodsFor: 'accessing' stamp: 'damiencassou 12/23/2008 08:27'!at: key put: value		self at: key ifAbsent: [ order add: key ].	^ super at: key put: value.	! !!SakeMeta methodsFor: 'error handling' stamp: 'kph 7/3/2008 00:41'!doesNotUnderstand: aMessage	aMessage selector isUnary ifTrue: [ ^ self at: aMessage selector ifAbsent: [ nil ] ].		aMessage selector keywords with: aMessage arguments do: [ :key :value |		self at: key allButLast put: value	].		^ self	  ! !!SakeMeta methodsFor: 'initialize-release' stamp: 'kph 12/17/2008 22:30'!initialize	super initialize.	order := OrderedCollection new.! !!SakeMeta methodsFor: 'private' stamp: 'kph 12/17/2008 22:39'!initialize: n	super initialize: n.	order := OrderedCollection new.! !!SakeMeta methodsFor: 'testing' stamp: 'kph 1/28/2008 14:36'!name ^ self at: #name! !!SakeMeta methodsFor: 'accessing' stamp: 'kph 12/17/2008 22:34'!order	^ order! !!SakeMeta methodsFor: 'printing' stamp: 'kph 2/16/2009 00:45'!printOn: aStream	"writes metadata in a user readable format"	self withIndexDo: [ :value :key | 			aStream				nextPutAll: key;				nextPutAll: ': ';				store: value ;				cr]! !!SakeMeta methodsFor: 'removing' stamp: 'kph 12/17/2008 22:36'!removeKey: key		super removeKey: key.	order remove: key.! !!SakeMeta methodsFor: 'printing' stamp: 'kph 2/16/2009 00:31'!storeOn: aStream	"writes metadata in a user readable format"	| noneYet |	aStream nextPutAll: '('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' new'; cr.	noneYet := true.	self withIndexDo: [ :value :key | 			noneYet				ifTrue: [noneYet := false]				ifFalse: [aStream nextPut: $;; cr].			aStream nextPutAll: ' at: '.			aStream store: key.			aStream nextPutAll: ' put: '.			aStream store: value.			].	noneYet ifFalse: [aStream nextPut: $;; cr; nextPutAll: 'yourself'].	aStream nextPut: $)! !!SakeMeta methodsFor: 'enumerating' stamp: 'kph 12/17/2008 22:36'!withIndexDo: aBlock	"use the order for readable printing"		order do: [ :key |  aBlock value: (self at: key) value: key ]! !!SakeCompiler commentStamp: 'kph 10/2/2008 01:29' prior: 0!Enables methods to include raw uncompiled text for documentation purposes following a line containing 6 quotes """"""!!SakeTask commentStamp: 'kph 4/22/2008 22:42' prior: 0!SakeTasks are typically defined as class side methods, which return an instance of SakeTask.To obtain a list of available tasks, do "Senders of #define: "MyClass-task1: aParameter	^ SakeTask define: [ :task |		 	task dependsOn: {self ruleL3.}.			task if: [ <return true if action is needed> ].	     	task action: [ <do something> ]	  ]The 'unique id' of a task is the method context in which it is instanciated, and its paramters.Therefore only one task should be instanciated per method.Note: Sake tasks can have parameters, Rake tasks dont.To execute a task...(MyClass task1: 'param') run.Results of the prior tasks are available via #results.FAQ====How can I call one Sake task from inside another task?Generally, if you want invoke one task from another task, the proper way to do that is to include the task to be invoked as a prerequisite of the task doing the invoking.For example:MyTasks-c-#taskPrimary^ SakeTask define: [ :task |	task dependsOn: { self taskSecondary }.	task action: [ self log sake: 'Doing Primary Task'. ].]MyTasks-c-#taskSecondary^ SakeTask define: [ :task |	task action: [ self log sake: 'Doing Secondary Task' ].]In this case, if the secondary task fails, the whole task stops. Secondary tasks can also be passed to the ifBlock. In that case, if the task succeeds then the action is performed, if the task fails then the action is considered not needed.^ SakeTask define: [ :task |	task if: { self taskSecondary }.	task action: [ self log sake: 'Doing Primary Task'. ].]Action, can also take a list of tasks.		^ SakeTask define: [ :task |	task action: {	                 self taskSecondary. 	                 [ self log sake: 'Doing Primary Task' ].  "a block task"				} ].		!!SakeMeta commentStamp: 'damiencassou 12/23/2008 08:39' prior: 0!I'm a dictionary which can be used using any method call instead of #at:put: and at:. Use me like:- (aSakeMeta foo: 'bar') which is equivalent to (aSakeMeta at: 'foo' put: 'bar')- (aSakeMeta foo) which is equivalent to (aSakeMeta at: 'foo')The instance variable 'order' remembers the order in which the elements have been added. The methods #withIndexDo: and #printOn: use this variable to iterate in the same order.| s |s := ReadWriteStream on: String new.(self new a: 1; b: 2; yourself) storeOn: s.s reset contents!"Sake-Core"!!MCWorkingCopy methodsFor: '*sake-packages' stamp: 'test 12/23/2008 02:53'!myMenuForPackages: aMenu	(self packageInfo propertyAt: #packages) ifNotNilDo: [ :pkgName |		aMenu			add: 'load latest release using Sake/Packages' 			target: (Packages current named: pkgName) 			selector: #run.				aMenu 			add: 'load latest code using Sake/Packages' 			target: (Packages beta named: pkgName) 			selector: #run.			]. ! !!Packages class methodsFor: 'initialization' stamp: 'kph 2/18/2009 00:04'!initialize	lastUpdate := nil. 	self provided keysAndValuesDo: [ :k :v | 		| info |				(v respondsTo: #info) ifTrue: [ 						info := v info.			info dependsOn: (v dependsOn collect: [ :ea | ea asString ]).			info provides: v provides.			info class: v class name.			self provided at: k put: info.						]		]! !!Packages class methodsFor: 'public' stamp: 'kph 4/20/2008 04:22'!UUniverse	^ Smalltalk classNamed: 'UUniverse'! !!Packages class methodsFor: 'public' stamp: 'damiencassou 12/23/2008 11:21'!allPackages	^ (self allSelectorsBelow: Packages) collect: [:selector | self named: selector]! !!Packages class methodsFor: 'public' stamp: 'damiencassou 12/23/2008 11:51'!allPackagesDo: aBlock	^ (self allSelectorsBelow: Packages) do: [ :ea | aBlock value: (self named: ea) ]! !!Packages class methodsFor: 'utils' stamp: 'kph 5/26/2008 12:02'!asSelector: aName	| toUse | 	toUse := ''.	aName do:		[:char | char isAlphaNumeric ifTrue: [toUse := toUse copyWith: char]].	(aName size == 0 or: [aName first isLetter not])		ifTrue:		[toUse := 'v', toUse].	^ toUse asSymbol  ! !!Packages class methodsFor: 'private' stamp: 'kph 4/10/2008 08:11'!basicNamed: packageName		^ self basicNew perform: (self asSelector: packageName); initialize; yourself! !!Packages class methodsFor: 'public' stamp: 'kph 9/4/2008 14:16'!beta	^ PackagesBeta! !!Packages class methodsFor: 'public' stamp: 'kph 9/4/2008 14:28'!current	^ (Smalltalk classNamed: ('Packages' , SystemVersion current majorMinorVersion asLegalSelector capitalized) asSymbol) ifNil: [ Packages ]! !!Packages class methodsFor: 'public' stamp: 'kph 9/4/2008 14:25'!dev	^ PackagesDev! !!Packages class methodsFor: 'private' stamp: 'kph 9/4/2008 15:18'!findNamed: packageName 	 	| sel |		sel := self asSelector: packageName.		^ (self findPath detect: [ :ea | ea canPerform: sel ] ifNone: [ self error: 'not found' ]) basicNamed: packageName! !!Packages class methodsFor: 'private' stamp: 'test 1/2/2009 18:18'!findPath	^ { self current. self dev. Seaside29. self beta. Seaside29Beta }! !!Packages class methodsFor: 'as yet unclassified' stamp: 'kph 1/27/2008 22:56'!freeSomeSpace	self initialize! !!Packages class methodsFor: 'testing' stamp: 'kph 2/13/2009 02:50'!isBeta	^ self name endsWith: 'Beta' ! !!Packages class methodsFor: 'accessors' stamp: 'kph 12/11/2008 13:51'!isPackageProvided: aPackage	| pkgInfo |	pkgInfo := PackageOrganizer packageNamed: aPackage name ifAbsent: [ nil ].! !!Packages class methodsFor: 'testing' stamp: 'kph 1/27/2008 20:30'!isUniverse	^ self class includesSelector: #universeSelector	 ! !!Packages class methodsFor: 'accessors' stamp: 'kph 12/28/2007 19:32'!lastUpdate	^ lastUpdate ifNil: [ lastUpdate := DateAndTime now ] ! !!Packages class methodsFor: 'launcher' stamp: 'kph 7/7/2008 15:13'!launchFrom: launcher	^self launchWith: launcher getParameters! !!Packages class methodsFor: 'launcher' stamp: 'kph 11/2/2008 01:03'!launchWith: params	| packagesClass task | 		packagesClass := self current.	 	params at: 'B' ifPresent: [ :v | params at: 'BETA' put: v ]. 	params at: 'U' ifPresent: [ :v | params at: 'UNLOAD' put: v ]. 	params at: 'L' ifPresent: [ :v | params at: 'LOAD' put: v ]. 	params at: 'BETA' ifPresent: [ :v | 		v ifTrue: [ packagesClass := self beta ].	].	params at: 'LOAD' ifPresent: [ :v | 		task := packagesClass collection: (v findTokens: ';')			]. 	params at: 'UNLOAD' ifPresent: [ :v | 		task := SakeTask collection: ((v findTokens: ';') collect: [ :ea | (self named: ea) unload ])		]. 	task launch: params.		^ true! !!Packages class methodsFor: 'public' stamp: 'kph 5/16/2008 01:18'!load: aNameOrList	^ (self named: aNameOrList) run! !!Packages class methodsFor: 'public' stamp: 'kph 9/4/2008 17:05'!named: packageNameOrList		packageNameOrList isString ifTrue: [ ^ self findNamed: packageNameOrList ].		^ (packageNameOrList collect: [ :ea | self findNamed: packageNameOrList ]) asTask! !!Packages class methodsFor: 'accessors' stamp: 'kph 1/28/2008 12:06'!provided	^ Provided ifNil: [ Provided := Dictionary new ]! !!Packages class methodsFor: 'public' stamp: 'kph 4/10/2008 07:45'!providedAt: aName	^ self provided at: aName! !!Packages class methodsFor: 'public' stamp: 'kph 4/21/2008 01:27'!squeakmap	^ Smalltalk classNamed: #PackagesSqueakMap! !!Packages class methodsFor: 'public' stamp: 'kph 6/3/2008 01:11'!string: aPackageName	^ self named: aPackageName! !!Packages class methodsFor: 'tasks - universes' stamp: 'kph 4/24/2008 20:23'!taskGenerateAll ^ SakeTask define: [ :task | 	 	task dependsOn: { 		self taskGenerateAllUniverses 		 }.			task if: [ self squeakmap notNil ].		task action: { self squeakmap taskGenerateSqueakMapPackageTasks }]! !!Packages class methodsFor: 'tasks - universes' stamp: 'kph 9/4/2008 17:25'!taskGenerateAllUniverses "self taskGenerateAllUniverses run."^ SakeTask define: [ :task | 	task if: { (SakeTask class: 'UUniverse') exists }.		task action: 			(Packages allSubclasses select: [ :each | each initialize isUniverse ] thenCollect: [ :sc | sc taskGenerateUniversePackageTasks ]). 	 ]! !!Packages class methodsFor: 'accessors' stamp: 'test 12/22/2008 17:00'!taskGenerateFiles	^ lastUpdate ifNil: [ lastUpdate := DateAndTime now ] ! !!Packages class methodsFor: 'tasks - universes' stamp: 'kph 11/12/2008 16:57'!taskGenerateUniversePackageTasks| source selector |^ SakeTask define: [ :task | 		task dependsOn: { 			[ self isUniverse ].  		self taskUpdateUniverse.		self taskRemoveOldPackages.	}.	task action: [ 		(self theUUniverse packageNames collect: [ :each | self theUUniverse newestPackageNamed: each ]) do: [ :each | 			source := (WriteStream on: String new).				source << (selector := self asSelector: each name).				source cr; cr.				source << '	self name: ' << each name printString << '.' ; cr.				source << '	self version: ''' << each version << '''.' ; cr.				 									source << '	info category: ''' << each category printString << '''.' ; cr.				source << '	info description: ' ; cr.				source << each description withSqueakLineEndings printString << '.' ; cr.				source << '	info maintainer: ''' << each maintainer << '''.' ; cr.				source << '	info homepage: ''' << (each homepage ifNil: ['']) asString << '''.' ; cr.									source << '	info squeakMapID: ''' << (each squeakMapID ifNil: [''])  asString << '''.' ; cr.									source << '	info url: ' << (each url ifNotNil: [  '''' , each url printString , '''' ] ifNil: [ 'nil' ]) << '.' ; cr.									source << '	self provides: ' << each provides asArray printString << '.' ; cr ; cr.								source << '	self dependsOn: ' << each depends asSortedCollection asArray printString << '.' ; cr ; cr. 			(self sourceCodeAt: selector ifAbsent: nil)	 ~= source contents ifTrue: [								 			 				self compile: source contents classified: each category printString notifying: nil			]		].		theUUniverse := nil.	].	]! !!Packages class methodsFor: 'tasks - universes' stamp: 'kph 5/26/2008 12:03'!taskRemoveOldPackages ^ SakeTask define: [ :task | 	task dependsOn: { [ self isUniverse ]. self taskUpdateUniverse. }.			task action: [ 		(self selectors difference: 			(self theUUniverse packageNames collect: [ :each | self asSelector: each ]))			do: [ :old | self removeSelector: old ]	].	  ]! !!Packages class methodsFor: 'tasks - universes' stamp: 'kph 4/22/2008 21:35'!taskUpdateUniverse^ SakeTask define: [ :task | 		task dependsOn: { [ self isUniverse ] }.	task if: [ theUUniverse isNil or: [ DateAndTime now - self lastUpdate > 10 minutes ] ].	task action: [ 		self theUUniverse updatePackagesViaWWW. 		lastUpdate := DateAndTime now 	].	]! !!Packages class methodsFor: 'tasks - universes' stamp: 'kph 9/4/2008 17:27'!taskValidate  "self taskValidateAll run."^ SakeTask define: [ :task | 		task action:  { 	 					self taskValidateCategories }	 ]! !!Packages class methodsFor: 'tasks - universes' stamp: 'kph 9/4/2008 17:27'!taskValidateAll "self taskValidateAll run."^ SakeTask define: [ :task | 		task action: 			(Packages allSubclasses select: [ :each | each initialize isUniverse ] thenCollect: [ :sc | sc taskValidate ]). 	 ]! !!Packages class methodsFor: 'tasks - universes' stamp: 'kph 8/12/2008 22:03'!taskValidateCategories ^ SakeTask define: [ :task | 		task action: [		self selectors do: [ :sel | 			self organization classify: sel under: (((self named: sel) info category) ifNil: [ 'as yet unclassified' ])		].		self organization removeEmptyCategories. 	]]! !!Packages class methodsFor: 'accessors' stamp: 'kph 4/20/2008 16:43'!theUUniverse	^ theUUniverse 	ifNil: [ theUUniverse := (Smalltalk classNamed: 'UUniverse') perform: self universeSelector asSymbol ]! !!Packages class methodsFor: 'public' stamp: 'kph 4/20/2008 16:38'!universe	^ Smalltalk classNamed: (('Packages' , SystemVersion current majorMinorVersion asLegalSelector capitalized), 'U') asSymbol  ! !!Packages class methodsFor: 'public' stamp: 'kph 5/16/2008 01:25'!unload: aNameOrList	aNameOrList isString ifTrue: [ ^ (self providedAt: aNameOrList) unload run].		^ (aNameOrList collect: [ :ea |  (self providedAt: aNameOrList) unload ]) asTask run ! !!Packages class methodsFor: 'public' stamp: 'kph 5/16/2008 01:25'!unloadStepping: aNameOrList	aNameOrList isString ifTrue: [ ^ (self providedAt: aNameOrList) unload runStepping].		^ (aNameOrList collect: [ :ea |  (self providedAt: aNameOrList) unload ]) asTask runStepping ! !!Packages class methodsFor: 'public' stamp: 'test 12/23/2008 06:29'!update	"load the latest definitions"	Packages current load: 'Packages'.! !!Packages class methodsFor: 'public' stamp: 'kph 2/17/2009 22:03'!upgrade		self upgradeTasks run	! !!Packages class methodsFor: 'public' stamp: 'kph 2/17/2009 22:03'!upgradeList	"the list of pacakges that would be loaded by an upgrade"	Packages beta load: 'Packages'.	^ (self upgradeTasks instVarNamed: 'actionBlock') select: [ :ea | ea isNeeded: #() ] thenCollect: [ :ea | ea name ].		"	self upgradeList	"! !!Packages class methodsFor: 'public' stamp: 'kph 2/17/2009 22:48'!upgradeTasks	| list |	Packages update.		list := Set new.		self provided withIndexDo: [ :k :v |  list add: ((Smalltalk classNamed: v class) named: k) ].		^ list asTask! !!Packages methodsFor: 'comparing' stamp: 'kph 4/24/2008 17:41'!= other ^ (super = other) and: [ self version = other version ]! !!Packages methodsFor: 'accessing' stamp: 'kph 8/19/2008 00:10'!action	^ self isUnloading 		ifTrue: [ unloadBlock ifNil: [ [ self defaultUnloadAction ] ] ]		ifFalse: [ super action ].! !!Packages methodsFor: 'as yet unclassified' stamp: 'test 12/23/2008 03:08'!addToPackageInfo    "    Here we tell the PackageInfo instance what name was used to load it.   if a package appears in PackageInfo under a different name to which it    appears in Packages, the PackageInfo name can be told to us via    metadata #mcName:  Example: 'Seaside' is in PackageInfo as 'Seaside2'.       "		(self info mcName ifNil: [ self name ]) ifNotNilDo: [ :mcName |		(PackageOrganizer default packageNamed: mcName ifAbsent: [ ^ self ])			in: [ :pkgInfo |				(pkgInfo respondsTo: #propertyAt:put:)					ifTrue: [ pkgInfo propertyAt: #packages put: self name ].			].	]. 	! !!Packages methodsFor: 'Packages-Core' stamp: 'kph 8/19/2008 18:50'!allDependants	| list |	list := OrderedCollection new.	self provides in: [ :tgt |		self class allPackagesDo: [ :package |			package withAllPriorTasksIgnoringErrorsDo: [ :ea |				(ea dependsOn includesAnyOf: tgt) ifTrue: [ (list includes: package) ifFalse: [ list add: package ] ].			] 			]	].	^ list	"String streamContents: [ :str | (Packages current named:'Seaside') allDependants do: [ :ea | str << ea info name << String cr << ea info description << String cr << '======='; cr ] ]"! !!Packages methodsFor: 'as yet unclassified' stamp: 'kph 8/18/2008 01:07'!beUnloading	isUnload := true.	hasRun := false.! !!Packages methodsFor: 'defaults' stamp: 'kph 2/11/2009 20:15'!defaultAction	^ [ self info url ifNotNilDo: [ :url |  (Installer fromUrl: url) install  ] ]! !!Packages methodsFor: 'defaults' stamp: 'kph 2/13/2009 06:35'!defaultUnloadAction	Installer mc unload: (self info mcName ifNil: [ self name])! !!Packages methodsFor: 'as yet unclassified' stamp: 'kph 8/18/2008 01:14'!dependsOn	self isUnloading ifFalse: [ ^ super dependsOn ].		unloadPriors ifNil: [ self unloadDependsOn: self loadedDependantsUnloadTasks ].		^ unloadPriors! !!Packages methodsFor: 'as yet unclassified' stamp: 'kph 2/17/2009 22:18'!doActionEnd	self isUnloading ifTrue: [ ^ self ].		self class provided in: [ :reg |		info dependsOn: (self dependsOn collect: [ :ea | ea asString ]).		info provides: self provides.		info class: self class name.		self provides do: [ :each | reg at: each put: info ].	].	"if a package appears in Packages under an obscure name, it can	tell the PackageInfo instance what name was used to load it via metadata	at mcName"		self addToPackageInfo.	! !!Packages methodsFor: 'as yet unclassified' stamp: 'kph 9/2/2008 02:36'!doActionStep	name ifNil: [ ^ self ].			 self isUnloading 		ifTrue: [ self step: 'Confirm unload: ', self name printString ]		ifFalse: [ self step: 'Confirm load: ', self name printString ]! !!Packages methodsFor: 'comparing' stamp: 'damiencassou 12/11/2008 14:33'!hash	^ super hash bitXor: self version hash! !!Packages methodsFor: 'comparing' stamp: 'kph 2/13/2009 03:02'!isAlreadyProvided	(self class isBeta or: [ self version last = $+ ]) ifTrue: [ ^ false ]. "means the package is being loaded without specifying any fixed version"	^ (self class provided at: self name ifAbsent: [ ^ false ]) version = self version! !!Packages methodsFor: 'testing' stamp: 'kph 2/13/2009 06:32'!isNeeded: priorTasks	(self isUnloading not and: [ self isAlreadyProvided ]) ifTrue: [ ^ false ].	^ super isNeeded: priorTasks! !!Packages methodsFor: 'testing' stamp: 'kph 8/18/2008 00:56'!isUnloading	^ isUnload = true! !!Packages methodsFor: 'initialize' stamp: 'kph 4/9/2008 06:10'!load: aBlock	self action: aBlock! !!Packages methodsFor: 'as yet unclassified' stamp: 'kph 6/3/2008 18:10'!loadedDependants	^ self class provided select: [ :dependant  | 		 dependant dependsOn includesAnyOf: self provides.	].! !!Packages methodsFor: 'as yet unclassified' stamp: 'kph 8/18/2008 01:07'!loadedDependantsUnloadTasks	"if the task is the provided one, then we return the provided dependants."		self loadedDependants in: [ :deps |			deps ifEmpty: [ ^ #() ].		 	^ (self class provided at: self name ifAbsent: nil) == self			ifTrue: [ (deps collect: [ :ea | ea copy beUnloading ]) ]			ifFalse: [ (deps collect: [ : ea | (self class named: ea name) beUnloading ]) ]	].! !!Packages methodsFor: 'accessing' stamp: 'damiencassou 12/23/2008 14:00'!longDescription	^ self info printString! !!Packages methodsFor: 'accessing' stamp: 'kph 9/2/2008 02:35'!name	^ name ifNil: [ 'No Name' ]! !!Packages methodsFor: 'accessing' stamp: 'kph 4/24/2008 20:15'!name: aPackageName	"the method which names us is our context"	self setContext: thisContext sender.	name := aPackageName.	self info name: aPackageName.! !!Packages methodsFor: 'accessing' stamp: 'kph 4/21/2008 01:34'!provides	provides ifNil: [ provides := #() ].				(provides includes: self name) ifFalse: [ provides := provides copyWith: self name ].	^ provides! !!Packages methodsFor: 'accessing' stamp: 'kph 4/10/2008 07:36'!provides: list	provides := list.	(list includes: self name) ifFalse: [ provides := provides copyWith: self name ].! !!Packages methodsFor: 'accessing' stamp: 'kph 4/10/2008 08:16'!unload	^ self copy beUnloading ! !!Packages methodsFor: 'accessing' stamp: 'kph 4/9/2008 05:33'!unload: aBlock	unloadBlock := aBlock! !!Packages methodsFor: 'as yet unclassified' stamp: 'kph 4/10/2008 09:12'!unloadDependsOn: aList	unloadPriors := aList reject: [ :ea | ea isNil ]	! !!Packages methodsFor: 'accessing' stamp: 'kph 7/7/2008 19:59'!version	^ version! !!Packages methodsFor: 'accessing' stamp: 'kph 7/7/2008 16:19'!version: aPackageVersion	"the method which versions us is our context"	self setContext: thisContext sender. 	self info version: aPackageVersion.	version := aPackageVersion.! !!Packages commentStamp: 'test 1/17/2009 00:22' prior: 0!Sake/Packages usage:Public API============Package definition for your current version of Squeak are found using the following path.For SystemVersion Squeak3.7Packages findPath  -> {PackagesSqueak37 . PackagesDev . PackagesBeta} *the default is #currentPackages current findPath  -> {PackagesSqueak37 . PackagesDev . PackagesBeta}Packages dev findPath  {PackagesDev. PackagesSqueak37 . PackagesBeta}Packages beta findPath {PackagesBeta . PackagesSqueak37 . PackagesDev}Packages current load: 'Seaside'.Packages beta load: 'Seaside'.or(Packages current named: 'Seaside') run.  " or runQuietly, runStepping, runLogging"(Packages beta named: 'Seaside') run.multiples:Packages current load: #('Seaside' 'Magma' 'Logging')  Run-variants=========#runStepping , - presents a confirm/debug dialog before each action.#run                 - default.#runQuietly     - auto-confirms any SakeConfirm dialogs.#runLogging    - Writes any SakeStop warnings to self log.Unloading========Unloading comes in two variants.Each package task loaded by Sake/Packages is remembered in the 'provided' listIf you perform:    Packages unload: 'Seaside' .    Packages unloadStepping: 'Seaside' .Then the 'historical' unload scripts are used, as defined when the original load tasks were run.If instead you perform:    (Packages current named: 'Seaside') unload runStepping. Then the most recently defined unload script will be run.Note: If packages such as "Magma server" and "Magma client" provides "Magma", then    Packages unload: 'Magma'.Will unload whichever of the two are loaded.===Misc notes...Universes are using 'instance side' task definition, so the task extensions mechanism does not work in this context.If a package appears in Packages under an obscure name, it cantell the PackageInfo instance what name was used to load it via metadataat mcName:If a package has a version number with a '+' after it, then 'Packages upgrade' will always attempt to load the latest code, leaving Monticello to determing if there are any code changed that need to be applied.To generate all of the methods based upon universes definitions:	 	Packages taskGenerateAllUniverses run.	or	Packages taskGenerateAll  run.!"Sake-Packages"!!PackagesAll methodsFor: 'kernel' stamp: 'damiencassou 12/23/2008 11:25'!KernelTracer	self name: 'Kernel-Tracer'.	self info url: 'http://www.squeaksource.com/311/Kernel-Tracer'.	self unload: 		[ Installer mc 			project: '311' ; 			package: 'Kernel-Tracer';			install;			unload ].	 	! !!PackagesAll methodsFor: 'as yet unclassified' stamp: 'kph 12/2/2008 06:45'!LevelPlayingField	self name: 'LevelPlayingField'.	"version number tracks MC"	self version: '1.5.502+'.	info description: 'Load all squeak versions to a common level of tools'.	info author: 'keith_hodges@yahoo.co.uk'.	info owner: 'Keith Hodges'.	 	self dependsOn: { 'Monticello15' }.	self unload: [		self error: 'not presently unloadable'.	].! !!PackagesAll methodsFor: 'as yet unclassified' stamp: 'kph 12/2/2008 07:02'!SqueakMap2base	self name: 'SqueakMap2base'.	self version: '1.86+'.	info category: 'Group Development'.	info description: 'The new SqueakMap with lots of good stuff. :)'.	info maintainer: 'goran'.	info homepage: 'http://map.squeak.org'.		info url: 'http://squeak.krampe.se/SMBase-dew.86.mcz'.	self provides: #().	self dependsOn: #( ).	self load: [		Installer wsm install: 'SqueakMap2 base'.	].	self unload: [		"reclassify this method so that it is not removed - Installer uses it"		SystemVersion organization classify: #majorMinorVersion under: 'accessing'. 		Installer mc unload: 'SMBase'.	].! !!PackagesAll methodsFor: 'as yet unclassified' stamp: 'kph 12/2/2008 07:02'!SqueakMap2loader	self name: 'SqueakMap2 loader'.	self version: '1.86+'.	info category: 'Group Development'.	info description: 'This is the graphical tool called the "SqueakMap Package Loader" that can be opened from the World open... menu. This tool is a UI for the local instance of SMSqueakMap that can be accessed with "SMSqueakMap default".In the loader you can browse the map and see packages and package releases and also install them into the image. '.	info maintainer: 'goran'.	info homepage: 'http://map.squeak.org'.		info url: 'http://squeak.krampe.se/SMLoader-btr.55.mcz'.	self provides: #().	self dependsOn: #(  'SqueakMap2 base' ).	self load: [		Installer wsm install: 'SqueakMap2 loader'.	].	self unload: [		Smalltalk at: #SMLoader ifPresent: [ :c | c unload ].		Flaps reinstateDefaultFlaps.		Installer mc unload: 'SMLoader'.	].! !!PackagesAll methodsFor: 'as yet unclassified' stamp: 'kph 12/2/2008 07:02'!SqueakMap2server	self name: 'SqueakMap2 server'.	self version: '0.9+'.	info description: 'The server package for SqueakMap2. Mainly a web UI built using HttpView.'.	info author: 'Göran Krampe <goran@krampe.se>'.	info owner: 'Göran Krampe'.	info created: '18 September 2003 12:19:06 pm'.	info updated: '10 October 2005 6:29:15 pm'.	 	self dependsOn: { 'SqueakMap2 base' }.	self load: [		Installer wsm install: 'SqueakMap2 server'.	].	self unload: [		Installer mc unload: 'SqueakMap2 server'.	].! !!PackagesBeta class methodsFor: 'as yet unclassified' stamp: 'test 1/2/2009 18:18'!findPath ^ { self beta. Seaside29Beta. self current. self dev. }  ! !!PackagesBeta methodsFor: 'Group Development' stamp: 'kph 12/8/2008 10:08'!KernelExtensions 		self name: 'Kernel-Extensions'. 	self version: '1+'.	info description: 'Extensions for the kernel'.	info author: 'keith_hodges@yahoo.co.uk'.	 		self dependsOn: { 'Null' }.	 	self load: [		 Installer squeaksource project: '311'; 			install: 'Kernel-Extensions'.	].		! !!PackagesBeta methodsFor: 'Web Development' stamp: 'kph 7/7/2008 03:39'!NiftyCorners    self name: 'NiftyCorners'.    info category: 'Web Development'.    info description: 'NiftyCornersCube Javascript library for use with Seaside'.    info maintainer: 'kph'.    info homepage: 'http://www.squeaksource.com/Jetsam.html'.	"the js library is licenced GPL, for GPL read can of worms"		info licence: 'GPL'.    self version: '2.8.1+'.    self provides: #().    self dependsOn: #('Seaside').    self load: [        Installer squeaksource project:'Jetsam' ; install: 'Seaside28Jetsam'.    ].    self unload: [        Installer mc unload: 'Seaside28Jetsam-NiftyCorners'.    ].! !!PackagesBeta methodsFor: 'Group Development' stamp: 'kph 12/12/2008 01:43'!Packages 		self name: 'Packages'. 	self version: '1+'.	info description: 'Package definitions for this version of squeak'.	info author: 'keith_hodges@yahoo.co.uk'.	info owner: 'Keith Hodges'.	 	self dependsOn: { 'Sake-Packages' }.	"implemented as a block, since we are self destucting"	self unload: [  		Installer mc unload: 'Packages-Library'.		Installer mc unload: 'Sake-Packages'.	].					! !!PackagesBeta methodsFor: 'Group Development' stamp: 'kph 12/12/2008 01:52'!PackagesLibrary 		super PackagesLibrary	info description: 'Package definitions for this version of squeak'.	info author: 'keith_hodges@yahoo.co.uk'.	info owner: 'Keith Hodges'.	 	self dependsOn: { 'Sake-Packages' }.	"implemented as a block, since we are self destucting"	self unload: [  		Installer mc unload: 'Packages-Library'.		Installer mc unload: 'Sake-Packages'.	].					! !!PackagesBeta methodsFor: 'Group Development' stamp: 'kph 12/12/2008 05:03'!Sake 	super Sake.		self info mcName: 'Sake-Core'.	 	self unload: [		"I doubt if Sake can be removed while running Sake"		[ Installer mc unload: 'Sake-Core' ] fork.	].					! !!PackagesBeta methodsFor: 'Web Development' stamp: 'test 12/23/2008 02:41'!Seaside     super Seaside.	self version: self version, '+'.	self info mcName: 'Seaside2'.		self load: [         Installer squeaksource			project: 'Seaside';			install: #('Seaside2.8a1-lr' 'Seaside2.8a1-pmm').		     ].    ! !!PackagesBeta methodsFor: 'Group Development' stamp: 'kph 12/8/2008 02:22'!Squeakdevimage	self name: 'Squeak-dev image'.	self version: '0.167'.	info category: 'Squeak Distributions'.	info description: 'This package creates a squeak image made for developers. If you update a squeak-dev image, you can execute ''DEVImageCreator default install''.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://damien.cassou.free.fr/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ImageForDevelopers/ImageForDevelopers-dc.167.mcz'.	self provides: #().	self dependsOn: #('Polymorph TaskbarIcons' 'Polymorph ToolBuilder' 'Polymorph Tools Diff' 'Squeak dev packages').! !!PackagesBeta methodsFor: 'Web Development' stamp: 'kph 12/8/2008 02:32'!Squeakfullimage	self name: 'Squeak-full image'.	info category: 'Squeak Distributions'.	info description: 'This package has lots of packages loaded.'.	self dependsOn: #( ).! !!PackagesBeta methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 02:32'!Squeakfunimage	self name: 'Squeak-full image'.	info category: 'Squeak Distributions'.	info description: 'This package has lots of packages loaded, and things to play with'.	self dependsOn: #( 'Squeakfullimage' ).! !!PackagesBeta methodsFor: 'Web Development' stamp: 'kph 2/11/2009 20:15'!defaultAction	self version: self version, '+'.	^ [ self info url ifNotNilDo: [ :url | (Installer fromUrl: url) latest install ] ]! !!PackagesDev methodsFor: 'Web Development' stamp: 'kph 12/21/2008 21:20'!Algernon   super Algernon.	self answer: '*Would*' with: true.  ! !!PackagesDev methodsFor: 'Web Development' stamp: 'kph 12/21/2008 21:55'!Cryptography	super Cryptography.	self answer: '*pool*' with: true. ! !!PackagesDev methodsFor: 'System' stamp: 'kph 7/7/2008 03:34'!FFI    self name: 'FFI'.	self version: '3.9.1'.    info category: 'System'.    info description: 'The Squeak foreign function interface.'.    info maintainer: 'Lex Spoon <lex@lexspoon.org>'.    info homepage: 'http://wiki.squeak.org/squeak/1414'.    info squeakMapID: ''.    info url: 'http://map.squeak.org/accountbyid/cf58c358-46ee-465e-b6db-2740e9b32a53/files/InstallFFI3.st'.    self provides: #().    self dependsOn: #().    self load: [	(Installer mantis) "patch to stop NetNameResolver being broken when FFI is loaded"		bug: 6980 		fix:	'SystemDictionary-recreateSpecialObjectsArray-M6980.st'.		 	Installer installUrl:'http://map.squeak.org/accountbyid/cf58c358-46ee-465e-b6db-2740e9b32a53/files/InstallFFI3.st'.	"preamble/postscript are not run with older versions of MC1.5, so recreateSpecialObjectsArray now"	Smalltalk recreateSpecialObjectsArray    ].    self unload: [        Installer mc unload: 'FFI'.    ].! !!PackagesDev methodsFor: 'Fonts' stamp: 'kph 7/7/2008 03:34'!FreeTypePlus    self name: 'FreeType Plus'.    info category: 'Fonts'.    info description: 'Support for FreeType font system.Scans host OS for available font files, and automatically creates TextStyles.Re-scans on every image startup.'.    info maintainer: 'amtween@hotmail.com'.    info homepage: ''.    info squeakMapID: ''.    info url: 'http://map.squeak.org/accountbyid/46dcf6af-067d-43e3-9fc9-d7010e067153/files/FreeType-tween.355.mcz'.    self version: '0.5'.    self provides: #().    self dependsOn: #('FreeType Plus-plugins installer' 'FFI').    self load: [	"preamble/postscript are not run with older versions of MC1.5, so manually do the preamble now"		"add pendingKernX to CharacterScanner and MultiCharacterScanner"		Compiler evaluate: 'Object subclass: #CharacterScanner	instanceVariableNames: ''destX lastIndex xTable destY stopConditions text textStyle alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth emphasisCode kern indentationLevel wantsColumnBreaks pendingKernX''	classVariableNames: ''DefaultStopConditions NilCondition PaddedSpaceCondition SpaceCondition''	poolDictionaries: ''TextConstants''	category: ''Graphics-Text'' '.			Compiler evaluate: 'Object subclass: #MultiCharacterScanner	instanceVariableNames: ''destX lastIndex xTable destY stopConditions text textStyle alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth emphasisCode kern indentationLevel wantsColumnBreaks presentation presentationLine numOfComposition baselineY firstDestX pendingKernX''	classVariableNames: ''DefaultStopConditions NilCondition PaddedSpaceCondition SpaceCondition''	poolDictionaries: ''TextConstants''	category: ''Multilingual-Scanning'' '. 	        [Installer installUrl:'http://map.squeak.org/accountbyid/46dcf6af-067d-43e3-9fc9-d7010e067153/files/FreeType-tween.355.mcz']		on: Error do:[:e | 			(Smalltalk at: #FT2Constants) initialize.			(Smalltalk at: #FreeTypeCacheConstants) initialize.			(Smalltalk at: #FT2Handle) initialize.			(Smalltalk at: #FreeTypeFontProvider) initialize.			(Smalltalk at: #FreeTypeCache) initialize.			(Smalltalk at: #FreeTypeSettings) initialize.			(Smalltalk at: #LogicalFont) initialize.			(Smalltalk at: #FreeTypeFontProvider) current updateFromSystem]    ].    self unload: [        Installer mc unload: 'FreeType Plus'.    ].! !!PackagesDev methodsFor: 'Group Development' stamp: 'kph 12/12/2008 05:04'!Installer	self name: 'Installer'.	self info mcName: 'Installer-Core'.	self version: '4.1+'.	info category: 'Group Development'.	info description: 'Installer provides a simple Domain Specific Language for installing packages from monticello and squeakmap of various version.One design decision is to be able to paste scripts a workspace and run and tested from there without any special editing.Includes support for Package Universes'.	info maintainer: 'kph'.	info homepage: 'http://wiki.squeak.org/squeak/Installer'.  	self dependsOn: #().	self load: [		Installer upgrade.	].	self unloadDependsOn: #().	self unload: [		(MCPackage named: 'Installer-Core') workingCopy unload.	].		! !!PackagesDev methodsFor: 'Network' stamp: 'kph 12/11/2008 23:33'!KomHttpServer    super KomHttpServer.    info url: 'http://www.squeaksource.com/KomHttpServer/KomHttpServer-rjl.43.mcz'.    self version: '7.1.43a'.    self provides: #().    self dependsOn: #('KomServices').! !!PackagesDev methodsFor: 'Network' stamp: 'kph 12/11/2008 23:34'!KomServices    super KomServices.    info url: 'http://www.squeaksource.com/KomHttpServer/KomServices-gc.19.mcz'.    self version: '7.1.19a'.! !!PackagesDev methodsFor: 'Group Development' stamp: 'kph 12/12/2008 00:27'!Monticello15	super Monticello15..	self info mcName: 'Monticello.impl'.	! !!PackagesDev methodsFor: 'Group Development' stamp: 'kph 12/12/2008 00:27'!Monticello16	super Monticello16..	self info mcName: 'Monticello.impl'.	! !!PackagesDev methodsFor: 'Morphic' stamp: 'test 1/13/2009 22:31'!MorphicBooks    self name: 'MorphicBooks'.    info category: 'Morphic'.    info description: 'Unloadable version of Bookmorph and friends'.    info maintainer: 'kph'.    self version: '1'.    self info url: 'http://www.squeaksource.com/311/MorphicBooks-kph.1.mcz'.  ! !!PackagesDev methodsFor: 'Development' stamp: 'kph 12/21/2008 22:00'!Mse	super Mse.	self dependsOn: #('SmaCC runtime').! !!PackagesDev methodsFor: 'Translation' stamp: 'test 1/13/2009 15:53'!MultilingualEditor	self name: 'Multilingual-Editor'.	self version: '0.2'.	info category: 'Translation'.	info description: 'gettext support'.	info maintainer: 'm.rueger@acm.org'.	info homepage: ''.	info url: 'http://source.impara.de/aida/Multilingual-Editor-be.2.mcz'.	self dependsOn: #().! !!PackagesDev methodsFor: 'Morphic' stamp: 'kph 1/22/2009 02:32'!Nebraska    self name: 'Nebraska'.    info category: 'Morphic'.    info description: 'Nebraska load/unload'.    info maintainer: 'kph'.    self version: '14'.    self load: [	   (WorldState includesSelector: #remoteCanvasesDo:) ifTrue: [ 	   	WorldState organization classify: #remoteCanvasesDo: under: '*morphicextras-nebraska compatible'.	   ].        Installer squeaksource project: '311' ; install: 'Nebraska-kph.14'.    ].! !!PackagesDev methodsFor: 'Web Development' stamp: 'kph 12/11/2008 23:38'!NiftyCorners    self name: 'NiftyCorners'.	self info mcName: 'Seaside28Jetsam-NiftyCorners'.    info category: 'Web Development'.    info description: 'NiftyCornersCube Javascript library for use with Seaside'.    info maintainer: 'kph'.    info homepage: 'http://www.squeaksource.com/Jetsam.html'.    self version: '2.8.1'.    self provides: #().    self dependsOn: #('Seaside').    self load: [        Installer squeaksource project:'Jetsam' ; install: 'Seaside28Jetsam-NiftyCorners'.    ].! !!PackagesDev methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 11:19'!Null		super Null.		"we load it first, in case it has been recategorized"	self unload: [ 				Installer mc 			project: 'Null' ; 			package: 'Null-Core';			install;			unload ].	 	! !!PackagesDev methodsFor: 'Development' stamp: 'kph 12/21/2008 21:26'!ObjectFinder	super ObjectFinder.	self dependsOn: #('OmniBrowser-Full').! !!PackagesDev methodsFor: 'Group Development' stamp: 'kph 12/13/2008 04:03'!PackagesLibrary	super PackagesLibrary.	self version: self version, '+'.		self provides: #('Packages-Library').	self dependsOn: #('Sake-Packages').	self load: [				Installer ss project: 'Packages' ; install: 'Packages-Library'.			]! !!PackagesDev methodsFor: 'Web Development' stamp: 'kph 12/2/2008 06:32'!PierSeaside    super PierSeaside.  	self answer: '*Would*' with: true;		answer: '*Pier kernel*' with: 'Pier';		answer: '*entry point*' with: 'pier';		answer: '*Pier-Application*' with: true;		yourself! !!PackagesDev methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 11:20'!ProcessSpecific 	super ProcessSpecific.	"we load it first, in case it has been recategorized"	self unload: [ Installer mc 			project: 'Logging' ; 			package: 'ProcessSpecific';			install;			unload ].	 	! !!PackagesDev methodsFor: 'Group Development' stamp: 'kph 2/11/2009 17:37'!RemoteFrameBuffer	super RemoteFrameBuffer.	self info mcName: 'RFB'.	! !!PackagesDev methodsFor: 'Group Development' stamp: 'kph 12/12/2008 00:15'!SUnitGUIimproved	super SUnitGUIimproved.	self info mcName: 'SUnitGUI'.	! !!PackagesDev methodsFor: 'Group Development' stamp: 'kph 12/12/2008 00:15'!SUnitimproved	super SUnitimproved..	self info mcName: 'SUnit'.	! !!PackagesDev methodsFor: 'as yet unclassified' stamp: 'kph 12/2/2008 06:34'!Scheduler 	self name: 'Scheduler'.	self version: '1+'.	info description: 'Schedule Periodic Tasks'.	info author: 'John Pierce'.	 	self dependsOn: { }.	self load: [		 Installer squeaksource project: 'Scheduler'; 			install: 'Scheduler-jrp'.	]. 					! !!PackagesDev methodsFor: 'Web Development' stamp: 'test 12/23/2008 02:43'!Seaside   super Seaside.	self info mcName: 'Seaside2'.	self answer: '*config*' with: 'seaside';		answer: '*password*' with: 'admin'.		  ! !!PackagesDev methodsFor: 'Web Development' stamp: 'kph 12/2/2008 06:21'!Seaside28Jetsam    self name: 'Seaside28Jetsam'.    info category: 'Web Development'.    info description: 'Patches to the base seasideThe version number indicates the version of seaside this is synced with.'.    info maintainer: 'kph'.    info homepage: 'http://www.squeaksource.com/Jetsam.html'.    info squeakMapID: ''.    info url: 'http://www.squeaksource.com/Jetsam/Seaside28Jetsam-kph.63.mcz'.    self version: '2.8.541/63'.    self provides: #('Seaside28Jetsam').    self dependsOn: #('Seaside' 'KernelExt-kph'). ! !!PackagesDev methodsFor: 'Web Development' stamp: 'kph 12/8/2008 02:30'!Squeakminimalimage	self name: 'Squeak-minimal image'.	info category: 'Squeak Distributions'.	info description: 'This package creates a squeak image with lots of stuff removed''.'.	self dependsOn: #( (Packages beta named: 'Null') unload. (Packages beta named: 'Kernel-Tracer') unload.).! !!PackagesDev methodsFor: 'Web Development' stamp: 'kph 12/8/2008 02:23'!Squeakwebimage	self name: 'Squeak-dev image'.	self version: '0.167+'.	info category: 'Squeak Distributions'.	info description: 'This package creates a squeak image made for developers. If you update a squeak-dev image, you can execute ''DEVImageCreator default install''.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://damien.cassou.free.fr/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ImageForDevelopers/ImageForDevelopers-dc.167.mcz'.	self provides: #().	self dependsOn: #('Squeak-dev image' 'Squeak web packages').! !!PackagesDev methodsFor: 'Translation' stamp: 'test 1/13/2009 15:54'!SystemLocalization	self name: 'System-Localization'.	self version: '0.2'.	info category: 'Translation'.	info description: 'gettext support'.	info maintainer: 'm.rueger@acm.org'.	info homepage: ''.	info url: 'http://source.impara.de/aida/System-Localization-be.3.mcz'.	self dependsOn: #('Multilingual-Editor').! !!PackagesDev methodsFor: 'Group Development' stamp: 'kph 12/12/2008 00:42'!Tasks	| thisVersion sqVersion testCandidate |		self name: 'Tasks'.	self info mcName: 'Tasks-Common'.	self version: '1+'.	info description: 'Package definitions for this version of squeak'.	info author: 'keith_hodges@yahoo.co.uk'.	info owner: 'Keith Hodges'.	 	self dependsOn: { 'Sake' }.	thisVersion := 'Tasks-', (sqVersion := SystemVersion current majorMinorVersion copyWithout: $.).	testCandidate := ('ReleaseAfter', sqVersion) asSymbol.		self load: [		 Installer squeaksource project: 'Tasks'; 			install: 'Tasks-Common';			install: thisVersion. 		 		((Smalltalk classNamed: testCandidate) ifNil: [ self stop ]) releaseCandidateTasksInstaller install.		].	self unload: [		Installer mc unload: thisVersion.		Installer mc unload: 'Tasks-Common'.	].					! !!PackagesDev methodsFor: 'Network' stamp: 'kph 12/21/2008 22:04'!Telnet	super Telnet.	self answer: '*fon*' with: true.! !!PackagesDev methodsFor: 'Group Development' stamp: 'kph 12/11/2008 23:36'!TestsAll		self name: 'Tests-All'.	self version: '1+'.	info description: 'Loads/Unloads as many tests as it can find for current working packages'.	info author: 'keith_hodges@yahoo.co.uk'.	info owner: 'Keith Hodges'.	 	self load: [		MCWorkingCopy allManagers	 collect: [ :ea | 			(Installer mc mc: ea repository) install: ea packageInfo testsPackageName.		].	].	self unload: [			Installer mc unload: '*.test'.			Installer mc unload: '*Tests'.			Installer mc unload: '*Test'.			Installer mc unload: 'Tests*'.	].! !!PackagesDev methodsFor: 'Group Development' stamp: 'kph 12/11/2008 23:28'!YAXO	super YAXO.	self info mcName: 'XML-Support'.	! !!PackagesDevU class methodsFor: 'as yet unclassified' stamp: 'test 1/2/2009 18:18'!findPath ^ { self dev. self current. Seaside29. self beta. Seaside29Beta. }  ! !!PackagesDevU class methodsFor: 'as yet unclassified' stamp: 'kph 1/27/2008 22:47'!universeSelector^ #developmentUniverse! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'damiencassou 2/17/2009 18:56'!AST	self name: 'AST'.	self version: '161'.	info category: 'Model Extension'.	info description: 'The Abstract Syntax Tree of Squeak code. Used by the Refactoring Engine and NewCompiler.'.	info maintainer: 'Mathieu Suen <mathieusuen@yahoo.fr>'.	info homepage: 'http://www.squeaksource.com/AST'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/AST/AST-lr.161.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'kph 9/10/2008 10:09'!AXAnnouncements	self name: 'AXAnnouncements'.	self version: '1.0.31'.	info category: 'Model Extension'.	info description: 'Squeak implementation of Announcements Framework based on Vassili Bykov''s blog.'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://www.squeaksource.com/AXAnnouncements.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/AXAnnouncements/AXAnnouncements-ul.31.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 9/10/2008 10:09'!Aida	self name: 'Aida'.	self version: '5.6'.	info category: 'Web Development'.	info description: 'AIDA/Web is a web server and framework for complex web applications with integrated Ajax support, rich collection of web components to build web pages programatically, MVC-like separation of presentation from domain, nice looking and bookmarkable url links, with integrated session and security management and many more.What''s new in 5.6?   - class SwazooAida for easier start: just doit SwazooAida demoStart   - run on all interfaces, any host: SwazooAida startOn: somePort,     useful for running behind load balancers   - enhanced reliability and performance serving directly to     the Internet   - multilingual support for serving domain objects in many languages   - Party/Role framework for modeling complex relationships among     different parties (persons, companies). Useful among other for more     complex security scenarios   - upgrade to Prototye 1.6.0, Scriptaculous 1.8.0   - more understandable reorganization of packages'.	info maintainer: 'mivsek'.	info homepage: 'http://www.aidaweb.si/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Aida/Aida-5.6.mcz'.	self provides: #().	self dependsOn: #('Swazoo').! !!PackagesDevU methodsFor: 'IDE' stamp: 'kph 9/10/2008 10:09'!Algernon	self name: 'Algernon'.	self version: '1.2'.	info category: 'IDE'.	info description: 'Algernon is a productivity tool for Squeak programmers; your personal assistant for Squeak. It is a launcher and quick way to access any class. Press Shift-Return to bring up the text box. Start typing a class name, a morph''s name, a category, an object, global variable, or any valid smalltalk expression (prefixed with "=" ) to have quick access or print the results. Algernon aims to make programming in Squeak faster and more keyboard centric.Version 1.2 fixes performance problems encountered in 1.1.Usage: Press Shift-Return to start.'.	info maintainer: 'Joey Hagedorn<joey@joeyhagedorn.com>'.	info homepage: 'http://www.squeaksource.com/Algernon.html'.	info squeakMapID: ''.	info url: 'http://www.joeyhagedorn.com/media/downloads/Algernon.1.2.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'kph 9/10/2008 10:09'!Announcements	self name: 'Announcements'.	self version: '0.7'.	info category: 'Model Extension'.	info description: ''.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://mc.lukas-renggli.ch/announcements/'.	info squeakMapID: ''.	info url: 'http://mc.lukas-renggli.ch/announcements/Announcements-lr.7.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Data Structures' stamp: 'kph 9/10/2008 10:09'!Array2D	self name: 'Array2D'.	self version: '1'.	info category: 'Data Structures'.	info description: 'A simple 2D-Array implementation. Neither storing nor sorting (otherwise inherited from ArrayedCollection) will work. Neither comparing nor most accessing mehods inherited from Sequenceable collection will work.  Actually, it''s a bad idea to inherit this class from collection at all!!!!!!This used to be part of the image. This SqueakMap package is providedfor backward-compatibility.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Array2D-md.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 9/10/2008 10:09'!AutomaticMethodCategorizer	self name: 'AutomaticMethodCategorizer'.	self version: '0.25'.	info category: 'Code Browsing'.	info description: 'This package allows you to categorize uncategorized methods based on rules.For example you can put all uncategorized methods in SomeTest  that begins with "test" under the "tests" category.See the release notes for details.Acknowledgments: The idea of method categorization based on rules was taken from a VAST tool created by Maximiliano Contieri.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: ''.	info squeakMapID: '58bb4018-276b-4fe9-8f08-228bddb19ca9'.	info url: 'http://www.squeaksource.com/autoMethodCat/AutomaticMethodCategorizer-DF.25.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 9/10/2008 10:09'!AutomaticMethodCategorizerOB	self name: 'AutomaticMethodCategorizerOB'.	self version: '0.2'.	info category: 'Code Browsing'.	info description: ''.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/autoMethodCat/AutomaticMethodCategorizerOB-DF.1.mcz'.	self provides: #().	self dependsOn: #('AutomaticMethodCategorizer' 'OmniBrowser-Full').! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 9/10/2008 10:09'!AutomaticMethodCategorizerServices	self name: 'AutomaticMethodCategorizerServices'.	self version: '0.2'.	info category: 'Code Browsing'.	info description: 'This package allows you to categorize uncategorized methods based on rules.For example you can put all uncategorized methods in SomeTest  that begins with "test" under the "tests" category.See the release notes for details.Acknowledgments: The idea of method categorization based on rules was taken from a VAST tool created by Maximiliano Contieri.The services packages plugs AutomaticMethodCategorizer with the Services framework.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/autoMethodCat/AutomaticMethodCategorizerServices-DF.2.mcz'.	self provides: #().	self dependsOn: #('AutomaticMethodCategorizer').! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!BTree	self name: 'BTree'.	self version: '49'.	info category: 'Persistence'.	info description: 'This is an implementation of the BTree data structure as a Smalltalk collection.  It provides log(n) inserts, deletes, and retrieves of values by key.  The keys have to be sortable (ie, Magnitudes).This is useful in situations where you want to minimize the number and size of individual objects that need to be accessed when using a large collection - for example, when objects are being swapped out to an object database such as GOODS.  It is probably not a good choice for a collection that will be kept entirely in memory.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/BTree/Collections-BTree-avi.49.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Graphics' stamp: 'damiencassou 1/21/2009 13:12'!Balloon3D	self name: 'Balloon-3D'.	self version: '1.1.2'.	info category: 'Graphics'.	info description: 'The NEW Balloon3D package publish with a hyphen to work around limitations of universes. Includes Balloon3D, the tutorials, and Wonderland.'.	info maintainer: 'andreas.raab@gmx.de'.	info homepage: 'http://www.squeaksource.com/Balloon3D.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Balloon3D/Balloon3D-1.1.2.mcm'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Data Structures' stamp: 'kph 9/10/2008 10:09'!BitArray	self name: 'BitArray'.	self version: '1.0'.	info category: 'Data Structures'.	info description: 'Simple implementation of BitArray, which stores the bits.For the basic random access operations for a rather shorter array, you might want to consider ByteArray.BitArray supports the conversion from/to integers.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/BitArray1.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Games' stamp: 'kph 9/10/2008 10:09'!BreakOut	self name: 'BreakOut'.	self version: '5'.	info category: 'Games'.	info description: 'I designed this breakout slowly refactoring it step by steps because it was part of a book on OOP but I''m thinking to cancel this book and putting a draft on the web. This is the final version of the breakout.The bouncing is not that good. Have fun first, then submit a fix for the ball bouncing or any new bonuses. I would like also to have bonuses falling down. '.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/BreakOut-sd.5.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'test 1/13/2009 15:56'!CassandraClient	self name: 'CassandraClient'.	self version: '1.0'.	info category: 'Persistence'.	info description: ''.	info maintainer: 'shute'.	info homepage: 'http://www.squeaksource.com/CassandraClient.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/CassandraClient/CassandraClient-shute.2.mcz'.	self provides: #('CassandraClient').	self dependsOn: #('Thrift').! !!PackagesDevU methodsFor: 'Constraints' stamp: 'kph 9/10/2008 10:09'!Cassowary	self name: 'Cassowary'.	self version: '0.60'.	info category: 'Constraints'.	info description: 'This is a port of the Smalltalk version of Cassowary 0.60.  As the original authors put it, ''Cassowary is an incremental constraint solving toolkit that efficiently solves systems of linear equalities and inequalities.''.  More information can be found at:http://www.cs.washington.edu/research/constraints/cassowary/'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Cassowary.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!Celeste	self name: 'Celeste'.	self version: '2.21'.	info category: 'Network'.	info description: 'A POP-based email reader.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/1467'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Celeste/Network-Mail%20Reader-ls.21.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'kph 9/10/2008 10:09'!ClassSelectorSets	self name: 'ClassSelectorSets'.	self version: '1'.	info category: 'Model Extension'.	info description: 'Regroup methods on Behavior, Class, Trait... which provide browsing helpful functionalities like conflicting selectors, overriding selectors...'.	info maintainer: 'Damien Cassou'.	info homepage: 'http://www.squeaksource.com/ClassSelectorSets.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ClassSelectorSets/ClassSelectorSets-dc.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 11/2/2008 00:30'!Comet	self name: 'Comet'.	self version: '2.8.3.28'.	info category: 'Web Development'.	info description: 'High-level Comet bindings for the Seaside web application framework.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Seaside/Comet-lr.28.mcz'.	self provides: #().	self dependsOn: #('Scriptaculous').! !!PackagesDevU methodsFor: 'System' stamp: 'kph 11/28/2008 16:26'!CommandShell	self name: 'CommandShell'.	self version: '4.3'.	info category: 'System'.	info description: 'CommandShell is a Smalltalk simulation of a Unix command shell, with a simple dumb terminal window in Morphic and MVC. It is useful for running programs without leaving Squeak, and for piping command output directly into Squeak. Can be loaded and run on any platform, but is most useful on Unix, Linux and Windows systems with OSProcess. On Windows, command pipelines are not yet implemented for external commands, but you can run Windows programs from the CommandShell "Squeak shell" as well as pipelines with internal shell commands. A simple script processing capability is also included.The ExternalCommandShell allows Squeak to be used directly as a Unix shell, similar to /bin/sh but with access to Smalltalk expressions and the Squeak object environment. To initiate external shell processing, evaluate "ExternalCommandShell start". The image can be saved and restarted with "squeak -headless myImage" to run it as a headless Squeak shell. See the class comments in ExternalCommandShell for more information.'.	info maintainer: 'dtl'.	info homepage: 'http://wiki.squeak.org/squeak/1914'.	info squeakMapID: ''.	info url: 'http://wiki.squeak.org/squeak/uploads/1914/CommandShellV4-3.sar'.	self provides: #().	self dependsOn: #('OSProcess').! !!PackagesDevU methodsFor: 'Constraints' stamp: 'kph 9/10/2008 10:09'!Connectors	self name: 'Connectors'.	self version: '2.3-187'.	info category: 'Constraints'.	info description: 'Connectors is an application for making structured/connected drawings in Morphic. It adds a new kind of Morph (NCConnectorMorph) that can connect other Morphs together (and stay connected). There are also a number of other shapes, flaps, and tools for making your own drawings.It comes with some sample shapes in flaps for making UML class diagram and state diagrams.It''s also a framework for making your own structured drawing editors. There is an easy to use API for querying drawing structure, constructing drawings, and more.'.	info maintainer: 'ls'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/1773'.	info squeakMapID: ''.	info url: 'http://map.squeak.org/accountbyid/092daeeb-7a37-427f-8afb-66bf2db74f98/files/ConnectorsFor3.8-187.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Cryptography	self name: 'Cryptography'.	self version: '0.3'.	info category: 'Uncategorized'.	info description: 'The cryptography package provides some basic cryptographic algorithms andprotocols. This change set integrates algorithms implemented by several members of the Squeak community, including Leandro Caniglia, John Maloney,Duane Maxwell, Luciano Notarfrancesco and Carlos Sarraute. There isn''t muchdocumentation, but browsing the tests (CryptoTest) will give you a pretty goodidea of how to use it.This package includes:  - Symmetric key algorithms: DES, 3DES, AES (Rijndael), ARC4  - Block cipher modes: CBC, CFB, OFB  - Hash functions: MD4, MD5, SHA1  - Public key algorithms: DSA, ElGamal, RSA  - Other stuff: HMACs, Diffie-Hellman, a random pool, a secure prng, a primes finder'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Cryptography.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'System' stamp: 'kph 9/10/2008 10:09'!CryptographyTeamPackage	self name: 'Cryptography Team Package'.	self version: '1.1'.	info category: 'System'.	info description: ''.	info maintainer: 'rww'.	info homepage: 'http://www.squeaksource.com/Cryptography.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Cryptography/Cryptography-rww.5.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Mathematics' stamp: 'kph 9/10/2008 10:09'!DHBNumericalAnalysis	self name: 'DHB Numerical Analysis'.	self version: '1.0'.	info category: 'Mathematics'.	info description: 'Smalltalk numerical analysis codes based on Didier Besset''s '.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/DHBSqueakNumerical-1.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!DNSClient	self name: 'DNS Client'.	self version: '1.1'.	info category: 'Network'.	info description: 'This package implements the DNS protocol (not all of it, but extending it is very easy). It includes a DNS client (a name resolver).Example (put the address of a name server):	NameResolver default servers: #((xxx xxx xxx xxx))	NameResolver default addressByName: ''squeak.org''This version adds reverse lookups (IP to name).'.	info maintainer: 'Jason Johnson <azreal1977@hotmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/dnsclient'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!DebugReport	self name: 'DebugReport'.	self version: '2.5'.	info category: 'Development'.	info description: 'You can generate more helpful debug log from Notifier or Debugger.Generated HTML document has the same view as Debugger.See sample page: <a href="http://squeak.sakura.ne.jp/etc/DebugReportSample/" target="_blank">http://squeak.sakura.ne.jp/etc/DebugReportSample/</a>'.	info maintainer: 'ls'.	info homepage: 'http://swikis.ddo.jp:9091/DebugReport.html'.	info squeakMapID: ''.	info url: 'http://squeaksource.blueplane.jp/DebugReport/DebugReport-minami.25.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'damiencassou 2/4/2009 16:57'!DependencyBrowser	self name: 'DependencyBrowser'.	self version: '0.3'.	info category: 'Code Browsing'.	info description: 'This utility contains an OmniBrowser that could be useful to whom it needs to arm a production release or just perform an early exploration of a package. The browser will display the dependencies (class, inheritance references and loose methods) from classes and packages in your image in a convienient way.'.	info maintainer: 'Hernán Morales Durand (hernan.morales@gmail.com)'.	info homepage: 'http://cs.hernanmorales.com.ar/projects/dependencyBrowser/DBrowser-en.php'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/DependencyWalker/OBDependencyWalker-hfm.2.mcz'.	self provides: #().	self dependsOn: #('OmniBrowserOmniBrowser-StandardDependencyWalkerPackageInfo').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/4/2009 16:57'!DependencyWalker	self name: 'DependencyWalker'.	self version: '0.3'.	info category: 'Development'.	info description: 'This is the DependencyBrowser package that do the real job.'.	info maintainer: 'Hernán Morales Durand (hernan.morales@gmail.com)'.	info homepage: 'http://cs.hernanmorales.com.ar/projects/dependencyBrowser/DBrowser-en.php'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/DependencyWalker/DependencyWalker-hfm.11.mcz'.	self provides: #('DependencyWalker').	self dependsOn: #('AST RefactoringEngine').! !!PackagesDevU methodsFor: 'Office' stamp: 'kph 9/10/2008 10:09'!DiagramBrowser	self name: 'Diagram Browser'.	self version: '2004-7-25'.	info category: 'Office'.	info description: 'DiagramBrowser is a tool for building and classifying diagrams (or any kind of morphic drawing) in category tree fashion. DiagramBrowser is part of the Jacarandá Project but can be downloaded and used independently.Note that this package does not provide shapes for making the diagrams. You can use the excelent Connectors package or install the complete Jacaranda package.'.	info maintainer: 'ls'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/2958'.	info squeakMapID: ''.	info url: 'http://map.squeak.org/accountbyid/3c873639-61d0-43e1-8c87-1fa43bc8599d/files/DiagramBrowser-hpt.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!DictionaryBrowser	self name: 'DictionaryBrowser'.	self version: '0.2'.	info category: 'Development'.	info description: 'DictionaryBrowser is a basic query and results browser for dictionary servers that implement the RFC 2229 dictionary server protocol.Use "DictionaryBrowser open" or "DictionaryBrowser openExistingWith: ''squeak''" to get started.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/DictionaryBrowser-rkris.4.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Languages and Extensions' stamp: 'kph 9/10/2008 10:09'!DynamicBindings	self name: 'DynamicBindings'.	self version: '2.7'.	info category: 'Languages and Extensions'.	info description: 'DynamicBindings for Squeakby Stephen Pair <stephen@pairhome.net> ===== Introduction =====You may create a hierarchy of DynamicBindings and directly manipulate the keys and values of those instances (just as you would any dictionary).  There is a root DynamicBindings that you may use to create new children if you like (but you can also create entirely separate hierarchies).  You can access this root with "DynamicBindings root".  To force a process to use one of your sets of DynamicBindings, you write code as follows (note, I only use ''PATH'' to highlight the similarity with normal OS environment variables):	myBindings _ DynamicBindings root newChild.	myBindings at: #PATH put: ''/bin:/usr/bin''.	myBindings bindDuring: 		[Bindings at: #PATH.  				"-> ''/bin:/usr/bin''"		Bindings at: #PATH put: (''/usr/local/bin:'', (Bindings at: #PATH)).		Bindings at: #PATH].  				"-> ''/usr/local/bin:/bin:/usr/bin''"For convenience, two methods have been added to Object that enable more direct access to bindings.  The following exampel is equivalent to the first:	myBindings _ DynamicBindings root newChild.	myBindings at: #PATH put: ''/bin:/usr/bin''.	myBindings bindDuring: 		[#PATH binding.  				"-> ''/bin:/usr/bin''"		#PATH binding: (''/usr/local/bin:'', (#PATH binding)).		#PATH binding].  				"-> ''/usr/local/bin:/bin:/usr/bin''"The first line creates a new set of bindings that is a child of the root bindings.  Any variables set in the root bindings are also visible in this new child environment.The second line sets the dynamic variable "PATH".The third line uses the evaluates the argument block in the context of our new set of bindings.The fourth line gets the value for the variable "PATH" (which we just set).The fifth line in the above example modifies the environment variable "PATH", but only for the duration that the enclosing block is active.Here is another example:	#PATH binding: ''/bin''.	Bindings clamp:		[#PATH binding: ''/usr/bin''.		#PATH binding]. 						"-> ''/usr/bin''"	#PATH binding.								"-> ''/bin''"This example shows the use of the #clamp: method to isolate a our dynamic bindings only for the duration of a block.  After the block finishes execution, the original set of bindings is restored.Scoping semantics:A dynamic variables'' scope is defined at runtime by an enclosing activation context.  To locate the active lexicon of dynamic variables, the system follows the activation stack until a context is encountered that defines the active DynamicBindings (this lookup is implemented using the exception handling system).  Any changes to the active DynamicBindings are visible in all activation contexts where that set of DynamicBindings are being used (which may include contexts in more than one activation stack).A bit about how it''s implemented:The bindings for a given method activation context are located using the exception handling mechanism (see BindingsLocator).  If a given stack does not have a handler that answers a set of bindings, then dummy contexts will be added to the top of the stack that will answer the global root set of bindings.Unlike other implementations, DynamicBindings do not use the activation stack to define the hierarchy of bindings.  Instances of DynamicBindings have their own parent instance variable and will locate enclosing variable scopes by following the chain of parents (*not* by looking for enclosing handlers of BindingsLocator).  Using this design, we are able to accomodate a broader range of usage scenarios.If you need to isolate the bindings of a given context stack such that future changes in the bindings are not visible to users of the current set of dynamic bindings (ie. if you use continuations), you can send the message #isolate to the BindingsAccessor (ie. use "Bindings isolate").===== Release History =====Version 1.1:	- Packaged using KomPackaging (Squeak version only)	- Made Object>>binding: answer its argument	- Cleaned up a few obsolete methods from the old RuntimeEnvironments implementationVersion 1.0:	- Initial release'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/KomHttpServer/DynamicBindings-gc.7.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!DynamicProtocols	self name: 'DynamicProtocols'.	self version: '0.67'.	info category: 'Development'.	info description: 'A dynamic protocol is a category (displayed in the 3rd pane of your browser) whose content is computed dynamically based on the currently selected class. If a dynamic protocol is empty then it is not shown.This system is based on an idea of Nathanael Sharli and Andrew P. Black (see ''A Browser For Incremental Programming'')Here is a small list of possible dynamic protocols:- HaltUsage: displays all methods containing a call to #halt- Override: contains methods that are defined in the superclasses and redefined in the current class- Duplicated: shows methods that have the same source code as in their super class- RecentlyModified, SuperSend...A preference system has been set to permit the selection of desired dynamic protocols. After having browsed at least one class using OmniBrowser, you can set your preferred protocols using the Preference Browser in the category ''dynamic protocols''.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.squeaksource.com/DynamicProtocols'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/DynamicProtocols/DynamicProtocols-dc.67.mcz'.	self provides: #().	self dependsOn: #('ClassSelectorSets' 'OmniBrowser-Standard').! !!PackagesDevU methodsFor: 'Games' stamp: 'kph 9/10/2008 10:09'!ElectricityGame	self name: 'Electricity Game'.	self version: '1.19'.	info category: 'Games'.	info description: 'This is the game Stephan B. Wessels demoed at OOPSLA 2003.NsGame began as a Squeak port of the Shockwave Flash game by Pavils Jurjans.See http://www.jurjans.lv/stuff/net/freenet.htm.To begin the game perform:	NsGame new openInWorldInstructions are available from within the game.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: 'http://squeak.preeminent.org/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/NSGame/NsTileGame-sbw.19.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Morphs' stamp: 'kph 9/10/2008 10:09'!EventInterceptorMorph	self name: 'EventInterceptorMorph'.	self version: '1alpha'.	info category: 'Morphs'.	info description: 'Have you ever wanted to trace some code which is part of the Morphic UI process, or code triggered by it?  Had trouble trying to trace it in the debugger because interacting with the UI changes what you''re trying to watch?  EventInterceptorMorph may be able to help!!EventInterceptorMorph is a button which, when pressed, begins listening to the hand''s event stream.  When an even of the appropriate type is encountered, this morph intercepts it and traces the dispatch of the event using MessageSendTree, and opens a SendTreeExplorer on the results.  This is useful for debugging parts of the UI process which are otherwise difficult to trace.The eventType can be any of the Morphic event types, but #mouseUp, #mouseDown, and #keystroke are by far the most useful because they are the triggers for the majority of actual UI activity.A methodSelector may be set which identifies a particular method the user is interested in.  All method sends above this method are ignored.  This is useful when the user wishes to study the execution of a known method which is eventually triggered by a UI gesture, but has no interest in the complete event dispatching send tree leading up to it.  See example in changeset preamble.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/EventInterceptorMorph-JW.1.cs.gz'.	self provides: #().	self dependsOn: #('SendTreeExplorer').! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!ExternalWebBrowser	self name: 'ExternalWebBrowser'.	self version: '9'.	info category: 'Network'.	info description: 'This small package should work as an alternative to scamper. It just hands over every url to a platform specific external browser.'.	info maintainer: 'Norbert Hartl <norbert@hartl.name>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ExternalWebBrowser/ExternalWebBrowser-noha.8.mcz'.	self provides: #().	self dependsOn: #('FFI').! !!PackagesDevU methodsFor: 'System' stamp: 'kph 9/10/2008 10:09'!Exupery	self name: 'Exupery'.	self version: '0.14'.	info category: 'System'.	info description: 'Exupery is a byte code compiler written in Squeak. It has been written fully test first with both customer and acceptance tests.The project is a personal master work, it is meant to both be useful in itself and help me improve my personal programming skills.It is going to be a compiler for leaf methods first, providing an alternative to writing plugins as a performance improvement.The programming exersize is complexity control. Compilers are much harder to write than interpreters yet in theory they should be intermediate generation (equivilent to the interpreter) plus a back-end. Both parts are individually well understood.'.	info maintainer: 'Bryce Kampjes <bryce@kampjes.demon.co.uk>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Exupery/Exupery-wbk.321.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'System' stamp: 'kph 11/2/2008 00:30'!ExuperyDevelopment	self name: 'Exupery Development'.	self version: '0.14.3'.	info category: 'System'.	info description: 'Provides a development image with the usual tools for Exupery.'.	info maintainer: 'wbk'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Exupery/VMMaker-wbk.80.mcz'.	self provides: #('VMMaker').	self dependsOn: #('CommandShell' 'Connectors' 'Exupery' 'FFI' 'FreeType Plus-plugins source' 'GraphViz' 'OSProcessPlugin' 'Refactoring Tests' 'Speech').! !!PackagesDevU methodsFor: 'System' stamp: 'kph 9/10/2008 10:09'!FFI	self name: 'FFI'.	self version: '3.9.1'.	info category: 'System'.	info description: 'The Squeak foreign function interface.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: 'http://wiki.squeak.org/squeak/1414'.	info squeakMapID: ''.	info url: 'http://map.squeak.org/accountbyid/cf58c358-46ee-465e-b6db-2740e9b32a53/files/InstallFFI3.st'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'System' stamp: 'kph 9/10/2008 10:09'!FFIExamples	self name: 'FFI-Examples'.	self version: '3.9'.	info category: 'System'.	info description: 'Examples for the Squeak foreign function interface.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://source.squeakfoundation.org/FFI/FFI-Examples-ar.1.mcz'.	self provides: #().	self dependsOn: #('FFI').! !!PackagesDevU methodsFor: 'System' stamp: 'kph 9/10/2008 10:09'!FFITests	self name: 'FFI-Tests'.	self version: '3.9'.	info category: 'System'.	info description: 'Tests for the Squeak foreign function interface.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://source.squeakfoundation.org/FFI/FFI-Tests-ar.2.mcz'.	self provides: #().	self dependsOn: #('FFI').! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'test 1/13/2009 15:56'!FileBase	self name: 'File-Base'.	self version: '10'.	info category: 'Model Extension'.	info description: 'A file IO interface inspired by http://rio.rubyforge.org , potentially replaces FileDirectory/FileMan.Transparently supports archives and ftp filesystems'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://wiki.squeak.org/squeak/5929'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Rio/File-Base-test.10.mcz'.	self provides: #().	self dependsOn: #('File-Kernel').! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'test 1/13/2009 15:56'!FileKernel	self name: 'File-Kernel'.	self version: '10'.	info category: 'Model Extension'.	info description: 'A file IO interface inspired by http://rio.rubyforge.org , potentially replaces FileDirectory.This package contains only the kernel of Rio. See the package File-Base to get the full distribution.'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://wiki.squeak.org/squeak/5929'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Rio/File-Kernel-test.10.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'kph 9/10/2008 10:09'!FileMan	self name: 'FileMan'.	self version: '0.85'.	info category: 'Model Extension'.	info description: 'Squeak''s file libraries (Directory, DirectoryEntry, FileStream, etc.) are sometimes very confusing to use. FileMan provides a simple, refactored interfaces for manipulating files and directories by wrapping those classes."Before"subDir := FileDirectory default directoryNamed: ''subDir''.subDir assureExistence.[str := subDir newFileNamed: ''file1''.str nextPutAll: ''Hello!!'']	ensure: [str close]."After installation of FileMan"''./subDir'' asDirectoryEntry at: ''file2'' put: ''Hello!!'''.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://squeaksource.blueplane.jp/FileMan.html'.	info squeakMapID: ''.	info url: 'http://squeaksource.blueplane.jp/FileMan/FileMan-mu.85.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'test 1/13/2009 15:56'!FileTest	self name: 'File-Test'.	self version: '7'.	info category: 'Model Extension'.	info description: 'File-Tests '.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://wiki.squeak.org/squeak/5929'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Rio/File-Test-test.7.mcz'.	self provides: #().	self dependsOn: #('File-Base').! !!PackagesDevU methodsFor: 'Data Structures' stamp: 'kph 9/10/2008 10:09'!FixedDecimal	self name: 'FixedDecimal'.	self version: '13'.	info category: 'Data Structures'.	info description: 'An implementation of FixedDecimal.  Should be like Scaled Decimal, except that it actually does math correctly (i.e., two FixedDecimal that the printed version of them look like they are equal are, in fact, equal - unlike Scaled Decimal).'.	info maintainer: 'kph'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/FixedDecimal/FixedDecimal-cbc.13.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!Folktale	self name: 'Folktale'.	self version: '0.51'.	info category: 'Network'.	info description: 'Folktale is a useful command shell for headless Swiki user.You can log in squeak image through telnet client at localhost port 4919.Try$ squeak -headless squeak.image Folktale.st &Useful expressions and pseudo variables.Jump result object unless your query has dot(.) at end.----Basic command is follwedhelp -- This message.exit  -- Exit.self -- Current object.ii -- Inspect self.history -- Show history.back -- Back.q -- The agent (me).q usefulExpressions -- Show more useful expressions.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Folktale-051.st'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Morphs' stamp: 'kph 9/10/2008 10:09'!FractalMorph	self name: 'FractalMorph'.	self version: '1.2'.	info category: 'Morphs'.	info description: 'see webpage http://minnow.cc.gatech.edu/squeak/2911 for descriptions.  Allows you to zoom in and out of a fractal image, possibly make small animations as well.  begin with (FractalMorph newopenInWorld)'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/FractalMorph.2.cs'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Fonts' stamp: 'kph 9/10/2008 10:09'!FreeTypePlus	self name: 'FreeType Plus'.	self version: '0.5'.	info category: 'Fonts'.	info description: 'Support for FreeType font system.Scans host OS for available font files, and automatically creates TextStyles.Re-scans on every image startup.'.	info maintainer: 'amtween@hotmail.com'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://map.squeak.org/accountbyid/46dcf6af-067d-43e3-9fc9-d7010e067153/files/FreeType-tween.355.mcz'.	self provides: #().	self dependsOn: #('FFI' 'FreeType Plus-plugins installer').! !!PackagesDevU methodsFor: 'Fonts' stamp: 'kph 11/2/2008 00:30'!FreeTypePlusBase	self name: 'FreeType Plus-Base'.	self version: '0'.	info category: 'Fonts'.	info description: 'The main FreeType Plus package.Bryce has created this because loading FreeType Plus loads  FreeType Plus-plugins which breaks on Linux if you''re using a VM with the Freetype plugin build directories beside it. It''s here so FreeType Plus-plugins source can load it to automate building an image to build the VM from.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/FreeTypePlus/FreeType-tween.435.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Fonts' stamp: 'kph 9/10/2008 10:09'!FreeTypePlusplugins	self name: 'FreeType Plus-plugins'.	self version: '0.15'.	info category: 'Fonts'.	info description: 'Installs plugins (for Windows/Linux) into VM executable directory.For Mac OS X - use the most recent VM (which includes the FT2Plugin) and get the modified BitBltPlugin from ftp://ftp.smalltalkconsulting.com/experimental/BitBltPlugin.v1.0.0b1.FreeTypePlus.bundle.zip'.	info maintainer: 'amtween@hotmail.com'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://map.squeak.org/accountbyid/46dcf6af-067d-43e3-9fc9-d7010e067153/files/FreeTypePluginInstaller3.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Fonts' stamp: 'kph 9/10/2008 10:09'!FreeTypePluspluginsinstaller	self name: 'FreeType Plus-plugins installer'.	self version: '0.16'.	info category: 'Fonts'.	info description: 'Installs plugins (for Windows/Linux) into VM executable directory.For Mac OS X - use the most recent VM (which includes the FT2Plugin) and get the modified BitBltPlugin from ftp://ftp.smalltalkconsulting.com/experimental/BitBltPlugin.v1.0.0b1.FreeTypePlus.bundle.zip'.	info maintainer: 'amtween@hotmail.com'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://map.squeak.org/accountbyid/46dcf6af-067d-43e3-9fc9-d7010e067153/files/FreeTypePluginInstaller3.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Fonts' stamp: 'kph 11/2/2008 00:30'!FreeTypePluspluginssource	self name: 'FreeType Plus-plugins source'.	self version: '3'.	info category: 'Fonts'.	info description: 'The Slang source for the FreeType Plus plugin. This is to be used with VMMaker'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://source.impara.de/freetype/Freetype-Plugin-JMM.53.mcz'.	self provides: #().	self dependsOn: #('FreeType Plus-Base' 'VMMaker').! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!GOODS	self name: 'GOODS'.	self version: '80'.	info category: 'Persistence'.	info description: 'GOODS is a distributed, language-neutral object database from Konstantin Knizhnik. It''s available from http://www.garret.ru/~knizhnik/goods.html .This client provides transparent storage of Smalltalk objects, or, given some extra type information, compatibility with the GOODS Java interface storage conventions, for easy sharing of object data between Squeak and Java.See http://minnow.cc.gatech.edu/squeak/3492 for more information.*Requires GOODS 2.72 or later*'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/GOODS/GOODS-avi.80.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Games' stamp: 'kph 9/10/2008 10:09'!Games	self name: 'Games'.	self version: '2005-10-14'.	info category: 'Games'.	info description: 'Chess, FreeCell, SameGame, ChineseCheckers, Tetris and more'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://map.squeak.org/accountbyid/fc09dff0-87b1-47ec-ace7-fa4172b5d6a0/files/Morphic-Games.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Games' stamp: 'kph 9/10/2008 10:09'!GamesTests	self name: 'GamesTests'.	self version: '2003-5-2'.	info category: 'Games'.	info description: ''.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/gamesTests-asm.cs'.	self provides: #().	self dependsOn: #('Games').! !!PackagesDevU methodsFor: 'Network' stamp: 'damiencassou 2/4/2009 16:57'!GemToolsClient	self name: 'GemTools-Client'.	self version: '0.355'.	info category: 'Network'.	info description: 'Installs GLASS client software. Provides development environment UI for OmniBrowser-based tools running in a GemStone server.This new version depends upon OSTestRunner, an OmniBrowser-based version of TestRunnerNote that this package is not only dependent upon certain packages, but it is dependent upon specific versions of those packages in the client image. Here is the list of versions that the client has been tested with:	OmniBrowser version 0.432	ShoutOmniBrowser version tween.6	FFI version 3.9.1	OmniBrowser-Morphic version 0.68If you experience problems, you should make sure that you have the above versions loaded.This version is also dependent upon GLASS.230-dkh.182 (or later) on the GemStone side.'.	info maintainer: 'Dale Henrichs'.	info homepage: 'http://seaside.gemstone.com/'.	info squeakMapID: ''.	info url: 'http://seaside.gemstone.com/ss/GLASSClient/GemStone-dkh.355.mcz'.	self provides: #('GemTools-Client').	self dependsOn: #('FFI' 'OmniBrowser' 'OmniBrowser-Morphic' 'OmniBrowser-SUnit-GUI' 'ShoutOmniBrowser').! !!PackagesDevU methodsFor: 'User Interface' stamp: 'kph 9/10/2008 10:09'!Genie	self name: 'Genie'.	self version: 'r67'.	info category: 'User Interface'.	info description: 'Genie is a powerful gesture recognition system by Nathanael Schärli. It lets you control anything in your Squeak environment through mouse or pen gestures. This version includes better Squeak integration, a small dictionary of useful gestures for project navigation and UI control, and should "just work" after installation.'.	info maintainer: 'Simon Michael'.	info homepage: 'http://squeaksource.com/genie.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/genie/Genie-sm.67.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!Glorp	self name: 'Glorp'.	self version: '0.4.169'.	info category: 'Persistence'.	info description: 'Glorp is Object-Relational Mapping Framework similar to TopLink, developed by Alan Knight. Squeak version requires the Postgres client '.	info maintainer: 'Norbert Hartl <norbert@hartl.name>'.	info homepage: 'http://www.glorp.org/'.	info squeakMapID: ''.	info url: 'http://selfish.org/files/st/Glorp-0.4.169.sar'.	self provides: #().	self dependsOn: #('PostgreSQL Client').! !!PackagesDevU methodsFor: 'Graphics' stamp: 'kph 9/10/2008 10:09'!GraphViz	self name: 'GraphViz'.	self version: '41r2'.	info category: 'Graphics'.	info description: 'Graph visualization is a way of representing structural information asdiagrams of abstract graphs and networks. Automatic graph drawing hasmany important applications in software engineering, database and webdesign, networking, and in visual interfaces for many other domains.The Graphviz layout programs take descriptions of graphs in a simpletext language, and make diagrams in several useful formats such asimages and SVG for web pages, Postscript for inclusion in PDF or otherdocuments; or display in an interactive graph browser. (Graphviz alsosupports GXL, an XML dialect.)Graphviz has many useful features for concrete diagrams, such asoptions for colors, fonts, tabular node layouts, line styles,hyperlinks, and custom shapes.In practice, graphs are usually generated from an external datasources, but they can also be created and edited manually, either asraw text files or within a graphical editor. (Graphviz was notintended to be a Visio replacement, so it is probably frustrating totry to use it that way.)So basically, the Squeak interface provided here makes it fairlystraightforward to generate the "dot" language file that the GraphVizcommand line programs use as input to create the graphs.  Forreferences on the "dot" language you can go to the graphviz web sitementioned above.Several examples are provided in the Squeak package if you look at theclass side of GraphViz or inspect my test cases.  Graphing Smalltalkclass hierarchies and/or class references has been a source of delightas well as using this program to graph many relationships pertinent tomy business data.Lastly, GraphViz will generate SVG output formats as well.  I found avery cool Java-based Zoomable User Interface built specially tonavigate large graphs generated by GraphViz called ZGRViewer(http://zvtm.sourceforge.net/zgrviewer.html). Then you can open the Java ZGRViewer program and surf around the graph file this is generated by Squeak.  Very cool for looking at large models!!'.	info maintainer: 'wbk'.	info homepage: 'http://squeak.saltypickle.com/GraphViz'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/GraphViz/GraphViz-jrp.41.mcz'.	self provides: #().	self dependsOn: #('CommandShell' 'Connectors' 'FFI').! !!PackagesDevU methodsFor: 'Graphics' stamp: 'kph 9/10/2008 10:09'!GraphicsExternal	self name: 'Graphics-External'.	self version: '0.1'.	info category: 'Graphics'.	info description: 'Balloon3D dependencies'.	info maintainer: 'Mathieu Suen <mathieusuen@yahoo.fr>'.	info homepage: 'http://www.squeaksource.com/Balloon3D'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Balloon3D/Graphics-External-ar.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Graphics' stamp: 'kph 9/10/2008 10:09'!GraphicsTools	self name: 'Graphics-Tools'.	self version: '0.2'.	info category: 'Graphics'.	info description: 'Balloon3D dependencies'.	info maintainer: 'Mathieu Suen <mathieusuen@yahoo.fr>'.	info homepage: 'http://www.squeaksource.com/Balloon3D'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Balloon3D/Graphics-Tools-ar.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!HTMLParser	self name: 'HTML-Parser'.	self version: '1.5-2'.	info category: 'Network'.	info description: 'Parses an HTML document into an XML DOM, using YAXO''s XMLElement.  This parser is HTML 4.01 compliant - it will accurately infer the structure of correct HTML, but it is not tolerant of broken markup.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/HTML-Parser.st'.	self provides: #().	self dependsOn: #('Network-HTML' 'YAXO').! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!HTTPClient	self name: 'HTTPClient'.	self version: '19'.	info category: 'Network'.	info description: 'A Squeak port of Steve Waring''s HTTP client.  (The original, Dolphin package is available at http://www.dolphinharbor.org/dh/projects/httpclient/index.html.)  The Squeak port is usable, but still needs a lot of cleanup work.The Squeak port must be installed using an up-to-date version of MCInstaller; the easiest way to get that is to update to SM2.See the class side of SptHTTPRequest for example usage.Features:    * HTTP 1.1 persistent connections.    * Ability to process requests in a background process and set timeouts.    * Cookie parsing/sending.    * Partial range requests.    * Automatic following of redirections.    * Streaming of responses to writeStreams/fileStreams.    * Basic Authentication.    * Support for Proxies.    * Flexible progress notifications.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SWHTTPClient-bkv.19.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!IRCBot	self name: 'IRCBot'.	self version: '2.1'.	info category: 'Network'.	info description: 'see homepage for instructions on how to use and set up the bot.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Network-IRC%20Bot.st'.	self provides: #().	self dependsOn: #('IRCe').! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!IRCe	self name: 'IRCe'.	self version: '10.7.6-2'.	info category: 'Network'.	info description: 'This is a significant rewrite of the built-in Squeak IRC client GUI. A new user interface includes having one console window per connection and then having all console messages, channel messages and private messages contained inside the main console window using tabbed swapped panes.                                         Numerous other changes are also included but are not described here. The change-set contains documentation for all features added or modified.Instructions at http://squeak.preeminent.org/irc-help/irc-help.html'.	info maintainer: 'Frank Caggiano'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://kilana.unibe.ch:8888/IRC/Network-IRC-fc.10.7.6.mcz'.	self provides: #().	self dependsOn: #('ExternalWebBrowser' 'FFI').! !!PackagesDevU methodsFor: 'Group Development' stamp: 'damiencassou 1/21/2009 13:12'!Installer	self name: 'Installer'.	self version: '4.3.284'.	info category: 'Group Development'.	info description: 'Installer provides a simple Domain Specific Language for installing packages from monticello and squeakmap of various version.One design decision is to be able to paste scripts a workspace and run and tested from there without any special editing.Includes support for Package Universes'.	info maintainer: 'kph'.	info homepage: 'http://wiki.squeak.org/squeak/Installer'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Installer/Installer-Core-kph.284.mcz'.	self provides: #('Installer').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Data Structures' stamp: 'kph 9/10/2008 10:09'!Iterator	self name: 'Iterator'.	self version: '1.0'.	info category: 'Data Structures'.	info description: 'Ported from the Iterator goodie by Mario Wolczko.Occasionally you may have a block that when evaluated can betreated as a collection -- ie it takes another block as parameter,then applies that to a sequence of values.This goodie wraps the block into an object -- an iterator -- which ispart of the collection hierarchy, and therefore inherits a variety ofuseful collection-related methods.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Iterator.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!JavaSerialization	self name: 'Java Serialization'.	self version: '1.71'.	info category: 'Persistence'.	info description: 'Gives Squeak the ability to read in and write out Java serialized objects. It also includes a Java Class Loader. Great for debugging serialization problems in Java. Right now, I can load in any serialized stream, but those written with customized methods are just simple byte arrays. Future versions will use the class loader to make sense of this information. If you get any use out of it or have suggestions, let me know. I want it to become a way to interface to Java easily and the Smalltalk way. I want to do Java better than Java.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: 'http://www.squeaksource.com/Java.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Java/btb-Java-btb.171.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Data Structures' stamp: 'kph 9/10/2008 10:09'!KGraph	self name: 'KGraph'.	self version: '0.0'.	info category: 'Data Structures'.	info description: 'General purpose graph package.  Or it will be if it gets finished ;-)'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/KGraph-Propertied-jcg.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Kernel' stamp: 'kph 9/10/2008 10:09'!KernelExtkph	self name: 'KernelExt-kph'.	self version: '3.10.54+'.	info category: 'Kernel'.	info description: 'see: http://installer.pbwiki.com/311-KernelExtensions'.	info maintainer: 'kph <keith_hodges@yahoo.co.uk>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://installer.pbwiki.com/f/Install311KernelExtensions.st'.	self provides: #('Null').	self dependsOn: #().! !!PackagesDevU methodsFor: 'IDE' stamp: 'kph 9/10/2008 10:09'!KeyBinder	self name: 'KeyBinder'.	self version: '2004.8.14.18'.	info category: 'IDE'.	info description: 'KeyBinder modifies the way Squeak handles keyboard events and provides a framework for constructing keyboard bindings.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://wiki.squeak.org/squeak/HernanTylim'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/KeyBinder/KeyBinder-cdlm.18.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'IDE' stamp: 'kph 9/10/2008 10:09'!Keymapping	self name: 'Keymapping'.	self version: '4.1'.	info category: 'IDE'.	info description: 'Allows binding of keymaps to any morph, class or category of morphs.  Includes a simple GUI for editing keyboard bindings'.	info maintainer: 'cds'.	info homepage: 'http://map1.squeakfoundation.org/sm/package/51055995-d976-42da-ae18-7f3bdb9fb27d'.	info squeakMapID: '51055995-d976-42da-ae18-7f3bdb9fb27d'.	info url: 'http://map.squeak.org/accountbyid/1885112d-8641-485b-b40c-c0964d48e674/files/KeymappingInstaller-9.sar'.	self provides: #('Keymapping').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!KomHttpServer	self name: 'KomHttpServer'.	self version: '7.0.30'.	info category: 'Network'.	info description: 'KomHttpServer is the Comanche web server package.  To get a simple web server running, install this package and evaluate the code below.  A simple file serving web server will be started and will serve the files in your default directory.	| ma |	ma := ModuleAssembly core.	ma serverRoot: FileDirectory default fullName.	ma documentRoot: FileDirectory default fullName.	ma directoryIndex: ''index.html index.htm''.	ma serveFiles.	(HttpService startOn: 8080 named: ''httpd'') plug: ma rootModuleAfter starting the server, point your web browser to http://localhost:8080/If you have loaded Seaside, you can start a web server that serves Seaside based applications using the following configuration:	| ma seaside |	seaside := WAKom default.	ma := ModuleAssembly core.	ma serverRoot: FileDirectory default fullName.	ma alias: ''/seaside'' to: [ma addPlug: [:request | seaside process: request]].	ma documentRoot: FileDirectory default fullName.	ma directoryIndex: ''index.html index.htm''.	ma serveFiles.	(HttpService startOn: 8080 named: ''httpd'') plug: ma rootModuleSee the class comments of the various subclasses of ComancheModule for documentation and usage examples.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/KomHttpServer/KomHttpServer-gc.30.mcz'.	self provides: #().	self dependsOn: #('KomServices').! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!KomServices	self name: 'KomServices'.	self version: '1.12'.	info category: 'Network'.	info description: 'KomServices provides a framework for the creation and management of background processes.  A generic Service class is provided for this purpose.  Additionally, TcpService is provided for creating services that respond to inbound TCP connections.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/KomHttpServer/KomServices-gc.12.mcz'.	self provides: #().	self dependsOn: #('DynamicBindings').! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'kph 9/10/2008 10:09'!LambdaMessageSend	self name: 'LambdaMessageSend'.	self version: '16'.	info category: 'Model Extension'.	info description: 'This package implements a specialized MessageSend subclass and an associated API for functional programming in Squeak.See the test cases in FunctionalTalkTest for comprehensive documentation'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.zogotounga.net/comp/squeak/functionaltalk.htm'.	info squeakMapID: ''.	info url: 'http://map.squeak.org/accountbyid/5f9bef44-1fbb-4dd6-8f10-a69862ad5674/files/FunctionalTalk-17.st'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'IDE' stamp: 'kph 9/10/2008 10:09'!Launcher	self name: 'Launcher'.	self version: '1.0.62'.	info category: 'IDE'.	info description: 'A Launcher provides squeak with a range of capabilities that are intended to be used from the command line.As a design goal, the startup process can invoke Launcher several times at several points in the startup sequence. In particular 1) below aims to provide a mechanism for getting into images that are broken in some form, so as to enable a script to be run before morphic has attempted to startup.1) Launcher is registered to handle startup notification after Security managerany class which wishes to provide a service to be usable at this time implements startFrom:2) Launcher is wired in to ProjectLauncher to handle startup notification when squeak is fully initialized. Any class wishing to provide a service to be usable at this time implements launchFrom:#startFrom: and #launchFrom: are called providing a handle to the launcher which may be used to obtain parameters using the desired scheme. a) launcher getParameters . key=value +yes -nob) launcher getParametersOldStyle . key value key2 value2  '.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://www.squeaksource.com/Installer.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Installer/Launcher-Core-kph.62.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Games' stamp: 'kph 9/10/2008 10:09'!LifeMorph	self name: 'LifeMorph'.	self version: '1.0'.	info category: 'Games'.	info description: 'A simple implementation of Life Game.  It is based on Dan''s original Life Game for Smalltalk-80.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/LifeMorph.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Languages and Extensions' stamp: 'kph 9/10/2008 10:09'!Lisp	self name: 'Lisp'.	self version: '1'.	info category: 'Languages and Extensions'.	info description: 'GUI works only in MVC. How to start 1) evaluate: LispInterpreter open or LispInterpreter fullOpen'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Lisp-md.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!LogEngine	self name: 'LogEngine'.	self version: '2'.	info category: 'Development'.	info description: 'A powerful and small LogEngine for Squeak!!A Sample usage islc := LogClient getInstance: ''Client''.lc debug:''test1''.lc info:''test2''.When you create a LogClient, you must use the getInstance: method, passing a "Category Name"used to create a special category log file.LogClient features:+ Integrated con Preferences (debug panel)+ Can output on file and on Transcript on demand+ Can print the method where the line is called+ Can disable the debug level (only this for the meantime, sorry).+ Easy to extend'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/LogEngine2.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'test 1/13/2009 15:56'!Logging	self name: 'Logging'.	self version: '3.42'.	info category: 'Development'.	info description: 'Logging for squeak, a front end to Toothpick OR SimpleLog (apologies to LogEngine)usage:self log this.self log x: 10 y: 20.and much more...'.	info maintainer: 'Keith Hodges <keith_hodges@yahoo.co.uk>'.	info homepage: 'http://wiki.squeak.org/squeak/3706'.	info squeakMapID: '6c1b03cd-6c37-4acf-b971-72ff132c03f0'.	info url: 'http://www.squeaksource.com/Logging/Logging-kph.42.mcz'.	self provides: #('Logging').	self dependsOn: #('ProcessSpecific' 'StreamsReadability').! !!PackagesDevU methodsFor: 'Languages and Extensions' stamp: 'kph 9/10/2008 10:09'!Logicexpressions	self name: 'Logic expressions'.	self version: '2.1'.	info category: 'Languages and Extensions'.	info description: 'This is a model of first order logic expressions, allowing you to manipulate them as objects instead of just strings.Prerequisites: 	Refactoring Browser	SmaCC Runtime Package	SmaCC Development PackageFor example, inspect the following lines to get the expression correspondingto "(p => q) = (not p or q)":	| p q |	p := LVariable named: ''p''.	q := LVariable named: ''q''.	p => q equiv: (p not | q).Now, the same formula could be created using:	LExpression fromString: ''{p=>q = not p or q}''More complex formulas can also be created and evaluated, for example try:	| exp |	exp := LExpression fromString: ''{V(x)[x even]}''.	exp valueDomains: {''x'' -> #(2 4 6 8 10 12 )}.See more examples in the Homepage and on the Logic-Tests category.I hope you enjoy it!!Dany'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/3539'.	info squeakMapID: ''.	info url: 'http://map.squeak.org/accountbyid/3b1bce7e-2c48-4820-a5ab-4d806a1f29ba/files/Logic-DEA.2.mcz'.	self provides: #().	self dependsOn: #('SmaCC').! !!PackagesDevU methodsFor: 'Kernel' stamp: 'damiencassou 2/17/2009 18:56'!M7219StreamsReadability	self name: 'M7219-StreamsReadability'.	self version: '0.3'.	info category: 'Kernel'.	info description: 'Provides Stream-#<< , used by Logging'.	info maintainer: 'kph'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://bugs.squeak.org/file_download.php?file_id=3565&type=bug&e=.st'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Kernel' stamp: 'damiencassou 2/17/2009 18:56'!M7284firsOrNil	self name: 'M7284-firsOrNil'.	self version: '0.3'.	info category: 'Kernel'.	info description: 'useful methods #firstOrNil #lastOrNil'.	info maintainer: 'kph'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://bugs.squeak.org/file_download.php?file_id=3666&type=bug&e=.st'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'damiencassou 2/17/2009 18:56'!Magma	self name: 'Magma'.	self version: 'r41.2'.	info category: 'Persistence'.	info description: 'Client, Server and Tester components for the Magma object database. '.	info maintainer: 'kph <keith_hodges@yahoo.co.uk>'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/2665'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Magma/r41.2.mcm'.	self provides: #('Magma').	self dependsOn: #('Monticello15').! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!Magma10client	self name: 'Magma 1.0 client'.	self version: 'r40'.	info category: 'Persistence'.	info description: 'Client, Server and Tester components for the Magma object database. '.	info maintainer: 'kph <keith_hodges@yahoo.co.uk>'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/2665'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Magma/Magma%201.0r40%20client%20configuration.mcm'.	self provides: #('Magma').	self dependsOn: #('MonticelloConfigurations').! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 11/28/2008 16:26'!Magma10server	self name: 'Magma 1.0 server'.	self version: 'r41'.	info category: 'Persistence'.	info description: 'Client, Server and Tester components for the Magma object database. '.	info maintainer: 'kph <keith_hodges@yahoo.co.uk>'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/2665'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Magma/1.0r41.mcm'.	self provides: #('Magma').	self dependsOn: #('MonticelloConfigurations').! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 11/28/2008 16:26'!Magma141	self name: 'Magma 1.41'.	self version: 'r41.1'.	info category: 'Persistence'.	info description: 'Client, Server and Tester components for the Magma object database. '.	info maintainer: 'kph <keith_hodges@yahoo.co.uk>'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/2665'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Magma/r41.1.mcm'.	self provides: #('Magma').	self dependsOn: #('Monticello15').! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!MagmaClient	self name: 'Magma Client'.	self version: '0.9beta'.	info category: 'Persistence'.	info description: 'The client component for Magma.Magma is a highly transparent, multi-user object-database.  It offers Squeak users, as a community, concurrent access to a large model of objects, as well as query power comparable to relational databases for locating any object in the model.  It is easy to learn and use.'.	info maintainer: 'Chris Muller <chris@funkyobjects.org>'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/2665'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Magma/MagmaClientLoader-cmm.23.mcz'.	self provides: #('Magma client').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!MagmaSeaside	self name: 'Magma Seaside'.	self version: '0.9beta'.	info category: 'Persistence'.	info description: 'Provides Seaside applications a suggested interface to a Magma repository, and a supplemental panel in Seaside''s Configuration utility to point the application to any local or remote Magma repository.Each Seaside session will create its own connection to the Magma repository, known as a MagmaSession. Note WAMagmaSession extends WASession to manage the allocation of this MagmaSession and its closure when the Seaside session is finalized.See the website for more information'.	info maintainer: 'Chris Muller <chris@funkyobjects.org>'.	info homepage: 'http://wiki.squeak.org/squeak/5817'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Magma/Magma%20seaside-brp.4.mcz'.	self provides: #('Easy connection from Seaside to a Magma repository').	self dependsOn: #('Magma Client' 'Seaside').! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!MagmaSeasidealpha	self name: 'Magma Seaside-alpha'.	self version: '1.0.86'.	info category: 'Persistence'.	info description: 'Greatly enhanced- control panel for magma- shared sessions- support for detailed logging'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://wiki.squeak.org/squeak/5817'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/MagmaTester/Magma%20seaside-kph.86.mcz'.	self provides: #().	self dependsOn: #('Magma 1.0 tester' 'Seaside-beta' 'Seaside28Jetsam').! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!MagmaServer	self name: 'Magma Server'.	self version: '0.9beta'.	info category: 'Persistence'.	info description: 'Server component for the Magma object database.'.	info maintainer: 'Chris Muller <chris@funkyobjects.org>'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/2665'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Magma/MagmaServerLoader-cmm.25.mcz'.	self provides: #('Magma server').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'damiencassou 2/17/2009 18:56'!MagmaseasideHelper	self name: 'Magma seasideHelper'.	self version: '2.8.r40.33'.	info category: 'Persistence'.	info description: 'Provides Seaside applications with an interface to a Magma repository.Includes detailed logging, and many preconfigured MagmaSession policies.See the website for more information'.	info maintainer: 'Keith Hodges <keith_hodges@yahoo.co.uk>'.	info homepage: 'http://wiki.squeak.org/squeak/6019'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/MagmaTester/Magma%20seasideHelper-kph.32.mcz'.	self provides: #().	self dependsOn: #('Logging' 'Magma' 'Seaside' 'Seaside28Jetsam').! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!Magmasunit	self name: 'Magma sunit'.	self version: '1.0.8'.	info category: 'Persistence'.	info description: 'Magma as an SUnit test resource'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://wiki.squeak.org/squeak/5817'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/MagmaTester/Magma%20sunit-kph.8.mcz'.	self provides: #().	self dependsOn: #('Magma').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/4/2009 16:57'!MagritteModel	self name: 'Magritte-Model'.	self version: '1.1.331'.	info category: 'Development'.	info description: 'Most applications consist of a big number of model- or so called domain-objects. Building different views, editors, and reports; querying, validating and storing those objects is very repetitive and error-prone, if an object changes its shape frequently. Magritte is a fully dynamic meta-description framework that helps to solve those problems, while keeping the full power to the programmer in all aspects. Moreover since Magritte is described in itself, you can let your users modify the meta-world and add their own fields and forms without writing a single line of code.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.lukas-renggli.ch/smalltalk/magritte'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/magritte/Magritte-Model-lr.331.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Morphs' stamp: 'damiencassou 2/4/2009 16:57'!MagritteMorph	self name: 'Magritte-Morph'.	self version: '1.1.42'.	info category: 'Morphs'.	info description: 'Magritte bindings for Morphic.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.lukas-renggli.ch/smalltalk/magritte'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/magritte/Magritte-Morph-lr.42.mcz'.	self provides: #().	self dependsOn: #('Magritte-Model').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/4/2009 16:57'!MagritteMse	self name: 'Magritte-Mse'.	self version: '1.1.2'.	info category: 'Development'.	info description: 'MSE file format integration to Magritte.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://smallwiki.unibe.ch/fame/mse/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/mse/Magritte-Mse-lr.2.mcz'.	self provides: #().	self dependsOn: #('Magritte-Model' 'Mse').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/5/2009 16:16'!MagritteSeaside	self name: 'Magritte-Seaside'.	self version: '1.1.283'.	info category: 'Web Development'.	info description: 'Magritte bindings for Seaside.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.lukas-renggli.ch/smalltalk/magritte'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/magritte/Magritte-Seaside-pmm.283.mcz'.	self provides: #().	self dependsOn: #('Magritte-Model' 'Scriptaculous' 'Seaside').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/4/2009 16:57'!MagritteTests	self name: 'Magritte-Tests'.	self version: '1.1.148'.	info category: 'Development'.	info description: 'Magritte SUnit tests.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.lukas-renggli.ch/smalltalk/magritte'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/magritte/Magritte-Tests-lr.148.mcz'.	self provides: #().	self dependsOn: #('Magritte-Model').! !!PackagesDevU methodsFor: 'Simulation' stamp: 'kph 9/10/2008 10:09'!Manzana	self name: 'Manzana'.	self version: '2003-1-21'.	info category: 'Simulation'.	info description: 'Really simple physics simulations with Morphs.Every Morph with mass contained in ManzanaUniversePasteUpMorph or in ManzanaPlanetPasteUpMorph with mass will be part in a simple simulation.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Manzana-2003-01-21.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Morphs' stamp: 'kph 9/10/2008 10:09'!MemoryUsage	self name: 'MemoryUsage'.	self version: '0.3'.	info category: 'Morphs'.	info description: 'A ProgressMorph subclass to display the current VM memory in use.  I wrotethis because the vm statistics menu item in the help menu is static; itdoesn''t periodically update.Plus, it''s cool!!"MemoryUsage new openInWorld."'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://web.nilpotent.org/software/smalltalk/MemoryUsage3.st.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Office' stamp: 'kph 9/10/2008 10:09'!MiniToDo	self name: 'MiniToDo'.	self version: '1.1'.	info category: 'Office'.	info description: 'Very simple task administration system.Developed mainly as a learning-project. A lot of features must be added.Sorry by the "spanglish" mix :)Need a PluggableListMorph.To start the app, evaluate:SistemaTareas new initialize openAViewOnMe'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://map.squeak.org/accountbyid/1c274487-4fe7-4e08-ae09-c43a6c4ca73c/files/MiniToDo-gsa.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!MinneStore	self name: 'MinneStore'.	self version: '2.8'.	info category: 'Persistence'.	info description: 'Object Database Management System forVisual Smalltalk 3.1, Dolphin Smalltalk, VisualAge Smalltalk, VisualWorks Smalltalk and Squeak.Its licensed under the MIT LicenseDownload the 2.7, 2.8 and 2.9 version port from the Stephen Pope''s site ftp://ftp.create.ucsb.edu/pub/stp/OODB/'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SMS.2.08.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Mondrian	self name: 'Mondrian'.	self version: '0.40'.	info category: 'Uncategorized'.	info description: ''.	info maintainer: 'ls'.	info homepage: 'http://mc.lukas-renggli.ch/mondrian/'.	info squeakMapID: ''.	info url: 'http://mc.lukas-renggli.ch/mondrian/Mondrian-dr.40.mcz'.	self provides: #().	self dependsOn: #('Announcements').! !!PackagesDevU methodsFor: 'Group Development' stamp: 'damiencassou 2/17/2009 18:56'!Monticello15	self name: 'Monticello15'.	self version: '1.5+'.	info category: 'Group Development'.	info description: 'Monticello - evolution - Improvements over 1.0 - Method/Class Orphanage which enables out-of-order loading of packages, and maintenance of packages whose dependencies have not been loaded.- Method Overrides (if properly categorized) are fully supported preserving the integrity of a package even if it has overridden methods- Refactored UI/repository classes so that one UI heirachy serves all.- Dual Changes Browser- In memory cache repository- Support for configurations (Please name them using the MC conventions)- Support for more complex version numbering conventions i.e. Package-kph-1.0.3.mczknown problems:methods have been known to loose their categoriesfuture:Atomic Loading loader using System Editor is already coded and contained in this release.See #theChosenLoaderClass.'.	info maintainer: 'kph <keith_hodges@yahoo.co.uk>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://installer.pbwiki.com/f/mc15.st'.	self provides: #('Monticello15' 'Installer' 'MonticelloConfigurations' 'PackageInfo-Base').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 11/28/2008 16:33'!Monticello16	self name: 'Monticello16'.	self version: '1.6+'.	info category: 'Group Development'.	info description: 'Monticello - evolution - Improvements over 1.5Monticello on speed!!'.	info maintainer: 'kph <keith_hodges@yahoo.co.uk>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://installer.pbwiki.com/f/enableAtomicLoading.st'.	self provides: #().	self dependsOn: #('Monticello15' 'SystemEditor').! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 11/12/2008 16:59'!Monticello2	self name: 'Monticello2'.	self version: '0.2'.	info category: 'Group Development'.	info description: 'Monticello is a distributed version control system.Monticello 2 addresses the problems we encountered with Monticello 1. They mostly stem from a common cause: its unit of versioning, the package, is too coarse for many situations that arise in normal development.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://wiki.squeak.org/squeak/5624'.	info squeakMapID: ''.	info url: nil.	self provides: #().	self dependsOn: #('Monticello2-Core' 'Monticello2-OmniBrowser' 'Monticello2-Squeak').! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 9/10/2008 10:09'!Monticello2Core	self name: 'Monticello2-Core'.	self version: '0.194'.	info category: 'Group Development'.	info description: 'Monticello is a distributed version control system.Monticello 2 addresses the problems we encountered with Monticello 1. They mostly stem from a common cause: its unit of versioning, the package, is too coarse for many situations that arise in normal development.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://wiki.squeak.org/squeak/5624'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Monticello2/Monticello2-dc.194.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 9/10/2008 10:09'!Monticello2OmniBrowser	self name: 'Monticello2-OmniBrowser'.	self version: '0.17'.	info category: 'Group Development'.	info description: 'Monticello is a distributed version control system.Monticello 2 addresses the problems we encountered with Monticello 1. They mostly stem from a common cause: its unit of versioning, the package, is too coarse for many situations that arise in normal development.This package provides an a browser'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://wiki.squeak.org/squeak/5624'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Monticello2/Monticello2OB-dc.17.mcz'.	self provides: #().	self dependsOn: #('Monticello2-Core' 'Monticello2-Squeak' 'OmniBrowser' 'OmniBrowser-Morphic').! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 9/10/2008 10:09'!Monticello2Squeak	self name: 'Monticello2-Squeak'.	self version: '0.62'.	info category: 'Group Development'.	info description: 'Monticello is a distributed version control system.Monticello 2 addresses the problems we encountered with Monticello 1. They mostly stem from a common cause: its unit of versioning, the package, is too coarse for many situations that arise in normal development.This package provides Squeak-specific classes.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://wiki.squeak.org/squeak/5624'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Monticello2/MC2-Squeak-dc.62.mcz'.	self provides: #().	self dependsOn: #('Monticello2-Core').! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 12/21/2008 22:12'!MonticelloConfigurations	self name: 'MonticelloConfigurations'.	self version: '1.0.52'.	info category: 'Group Development'.	info description: 'Monticello Configurations http://lists.squeakfoundation.org/pipermail/squeak-dev/2005-November/098181.html'.	info maintainer: 'kph <keith_hodges@yahoo.co.uk>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/mc/MonticelloConfigurations-kph.52.mcz'.	self provides: #('MonticelloConfigurations').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 9/10/2008 10:09'!MonticelloConfigurationsUniversesFix	self name: 'MonticelloConfigurations-UniversesFix'.	self version: 'un.33.fix.3'.	info category: 'Group Development'.	info description: 'Fixes Universes to load MonticelloConfigurations, and to handle "provides" field.Patch Monticello, (trivial additions) so that MonticelloConfigurations and patched Universes works without needing Monticello1.5 '.	info maintainer: 'kph <keith_hodges@yahoo.co.uk>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://installer.pbwiki.com/f/UniversesMCAndProvidesPatch.3.cs'.	self provides: #('MonticelloConfigurations-UniversesFix').	self dependsOn: #().! !!PackagesDevU methodsFor: 'web development' stamp: 'damiencassou 1/21/2009 13:12'!Morphlepackagesbeta	self name: 'Morphle packages beta'.	self version: '0.1'.	info category: 'web development'.	info description: 'the dependenties to generate the Morphle Squeak web image'.	info maintainer: 'Merik Voswinkel'.	info homepage: 'http://morphle.org/'.	info squeakMapID: ''.	info url: nil.	self provides: #().	self dependsOn: #('squeak web packages').! !!PackagesDevU methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!MorseCode	self name: 'Morse Code'.	self version: '2'.	info category: 'Uncategorized'.	info description: 'Send messages in morse code. Set the character speed and pitch, thenstart sending messages. Uses QueueSound class.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/MorseCode.02.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/4/2009 16:57'!Mse	self name: 'Mse'.	self version: '1.1.10'.	info category: 'Development'.	info description: 'MSE file format to exchange data of meta-metamodels, metamodels and models.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://smallwiki.unibe.ch/fame/mse'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/mse/Mse-lr.10.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Morphs' stamp: 'kph 9/10/2008 10:09'!MultiColumnListMorph	self name: 'MultiColumn List Morph'.	self version: '6'.	info category: 'Morphs'.	info description: 'MultiColumnListMorph (and its related StackedStringMorph) are competitors for PluggableMultiColumnListMorph.  The speed is substantially faster than the the standard Pluggable... hieararchy, and there are some additional features (most notably the ability to add a header for the list).  Currently, this morph only takes arrays of arrays of strings as arguments.Please look at the class side of MultiColumnListMorph for examples.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/MultiColumn%20Lists-cbc.6.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!MysqlDriver	self name: 'Mysql Driver'.	self version: '1.13'.	info category: 'Persistence'.	info description: '- Compatible with new Mysql 4.1/5x authentication and resultset changes.- Should also work with 4.1/5x with old (short) password table.- May still work with Mysql 4.0 and below.- Fixed float conversion not to use ''+'', eg ''3.041234e+23'' n/g in Squeak 3.8.- Added an Integer type used in Mysql 5.x.- Test suites upgraded, eg factored connectionSpec 4 ez changing.'.	info maintainer: 'alan reider <squeakdev@reider.net>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://squeak.reider.net/mysql/Mysql-alnr.12.mcz'.	self provides: #('Mysql Driver').	self dependsOn: #('Cryptography').! !!PackagesDevU methodsFor: 'Tools' stamp: 'kph 9/10/2008 10:09'!NamespaceTools	self name: 'NamespaceTools'.	self version: '36'.	info category: 'Tools'.	info description: 'This is a "Toolset" currently consisting of a NamespaceBrowser, NamespaceWorkspace and a PackageManager.This package is only of use to curious programmers and is not ready for general consumption. To try it out, type "NamespaceExamples openPackageManager".This version is strictly for adventurous developers only; it is very buggy. Documentation is at http://gulik.pbwiki.com/Namespaces'.	info maintainer: 'Michael van der Gulik'.	info homepage: 'http://gulik.pbwiki.com/Namespaces'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SecureSqueak/NamespaceTools-mvdg.36.mcz'.	self provides: #().	self dependsOn: #('Namespaces' 'PlusTools').! !!PackagesDevU methodsFor: 'System' stamp: 'kph 9/10/2008 10:09'!Namespaces	self name: 'Namespaces'.	self version: '46'.	info category: 'System'.	info description: 'You don''t actually want to load this package; you want to load "NamespaceTools" under the Tools category.This package provides the core infrastructure for hierarchical namespaces in Squeak.Note that this is an "experimental" package and is intended for use by curious programmers only.'.	info maintainer: 'Michael van der Gulik, mikevdg@gulik.co.nz'.	info homepage: 'http://www.squeaksource.com/SecureSqueak'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SecureSqueak/Namespaces-mvdg.46.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!NetStrings	self name: 'NetStrings'.	self version: '1.0'.	info category: 'Persistence'.	info description: 'This is an implementation of the Netstring protocol as defined here: http://cr.yp.to/proto/netstrings.txt (by D. J. Bernstein, djbpobox.com). It adds the ability to read and write Netstrings onto any byte or character stream. Integer, ByteArray, and String can be converted to or from a Netstring. See the methods added to those classes (instance and class methods). Netstrings are handy for creating network protocols.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/NetStrings.st'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!NetworkHTML	self name: 'Network-HTML'.	self version: '4'.	info category: 'Uncategorized'.	info description: 'An HTML parser and formatter.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Network-HTML-md.4.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!NewCompiler	self name: 'NewCompiler'.	self version: '281'.	info category: 'Development'.	info description: 'The new Compiler, based on the ClosureCompiler'.	info maintainer: 'Mathieu Suen <mathieusuen@yahoo.fr>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/NewCompiler/NewCompiler-md.281.mcz'.	self provides: #().	self dependsOn: #('AST' 'NewParser').! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!NewParser	self name: 'NewParser'.	self version: '5'.	info category: 'Development'.	info description: 'A smalltalk parser the generate AST from the AST project.it also can parse pragmas and comments'.	info maintainer: 'Mathieu Suen <mathieusuen@yahoo.fr>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://squeaksource.com/AST/NewParser-ms.5.mcz'.	self provides: #().	self dependsOn: #('AST' 'SmaCC runtime').! !!PackagesDevU methodsFor: 'Fonts' stamp: 'kph 9/30/2008 16:20'!Nicefonts	self name: 'Nice fonts'.	self version: '0.6'.	info category: 'Fonts'.	info description: 'From Juan Vuletich: One of the very few things I don''t like in Squeak is font support. I''m used to nice sub pixel rendered text. I find StrikeFonts and TTFFonts in Squeak equally ugly on LCD monitors. I have been a long time admirer of Henrik Gedenryd''s FreeType work, now continued by Andy Tween. But Andy''s work requires linking the FreeType library, and a new BitBlt plugin with newer modes to work. Something smaller and simpler needs to be done!!Once installed, execute the following line to install the new fonts. It may take some time so be patient. Also ensure that the ''display depth'' of your image is set to 32 (World menu->appearance->set display depth...).StrikeFont new installNiceFonts'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.jvuletich.org/NiceFonts.html'.	info squeakMapID: ''.	info url: 'http://damien.cassou.free.fr/squeak-dev/fonts/AAStrikeFonts.15.cs'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'damiencassou 2/17/2009 18:56'!Nile	self name: 'Nile'.	self version: '1.0.143'.	info category: 'Model Extension'.	info description: 'Nile is a complete reimplementation of the squeak stream hierarchy. It provides:    * traits for code reuse.    * lots of tests: same tests are used for the squeak stream hierarchy and Nile (they are implemented in traits).    * lots of clients to verify the reusability.    * a diagram of the implementation: http://damien.cassou.free.fr/documents/internship_2007/nile/complete_hierarchy.pdf '.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.squeaksource.com/Nile/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Nile/Nile-All-damiencassou.143.mcz'.	self provides: #().	self dependsOn: #('Nile-Base' 'Nile-Clients' 'Nile-Tests').! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'damiencassou 2/17/2009 18:56'!NileBase	self name: 'Nile-Base'.	self version: '1.0.63'.	info category: 'Model Extension'.	info description: 'Nile is a complete reimplementation of the squeak stream hierarchy. It provides:    * traits for code reuse.    * lots of tests: same tests are used for the squeak stream hierarchy and Nile (they are implemented in traits).    * lots of clients to verify the reusability.    * a diagram of the implementation: http://damien.cassou.free.fr/documents/internship_2007/nile/complete_hierarchy.pdf '.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.squeaksource.com/Nile/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Nile/Nile-Base-damiencassou.63.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'damiencassou 2/17/2009 18:56'!NileClients	self name: 'Nile-Clients'.	self version: '101'.	info category: 'Model Extension'.	info description: 'Nile is a complete reimplementation of the squeak stream hierarchy. It provides:    * traits for code reuse.    * lots of tests: same tests are used for the squeak stream hierarchy and Nile (they are implemented in traits).    * lots of clients to verify the reusability.    * a diagram of the implementation: http://damien.cassou.free.fr/documents/internship_2007/nile/complete_hierarchy.pdf '.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.squeaksource.com/Nile/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Nile/Nile-Clients-damiencassou.101.mcz'.	self provides: #().	self dependsOn: #('Nile-Base' 'Nile-Tests').! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'damiencassou 2/17/2009 18:56'!NileTests	self name: 'Nile-Tests'.	self version: '1.0.73'.	info category: 'Model Extension'.	info description: 'Nile is a complete reimplementation of the squeak stream hierarchy. It provides:    * traits for code reuse.    * lots of tests: same tests are used for the squeak stream hierarchy and Nile (they are implemented in traits).    * lots of clients to verify the reusability.    * a diagram of the implementation: http://damien.cassou.free.fr/documents/internship_2007/nile/complete_hierarchy.pdf '.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.squeaksource.com/Nile/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Nile/Nile-Tests-damiencassou.73.mcz'.	self provides: #().	self dependsOn: #('Nile-Base').! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'kph 9/10/2008 10:09'!Null	self name: 'Null'.	self version: '0.14'.	info category: 'Model Extension'.	info description: 'Message Eating Null package for Squeak.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://wiki.squeak.org/squeak/5962'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Null/Null-kph.14.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Mathematics' stamp: 'kph 11/2/2008 00:30'!Numerics	self name: 'Numerics'.	self version: '4'.	info category: 'Mathematics'.	info description: 'Linear algebra classes for matrix and vector.Supports all basic operations and:- Solving of linear equations- Fast matrix determinants- LU decomposition (with pivoting)- Matrix inversion - Kronecker multiplication- Schur complement- Adjoint- Cofactor- Minor'.	info maintainer: 'Ramiro Diaz Trepat <ramirodt@gmail.com>'.	info homepage: 'http://www.squeaksource.com/Numerics.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Numerics/Numerics-rdt.29.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'damiencassou 2/4/2009 16:57'!OBEnhancements	self name: 'OB-Enhancements'.	self version: '0.292'.	info category: 'Code Browsing'.	info description: 'OB-Enhancements extend the OmniBrowser framework with new features such as multiple selection of elements in columns, a package-based view on the image instead of using just class categories, or smart groups to categorize source artifacts.This package requires the latest version of the OmniBrowser framework.'.	info maintainer: 'David Röthlisberger'.	info homepage: 'http://source.wiresong.ca/ob/'.	info squeakMapID: ''.	info url: 'http://source.wiresong.ca/ob/OB-Enhancements-dr.292.mcz'.	self provides: #().	self dependsOn: #('OmniBrowser' 'OmniBrowser-Morphic' 'OmniBrowser-Standard').! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 12/21/2008 22:12'!OBMonticello	self name: 'OB-Monticello'.	self version: '0.67'.	info category: 'Group Development'.	info description: 'OB-Monticello contains an implementation of the Monticello tools based on OmniBrowser. MCPackageBrowser is equivalent to the Morphic Monticello Browser. MCAllRepositoryBrowser is a new tool that provides most of your day to day in a single window.'.	info maintainer: 'Dale Henrichs'.	info homepage: 'http://source.wiresong.ca/ob/'.	info squeakMapID: ''.	info url: 'http://source.wiresong.ca/ob/OB-Monticello-dkh.67.mcz'.	self provides: #().	self dependsOn: #('OmniBrowser' 'OmniBrowser-Morphic').! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 9/10/2008 10:09'!OBProtocolBrowser	self name: 'OBProtocolBrowser'.	self version: '0.19'.	info category: 'Code Browsing'.	info description: 'This is an implementation of the Protocol Browser using the OmniBrowser framework.Authors: 	Duncan Mak <duncanmak@gmail.com>	Juraj Kubelka <Juraj.Kubelka@gmail.com>'.	info maintainer: 'Duncan Mak <duncanmak@gmail.com>'.	info homepage: 'http://www.squeaksource.com/OBProtocolBrowser.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/OBProtocolBrowser/OBProtocolBrowser-DM.19.mcz'.	self provides: #().	self dependsOn: #('OmniBrowser-Standard').! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!ODBC	self name: 'ODBC'.	self version: '2'.	info category: 'Persistence'.	info description: 'Very simple framework for ODBC support in Squeak. Use FFI to talk to ODBC32.dll, no other DLL is necessary.It works in Windows and in Unix.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://wiki.squeak.org/squeak/uploads/2480/ODBC-dgd.10.cs.gz'.	self provides: #().	self dependsOn: #('FFI').! !!PackagesDevU methodsFor: 'System' stamp: 'kph 11/28/2008 16:26'!OSProcess	self name: 'OSProcess'.	self version: 'V4-3-7'.	info category: 'System'.	info description: 'OSProcess provides access to the external operating system from Squeak. Plugins are provided for Unix, Linux, and Windows systems (loaded separately from SqueakMap packages). OSProcess can be loaded on other platforms as well, and placeholder classes are provided in the OSProcess hierarchy for other operating systems (Mac, OS/2, RiscOS), although support for these systems is not yet implemented. Load CommandShell for additional OSProcess functions, including class PipeableOSProcess, which allows reading from and writing to external processes through OS pipe streams.'.	info maintainer: 'lewis'.	info homepage: 'http://wiki.squeak.org/squeak/708'.	info squeakMapID: ''.	info url: 'http://wiki.squeak.org/squeak/uploads/708/OSProcessV4-3-7.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'System' stamp: 'kph 9/10/2008 10:09'!OSProcessIO	self name: 'OSProcessIO'.	self version: '0.3'.	info category: 'System'.	info description: 'An intermediate layer between OSProcess and another application.Used for Smagick and FoPDF to simplify IO-feebacks with the command shell (likely to get enhanced or obsolete in the future)changes to 0.2:- bugfixes'.	info maintainer: 'Stefan Reichhart <stefan.reichhart@gmx.ch>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SqueakAddOns/OSProcessIO-SR.16.mcz'.	self provides: #().	self dependsOn: #('OSProcess').! !!PackagesDevU methodsFor: 'System' stamp: 'kph 11/2/2008 00:30'!OSProcessPlugin	self name: 'OSProcessPlugin'.	self version: '4.2.7a.1'.	info category: 'System'.	info description: 'OSProcessPlugin (OSPP) provides access to Unix/Linux and Windows operating system functions. OSPP is used by OSProcess for low level system access. Stub classes are provided for other operating systems (porting assistance welcome). OSProcessPlugin contains the complete source code for the Unix and Windows OSProcessPlugin (OSPP). Generate the plugin with VMMaker. No external support code is required.(Bryce added a dependency to VMMaker so this will load in a fresh image)'.	info maintainer: 'Dave Lewis'.	info homepage: 'http://wiki.squeak.org/squeak/3349'.	info squeakMapID: ''.	info url: 'http://wiki.squeak.org/squeak/uploads/3349/OSProcessPluginV4-2-6.sar'.	self provides: #().	self dependsOn: #('VMMaker').! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!ObjectFinder	self name: 'ObjectFinder'.	self version: '0.2'.	info category: 'Development'.	info description: 'A new object inspector for Squeak based on OmniBrowser. Why Finder ? Because you can explore your object like in the OS X Finder !! This tool permits to explore easy an object and its linked objects (and their linked objects and ...) but it is overall extensible. Subclass OFObjectNode, add a method #asNodeWithName: and you have a personal inspector for your project !! A simple option in the Preference panel permits to enable/disable the replacement of the old inspector by this new one. Have fun !! See http://decomp.ulb.ac.be/frdricpluquet/personalstuff/theobjectfinder/ for more information. Please, send me a mail when you really use it :-) (Just to have some feed back)'.	info maintainer: 'PF'.	info homepage: 'http://decomp.ulb.ac.be/frdricpluquet/personalstuff/theobjectfinder/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ObjectFinder/ObjectFinder-PF.16.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'damiencassou 2/4/2009 16:57'!OmniBrowser	self name: 'OmniBrowser'.	self version: '0.436'.	info category: 'Code Browsing'.	info description: 'OmniBrowser is a ground up rewrite of the classical system browsers providedin Smalltalk. It''s designed to be flexible and extensible, so as to encourageexperimentation with new types of development tools, language extensions,and runtime environments. In fact it''s a framework to build browsers. Install OmniBrowser-Standard to get the new browser using this framework.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://source.wiresong.ca/ob/'.	info squeakMapID: '81451b19-7df8-4fc7-8652-b26cc55dd291'.	info url: 'http://source.wiresong.ca/ob/OmniBrowser-dr.436.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'IDE' stamp: 'kph 9/10/2008 10:09'!OmniBrowserAlgernon	self name: 'OmniBrowser-Algernon'.	self version: '0.5'.	info category: 'IDE'.	info description: ''.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://source.wiresong.ca/ob/OB-Algernon-EL.5.mcz'.	self provides: #().	self dependsOn: #('Algernon' 'OmniBrowser-Standard').! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 11/12/2008 16:59'!OmniBrowserFull	self name: 'OmniBrowser-Full'.	self version: '0.27'.	info category: 'Code Browsing'.	info description: 'OmniBrowser is a ground up rewrite of the classical system browsers provided in Smalltalk. It''s designed to be flexible and extensible, so as to encourage experimentation with new types of development tools, language extensions, and runtime environments. In fact it''s a framework to build browsers.This packages installs OmniBrowser, a rewrite of the system browser using OmniBrowser and fixes to make things work with new Squeak versions.'.	info maintainer: 'Damien Cassou'.	info homepage: 'http://source.wiresong.ca/ob/'.	info squeakMapID: ''.	info url: nil.	self provides: #().	self dependsOn: #('OB-Enhancements' 'OmniBrowser' 'OmniBrowser-Morphic' 'OmniBrowser-Standard').! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'damiencassou 2/4/2009 16:57'!OmniBrowserMorphic	self name: 'OmniBrowser-Morphic'.	self version: '0.74'.	info category: 'Code Browsing'.	info description: 'OB-Standard represents the classical system browser implemented with the OmniBrowser framework.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://source.wiresong.ca/ob/'.	info squeakMapID: ''.	info url: 'http://source.wiresong.ca/ob/OB-Morphic-dr.74.mcz'.	self provides: #().	self dependsOn: #('OmniBrowser' 'OmniBrowser-Standard').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/18/2009 13:29'!OmniBrowserRefactory	self name: 'OmniBrowser-Refactory'.	self version: '129'.	info category: 'Development'.	info description: 'Brings refactorings to OmniBrowser'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/omnibrowser/OB-Refactory-lr.129.mcz'.	self provides: #().	self dependsOn: #('OmniBrowser-Morphic' 'OmniBrowser-Standard' 'Refactoring Core' 'Refactoring Spelling').! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/30/2008 16:20'!OmniBrowserRegex	self name: 'OmniBrowser-Regex'.	self version: '0.9.1'.	info category: 'Development'.	info description: 'Brings refactorings to OmniBrowser'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/omnibrowser/OB-Regex-lr.9.mcz'.	self provides: #().	self dependsOn: #('OmniBrowser-Refactory' 'OmniBrowser-Standard' 'Refactoring Core' 'VBRegex').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/4/2009 16:57'!OmniBrowserSUnitGUI	self name: 'OmniBrowser-SUnit-GUI'.	self version: '0.52'.	info category: 'Development'.	info description: 'OmniBrowser-based implementation of TestRunner. Expects SUnit to be already loaded'.	info maintainer: 'Dale Henrichs'.	info homepage: 'http://seaside.gemstone.com/ss/obsunit.html'.	info squeakMapID: ''.	info url: 'http://seaside.gemstone.com/ss/obsunit/OB-SUnitGUI-dkh.52.mcz'.	self provides: #('OmniBrowser-SUnit-GUI').	self dependsOn: #('OmniBrowser' 'OmniBrowser-Morphic' 'OmniBrowser-Standard').! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 11/12/2008 16:59'!OmniBrowserSUnitIntegration	self name: 'OmniBrowser-SUnitIntegration'.	self version: '1 obsolete'.	info category: 'Code Browsing'.	info description: 'Obsolete. Merged into OB-Enhancements'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: nil.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'damiencassou 2/5/2009 16:16'!OmniBrowserStandard	self name: 'OmniBrowser-Standard'.	self version: '0.389'.	info category: 'Code Browsing'.	info description: 'OB-Standard represents the classical system browser implemented with the OmniBrowser framework.'.	info maintainer: 'Colin Putney'.	info homepage: 'http://source.wiresong.ca/ob/'.	info squeakMapID: ''.	info url: 'http://source.wiresong.ca/ob/OB-Standard-dr.389.mcz'.	self provides: #().	self dependsOn: #('OmniBrowser').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/4/2009 16:57'!OmniBrowserTools	self name: 'OmniBrowser-Tools'.	self version: '0.60'.	info category: 'Development'.	info description: 'Set of tools (debugger, inspector...) rewritten on top of the OmniBrowser framework.'.	info maintainer: 'Dale Henrichs <dale.henrichs@gemstone.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/omnibrowser/OB-Tools-EL.60.mcz'.	self provides: #().	self dependsOn: #('OmniBrowser-Standard').! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 11/12/2008 16:59'!OmniBrowserTraitsIntegration	self name: 'OmniBrowser-TraitsIntegration'.	self version: '1 obsolete'.	info category: 'Code Browsing'.	info description: 'Obsolete. Has been merged into OB-Enhancements'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: nil.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Office' stamp: 'kph 9/10/2008 10:09'!OpenOfficeImporter	self name: 'OpenOffice Importer'.	self version: '17'.	info category: 'Office'.	info description: 'Squeak is the new media. To be the new media Squeak has to give us the option to convert a lot already created documents.OpenOffice is an open source project and its format is well specified and it''s based on XML and Zip (see http://xml.openoffice.org). OpenOffice also has a lot of good job to handle propietary formats so, importing OO format, we''ll able to import really a lot of content.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/3624'.	info squeakMapID: ''.	info url: 'http://map.squeak.org/accountbyid/7670b859-735e-4027-b5cd-db4b61bac95e/files/OpenOffice-Importer-dgd.17.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!PWS	self name: 'PWS'.	self version: '0.2gt1'.	info category: 'Network'.	info description: 'The Pluggable WebServer (PWS) is a web server and toolkit for flexibly creating CGI scripts. Mark Guzdial designed and implemented it to help him create different kinds of collaborative tools: e.g. Virtual Other-Than-Communities. PWS builds on the work of Georg Gollmann and Tim Jones.PWS is mostly obsolete now, and is superseded by the newer Comanche web server.This version of PWS has been slightly modified:	1. It replaces all uses of getData by receiveData in order to pevent a crash.	2. The default setting of serverDirectory is the current directory.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/PWS-0.2gt1.st.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 12/21/2008 22:12'!PackagesLibrary	self name: 'Packages-Library'.	self version: '0'.	info category: 'Group Development'.	info description: 'The definitive library of Package definitions for all squeak images.Please contribute your knowledge of what works where.thanks in advanceKeith'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://wiki.squeak.org/squeak/5953'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Packages/Packages-Library-kph.14.mcz'.	self provides: #('Packages-Library').	self dependsOn: #('Sake-Packages').! !!PackagesDevU methodsFor: 'Distributions' stamp: 'damiencassou 2/17/2009 18:56'!Pharopackages	self name: 'Pharo packages'.	self version: '0.13'.	info category: 'Distributions'.	info description: 'This package generates a Pharo image prepared for end-users from a Pharo core.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://code.google.com/p/pharo/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ImageForDevelopers/ImageForDevelopers-pharo-damiencassou.173.mcz'.	self provides: #().	self dependsOn: #('AutomaticMethodCategorizerOB' 'Installer' 'Nile' 'OB-Enhancements' 'OmniBrowser-Refactory' 'OmniBrowser-Regex' 'OmniBrowser-Tools' 'Shout' 'ShoutWorkspace' 'Universes' 'Universes OmniBrowser' 'eCompletion' 'eCompletion-Traits' 'eCompletionOmniBrowser').! !!PackagesDevU methodsFor: 'Morphs' stamp: 'kph 9/10/2008 10:09'!PieChartMorph	self name: 'PieChartMorph'.	self version: '0.2'.	info category: 'Morphs'.	info description: ''.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/PieChartMorph-gm.5.cs'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!Pier	self name: 'Pier'.	self version: 'current'.	info category: 'Web Development'.	info description: 'Pier with some common plugins. A good package to get started with Pier development or deployment.'.	info maintainer: 'lr'.	info homepage: 'http://www.lukas-renggli.ch/smalltalk/pier'.	info squeakMapID: ''.	info url: nil.	self provides: #().	self dependsOn: #('Magritte-Tests' 'Pier-Blog' 'Pier-Documents' 'Pier-EditorEnh' 'Pier-Seaside' 'Pier-Security' 'Pier-Tests').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!PierBlog	self name: 'Pier-Blog'.	self version: '1.1.103'.	info category: 'Web Development'.	info description: 'Pier blog plugin.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pier/Pier-Blog-lr.103.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside' 'RSRSS2').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 9/10/2008 10:09'!PierCommandsRemoveChildren	self name: 'Pier-Commands-RemoveChildren'.	self version: '1.0.14.2'.	info category: 'Web Development'.	info description: 'Additional command for pier for removing nominated children'.	info maintainer: 'kph'.	info homepage: 'http://mc.lukas-renggli.ch/pieraddons.html'.	info squeakMapID: ''.	info url: 'http://mc.lukas-renggli.ch/pieraddons/Pier-Commands-RemoveChildren-kph.2.mcz'.	self provides: #().	self dependsOn: #('Pier-Model').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!PierDesign	self name: 'Pier-Design'.	self version: '1.1.5'.	info category: 'Web Development'.	info description: 'Enabled design editing tools in the context of the applied page.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pieraddons/Pier-Design-tg.5.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!PierDocuments	self name: 'Pier-Documents'.	self version: '1.1.7'.	info category: 'Web Development'.	info description: 'Provide additional documents on a praticular structure, for example to add a side-bar. Custom documents can inherit from the parent and/or provide a default document.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pieraddons/Pier-Documents-lr.7.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!PierEditorEnh	self name: 'Pier-EditorEnh'.	self version: '1.1.17'.	info category: 'Web Development'.	info description: 'Pier editor enhancement plugin.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pieraddons/Pier-EditorEnh-damiencassou.17.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!PierGoogle	self name: 'Pier-Google'.	self version: '1.1.6'.	info category: 'Web Development'.	info description: 'Integration of Google services into Pier.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pieraddons/Pier-Google-lr.6.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 9/10/2008 10:09'!PierJetsamEnvironment	self name: 'Pier-Jetsam-Environment'.	self version: '1.0.16.7'.	info category: 'Web Development'.	info description: 'Provides centralized initialization and control of whole pier layout/style policies for the root frame component.'.	info maintainer: 'kph'.	info homepage: 'http://mc.lukas-renggli.ch/pieraddons.html'.	info squeakMapID: ''.	info url: 'http://mc.lukas-renggli.ch/pieraddons/Pier-Jetsam-Environment-kph.7.mcz'.	self provides: #().	self dependsOn: #('Pier-Model' 'Seaside28Jetsam-Blueprint' 'Seaside28Jetsam-NiftyCorners' 'Seaside28Jetsam-Supersleight' 'Seaside28Jetsam-Useful-CSS').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!PierLightBox	self name: 'Pier-LightBox'.	self version: '1.1.6'.	info category: 'Web Development'.	info description: 'Pier lightbox plugin.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pieraddons/Pier-LightBox-dc.6.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!PierLinks	self name: 'Pier-Links'.	self version: '1.1.2'.	info category: 'Web Development'.	info description: 'Pier links for YouTube, Vimeo and SlideShare'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pieraddons/Pier-Links-damiencassou.2.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 9/10/2008 10:09'!PierMagma	self name: 'Pier-Magma'.	self version: '1.38'.	info category: 'Web Development'.	info description: 'Extension to pier providing Magma persistence'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://www.lukas-renggli.ch/smalltalk/pier'.	info squeakMapID: ''.	info url: 'http://mc.lukas-renggli.ch/pier/Pier-Magma-kph.38.mcz'.	self provides: #('Pier-Magma').	self dependsOn: #('Magma seasideHelper' 'Pier-Model').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 9/10/2008 10:09'!PierMagmabeta	self name: 'Pier-Magma-beta'.	self version: '1.0.9-alpha.35'.	info category: 'Web Development'.	info description: 'Extension to pier providing Magma persistence'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://www.lukas-renggli.ch/smalltalk/pier'.	info squeakMapID: ''.	info url: 'http://mc.lukas-renggli.ch/pier/Pier-Magma-kph.35.mcz'.	self provides: #('Pier-Magma-beta').	self dependsOn: #('Magma Seaside-alpha').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!PierMath	self name: 'Pier-Math'.	self version: '1.1.6'.	info category: 'Web Development'.	info description: 'Pier LaTeX math mode plugin.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pieraddons/Pier-Math-lr.6.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/5/2009 16:16'!PierModel	self name: 'Pier-Model'.	self version: '1.1.263'.	info category: 'Development'.	info description: 'Pier is a powerful and extensible implementation of a meta-described content management and Wiki system, written with objects from top to bottom: (1) Object-Oriented Design: Pier features a fully object oriented and meta-described domain model. As an example, the content of the pages is parsed and stored as a tree of different entities representing text, links, tables, lists, etc. (2) Extensibility: Everything in Pier can be extended: page types, storage mechanism, actions, security mechanism, web-server, etc. Plug-ins can be shared within the community and loaded independently of each other into the system. (3) Open Source: Pier is released under the MIT license which grants unrestricted rights to copy, modify, and redistribute as long as the original copyright and license terms are retained. (4) Test Suites: Pier is heavily tested. There are more than 1200 unit tests included with the core of Pier. This makes it easy to change and verify the code and comes in extremely useful when porting Pier to other Smalltalk dialects or when writing extensions.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pier/Pier-Model-lr.263.mcz'.	self provides: #().	self dependsOn: #('Magritte-Model').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/4/2009 16:57'!PierOmniBrowser	self name: 'Pier-OmniBrowser'.	self version: '1.1.35'.	info category: 'Development'.	info description: 'Pier bindings for OmniBrowser.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pier/Pier-OmniBrowser-lr.35.mcz'.	self provides: #().	self dependsOn: #('Magritte-Morph' 'OmniBrowser-Full' 'Pier-Model').! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!PierPersistencyManager	self name: 'Pier-PersistencyManager'.	self version: '1.0.16/16'.	info category: 'Development'.	info description: 'Pier persistency mechanisms for Squeak.'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://www.lukas-renggli.ch/smalltalk/pier'.	info squeakMapID: ''.	info url: 'http://mc.lukas-renggli.ch/pier/Pier-PersistencyManager-kph.16.mcz'.	self provides: #().	self dependsOn: #('Pier-Model').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!PierRandomizer	self name: 'Pier-Randomizer'.	self version: '1.1.4'.	info category: 'Web Development'.	info description: 'Pier randomizer plugin.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pieraddons/Pier-Randomizer-lr.4.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/5/2009 16:16'!PierSeaside	self name: 'Pier-Seaside'.	self version: '1.1.331'.	info category: 'Web Development'.	info description: 'Pier bindings for Seaside.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pier/Pier-Seaside-lr.331.mcz'.	self provides: #().	self dependsOn: #('Magritte-Seaside' 'Pier-Model' 'Scriptaculous' 'Seaside').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/5/2009 16:16'!PierSecurity	self name: 'Pier-Security'.	self version: '1.1.119'.	info category: 'Web Development'.	info description: 'Pier Unix security plugin.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pier/Pier-Security-lr.119.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside' 'Pier-Tests').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/5/2009 16:16'!PierSetup	self name: 'Pier-Setup'.	self version: '1.1.35'.	info category: 'Web Development'.	info description: 'Metapackage that loads a common collection of Pier plugins, and a helper class to instantiate the one-click experience.'.	info maintainer: 'Tudor Girba <tudor.girba@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pieraddons/Pier-Setup-tg.35.mcz'.	self provides: #().	self dependsOn: #('Pier-Blog' 'Pier-Design' 'Pier-Documents' 'Pier-EditorEnh' 'Pier-Google' 'Pier-Links' 'Pier-Randomizer' 'Pier-Security' 'Pier-Shout' 'Pier-Sitemap' 'Pier-TagCloud' 'Pier-Titles').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!PierShout	self name: 'Pier-Shout'.	self version: '1.1.10'.	info category: 'Web Development'.	info description: 'Pier Smalltalk syntax highlighting plugin.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pieraddons/ShoutPier-lr.10.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside' 'Shout').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!PierSitemap	self name: 'Pier-Sitemap'.	self version: '1.1.20'.	info category: 'Web Development'.	info description: 'Creates a Google and Yahoo Sitemap definitions.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pieraddons/Sitemap-pmm.20.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside' 'YAXO').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/5/2009 16:16'!PierSqueakPersistency	self name: 'Pier-Squeak-Persistency'.	self version: '1.1.11'.	info category: 'Development'.	info description: 'Pier persistency mechanisms for Squeak.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pier/Pier-Squeak-Persistency-lr.11.mcz'.	self provides: #().	self dependsOn: #('Pier-Model' 'Pier-Tests').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/17/2009 18:56'!PierTabbedPagesWidgets	self name: 'Pier-TabbedPagesWidgets'.	self version: '1.0.14.6'.	info category: 'Web Development'.	info description: 'Widget providing tabbed folders display of tagged pages'.	info maintainer: 'kph'.	info homepage: 'http://mc.lukas-renggli.ch/pieraddons.html'.	info squeakMapID: ''.	info url: 'http://mc.lukas-renggli.ch/pieraddons/Pier-TabbedPagesWidgets-kph.5.mcz'.	self provides: #().	self dependsOn: #('M7284-firsOrNil' 'Pier-Model').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!PierTagCloud	self name: 'Pier-TagCloud'.	self version: '1.1.11'.	info category: 'Web Development'.	info description: 'Pier tag cloud plugin.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pieraddons/Pier-TagCloud-lr.11.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/5/2009 16:16'!PierTests	self name: 'Pier-Tests'.	self version: '1.1.116'.	info category: 'Development'.	info description: 'Pier SUnit tests.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pier/Pier-Tests-lr.116.mcz'.	self provides: #().	self dependsOn: #('Magritte-Tests' 'Pier-Model').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/4/2009 16:57'!PierTitles	self name: 'Pier-Titles'.	self version: '1.1.1'.	info category: 'Web Development'.	info description: 'A set of widgets to control the title of a page.'.	info maintainer: 'Tudor Girba <tudor.girba@gmail.com>'.	info homepage: 'http://www.piercms.com/'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/pieraddons/Pier-Titles-tg.1.mcz'.	self provides: #().	self dependsOn: #('Pier-Seaside').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 9/10/2008 10:09'!PlotKit	self name: 'PlotKit'.	self version: '0.9.1.27'.	info category: 'Web Development'.	info description: 'Seaside goodies. Includes different charts libraries and other cool stuff for seaside applications. SeaChart components are standard Seaside components that you can embed into your Seaside application.Seaside bindings for PlotKit (http://www.liquidx.net/plotkit). PlotKit is a Chart and Graph Plotting Library for Javascript.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://seachart.seasidehosting.st/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/seachart/PlotKit-0.9.1-mb.27.mcz'.	self provides: #().	self dependsOn: #('Seaside').! !!PackagesDevU methodsFor: 'Morphs' stamp: 'kph 9/10/2008 10:09'!PlotMorph	self name: 'Plot Morph'.	self version: '3'.	info category: 'Morphs'.	info description: 'Morph to draw XY plots. See the methods testXXX in the class side.Try with:    PlotMorph test.    PlotMorph test2.    PlotMorph test4.    PlotMorph testWithReferences.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/PlotMorph3-dgd.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Tools' stamp: 'kph 9/10/2008 10:09'!PlusTools	self name: 'PlusTools'.	self version: '37.3'.	info category: 'Tools'.	info description: 'This is the PlusTools package, an implementation of the Smalltalk tools (Browser, Inspecter, etc) written to use ToolBuilder.Note that this package is quite unstable and is "unfinished".This version specifically requires ToolBuilder-Morphic; this will be fixed in a later release.'.	info maintainer: 'Michael van der Gulik'.	info homepage: 'http://www.squeaksource.com/PlusTools'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SecureSqueak/PlusTools-mvdg.37.mcz'.	self provides: #().	self dependsOn: #('ToolBuilder-Examples' 'ToolBuilder-Morphic').! !!PackagesDevU methodsFor: 'User Interface' stamp: 'kph 11/28/2008 16:26'!PolymorphEventEnhancements	self name: 'Polymorph EventEnhancements'.	self version: '1.1'.	info category: 'User Interface'.	info description: 'Basic extension to the event system providing for recurisve short-circuit event handling (avoiding re-entry). Along with the same for "shared" events.'.	info maintainer: 'Gary Chambers'.	info homepage: 'http://wiki.squeak.org/squeak/6005'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/UIEnhancements/Polymorph-EventEnhancements-gvc.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'User Interface' stamp: 'damiencassou 1/21/2009 13:12'!PolymorphGeometry	self name: 'Polymorph Geometry'.	self version: '1.1'.	info category: 'User Interface'.	info description: 'Basic models of shapes. Used in Diff Tools.'.	info maintainer: 'Gary Chambers'.	info homepage: 'http://wiki.squeak.org/squeak/6005'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/UIEnhancements/Polymorph-Geometry-gvc.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'User Interface' stamp: 'kph 9/30/2008 16:20'!PolymorphTaskbarIcons	self name: 'Polymorph TaskbarIcons'.	self version: '1.0'.	info category: 'User Interface'.	info description: 'Taskbar/window icons for common windows.'.	info maintainer: 'Gary Chambers'.	info homepage: 'http://wiki.squeak.org/squeak/6005'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/UIEnhancements/Polymorph-TaskbarIcons-gvc.1.mcz'.	self provides: #().	self dependsOn: #('Polymorph Widgets').! !!PackagesDevU methodsFor: 'User Interface' stamp: 'damiencassou 1/21/2009 13:12'!PolymorphToolBuilder	self name: 'Polymorph ToolBuilder'.	self version: '1.2'.	info category: 'User Interface'.	info description: 'Integrates Polymorph widgets with Squeak''s development environment via UIManager.'.	info maintainer: 'Gary Chambers'.	info homepage: 'http://wiki.squeak.org/squeak/6005'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/UIEnhancements/Polymorph-ToolBuilder-gvc.4.mcz'.	self provides: #().	self dependsOn: #('Polymorph Widgets').! !!PackagesDevU methodsFor: 'User Interface' stamp: 'damiencassou 2/10/2009 14:55'!PolymorphToolsDiff	self name: 'Polymorph Tools Diff'.	self version: '1.3'.	info category: 'User Interface'.	info description: 'Provides side-by-side code comaprison with cross-links indicating changes between lines of text. Highlight "intra-line" changes also.Integrated with "compare with current version" of standard versions browser.Integrated with Monticello replacing changes and merge browsers.'.	info maintainer: 'Gary Chambers'.	info homepage: 'http://wiki.squeak.org/squeak/6005'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/UIEnhancements/Polymorph-Tools-Diff-gvc.12.mcz'.	self provides: #().	self dependsOn: #('Polymorph EventEnhancements' 'Polymorph Geometry' 'Polymorph Widgets').! !!PackagesDevU methodsFor: 'User Interface' stamp: 'damiencassou 2/5/2009 16:16'!PolymorphWidgets	self name: 'Polymorph Widgets'.	self version: '1.3'.	info category: 'User Interface'.	info description: 'Modifies Morphic to provide for selectable theming of controls and provides a framework and extra Morphs for creating consistent user interfaces. Improves both look and feel.Fixes a few problems too (corner grips, window titlebar sizing wrt fonts...).Noteable changes since last release:Changed browser button rows to use a theme row.Balloon help now themed.Cosmetic changes to DropListMorphs and ExpanderTitleMorphs.ImageFillStyles support offset into form to allow clipping to part of form.Fix for Morph>>layoutChanged to clear caches.#taskbarLabel supported for windows and models.Fix for y/n keys on proceed dialogs.'.	info maintainer: 'Gary Chambers'.	info homepage: 'http://wiki.squeak.org/squeak/6005'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/UIEnhancements/Polymorph-Widgets-gvc.39.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!PostgreSQLClient	self name: 'PostgreSQL Client'.	self version: '1.0'.	info category: 'Persistence'.	info description: 'Implements a native Smalltalk connection to PostgreSQL backend. See the "Frontend/Backend Protocol" chapter in the "PostgreSQL Programmer''s Guide" for more information.Notes:1. Only "plaintext" and "md5" authentication modes are currently supported. This option is configurable via the pg_hba.conf file in your postgres server configuration.2. If you want to use "md5" authentication, you must load the Cryptography package first, before loading this package.3. If you only want to use "plaintext" authentication, it is not necessary to load the Cryptography package at all.See the class TestPGConnection for example code of how to access the postgres.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: 'http://ca.geocities.com/zazu%40rogers.com/pgsqueak/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/PostgresV2/PostgresV2-yj.5.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'System' stamp: 'test 1/13/2009 15:56'!ProcessSpecific	self name: 'ProcessSpecific'.	self version: '1.0.18'.	info category: 'System'.	info description: 'My subclasses (not instances of them) keep state specific to the current process.There are two kinds of process-specific variables: process-local (state availablefor read and write in all methods inside the process), and dynamic variables(implementing dynamic scope).Includes tests and example: DateAndTimeWarpIncludes extension (if not loaded ignore) for seaside for debugging.'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Logging/ProcessSpecific-kph.18.mcz'.	self provides: #('ProcessSpecific').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ProjectsAsPNG	self name: 'ProjectsAsPNG'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: '- Add a menuItem ''Export Projects as PNG'' to an InternalThreadNavigationMorph. - Export projects included in pages of an InternalThreadNavigationMorph as PNG graphics. - The png files are places in the Squeak DefaultDirectory. - The external name of the world is given the Project''s name as it is used to named the PNG file. On the class side of InternalThreadNavigationMorph you''ll see #nonSavedClasses that you can edit to add or remove Class that you don''t want to show in your PNG file. Some of this code is a reuse of Ned Konz work. Work with: - Squeak 3.7 - Squeak 3.8 - Squeak 3.9'.	info maintainer: 'Raymond Asselin'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ThreadNavigatorPlus'.	self provides: #('Add amenuItem ''Export Projects as PNG'' to InternalThreadNavigationMorph').	self dependsOn: #('Morphic').! !!PackagesDevU methodsFor: 'Data Structures' stamp: 'kph 9/10/2008 10:09'!PropertyList	self name: 'PropertyList'.	self version: '5'.	info category: 'Data Structures'.	info description: 'This package can currently read or write the old NeXT style .plist files as well as read the newer XML style extensively used in Mac OS X.The old format is supported by PropertyListStream, which works much like DataStream or ReferenceStream, eg,dict := (PropertyListStream on: (FileStream fileNamed: ''old.plist'')) next.The new format is supported by XMLPropertyListReader, which has a different API:dict := (XMLPropertyListReader on: (FileStream fileNamed: ''new.plist'')) root.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://squeaksource.com/PropertyList/PropertyList-avi.5.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Games' stamp: 'kph 9/10/2008 10:09'!Quotes	self name: 'Quotes'.	self version: '22'.	info category: 'Games'.	info description: 'A simple package that displays Quote/Author pairs in a window. The quotes are displayed sequentially or in a random order. The speed of the display is adjustable via a slider.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Quotes/Quote-Display-fc.22.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!REPLServer	self name: 'REPLServer'.	self version: '16'.	info category: 'Network'.	info description: 'REPLServer provides a back door in to Squeak via Telnet. To start:REPLServer start.(and to stop, do ''REPLServer stop'')This way, when Morphic crashes, you can reset it by telnetting to localhost on port 4445. When it is first started, it will prompt you (in the GUI) for a password. The service will restart itself if you restart Squeak. Note that by default, only connections from localhost are accepted.This version has improved Exception handling and fixes several bugs. Please report any bugs you find to the package maintainer.'.	info maintainer: 'mikevdg'.	info homepage: 'http://www.squeaksource.com/SecureSqueak/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SecureSqueak/REPL-mvdg.16.mcz'.	self provides: #().	self dependsOn: #('DynamicBindings' 'KomServices').! !!PackagesDevU methodsFor: 'Network' stamp: 'damiencassou 2/17/2009 18:56'!RFBVNC	self name: 'RFB-VNC'.	self version: '1.2'.	info category: 'Network'.	info description: 'Remote Frame Buffer (VNC) implementation.'.	info maintainer: 'ikp'.	info homepage: 'http://www.squeaksource.com/RFB'.	info squeakMapID: ''.	info url: 'http://source.lukas-renggli.ch/unsorted/RFB-lr.10.mcz'.	self provides: #('Remote Frame Buffer').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!ROE	self name: 'ROE'.	self version: '42'.	info category: 'Persistence'.	info description: 'A library for manipulating relational queries as first class Smalltalk expressions, and generating SQL from them.There''s no documentation yet, but you can maybe muddle through using the test cases and some comments I made on my blog here:  http://www.cincomsmalltalk.com/userblogs/avi/blogView?searchCategory=databases .Requires the PostgreSQL Client.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Roe-avi.42.mcz'.	self provides: #().	self dependsOn: #('PostgreSQL Client').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 11/2/2008 00:30'!RSRSS2	self name: 'RSRSS2'.	self version: '2.8.3.11'.	info category: 'Web Development'.	info description: 'RSS 2.0 feed creation with Seaside canvas API.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/rsrss/RSRSS2-SW.11.mcz'.	self provides: #().	self dependsOn: #('Seaside').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/17/2009 18:56'!RefactoringCore	self name: 'Refactoring Core'.	self version: '25'.	info category: 'Development'.	info description: 'The refactoring engine of the old RefactoringBrowser. It does not include any browser and needs at least Squeak 3.9.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.squeaksource.com/RefactoringEngine.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/RefactoringEngine/Refactoring-Core-lr.25.mcz'.	self provides: #().	self dependsOn: #('AST').! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 11/12/2008 16:59'!RefactoringEngine	self name: 'Refactoring Engine'.	self version: '51'.	info category: 'Development'.	info description: 'Damien Cassou: This package is now obsolete. Use ''Refactoring Core'' instead.'.	info maintainer: 'Marcus Denker <denker@iam.unibe.ch>'.	info homepage: 'http://www.squeaksource.com/RefactoringEngine.html'.	info squeakMapID: ''.	info url: nil.	self provides: #().	self dependsOn: #('AST').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/17/2009 18:56'!RefactoringSpelling	self name: 'Refactoring Spelling'.	self version: '1'.	info category: 'Development'.	info description: 'A lint extension that does spell check your code: argument variables, class category names, class comments, class names, class variable names, literal values (strings, symbols), method protocols, method selectors, pool variable names, method comments, temporary variable names'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/RefactoringEngine/Refactoring-Spelling-lr.1.mcz'.	self provides: #().	self dependsOn: #('Refactoring Core').! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 11/2/2008 00:30'!RefactoringTests	self name: 'Refactoring Tests'.	self version: '3'.	info category: 'Development'.	info description: 'The tests for the refactoring engine.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/RefactoringEngine/Refactoring-Tests-lr.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!RemoteFrameBuffer	self name: 'RemoteFrameBuffer'.	self version: '34'.	info category: 'Network'.	info description: 'Provides RFB (VNC) server and client, written entirely in Squeak.Both server and client implement a superset of the latest (version3.3.7) RFB protocol published by RealVNC.com (with extensions tosupport local cursor handling in the popular TightVNC client).The server transmits (or broadcasts) the Squeak desktop to remoteVNC clients (either running natively on Unix, Mac or Windows, orrunning the Squeak client included in this same package).The client connects to and displays a remote framebuffer (providedeither from a VNC server running natively on Unix, Mac, Windows, etc.,or from a remote Squeak image running the server included in thispackage).Full documentation is included (see the class comments inRFBServer and RFBClient, and the help items on theassociated menus).'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/RFB/RFB-ikp.3.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'kph 11/28/2008 16:26'!Rio	self name: 'Rio'.	self version: '4'.	info category: 'Model Extension'.	info description: 'A file IO interface inspired by http://rio.rubyforge.org , potentially replaces FileDirectory/FileMan.Transparently supports archives and ftp filesystems'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://wiki.squeak.org/squeak/5929'.	info squeakMapID: ''.	info url: nil.	self provides: #().	self dependsOn: #('File-Test').! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!RoelTyper	self name: 'RoelTyper'.	self version: '0.60'.	info category: 'Development'.	info description: 'RoelTyper is a fast type reconstructor for Smalltalk, based on heuristics. It type-checks instance variables of classes. Typing a complete VisualWorks Smalltalk image takes less than one minute and a half!! For this speed you get the types for about 80% of instance variables in the system. The approach is quite similar to what the Refactoring Browser does, but somewhat more refined.'.	info maintainer: 'Roel Wuyts'.	info homepage: 'http://decomp.ulb.ac.be/roelwuyts/smalltalk/roeltyper/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/RoelTyper/RoelTyper-rw.60.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 9/10/2008 10:09'!SARBuilder	self name: 'SARBuilder'.	self version: '8'.	info category: 'Group Development'.	info description: 'SARBuilder lets you build .SAR (Squeak ARchive) packages from ChangeSets, Monticello packages, versions, or snapshots, or PackageInfo instances.Please see the class comments in SARInstaller'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SARBuilder.8.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!SIXX	self name: 'SIXX'.	self version: '0.95'.	info category: 'Persistence'.	info description: 'SIXX is an XML serializer/deserializer written in Smalltalk (currently Squeak 3.9, VisualWorks 5i.4 - 7, and Dolphin XP are supported).The purpose is to store and load Smalltalk objects in a portable, dialect-independent XML format.Example:		array := Array with: 1 with: ''''Hello'''' with: Date today.array sixxString.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'ftp://swikis.ddo.jp/SIXX/squeak/SIXX20070812.sar'.	self provides: #().	self dependsOn: #('YAXO').! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 9/10/2008 10:09'!SPLPDFLibrary	self name: 'SPL PDF Library'.	self version: '1.0-21a'.	info category: 'Persistence'.	info description: 'Write PDF files directly from within Squeak using the PDF Library. The latest version has support for text, lines and TIFF images. The library was developed and extended at SPL WorldGroup for specific projects, and does what was needed for those projects. It is expected that the library will contine to be extended over time as feedback is received from the people using it.The library is available under a very unrestrictive licence, but it is nevertheless a license. Please read the license at: http://wiki.cs.uiuc.edu/VisualWorks/PDF+Library.Once you have loaded the package, have a look at PDFReportingSelfTest class>>test to get an idea of what the framework can do.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SPDF-1.0-021a.st.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'System' stamp: 'kph 9/10/2008 10:09'!SSH	self name: 'SSH'.	self version: '1.0'.	info category: 'System'.	info description: 'An implementation of SSH in Squeak'.	info maintainer: 'rww'.	info homepage: 'http://www.squeaksource.com/Cryptography.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Cryptography/SSH-rww.12.mcz'.	self provides: #().	self dependsOn: #('Cryptography Team Package' 'SSL' 'Telnet').! !!PackagesDevU methodsFor: 'System' stamp: 'kph 9/10/2008 10:09'!SSL	self name: 'SSL'.	self version: '1.0'.	info category: 'System'.	info description: 'This is an implementation of the SSL protocol in Squeak.'.	info maintainer: 'rww'.	info homepage: 'http://www.squeaksource.com/Cryptography.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Cryptography/SSL-rww.3.mcz'.	self provides: #().	self dependsOn: #('Cryptography Team Package').! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!SUnit	self name: 'SUnit'.	self version: '0.33'.	info category: 'Development'.	info description: 'SUnit is the Smalltalk way of doing unit testing.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://sunit.sourceforge.net/'.	info squeakMapID: ''.	info url: 'http://source.squeakfoundation.org/39a/SUnit-md.33.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 12/11/2008 22:14'!SUnitGUIimproved	self name: 'SUnitGUI-improved'.	self version: '4.0.50'.	info category: 'Development'.	info description: 'Improved TestRunner- pane for selecting published suites and filtering- can report results to a file via TestReporter.'.	info maintainer: 'kph'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Testing/SUnitGUI-kph.50.mcz'.	self provides: #('SUnitGUI').	self dependsOn: #('SUnit-improved').! !!PackagesDevU methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SUnitProgress	self name: 'SUnitProgress'.	self version: '0.2'.	info category: 'Uncategorized'.	info description: 'Simple extension for SUnit showing a progress-bar while the unit tests are running ...'.	info maintainer: ''.	info homepage: 'http://www.squeaksource.com/SUnitProgress'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SUnitProgress/SUnitProgress-SR.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 12/12/2008 01:56'!SUnitimproved	self name: 'SUnit-improved'.	self version: '4.0.118'.	info category: 'Development'.	info description: 'Improved SUnit, allows categorization of tests for selective running, per platform, per vm or image version. Includes: TestReporter a non gui test runner'.	info maintainer: 'kph'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Testing/SUnit-kph.117.mcz'.	self provides: #('SUnit' 'SUnit-improved').	self dependsOn: #().! !!PackagesDevU methodsFor: 'IDE' stamp: 'kph 9/10/2008 10:09'!SVI	self name: 'SVI'.	self version: '0.115'.	info category: 'IDE'.	info description: 'SVI is a text editor for squeak that can be used in place of the PluggableTextMorph. SVI is designed to behave, as much as possible, like a standard text editor, so as not to confuse users that are not familiar with modal text editors. Nevertheless, SVI features extensive support for VIM and Emacs modes and commands, including:- incremental search- interactive search/replace- split panes- multilevel undo/redo- navigation, using keyboard driven menus and bookmarks, between classes, methods, files, and system windows- context sensitive help and command completion- customizable keybindings- ability to paste recently deleted, inserted, or copied text. Also, VIM-style "registers" - support for VIM''s Normal, Visual and Linewise Visual modes, with extensive support for the VIM commands, motions, registers. Mark implementation supports method-to-method jumps , method-to-file, file-to-file, etc.By default, SVI supports many VIM commands. If you want SVI to support Emacs commands instead, be sure to take the tour of Emin (SVI''s "mini-emacs"). After loading SVI, execute "SVI openEminDocs" to take a tour of Emin. Patches to make SVI work with StarBrowser and Celeste are available <a href="http://www.swerlingphoto.com/squeak/svi2/appPatches.html">here</a>. The Celeste version is provided as an example of how to fully integrate an application with SVI (with a recent message list, bookmarking, opening a celeste message in a split pane, etc). '.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.swerlingphoto.com/squeak/svi2/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SVI/SVI-3.9v2-sps.115.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 12/21/2008 22:12'!Sake	self name: 'Sake'.	self version: '82'.	info category: 'Group Development'.	info description: 'Smalltalk take on Rake/MakeProvide Squeak with a declarative, idempotent build system for external files and programs as well as other Squeak images, that also integrates well with other Squeak code and libraries. It could even offer new facilities for building Squeak images using the Installer tool.'.	info maintainer: 'Keith Hodges'.	info homepage: 'http://wiki.squeak.org/squeak/5953'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Sake/Sake-Core-kph.82.mcz'.	self provides: #('Sake').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Group Development' stamp: 'auto 12/7/2008 06:59'!SakeBob	self name: 'Sake-Bob'.	self version: '7'.	info category: 'Group Development'.	info description: 'Framework for performing regular, Scheduled scripted actions using Sake, i.e. builds'.	info maintainer: 'Keith Hodges'.	info homepage: 'http://wiki.squeak.org/squeak/5953'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Sake/Sake-Bob-kph.7.mcz'.	self provides: #('Sake-Bob').	self dependsOn: #('Sake' 'Sake-Scheduler').! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 12/13/2008 02:10'!SakePackages	self name: 'Sake-Packages'.	self version: '8'.	info category: 'Group Development'.	info description: 'Sake Tasks for loading packages, see Packages-Library'.	info maintainer: 'Keith Hodges'.	info homepage: 'http://wiki.squeak.org/squeak/5953'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Packages/Sake-Packages-kph.8.mcz'.	self provides: #('Sake-Packages').	self dependsOn: #('Sake').! !!PackagesDevU methodsFor: 'Group Development' stamp: 'auto 12/7/2008 06:59'!SakeScheduler	self name: 'Sake-Scheduler'.	self version: ''.	info category: 'Group Development'.	info description: 'Periodic actions'.	info maintainer: 'Keith Hodges'.	info homepage: 'http://wiki.squeak.org/squeak/5953'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Sake/Sake-Scheduler-kph.6.mcz'.	self provides: #('Sake-Scheduler').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Web Development beta' stamp: 'kph 9/10/2008 10:09'!Sandcastle	self name: 'Sandcastle'.	self version: '1.0'.	info category: 'Web Development beta'.	info description: 'see version 0'.	info maintainer: 'tbn'.	info homepage: 'http://squeaksource.com/Sandcastle.html'.	info squeakMapID: ''.	info url: 'http://squeaksource.com/Sandcastle/Sandcastle-tbn.9.mcz'.	self provides: #().	self dependsOn: #('ExternalWebBrowser' 'Scriptaculous-beta' 'ShoreComponents-beta').! !!PackagesDevU methodsFor: 'Persistence' stamp: 'kph 12/21/2008 22:12'!SandstoneDb	self name: 'SandstoneDb'.	self version: '113'.	info category: 'Persistence'.	info description: 'SandstoneDb is a lightweight Prevayler style embedded object database with an ActiveRecord API that doesn''t require a command pattern and works for small apps that a single Squeak image can handle. The idea is to make a Squeak image durable and crash proof and suitable for use in small office applications.Data is kept in ram for speed and on disk for safety. All data is reloaded from disk on image startup.Since we''re dealing with live objects in memory, concurrency is handled via optional record level critical sections rather than optimistic locking and commit failures. It''s up to the developer to use critical sections at the appropriate points by using the critical method on the record.Saves are atomic for an ActiveRecord and all its non ActiveRecord children, for example, an order and its items. There is no atomic save across multiple ActiveRecords. A record is a cluster of objects that are stored in a single file together.Assuming you have the latest SUnit (SUnitGUI-improved from Universe), all tests should pass.For more information and API see http://onsmalltalk.com/sandstonedb-simple-activerecord-style-persistence-in-squeak/'.	info maintainer: 'Ramon Leon'.	info homepage: 'http://onsmalltalk.com/sandstonedb-simple-activerecord-style-persistence-in-squeak'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SandstoneDb/SandstoneDb-rjl.113.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Morphs' stamp: 'kph 9/10/2008 10:09'!ScreenShotMorph	self name: 'Screen Shot Morph'.	self version: '0.0.0.2'.	info category: 'Morphs'.	info description: 'A morph helping you to make a screenshot. The morph should openin the top left corner of the screen. Double clickwill activate the morph. You have 5 seconds before the screen shot is taken.- Originally written by Lex Spoon- Torsten added image, double click behavior- the morph now hides itself if the screenshot is taken'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ScreenShotMorph/ScreenShotMorph-tbn.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'IDE' stamp: 'kph 9/10/2008 10:09'!ScriptManager	self name: 'ScriptManager'.	self version: '0.6'.	info category: 'IDE'.	info description: 'ScriptManager provides a tool to write documentation/code. This texts are organized into folders.'.	info maintainer: 'Damien Cassou'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/DeveloperWorkspace/ScriptManager-tbn.6.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 11/2/2008 00:30'!Scriptaculous	self name: 'Scriptaculous'.	self version: '2.8.3.242'.	info category: 'Web Development'.	info description: 'High-level Javascript bindings for the Seaside web application framework. This package includes PrototypeJS (http://www.prototypejs.org) and script.aculo.us (http://script.aculo.us).'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://scriptaculous.seasidehosting.st/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Seaside/Scriptaculous-lr.242.mcz'.	self provides: #().	self dependsOn: #('Seaside').! !!PackagesDevU methodsFor: 'IDE' stamp: 'kph 9/10/2008 10:09'!Scripter	self name: 'Scripter'.	self version: '0.5.5'.	info category: 'IDE'.	info description: 'Scripter is an interface for scripting Squeak UI Tools.Windows: Collapsing, minimizing, maximizing, tidying,  moving, closing.Tools: Open and use.Menus: select menu itemsButtons: click buttonsLists: select list itemsTo Do:Track action which spawns opening a new window.Trees: select tree items'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://www.squeaksource.com/Scripter.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Scripter/Scripter-Core-kph.5.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!ScriptingWorkspace	self name: 'Scripting Workspace'.	self version: '1.22-apha'.	info category: 'Development'.	info description: 'This is meant to be a workspace for people familiar with scriping languages like Javascript, Ruby, Python, or Perl. It gives the workspace the ability to add classes and methods.See ScriptingWorkspaceTest for examples."Do This To See It"ScriptingWorkspace open'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/btb-ScriptingWorkspace-btb.22.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 11/2/2008 00:30'!Seaside	self name: 'Seaside'.	self version: '2.8.3.572'.	info category: 'Web Development'.	info description: 'A framework for building sophisticated web applications in Squeak. Develop for the web using reusable, embeddable components and unique call/return semantics for moving between pages.'.	info maintainer: 'Lukas Renggli <renggli@gmail.com>'.	info homepage: 'http://www.seaside.st/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Seaside/Seaside2.8a1-lr.572.mcz'.	self provides: #().	self dependsOn: #('KomHttpServer').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'damiencassou 2/17/2009 18:56'!Seaside28Jetsam	self name: 'Seaside28Jetsam'.	self version: '2.8.546'.	info category: 'Web Development'.	info description: 'Patches to the base seasideThe version number indicates the version of seaside this is synced with.'.	info maintainer: 'kph'.	info homepage: 'http://www.squeaksource.com/Jetsam.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Jetsam/Seaside28Jetsam-kph.67.mcz'.	self provides: #('Seaside28Jetsam-Useful-CSS' 'Seaside28Jetsam-NiftyCorners' 'Seaside28Jetsam' 'Seaside28Jetsam-Supersleight' 'Seaside28Jetsam-Blueprint').	self dependsOn: #('M7219-StreamsReadability' 'M7284-firsOrNil' 'Seaside').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 9/10/2008 10:09'!Seaside28JetsamBlueprint	self name: 'Seaside28Jetsam-Blueprint'.	self version: '0.7.1'.	info category: 'Web Development'.	info description: 'Lukas'' import of the Blueprint Library'.	info maintainer: 'kph'.	info homepage: 'http://www.squeaksource.com/Jetsam.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Jetsam/Seaside28Jetsam-Blueprint-kph.1.mcz'.	self provides: #().	self dependsOn: #('Seaside').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 9/10/2008 10:09'!Seaside28JetsamSupersleight	self name: 'Seaside28Jetsam-Supersleight'.	self version: '0.1'.	info category: 'Web Development'.	info description: 'Supersleight library for transparent ng support in IE6 http://24ways.org/2007/supersleight-transparent-png-in-ie6'.	info maintainer: 'kph'.	info homepage: 'http://www.squeaksource.com/Jetsam.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Jetsam/Seaside28Jetsam-Supersleight-kph.3.mcz'.	self provides: #().	self dependsOn: #('Seaside').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 9/10/2008 10:09'!Seaside28JetsamUsefulCSS	self name: 'Seaside28Jetsam-Useful-CSS'.	self version: '0.1'.	info category: 'Web Development'.	info description: 'Class for constructing css'.	info maintainer: 'kph'.	info homepage: 'http://www.squeaksource.com/Jetsam.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Jetsam/Seaside28Jetsam-Useful-CSS-kph.3.mcz'.	self provides: #().	self dependsOn: #('Seaside').! !!PackagesDevU methodsFor: 'Example/Tutorial' stamp: 'kph 9/10/2008 10:09'!SeasideAXAnnouncementsMenu	self name: 'Seaside-AXAnnouncementsMenu'.	self version: '1'.	info category: 'Example/Tutorial'.	info description: 'A small example using announcements to implement a simple menu in seaside.'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://www.squeaksource.com/AXAnnouncements.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/AXAnnouncements/AnnouncementMenu-kb.1.mcz'.	self provides: #().	self dependsOn: #('AXAnnouncements' 'Seaside').! !!PackagesDevU methodsFor: 'Web Development beta' stamp: 'kph 9/10/2008 10:09'!SeasideAdaptersCompatibility	self name: 'SeasideAdaptersCompatibility'.	self version: 'pmm.1.mcz'.	info category: 'Web Development beta'.	info description: 'This compatibility package allows to run Seaside 2.9 server adapters in Seaside 2.8 (and below).'.	info maintainer: 'pmm'.	info homepage: 'http://www.squeaksource.com/Seaside.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Seaside/SeasideAdaptersCompatibility-pmm.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Web Development beta' stamp: 'kph 9/10/2008 10:09'!SeasideAdaptersCore	self name: 'Seaside-Adapters-Core'.	self version: 'pmm.2.mcz'.	info category: 'Web Development beta'.	info description: 'This is the core server adapter package of Seaside 2.9. It includes all the common server adapter code for Seaside 2.9 (currently only used in Squeak).'.	info maintainer: 'pmm'.	info homepage: 'http://www.squeaksource.com/Seaside29.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Seaside29old/Seaside-Adapters-Core-pmm.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Web Development beta' stamp: 'kph 11/12/2008 16:59'!SeasideAdaptersSwazoo	self name: 'Seaside-Adapters-Swazoo'.	self version: '9'.	info category: 'Web Development beta'.	info description: 'The Swazoo 2.1 server adapter form Seaside 2.9, works also with Seaside 2.8.Can be started and stopped with:SwazooSeaside startOn: 8080SwazooSeaside stop'.	info maintainer: 'pmm'.	info homepage: 'http://www.squeaksource.com/Seaside29.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Seaside29old/Seaside-Adapters-Swazoo-pmm.8.mcz'.	self provides: #().	self dependsOn: #('Seaside-Squeak-Adapters' 'SeasideAdaptersCompatibility' 'Swazoo').! !!PackagesDevU methodsFor: 'Web Development beta' stamp: 'kph 9/10/2008 10:09'!SeasideHTML5beta	self name: 'Seaside-HTML5-beta'.	self version: '2.8.411.5'.	info category: 'Web Development beta'.	info description: 'HTML5 support moved out of Seaside2.8'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://www.seaside.st/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Seaside/HTML5-pmm.5.mcz'.	self provides: #().	self dependsOn: #('Seaside-beta').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 9/10/2008 10:09'!SeasidePlotKitbeta	self name: 'Seaside-PlotKit-beta'.	self version: '0.9.1.26'.	info category: 'Web Development'.	info description: 'Seaside goodies. Includes different charts libraries and other cool stuff for seaside applications. SeaChart components are standard Seaside components that you can embed into your Seaside application.Seaside bindings for PlotKit (http://www.liquidx.net/plotkit). PlotKit is a Chart and Graph Plotting Library for Javascript.Includes dependency upon HTML5 package which is no longer in seaside.'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: 'http://seachart.seasidehosting.st/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/seachart/PlotKit-0.9.1-mb.27.mcz'.	self provides: #().	self dependsOn: #('Seaside-HTML5-beta' 'Seaside-beta').! !!PackagesDevU methodsFor: 'Web Development beta' stamp: 'kph 9/10/2008 10:09'!SeasideSqueakAdapters	self name: 'Seaside-Squeak-Adapters'.	self version: 'pmm.3.mcz'.	info category: 'Web Development beta'.	info description: 'The Squeak specific implementation classes for the Seaside-Adapters-Core package.'.	info maintainer: 'pmm'.	info homepage: 'http://www.squeaksource.com/Seaside29.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Seaside29old/Seaside-Squeak-Adapters-pmm.3.mcz'.	self provides: #().	self dependsOn: #('Seaside-Adapters-Core').! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!SendTreeExplorer	self name: 'SendTreeExplorer'.	self version: '1alpha'.	info category: 'Development'.	info description: 'This little goodie provides new tools SendTreeExplorer and MessageSendTree.  Like MessageTally, MessageSendTree traces the execution of a block in simulation. There are three key differences:    1.	Rather than tallying the number of times each method is called in a given context, MessageSendTree traces and returns the exact tree of the sends made, in send order.     2.	MessageSendTree is designed to work with a SendTreeExplorer which presents the results in a hierarchical list view rather than flattened to a text pane.     3.	MessageSendTree allows all sends above a given method to be ignored, so that such a method can be conveniently traced deep in the execution of the block without the bother of wading through a long send chain to get there. '.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SendTreeExplorer-JW.1.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!SharedStreams	self name: 'SharedStreams'.	self version: '1.1'.	info category: 'Development'.	info description: 'SharedStreams introduces SharedBufferStream and SharedBidirectionalStream.SharedBufferStream is like a SharedQueue (FIFO) but for a stream of bytes/characters instead of separate objects. It can be used as a "socket" between Squeak processes in order for them to communicate with a stream protocol.A SharedBidirectionalStream is like a "socket" between two (or more) Squeak processes. Internally it uses two SharedBufferStreams, one for input and one foroutput. It handles multiple Processes at both ends.In order for the protocol to be the same no matter what side you are of thestream you can access the "other end" by calling #otherEnd.A SharedBidirectionalStream then creates a single mirror twin brotherwhich it shares the two internal SharedBufferStream with - but with the inStreamand outStream twisted.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SharedStreams-1_1.st.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 9/10/2008 10:09'!ShoreComponents	self name: 'ShoreComponents'.	self version: '3.10'.	info category: 'Web Development'.	info description: 'A set of useful components for Seaside.Shore Components project is a library of building blocks for Seaside.Currently it contains only few of them, but we hope that the projectcan serve as the meeting point for those people asking in mailinglists for such a library again and again.Anybody who has an interesting reusable component for Seaside and iswilling to share it with community is strongly encouraged to do so.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.squeaksource.com/ShoreComponents.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ShoreComponents/ShoreComponents-3-pk.10.mcz'.	self provides: #().	self dependsOn: #('Scriptaculous' 'Seaside').! !!PackagesDevU methodsFor: 'Web Development beta' stamp: 'kph 9/10/2008 10:09'!ShoreComponentsbeta	self name: 'ShoreComponents-beta'.	self version: '3.10'.	info category: 'Web Development beta'.	info description: 'A set of useful components for Seaside.Shore Components project is a library of building blocks for Seaside.Currently it contains only few of them, but we hope that the projectcan serve as the meeting point for those people asking in mailinglists for such a library again and again.Anybody who has an interesting reusable component for Seaside and iswilling to share it with community is strongly encouraged to do so.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.squeaksource.com/ShoreComponents.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ShoreComponents/ShoreComponents-3-pk.10.mcz'.	self provides: #().	self dependsOn: #('Scriptaculous-beta' 'Seaside-beta').! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 9/10/2008 10:09'!Shout	self name: 'Shout'.	self version: '3.15-tween.72'.	info category: 'Code Browsing'.	info description: 'Syntax Highlighting that updates after each key stroke so that the highlighting remains correct during the editing of a method.    * Syntax Highlighting is shown in browsers and debuggers.    * Optional add-on packages are available to enable Shout in Monticello, OmniBrowser, Traits, WhiskerBrowser, and Workspaces    * Fonts may be specified for syntax elements (for example, the left arrow assignment can be shown in a different font thus removing the need to ''doctor'' fonts to get the left arrow looking correct).    * Unterminated strings and comments can be shown in a different colour.    * Parenthesis, and block [], matching is indicated by highlighting matching brackets in the same colour, with the colour determined by the level of nesting.    * Variables may be highlighted differently according to their type (instance variable, temporary variable, temporary block variable, workspace variable, Pool constant, class variable, global).    * Arguments may be highlighted differently according to their type (method argument, block argument)    * Operates in both Morphic and MVC    * Preserves TextActions within method source    * Can be configured to show assignments as the ANSI := , left arrow, or in the form that they appear in the source (which could be both versions in a single method)    * Styles are configurable, although there is currently no editor for this'.	info maintainer: ''.	info homepage: 'http://www.squeaksource.com/shout/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/shout/Shout.3.15-tween.72.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 9/10/2008 10:09'!ShoutMonticello	self name: 'ShoutMonticello'.	self version: '1-tween.2'.	info category: 'Code Browsing'.	info description: ''.	info maintainer: ''.	info homepage: 'http://www.squeaksource.com/shout'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/shout/ShoutMonticello.1-tween.2.mcz'.	self provides: #().	self dependsOn: #('Shout').! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 9/10/2008 10:09'!ShoutOmniBrowser	self name: 'ShoutOmniBrowser'.	self version: 'tween.6'.	info category: 'Code Browsing'.	info description: 'Brings colors to the OmniBrowser framework and browsers.'.	info maintainer: ''.	info homepage: 'http://www.squeaksource.com/shout'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/shout/ShoutOmniBrowser-dc.5.mcz'.	self provides: #().	self dependsOn: #('OmniBrowser-Morphic' 'Shout').! !!PackagesDevU methodsFor: 'Uncategorized' stamp: 'kph 9/30/2008 16:20'!ShoutWorkspace	self name: 'ShoutWorkspace'.	self version: '1-tween.4'.	info category: 'Uncategorized'.	info description: 'Brings colors to the Workspace. Use Open->Shout Workspace to get the new workspace.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://damiencassou.seasidehosting.st/seaside/pier'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/shout/ShoutWorkspace.1-tween.4.mcz'.	self provides: #().	self dependsOn: #('Shout').! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!SimpleLog	self name: 'SimpleLog'.	self version: '1.13'.	info category: 'Development'.	info description: 'Nice and simple logging. There are eight messages for logging based on severity. These correspond to the eight levels defined in syslog:7 - debug (Debug-level messages)6 - info (Informational)5 - notice (Normal but significant Condition)4 - warning (Warning Condition)3 - err (Error Condition)2 - crit (Critical Conditions)1 - alert (must be handled immediately)0 - emerg (System is unusable)	The absolutely easiest way to log is like this:	SLLog warn: ''Oopsidaisy''We only need to include the actual message in the string, timestamp etc is added automatically.You can also explicitly supply a "sender" object which can be anything you like, a symbol or a specific domain object even:	SLLog warn: ''Yowsa'' sender: #emailSLLog uses printString on the sender when producing the log entry, so if you use domain objects - make sure they have a unique printOn: method defined so that you can distinguish them. See class side category "logging" and "logging shorthand" for the available log messages.By default there is a single emitter registered that logs on Transcript, you can turn this off with:	SLLog useTranscript: falseAnd you can set a threshold for the above 8 syslog levels that should be logged onto Transcript using:	SLLog instance transcriptMaxLevel: 4..or set a global threshold for all emitters:	SLLog instance globalMaxLevel: 4Global flushing of all emitters can be done using "SLLog flush" and should ideally be called regularly by some background process.Finally take a look at SLLogFile for details on how to add it as an emitter to get logging onto file instead of Transcript, and SLLogMorph for getting logging into a very nice UI that offers filtering, searching etc.'.	info maintainer: 'keith_hodges@yahoo.co.uk'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Logging/SimpleLog-kph.13.mcz'.	self provides: #('SimpleLog').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!SmaCC	self name: 'SmaCC'.	self version: '18'.	info category: 'Development'.	info description: 'SmaCC (Smalltalk Compiler-Compiler) is a freely available parser generator for Smalltalk. Use this package if you want to develop a new parser/scanner/compiler.It  is a replacement for the T-Gen parser generator. T-Gen has several limitations  that make it difficult to produce parsers. SmaCC overcomes T-Gen''s limitations. For example, SmaCC  can generate parsers for ambiguous grammars and grammars with overlapping tokens.  Both of these are not possible using T-Gen. In addition to handling more  grammars than T-Gen, SmaCC has a smaller runtime than T-Gen and is faster than  T-Gen.   '.	info maintainer: 'Mathieu Suen'.	info homepage: 'http://wiki.squeak.org/squeak/3117'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SmaccDevelopment/SmaCCDev-lr.18.mcz'.	self provides: #().	self dependsOn: #('Refactoring Engine' 'SmaCC runtime').! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!SmaCCruntime	self name: 'SmaCC runtime'.	self version: '13'.	info category: 'Development'.	info description: 'SmaCC (Smalltalk Compiler-Compiler) is a freely available parser generator for Smalltalk. Use this package if you want to develop a new parser/scanner/compiler. SmaCC-Runtime is part of the Squeak Image, for developing new parsers, the dev package nees to be installed. SmaCC-Developments is for Squeak <3.8 SmaCCDev is the current development version for 3.9.'.	info maintainer: 'Mathieu Suen <mathieusuen@yahoo.fr>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SmaccDevelopment/SmaCC-lr.13.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Graphics' stamp: 'kph 9/10/2008 10:09'!Smagick	self name: 'Smagick'.	self version: '0.5'.	info category: 'Graphics'.	info description: 'A simple interface to control "Image Magick" from a Smalltalk environmentchanges to 0.4:- bugfixes'.	info maintainer: 'Stefan Reichhart <stefan.reichhart@gmx.ch>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SqueakAddOns/Smagick-SR.72.mcz'.	self provides: #().	self dependsOn: #('OSProcess' 'OSProcessIO' 'VBRegex').! !!PackagesDevU methodsFor: 'Simulation' stamp: 'kph 9/10/2008 10:09'!SmallDEVS	self name: 'SmallDEVS'.	self version: '2006-12-6'.	info category: 'Simulation'.	info description: 'SmallDEVS is a new, lightweight implementation of B. Zeigler''s DEVS (Discrete event systems specification) formalism. It is an experimental software intended for research and education. It allows for experimenting with:    * prototype-based object-oriented model construction,    * interactive modeling and simulation,    * multisimulation and reflective simulation. '.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: 'http://perchta.fit.vutbr.cz:8000/projekty/10'.	info squeakMapID: ''.	info url: 'http://perchta.fit.vutbr.cz:8000/projekty/uploads/10/SmallDEVS-061206.sar'.	self provides: #().	self dependsOn: #('Connectors' 'SIXX' 'YAXO').! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!SoapCore	self name: 'SoapCore'.	self version: '1.0b'.	info category: 'Network'.	info description: 'SoapCore is a SOAP implementation for Squeak (including both client and  server). It is a SOAP part of SoapOpera.It achieves some interoperability with other SOAP, such as SOAP4R, Splash/Spray, etc. Designed to be lean and simple.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: 'http://www.mars.dti.ne.jp/%7Eumejava/smalltalk/soapOpera/index.html'.	info squeakMapID: ''.	info url: 'ftp://swikis.ddo.jp/SoapOpera/SoapCore/SoapCore20061219.sar'.	self provides: #().	self dependsOn: #('YAXO').! !!PackagesDevU methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Speech	self name: 'Speech'.	self version: '9'.	info category: 'Uncategorized'.	info description: 'Speech synthesis and facial animation'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://source.squeakfoundation.org/39a/Speech-md.9.mcz'.	self provides: #('Mathieu Suen <mathieu.suen@yahoo.fr>').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!Sport	self name: 'Sport'.	self version: '2.31'.	info category: 'Development'.	info description: 'Smalltalk portability library from Bruce Badger, consisting basic portable classes for Times, Files and Sockets031 brings an extended and portable support for image startup and shutdown tasks. This is useful for any cleanup you want to do before image is quit and for any work after image  is started. For instance, a Swazoo web server will restart all its websites automatically after image start with help of those Sport startup methods. '.	info maintainer: 'mivsek'.	info homepage: 'http://wiki.openskills.org/OpenSkills/Sport'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SPort/Sport-2.031.mcz'.	self provides: #('Portability').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 9/10/2008 10:09'!SqCVS	self name: 'SqCVS'.	self version: '0.51'.	info category: 'Group Development'.	info description: 'SqCVS is a clean implementation of the CVS pserver protocol in Squeak.It is written on top of SocketStream - the highlevel Socket class found in theComanche package. This means Comanche is a prerequisite.SqCVS has no UI and it still doesn''t know how to do "add" and "remove".But it knows how to do pretty much of the CVS protocol.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/CVS-0_51.st.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'test 1/13/2009 15:56'!SqueakDBX	self name: 'SqueakDBX'.	self version: '0.8'.	info category: 'Persistence'.	info description: 'OpenDBX plugin, provides db connection to free and commercial databases.Currently supports: PostgreSQL, mySQL, Oracle, sqlite3 and MSSQL. Use FFI to talk to OpenDBX.It works in Unix, OSX and (through MinGW) Windows. '.	info maintainer: 'EL'.	info homepage: 'http://wiki.squeak.org/squeak/6052'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SqueakDBX/OpenDBX-Core-MMP.117.mcz'.	self provides: #().	self dependsOn: #('FFI').! !!PackagesDevU methodsFor: 'System' stamp: 'kph 9/10/2008 10:09'!SqueakElib	self name: 'SqueakElib'.	self version: '1'.	info category: 'System'.	info description: ''.	info maintainer: 'rww'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/6011'.	info squeakMapID: '7f93bcef-201b-4f53-83ea-b671eacb23f6'.	info url: 'http://www.squeaksource.com/squeakelib/SqueakElib-rww.1.mcz'.	self provides: #().	self dependsOn: #('Cryptography Team Package').! !!PackagesDevU methodsFor: 'Games' stamp: 'kph 9/10/2008 10:09'!SqueakPipes	self name: 'SqueakPipes'.	self version: '20040426'.	info category: 'Games'.	info description: 'Squeak Pipes Game is a little experiment I did to draw some graphics with Morphic and then use them in a game. It''s using a lot of the framework/ideas from the Electricity Game with some new animation.See <a href="http://squeak.preeminent.org">http://squeak.preeminent.org</a> for more details and a picture of the game.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SqueakPipe-sbw.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 9/10/2008 10:09'!SqueakSource	self name: 'SqueakSource'.	self version: '1.0.6'.	info category: 'Group Development'.	info description: 'SqueakSource is a web based repository for Monticello.'.	info maintainer: 'pmm'.	info homepage: 'http://www.squeaksource.com/ss2.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ss2/SqueakSource-pmm.1069.mcz'.	self provides: #().	self dependsOn: #('Announcements' 'Magritte-Seaside' 'Magritte-Tests' 'RSRSS2' 'Seaside' 'TinyWiki' 'YAXO').! !!PackagesDevU methodsFor: 'Squeak Distributions' stamp: 'damiencassou 2/17/2009 18:56'!Squeakdevimage	self name: 'Squeak-dev image'.	self version: '0.173'.	info category: 'Squeak Distributions'.	info description: 'This package creates a squeak image made for developers. If you update a squeak-dev image, you can execute ''DEVImageCreator default install''.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://damien.cassou.free.fr/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ImageForDevelopers/ImageForDevelopers-damiencassou.173.mcz'.	self provides: #().	self dependsOn: #('Squeak dev packages').! !!PackagesDevU methodsFor: 'Development' stamp: 'damiencassou 2/17/2009 18:56'!Squeakdevpackages	self name: 'Squeak dev packages'.	self version: '0.28'.	info category: 'Development'.	info description: 'Abstract package that only depends on other packages. This packages are used to build a squeak distribution for developers.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://damien.cassou.free.fr/'.	info squeakMapID: ''.	info url: nil.	self provides: #().	self dependsOn: #('AST' 'Algernon' 'AutomaticMethodCategorizer' 'AutomaticMethodCategorizerOB' 'Installer' 'OB-Enhancements' 'OmniBrowser-Algernon' 'OmniBrowser-Full' 'OmniBrowser-Refactory' 'OmniBrowser-Regex' 'Polymorph TaskbarIcons' 'Polymorph ToolBuilder' 'Polymorph Tools Diff' 'Refactoring Core' 'SUnitGUI-improved' 'ScriptManager' 'Shout' 'ShoutWorkspace' 'SmaCC runtime' 'Universes' 'Universes OmniBrowser' 'eCompletion' 'eCompletion-Traits' 'eCompletionOmniBrowser').! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 11/12/2008 16:59'!Squeakdevpackagesbeta	self name: 'Squeak dev packages beta'.	self version: '0.32'.	info category: 'Development'.	info description: 'Abstract package that only depends on other packages. This packages are used to build a squeak distribution for developers.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: nil.	self provides: #().	self dependsOn: #('Polymorph TaskbarIcons' 'Polymorph ToolBuilder' 'Polymorph Tools Diff' 'Squeak dev packages').! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 11/12/2008 16:59'!Squeakwebpackages	self name: 'Squeak web packages'.	self version: '0.2'.	info category: 'Web Development'.	info description: 'Abstract package that only depends on other packages. This packages are used to build a squeak distribution for developers.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://damien.cassou.free.fr/'.	info squeakMapID: ''.	info url: nil.	self provides: #().	self dependsOn: #('Aida' 'Pier' 'Scriptaculous' 'Seaside' 'Seaside-Adapters-Swazoo' 'Squeak dev packages').! !!PackagesDevU methodsFor: 'Kernel' stamp: 'test 1/13/2009 15:56'!StreamsReadability	self name: 'StreamsReadability'.	self version: '0.1'.	info category: 'Kernel'.	info description: 'Provides Stream-#<< , used by Logging'.	info maintainer: 'kph'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://bugs.squeak.org/file_download.php?file_id=3565&type=bug&e=.st'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!Swazoo	self name: 'Swazoo'.	self version: '2.1'.	info category: 'Network'.	info description: 'Swazoo (Smalltalk Web Application Zoo) is an open source, vendor agnostic, dialect neutral Smalltalk web server with resource and web request resolution framework.Main new feature: SwazooServer startOn: aPort will start on all IP interfaces, on any host.Other improvements:- auto restart sites which were running before image shutdown- reliability of serving directly on the wild wild Internet- SwazooServer watchdog instvar added, just that for now- HttpConnection is not closed anymore after 302 redirect- Connection: Keep-alive, if this header is in request then put that header in response too, even for HTTP/1.1- HttpConnection produceResponse closes connection after every non-GET, this solves 200 bad request error after two consecutive POSTs, but it is really a hack and original reason must be found!!- streaming in case of HTTP/1.0 protocol - not chunked; in case that length is known: stream but not chunked.- HTTPRequest isHttp10, isHttp11- SwazooBuffer to 8K- HTTPResponse printContentLength adds to headers too, for easier debugging- Improved and added many tests'.	info maintainer: 'mivsek'.	info homepage: 'http://www.swazoo.org/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Swazoo/Swazoo-2.1.mcz'.	self provides: #().	self dependsOn: #('Sport').! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!SwazooHTTP	self name: 'Swazoo-HTTP'.	self version: '7'.	info category: 'Network'.	info description: 'A portable set of classes that model HTTP requests and responses, that form a base on which a web server could be built.  With suitable extensions, these could also be used for an HTTP client library.See *Swazoo-Server* for the original, portable server code that used these, or *Swazoo-Listener* for a much simplified, Squeak-specific server.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Swazoo-HTTP-avi.7.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'kph 9/10/2008 10:09'!SystemChangeNotifierimprovements	self name: 'SystemChangeNotifier improvements'.	self version: '1'.	info category: 'Model Extension'.	info description: 'Adds more detail to the events sent out by SystemChangeNotifier. It should be completely backward compatable'.	info maintainer: 'Matthew Fulmer'.	info homepage: 'http://www.squeaksource.com/DeltaStreams/SystemEditor-mtf.78.mcz'.	info squeakMapID: '07238fff-3116-47bf-a90e-f1f75e10fec5'.	info url: 'http://map.squeak.org/account/files/SystemChangeNotification-Improvements39.2.cs.gz'.	self provides: #('SystemChangeNotifier improvements').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Kernel' stamp: 'kph 11/28/2008 16:26'!SystemEditor	self name: 'SystemEditor'.	self version: '1+'.	info category: 'Kernel'.	info description: 'SystemEditor from MC development effort, now supported by Monticello 1.6Traits support is alpha'.	info maintainer: 'kph <keith_hodges@yahoo.co.uk>'.	info homepage: ''.	info squeakMapID: ''.	info url: nil.	self provides: #('SystemEditor').	self dependsOn: #('SystemEditor-Squeak').! !!PackagesDevU methodsFor: 'Kernel' stamp: 'kph 12/13/2008 02:10'!SystemEditorCore	self name: 'SystemEditor-Core'.	self version: '1.156'.	info category: 'Kernel'.	info description: 'SystemEditor from MC development effort, now supported by Monticello 1.6'.	info maintainer: 'kph <keith_hodges@yahoo.co.uk>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SystemEditor/SystemEditor-Core-mtf.156.mcz'.	self provides: #('SystemEditor-Core').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Kernel' stamp: 'kph 12/13/2008 02:10'!SystemEditorSqueak	self name: 'SystemEditor-Squeak'.	self version: '1.165'.	info category: 'Kernel'.	info description: 'SystemEditor from MC development effort, now supported by Monticello 1.6'.	info maintainer: 'kph <keith_hodges@yahoo.co.uk>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/SystemEditor/SystemEditor-Squeak-mtf.165.mcz'.	self provides: #('SystemEditor-Squeak').	self dependsOn: #('SystemEditor-Core').! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!Tamaris	self name: 'Tamaris'.	self version: '0.61'.	info category: 'Development'.	info description: 'Tamaris is an object explorer for squeak.'.	info maintainer: 'Nicolas Petton'.	info homepage: 'http://cassoulet.univ-brest.fr/squeak/Tamaris'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Tamaris/Tamaris-apl.61.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!TechoBase	self name: 'Techo-Base'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'Techo is:-Multiple workspace stored plain text file-Notepad without file name-Grep tool(but not real REgexp).It is very simple tool, but useful to make a memo, to exchange oneliner among Squeak images, and to play a text base Smalltalk programming puzzle.'.	info maintainer: ''.	info homepage: 'http://map.squeak.org/package/2fa59952-dde7-426c-8823-5d70791cae76'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/DeveloperWorkspace/Techo-Base-tbn.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'IDE' stamp: 'kph 9/10/2008 10:09'!TechoShout	self name: 'Techo-Shout'.	self version: '4'.	info category: 'IDE'.	info description: 'Techo is:-Multiple workspace stored plain text file-Notepad without file name-Grep tool(but not real REgexp).It is very simple tool, but useful to make a memo, to exchange oneliner among Squeak images, and to play a text base Smalltalk programming puzzle.'.	info maintainer: ''.	info homepage: 'http://map.squeak.org/package/2fa59952-dde7-426c-8823-5d70791cae76'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/DeveloperWorkspace/Techo-Shout-tbn.4.mcz'.	self provides: #().	self dependsOn: #('Shout').! !!PackagesDevU methodsFor: 'Network' stamp: 'kph 9/10/2008 10:09'!Telnet	self name: 'Telnet'.	self version: '301'.	info category: 'Network'.	info description: 'This package contains various components that facilitate interactive loginto a remote (or the local) machine:* a (glass) TeletypeMorph;* essentially complete emulation of vt52, vt102 and xterm terminals;* a telnet client for connecting to remote machines;* a `pseudo-tty'' client for connecting to an interactive shell on the local machine;* a protocol stack abstraction that glues the above together; and* a TeletypeWindow morph which makes a clickable application out of it all.The pseudo-tty client will only work on Unix, but the telnet client shouldwork fine on any platform (Unix, Mac, Windows, etc.) that supports sockets.Please visit the homepage for further details (especially if you want to usethe pseudo-tty client, since you may have to download an additional changeset).'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/telnet.301.cs'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!TestBrowser	self name: 'TestBrowser'.	self version: '120'.	info category: 'Development'.	info description: ''.	info maintainer: ''.	info homepage: 'http://www.squeaksource.com/DeveloperWorkspace/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/DeveloperWorkspace/TestBrowser-tbn.120.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'test 1/13/2009 15:56'!Thrift	self name: 'Thrift'.	self version: '1.0'.	info category: 'Persistence'.	info description: ''.	info maintainer: 'shute'.	info homepage: 'http://www.squeaksource.com/CassandraClient.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/CassandraClient/Thrift-shute.1.mcz'.	self provides: #('Thrift').	self dependsOn: #().! !!PackagesDevU methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!TimeZoneDatabase	self name: 'TimeZoneDatabase'.	self version: '1.2.5'.	info category: 'Uncategorized'.	info description: 'This is a time zone database for Smalltalk. It answers the number of secondsoffset from UTC for any time zone at any point in time in the range of thedatabase rule set, as well as the number of leap seconds for a point in time(for tzfiles which contain the leap second rules).A full time zone database requires access to tzfile data files, typicallydistributed with Unix (Linux) systems. A limited set of tzfile files is providedto initialize the database and demonstrate its functions.~'.	info maintainer: 'Dave Lewis <lewis@mail.msen.com>'.	info homepage: 'http://wiki.squeak.org/squeak/1076'.	info squeakMapID: ''.	info url: 'http://wiki.squeak.org/squeak/uploads/1076/TimeZoneDatabaseV1-2-5-dtl.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Web Development' stamp: 'kph 9/10/2008 10:09'!TinyWiki	self name: 'TinyWiki'.	self version: '1.0.1'.	info category: 'Web Development'.	info description: 'TinyWiki is a tiny wiki implementation based on the model of SmallWiki.'.	info maintainer: 'pmm'.	info homepage: 'http://www.squeaksource.com/ss2.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ss2/TinyWiki-pmm.16.mcz'.	self provides: #().	self dependsOn: #('Seaside' 'SmaCC runtime').! !!PackagesDevU methodsFor: 'Tools' stamp: 'kph 9/10/2008 10:09'!ToolBuilderExamples	self name: 'ToolBuilder-Examples'.	self version: '4'.	info category: 'Tools'.	info description: 'These are some examples for ToolBuilder.'.	info maintainer: 'Andreas Raab'.	info homepage: 'http://www.squeaksource.com/ToolBuilder'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ToolBuilder/ToolBuilder-Examples-cwp.4.mcz'.	self provides: #().	self dependsOn: #('ToolBuilder-Kernel').! !!PackagesDevU methodsFor: 'Tools' stamp: 'kph 9/10/2008 10:09'!ToolBuilderKernel	self name: 'ToolBuilder-Kernel'.	self version: '27'.	info category: 'Tools'.	info description: 'ToolBuilder is a user interface builder that can be used to create user interfaces for multiple platforms.'.	info maintainer: 'Michael van der Gulik (mikevdg@gmail.com)'.	info homepage: 'http://www.squeaksource.com/ToolBuilder'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ToolBuilder/ToolBuilder-Kernel-mvdg.27.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Tools' stamp: 'kph 9/10/2008 10:09'!ToolBuilderMVC	self name: 'ToolBuilder-MVC'.	self version: '14'.	info category: 'Tools'.	info description: 'This is the MVC package for ToolBuilder.'.	info maintainer: 'Michael van der Gulik'.	info homepage: 'http://www.squeaksource.com/ToolBuilder'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ToolBuilder/ToolBuilder-MVC-dc-14.mcz'.	self provides: #('ToolBuilder-Implementation').	self dependsOn: #('ToolBuilder-Kernel').! !!PackagesDevU methodsFor: 'Tools' stamp: 'kph 9/10/2008 10:09'!ToolBuilderMorphic	self name: 'ToolBuilder-Morphic'.	self version: '27'.	info category: 'Tools'.	info description: 'ToolBuilder is a package which allows you to create multi-platform user interfaces.This is the Morphic platform for ToolBuilder.'.	info maintainer: 'Michael van der Gulik'.	info homepage: 'http://www.squeaksource.com/ToolBuilder'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ToolBuilder/ToolBuilder-Morphic-dc.27.mcz'.	self provides: #('ToolBuilder-Implementation').	self dependsOn: #('ToolBuilder-Kernel').! !!PackagesDevU methodsFor: 'Tools' stamp: 'kph 9/10/2008 10:09'!ToolBuilderSpecs	self name: 'ToolBuilder-Specs'.	self version: '1'.	info category: 'Tools'.	info description: 'ToolBuilder-Specs'.	info maintainer: 'Andreas Raab'.	info homepage: 'http://www.squeaksource.com/ToolBuilder'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ToolBuilder/ToolBuilder-Specs-ar.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Tools' stamp: 'kph 9/10/2008 10:09'!ToolBuilderTweak	self name: 'ToolBuilder-Tweak'.	self version: '23'.	info category: 'Tools'.	info description: 'This is the Tweak package for ToolBuilder.Note that Tweak must be installed to use this package.'.	info maintainer: ''.	info homepage: 'http://www.squeaksource.com/ToolBuilder'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/ToolBuilder/ToolBuilder-Tweak-pe.23.mcz'.	self provides: #('ToolBuilder-Implementation').	self dependsOn: #('ToolBuilder-Kernel').! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'kph 9/10/2008 10:09'!Toothpick	self name: 'Toothpick'.	self version: '0.1'.	info category: 'Model Extension'.	info description: 'Toothpick is a simple tool for logging things of interest in Smalltalk. It''''s easy to use, very lightweight, and highly configurable. The basic design idea behind Toothpick was to separate something to be logged from the three things one needs to think about when logging it:* Whether to log it* Where to log it* How to log itEach of these three aspects is represented by a separate class hierarchy, and you can mix and match aspects to provide you with the optimal logging solution for your needs.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.metaprog.com/Toothpick'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Toothpick/Toothpick-tbn.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 9/10/2008 10:09'!TraitsOmniBrowser	self name: 'TraitsOmniBrowser'.	self version: '0.39'.	info category: 'Code Browsing'.	info description: 'This extends the Omnibrowser to work with Traits enabled Squeak. Prerequisites: OmniBrowser package installed on Squeak with Traits.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.squeaksource.com/TraitsOmniBrowser.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/TraitsOmniBrowser/TraitsOmniBrowser-dc.39.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Development' stamp: 'kph 9/10/2008 10:09'!Typeinference	self name: 'Typeinference'.	self version: '1'.	info category: 'Development'.	info description: 'This is Francisco Garau''s TypeInferencer, as a SAR package.This does not contain the Morphic-Wrapper dependendparts.                                             For more information, see http://typeinference.swiki.net/1'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/TypeInference.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Mathematics' stamp: 'kph 9/10/2008 10:09'!Units	self name: 'Units'.	self version: '4'.	info category: 'Mathematics'.	info description: 'The Units package allows you to represent, convert, and perform arithmetic with physical unit values (e.g. distances, velocities, accelerations, etc).There is not much formal documentation, but most of the classes in this package have comments. The most important methods are those in Unit and UnitValue. You should look through all those.To add your own units, see the classes BaseUnit, DerivedUnit, NamedUnit, and PrefixedUnit, and look through the initialization code. You should duplicate what is done there to add your own units. Remember to send Unit initialize to make your changes take effect.Note that you can send  Unit printAbbreviated: true  or  Unit printAbbreviated: false  to control how units print.Ported to Squeak by Helge Horch'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Units/Units-md.4.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Group Development' stamp: 'damiencassou 2/17/2009 18:56'!Universes	self name: 'Universes'.	self version: '52'.	info category: 'Group Development'.	info description: 'Package universes is a toolset that supports reliable, automatic installation of packages via a package-browsing tool.  The approach of the tools is that users operate within one universe, and each universe only has a large but limited set of packages available.  Thus, a universe sets a context that simplifies other aspects of the tools including package naming, dependency management, and package-update policies. '.	info maintainer: '"Lex Spoon" <lex@lexspoon.org>'.	info homepage: 'http://www.squeaksource.com/universes/'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/universes/Universes-kph.52.mcz'.	self provides: #().	self dependsOn: #('YAXO').! !!PackagesDevU methodsFor: 'Group Development' stamp: 'kph 11/2/2008 00:30'!UniversesOmniBrowser	self name: 'Universes OmniBrowser'.	self version: '0.38'.	info category: 'Group Development'.	info description: 'Provides a better universe browser based on the OmniBrowser framework.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/OBUniverse/OBUniverse-Dan%20Corneanu.38.mcz'.	self provides: #().	self dependsOn: #('OmniBrowser-Full' 'Universes').! !!PackagesDevU methodsFor: 'Model Extension' stamp: 'kph 9/10/2008 10:09'!VBRegex	self name: 'VBRegex'.	self version: '1.9'.	info category: 'Model Extension'.	info description: 'A pure Smalltalk regular expression matcher.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: 'http://www.squeaksource.com/Regex.html'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Regex/VB-Regex-sd.9.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'System' stamp: 'kph 9/10/2008 10:09'!VMMaker	self name: 'VMMaker'.	self version: '3.8b6.1'.	info category: 'System'.	info description: 'his package includes all the ObjectMemory/Interpreter classes, the VMMaker/Tool classes, the InterpreterPlugin hierarchy and all the assorted helper methods. It does <em>not</em> include the handwritten platform specific C code that you will also need. See the documentation for the specific release for more details.If you install this you will be able to build or simulate a VM or plugin - as long as you have the platform sources tree from our SubVersion server.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/VMMaker'.	info squeakMapID: ''.	info url: 'http://map.squeak.org/accountbyid/4340a66e-2296-48b7-9aa8-5305d303752f/files/VMMaker-3.8b6.mcz'.	self provides: #().	self dependsOn: #('FFI' 'Speech').! !!PackagesDevU methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!VersionNumber	self name: 'VersionNumber'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'I am a version number. My representation allows me to handle an entire tree of versions. From a directory listing of verison numbered files, I can infer things about the tree of versions.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/VersionNumber.st'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 9/10/2008 10:09'!VersionsBrowser	self name: 'VersionsBrowser'.	self version: '1.0'.	info category: 'Code Browsing'.	info description: 'This is the new version of the VersionsBrowser for use with 3.10 and beyond. It has been refactored to support the (future) archaeological work over the entire history of the Squeak source code.'.	info maintainer: 'Maurice Rabb'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/Archaeology/Tools-Archaeology-m3r.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!VideoandImageProcessing	self name: 'Video and Image Processing'.	self version: '2.1'.	info category: 'Uncategorized'.	info description: 'Mini-framework and tool for play with video in Squeak. You have filters that you can push in a stack, the output of the first filter is processed by the second and so on. The filters available today are: BackgroundSubstraction, GrayScale, Rotator, Mirror, Trail, Melt, Labeler, Mosaic, DepthChanger, Nervous, Delayer, Old TV, Emboss, Enhanced Focus, Blur, Edge Detector, Enhanced Edges and Soften. Add new filters is so easy, take a Form and give me a Form.Today is posible to get a video from a mpeg file or from a camera (the camera supports works only in windows).'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net/universes/repositories/squeak-3.9/VideoAndImageProcessing-dgd.1.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Morphs' stamp: 'kph 9/10/2008 10:09'!WanderingLetters	self name: 'WanderingLetters'.	self version: '22Feb-2.1'.	info category: 'Morphs'.	info description: 'This is wandering letters using the old non-Players (and non-multi-instance Players).  Just make a new Morphic Project and file it in. Toggle wandering by clicking the top button.  Responds to Stop and Go buttons so it does not have to be running all the time.Toggle method if getting back to their right places with the lower button.Change WanderingLetters>>stepTime to make the speed be right.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/WanderingLetters.22Feb-02.1.cs'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Morphs' stamp: 'kph 9/10/2008 10:09'!WarpSketchMorph	self name: 'WarpSketchMorph'.	self version: '1.12'.	info category: 'Morphs'.	info description: 'Playing with squeak morphic, I saw WarpBlt which seems to provide exactly the functionality I need to port an old java applet I did in 1997. WarpSketchMorph is a Morphic implementation similar to my DynFlex applet. Most fun is modifying images of faces.You can create a WarpSketchMorph either by evaluatingWarpSketchMorph new openInWorld.and choose an image with the "Choose new graphic..." halo menu item or use(WarpSketchMorph withForm: <yourForm>) openInWorld.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/WarpSketch.012.pr'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 9/10/2008 10:09'!WhiskerBrowser	self name: 'Whisker Browser'.	self version: '1.0'.	info category: 'Code Browsing'.	info description: 'Whisker is a different sort of object-oriented code browser for the Squeak Smalltalk environment.The goal of the Whisker Browser (a.k.a. Stacking Browser) is to provide a simple and intuitive way to view the contents of multiple classes and multiple methods simultaneously, while using screen real estate efficiently and not requiring a lot of window moving/resizing. It does this by introducing the concept of subpane stacking. The principles behind Whisker could potentially be used by browsers for other object-oriented languages (Java, Python, etc.).To open the Whisker Browser, use the ''open...''/''Whisker Browser'' menu item in the World menu.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Whisker1_0-Sq37.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Fonts' stamp: 'kph 9/10/2008 10:09'!X11Fonts	self name: 'X11Fonts'.	self version: '1-2'.	info category: 'Fonts'.	info description: 'SAR containing various X11 fonts using ISO-8859-15 encoding(similar to Latin-1 but the Euro sign is where it should be).Install from this archive to add TimesRoman, Helvetica, Courierand Fixed to the available system fonts, in various point sizes.Note that this archive neither creates any new methods in theimage, nor does it create any files in the working directory duringinstallation.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/x11fonts.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Persistence' stamp: 'damiencassou 1/21/2009 13:12'!YAXO	self name: 'YAXO'.	self version: '14'.	info category: 'Persistence'.	info description: 'XML toolkit'.	info maintainer: ''.	info homepage: 'http://www.squeaksource.com/XMLSupport'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/XMLSupport/XML-Parser-mir.14.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Games' stamp: 'kph 9/10/2008 10:09'!ZigZag	self name: 'ZigZag'.	self version: '0.1'.	info category: 'Games'.	info description: 'Categoring system influenced by Ted Nelson''s ZigZag with graphical visualisation.'.	info maintainer: 'Lex Spoon <lex@lexspoon.org>'.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/zigzag.sar'.	self provides: #().	self dependsOn: #().! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'test 1/13/2009 15:56'!eCompletion	self name: 'eCompletion'.	self version: '0.102'.	info category: 'Code Browsing'.	info description: 'Complete variables, selectors, class names in your browser, workspace, debugger and other code holders.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.squeaksource.com/eCompletion'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/eCompletion/ECompletion-damiencassou.102.mcz'.	self provides: #().	self dependsOn: #('RoelTyper' 'Shout').! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 11/2/2008 00:30'!eCompletionOmniBrowser	self name: 'eCompletionOmniBrowser'.	self version: '0.5'.	info category: 'Code Browsing'.	info description: ''.	info maintainer: ''.	info homepage: 'http://www.squeaksource.com/eCompletion'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/eCompletion/ECompletionOmniBrowser-dr.5.mcz'.	self provides: #().	self dependsOn: #('OmniBrowser' 'eCompletion').! !!PackagesDevU methodsFor: 'Code Browsing' stamp: 'kph 9/10/2008 10:09'!eCompletionTraits	self name: 'eCompletion-Traits'.	self version: '0.1'.	info category: 'Code Browsing'.	info description: 'Complete variables, selectors, class names in your browser, workspace, debugger and other code holders.This package brings trait functionalities to eCompletion.'.	info maintainer: 'Damien Cassou <damien.cassou@gmail.com>'.	info homepage: 'http://www.squeaksource.com/eCompletion'.	info squeakMapID: ''.	info url: 'http://www.squeaksource.com/eCompletion/ECompletionTraits-bar.1.mcz'.	self provides: #().	self dependsOn: #('eCompletion').! !!PackagesSqueak37 methodsFor: 'as yet unclassified' stamp: 'kph 7/7/2008 03:37'!DynamicBindings    self name: 'DynamicBindings'.    info category: 'Languages and Extensions'.    info description: 'DynamicBindings for Squeakby Stephen Pair <stephen@pairhome.net> ===== Introduction =====You may create a hierarchy of DynamicBindings and directly manipulate the keys and values of those instances (just as you would any dictionary).  There is a root DynamicBindings that you may use to create new children if you like (but you can also create entirely separate hierarchies).  You can access this root with "DynamicBindings root".  To force a process to use one of your sets of DynamicBindings, you write code as follows (note, I only use ''PATH'' to highlight the similarity with normal OS environment variables):	myBindings _ DynamicBindings root newChild.	myBindings at: #PATH put: ''/bin:/usr/bin''.	myBindings bindDuring: 		[Bindings at: #PATH.  				"-> ''/bin:/usr/bin''"		Bindings at: #PATH put: (''/usr/local/bin:'', (Bindings at: #PATH)).		Bindings at: #PATH].  				"-> ''/usr/local/bin:/bin:/usr/bin''"For convenience, two methods have been added to Object that enable more direct access to bindings.  The following exampel is equivalent to the first:	myBindings _ DynamicBindings root newChild.	myBindings at: #PATH put: ''/bin:/usr/bin''.	myBindings bindDuring: 		[#PATH binding.  				"-> ''/bin:/usr/bin''"		#PATH binding: (''/usr/local/bin:'', (#PATH binding)).		#PATH binding].  				"-> ''/usr/local/bin:/bin:/usr/bin''"The first line creates a new set of bindings that is a child of the root bindings.  Any variables set in the root bindings are also visible in this new child environment.The second line sets the dynamic variable "PATH".The third line uses the evaluates the argument block in the context of our new set of bindings.The fourth line gets the value for the variable "PATH" (which we just set).The fifth line in the above example modifies the environment variable "PATH", but only for the duration that the enclosing block is active.Here is another example:	#PATH binding: ''/bin''.	Bindings clamp:		[#PATH binding: ''/usr/bin''.		#PATH binding]. 						"-> ''/usr/bin''"	#PATH binding.								"-> ''/bin''"This example shows the use of the #clamp: method to isolate a our dynamic bindings only for the duration of a block.  After the block finishes execution, the original set of bindings is restored.Scoping semantics:A dynamic variables'' scope is defined at runtime by an enclosing activation context.  To locate the active lexicon of dynamic variables, the system follows the activation stack until a context is encountered that defines the active DynamicBindings (this lookup is implemented using the exception handling system).  Any changes to the active DynamicBindings are visible in all activation contexts where that set of DynamicBindings are being used (which may include contexts in more than one activation stack).A bit about how it''s implemented:The bindings for a given method activation context are located using the exception handling mechanism (see BindingsLocator).  If a given stack does not have a handler that answers a set of bindings, then dummy contexts will be added to the top of the stack that will answer the global root set of bindings.Unlike other implementations, DynamicBindings do not use the activation stack to define the hierarchy of bindings.  Instances of DynamicBindings have their own parent instance variable and will locate enclosing variable scopes by following the chain of parents (*not* by looking for enclosing handlers of BindingsLocator).  Using this design, we are able to accomodate a broader range of usage scenarios.If you need to isolate the bindings of a given context stack such that future changes in the bindings are not visible to users of the current set of dynamic bindings (ie. if you use continuations), you can send the message #isolate to the BindingsAccessor (ie. use "Bindings isolate").===== Release History =====Version 1.1:	- Packaged using KomPackaging (Squeak version only)	- Made Object>>binding: answer its argument	- Cleaned up a few obsolete methods from the old RuntimeEnvironments implementationVersion 1.0:	- Initial release'.    info maintainer: 'Lex Spoon <lex@lexspoon.org>'.    info homepage: ''.    info squeakMapID: ''.    info url: 'http://www.squeaksource.com/KomHttpServer/DynamicBindings-gc.7.mcz'.    self version: '2.7'.    self provides: #().    self dependsOn: #().    self load: [        Installer installUrl:'http://www.squeaksource.com/KomHttpServer/DynamicBindings-gc.7.mcz'.    ].    self unload: [        Installer mc unload: 'DynamicBindings'.    ].! !!PackagesSqueak37 methodsFor: 'as yet unclassified' stamp: 'kph 4/24/2008 20:50'!KomHttpServer    super KomHttpServer.    info url: 'http://www.squeaksource.com/KomHttpServer/KomHttpServer-gk.31.mcz'.    self version: '7.0.31'.    self provides: #().    self dependsOn: #('KomServices').    self load: [        Installer installUrl:'http://www.squeaksource.com/KomHttpServer/KomHttpServer-gc.31.mcz'.    ].! !!PackagesSqueak37 methodsFor: 'as yet unclassified' stamp: 'kph 4/24/2008 20:51'!KomServices    super KomServices.    info url: 'http://www.squeaksource.com/KomHttpServer/KomServices-klc.13.mcz'.    self version: '1.13'.    self load: [        Installer installUrl:'http://www.squeaksource.com/KomHttpServer/KomServices-klc.13.mcz'.    ].! !!PackagesSqueak37 methodsFor: 'as yet unclassified' stamp: 'kph 4/24/2008 20:51'!Scriptaculous   super Scriptaculous.    info url: 'http://www.squeaksource.com/Seaside.html'.    self version: '2.8.240'.    self load: [        Installer ss project: 'Seaside'; install: 'Scriptaculous-lr.240'.    ].! !!PackagesSqueak37 methodsFor: 'as yet unclassified' stamp: 'kph 4/24/2008 20:51'!Seaside    self name: 'Seaside'.    info category: 'Web Development'.    info description: 'A framework for building sophisticated web applications in Squeak. Develop for the web using reusable, embeddable components and unique call/return semantics for moving between pages.'.    info maintainer: 'Lukas Renggli <renggli@gmail.com>'.    info homepage: 'http://www.seaside.st/'.    info squeakMapID: ''.    info url: 'http://www.squeaksource.com/Seaside/Seaside2.8a1-pmm.541.mcz'.    self version: '2.8.541'.    self load: [        Installer squeaksource			project: 'Seaside';			answer: '*config*' with: 'seaside';			answer: '*password*' with: 'admin';			install:'Seaside2.8a1-lr.541.mcz'.    ].! !!PackagesSqueak37 methodsFor: 'as yet unclassified' stamp: 'kph 7/7/2008 03:37'!Seaside25    self name: 'Seaside'.    info category: 'Uncategorized'.    info description: 'A framework for building sophisticated web applications in Squeak.  Develop for the web using reusable, embeddable components and unique call/return semantics for moving between pages.Seaside requires a web server; the most commonly used is KomHttpServer.'.    info maintainer: ''.    info homepage: ''.    info squeakMapID: ''.    info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Seaside2.5b3.mcz'.    self version: '2.5b3'.    self provides: #().    self dependsOn: #('KomHttpServer').    self load: [        Installer installUrl:'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Seaside2.5b3.mcz'.    ].    self unload: [        Installer mc unload: 'Seaside2.5b3'.    ].! !!PackagesSqueak37U class methodsFor: 'as yet unclassified' stamp: 'kph 1/27/2008 20:31'!universeSelector	^ #squeak37Universe! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Actalk	self name: 'Actalk'.	self version: '3.0.6.23112002'.	info category: 'Uncategorized'.	info description: 'The Actalk testbed is designed to help understanding, classifying, designing, combining, and experimenting with various OOCP languages and constructs.Actalk is implemented and integrated within Squeak environment. The testbed includes the kernel which models basic OOCP model (that is serialized active objects and asynchronous message passing), and various extensions in order to simulate various OOCP languages and constructs.They implement various models of activity (serial, quasi-concurrent, concurrent...), communication (asynchronous, synchronous, eager, express...), and synchronization (to control/delay acceptance of messages).Actalk stands for active objects, or also actors, in Smalltalk. '.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Actalk-3.06.23112002.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!AioPlugin	self name: 'AioPlugin'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'AioPlugin provides support for asynchronous IO event notification. When an external IO event occurs, the event registration causes a Smalltalk semaphore to be signaled. A process can waiton this semaphore, thereby acting as an event handler for the external event. Currently this works with the Unix VM.UnixAioPlugin implements the primitives that interact with the aio mechanism in the Unix VM. Other platform-specific subclasses could be written to provide a compatible aio mechanism forother platforms.AioEventHandler provides image side support for aio event notification. An AioEventHandler is an object that waits for an external IO event to occur, then sends #changed to itself. Anyobject that is interested in the external event can register itself as a dependent of the AioEventHandler, and take appropriate action whenever the external event occurs.AioEventHanderExample demonstrate asynchronous read handers for file streams, OS pipes, standard input, and sockets. See class category ''examples''. Some examples require OSProcess.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/AioPluginV1-1.sar'.	self provides: #().	self dependsOn: #('VMMaker').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Algebraic	self name: 'Algebraic'.	self version: '0.1'.	info category: 'Uncategorized'.	info description: 'This package is intented for providing you with various algebraic objects. Currently there is only support for complex numbers (quite useful) and matrices (very basic).Complex number collaborates with other kinds of numbers and vice versa.Matrix can be multiplied by some number.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Algebraic.1.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!AnnotatedMethodPuller	self name: 'AnnotatedMethodPuller'.	self version: '0.1'.	info category: 'Uncategorized'.	info description: 'Before you install this package, you must install MethodAnnotations.Gathers up items from class-side methods in the image with annotations saying <register: #(foo)>. Useful with the Registry class.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/AnnotatedMethodPuller.st'.	self provides: #().	self dependsOn: #('Method Annotations').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!AppRegistry	self name: 'AppRegistry'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'AppRegistry is just a simple class that emerged from our attempts to create removal packages for applications like Celeste and Scamper. An AppRegistry holds a list of applications of a certain type (for example, mail senders or web browsers), so that you can get a web browser by writing "WebBrowser default" instead of hard-coding "Scamper".'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/AppRegistry.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!AppearanceMenuRegistry	self name: 'Appearance Menu Registry'.	self version: '2003.4.15'.	info category: 'Uncategorized'.	info description: 'Provides a menu registry for the world appearance menu.  For example...	TheWorldMenu registerAppearanceCommand: {		''set desktop image...''. 		{FileList2. #openMorphicViewWithPreviewInWorld}. 		''open up an image browser to choose a new desktop background''}.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/AppearanceMenuReg-sbw.released.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Array2D	self name: 'Array2D'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'A simple 2D-Array implementation. Neither storing nor sorting (otherwise inherited from ArrayedCollection) will work. Neither comparing nor most accessing mehods inherited from Sequenceable collection will work.  Actually, it''s a bad idea to inherit this class from collection at all!!!!!!This used to be part of the image. This SqueakMap package is providedfor backward-compatibility.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Array2D-md.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!AspectS	self name: 'AspectS'.	self version: '0.4.6'.	info category: 'Uncategorized'.	info description: 'AspectS is an approach to general-purpose aspect-oriented programming in the Squeak/Smalltalk environment. Based on concepts of AspectJ it extends the Smalltalk metaobject protocol to accommodate the aspect modularity mechanism. In contrast to systems like AspectJ, weaving and unweaving in AspectS happens dynamically at runtime, on-demand, employing metaobject composition. Instead of introducing new language constructs, AspectS utilizes the expressiveness of Smalltalk itself as a pointcut language.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/AspectS.25Jun1255.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Assertions	self name: 'Assertions'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'This is the port of Vassili Bykov''s assertions for Squeak, originally released for Squeak 2.7(yes, 1.0 version later ...).The port includes now a preference to toggle assertions on or off,and a unit test to show you it works ;-)'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Assertions-rr.4.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!BFAV2	self name: 'BFAV2'.	self version: '2.11'.	info category: 'Uncategorized'.	info description: 'The BFAV2 is a cleaned-up, faster, more powerful second version of the "BFAV"; the acronym stands for Bug Fixes Archive Viewer.  The BFAV2 is a tool meant to empower bug/fix/enhancement reviewers and harvesters in the Squeak community.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/BFAV-tlk.165.mcz'.	self provides: #().	self dependsOn: #('HTTPClient').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!BRegexpforSqueak	self name: 'BRegexp for Squeak'.	self version: '2'.	info category: 'Uncategorized'.	info description: 'BRegexp is Perl5 compatible regular expression library for Squeak.-Supports multilingualized Squeak.-Supports only Windows environment.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/BRegexp.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!BTree	self name: 'BTree'.	self version: '28'.	info category: 'Uncategorized'.	info description: 'This is an implementation of the BTree data structure as a Smalltalk collection.  It provides log(n) inserts, deletes, and retrieves of values by key.  The keys have to be sortable (ie, Magnitudes).This is useful in situations where you want to minimize the number and size of individual objects that need to be accessed when using a large collection - for example, when objects are being swapped out to an object database such as GOODS.  It is probably not a good choice for a collection that will be kept entirely in memory.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Collections-BTree-avi.28.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!BackgroundLoader	self name: 'Background Loader'.	self version: '20040425'.	info category: 'Uncategorized'.	info description: 'Provides a previewer for images that can be loaded as the desktop. Accessed via the appearance menu, just as before. The modified file browser is produced for background image browsing. This new version provides options over how the image is placed in the desktop.For a picture and more details see <a href="http://squeak.preeminent.org">http://squeak.preeminent.org</a>'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/DesktopBackgroundLoader-sbw.mcz'.	self provides: #().	self dependsOn: #('Appearance Menu Registry').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Balloon3D	self name: 'Balloon3D'.	self version: '1.0.3'.	info category: 'Uncategorized'.	info description: ''.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Balloon3D.1.0.3.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Befunge93	self name: 'Befunge''93'.	self version: '0.0.2'.	info category: 'Uncategorized'.	info description: 'This is the basis for the next generation of InterpreterProxy ;)'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Befunge%2093.16.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!BerkeleyDBPlugin	self name: 'Berkeley DB Plugin'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'This is an interface to Sleepycat''s Berkeley DB (www.sleepycat.com).  Currently, it supports simple database creation and manipulation using the BTREE access method.  The plan is to eventually grow this implementation to support the complete Berkeley DB api.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/BerkeleyDB.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!BinarySavingMC	self name: 'BinarySavingMC'.	self version: '29'.	info category: 'Uncategorized'.	info description: 'It adds a new preference "binary saving"'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/BinarySavingMC-ab.29.mcz'.	self provides: #().	self dependsOn: #('Monticello').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!BitArray	self name: 'BitArray'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'Simple implementation of BitArray, which stores the bits.For the basic random access operations for a rather shorter array, you might want to consider ByteArray.BitArray supports the conversion from/to integers.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/BitArray1.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!BlogBrowser	self name: 'BlogBrowser'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'BlogBrowser is a minimal blog reader which supports the following features:  - Subscribe to RSS and Atom feeds  - Manage subscriptions in the Squeak image and save them to a text file  - Tracks read/unread items (but only in the image)'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/BlogBrowser-rkris.6.mcz'.	self provides: #().	self dependsOn: #('Network-HTML' 'YAXO').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!BreakOut	self name: 'BreakOut'.	self version: '5'.	info category: 'Uncategorized'.	info description: 'I designed this breakout slowly refactoring it step by steps because it was part of a book on OOP but I''m thinking to cancel this book and putting a draft on the web. This is the final version of the breakout.The bouncing is not that good. Have fun first, then submit a fix for the ball bouncing or any new bonuses. I would like also to have bonuses falling down. '.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/BreakOut-sd.5.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!BrowserInheritanceIcons	self name: 'BrowserInheritanceIcons'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'I can''t remember the color codes of the inheritance button in the browser. The balloon description does not help too much, because I don''t know how mauve or tan are supposed to look like. And I think even synaesthetic people don''t associate pink with "is an override but doesn''t call super". I added a few icons and made it only signal super sends to an overridden method.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/BrowserInheritanceIcons-laza.4.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Cassowary	self name: 'Cassowary'.	self version: '0.60'.	info category: 'Uncategorized'.	info description: 'This is a port of the Smalltalk version of Cassowary 0.60.  As the original authors put it, ''Cassowary is an incremental constraint solving toolkit that efficiently solves systems of linear equalities and inequalities.''.  More information can be found at:http://www.cs.washington.edu/research/constraints/cassowary/'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Cassowary.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Celeste	self name: 'Celeste'.	self version: '1.23'.	info category: 'Uncategorized'.	info description: 'An email reader for Internet email.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Network-Mail%20Reader-ls.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!CelesteTests	self name: 'Celeste Tests'.	self version: '3'.	info category: 'Uncategorized'.	info description: 'Some tests for Celeste.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Tests-Network-Mail.st'.	self provides: #().	self dependsOn: #('Celeste').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Chuck	self name: 'Chuck'.	self version: '23'.	info category: 'Uncategorized'.	info description: 'Chuck is a type inferencer for Squeak program code.  Type inference allows programmers and tools to find the type of a variable or expression in the program.  This information is useful directly, and it is also helpful for improving tools like the system browser.  For example, the senders-of query can look not only at message selectors, but at queried receiver types, in order to decide which message sends to show the user.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Chuck-Standard-ls.23.mcz'.	self provides: #().	self dependsOn: #('Chuck Repository' 'Monticello' 'Refactoring Browser').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ChuckRepository	self name: 'Chuck Repository'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'This tells your image''s Monticello tools about Chuck''s code repository on SqueakSource.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ChuckRepository.1.cs'.	self provides: #().	self dependsOn: #('Monticello').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!CollectionsMisc	self name: 'Collections-Misc'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'Ported from the old collections-misc goodie by Mario Wolczko.This goodie contains a variety of methods and classes whichadd functionality to collections.  Nothing is particularly startling,but you may find the odd useful method.  I use these quite a lot.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Collections-Misc.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!CommandShell	self name: 'CommandShell'.	self version: '3.0.1'.	info category: 'Uncategorized'.	info description: 'CommandShell is a Smalltalk simulation of a Unix command shell, with a simpledumb terminal window in Morphic and MVC. It is useful for running programswithout leaving Squeak, and for piping command output directly into Squeak.Can be loaded and run on any platform, but is most useful on Unix, Linux andWindows systems with OSProcess. On Windows, command pipelines are not yetimplemented for external commands, but you can run Windows programs from theCommandShell "Squeak shell" as well as pipelines with internal shell commands.A simple script processing capability is also included.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/CommandShellV3-0-1-dtl.sar'.	self provides: #().	self dependsOn: #('OSProcess').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Compiler	self name: 'Compiler'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'The Squeak compiler.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Compiler-md.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!CompletionEnhancements	self name: 'Completion Enhancements'.	self version: '3'.	info category: 'Uncategorized'.	info description: 'Enhances squeak''s completion system, byproposing all completions in a menu (keyboard-sensitive), includings class varsand temps vars if appropriate.Most recent version works in 3.7, but the older one works insqueak 3.2 to 3.6.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Completion-rr.3.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!CompletionMorph	self name: 'Completion Morph'.	self version: '0.15-alpha'.	info category: 'Uncategorized'.	info description: 'Completion system with pop up listing morph'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/CompletionMorph-0-15.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!CompressedSourcesFile	self name: 'Compressed Sources File'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'CompressedSourceStream writes files as a series of GZipped segments that can be written and read sequentially like regular source files, and yet remain compressed 4x on the disk.  Full sources for Squeak 3.6 fit in 3.5MB.Smalltalk compressSources will write a copy of the sources file in this format.  Thereafter openSources:forImage: will look first for such a compressed copy, and open it if found.Should work for .changes files too, but I haven''t bothered to test.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/CompressedSources-di.1.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ConflictChecker	self name: 'ConflictChecker'.	self version: '1.5'.	info category: 'Uncategorized'.	info description: 'Given a changeset filename, you can use this goodie to check an older .cs/.st file for conflicts with methods from more recent update-changesets in your image.  Its output is displayed in a Transcript window.Example usage: ''FilePackage conflictsWithUpdatedMethods: ''MyChangeSet.cs''.''  Or, use the ''conflicts with updated methods'' menu item or ''conflicts'' button in the FileList window.The ConflictChecker doesn''t just check to see which methods in a changeset would overwrite methods in the image... it actually checks to see if there have been more recent updates to the image since the changeset was created*, in which case the more recent methods would be overwritten by older methods from your changeset if you filed it in, which would likely break things.  It''s basically a 3-way conflict check.*It uses the latest update # from the .cs/.st file header as a basis for comparison.Generally, you should use a reasonably fresh image to do this, and the image should have update-changesets going as far back as possible (at least as far back as the changeset you want to test).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ConflictChecker-1_5.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Connectors	self name: 'Connectors'.	self version: '2.0.173'.	info category: 'Uncategorized'.	info description: 'Connectors is an application for making structured/connected drawings in Morphic. It adds a new kind of Morph (NCConnectorMorph) that can connect other Morphs together (and stay connected). There are also a number of other shapes, flaps, and tools for making your own drawings.It comes with some sample shapes in flaps for making UML class diagram and state diagrams.It''s also a framework for making your own structured drawing editors. There is an easy to use API for querying drawing structure, constructing drawings, and more.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ConnectorsBasic-173-Squeak37g.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!CropMorphs	self name: 'Crop Morphs'.	self version: '20040612'.	info category: 'Uncategorized'.	info description: 'Provides a menu option to allow a crop operation on an existing SketchMorph. Very handy for modifying a SketchMorph on your desktop. Also provides basic change to how a rectangle is grabbed from the screen. A new crop/grab UI design is used.See <a href="http://squeak.preeminent.org">http://squeak.preeminent.org</a> for instructions on use.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/CropOrGrabMorph-sbw.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!CropSketchMorphsandGrabScreenRecttoJPGforSqueak34	self name: 'Crop SketchMorphs and Grab Screen Rect to JPG for Squeak 3.4'.	self version: '15-apr-2003'.	info category: 'Uncategorized'.	info description: 'Provides a menu option to allow a crop operation on an existing SketchMorph. Very handy for modifying a SketchMorph on your desktop. Also provides basic change to how a rectangle is grabbed from the screen. A new crop/grab UI design is used.In addition, two new Utility methods were added and one was re-grouped. The new Utilities grabScreenAndSaveOnDiskAsJpeg will save the grabbed rectangle as a JPEG file. It also prompts you for the output file name. A default file name is provided.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/CropMorphOrGrabRect-sbw.released.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Cryptography	self name: 'Cryptography'.	self version: '0.3'.	info category: 'Uncategorized'.	info description: 'The cryptography package provides some basic cryptographic algorithms andprotocols. This change set integrates algorithms implemented by several members of the Squeak community, including Leandro Caniglia, John Maloney,Duane Maxwell, Luciano Notarfrancesco and Carlos Sarraute. There isn''t muchdocumentation, but browsing the tests (CryptoTest) will give you a pretty goodidea of how to use it.This package includes:  - Symmetric key algorithms: DES, 3DES, AES (Rijndael), ARC4  - Block cipher modes: CBC, CFB, OFB  - Hash functions: MD4, MD5, SHA1  - Public key algorithms: DSA, ElGamal, RSA  - Other stuff: HMACs, Diffie-Hellman, a random pool, a secure prng, a primes finder'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Cryptography.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!CzechKeyboard	self name: 'Czech Keyboard'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'Requires no suport from host platform.Shift-Alt-"\" ... switches cz/us keyboardHorni rada klaves ceske klavesnice:<N> ... +ì¹èø¾ýáíéShift-<N> ... 1234567890Shift-Alt-<N> ... !!!!@#$%^&*()Alt-<N> ... special squeak editor commands (untouched)+ ... hacek/krouzek (dead key)= ... carka (dead key)'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/keyboard-cz.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!DHBNumericalAnalysis	self name: 'DHB Numerical Analysis'.	self version: 'CS 4 1.0'.	info category: 'Uncategorized'.	info description: ''.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/DHBSqueakNumerical-1.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!DNSClient	self name: 'DNS Client'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'This package implements the DNS protocol (not all of it, but extending it is very easy). It includes a DNS client (a name resolver).Example (put the address of a name server):	NameResolver default servers: #((xxx xxx xxx xxx))	NameResolver default addressByName: ''squeak.org'''.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/DNS.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Debuggerkeybindings	self name: 'Debugger - key bindings'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'Provides F key bindings to support faster debugging. These keys are handled whereever your cursor is the debugger and pre-debugger windows. (Valid for windows-like keyboard having F1 to F12 keys)Debugger:F4 closeF5 send (or sept into)F6 step (or step over)F7 step throughF8 create - if corresponding package in SqueakMap is installedF9 proceedF10 restartF11 wherePreDebuggerF4 abandonF5 debugF8 create - if corresponding package in SqueakMap is installedF9 proceed'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Debugger-FKeys-TREG-1.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!DefaultExternalDropHandler	self name: 'DefaultExternalDropHandler'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'New default external drop handler that uses the FileList services to handle the file droped.Installing this ExternalDropHandler all the file-types registered in FileList become available when a file is droped in the Squeak windows. If only one service was elected, this is automatically executed, otherwise the user will be interrogated with the list of posible services via a menu.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/DefaultExternalDropHandler-dgd.2.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!DiagramBrowser	self name: 'Diagram Browser'.	self version: '25-jul-2004'.	info category: 'Uncategorized'.	info description: 'DiagramBrowser is a tool for building and classifying diagrams (or any kind of morphic drawing) in category tree fashion. DiagramBrowser is part of the Jacarandá Project but can be downloaded and used independently.Note that this package does not provide shapes for making the diagrams. You can use the excelent Connectors package or install the complete Jacaranda package.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/DiagramBrowser-hpt.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!DictionaryBrowser	self name: 'DictionaryBrowser'.	self version: '0.2'.	info category: 'Uncategorized'.	info description: 'DictionaryBrowser is a basic query and results browser for dictionary servers that implement the RFC 2229 dictionary server protocol.Use "DictionaryBrowser open" or "DictionaryBrowser openExistingWith: ''squeak''" to get started.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/DictionaryBrowser-rkris.4.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!DirectoryPlugin	self name: 'DirectoryPlugin'.	self version: '1.5'.	info category: 'Uncategorized'.	info description: 'DirectoryPlugin runs on Unix and Windows, and provides a noticable improvement in many directory and file access methods. If you use CommandShell on Unix (Linux), you should see anoverall 15X improvement based on timing the CommandShell SUnit tests with and without DirectoryPlugin.DirectoryPlugin provides access to file stat calls, which provides significant improvement to methods such as FileDirectory>>isAFileNamed, FileDirectory>>fileExists,UnixFileDirectory>>entryAt:, and similar methods.DirectoryPlugin provides a significant improvement in directory access speed on platforms with Posix style directory streams. It provides primitives for access to opendir(), readdir() andrelated calls, as well as stat() calls on named files. On Unix systems, this enables performance improvements for methods such asFileDirectory>>entries andFileDirectory>>fileAndDirectoryNames. The primitives run on Windows also, but do not improve performance.This change set hooks the directory stream primitives into UnixFileDirectory so they are in effect only for Unix systems. It hooks the file stat primitives into StandardFileStream andFileDirectory, so they provide performance improvements for both Windows and Unix systems.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/DirectoryPluginV1-5-dtl.2.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Dispatch	self name: 'Dispatch'.	self version: '10'.	info category: 'Uncategorized'.	info description: 'This provides simple CLOS-like multiple dispatch for Smalltalk methods.  It operates on a selector naming convention.  For example, you might have a generic selector #add:to:, with more specific versions #addNumber:to:, addString:to:, add:toArray:, addDictionary:toDictionary:, and so on.  With this package loaded, you would implement the generic #add:to: method like this:add: x to: y  ^ self dispatchThe most specific of the add*:to*: methods, based on the classes of self, x and y, would be invoked.  From within one of the specific implementations, you can also send "self nextMethod", which will invoke the next-most-specific version - this is like a super send but more general.Currently, this experimental implementation is absurdly slow (maybe 10 sends/s).  In the future it will likely be sped up by 2 or 3 orders of magnitude.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Dispatch-avi.10.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!DynamicBindings	self name: 'DynamicBindings'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'DynamicBindings for Squeakby Stephen Pair <stephen@pairhome.net> ===== Introduction =====You may create a hierarchy of DynamicBindings and directly manipulate the keys and values of those instances (just as you would any dictionary).  There is a root DynamicBindings that you may use to create new children if you like (but you can also create entirely separate hierarchies).  You can access this root with "DynamicBindings root".  To force a process to use one of your sets of DynamicBindings, you write code as follows (note, I only use ''PATH'' to highlight the similarity with normal OS environment variables):	myBindings _ DynamicBindings root newChild.	myBindings at: #PATH put: ''/bin:/usr/bin''.	myBindings bindDuring: 		[Bindings at: #PATH.  				"-> ''/bin:/usr/bin''"		Bindings at: #PATH put: (''/usr/local/bin:'', (Bindings at: #PATH)).		Bindings at: #PATH].  				"-> ''/usr/local/bin:/bin:/usr/bin''"For convenience, two methods have been added to Object that enable more direct access to bindings.  The following exampel is equivalent to the first:	myBindings _ DynamicBindings root newChild.	myBindings at: #PATH put: ''/bin:/usr/bin''.	myBindings bindDuring: 		[#PATH binding.  				"-> ''/bin:/usr/bin''"		#PATH binding: (''/usr/local/bin:'', (#PATH binding)).		#PATH binding].  				"-> ''/usr/local/bin:/bin:/usr/bin''"The first line creates a new set of bindings that is a child of the root bindings.  Any variables set in the root bindings are also visible in this new child environment.The second line sets the dynamic variable "PATH".The third line uses the evaluates the argument block in the context of our new set of bindings.The fourth line gets the value for the variable "PATH" (which we just set).The fifth line in the above example modifies the environment variable "PATH", but only for the duration that the enclosing block is active.Here is another example:	#PATH binding: ''/bin''.	Bindings clamp:		[#PATH binding: ''/usr/bin''.		#PATH binding]. 						"-> ''/usr/bin''"	#PATH binding.								"-> ''/bin''"This example shows the use of the #clamp: method to isolate a our dynamic bindings only for the duration of a block.  After the block finishes execution, the original set of bindings is restored.Scoping semantics:A dynamic variables'' scope is defined at runtime by an enclosing activation context.  To locate the active lexicon of dynamic variables, the system follows the activation stack until a context is encountered that defines the active DynamicBindings (this lookup is implemented using the exception handling system).  Any changes to the active DynamicBindings are visible in all activation contexts where that set of DynamicBindings are being used (which may include contexts in more than one activation stack).A bit about how it''s implemented:The bindings for a given method activation context are located using the exception handling mechanism (see BindingsLocator).  If a given stack does not have a handler that answers a set of bindings, then dummy contexts will be added to the top of the stack that will answer the global root set of bindings.Unlike other implementations, DynamicBindings do not use the activation stack to define the hierarchy of bindings.  Instances of DynamicBindings have their own parent instance variable and will locate enclosing variable scopes by following the chain of parents (*not* by looking for enclosing handlers of BindingsLocator).  Using this design, we are able to accomodate a broader range of usage scenarios.If you need to isolate the bindings of a given context stack such that future changes in the bindings are not visible to users of the current set of dynamic bindings (ie. if you use continuations), you can send the message #isolate to the BindingsAccessor (ie. use "Bindings isolate").===== Release History =====Version 1.1:	- Packaged using KomPackaging (Squeak version only)	- Made Object>>binding: answer its argument	- Cleaned up a few obsolete methods from the old RuntimeEnvironments implementationVersion 1.0:	- Initial release'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/DynamicBindings-1.1univ.sar'.	self provides: #().	self dependsOn: #('KomPackaging').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ECoDEDesignEnvironment	self name: 'ECoDE Design Environment'.	self version: '3.0.5'.	info category: 'Uncategorized'.	info description: 'Ectropic Design supports object-oriented analysis (OOA), object-oriented design (OOD), and object-oriented programming (OOP) in Squeak.  Our goal is to bring more order to projects suffering from entropy - the tendancy for code and design to become more disordered as it matures.  We believe that design critics, collaboration, code generation, code import, and tightly integrated design and coding concepts allow users to impose more order on a new or existing project.  OOA Tools:  CRC Cards with a diagram layout, Scenarios, and a Goal Tree all connected by common responsibilities.  OOD Tools:  Simplified UML class diagram.  OOP Tools:  Code Generation, and Code Import.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ECoDE-v3-0-5.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!EasySqueak	self name: 'EasySqueak'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'This is a set of services to help you define simple exercice sessions for students learning SqueakBasically for each sessions you define a class, writes the session''s topic in the class comment,and write a code skeleton in the class''s body. You can also write unit tests in this class to be surethat the code demanded to the the students will be properly implemented.Once this is done, students can load a session class, and they will have a  browser limited to thisclass, a little shell (a modified version of the commandshell, allowing to eavaluate expression on a target object but using a shell), and a window telling the session''s summary.This could form the basis to a tool allowing people to easily learn Smalltalk''s syntax, like the LessonRunner provided with VisualWorks (which I find the fastest way to learn our syntax).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/EasySqueak-rr.6.mcz'.	self provides: #().	self dependsOn: #('CommandShell' 'OmniBrowser' 'Services-Base').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!EditPrettyPrintTextColors	self name: 'Edit Pretty Print Text Colors'.	self version: '20040425'.	info category: 'Uncategorized'.	info description: 'Provides a new editor allowing the easy modification of pretty print code colors.See <a href="http://squeak.preeminent.org/">http://squeak.preeminent.org/</a> for details and pictures.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ColorPrettyPrintEditor-sbw.mcz'.	self provides: #().	self dependsOn: #('Appearance Menu Registry').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Emacskeybindings	self name: 'Emacs key bindings'.	self version: '1.0.2002'.	info category: 'Uncategorized'.	info description: 'To get going file this changeset in and then evaluate the following:ParagraphEditor emacsBindings.You will then have a number of Emacs text-editting commands at your disposal.To see what''s available check ParagraphEditor''s #emacsControlKeyShortcuts.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/EmacsKeys.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Ephemerons	self name: 'Ephemerons'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'An Ephemeron is an object which refers strongly to its contents as long as theEphemeron''s key is not garbage collected, and weakly from then on. Ephemerons solve a problem which is commonly found when trying to "attach" properties to objects by using a registry. When some property should be attached to an object, the property should (in terms of GC behavior) typically have the life-time that an instance variable of this object would have. However, this is complicated by having an external association between the object and its property such as:registry ------------> association -------------> object			   |			   |			   |			   v			propertyHere, the registry (a third party) will hold onto the association itself which would require manual removal from the registry (instead of automated garbage collection). While this problem can be always be solved in any given concrete situation by using one of the various weak association types, choosing the ''right'' kind of association depends on a variety of factors some of which can change dynamically.Ephemerons solve this problem by defining that the ''contents'' (value) of an Ephemeron will be held strongly until the key is known to be garbage collected. From then on, the contents of the ephemeron will be held weakly. Therefore, the contents of an ephemeron can only become eligible for garbage collection if and only if the key is garbage collectable which is the exact behavior which we would observe for an instance variable of the object.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Ephemerons.cs'.	self provides: #().	self dependsOn: #('VMMaker').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!EsSqeakzMe	self name: 'Es-Sqeakz-Me'.	self version: '7'.	info category: 'Uncategorized'.	info description: 'Includes Laurence Rozier''s changeSet from package "Say Something" along withsome additional changes in this Project.  More fun for everyone!!'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/EsSqueaksMe.001.pr'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!EventInterceptorMorph	self name: 'EventInterceptorMorph'.	self version: '1alpha'.	info category: 'Uncategorized'.	info description: 'Have you ever wanted to trace some code which is part of the Morphic UI process, or code triggered by it?  Had trouble trying to trace it in the debugger because interacting with the UI changes what you''re trying to watch?  EventInterceptorMorph may be able to help!!EventInterceptorMorph is a button which, when pressed, begins listening to the hand''s event stream.  When an even of the appropriate type is encountered, this morph intercepts it and traces the dispatch of the event using MessageSendTree, and opens a SendTreeExplorer on the results.  This is useful for debugging parts of the UI process which are otherwise difficult to trace.The eventType can be any of the Morphic event types, but #mouseUp, #mouseDown, and #keystroke are by far the most useful because they are the triggers for the majority of actual UI activity.A methodSelector may be set which identifies a particular method the user is interested in.  All method sends above this method are ignored.  This is useful when the user wishes to study the execution of a known method which is eventually triggered by a UI gesture, but has no interest in the complete event dispatching send tree leading up to it.  See example in changeset preamble.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/EventInterceptorMorph-JW.1.cs.gz'.	self provides: #().	self dependsOn: #('SendTreeExplorer').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ExternalWebBrowser	self name: 'ExternalWebBrowser'.	self version: '6'.	info category: 'Uncategorized'.	info description: 'This small package should work as an alternative to scamper. It just hands over every url to a platform specific external browser.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ExternalWebBrowser-laza.6.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Exupery	self name: 'Exupery'.	self version: '0.4'.	info category: 'Uncategorized'.	info description: 'Exupery is a byte code compiler written in Squeak. It has been written fully test first with both customer and acceptance tests.The project is a personal master work, it is meant to both be useful in itself and help me improve my personal programming skills.It is going to be a compiler for leaf methods first, providing an alternative to writing plugins as a performance improvement.The programming exersize is complexity control. Compilers are much harder to write than interpreters yet in theory they should be intermediate generation (equivilent to the interpreter) plus a back-end. Both parts are individually well understood.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Exupery-wbk.26.mcz'.	self provides: #().	self dependsOn: #('VMMaker').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Faure	self name: 'Faure'.	self version: '0.3'.	info category: 'Uncategorized'.	info description: 'Faure is a PDA environment for running on iPaq class machines.  It is available either as a file-in, or as a premade image from the homepage.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Faure-Framework.40.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!FillInTheBlankMorphLookEnhancement	self name: 'FillInTheBlankMorph Look Enhancement'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'UI enhancements to FillInTheBlankMorph along the lines of Diego''s other "Look Enhancements" for Squeak ( see http://minnow.cc.gatech.edu/squeak/3142 for a full list ).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/FillInTheBlankEnhancements-dgd.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!FlapsRegistry	self name: 'FlapsRegistry'.	self version: '2003-4-14'.	info category: 'Uncategorized'.	info description: 'a tool can be registered to appear in a flapfor an example:-select the next two lines and do itFlaps registerQuad: #(FileList2 openMorphicViewInWorld	''Enhanced File List''''A nicer File List.'')	forFlapNamed: ''Tools''.Flaps replaceToolsFlap-if you don''''t like the FileList2 in the tools flap, remove it with the nexttwo lines:Flaps unregisterQuadsWithReceiver: FileList2 fromFlapNamed:''Tools''.Flaps replaceToolsFlapNote: after registering or unregistering, the flap need to be manually recreated see Flaps class>>replace*Flap methods'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/dinamicFlaps-asm.8.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Folktale	self name: 'Folktale'.	self version: '0.51'.	info category: 'Uncategorized'.	info description: 'Folktale is a useful command shell for headless Swiki user.You can log in squeak image through telnet client at localhost port 4919.Try$ squeak -headless squeak.image Folktale.st &Useful expressions and pseudo variables.Jump result object unless your query has dot(.) at end.----Basic command is follwedhelp -- This message.exit  -- Exit.self -- Current object.ii -- Inspect self.history -- Show history.back -- Back.q -- The agent (me).q usefulExpressions -- Show more useful expressions.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Folktale-051.st'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!FontSetCream	self name: 'FontSetCream'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'Cream font for Squeak (aka "PaloAlto" font)Nostalgia!! Maybe you have dug out the 1981 BYTE special Smalltalk issue, or seen old screenshots of Smalltalk-76 systems. Now you can have the funky font, too. (This was converted from a very old Mac PD CD-ROM (it was called "PaloAlto" and in 12 point only.)'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/FontSetCream.st'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!FractalMorph	self name: 'FractalMorph'.	self version: '1.2'.	info category: 'Uncategorized'.	info description: 'see webpage http://minnow.cc.gatech.edu/squeak/2911 for descriptions.  Allows you to zoom in and out of a fractal image, possibly make small animations as well.  begin with (FractalMorph newopenInWorld)'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/FractalMorph.2.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Freetype2FontDemo	self name: 'Freetype/2 Font Demo'.	self version: '5'.	info category: 'Uncategorized'.	info description: 'This SAR contains pre-rendered versions of the BitstreamVera family, along with the FT2Font class and the BitBlt and other changes required to display these fonts (with or without the enhanced BitBlt plugin, but since I''m the only one right now with a copy of that plugin that doesn''t matter).It should work in a recent (3.7a) Squeak image; I have only tried it in a 5816 image.Arjen van Elteren wrote the original plugin and font code; I have modified it to understand style changes (bold, italic, etc.) and to render properly in the absence of the enhanced BitBlt modes that were provided by his plugins.There is also a plugin that speeds up drawing (which works under Linux right now), and a plugin that interfaces with the Freetype/2 libraries. I will be putting the code for all of these things on SqueakMap.I find them quite usable. They don''t have the arrows re-mapped; I could do this easily if there is enough demand (the glyphs are (I believe) in the original fonts)). I believe that the demo has characters in the Latin1 mapping, rather than MacRoman (I can fix this easily, but wanted to get a sample out).Currently, the design of the FT2Font is very similar to the design of the StrikeFont: the character glyphs (corresponding to characters whose values are between 0 and 255) are stored in a single Form.So to use these for extended character sets would require a bit of tinkering. However, the FT2 library interface is quite capable of working together with something like TTCFont and producing better antialiased results.The font interface in Squeak should be unified; there is quite a bit of overlap.The BitBlt changes could also benefit TTCFonts which are rendered in a single color. Right now we''re caching 32-bit forms rendered in a single color. Using this 8-bit deep encoding would mean that we could save at least 75% of the memory, and more whenever we''re rendering the same glyphs in different colors.I will be moving Arjen''s BitBlt changes out of mode 34 and into a new mode (38?) soon.For reference, I''m using the auto-hinting in Freetype/2 (that is, my version is compiled without the patent-encumbered interpreter).My current work on this package is in my Monticello repository at:http://bikenomad.microship.com/squeak/monticello/Misc/'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/FT2DemoInstall5-nk.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!FullImage	self name: 'Full Image'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'This package depends on all the packages you need to get a "full" image with several extra goodies.   Load this if you really want to play around with all that Squeak has to offer, and don''t mind having a large image.See this page for more info:http://minnow.cc.gatech.edu/squeak/3412'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Full%203.7%20Squeak.cs'.	self provides: #().	self dependsOn: #('Balloon3D' 'Celeste' 'FullImageProjectAlice' 'FullImageProjectSmalltalkIntroduction' 'Games' 'IRCe' 'Monticello' 'Scamper' 'VMMaker' 'YAXO').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!FullImageProjectAlice	self name: 'FullImageProjectAlice'.	self version: '2'.	info category: 'Uncategorized'.	info description: 'A project demonstrating the "Alice" system for end-user scripting of 3D worlds.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Squeak%20in%203D.008.pr'.	self provides: #().	self dependsOn: #('Balloon3D').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!FullImageProjectSmalltalkIntroduction	self name: 'FullImageProjectSmalltalkIntroduction'.	self version: '2'.	info category: 'Uncategorized'.	info description: 'A project introducing the Smalltalk programming language that Squeak is based on.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SmalltalkIntroduction.002.pr'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!GLORPport	self name: 'GLORP port'.	self version: '0.2.34'.	info category: 'Uncategorized'.	info description: 'NOTE: After loading Glorp, the following test cases will fail,for the following reasons:GlorpDatabaseLoginTest>>testUnsuccessfulLogin       This test is supposed to fail.  If it succeeds, there is a problemGlorpDatabasePlatformTest>>testReadTimestampGlorpDatabasePlatformTest>>testReadTimestampNoTZGlorpDatabasePlatformTest>>testReadTimestampOverflowDays       Squeak TimeStamp instances don''t support milliseconds,       and these three tests test for millisecond values.GlorpDatabaseTypeDBTest>>testNumericGlorpDatabaseTypeDBRoundTripTest>>testNumeric       Tests write a ScaledDecimal, but PostgreSQL treats it like a double float. When it is read back in, it doesn''t compare, so the test fails.I am in the process of writing GLORP documentation.  The current draft can be found here (NOTE: this documentation was written LONG ago, and haven''t been updated for quite some time!!!!):http://www.smalltalkpro.com/downloads/3.Tools/GlorpUserGuide.pdf.gz'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/GLORP.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!GOODS	self name: 'GOODS'.	self version: '71'.	info category: 'Uncategorized'.	info description: 'GOODS is a distributed, language-neutral object database from Konstantin Knizhnik. It''s available from http://www.garret.ru/~knizhnik/goods.html .This client provides transparent storage of Smalltalk objects, or, given some extra type information, compatibility with the GOODS Java interface storage conventions, for easy sharing of object data between Squeak and Java.See http://minnow.cc.gatech.edu/squeak/3492 for more information.*Requires GOODS 2.72 or later*'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/GOODS-avi.71.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Games	self name: 'Games'.	self version: '22-4-2004'.	info category: 'Uncategorized'.	info description: 'Chess, FreeCell, SameGame, ChineseCheckers, Tetris and moreWarning: use this if you deleted games using something like GamesRemoval, you must have Led*s classes in your image before filing in this.Depends on:   - SarInstaller (present in 3.6a)If you want to load this on a image younger than 3.6 you must: - load GamesRemoval - load MCP changes - load KCP changes - load SarInstaller - load DeclarativePools - finally, you can file in Games'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Morphic-Games.5.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!GamesTests	self name: 'GamesTests'.	self version: '2003-5-2'.	info category: 'Uncategorized'.	info description: ''.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/gamesTests-asm.cs'.	self provides: #().	self dependsOn: #('Games').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!GradientWindowLook	self name: 'Gradient Window Look'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'An attempt for a (hopefully better) look for the Squeak environment. Tries to deal with Windows, ScrollBars and some buttons using gradients formost graphical elements.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/GradientWindowLook.2.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Graph	self name: 'Graph'.	self version: '5'.	info category: 'Uncategorized'.	info description: ''.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Collections-Graphs-mic.5.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!HTMLParser	self name: 'HTML-Parser'.	self version: '1.5'.	info category: 'Uncategorized'.	info description: 'Parses an HTML document into an XML DOM, using YAXO''s XMLElement.  This parser is HTML 4.01 compliant - it will accurately infer the structure of correct HTML, but it is not tolerant of broken markup.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/HTML-Parser.st'.	self provides: #().	self dependsOn: #('YAXO').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!HTMLTableMorph	self name: 'HTMLTableMorph'.	self version: '0'.	info category: 'Uncategorized'.	info description: 'A experimental package for Scamper to build a TableMorph of a HTML table. Lot''s of websites use tables as their layout format and giving Scamper this would be cool.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/HTMLTableMorph.cs.gz'.	self provides: #().	self dependsOn: #('Network-HTML').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!HTTPClient	self name: 'HTTPClient'.	self version: '19'.	info category: 'Uncategorized'.	info description: 'A Squeak port of Steve Waring''s HTTP client.  (The original, Dolphin package is available at http://www.dolphinharbor.org/dh/projects/httpclient/index.html.)  The Squeak port is usable, but still needs a lot of cleanup work.The Squeak port must be installed using an up-to-date version of MCInstaller; the easiest way to get that is to update to SM2.See the class side of SptHTTPRequest for example usage.Features:    * HTTP 1.1 persistent connections.    * Ability to process requests in a background process and set timeouts.    * Cookie parsing/sending.    * Partial range requests.    * Automatic following of redirections.    * Streaming of responses to writeStreams/fileStreams.    * Basic Authentication.    * Support for Proxies.    * Flexible progress notifications.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SWHTTPClient-bkv.19.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!HaltOnce	self name: 'HaltOnce'.	self version: '20040612'.	info category: 'Uncategorized'.	info description: 'The most common method of "breakpointing" is to modify the code you are working on and include a  self halt in the right place. Sometimes, however, you find you have a looping operation or  some kind of recursive operation and you only want to stop one time. This enhancement provides methods on the class Object enabling these new techniques.See <a href="http://squeak.preeminent.org">http://squeak.preeminent.org</a> for details on use.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/HaltOnce-sbw.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Hobble	self name: 'Hobble'.	self version: '0.6'.	info category: 'Uncategorized'.	info description: 'Hobble is a simple simulation of TCP/IP data transfer across a network circuit.See the ReadMe window in the project for more information.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Hobble.006.pr'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!HttpView2	self name: 'HttpView2'.	self version: '0.94'.	info category: 'Uncategorized'.	info description: 'This is the new HttpView called HttpView2 that is:- Better (refactored, more comments, bug fixes etc)- Adapted to the new *KomHttpServer* that *Stephen Pair* maintains.- Works in Squeak 3.6.- Simpler (submits are now buttons, no more HVModule needed etc)- From version 0.94 it now depends on a lower *HTMLBuilder* layer.It also includes much better samples and comments and an upcoming article inboth Swedish and English is intended to work as a tutorial.HttpView is a lightweight web framework based on KomHttpServer. It differs a bit from "classic" such frameworks:-Url resolution:: The url "path" strictly corresponds to a chain of HttpView instances connected together with a parent pointer. The "document" name at the end of the url is matched with a message selector in the HttpView instance.-Page construction: Pages and HTML components are built by "feeding" a builder object - an instance of HVHtmlBuilder - messages from a rather large protocol. The builder has plenty of "smart" messages that makes building pages and Forms a breeze. And it''s all in Smalltalk.-Forms handling: The Forms are constructed from instances of classes like HVHtmlForm, HVHtmlInputCheckbox, HVHtmlSelect etc. This means that Forms are built much like you build UIs in Morphic or Java''s Swing. When a Form is submitted the values of the fields are easily accessible by sending the message "value" to it'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/HV-gk.31.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!IRCBot	self name: 'IRCBot'.	self version: '2.1'.	info category: 'Uncategorized'.	info description: 'see homepage for instructions on how to use and set up the bot.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Network-IRC%20Bot.st'.	self provides: #().	self dependsOn: #('IRCe').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!IRCe	self name: 'IRCe'.	self version: '10.1'.	info category: 'Uncategorized'.	info description: 'A client for Internet Relay Chat (IRC).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Network-IRC-fc.10.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!IRCeTests	self name: 'IRCe-Tests'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'IRCe test suite'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Network-IRCTests-sbw.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ImageBrowser	self name: 'Image Browser'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'Select an image file in the FileList and choose ''browse squeak image''.Typical usage is to add classes from the class pane menu, then choose ''remove unmodified categories'' to delete the identical methods with in the image.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ImageBrowser3.6.1.cs.gz'.	self provides: #().	self dependsOn: #('VMMaker').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Iterator	self name: 'Iterator'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'Ported from the Iterator goodie by Mario Wolczko.Occasionally you may have a block that when evaluated can betreated as a collection -- ie it takes another block as parameter,then applies that to a sequence of values.This goodie wraps the block into an object -- an iterator -- which ispart of the collection hierarchy, and therefore inherits a variety ofuseful collection-related methods.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Iterator.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!IvapParser	self name: 'IvapParser'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'Instructions for using the "IVAP" Parserby Stephen Pair"IVAP" is an acronym for "Instance Variable Acess Protecting"; thus what we have is an instance variable acess protecting parser. The IVAP Parser enables you to selectively compile message sends where instance variable accessing bytecodes would normally appear. This effectively enables you to trap all reads and writes to instance variables without needing to write special code in your class to do so. Additionally, the "inst var refs..." and "inst var defs..." functionality of the system is modified to be aware of such specially compiled methods.You can choose to enable this special compiling behavior on a class by class basis. Additionally, you can control which methods within a class use the special compiling behavior. To enable a class to trap inst var access, you first need to override #useInstVarAccessorMethods in your class (on the class side) to answer true. Then, you can override one or both of #selectorForInstVarAccess or #selectorForInstVarMutation to answer the specific messages that you want to have sent when an attempt is made to access an instance variable. See those methods for details on the signature of those methods. You do not need to override both methods; thus you can choose to trap only reads or only writes.That is it!! Any methods that you compile in your class will now trap inst var reads and/or writes (it is up to you to actually implement the messages that are sent to access instance variables).You may also be more selective in which methods will actually trap reads and/or writes by overriding #normallyCompiledMethods and/or #useInstVarAccessorMethodsFor:.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/IvapParser.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!JavaSerialization	self name: 'Java Serialization'.	self version: '90-alpha'.	info category: 'Uncategorized'.	info description: 'Gives Squeak the ability to read in and write out Java serialized objects. It also includes a Java Class Loader. Great for debugging serialization problems in Java. Right now, I can load in any serialized stream, but those written with customized methods are just simple byte arrays. Future versions will use the class loader to make sense of this information. If you get any use out of it or have suggestions, let me know. I want it to become a way to interface to Java easily and the Smalltalk way. I want to do Java better than Java.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Java-btb.90.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!KGraph	self name: 'KGraph'.	self version: '0.0'.	info category: 'Uncategorized'.	info description: 'General purpose graph package.  Or it will be if it gets finished ;-)'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/KGraph-Propertied-jcg.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!KarelsWorld	self name: 'Karel''s World'.	self version: '10'.	info category: 'Uncategorized'.	info description: 'This is a version of the Karel the Robot educational simulation done with eToys.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Karel%27s%20World.010.pr'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'damiencassou 2/4/2009 16:57'!KomHttpServer	self name: 'KomHttpServer'.	self version: '6.2'.	info category: 'Uncategorized'.	info description: 'KomHttpServer is the Comanche web server package.  To get a simple web server running, install this package and evaluate the code below.  A simple file serving web server will be started and will serve the files in your default directory.	| ma |	ma := ModuleAssembly core.	ma serverRoot: FileDirectory default fullName.	ma documentRoot: FileDirectory default fullName.	ma directoryIndex: ''index.html index.htm''.	ma serveFiles.	(HttpService startOn: 8080 named: ''httpd'') plug: ma rootModuleAfter starting the server, point your web browser to http://localhost:8080/If you have loaded Seaside, you can start a web server that serves Seaside based applications using the following configuration:	| ma seaside |	seaside := WAKom default.	ma := ModuleAssembly core.	ma serverRoot: FileDirectory default fullName.	ma alias: ''/seaside'' to: [ma addPlug: [:request | seaside process: request]].	ma documentRoot: FileDirectory default fullName.	ma directoryIndex: ''index.html index.htm''.	ma serveFiles.	(HttpService startOn: 8080 named: ''httpd'') plug: ma rootModuleSee the class comments of the various subclasses of ComancheModule for documentation and usage examples.===== Release History =====Version 6.2:	- Added support for Squeak 3.6	- Now uses SocketStream from the network rewriteVersion 6.1:	- (build #41) Fixes various issues for running on Mac OSX	- Packaged using KomPackaging (Squeak version only)	- Separated the services framework into a separate package called KomServices	- Added a module framework	- The following modules have been added (see the individual classes for details):		- ModCore - this is the core module and designed to be the root of a module assembly, it extracts basic information from the request and makes it available to sub-modules, it also handles http TRACE and OPTIONS methods		- ModMulti - this is a module designed only to wrap submodules into a single entity		- ModAlias - for mapping url prefixes to sub modules		- ModAuth - for authentication			- KomAuthDb - a very basic user and password database		- ModAutoIndex - for generating directory listings		- ModDir - for directory processing (including redirects to fix the trailing slash problem)		- ModDoc - for file location processing in a file server		- ModVhost - for name based virtual hosting			- ModVhostDoc - for document serving based on virtual host name			- ModVhostAlias - for module routing based on the virtual host name		- ModFile - for serving files		- ModLog - for logging http requests (not yet usable)			- KomLogger - writes out a log in CLF format			- KomTracer - writes out a detailed trace of http request/response pairs		- ModNotFound - if reached will generate a not found response		- ModSession - for client session handling			- KomSession - the session class used by ModSession (by default)	- Added ModuleAssembly to help in creating module assemblies	- Renamed classes:		- ComancheHttpService -> HttpService	- Removed classes		- BoundedStream		- HttpBadRequest		- HttpParser		- NetworkProtocolAdaptor		- NetworkRequestVersion 6.0.1:	- Adds pluggability to ComancheHttpService (see class comments).Version 6.0:	- Initial ComancheNG release===== Future Enhancement Plans =====- add WebDAV server capability (in a separate package)- synchronize with the network rewrite project- separate some of the http protocol support into a separate package and provide an Http/WebDAV client implementation (separate package)- rework the handling of chunked responses (using the SharedStreams package)- rework the handling of document uploads (via multipart/form-data) using the SharedStreams package- support chunked transfer encoding for incoming requests- Reify cookies and make them easier to work with- Slim down HttpRequest and HttpResponse such that they are only responsible for constructing requests and responses (currently, these classes are heavily overloaded)'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/KomHttpServer-6.2univ.sar'.	self provides: #().	self dependsOn: #('KomServices').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'damiencassou 2/4/2009 16:57'!KomPackaging	self name: 'KomPackaging'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'This package adds support for two types of urls, package and squeakmap...they take the forms:	sqpkg://httpserver.kom:6.1	sqmap://Named Process:1.1You can to interesting things with these URLs, such as install them:	''sqpkg://httpserver.kom:6.1'' asUrl installor, query whether or not a version of the package is currently installed:	''sqpkg://httpserver.kom:6.1'' asUrl isPresentVersion 1.0:	- initial version'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/KomPackaging-1.0univ.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'damiencassou 2/4/2009 16:57'!KomServices	self name: 'KomServices'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: '===== Release Notes =====KomServices provides a framework for the creation and management of background processes.  A generic Service class is provided for this purpose.  Additionally, TcpService is provided for creating services that respond to inbound TCP connections.===== Release History =====Version 1.0:	- initial version, this package is bourne out of KomHttpServer and renames a few classes:		- ComancheService -> Service		- ComancheNetService -> TcpService	- the old ConnectionHandler is dropped in favor of a cleaner TcpListener.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/KomServices-1.0univ.sar'.	self provides: #().	self dependsOn: #('DynamicBindings' 'KomPackaging').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!LanguageEditor	self name: 'LanguageEditor'.	self version: '2.0'.	info category: 'Uncategorized'.	info description: 'Editor for Babel''s languages.Open it from	World Menu >> open... >> Language Editor         (to open on default language)	World Menu >> open... >> Language Editor for...  (to choose the language)Or evaluate:	LanguageEditor openOnDefault.	LanguageEditor open.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Babel-Editor-dgd.1.mcz'.	self provides: #().	self dependsOn: #('Balloon3D').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!LifeMorph	self name: 'LifeMorph'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'A simple implementation of Life Game.  It is based on Dan''s original Life Game for Smalltalk-80.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/LifeMorph.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Lisp	self name: 'Lisp'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'GUI works only in MVC. How to start 1) evaluate: LispInterpreter open or LispInterpreter fullOpen'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Lisp-md.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!LogEngine	self name: 'LogEngine'.	self version: '2'.	info category: 'Uncategorized'.	info description: 'A powerful and small LogEngine for Squeak!!A Sample usage islc := LogClient getInstance: ''Client''.lc debug:''test1''.lc info:''test2''.When you create a LogClient, you must use the getInstance: method, passing a "Category Name"used to create a special category log file.LogClient features:+ Integrated con Preferences (debug panel)+ Can output on file and on Transcript on demand+ Can print the method where the line is called+ Can disable the debug level (only this for the meantime, sorry).+ Easy to extend'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/LogEngine2.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Logicexpressions	self name: 'Logic expressions'.	self version: '1.0-alpha'.	info category: 'Uncategorized'.	info description: 'This was done as part of my master thesis project (directed by Dan Rozenfarb). I am using it myself and hope it can be useful to someone else.Try inspecting: LExpression fromString: ''{p=>q = not p or q}''See more examples in the Homepage and on the Logic-Tests category.I hope you enjoy it!!Dany'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Logic.sar'.	self provides: #().	self dependsOn: #('SmaCC').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!MAPIClient	self name: 'MAPIClient'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'This is a simple package allowing you to send already composed MailMessagesthrough your registered default email client on Windows (such as Outlook orEudora). To invoke it, merely ask it to      MAPIClient sendMailMessage: aMailMessage.and it will take you from there. On Squeak versions which have the AppRegistryinstalled (which is included in 3.6 and later versions) MAPIClient willregister itself as a MailSender which means you can use it to do any kind ofmailing through your default email client (including bug-reports, the bug fixarchive viewer etc.)'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/MAPIClient.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Manzana	self name: 'Manzana'.	self version: ''.	info category: 'Uncategorized'.	info description: 'Really simple physics simulations with Morphs.Every Morph with mass contained in ManzanaUniversePasteUpMorph or in ManzanaPlanetPasteUpMorph with mass will be part in a simple simulation.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Manzana-2003-01-21.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!MemoryUsage	self name: 'MemoryUsage'.	self version: ''.	info category: 'Uncategorized'.	info description: 'A ProgressMorph subclass to display the current VM memory in use.  I wrotethis because the vm statistics menu item in the help menu is static; itdoesn''t periodically update.Plus, it''s cool!!"MemoryUsage new openInWorld."'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/MemoryUsage.st.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!MethodAnnotations	self name: 'Method Annotations'.	self version: '0.1b'.	info category: 'Uncategorized'.	info description: 'Optional annotation for methods. All <mumble> expressions are now treated as property of the compiled method. In other words, a method may look like:Object>>mumble	<categories: #(basic eToy)>	<index: 42>	<value: 123.45>	<returnType: Array>After the method is compiled we may query it for those properties as in:	(Object compiledMethodAt: #mumble)		valueOfProperty: #categories; 	=> #(basic eToy)		valueOfProperty: #index;		=> 42		valueOfProperty: #value;		=> 123.45		valueOfProperty: #returnType.	=> Array'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/MethodAnnotations-ar-tweaked.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!MethodRecompiler	self name: 'MethodRecompiler'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'This packages enables the recompilation of methods after changes in classeswithout the need to access any source code. This improves speed and in some situations even makes it possible to recompile some classes at all (for example, when using alternative compilers without first-hand source code representation).To use MethodRecompiler for about everything interesting change Behavior>>compileAllFrom: oldClass  ^MRMethodRecompiler recompileFrom: oldClass to: self'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/MethodRecompiler.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!MiniToDo	self name: 'MiniToDo'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'Very simple task administration system.Developed mainly as a learning-project. A lot of features must be added.Sorry by the "spanglish" mix :)Need a PluggableListMorph.To start the app, evaluate:SistemaTareas new initialize openAViewOnMe'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/MiniToDo-gsa.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!MinneStore	self name: 'MinneStore'.	self version: '2.8'.	info category: 'Uncategorized'.	info description: 'Object Database Management System forVisual Smalltalk 3.1, Dolphin Smalltalk, VisualAge Smalltalk, VisualWorks Smalltalk and Squeak.Its licensed under the MIT LicenseDownload the 2.7, 2.8 and 2.9 version port from the Stephen Pope''s site ftp://ftp.create.ucsb.edu/pub/stp/OODB/'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SMS.2.08.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Monticello	self name: 'Monticello'.	self version: '183'.	info category: 'Uncategorized'.	info description: 'Monticello is a distributed concurrent versioning system based on a declarative representation of Squeak source code.  It allows packages to be safely saved, loaded and updated, and provides tools for branching and merging package versions.  It does not depend on (and does not provide) any form of central repository.Requires PackageInfo (already included in Squeak 3.6 5250).Requires MCInstaller for installation.See also MonticelloCVS, which supports managing Monticello packages with CVS rather than with the native versioning tools.  This is probably mostly of interest to "legacy" Monticello and DVS users.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Monticello-avi.183.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!MonticelloCVS	self name: 'MonticelloCVS'.	self version: '123'.	info category: 'Uncategorized'.	info description: 'Allows Monticello packages to be filed in and out in the old .mc format for compatibility with CVS.  Provides the MCFilePackagePanel UI familiar to users of DVS.  Also supports resolving CVS conflict markers using the Monticello Merge Browser.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/MonticelloCVS-jf.11.mcz'.	self provides: #().	self dependsOn: #('Monticello').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!MorphicFontEditor	self name: 'MorphicFontEditor'.	self version: '1.3'.	info category: 'Uncategorized'.	info description: 'A Morphic application to create and to edit StrikeFonts.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/MorphicFontEditor.1.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!MorphicWrappers	self name: 'MorphicWrappers'.	self version: '3.6-5325-c'.	info category: 'Uncategorized'.	info description: 'With MorphicWrappers you can put any object in a MorphicWorld.Simply click on the world (or any other target for your sentence, thenpress <tab> an write a Smalltalk expression, once you press enter the resulting object will be included in your world.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/MW-3.6-5325-c.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!MorseCode	self name: 'Morse Code'.	self version: '2'.	info category: 'Uncategorized'.	info description: 'Send messages in morse code. Set the character speed and pitch, thenstart sending messages. Uses QueueSound class.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/MorseCode.02.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!MultiColumnListMorph	self name: 'MultiColumn List Morph'.	self version: '6'.	info category: 'Uncategorized'.	info description: 'MultiColumnListMorph (and its related StackedStringMorph) are competitors for PluggableMultiColumnListMorph.  The speed is substantially faster than the the standard Pluggable... hieararchy, and there are some additional features (most notably the ability to add a header for the list).  Currently, this morph only takes arrays of arrays of strings as arguments.Please look at the class side of MultiColumnListMorph for examples.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/MultiColumn%20Lists-cbc.6.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!MultilevelUndoforTextMorph	self name: 'Multi-level Undo for TextMorph'.	self version: '3.7.1'.	info category: 'Uncategorized'.	info description: '=== RELEASE INFO PLEASE READ ===IMPORTANT: Do not try to use the 3.6 release in the 3.7 image, or vice-versa. FOR 3.6, the latest version is release 1-3.6.1, also at:  http://www.swerlingphoto.com/squeak/multiundo/MultiUndo-v2-sps.1.cs.gzFOR 3.7, the lastest version is release 1-3.7.1, also at:  http://www.swerlingphoto.com/squeak/multiundo/MultiUndo-v2-sps.1.cs.gz=== DESCRIPTION ===Adds a preference, #multipleUndo, that adds multilevel undo/redo capability to TextMorph.  A method is added that remaps cmd-r to redo. Most of the code is in TextMorphEditor or support classes, and I believe it could be ported to MVC without too much trouble, mostly by moving the methods in TextMorphEditor up to ParagraphEditor. But I don''t know my way around MVC, so someone else would have to do that. '.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/MultiUndo-v2-sps.1.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!NetMorph	self name: 'NetMorph'.	self version: '0.2'.	info category: 'Uncategorized'.	info description: 'NetMorph is a distributed environment for everyone.It extends the current Squeak Morphic system to a network-enabled one.In NetMorph, Morph is no longer ''a bird in a cage''.It can go out from the local desktop and freely crawls ''across the universe'' (many desktops).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/NetMorph.25.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!NetMorphMapServer	self name: 'NetMorph MapServer'.	self version: '0.2'.	info category: 'Uncategorized'.	info description: 'MapServer serves WorldMap data to NetMorph clients.You may not need this, because the default server is running at:http://swikis.ddo.jp:8823/NetMorphAdminServerTo run the server, just pick the NetMorph Server setting morph.-map server port -> port number of the server (default is 80)	The check box indicates the server is running.-map path -> local location of the WorldMap csv files'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/NMServer.14.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!NetStrings	self name: 'NetStrings'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'This is an implementation of the Netstring protocol as defined here: http://cr.yp.to/proto/netstrings.txt (by D. J. Bernstein, djbpobox.com). It adds the ability to read and write Netstrings onto any byte or character stream. Integer, ByteArray, and String can be converted to or from a Netstring. See the methods added to those classes (instance and class methods). Netstrings are handy for creating network protocols.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/NetStrings.st'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!NetworkHTML	self name: 'Network-HTML'.	self version: '4'.	info category: 'Uncategorized'.	info description: 'An HTML parser and formatter.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Network-HTML-md.4.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!NsGame	self name: 'Ns Game'.	self version: '29'.	info category: 'Uncategorized'.	info description: 'This is the game I demoed at OOPSLA 2003.NsGame began as a Squeak port of the Shockwave Flash game by Pavils Jurjans.See <a href="http://www.jurjans.lv/stuff/net/freenet.htm">http://www.jurjans.lv/stuff/net/freenet.htm</a>.To begin the game perform:	NsGame new openInWorldInstructions are available from within the game.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/NsTileGame-sbw.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ODBC	self name: 'ODBC'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'Very simple framework for ODBC support in Squeak. Use FFI to talk to ODBC32.dll, no other DLL is necessary.It works in Windows and in Unix.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ODBC-dgd.10.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ODBCEnh	self name: 'ODBCEnh'.	self version: '12'.	info category: 'Uncategorized'.	info description: 'Enhancements to the ODBC package from Diego Gomez Deck. The enhancements are as follows:* DSN-less connection string support* Simpler access to result sets with a single message named "run" that takes an SQL statement and returns a Collection of rows. See ODBCConnection>>run:* ODBCResultTable - used to open the results as a grid-like morph* Permits camelCase way of referring to column names if your database is using conventional YELLING_OUT_LOUD_STYLE, old_c_style, or PascalNamingStyle of column namesTo view the ODBCResultTable as a morph you should have Bitstream Vera Fonts installed which contains a nice monospaced font used to simulate a table.Of course, requires ODBC for Squeak package.  More detailed info can be found on http://squeak.saltypickle.com and by going to the ODBCEnh project wiki page.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ODBCEnh-jrp.12.mcz'.	self provides: #().	self dependsOn: #('ODBC').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!OSProcess	self name: 'OSProcess'.	self version: '3.2.2'.	info category: 'Uncategorized'.	info description: 'OSProcess provides access to operating system functions, including pipes andchild process creation. It is implemented using pluggable primitives in sharedlibrary (.so file) for Unix or Linux, and a DLL for Windows. The Smalltalk code,including the classes which implement pluggable primitives for Unix or Win32operating system functions, may be loaded into any Squeak image, but theprimitives are only useful on Unix and Windows systems. Placeholder classesare provided for MacOS, OS/2 and RiscOS, but are not yet implemented.If you use OSProcess, you will probably also want CommandShell.VM builders will also want to load OSProcesPlugin and XDisplayControlPlugin.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/OSProcessV3-2-2-noChat.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!OSProcessPlugin	self name: 'OSProcessPlugin'.	self version: '3.3'.	info category: 'Uncategorized'.	info description: 'OSProcessPlugin (OSPP) provides access to Unix/Linux and Windows operating systemfunctions. OSPP is used by OSProcess for low level system access. Stub classesare provided for other operating systems (porting assistance welcome).OSProcessPlugin contains the complete source code for the Unix and WindowsOSProcessPlugin (OSPP). Generate the plugin with VMMaker. No external support codeis required.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/OSProcessPluginV3-3.sar'.	self provides: #().	self dependsOn: #('VMMaker').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!OggVorbis	self name: 'OggVorbis'.	self version: '0.2-pre-alpha'.	info category: 'Uncategorized'.	info description: 'A pure smalltalk port of the Ogg-Vorbis decoder. It works (just) but is EXTREMELY ugly code. Refactoring is neccesary.It runs VERY slowly and it is not really usable at the moment. There will be cases that it cannot decode and errors are likely (and fatal).Please note the later release uses some primitives to double the speed.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Ogg-rop.9.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!OmniBrowser	self name: 'OmniBrowser'.	self version: '1.0a3'.	info category: 'Uncategorized'.	info description: 'OmniBrowser is a ground up rewrite of the classical system browsers providedin Smalltalk. It''s designed to flexible and extensible, so as to encourageexperimentation with new types of development tools, language extensions,and runtime environments.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/OmniBrowser-cwp.198.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!OpenOfficeImporter	self name: 'OpenOffice Importer'.	self version: '16'.	info category: 'Uncategorized'.	info description: 'Squeak is the new media. To be the new media Squeak has to give us the option to convert a lot already created documents.OpenOffice is an open source project and its format is well specified and it''s based on XML and Zip (see http://xml.openoffice.org). OpenOffice also has a lot of good job to handle propietary formats so, importing OO format, we''ll able to import really a lot of content.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/OpenOffice-Importer-dgd_16.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!PWSInstallation	self name: 'PWS Installation'.	self version: '0.2gt1'.	info category: 'Uncategorized'.	info description: 'The Pluggable WebServer (PWS) is a web server and toolkit for flexibly creating CGI scripts. Mark Guzdial designed and implemented it to help him create different kinds of collaborative tools: e.g. Virtual Other-Than-Communities. PWS builds on the work of Georg Gollmann and Tim Jones.PWS is mostly obsolete now, and is superseded by the newer Comanche web server.This version of PWS has been slightly modified:	1. It replaces all uses of getData by receiveData in order to pevent a crash.	2. The default setting of serverDirectory is the current directory.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/PWS-0.2gt1.st.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!PackageInfo	self name: 'PackageInfo'.	self version: '17'.	info category: 'Uncategorized'.	info description: 'Provides a mechanism for categorizing Squeak code by means of a simple naming convention.  Used mainly by versioning systems and analysis tools.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/PackageInfo-Base-avi.17.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!PackageInfoExtras	self name: 'PackageInfo-Extras'.	self version: '8'.	info category: 'Uncategorized'.	info description: 'Includes:- Exporters for VW3 and VW5- some UI for browsing package dependencies (#browseExternalReferences)- Ned''s PackagesVsChangeSet code, which provides changeset conversion and filtering facilities'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/PackageInfo-Extras-nk.8.mcz'.	self provides: #().	self dependsOn: #('PackageInfo').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!PieChartMorph	self name: 'PieChartMorph'.	self version: '0.2'.	info category: 'Uncategorized'.	info description: ''.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/PieChartMorph-gm.5.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!PipesGames	self name: 'Pipes Games'.	self version: '20040426'.	info category: 'Uncategorized'.	info description: 'Squeak Pipes Game is a little experiment I did to draw some graphics with Morphic and then use them in a game. It''s using a lot of the framework/ideas from the Electricity Game with some new animation.See <a href="http://squeak.preeminent.org">http://squeak.preeminent.org</a> for more details and a picture of the game.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SqueakPipe-sbw.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!PlotMorph	self name: 'Plot Morph'.	self version: '3'.	info category: 'Uncategorized'.	info description: 'Morph to draw XY plots. See the methods testXXX in the class side.Try with:    PlotMorph test.    PlotMorph test2.    PlotMorph test4.    PlotMorph testWithReferences.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/PlotMorph3-dgd.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!PointerExplorer	self name: 'PointerExplorer'.	self version: '3'.	info category: 'Uncategorized'.	info description: 'A very simple subclass of the ObjectExplorer which works backwards: starting at a child it allows you to inspect the tree of its parents.  This is much more convenient than the ''objects pointing to this value'' menu item in the Inspector.eg:PointerExplorer new openExplorerFor: #to:do:(You can now also use ''explore pointers'' in the Inspector context menu).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Tools-PointerExplorer-avi.3.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Poses	self name: 'Poses'.	self version: '0.11'.	info category: 'Uncategorized'.	info description: 'The idea is to make it easier to work directly with individual objects on the screen. So instead of calling up a Class Hierarchy Browser, you might say, "Bring me the family tree of this class, arranged on the screen to look like a tree," and the objects will just sorta slide into place. You''ll also be able to create "ad hoc" poses - "Remember the arrangement of morphs on the screen now."The result, I hope, will be an environment that makes you feel like you''re really getting your hands directly on the objects, rather than using "tools" to manipulate them like we do today.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Poses.st'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!PostgreSQLClient	self name: 'PostgreSQL Client'.	self version: '0.9.2'.	info category: 'Uncategorized'.	info description: 'Implements a native Smalltalk connection to PostgreSQL backend. See the "Frontend/Backend Protocol" chapter in the "PostgreSQL Programmer''s Guide" for more information.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/PostgreSQL-Client.20040126.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!PrimCallController	self name: 'PrimCallController'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'A PrimCallController (PCC) serves for switching external prim calls (primitiveExternalCall) on and off: this is helpful for e.g. testing of plugins.Dis/en-abling prims by a PCC works for *both* internal and external modules!!This package contains two concrete PCCs using totally different mechanisms for dis/en-abling prims, each has its value.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/PrimCallController.23.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ProgrammingMorphs	self name: 'ProgrammingMorphs'.	self version: '1.0.4'.	info category: 'Uncategorized'.	info description: 'This Squeak book gives you an interactive introduction to programming your own morphs: each time you read about a feature, you first get to try it out live, and then you are given a small programming exercise to really practice with it.If you find yourself wanting to write a new kind of morph, but you don''t know how to get started, then this is a good place to go.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ProgrammingMorphs.4.pr'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Prolog	self name: 'Prolog'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'http://bolot.net/squeak/prolog/v-prolog.pdf '.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Prolog.15Dec1836.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!PropertyList	self name: 'PropertyList'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'Provides PropertyListStream which works much like DataStream or ReferenceStream, eg,dict := (PropertyListStream on: (FileStream fileNamed: ''foo.plist'')) next.Currently only supports Dictionaries, Arrays, and Strings.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/PropertyList.st'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ProtocolsExamples	self name: 'Protocols-Examples'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'These are some classes that are removed by Sunit-removal,but are not part of SUNIT 3.1.The classes (TestViaMethodCall, VerifierOfProperty, Verifier)are now in the system cathegoy "Protocols-Examples", all "example-for" methods are in the according DVS-category.Original documentation (from Verifier class comment):Instead of one new class per class being tested, many classes may use TestViaMethodCall.  Hold a Verifier (a MethodCall with an expected answer).  Run that method and compare the actual answer with the expected answer.All class that implements #exampleFor: will be asked for all of their test cases.  For now, they appear in one big list, not separated by class.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Protocols-Examples.st'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Quotes	self name: 'Quotes'.	self version: '21'.	info category: 'Uncategorized'.	info description: 'A simple package that displays Quote/Author pairs in a window. The quotes are displayed sequentially or in a random order. The speed of the display is adjustable via a slider.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Quote-Display-fc.21.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ROE	self name: 'ROE'.	self version: '42'.	info category: 'Uncategorized'.	info description: 'A library for manipulating relational queries as first class Smalltalk expressions, and generating SQL from them.There''s no documentation yet, but you can maybe muddle through using the test cases and some comments I made on my blog here:  http://www.cincomsmalltalk.com/userblogs/avi/blogView?searchCategory=databases .Requires the PostgreSQL Client.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Roe-avi.42.mcz'.	self provides: #().	self dependsOn: #('PostgreSQL Client').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!RefactoringBrowser	self name: 'Refactoring Browser'.	self version: '32'.	info category: 'Uncategorized'.	info description: 'The Refactoring Browser, a system browser that has additional menu items to perform refactorings on your code.  There are many supported refactorings, including renaming of methods and variables while simultaneously updating all accesses to those methonds and variables.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Refactory-md.3.7.32.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!RegularExpressionPlugin	self name: 'Regular Expression Plugin'.	self version: '3.3.1'.	info category: 'Uncategorized'.	info description: 'This package is extensively documented, and comes with a large test suite. From the comments in the package:Regular expressions are a language for specifying text to ease the searching and manipulation of text.  A complete discussion of regular expressions is beyond the scope of this document.  See Jeffrey Friedl, Mastering Regular Expressions, by O''Reilly for a relatively complete.  The regular expressions supported by this package are similar to those presently used in Perl 5.0 5 and Python, and are based upon Philip Hazel''s excellent PCRE libraries (incorporated almost without change, subject to a free license described in Re aLicenseComment.  Thanks are due to Markus Kohler and Stephen Pair for their assistance in the initial ports of early versions of the Plugin.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Regex5.sar'.	self provides: #().	self dependsOn: #('VMMaker').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!RemoteFrameBuffer	self name: 'RemoteFrameBuffer'.	self version: '33'.	info category: 'Uncategorized'.	info description: 'Provides RFB (VNC) server and client, written entirely in Squeak.Both server and client implement a superset of the latest (version3.3.7) RFB protocol published by RealVNC.com (with extensions tosupport local cursor handling in the popular TightVNC client).The server transmits (or broadcasts) the Squeak desktop to remoteVNC clients (either running natively on Unix, Mac or Windows, orrunning the Squeak client included in this same package).The client connects to and displays a remote framebuffer (providedeither from a VNC server running natively on Unix, Mac, Windows, etc.,or from a remote Squeak image running the server included in thispackage).To install, just grab RFB.33.cs and file it into a 3.6 image.Full documentation is included (see the class comments inRFBServer and RFBClient, and the help items on theassociated menus).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/RFB.33.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!RoleS	self name: 'RoleS'.	self version: '0.0.4'.	info category: 'Uncategorized'.	info description: 'RoleS is an experimental extension of Squeak for role modeling. It builds on AspectS. One of the interesting properties of RoleS is that when one or more roles are added to an instance, the instance''s identity does not change (no loss of identity)... '.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/RoleS.23Mar1845.cs.gz'.	self provides: #().	self dependsOn: #('AspectS').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SARBuilder	self name: 'SARBuilder'.	self version: '8'.	info category: 'Uncategorized'.	info description: 'SARBuilder lets you build .SAR (Squeak ARchive) packages from ChangeSets, Monticello packages, versions, or snapshots, or PackageInfo instances.Please see the class comments in SARInstaller'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SARBuilder.8.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SIForgeWizard	self name: 'SIForgeWizard'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'SIForgeWizard is a small seaside application for the authors of the http://www.siforge.org  italian web site. SIForgeWizard is suitable for  building a small XML-article complaiant with the SIForge specification. Look at http://www.siforge.org  for more information.It is ALSO a SMALL example of how building a simple wizard with seaside.For comments, questions and so on email to giovanni.giorgi@siforge.orgthe current mantainer of this package.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SIForge.1.0.st.gz'.	self provides: #().	self dependsOn: #('Seaside').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SIXX	self name: 'SIXX'.	self version: '0.1h'.	info category: 'Uncategorized'.	info description: 'SIXX is an XML serializer/deserializer written in Smalltalk (currently Squeak 3.7, VisualWorks 5i.4 - 7, and Dolphin XP are supported). The purpose is to store and load Smalltalk objects in a portable, dialect-independent XML format.*YAXO or VWXML is needed to run SIXX*'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SIXX.sar'.	self provides: #().	self dependsOn: #('YAXO').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SPLPDFLibrary	self name: 'SPL PDF Library'.	self version: '1.0-21a'.	info category: 'Uncategorized'.	info description: 'Write PDF files directly from within Squeak using the PDF Library. The latest version has support for text, lines and TIFF images. The library was developed and extended at SPL WorldGroup for specific projects, and does what was needed for those projects. It is expected that the library will contine to be extended over time as feedback is received from the people using it.The library is available under a very unrestrictive licence, but it is nevertheless a license. Please read the license at: http://wiki.cs.uiuc.edu/VisualWorks/PDF+Library.Once you have loaded the package, have a look at PDFReportingSelfTest class>>test to get an idea of what the framework can do.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SPDF-1.0-021a.st.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SSP	self name: 'SSP'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'This change set enables servlet style methods to be written in the class browser. I named it SSP because of it''s likeness to JSP, PSP, etc. However, it''s not exactly like those schemes, in that it has nothing (necessarily) to do with web serving and the like. SSP methods write the contents of their source onto a stream. Smalltalk code segments (delinieated with <% and %>) can be embedded into this text. Additionally, embedding Smalltalk code between <%= and %>, will force the compiler to send #sspStreamOn: to the result of evaluating the enclosed expression.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ssp.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SUnit	self name: 'SUnit'.	self version: '3.1.6'.	info category: 'Uncategorized'.	info description: 'This is SUnit 3.1This is for Squeak3.7This will not work on Squeak3.6 (you allready haveSUnit 3.1 in the 3.6 Image. No need to install this one).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SUnit-md.6.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SUnitactivetutorial	self name: 'SUnit active tutorial'.	self version: '0.4'.	info category: 'Uncategorized'.	info description: 'Requires that SUnit 3.1 be installed (it is preinstalled in 3.6).This is a two part tutorial. Test Driven Programming consists of two activities -1. Extending the code so that it passes the tests.1. Extending the test suite to cover new/intended functionality.To get a taste of the first (and learn how to use the Test Runner), you should do the tutorial described in the class comment of the class LargestSuffixTest. For more practice, pick one of the failing tests from the weekly report, get it green, and submit your fix.To get a taste of the second, do the tutorial described in the class comments of  CommonPrefix, CommonPrefixTest and TestCompleteTest.If you want to read more about SUnit itself, you might find the articles below usefulhttp://www.iam.unibe.ch/~ducasse/WebPages/Programmez/OnTheWeb/Eng-Art8-SUnit-V1.pdfhttp://www.xprogramming.com/testfram.htmold version comments:0.3 -First public version. Try it out, and if it seems unclear, please contact us to let us know. Making it very clear what to do is what a tutorial is all about...'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SUnit-Tutorial.st'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SVI	self name: 'SVI'.	self version: '2.1alpha2'.	info category: 'Uncategorized'.	info description: 'The latest version of SVI is for Squeak 3.7. If you want a version that works in Squeak 3.6, go <a href="http://www.swerlingphoto.com/squeak/svi2/svi2.html">here</a>.The latest release of SVI has been tested on Squeak 3.7 with updates up to #5969. SVI is a modal text editor for squeak that can be used in place of the PluggableTextMorph. SVI is designed to behave, as much as possible, like a standard text editor, so as not to confuse users that are not familiar with modal text editors. Nevertheless, SVI features extensive support for VIM and Emacs modes and commands, including:- incremental search, w/ support for Andrew Greenberg''s regex plugin, if it''s installed- interactive search/replace- split panes- multilevel undo/redo- navigation, using keyboard driven menus and bookmarks, between classes, methods, files, and system windows- context sensitive help and command completion- customizable keybindings- ability to paste recently deleted, inserted, or copied text. Also, VIM-style "registers" - support for VIM''s Normal, Visual and Linewise Visual modes, with extensive support for the VIM commands, motions, registers. Mark implementation supports method-to-method jumps , method-to-file, file-to-file, etc.By default, SVI supports many VIM commands. If you want SVI to support Emacs commands instead, be sure to take the tour of Emin (SVI''s "mini-emacs"). After loading SVI, execute "SVI openEminDocs" to take a tour of Emin. Patches to make SVI work with StarBrowser and Celeste are available <a href="http://www.swerlingphoto.com/squeak/svi2/appPatches.html">here</a>. The Celeste version is provided as an example of how to fully integrate an application with SVI (with a recent message list, bookmarking, opening a celeste message in a split pane, etc). A release change log for SVI is <a href="http://www.swerlingphoto.com/squeak/svi2/sviChanges.txt">here</a>'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SVI-v2.1alpha2.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Scamper	self name: 'Scamper'.	self version: '32'.	info category: 'Uncategorized'.	info description: 'A WWW browser.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Scamper-md.3.mcz'.	self provides: #().	self dependsOn: #('Network-HTML').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Scheduler	self name: 'Scheduler'.	self version: '10'.	info category: 'Uncategorized'.	info description: 'A simple task scheduler that can run tasks:    * Now    * Once at a particular time point in the future    * Every x seconds, minutes, or hours    * Daily at a set timeTasks are blocks passed to the scheduler for ease of use. e.g.scheduler := TaskScheduler new.scheduler start.scheduler  do: [Smalltalk snapshot: true andQuit: false]  everyMinute: 30.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Scheduler-jrp.10.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ScreenShotMorph	self name: 'Screen Shot Morph'.	self version: '0.0.0.1'.	info category: 'Uncategorized'.	info description: 'A morph helping you to make a screenshot. The morph should openin the top left corner of the screen. Double clickwill activate the morph. You have 5 seconds before the screen shot is taken.- Originally written by Lex Spoon- Torsten added image, double click behavior- the morph now hides itself if the screenshot is taken'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ScreenShotMorph.1.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ScriptingWorkspace	self name: 'Scripting Workspace'.	self version: '1.22-apha'.	info category: 'Uncategorized'.	info description: 'This is meant to be a workspace for people familiar with scriping languages like Javascript, Ruby, Python, or Perl. It gives the workspace the ability to add classes and methods.See ScriptingWorkspaceTest for examples."Do This To See It"ScriptingWorkspace open'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/btb-ScriptingWorkspace-btb.22.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Seaside	self name: 'Seaside'.	self version: '2.5b3'.	info category: 'Uncategorized'.	info description: 'A framework for building sophisticated web applications in Squeak.  Develop for the web using reusable, embeddable components and unique call/return semantics for moving between pages.Seaside requires a web server; the most commonly used is KomHttpServer.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Seaside2.5b3.mcz'.	self provides: #().	self dependsOn: #('KomHttpServer').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SeasidePresentation	self name: 'Seaside Presentation'.	self version: '1.55-alpha'.	info category: 'Uncategorized'.	info description: 'This is a presentation that Blaine Buxton gave at the Omaha User''s Group and several times at work. It looks best in Opera, but works fine in IE and Mozilla as well.Make sure you have Seaside 2.5 installed.To start (do-it if you Kom is not started):WAKom startOn: 9090.And then point your browser to:http://localhost:9090/seaside/presentationEnjoy!!'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/btb-presentation-btb.55.mcz'.	self provides: #().	self dependsOn: #('Seaside').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SeasideTesting	self name: 'SeasideTesting'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'This package extends SUnit to enhance testing of Seaside components.  Tutorial is available (see package web site).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SeasideTesting-R1.1-cds.3.mcz'.	self provides: #().	self dependsOn: #('SUnit').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SendTreeExplorer	self name: 'SendTreeExplorer'.	self version: '1alpha'.	info category: 'Uncategorized'.	info description: 'This little goodie provides new tools SendTreeExplorer and MessageSendTree.  Like MessageTally, MessageSendTree traces the execution of a block in simulation. There are three key differences:    1.	Rather than tallying the number of times each method is called in a given context, MessageSendTree traces and returns the exact tree of the sends made, in send order.     2.	MessageSendTree is designed to work with a SendTreeExplorer which presents the results in a hierarchical list view rather than flattened to a text pane.     3.	MessageSendTree allows all sends above a given method to be ignored, so that such a method can be conveniently traced deep in the execution of the block without the bother of wading through a long send chain to get there. '.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SendTreeExplorer-JW.1.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ServicesBase	self name: 'Services-Base'.	self version: '23'.	info category: 'Uncategorized'.	info description: 'Support code and basic services forsqueak. Does not depend on anything,but you might want to load :-Keymapping (from Steven Swerling and C. David Schaffer)-Services-Keymapping-Services-RB-Services-OB-Services-Whisker-BrowseUnit'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Services-Base-rr.23.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SharedStreams	self name: 'SharedStreams'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'SharedStreams introduces SharedBufferStream and SharedBidirectionalStream.SharedBufferStream is like a SharedQueue (FIFO) but for a stream of bytes/characters instead of separate objects. It can be used as a "socket" between Squeak processes in order for them to communicate with a stream protocol.A SharedBidirectionalStream is like a "socket" between two (or more) Squeak processes. Internally it uses two SharedBufferStreams, one for input and one foroutput. It handles multiple Processes at both ends.In order for the protocol to be the same no matter what side you are of thestream you can access the "other end" by calling #otherEnd.A SharedBidirectionalStream then creates a single mirror twin brotherwhich it shares the two internal SharedBufferStream with - but with the inStreamand outStream twisted.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SharedStreams-1_1.st.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Shout	self name: 'Shout'.	self version: '3'.	info category: 'Uncategorized'.	info description: 'Syntax highlighting that dynamically changes as you edit a method. After each key stroke (or other change) the code is parsed and the syntax highlighting updated so that it is in sync with the current method source.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Shout.3.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ShoutMonticello	self name: 'ShoutMonticello'.	self version: 'Alpha.1'.	info category: 'Uncategorized'.	info description: 'Enables syntax highlighting in Monticello browsers.Requires Shout.2 to be loaded first.Resolves identifiers according to Snapshot contents, so that unloaded packages are styled correctly (with respect to their own contents).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ShoutMonticello.1.mcz'.	self provides: #().	self dependsOn: #('Monticello' 'Shout').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ShoutOmniBrowser	self name: 'ShoutOmniBrowser'.	self version: 'Alpha.1'.	info category: 'Uncategorized'.	info description: 'Enables Shout with OmniBrowser (1.0a3).Shout.2 and OmniBrowser1.0a3 must be installed first.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ShoutOmniBrowser.4.mcz'.	self provides: #().	self dependsOn: #('OmniBrowser' 'Shout').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ShoutTraits	self name: 'ShoutTraits'.	self version: 'Alpha.1'.	info category: 'Uncategorized'.	info description: 'Shout.2 and Traits Beta1 must be installed first.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ShoutTraits.4.mcz'.	self provides: #().	self dependsOn: #('Shout' 'Traits').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ShoutWhisker	self name: 'ShoutWhisker'.	self version: 'Alpha.1'.	info category: 'Uncategorized'.	info description: 'Enables Shout with the Whisker Browser (1.0).Whisker Browser 1.0 and Shout.2 must be installed first'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ShoutWhisker.2.mcz'.	self provides: #().	self dependsOn: #('Shout' 'Whisker Browser').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ShoutWorkspace	self name: 'ShoutWorkspace'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'An optional package that installs a Syntax Highlighted Workspace, which can be opened from the World,open...,Shout Workspace menu item.Requires Shout.3 or later to be installed first.Previous versions of Shout applied syntax highlighting to all workspaces. This was annoying if the workspace was being used to edit plain text. Shout.3 no longer syntax highlights workspaces, hence the need for a distinct ShoutWorkspace.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/ShoutWorkspace.1.mcz'.	self provides: #().	self dependsOn: #('Shout').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Simulations	self name: 'Simulations'.	self version: '1'.	info category: 'Uncategorized'.	info description: ''.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Simulations.2.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Singletons	self name: 'Singletons'.	self version: '1'.	info category: 'Uncategorized'.	info description: '***The delegation methods of this package make use of the ObjectsAsMethods VM support.  In a 3.6 image, you must call #recreateSpecialObjectsArray before using this package.***This package adds the #becomeSingleton method to Object, which will transform the receiver into an instance of a new, anonymous subclass of its original class.  This lets you add or redefine methods on an object-by-object basis.This is intended to be used primarily for delegation - replacing a method with a block or a message send to another object.  The methods #to:run:, #to:send:to:, and #delegate:to: are provided for this purpose.  The following three calls are all equivalent:<pre>x delegate: #foo: to: someOtherObject.x to: #foo: send: #foo: to: someOtherObject.x to: #foo: run: [:arg | someOtherObject foo: arg].</pre>In all three cases, sending #foo: to x will end up forwarding the message to someOtherObject. My expectation is that this might be useful as a replacement for specifying pluggable behavior with block inst vars or target/selector pairs, particularly for UI classes.  Rather than explicitly putting in hooks for pluggablity, a well factored object can be customized from the outside without its knowledge, by overriding existing methods - particularly those that are #subclassResponsibility - but without going to the trouble of adding a named subclass for each use.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Singletons-avi.1.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Skeleton	self name: 'Skeleton'.	self version: '0.4.1'.	info category: 'Uncategorized'.	info description: 'Skeleton is a easy scripting system with spreadsheet-like userinterface.  It handles an etoy''s slot as a spread sheet''s cell. So usercan describe declarative rules among morphs as spread sheet''s "=A1 +A2" style. It is similar with Visio''s "shape sheet", butSkeleton-sheet has more dynamic and real-time behavior.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Skeleton-Base-0.4.1.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SmaCC	self name: 'SmaCC'.	self version: '1.4'.	info category: 'Uncategorized'.	info description: 'SmaCC (Smalltalk Compiler-Compiler) is a freely available parser generator for Smalltalk. Use this package if you want to develop a new parser/scanner/compiler.It  is a replacement for the T-Gen parser generator. T-Gen has several limitations  that make it difficult to produce parsers. SmaCC overcomes T-Gen''s limitations. For example, SmaCC  can generate parsers for ambiguous grammars and grammars with overlapping tokens.  Both of these are not possible using T-Gen. In addition to handling more  grammars than T-Gen, SmaCC has a smaller runtime than T-Gen and is faster than  T-Gen.   Needs the refactoring browser as a prerequisite, but installs one on its own, if none is installed.Use the tutorial as a starter.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SmaCC-Development-mga.8.mcz'.	self provides: #().	self dependsOn: #('Refactoring Browser').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SmallDEVS	self name: 'SmallDEVS'.	self version: '2004-3-19'.	info category: 'Uncategorized'.	info description: 'SmallDEVS is a new implementation of B. Zeigler''s DEVS formalism. Its design is based on Zeigler''s book "Theory of Modeling and Simulation" and partially inspired by Python DEVS  (http://moncs.cs.mcgill.ca/MSDL/research/projects/DEVS/).References:- Bernard P. Zeigler, Herbert Praehofer, Tag Gon Kim: "Theory of Modeling and Simulation. Integrating Discrete Event and Continuous Complex Dynamic Systems". Second Edition. Acadedemic Press, 2000- Python DEVS http://moncs.cs.mcgill.ca/MSDL/research/projects/DEVS/- Other DEVS implementations http://www.sce.carleton.ca/faculty/wainer/standard/tools.htm- One of DEVS tutorials (DEVSim++) http://sim.kaist.ac.kr/devsim/tutorial-ESS2001.pdf'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SmallDEVS.9.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SmallInterfaces	self name: 'SmallInterfaces'.	self version: '2.0.0a'.	info category: 'Uncategorized'.	info description: '''SmallInterfaces'' brings you long-awaited ''interface'' in Smalltalk. The extension is originally developed by Benny Sadeh in VisualWorks NC. I ported this interesting extension to Squeak.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SmallInterfaces.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Smalltalk72	self name: 'Smalltalk 72'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'Dan Ingalls did an emulation of the Smalltalk-72 emulator for Alan Kay''s birthday.The original Smalltalk 72 User Manual is available:http://www.spies.com/~aek/pdf/xerox/alto/Smalltalk72_Manual.pdf'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Smalltalk72.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SoapCoreClient	self name: 'SoapCoreClient'.	self version: '0.6'.	info category: 'Uncategorized'.	info description: 'SoapCoreClient is a SOAP client implementation for Squeak. It achieves some interoperability with other SOAP, such as SOAP4R, Splash/Spray, etc. Designed to be lean and simple.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SoapCoreClient.sar'.	self provides: #().	self dependsOn: #('YAXO').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SoapCoreServer	self name: 'SoapCoreServer'.	self version: '0.6'.	info category: 'Uncategorized'.	info description: 'SoapCoreServer is a SOAP server implementation for Squeak. It achieves some interoperability with other SOAP, such as SOAP4R, Splash/Spray, etc. Designed to be lean and simple.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SoapCoreServer.sar'.	self provides: #().	self dependsOn: #('KomHttpServer').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Sokoban	self name: 'Sokoban'.	self version: '0.1.3'.	info category: 'Uncategorized'.	info description: '"The object of Sokoban is to push all stones (or boxes) in a maze, such as the one to the right, to the designated goal areas. The player controls the man and the man can only push stones and only one at a time. The restriction of only being able to push the stones makes this game challenging: One can create unsolvable positions. Players will soon learn that this is the main obstacle in solving problems. Advanced players also try to find shorter and shorter solutions, measured in stone pushes and man moves." (http://www.cs.ualberta.ca/~games/Sokoban/)'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Sokoban.19Jul1841.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SokobanEnhanced	self name: 'Sokoban Enhanced'.	self version: '20040425'.	info category: 'Uncategorized'.	info description: 'Sokoban is a wonderfully addictive little puzzle game. This is an enhanced version of the original version as found on Squeak Map. The original version was published for Squeak by Robert Hirschfeld.After playing it for a while I made a few enhancements to the game. A lot of the changes were cosmetic. But the most important enhancement is that an undo command was added. The game is a lot more playable. All the original rules about moves and the original puzzle/board configurations are intact. I just added a move stack that allows you to use the "z" key and roll-back any move you had already made. I also added a move that allows the use of the Control key modifier and causes a move to repeat. It''s easier to just try it than explain it here.To see a picture of the game look here: <a href="http://squeak.preeminent.org">http://squeak.preeminent.org</a>'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Games-Sokoban-sbw.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Sorrow	self name: 'Sorrow'.	self version: '6'.	info category: 'Uncategorized'.	info description: 'A compiler for a language similar to Joy (http://www.latrobe.edu.au/philosophy/phimvt/joy.html) to Squeak bytecode.Requires Squeak 3.7.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Sorrow-avi.6.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SortCriteria	self name: 'Sort Criteria'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'The Sort Criteria objects extend the standard SortCollection with an easy touse, simple yet powerful and dynamic sorting capability that can sortmultiple ''columns'' or ''attributes'' of a collection of objects. It''s easy torearrange the column sort ordering and the acending or decending state of thesort. It''s simple because it just works with SortedCollections as you currentlyuse them. It''s powerful because you can sort any sequence of attributes in anobject. It''s dynamic as a SortCriteria and it''s columns can be created on thefly by a user interface enabling the user to choose their own sort order andascending/decending sequence.The SortCriteria and SortCriteriaColumn (and SortCriteriaTest for an example)are the classes that are added to the Smalltalk system. No changes toSortedCollection were required or other Smalltalk system classes.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SortCriteria_Squeak_v1.st.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SpaceWar	self name: 'SpaceWar'.	self version: ''.	info category: 'Uncategorized'.	info description: ''.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SpaceWar.25Jan2223.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SqCVS	self name: 'SqCVS'.	self version: '0.51'.	info category: 'Uncategorized'.	info description: 'SqCVS is a clean implementation of the CVS pserver protocol in Squeak.It is written on top of SocketStream - the highlevel Socket class found in theComanche package. This means Comanche is a prerequisite.SqCVS has no UI and it still doesn''t know how to do "add" and "remove".But it knows how to do pretty much of the CVS protocol.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/CVS-0_51.st.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SqueakMap2Base	self name: 'SqueakMap2 Base'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'The base package for SqueakMap2. Contains the domain code.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SMBase-gk.63.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SqueakMap2Loader	self name: 'SqueakMap2 Loader'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'This is the graphical tool called the "SqueakMap Package Loader" that can be opened from the World open... menu. This tool is a UI for the local instance of SMSqueakMap that can be accessed with "SMSqueakMap default".In the loader you can browse the map and see packages and package releases and also install them into the image. '.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SMLoader-gk.24.mcz'.	self provides: #().	self dependsOn: #('SqueakMap2 Base').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SqueakMap2server	self name: 'SqueakMap2 server'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'The new SqueakMap web front end with lots of good stuff. :)'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SMServer-gk.17.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SqueakNETBridge	self name: 'Squeak/.NET Bridge'.	self version: 'R5'.	info category: 'Uncategorized'.	info description: 'The Squeak/.NET bridge lets you use .NET objectsin your Squeak programs.  It uses TCP sockets tocommunicate with a .NET VM.  You can use any .NETlibrary with the bridge, and can implement interfacesfrom your .NET libraries in Squeak.Here''s the canonical example:    list := DotNet ArrayList new.    Transcript show: list count. "Prints 0"'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SqueakDotNet.r5.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SqueakPrototypes	self name: 'Squeak Prototypes'.	self version: '7'.	info category: 'Uncategorized'.	info description: 'Hans-Martin Mosner originally wrote some code to allow prototype objects to exist in the Squeak image.  All I have done is allow those objects to delegate their behavior to other objects.    This code is stable, in the sense that I am unlikely to change it...'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/System-Prototypes.7.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!StateReplicationProtocolSRP	self name: 'State Replication Protocol (SRP)'.	self version: '2.1 6'.	info category: 'Uncategorized'.	info description: 'SRP serializes the state of a network of objects into a stream of data. Serialization starts with a root object and traverses all objects referenced directly or indirectly down to a user defined level. As object state is serialized, it can be transported to an object space of another OO computer language or dialect and the object network can be loaded (replicated) as it was saved. SRP''s streaming of objects is affectionately refered to as "SluRPing"--as in slurping an object. '.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SRP2.1-006.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SwazooHTTP	self name: 'Swazoo-HTTP'.	self version: '7'.	info category: 'Uncategorized'.	info description: 'A portable set of classes that model HTTP requests and responses, that form a base on which a web server could be built.  With suitable extensions, these could also be used for an HTTP client library.See *Swazoo-Server* for the original, portable server code that used these, or *Swazoo-Listener* for a much simplified, Squeak-specific server.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Swazoo-HTTP-avi.7.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!SystemTracer2	self name: 'SystemTracer2'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'This work is based on Anthony Hannan''s original SystemTracer2. It adds a RehashingSystemTracer that allows you to manipulate identity hash values during a trace. See the class comments for SystemTracer2 and RehashingSystemTracer for more details.RECOMMENDED: It is recommended that you load the "Large Collections" package (available on SqueakMap) to get better performance. A trace on my machine that took 9.7 minutes without large collections took only 2.5 minutes with large collections loaded. Large collections are recommended, but not required for SystemTracer2 to work.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SystemTracer2.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!TableLayoutTutorialProject	self name: 'TableLayout Tutorial Project'.	self version: '11'.	info category: 'Uncategorized'.	info description: 'TableLayout tutorial project'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/TableLayouts.011.pr'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Taskbar	self name: 'Taskbar'.	self version: '0.6'.	info category: 'Uncategorized'.	info description: 'A simple morphic taskbar (similar to the taskbars available for many windowingsystems).  Shows a list of buttons representing windows and morphs in your world.Pressing a window''s button brings that window to the front and activates it.  Ifit is already in the front then it is hidden.  Replaces the default collapsebehavior for windows so that they hide/unhide instead.  Pressing a Morph''s buttonbrings it to the front and raises it''s halo.  Can be placed on a global flap.Execute "WindowListMorph open" to start (or use "Taskbar" from the open menu).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/WindowList-cds.28.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Techo	self name: 'Techo'.	self version: '20040514'.	info category: 'Uncategorized'.	info description: 'Techo isMultiple workspace stored plain text fileNotepad without file nameGrep tool(but not real REgexp).It is very simple tool, but useful to make a memo, to exchange oneliner among Squeak images, and to play a text base Smalltalk programming puzzle.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Techo-Base-20040514.st'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Telnet	self name: 'Telnet'.	self version: '301'.	info category: 'Uncategorized'.	info description: 'This package contains various components that facilitate interactive loginto a remote (or the local) machine:* a (glass) TeletypeMorph;* essentially complete emulation of vt52, vt102 and xterm terminals;* a telnet client for connecting to remote machines;* a `pseudo-tty'' client for connecting to an interactive shell on the local machine;* a protocol stack abstraction that glues the above together; and* a TeletypeWindow morph which makes a clickable application out of it all.The pseudo-tty client will only work on Unix, but the telnet client shouldwork fine on any platform (Unix, Mac, Windows, etc.) that supports sockets.Please visit the homepage for further details (especially if you want to usethe pseudo-tty client, since you may have to download an additional changeset).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/telnet.301.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!TestBrowser	self name: 'TestBrowser'.	self version: '1.12'.	info category: 'Uncategorized'.	info description: 'TestBrowser is a enhanced TestRunner for Squeak. It supports: * Filtering test cases by class category * You can run and edit test cases/codes in one window'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/TestBrowser.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!TextFiles	self name: 'TextFiles'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'TextFiles is a package for flexibly dealing with any sort of text file. Features:* Provides buffered operations for efficiently reading and writing large files* Supports automatic line end conversions* Provides a framework for various encodings such as ISO-8859 etc.* Polymorphic with FileStream so you can create a TextFile just the way you would create a FileStream* Usable with internal as well as external streams, so you can convert text representations within Squeak too* Supports ''chunking'' to index files containing chunks of text more efficientlyFor a closer look check out the accompanying documentation.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/TextFiles.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!TimeZoneDatabase	self name: 'TimeZoneDatabase'.	self version: '1.2.1'.	info category: 'Uncategorized'.	info description: 'This is a time zone database for Smalltalk. It answers the number of secondsoffset from UTC for any time zone at any point in time in the range of thedatabase rule set, as well as the number of leap seconds for a point in time(for tzfiles which contain the leap second rules).A full time zone database requires access to tzfile data files, typicallydistributed with Unix (Linux) systems. A limited set of tzfile files is providedto initialize the database and demonstrate its functions.~'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/TimeZoneDatabase-1-2-1-dtl.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Train	self name: 'Train'.	self version: '0.2-alpha'.	info category: 'Uncategorized'.	info description: ''.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Train.1.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Traits	self name: 'Traits'.	self version: 'beta1.1'.	info category: 'Uncategorized'.	info description: 'Prerequisite packages: Monticello and the newest version of PackageInfoTraits Release beta1====================Over the last months we have been working on a new stable implementation of Traits in Squeak. This is the first public beta release. Please note that this version features a new language kernel that supports all the necessary features for creating and composing traits, but that there are still many features missing that are absolutely crucial for getting the real "traits experience". (See the limitations section below).Please find more information and papers about Traits at:http://www.iam.unibe.ch/~scg/Research/TraitsOur implementation consists of the following parts:- The Kernel: In contrast to the traits prototype, the new traits implementation features a clean, efficient and stable kernel, which is an extension of the traditional Smalltalk-80 kernel of Squeak. The kernel is feature complete as far as creation and composition of traits is concerned, but it may still have bugs. Note that in the current version, the kernel contains some duplicated code between the class and the traits hierarchy. However, this is not an accident but a conscious design decision as we will get rid of this duplicated code by bootsrapping/refactoring the kernel using traits itself.- The User Interface: We''ve started implementing a new traits browser with OmniBrowser. It supports composing and browsing classes and traits and let you "dive" into the composition structure of traits. In addition, the old browser has been modified to show a flat view for programmers who like to view and work with Squeak as it was before.- Monticello: We''ve made Monticello traits aware, letting you save and load traits (even to SqueakSource). Note, that code which is saved with this modified version of Monticello can not be loaded with a normal Monticello (even if it does not include traits). This implementation should be considered as a prototype and should be refactored.As an alternative you can also use the normal fileOut mechanism which supports traits as well.Installation------------The implementation is available as a SAR file on SqueakMap. It is tested in a new fresh 3.7b image. Prerequisite packages are Monticello and the newest version of PackageInfo.Beside loading the kernel and the modified Monticello and OmniBrowser there will also be KCP-0220-ClassOrganizerFixAndCleanup.14.cs loaded because this change is not in the update stream yet. Please note, that the installation takes about 30 Minutes (depending on the speed of your machine) because it needs to recompile all the classes in the image. (This is a consequence of the fact that we had to change the format of the kernel classes.)Getting Started---------------Open the Traits OmniBrowser: World Menu -> open -> Traits BrowserCreate a new trait: Open the context menu in the class/trait pane and select "create trait..."Limitations------------ There are still many features missing that are absolutely essential for getting the real "traits experience", but these are mainly related to the UI and IDE. For example:  - There are no virtual categories that present the conflicts and glue methods of a composite class/trait.  - There is no automatic computation of requirements  - There is no information that shows which traits/classes provide or require the currently selected methods  - There is no support for turning classes into trait  - etc.- The current UI is just a "minimal placeholder" that allows one to start using/playing with traits. However, many improvements are still missing.- There are known bugs in OmniBrowser (which still is in alpha).- The OmniBrowser updates very slowly.- No documentation apart from the papers yet. '.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Traits-beta1.1.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Typeinference	self name: 'Typeinference'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'This is Francisco Garau''s TypeInferencer, as a SAR package.This does not contain the Morphic-Wrapper dependendparts.                                             For more information, see http://typeinference.swiki.net/1'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/TypeInference.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Units	self name: 'Units'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'The Units package allows you to represent, convert, and perform arithmetic with physical unit values (e.g. distances, velocities, accelerations, etc).There is not much formal documentation, but most of the classes in this package have comments. The most important methods are those in Unit and UnitValue. You should look through all those.To add your own units, see the classes BaseUnit, DerivedUnit, NamedUnit, and PrefixedUnit, and look through the initialization code. You should duplicate what is done there to add your own units. Remember to send Unit initialize to make your changes take effect.Note that you can send  Unit printAbbreviated: true  or  Unit printAbbreviated: false  to control how units print.Ported to Squeak by Helge Horch'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Units-md.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!Universes	self name: 'Universes'.	self version: '9'.	info category: 'Uncategorized'.	info description: 'Tools to manage package universes, including a package browser, a universe editor, and a universe server.'.	info maintainer: '"Lex Spoon"  <lex@cc.gatech.edu>'.	info homepage: 'http://minnow.cc.gatech.edu/squeak/3785'.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Universes-ls.9.mcz'.	self provides: #().	self dependsOn: #('YAXO').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!UpdateStreamsforSqueakMap	self name: 'UpdateStreams for SqueakMap'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'Provide the ability to host individual update streams for any package at SqueakMap. Right now, this relies on a hack in the package description which has to include the following lines somewhere:[loadUpdatesAt: http://isgwww.cs.uni-magdeburg.de/~raab/squeak/packages/SMUpdateStreams][storeUpdatesAt: ftp://raab@luxator.cs.uni-magdeburg.de/~/public_html/squeak/packages/SMUpdateStreams]'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/SMUpdateStreams.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!VMMaker	self name: 'VMMaker'.	self version: '3.7b5'.	info category: 'Uncategorized'.	info description: 'This package includes all the ObjectMemory/Interpreter classes, the VMMaker/Tool classes, the InterpreterPlugin hierarchy and all the assorted helper methods.If you install this you will be able to build or simulate a VM or plugin - AS LONG AS YOU HAVE THE LATEST CODE FROM SOURCEFORGE.See http://minnow.cc.gatech.edu/squeak/2015'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/VMMaker3-7b5.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!VassilisRegex	self name: 'Vassili''s Regex'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'A pure Smalltalk regular expression matcher.See http://www.magma.ca/~vassili/Regex/ for more info.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/VB-Regex-avi.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!VersionNumber	self name: 'VersionNumber'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'I am a version number. My representation allows me to handle an entire tree of versions. From a directory listing of verison numbered files, I can infer things about the tree of versions.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/VersionNumber.st'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!VideoandImageProcessing	self name: 'Video and Image Processing'.	self version: '2.1'.	info category: 'Uncategorized'.	info description: 'Mini-framework and tool for play with video in Squeak. You have filters that you can push in a stack, the output of the first filter is processed by the second and so on. The filters available today are: BackgroundSubstraction, GrayScale, Rotator, Mirror, Trail, Melt, Labeler, Mosaic, DepthChanger, Nervous, Delayer, Old TV, Emboss, Enhanced Focus, Blur, Edge Detector, Enhanced Edges and Soften. Add new filters is so easy, take a Form and give me a Form.Today is posible to get a video from a mpeg file or from a camera (the camera supports works only in windows).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/VideoAndImageProcessing-dgd.1.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!WanderingLetters	self name: 'WanderingLetters'.	self version: '22Feb-2.1'.	info category: 'Uncategorized'.	info description: 'This is wandering letters using the old non-Players (and non-multi-instance Players).  Just make a new Morphic Project and file it in. Toggle wandering by clicking the top button.  Responds to Stop and Go buttons so it does not have to be running all the time.Toggle method if getting back to their right places with the lower button.Change WanderingLetters>>stepTime to make the speed be right.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/WanderingLetters.22Feb-02.1.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!WarpSketchMorph	self name: 'WarpSketchMorph'.	self version: '1.12'.	info category: 'Uncategorized'.	info description: 'Playing with squeak morphic, I saw WarpBlt which seems to provide exactly the functionality I need to port an old java applet I did in 1997. WarpSketchMorph is a Morphic implementation similar to my DynFlex applet. Most fun is modifying images of faces.You can create a WarpSketchMorph either by evaluatingWarpSketchMorph new openInWorld.and choose an image with the "Choose new graphic..." halo menu item or use(WarpSketchMorph withForm: <yourForm>) openInWorld.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/WarpSketch.012.pr'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!WatchIt	self name: 'WatchIt!!'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'This adds a ''watch it'' choice to the context menus in text editors. This will take the selection, make a BlockContext out of it, and give you a Morph that will display the value of that block every half second.It can be used, for instance, from the Debugger to display an instance variable as your program runs.Try, for instance, watching this:World currentHand cursorPoint Only works in Morphic; results in an inspector being put up for the resultant block under MVC (you can evaluate ''self value'' in that inspector if you want).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/WatchWindow-nk.1.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!WhiskerBrowser	self name: 'Whisker Browser'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'Whisker is a different sort of object-oriented code browser for the Squeak Smalltalk environment.The goal of the Whisker Browser (a.k.a. Stacking Browser) is to provide a simple and intuitive way to view the contents of multiple classes and multiple methods simultaneously, while using screen real estate efficiently and not requiring a lot of window moving/resizing. It does this by introducing the concept of subpane stacking. The principles behind Whisker could potentially be used by browsers for other object-oriented languages (Java, Python, etc.).To open the Whisker Browser, use the ''open...''/''Whisker Browser'' menu item in the World menu.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Whisker1_0-Sq37.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!WintabTabletSupport	self name: 'Wintab Tablet Support'.	self version: '0.3-alpha'.	info category: 'Uncategorized'.	info description: 'This package extends the global variable Sensor for pressure sensitive tablets such as Graphire3 by WACOM(http://www.wacom.com/).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/WintabTablet.6.cs'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!X11Fonts	self name: 'X11Fonts'.	self version: '1'.	info category: 'Uncategorized'.	info description: 'SAR containing various X11 fonts using ISO-8859-15 encoding(similar to Latin-1 but the Euro sign is where it should be).Install from this archive to add TimesRoman, Helvetica, Courierand Fixed to the available system fonts, in various point sizes.Note that this archive neither creates any new methods in theimage, nor does it create any files in the working directory duringinstallation.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/x11fonts.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!XDisplayControlPlugin	self name: 'XDisplayControlPlugin'.	self version: '1.0'.	info category: 'Uncategorized'.	info description: 'The XDisplayControlPlugin package provides primitives for controlling the connection to an X display server for Squeak. Currently, this is useful for the Unix VM, but in principle can be used for any platform that can provide an X server, such as Win32, Mac OS, or OpenVMS. A running Squeak image may call these primitives to become headless, to open a display on an X server from a headless Squeak, or to connect itself to another X server.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/XDisplayControlPluginV1-0.2.sar'.	self provides: #().	self dependsOn: #('VMMaker').! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!XMLTransformer	self name: 'XMLTransformer'.	self version: '1.0-alpha'.	info category: 'Uncategorized'.	info description: 'With XMLTransformer you can bind Smalltalk code to any XML element.You can transform a XML into any other XML or finally in some other format ... Sound, Html, Pdf ... what you think of :)You can bind XML namespaces to a namespace class.You can bind XML elements to methods in a namespace class.After installing take a look at the examples and class comments in XMLT (Category XML-Transformer).Todo: - I have to create some example namespaces (Simplified Docbook). - Namespaces should be able to get parsed several times. - I need better solutions to avoid recursion.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/XMLT-1.0-alpha.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!YAXO	self name: 'YAXO'.	self version: '2.0b'.	info category: 'Uncategorized'.	info description: 'What''s new:- name space handling (turned off by default for compatibility)  adopted the code provided by Simon to have proper name space handling. Largely untested, might break some of the existing applications. That''s why it is turned off by default.- some speed-up fixes by Andreas and myself- misc fixes- SAX handlers #ignorableWhitespace: and #comment: now get called correctly.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Yaxo-2.0b.st.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!ZigZag	self name: 'ZigZag'.	self version: '0.1'.	info category: 'Uncategorized'.	info description: 'Categoring system influenced by Ted Nelson''s ZigZag with graphical visualisation.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/zigzag.sar'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!bonsexperimentsinalife	self name: 'bons - experiments in alife'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'some experiments in alife. There are no unit tests and the code could use some improvements but it''s a fun playground to goof off in.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/Morphic-alife-kdb.2.mcz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!presentationstutorial	self name: 'presentations tutorial'.	self version: '4'.	info category: 'Uncategorized'.	info description: 'A "bookish" tutorial with detailed instructions on how to create presentations.  Most examples focus on use of the StackMorph, but many points apply to BookMorphs and Projects as well.You can load this tutorial directly in squeak by popping up the "Navigator" flap, clicking the "Find" button, selecting "Bobs SuperSwiki", select "presentations tutorial.004.pr", and click "OK".'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/presentations%20tutorial.004.pr'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!rSTRemoteSmalltalk	self name: 'rST - Remote Smalltalk'.	self version: ''.	info category: 'Uncategorized'.	info description: 'Framework for supporting distributed Squeak objects. The main goal of the project is transparency, so you don''t need to change your objects to become remote. Another goal is to handle intermittence in the availability of the images, so PDA and Notebooks can interoperate in a distributed environment. Each object decides to pass "as copy" or "as reference", in the default implementation all objects pass "by reference" but Booleans, String, Character, Number and UndefinedObject (see implementors of #remoteType).'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/rST-dgd-19-March-2002.cs.gz'.	self provides: #().	self dependsOn: #().! !!PackagesSqueak37U methodsFor: 'Uncategorized' stamp: 'kph 9/10/2008 10:09'!shapes	self name: 'shapes'.	self version: '1.1'.	info category: 'Uncategorized'.	info description: 'Adds classes representing ESRI shapefiles. Commonly used types are handled: Polygon, Polyline, Point and MultiPoint shapes. Shape data are read from files and simply kept as-is in ByteArrays in ShapeMap objects. For further processing of shape data, conversion into real objects (Polygon, Arc, Point, etc) might be handier. Both the *.shp file and the index file (*.shx) are read. To get at the attributes of the shapes, the accompanying *.dbf file needs to be read (a dbf-reader is not incorporated in the current version).Besides reading, the only functionality included is viewing the contents of a ShapeMap as a Form.'.	info maintainer: ''.	info homepage: ''.	info squeakMapID: ''.	info url: 'http://universes.dnsalias.net:8888/universes/repositories/stable-3.7/shape1.1.sar'.	self provides: #().	self dependsOn: #().! !!Seaside29 class methodsFor: 'as yet unclassified' stamp: 'test 12/31/2008 03:05'!initialize	Platform := 'Squeak'! !!Seaside29 class methodsFor: 'as yet unclassified' stamp: 'test 1/2/2009 18:18'!findPath ^ { self. self current. self dev. Seaside29Beta. self beta.  }  ! !!Seaside29 methodsFor: 'as yet unclassified' stamp: 'test 1/2/2009 18:09'!KomHttpServer	 	^ self class current named: 'KomHttpServer'.! !!Seaside29 methodsFor: 'as yet unclassified' stamp: 'test 1/2/2009 18:10'!RefactoringCore	^ self class current named: 'RefactoringCore'.! !!Seaside29 methodsFor: 'as yet unclassified' stamp: 'test 1/2/2009 18:11'!Sport	 	^ self class current named: 'Sport'.! !!Seaside29Beta methodsFor: 'as yet unclassified' stamp: 'kph 2/11/2009 20:14'!defaultAction	self version: self version, '+'.	^ [ self info url ifNotNilDo: [ :url | (Installer fromUrl: url) latest install ] ]! !!Seaside29Builder class methodsFor: 'accessing'!findPath	^ Array with: self! !!Seaside29Builder methodsFor: 'private'!AST	self name: 'AST'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/AST/AST-lr.160.mcz'.	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!DynamicBindings	self name: 'DynamicBindings'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/KomHttpServer/DynamicBindings-gc.7.mcz'.	self action: self defaultAction! !!Seaside29Builder methodsFor: 'web 2.0'!JQueryCore	self name: 'JQuery-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/JQuery-Core-lr.37.mcz'.	self info description: 'jQuery integration for Seaside. Designed to change the way you write Javascript.'.	self info category: 'Web 2.0'.	self dependsOn: #('Javascript-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!JQueryTestsCore	self name: 'JQuery-Tests-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/JQuery-Tests-Core-lr.49.mcz'.	self info description: 'Functional and unit tests for the JQuery-Core package.'.	self info category: 'Tests'.	self dependsOn: #('JQuery-Core' 'Javascript-Tests-Core' 'Seaside-Development').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!JQueryTestsUI	self name: 'JQuery-Tests-UI'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/JQuery-Tests-UI-lr.32.mcz'.	self info description: 'Functional and unit tests for the JQuery-UI package.'.	self info category: 'Tests'.	self dependsOn: #('JQuery-UI' 'JQuery-Tests-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'web 2.0'!JQueryUI	self name: 'JQuery-UI'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/JQuery-UI-lr.25.mcz'.	self info description: 'jQuery-UI integration for Seaside. Expression through code.'.	self info category: 'Web 2.0'.	self dependsOn: #('JQuery-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'web 2.0'!JavascriptCore	self name: 'Javascript-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Javascript-Core-lr.27.mcz'.	self info description: 'Javascript integration in Seaside. Provides a basic functionality to generate Javascript from Smalltalk.'.	self info category: 'Web 2.0'.	self dependsOn: #('Seaside-Canvas').	self action: self defaultAction.	self addAction: (self class named: 'Javascript-Squeak-Core') defaultAction! !!Seaside29Builder methodsFor: 'private'!JavascriptSqueakCore	self name: 'Javascript-Squeak-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Javascript-Squeak-Core-lr.5.mcz'.	self dependsOn: #('Javascript-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!JavascriptTestsCore	self name: 'Javascript-Tests-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Javascript-Tests-Core-lr.25.mcz'.	self info description: 'Unit tests for the Javascript-Core package.'.	self info category: 'Tests'.	self dependsOn: #('Javascript-Core' 'Seaside-Tests-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!KomHttpServer	self name: 'KomHttpServer'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/KomHttpServer/KomHttpServer-gc.42.mcz'.	self dependsOn: #('KomServices').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!KomServices	self name: 'KomServices'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/KomHttpServer/KomServices-gc.19.mcz'.	self dependsOn: #('DynamicBindings').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'web 2.0'!RSSCore	self name: 'RSS-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/RSS-Core-lr.31.mcz'.	self info description: 'RSS integration for Seaside. Helps to create RSS 2.0 feeds.'.	self info category: 'Web 2.0'.	self dependsOn: #('Seaside-Canvas').	self action: self defaultAction.	self addAction: (self class named: 'RSS-Squeak-Core') defaultAction! !!Seaside29Builder methodsFor: 'examples'!RSSExamples	self name: 'RSS-Examples'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/RSS-Examples-pmm.14.mcz'.	self info description: 'Examples of how to use the "RSS-Core" package.'.	self info category: 'Examples'.	self dependsOn: #('RSS-Core' 'Seaside-Development').	self action: self defaultAction.	self addAction: (self class named: 'RSS-Squeak-Examples') defaultAction! !!Seaside29Builder methodsFor: 'private'!RSSSqueakCore	self name: 'RSS-Squeak-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/RSS-Squeak-Core-lr.5.mcz'.	self dependsOn: #('RSS-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!RSSSqueakExamples	self name: 'RSS-Squeak-Examples'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/RSS-Squeak-Examples-pmm.6.mcz'.	self info description: 'Squeak implementation classes for the package "RSS-Examples".'.	self dependsOn: #('RSS-Examples').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!RSSTestsCore	self name: 'RSS-Tests-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/RSS-Tests-Core-lr.10.mcz'.	self info description: 'Unit tests for the "RSS-Core" package.'.	self info category: 'Tests'.	self dependsOn: #('RSS-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!RefactoringCore	self name: 'Refactoring-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/RefactoringEngine/Refactoring-Core-lr.14.mcz'.	self dependsOn: #('AST').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'web 2.0'!ScriptaculousComponents	self name: 'Scriptaculous-Components'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Scriptaculous-Components-lr.70.mcz'.	self info description: 'A collection of AJAX based widgets written on top of script.aculo.us and Prototype.'.	self info category: 'Web 2.0'.	self dependsOn: #('Scriptaculous-Core' 'Seaside-Component').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'web 2.0'!ScriptaculousCore	self name: 'Scriptaculous-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Scriptaculous-Core-lr.66.mcz'.	self info description: 'Prototype and script.aculo.us integration for Seaside. Aims to ease development of dynamic web applications.'.	self info category: 'Web 2.0'.	self dependsOn: #('Javascript-Core' 'Seaside-Session').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!ScriptaculousTestsComponents	self name: 'Scriptaculous-Tests-Components'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Scriptaculous-Tests-Components-lr.17.mcz'.	self info description: 'Functional and unit tests for the Scriptaculous-Components package.'.	self info category: 'Tests'.	self dependsOn: #('Scriptaculous-Components' 'Scriptaculous-Tests-Core' 'Seaside-Environment').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!ScriptaculousTestsCore	self name: 'Scriptaculous-Tests-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Scriptaculous-Tests-Core-lr.19.mcz'.	self info description: 'Functional and unit tests for the Scriptaculous-Core package.'.	self info category: 'Tests'.	self dependsOn: #('Scriptaculous-Core' 'Javascript-Tests-Core' 'Seaside-Component' 'Seaside-Environment').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'server adaptors'!SeasideAdaptorsComanche	self name: 'Seaside-Adaptors-Comanche'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Adaptors-Comanche-lr.16.mcz'.	self info description: 'Makes Seaside run on the Comanche HTTP server.'.	self info category: 'Server Adaptors'.	self dependsOn: #('Seaside-Squeak-Core' 'KomHttpServer').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'server adaptors'!SeasideAdaptorsSwazoo	self name: 'Seaside-Adaptors-Swazoo'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Adaptors-Swazoo-lr.6.mcz'.	self info description: 'Makes Seaside run on the Swazoo Web server (LGPL).'.	self info category: 'Server Adaptors'.	self dependsOn: #('Seaside-Squeak-Core' 'Seaside-Swazoo').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'core library'!SeasideCanvas	self name: 'Seaside-Canvas'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Canvas-lr.35.mcz'.	self info description: 'The mechanism of choice to generate valid and reusable XHTML markup.'.	self info category: 'Core Library'.	self dependsOn: #('Seaside-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'core library'!SeasideComponent	self name: 'Seaside-Component'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Component-lr.31.mcz'.	self info description: 'Stateful, reuseable components to encapsulate a small part of a page.'.	self info category: 'Core Library'.	self dependsOn: #('Seaside-Core' 'Seaside-Squeak-Continuation' 'Seaside-Canvas').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'core library'!SeasideCore	self name: 'Seaside-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Core-lr.352.mcz'.	self info description: 'The core of Seaside, required for all packages.'.	self info category: 'Core Library'.	self dependsOn: #('Seaside-Platform').	self action: self defaultAction.	self addAction: (self class named: 'Seaside-Squeak-Core') defaultAction! !!Seaside29Builder methodsFor: 'development'!SeasideDevelopment	self name: 'Seaside-Development'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Development-lr.53.mcz'.	self info description: 'Web-based development tools and debugging support.'.	self info category: 'Development'.	self dependsOn: #('Seaside-Environment').	self action: self defaultAction.	self addAction: (self class named: 'Seaside-Squeak-Development') defaultAction! !!Seaside29Builder methodsFor: 'core library'!SeasideEmail	self name: 'Seaside-Email'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Email-pmm.5.mcz'.	self info description: 'Contains convience classes for sending of emails and preventing header injections.'.	self info category: 'Core Library'.	self dependsOn: #('Seaside-Core').	self action: self defaultAction.	self addAction: (self class named: 'Seaside-Squeak-Email') defaultAction! !!Seaside29Builder methodsFor: 'core library'!SeasideEnvironment	self name: 'Seaside-Environment'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Environment-lr.36.mcz'.	self info description: 'Administrative tools, useful to have for productive and development environments.'.	self info category: 'Core Library'.	self dependsOn: #('Seaside-Core' 'Seaside-Component' 'Seaside-RenderLoop' 'Seaside-Session' 'Seaside-Canvas').	self action: self defaultAction.	self addAction: (self class named: 'Seaside-Squeak-Environment') defaultAction! !!Seaside29Builder methodsFor: 'examples'!SeasideExamples	self name: 'Seaside-Examples'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Examples-lr.8.mcz'.	self info description: 'Simple example applications and components.'.	self info category: 'Examples'.	self dependsOn: #('Seaside-Component' 'Seaside-Environment').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'core library'!SeasideHTML5	self name: 'Seaside-HTML5'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-HTML5-lr.5.mcz'.	self info description: 'Support for HTML 5 tags.'.	self info category: 'Core Library'.	self dependsOn: #('Seaside-Canvas').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'core library'!SeasideInternetExplorer	self name: 'Seaside-InternetExplorer'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-InternetExplorer-lr.4.mcz'.	self info description: 'Support for proprietary Internet Explorer functionality.'.	self info category: 'Core Library'.	self dependsOn: #('Seaside-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'core library'!SeasidePlatform	self name: 'Seaside-Platform'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Platform-lr.25.mcz'.	self info description: 'Utilities and platform dependendent classes for Seaside.'.	self info category: 'Core Library'.	self action: self defaultAction.	self addAction: (self class named: 'Seaside-Squeak-Continuation') defaultAction.	self addAction: (self class named: 'Seaside-Squeak-Platform') defaultAction! !!Seaside29Builder methodsFor: 'core library'!SeasideRenderLoop	self name: 'Seaside-RenderLoop'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-RenderLoop-lr.27.mcz'.	self info description: 'Defines the low-level rendering and callback processing functionality.'.	self info category: 'Core Library'.	self dependsOn: #('Seaside-Session' 'Seaside-Component').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'core library'!SeasideSession	self name: 'Seaside-Session'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Session-lr.61.mcz'.	self info description: 'Support for stateful and secure session handling.'.	self info category: 'Core Library'.	self dependsOn: #('Seaside-Core' 'Seaside-Squeak-Continuation').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'development'!SeasideSlime	self name: 'Seaside-Slime'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Slime-lr.25.mcz'.	self info description: 'Code critis for Seaside. Detects common types of bugs.'.	self info category: 'Development'.	self dependsOn: #('Seaside-Component' 'Seaside-Session' 'Refactoring-Core' 'Seaside-Canvas').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!SeasideSqueakContinuation	self name: 'Seaside-Squeak-Continuation'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Squeak-Continuation-lr.8.mcz'.	self dependsOn: #('Seaside-Squeak-Platform' 'Seaside-Platform').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!SeasideSqueakCore	self name: 'Seaside-Squeak-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Squeak-Core-lr.73.mcz'.	self dependsOn: #('Seaside-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!SeasideSqueakDevelopment	self name: 'Seaside-Squeak-Development'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Squeak-Development-lr.57.mcz'.	self dependsOn: #('Seaside-Development' 'Seaside-Squeak-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!SeasideSqueakEmail	self name: 'Seaside-Squeak-Email'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Squeak-Email-pmm.6.mcz'.	self info description: 'Squeak implementation classes for the package "Seaside-Email".'.	self dependsOn: #('Seaside-Email' 'Seaside-Squeak-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!SeasideSqueakEnvironment	self name: 'Seaside-Squeak-Environment'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Squeak-Environment-jf.22.mcz'.	self dependsOn: #('Seaside-Environment' 'Seaside-Squeak-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!SeasideSqueakPlatform	self name: 'Seaside-Squeak-Platform'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Squeak-Platform-lr.29.mcz'.	self dependsOn: #('Seaside-Platform').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!SeasideSwazoo	self name: 'Seaside-Swazoo'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29LGPL/Seaside-Swazoo-lr.8.mcz'.	self info description: 'A small set of Swazoo 2 extensions to make it run Seaside'.	self dependsOn: #('Swazoo' 'Seaside-Platform').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsAdaptorsComanche	self name: 'Seaside-Tests-Adaptors-Comanche'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Adaptors-Comanche-pmm.4.mcz'.	self info description: 'Unit tests for the package Seaside-Adaptors-Comanche.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-Adaptors-Comanche' 'Seaside-Tests-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsCanvas	self name: 'Seaside-Tests-Canvas'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Canvas-lr.10.mcz'.	self info description: 'Unit tests for the package Seaside-Canvas.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-Canvas' 'Seaside-Tests-Core' 'Seaside-Session').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsColor	self name: 'Seaside-Tests-Color'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Color-pmm.7.mcz'.	self info description: 'Contains unit tests for Smalltalk dialects that have a Color class. Tests how well this class integrates into Seaside.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-Tests-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsComponent	self name: 'Seaside-Tests-Component'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Component-lr.15.mcz'.	self info description: 'Unit tests for the package Seaside-Component.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-Component' 'Seaside-Tests-Core' 'Seaside-Session').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsCore	self name: 'Seaside-Tests-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Core-lr.30.mcz'.	self info description: 'Unit tests for the package Seaside-Core.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-Core' 'Seaside-Tests-Platform' 'Seaside-Canvas').	self action: self defaultAction.	self addAction: (self class named: 'Seaside-Tests-Squeak-Core') defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsDevelopment	self name: 'Seaside-Tests-Development'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Development-lr.20.mcz'.	self info description: 'Unit tests for the package Seaside-Development.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-Development' 'Seaside-Tests-Environment').	self action: self defaultAction.	self addAction: (self class named: 'Seaside-Tests-Squeak-Development') defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsEmail	self name: 'Seaside-Tests-Email'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Email-pmm.5.mcz'.	self info description: 'Unit tests for the package Seaside-Email.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-Email' 'Seaside-Tests-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsEnvironment	self name: 'Seaside-Tests-Environment'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Environment-lr.8.mcz'.	self info description: 'Unit tests for the package Seaside-Environment.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-Environment' 'Seaside-Tests-Component' 'Seaside-Tests-RenderLoop' 'Seaside-Tests-Session' 'Seaside-Tests-Canvas').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsFunctional	self name: 'Seaside-Tests-Functional'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Functional-lr.40.mcz'.	self info description: 'Functional Seaside test suite.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-Environment' 'Seaside-Tests-Core').	self action: self defaultAction.	self addAction: (self class named: 'Seaside-Tests-Squeak-Functional') defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsHTML5	self name: 'Seaside-Tests-HTML5'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-HTML5-lr.10.mcz'.	self info description: 'Unit tests for the package Seaside-HTML5.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-HTML5' 'Seaside-Tests-Functional').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsInternetExplorer	self name: 'Seaside-Tests-InternetExplorer'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-InternetExplorer-lr.5.mcz'.	self info description: 'Unit tests for the package Seaside-InternetExplorer.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-InternetExplorer' 'Seaside-Tests-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsPlatform	self name: 'Seaside-Tests-Platform'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Platform-jgf.23.mcz'.	self info description: 'Unit tests for the package Seaside-Platform.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-Platform').	self action: self defaultAction.	self addAction: (self class named: 'Seaside-Tests-Squeak-Platform') defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsRenderLoop	self name: 'Seaside-Tests-RenderLoop'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-RenderLoop-lr.6.mcz'.	self info description: 'Unit tests for the package Seaside-RenderLoop.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-RenderLoop' 'Seaside-Tests-Session').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsSession	self name: 'Seaside-Tests-Session'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Session-pmm.7.mcz'.	self info description: 'Unit tests for the package Seaside-Session.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-Session' 'Seaside-Tests-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'tests'!SeasideTestsSlime	self name: 'Seaside-Tests-Slime'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Slime-lr.9.mcz'.	self info description: 'Unit tests for the package Seaside-Slime.'.	self info category: 'Tests'.	self dependsOn: #('Seaside-Slime' 'Seaside-Squeak-Development').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!SeasideTestsSqueakCore	self name: 'Seaside-Tests-Squeak-Core'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Squeak-Core-lr.8.mcz'.	self dependsOn: #('Seaside-Squeak-Core' 'Seaside-Tests-Core').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!SeasideTestsSqueakDevelopment	self name: 'Seaside-Tests-Squeak-Development'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Squeak-Development-lr.7.mcz'.	self dependsOn: #('Seaside-Squeak-Development' 'Seaside-Tests-Development').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!SeasideTestsSqueakFunctional	self name: 'Seaside-Tests-Squeak-Functional'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Squeak-Functional-pmm.6.mcz'.	self info description: 'Squeak specific functional Seaside test suite.'.	self dependsOn: #('Seaside-Tests-Functional').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!SeasideTestsSqueakPlatform	self name: 'Seaside-Tests-Squeak-Platform'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Seaside29/Seaside-Tests-Squeak-Platform-pmm.11.mcz'.	self info description: 'Unit tests for the package Seaside-Tests-Platform.'.	self dependsOn: #('Seaside-Squeak-Platform' 'Seaside-Tests-Platform').	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!Sport	self name: 'Sport'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/SPort/Sport-2.031.mcz'.	self action: self defaultAction! !!Seaside29Builder methodsFor: 'private'!Swazoo	self name: 'Swazoo'.	self version: '2.9.0-alpha2'.	self info url: 'http://www.squeaksource.com/Swazoo/Swazoo-2.2beta2.mcz'.	self dependsOn: #('Sport').	self action: self defaultAction! !!PackagesDevU commentStamp: 'kph 4/10/2008 07:17' prior: 0!Package definitions for this version as obtained automatically from the Universes server.To override the definitions in the univere add to my subclass in PackagesSqueak310To re-read the package definitions from the universes server.self taskGeneratePackageTasks run!!PackagesDev commentStamp: 'kph 4/20/2008 01:30' prior: 0!Most recent version stable version!!PackagesBeta commentStamp: 'kph 4/24/2008 17:47' prior: 0!When I say I apply to "all versions" I mean All versions with the level playing field!!If the version has + in it, then this task will run every time.If not then packages which are already provided are not reloaded.!!PackagesSqueak37U commentStamp: 'kph 4/10/2008 07:17' prior: 0!Package definitions for this version as obtained automatically from the Universes server.To override the definitions in the univere add to my subclass in PackagesSqueak37To re-read the package definitions from the universes server.self taskGeneratePackageTasks run!!PackagesSqueak37 commentStamp: 'kph 4/20/2008 01:30' prior: 0!Most recent version stable version!!Seaside29Builder commentStamp: 'test 1/2/2009 18:19' prior: 0!Generated from the seaside builder.seaside.st!"Packages-Library"!Installer mantis ensureFix: '7219 Streams Readability'. Installer mantis ensureFix: '7166 	speedup allSelectors add allSelectorsBelow'. Installer mantis ensureFix: '7272 BlockContext equality testing missing'. Installer squeaksource project: 'Sake'; install: 'Sake-Core'. Installer squeaksource project: 'Packages';   install: 'Sake-Packages';  install: 'Packages-Library'.!----End fileIn of a stream----!!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/14/2008 02:31'!buildDateStamp 	^ self status at: #date ifAbsent:[ self error: 'buildStampNow has never been called']	! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/14/2008 02:54'!buildDateStampString 	^ self buildDateStamp printYYMMDDHHSS: '-'. 		! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/14/2008 02:34'!buildNumber 	^ self status at: #build ifAbsent:['']	"	self buildNumber"! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/14/2008 02:26'!buildNumber: n		^ self status at: #build put: n! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/14/2008 02:30'!buildStampNow 	^ self status at: #date put: DateAndTime now 	! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/13/2008 17:49'!configIsSaving 	^ NetNameResolver localHostName =  'mercy.flat'! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 20:20'!fix: ref	"abbrev"	^ self isNextRelease ifTrue: [ self taskEnsureFix: ref ].! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 20:37'!fixEssential: ref	^ self taskEnsureFix: ref! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 20:56'!fixNotNeeded: ref	^ nil! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 20:59'!fixNotNeeded: ref fixedIn: aBlock	^ aBlock value! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 10/1/2008 02:36'!fixOneDay: ref	^ nil! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 18:29'!fixUnstable: ref	^ (self isNextRelease and: [ self isUnstable ]) 		ifFalse: [ nil ] ifTrue: [ self taskEnsureFix: ref ].! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 22:36'!fixesApplied	^ self selectors collect: [ :sel | (sel copyFrom: 2 to: 5) asNumber]! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 18:35'!isNextRelease	^ self name includesSubString: 'After'! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 8/29/2008 15:58'!isOnline"true means use Mantis bug scriptsfalse use saved bug scripts (not working yet)"^ true! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 18:21'!isStable	^ self isUnstable! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 18:18'!isUnstable	self withAllSuperclassesDo: [ :ea | (ea name includesSubString: 'Unstable') ifTrue: [ ^ true ] ].		^ false	! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 18:19'!isUpdate	^ self isNextRelease not! !!TasksRelease class methodsFor: 'waypoints' stamp: 'kph 12/9/2008 17:31'!isWaypointMissing: aSymbol	^ (self waypoints includes: aSymbol) not! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 8/29/2008 22:19'!mantisFieldsFrom: text	| rs fields key value |	rs := text readStream.	fields := Dictionary new.		[ rs atEnd ] whileFalse: [ 		key := rs upToAll: ': '.		key = 'Summary'		ifTrue: [ fields at: 'Summary' put: (rs upToAll: 'Description: ').			      key := 'Description'. ].			value := key = 'Description'		ifTrue: [ rs upToAll: 'Notes:' ]		ifFalse: [ rs upTo: Character cr ].		fields at: key put: value.	key = 'Description' ifTrue: [ ^ fields ].		].	self halt.! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 8/29/2008 15:59'!next ^ Smalltalk at: ('ReleaseAfter', (SystemVersion current majorMinorVersion copyWithout: $.)) asSymbol! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 8/29/2008 15:59'!nextUnstable ^ Smalltalk at: ('ReleaseAfter', (SystemVersion current majorMinorVersion copyWithout: $.), 'Unstable') asSymbol! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 8/29/2008 15:59'!nextUpdate ^ Smalltalk at: ('UpdateAfter', (SystemVersion current version copyWithout: $.)) asSymbol! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/13/2008 07:17'!packageInfoForMyTasks	^ PackageOrganizer default packageOfClass: self! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:25'!repositories	^ self selectors select: [ :ea | ea beginsWith: 'repository' ] thenCollect: [ :sel | self perform: sel ]! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/15/2008 00:02'!saveFileName	^ self buildDateStampString,'-', SystemVersion current version asString, '.image'! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 01:49'!setBackgroundColor 	| gf color version |		version := SystemVersion current version.color := Color r: 0.0 g: 0.658 b: 0.474. "green for final release"(version endsWith: '-unstable') ifTrue: [ color := Color r: 0.658 g: 0.0 b: 0.474 ]. "pink/red"(version endsWith: 'tc') ifTrue: [ color := Color yellow ]. "amber"(version endsWith: 'rc') ifTrue: [ color := Color r: 0.0 g: 0.0 b: 0.474 ]. "blue"(version endsWith: '-basic') ifTrue: [ color := Color r: 0.0 g: 0.0 b: 0.474 ]. "blue"(version endsWith: '-minimal') ifTrue: [ color := Color r: 0.0 g: 0.2 b: 0.474 ]. "blue"(version endsWith: '-full') ifTrue: [ color := Color r: 0.2 g: 0.0 b: 0.474 ]. "blue"gf := GradientFillStyle  ramp: {0.0->(Color r: 0.97 g: 0.98 b: 1.0) .1.0->(color)}.	gf	origin: 0 @ 0;		direction: 0@400;		normal: 640@0;		radial: false.World fillStyle: gf! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 18:26'!string: aBugRef			^ self fix: aBugRef! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 18:13'!suffix	^ self status at: #suffix ifAbsent: [ Utilities authorInitials ]! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 18:16'!suffix: str	^ self status at: #suffix put: str! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/12/2008 03:22'!suffixStatus	^ ''! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'auto 12/7/2008 07:04'!taskCleanUp	^  [				SmalltalkImage current cleanUpAll.				"(Object classPool at: #DependentsFields) size > 1 ifTrue: [self error:'Still have dependents']."				Smalltalk at: #Browser ifPresent:[:br| br initialize].				Project allSubInstancesDo:[:prj| prj == Project current ifFalse:[Project deletingProject: prj]].		 ]	! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/15/2008 22:01'!taskCleanUpAndSaveAs: filename	^ self define: [ :task |		task action: [				SmalltalkImage current cleanUpAllExcept: #(ChangeSet).			task author: '' during: [				SmalltalkImage current saveAs: filename.			].		]	].! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/14/2008 02:16'!taskDisplayReadMe	| w |		^ self action: [ 		w := Workspace openFile: 'Documentation/ReadMe-' , self suffix, '.text'.			w label: ('Welcome to... ', SystemVersion current asString).		w containingWindow 			position: (20@20);			extent: (400@500);			yourself.	]			! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/13/2008 01:10'!taskDocumentFixes	"document any fixes that have not already been documented"	^ self dependingOn: (			(Installer mantis fixesApplied difference: self fixesApplied) 				collect: [ :fix | self taskEnsureFix: fix ])! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 02:47'!taskEmptyRepositories	| |	^ self define: [ :task |				task action: [ 			MCWorkingCopy allManagers do: [ :ea | 				ea repositoryGroup initialize.		]]	]! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'test 12/29/2008 01:08'!taskEnsureFix: aFixString	| theBug theBugPage theBugScript fields selector cat |	^ self define: [ :task |				task info fixNumber: aFixString asNumber.							task action: [ 			"install the fix and record its details for posterity"			theBug := Installer mantis setBug: aFixString.			theBugPage := theBug report.			theBugScript := theBug script.				fields := self mantisFieldsFrom: theBugPage.									selector := fields at: 'Summary'.			selector :=  ('m', (selector copyFrom: 3 to: (selector size min: 40))) asLegalSelector asSymbol.			cat := (fields at: 'Status') ,'-' ,(fields at: 'Resolution').						self at: selector category: cat putMethod: theBugScript doc: theBugPage.						theBug ensureFix.		].	]! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/12/2008 03:24'!taskFinalize	^ self taskFinalize: self suffix, self suffixStatus! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 2/13/2009 04:23'!taskFinalize: suffix	^ [ 			self buildStampNow.			SystemVersion newVersion: self versionString,'-', suffix.			SystemVersion current date: Time now asDate.			Utilities setAuthorInitials: ''.			self setBackgroundColor. 	]! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 01:37'!taskGoGolden	^ self taskFinalize: '-basic'! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 05:51'!taskImportIntoKernelPackage: pkgName	"Migrate package into the main image"	| newCategory pkg |	^ self define: [ :task |				 		task dependsOn: { [PackageOrganizer default includesPackageNamed: pkgName] }. "load the package"				task action: [			pkg := PackageInfo named: pkgName. 			pkg extensionMethods do: [ :method |				newCategory := method category readStream upToAll: ('*', pkg name asLowercase ,'-'); upToAll: '-override'.				method actualClass organization classify: method methodSymbol under: newCategory.			].			pkg classes do: [ :theClass |				SystemOrganization classify: theClass name under: theClass destinationCategory.				theClass removeSelector: #destinationCategory.			].				]	].! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 02:57'!taskRepositoriesReset	^ self action: [					MCWorkingCopy allManagers do: [ :ea | 				ea repositoryGroup initialize.			].		MCRepositoryGroup default initialize. 	].! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 02:57'!taskRepositoriesTidy	| group myrepo |	^ self action: [ 			MCWorkingCopy allManagers do: [ :ea | 				myrepo := ea repository.				group := ea repositoryGroup 					initialize.									self repositories do: [ :repo | group add: repo ]. 				group addRepository: myrepo  ]	]! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/13/2008 03:28'!taskResetFixesAutoDocumentation	^ self action: {  ((SakeTask class: self) removeSelectorsMatching: '*') }		! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/14/2008 01:56'!taskSave: pkgInfo		^ pkgInfo manager taskSaveWithComment: 		(self configIsSaving 				ifTrue: [ 'saved by ', self class name ] 				ifFalse: [ nil ])! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/14/2008 02:34'!taskSave: pkgName rehomingIn: repo	"we link to the history of that already in the repo, so that the repo maintains a history"		| oldVersions wc comment |	^ self define: [ :task |				task if: [ (MCPackage named: pkgName) workingCopy needsSaving ] .  				task action: [					"findMostRecentInRepo, put that versionInfo into my history.				if none, keep the old history"								oldVersions := repo sortedVersionInfosAvailableForPackageNamed: pkgName.								wc := (MCPackage named: pkgName) workingCopy.										oldVersions ifNotEmpty: [ wc versionInfo: oldVersions first ].				    comment := 'Saved from ', self saveFileName .									self configIsSaving ifFalse: [ comment := nil. "prevents saving" ].									(wc taskAdoptHistoryFrom: repo saveWithComment: comment) run.						]	]! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 2/13/2009 02:28'!taskSaveAll	^ self define: [ :task |		 				task action: {		 			self taskSaveAll: self kernelPackages rehomingIn: self repository.					self taskSave: self packageNameForMyTasks.		}	]! !!TasksRelease class methodsFor: 'as yet unclassified' stamp: 'kph 12/13/2008 15:47'!taskSaveAll: packageNames rehomingIn: repo	^ self dependingOn: (packageNames collect: [ :p | self taskSave: p rehomingIn: repo ])! !!TasksRelease methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 22:16'!hashParts	^ { context receiver class. context selector. (self info fixNumber ifNil: [ args ]) }	 ! !"Tasks-Common"!!ProjectIdeas class methodsFor: 'as yet unclassified' stamp: 'kph 12/15/2008 22:02'!taskAlienSupport! !!ProjectIdeas class methodsFor: 'as yet unclassified' stamp: 'kph 12/22/2008 02:35'!taskChrisFixes! !!ProjectIdeas class methodsFor: 'as yet unclassified' stamp: 'kph 12/15/2008 22:05'!taskCurrentChangeSetName"	use a dynamic variable or notification of some kind that can be overridden in tests etc"! !!ProjectIdeas class methodsFor: 'as yet unclassified' stamp: 'kph 12/22/2008 02:36'!taskFileListToAPackage	"Make fileList into a package and share it with pharo	update with latest from pharo, see squeak-dev"! !!ProjectIdeas class methodsFor: 'as yet unclassified' stamp: 'kph 12/22/2008 02:37'!taskHarvestSqueakLight! !!ProjectIdeas class methodsFor: 'as yet unclassified' stamp: 'kph 12/15/2008 22:02'!taskMacMenusSupport! !!ProjectIdeas class methodsFor: 'as yet unclassified' stamp: 'kph 12/22/2008 02:37'!taskNewCompiler! !!ProjectIdeas class methodsFor: 'as yet unclassified' stamp: 'kph 12/15/2008 22:04'!taskPharoAuthorCompatability"	use a dynamic variable or notification of some kind that can be overridden in tests etc"! !!ProjectIdeas class methodsFor: 'as yet unclassified' stamp: 'kph 12/15/2008 22:05'!taskRefactorChangeSetsIntoAModule! !!ProjectIdeas class methodsFor: 'as yet unclassified' stamp: 'kph 12/15/2008 22:03'!taskRefactorSourceFilesIntoAModule! !!ProjectIdeas class methodsFor: 'as yet unclassified' stamp: 'kph 12/22/2008 02:37'!taskRemoveOldSocket! !!ProjectIdeas class methodsFor: 'as yet unclassified' stamp: 'kph 12/15/2008 22:03'!taskReplaceUnderscoresGlobally! !!ProjectIdeas class methodsFor: 'as yet unclassified' stamp: 'kph 12/15/2008 22:03'!taskUnderscoresInSelectors! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 15:54'!bobGO	"this is an example psuedo code of the calls that Bob would make"		| release |		TasksRelease nextUnstable taskBUILDCANDIDATE run.		TasksRelease nextUnstable taskFixes run.	"AutoGeneratedFixSchedule fixesAll run."		TasksRelease nextUnstable taskTESTCANDIDATE.	"save"		"when release = true"	release = true ifTrue: [ TasksRelease current taskRELEASECANDIDATE ].! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 11:28'!releaseCandidateTasksInstaller		^ Installer ss project: 'Tasks'; addPackage: 'Tasks-Squeak311'"self releaseCandidateTasksPackage install"! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:32'!repositoryOutputBC	^ MCHttpRepository				location: 'http://www.squeaksource.com/311bc'				user: ''				password: ''.	! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:34'!repositoryOutputRC	^ MCHttpRepository				location: 'http://www.squeaksource.com/311rc'				user: ''				password: ''.	! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:32'!repositorySubmissions	^ MCHttpRepository				location: 'http://www.squeaksource.com/311'				user: ''				password: ''.	! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/12/2008 03:23'!suffixStatus	^ '-prealpha'! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 22:33'!taskBugFixes	^ self define: [ :task |		task dependsOn: { 					self fixesMotherOfKernel.			self fixesMotherOfNetwork.			self fixesMotherOfDocumentation.			self fixesMotherOfUIMorphicCleanUp.			self fixesFromCroquet.			self fixesNicolasCellier.			self fixesMasashiUmezawa.			self fixesOthers.		} ]! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 9/1/2008 18:38'!taskCleanDeprecated	^ self define: [ :task |					task dependsOn: { 			'6866 Refs Stop CurrentProjectRefactoring Removal'.		}.						task action: [ 			Preferences noviceModeSettingChanged. "remove any old morphic key bindings"			Installer mc unload: '39Deprecated'.					]	].! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 9/1/2008 18:48'!taskCleanExcess	^ [			Installer mc unload: 'ReleaseBuilder'.			Installer mc unload: 'ScriptLoader'.			Installer mc unload: 'ToolBuilder-MVC'.			Installer mc unload: 'ToolBuilder-SUnit'.			Installer mc unload: 'OB-Standard'. "an empty project"		]! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 03:34'!taskCleanMiscellaneous	"thanks edgar"	"these could be removed through the deprecation process"	^ SakeTask define: [ :task |		task dependsOn: {					"Discards should be tasks and shouldnt clutter up SystemDictionary"				(self class: 'SystemDictionary') removeSelectorsMatching: 'discard*'.								"makeing a release is a task and shouldnt clutter up SystemDictionary"								(self class: 'SystemDictionary') removeSelectors: #(lastRemoval majorShrink zapMVCprojects		  makeExternalRelease makeInternalRelease zapAllOtherProjects computeImageSegmentation). 								"replaced with the more useful: Smalltalk globals explore from kernel-extensions"					(self class: 'SystemDictionary') removeSelector: #inspectGlobals.						(self class: 'ReleaseBuilder') removeSelector: #fixObsoleteReferences. 			(self class: 'ScriptLoader') removeSelector: #fixObsoleteReferences.						(self class: 'Morph') removeSelectors: #( reserveUrl: saveAsResource saveDocPane saveOnURL saveOnURL: saveOnURLbasic isTurtleRow objectViewed inATwoWayScrollPane).						(self class: 'PasteUpMorph') removeSelectors: #(playfieldOptionsMenu presentPlayfieldMenu allScriptEditors attemptCleanupReporting: modernizeBJProject scriptorForTextualScript:ofPlayer:).						(self class: 'Player') removeSelectors: #(isUniversalTiles noteDeletionOf:fromWorld: scriptorsForSelector:inWorld: tilesToCall: handMeTilesToFire).			(self class: 'TheWorldMainDockingBar') removeSelector: #hideAllViewersIn:.			(self class: 'WorldWindow class') removeSelectors: #(test1 test2).			(self class: 'PartsBin') removeSelector: #listDirection:quadList:buttonClass:.						"Found this in Installer sf project: 'inbox'; addPackage: 'Collections-dc.89' "			(self class: 'ReadWriteStream') removeSelector: #fileNameEndsWith:.						[				Player class removeCategory: 'turtles'. 				Player removeCategory: 'slots-user'.				Morph removeCategory: 'scripting'.					ColorType removeCategory: 'tiles'.				FileList2 class organization classify: #morphicViewOnDirectory: under: 'morphic ui'.				FileList2 class organization classify: #morphicView under: 'morphic ui'.			].		}.			].				   	 	  ! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/14/2008 02:16'!taskDisplayReadMe	| w |		^ self action: [ 		Installer ss project: '311'; install: 'Documentation'.		w := Workspace openFile: 'Documentation/ReadMe-' , self suffix, '.text'.			w label: ('Welcome to... ', SystemVersion current asString).		w containingWindow 			position: (20@20);			extent: (200@300);			yourself.	]			! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 02:01'!taskGenerate 	self deprecated: 'use taskTESTCANDIDATE'.	^ self taskTESTCANDIDATE! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 11:05'!taskKernelImports	^ self dependingOn: { 			Packages beta named: 'Kernel-Extensions'.				self taskImportIntoKernelPackage: 'Null'. 			self taskImportIntoKernelPackage: 'Kernel-Extensions'.			Packages beta named: 'ProcessSpecific'.				self taskImportIntoKernelPackage: 'ProcessSpecific'.	}! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 9/1/2008 18:39'!taskMarkNewlyDeprecated	^ self define: [ :task |						task action: [ 		]	].! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'test 1/13/2009 20:10'!taskReorganizeCategories	^ self define: [ :task |						task dependsOn: { 					"reorganize Kernel-Object"			self category: 'MorphicExtras-SqueakPage' 	classes: #ObjectOut.			self category: 'Kernel-Tracer' 				classes: #(ObjectTracer ObjectViewer).			 			self category: 'Kernel-Model' 				classes: #(Model DependantsArray MessageSend WeakMessageSend).			self category: 'Kernel-Model-Tests'			classes: #(DependentsArrayTest WeakMessageSendTest).			self category: 'Kernel-Objects'				classes: #(Null). "note: (Packages unload: 'Null) will stil remove it cleanly"			self category: 'Kernel-Classes'				classes: #SharedPool.									self category: 'CollectionsTests-Sequenceable'	classes: #SequenceableCollectionJoinSplitTest.			self category: 'Tools-Inspector-Tests' 			classes: #WeakSetInspectorTest.			self category: 'KernelTests-Chronology' 		classes: #DateAndTimeClockTest.							}.		task action: [   SystemOrganization removeEmptyCategories. SystemOrganization renameCategory: 'KernelTests-Chronology' toBe: 'Kernel-Chronology-Tests'. SystemOrganization renameCategory: 'KernelTests-Classes' toBe: 'Kernel-Classes-Tests'. SystemOrganization renameCategory: 'KernelTests-Methods' toBe: 'Kernel-Methods-Tests'. SystemOrganization renameCategory: 'KernelTests-Numbers' toBe: 'Kernel-Numbers-Tests'. SystemOrganization renameCategory: 'KernelTests-Objects' toBe: 'Kernel-Objects-Tests'. SystemOrganization renameCategory: 'KernelTests-Processes' toBe: 'Kernel-Processes-Tests'. SystemOrganization renameCategory: 'KernelTests-Contexts' toBe: 'Kernel-Contexts-Tests'. SystemOrganization renameCategory: 'CollectionsTests-Abstract' toBe: 'Collections-Abstract-Tests'. SystemOrganization renameCategory: 'CollectionsTests-Arrayed' toBe: 'Collections-Arrayed-Tests'. SystemOrganization renameCategory: 'CollectionsTests-Sequenceable' toBe: 'Collections-Sequenceable-Tests'. SystemOrganization renameCategory: 'CollectionsTests-SkipLists' toBe: 'Collections-SkipLists-Tests'. SystemOrganization renameCategory: 'CollectionsTests-Stack' toBe: 'Collections-Stack-Tests'. SystemOrganization renameCategory: 'CollectionsTests-Streams' toBe: 'Collections-Streams-Tests'. SystemOrganization renameCategory: 'CollectionsTests-Support' toBe: 'Collections-Support-Tests'. SystemOrganization renameCategory: 'CollectionsTests-Text' toBe: 'Collections-Text-Tests'. SystemOrganization renameCategory: 'CollectionsTests-Unordered' toBe: 'Collections-Unordered-Tests'. SystemOrganization renameCategory: 'CollectionsTests-Weak' toBe: 'Collections-Weak-Tests'.    SystemOrganization renameCategory: 'GraphicsTests-Primitives' toBe: 'Graphics-Primitives-Tests'. SystemOrganization renameCategory: 'GraphicsTests-Text' toBe: 'Graphics-Text-Tests'. SystemOrganization renameCategory: 'GraphicsTests-Files' toBe: 'Graphics-Files-Tests'.  SystemOrganization renameCategory: 'MorphicTests-Basic' toBe: 'Morphic-Basic-Tests'. SystemOrganization renameCategory: 'MorphicTests-Kernel' toBe: 'Morphic-Kernel-Tests'. SystemOrganization renameCategory: 'MorphicTests-Text Support' toBe: 'Morphic-Text Support-Tests'. SystemOrganization renameCategory: 'MorphicTests-Widgets' toBe: 'Morphic-Widgets-Tests'. SystemOrganization renameCategory: 'MorphicTests-Worlds' toBe: 'Morphic-Worlds-Tests'. SystemOrganization renameCategory: 'NetworkTests-Kernel' toBe: 'Network-Kernel-Tests'. SystemOrganization renameCategory: 'NetworkTests-Protocols' toBe: 'Network-Protocols-Tests'. SystemOrganization renameCategory: 'NetworkTests-RFC822' toBe: 'Network-RFC822-Tests'. SystemOrganization renameCategory: 'NetworkTests-UUID' toBe: 'Network-UUID-Tests'. SystemOrganization renameCategory: 'NetworkTests-Url' toBe: 'Network-Url-Tests'. SystemOrganization renameCategory: 'NetworkTests-URI' toBe: 'Network-URI-Tests'. SystemOrganization renameCategory: 'SystemChangeNotification-Tests' toBe: 'System-Change Notification-Tests'.   SystemOrganization classifyAll: #(AbstractMediaEventMorph ColorSwatch) under: 'MorphicExtras-AdditionalSupport'. SystemOrganization removeCategoriesMatching: 'UserObjects'.			 SystemOrganization sortCategories.			]	].! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 01:56'!taskReorganizePackages	^ self define: [ :task |						task action: [    (MCPackage named: 'Kernel') workingCopy package name: 'Kernel.impl'. (MCPackage named: 'KernelTests') workingCopy package name: 'Kernel.test'. (MCPackage named: 'Collections') workingCopy package name: 'Collections.impl'. (MCPackage named: 'CollectionsTests') workingCopy package name: 'Collections.test'. (MCPackage named: 'Graphics') workingCopy package name: 'Graphics.impl'. (MCPackage named: 'GraphicsTests') workingCopy package name: 'Graphics.test'. (MCPackage named: 'Morphic') workingCopy package name: 'Morphic.impl'. (MCPackage named: 'MorphicTests') workingCopy package name: 'Morphic.test'. (MCPackage named: 'Network') workingCopy package name: 'Network.impl'. (MCPackage named: 'NetworkTests') workingCopy package name: 'Network.test'.   (MCPackage named: 'Exceptions') workingCopy package name: 'Exceptions.impl'. (MCPackage named: 'Exceptions.test') workingCopy. (MCPackage named: 'Files') workingCopy package name: 'Files.impl'. (MCPackage named: 'Files.test') workingCopy. (MCPackage named: 'Files') workingCopy package name: 'Files.impl'. (MCPackage named: 'Files.test') workingCopy. (MCPackage named: 'ST80') workingCopy package name: 'ST80.impl'. (MCPackage named: 'ST80.test') workingCopy. (MCPackage named: 'Compiler') workingCopy package name: 'Compiler.impl'. (MCPackage named: 'Compiler.test') workingCopy. (MCPackage named: 'System') workingCopy package name: 'System.impl'. (MCPackage named: 'System.test') workingCopy. (MCPackage named: 'Tools') workingCopy package name: 'Tools.impl'. (MCPackage named: 'Tools.test') workingCopy. (MCPackage named: 'Traits') workingCopy package name: 'Traits.impl'. (MCPackage named: 'Traits.test') workingCopy. "pull outs" (MCPackage named: 'Kernel-Tracer') workingCopy.  MCWorkingCopy registry rehash.  				]	].! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'test 1/13/2009 20:28'!taskTESTCANDIDATE	^ self define: [ :task |						task dependsOn: { self taskBuildCandidate }.				task action: {			self taskUpgradePackages.			self taskKernelImports.  "in BC?"		"			self taskBugFixes.			self taskDocumentFixes.	 		"			self taskReorganizeCategories.  			self taskReorganizePackages.			self taskCleanDeprecated.			self taskCleanMiscellaneous.			self taskMarkNewlyDeprecated.						self taskCleanExcess.			self taskCleanUp.						self taskFinalize.			 		}.		 	].! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 15:53'!taskTestCandidate		"protected from being repeated by a waypoint"	^ self define: [ :task |							task if: [ self isWaypointMissing: #testCandidate ].		task action: {			self taskTESTCANDIDATE.						[ self markWaypoint: #testCandidate ].			 		}.		 	].! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 04:15'!taskTidyRepositories			^ [		| removeList rs |				removeList := #(	'http://source.squeakfoundation.org/39a' 						'http://source.impara.de/mc'						'http://source.wiresong.ca/mc/' ).				rs := MCRepositoryGroup default repositories.  		rs := rs select: [ :r | removeList includes: r description ].								rs do: [ :ea |  MCRepositoryGroup default removeRepository: ea ].				MCWorkingCopy allManagers do: [ :wc |						rs do: [ :ea |  wc repositoryGroup removeRepository: ea ].		]	]! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'test 1/13/2009 20:29'!taskUpgradePackages	^ {						Packages current named: 'Nebraska'.			Packages current named: 'MorphicBooks'.	} asTask ! !!ReleaseAfterSqueak310 class methodsFor: 'as yet unclassified' stamp: 'kph 9/1/2008 17:22'!versionString	^ 'Squeak3.11'.! !!ReleaseAfterSqueak310kph class methodsFor: 'as yet unclassified' stamp: 'kph 9/2/2008 04:42'!taskPackageUpgrades	^ self define: [ :task |			task action: [ 			"mc goes atomic"			Installer ss project: 'SystemEditor'; install: 'SystemEditor'.			Preferences setPreference: #useMonticelloAtomicLoader toValue: true.						Installer ss project: 'Testing'; installQuietly: 'SUnit' ; install: 'SUnitGUI'.			Installer ss project: 'XMLSupport'; install: 'XML-Parser-mir.9'.			Installer ss project: 'universes'; install: 'Universes'. 			Installer ss project: 'ToolBuilder';							addPackage: 'ToolBuilder-Kernel';							addPackage: 'ToolBuilder-Morphic';							addPackage: 'ToolBuilder-MVC';							addPackage: 'ToolBuilder-SUnit';							install.			Installer goran project: ''; installQuietly: 'SMBase'; installQuietly: 'SMLoader'.		]	].! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 12/12/2008 03:28'!kernelPackages	^ #('Sound' 'Files' 'Graphics' 'SystemChangeNotification' 'EToys' 'SystemChangeNotification-Tests' 'FlexibleVocabularies' 'Tests' 'VersionNumber' 'Compiler' 'NetworkTests' 'Traits' 'ST80' 'PreferenceBrowser' 'System' 'MorphicTests' '39Deprecated' 'Multilingual' 'Balloon' 'Network' 'Compression' 'Services-Base' 'TrueType' 'MorphicExtras' 'Morphic' 'Kernel' 'Exceptions' 'KernelTests' 'Nebraska' 'ToolBuilder-SUnit' 'ToolBuilder-Morphic' 'Protocols' 'Collections' 'ToolBuilder-MVC' 'ToolBuilder-Kernel' 'GraphicsTests' 'CollectionsTests' 'ScriptLoader' 'Tools')! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 12/13/2008 07:17'!packageNameForMyTasks	^ PackageOrganizer default packageOfClass: self! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 2/13/2009 04:31'!repository	^ MCHttpRepository				location: 'http://www.squeaksource.com/310build'				user: ''				password: ''.	! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 12/12/2008 23:20'!repositoryInputBC	^ MCHttpRepository				location: 'http://www.squeaksource.com/310bc'				user: ''				password: ''.	! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 2/13/2009 04:22'!suffix	^ 'build'! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 12/12/2008 03:21'!suffixStatus	^ '-beta'! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 12/16/2008 12:31'!taskBUILD	"starting with 3.10 or 3.10.2 get the image into a known state for fixes to be applied"	"	self taskBUILD runStepping. 	"	^ self define: [ :task |				task author: 'auto'.				task action: {						self taskResetFixesAutoDocumentation.					[ Transcript open ].					self taskRemoveItemFromTools: 'Package Loader'.			self taskRemoveItemFromTools: 'Package Loader'.			self taskSetPreferences. 						"self taskGoAtomic."					self taskUpgradePackages.						self taskEssentialFixes.			self taskDocumentFixes. "so far"					self taskTidyPackageOrganizer.			self taskFinalize.		}	]! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 12/12/2008 03:18'!taskBuild		"protected from being repeated by a waypoint"	^ self waypoint: self taskBUILD.					! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 1/22/2009 01:24'!taskEssentialFixes	"there are some fixes loaded with LPF, here are some more"		^ self dependingOn: {				"proposer: keith"			"needed for SUnit to discover whether tests use the network"						" http://bugs.squeak.org/view.php?id=5706 "			self fixEssential: '5706 Need minimal socket stats'. 			"building and removing things will trip on this"			" http://bugs.squeak.org/view.php?id=6868 "			self fixEssential: '6868: System Navigation-#obsoleteBehaviours chokes on ProtoObjects'.			"heres one I have been asking for for 2 years!!"			self fixEssential: '6466 LazyListMorph-listChanged'.			self fixEssential: '5669 Workspace openFile: convenience method'.			self fixEssential: '7244 Image cleanUp methods'.						self fixEssential: '6980 SystemDictionary-recreateSpecialObjectsArray'.	}! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 12/12/2008 20:15'!taskGoAtomic	^ self define: [ :task |		task dependsOn: { Packages current named: 'SystemEditor' }.				task action: [ Preferences setPreference: #useMonticelloAtomicLoader toValue: true ].	]! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 12/14/2008 02:36'!taskMakeRelease	^ self action: {				[World removeAllMorphs.			  Flaps enableGlobalFlaps ].			self taskDisplayReadMe.			 			self taskCleanUpAndSaveAs:  self saveFileName. 	}.	! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 12/13/2008 04:19'!taskRemoveItemFromTools: aToolName	"thanks edgar"	| partBins aButton |	^ self action: [	 			aButton := SimpleButtonMorph new label: 'Tools'.			aButton actWhen: #buttonDown.			partBins := OrderedCollection new.			(Flaps globalFlapTabWithID: 'Objects') ifNotNilDo: [ :objFl |				objFl referent showCategory: 'Tools' fromButton: aButton.				partBins add: (objFl referent submorphs at: 1).			].			(Flaps globalFlapTabWithID: 'Tools') ifNotNilDo: [ :objFl |				partBins add: objFl referent.			].						partBins do: [ :bin |				(bin submorphThat: [:any| (any arguments at: 2) = aToolName ] ifNone: [ nil ])					ifNotNilDo: [ :unwantedMorph | unwantedMorph delete ].			].		].! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 12/12/2008 00:23'!taskSetPreferences	^ self define: [ :task | 		task action: [ 			 #(                (mvcProjectsAllowed false)                (annotationPanes true)                (scrollBarsNarrow false)                (dismissAllOnOptionClose true)                (readDocumentAtStartup true)   ) do: [:spec| Preferences setPreference: spec first toValue: spec last]. "Workaround for bug" Preferences enable: #readDocumentAtStartup. Display newDepth: 32.		]	].! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 12/13/2008 22:03'!taskTidyPackageOrganizer	^ [		PackageOrganizer default unregisterPackageNamed: 'Morphic-CandidatesForGo'.		PackageOrganizer default unregisterPackageNamed: 'ToolBuilder'.		PackageOrganizer default unregisterPackageNamed: 'MonticelloConfigurations'.		PackageOrganizer default unregisterPackageNamed: 'Installer'.		PartsBin removeSelector: #listDirection:quadList:buttonClass:.		PackageOrganizer default unregisterPackageNamed: 'BabySRE'.	].! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'test 1/13/2009 22:37'!taskUpgradePackages	^ {				[ 				(Packages current named: 'Monticello15') addToPackageInfo.				(Packages current named: 'Sake') addToPackageInfo.				(Packages current named: 'Packages') addToPackageInfo.				 			].					Packages current named: 'SUnitGUI-improved'.			Packages current named: 'Universes'.			Packages current named: 'SqueakMap2 loader'.			Packages current named: 'Nebraska'.			Packages current named: 'MorphicBooks'.	} asTask ! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 12/13/2008 07:15'!tasksPackageName	^ 'Tasks-Squeak310'! !!Squeak310MakeBuildCandidate class methodsFor: 'as yet unclassified' stamp: 'kph 12/12/2008 03:49'!versionString	^ 'Squeak3.10.2'! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-fixed' stamp: 'auto 2/13/2009 04:28'!m05669WorkspaceopenFileconvenienceInstaller mantis bug: 5669 fix: 'M5669-Workspace-openFile.2.cs'.""""""Bug ID: 0005669Category: [Squeak] ToolsSeverity: featureReproducibility: alwaysDate Submitted: 12-23-06 06:21Date Updated: 01-09-09 23:31Reporter: Keith_HodgesView Status: publicHandler: Priority: normalResolution: fixedStatus: resolvedProduct Version: Summary: 0005669: Workspace openFile: convenience methodDescription: There is no convenience method for opening a workspace on text.Nor is there a way of saving a file such that it opens a workspace.And Workspace always adds '.text' to the name even if it already has itAdditional Information: Notes: (0008755 - 397 - 469 - 469 - 697 - 697 - 697)wiz	12-25-06 08:46See 0002993 and the recomplaint #4656.You can actually ask to put a file in a workspace thusly:In a file list read a text file. Using the menu (from the text pane)select read text into workspace.The problem is in 3.9 it doesn't quite work. and the fix in 0002993 never got in nor was a substitute fix ever created.The fix AFAIK works quite well.Yours in service, --Jerome Peace(0008756 - 43 - 43 - 43 - 43 - 43 - 43)Keith_Hodges	12-25-06 22:21But there are STILL no convenience methods.(0008757 - 631 - 719 - 719 - 719 - 719 - 719)wiz	12-26-06 01:51Cool, I piped up because I knew some things that were relevant.What do you mean by convenience methods?What do you see. And where do you see it being?In other words, in positive terms, what is the users story?The complaint here may make perfect sense to you. But how is the reader to understand what you mean? Please don't assume I have the same body of knowledge or vocabulary as you. In truth this is the first time I've come across the term "convenience methods" and I am totally at sea (i.e. pretty dang ignorant) as to what special meaning that has in this context.Yours in curiosity, -- Jerome Peace(0011294 - 163 - 205 - 205 - 205 - 205 - 205)Keith_Hodges	10-10-07 23:03ok exampleA := Workspace open.is A useful for addressing the workspace?A := Workspace withContents: 'test'.A := Workspace fromFile: 'test.txt'. etc(0011305 - 430 - 496 - 496 - 496 - 496 - 496)wiz	10-12-07 04:39Hi Keith, Your examples start to get there. What I really want to see is the user story in the formcontext: I wanted to do this( where you descirbe this generally and specifially enough that you give the reader of what you want)problem: Why this can't be done yetsolution: Add these methods to here and its done. (Be inclusive of most all you want done.)Then later you or others can upload the solution code.(0011988 - 344 - 356 - 356 - 356 - 356 - 356)kbrown	04-10-08 05:04Here's an example of how to read text from a file into an appropriately named Workspace so you can use the Workspace windowbar menu to save the contents of the Workspace back into the same file easily.(SHWorkspace new openLabel: 'myWorkspace') contents: ((FileStream fileNamed: 'myWorkspace.text') contentsOfEntireFile); changed: #contents.(0012842 - 90 - 134 - 134 - 134 - 134 - 134)Keith_Hodges	12-11-08 16:49edited on: 12-18-08 02:01	"fix begin"Installer mantis bug: 5669 fix: 'M5669-Workspace-openFile.2.cs'."fix end"(0012843 - 65 - 71 - 71 - 71 - 71 - 71)Keith_Hodges	12-11-08 17:42w := Workspace openFile: 'Readme.txt'.w label: 'Welcome to...'.(0012846 - 153 - 187 - 187 - 187 - 187 - 187)Keith_Hodges	12-13-08 01:47edited on: 12-15-08 20:31	Included Workspace-openFile.1.cs in 081214-0249-Squeak3.10.2bc-betaWorkspace-openFile.2.cs - adds "open..." menu item to provide a file opening UI.(0012862 - 37 - 37 - 37 - 37 - 37 - 37)Keith_Hodges	12-18-08 02:00allow to cancel out of opening a fileFiles: #('Workspace-openFile.1.cs' 'Workspace-openFile.2.cs' 'M5669-Workspace-openFile.1.cs' 'M5669-Workspace-openFile.2.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/13/2009 04:27'!m05706NeedminimalsocketstatsInstaller mantis bug: 5706 fix: 'SocketStats.6.cs'."fix test"Installer mantis bug: 5706 fix: 'SocketStatsTest.2.cs'.""""""Bug ID: 0005706Category: [Squeak] NetworkSeverity: minorReproducibility: alwaysDate Submitted: 01-06-07 20:13Date Updated: 01-09-09 23:31Reporter: Keith_HodgesView Status: publicHandler: Keith_HodgesPriority: normalResolution: openStatus: resolvedProduct Version: 3.10Summary: 0005706: Need minimal socket statsDescription: There is no way to easily work out whether a particular block of code accessed the network. Simple StatsOpened and StatsClosed counters would solve this problem. This is needed to categorize tests that do make use of the network.Additional Information: Notes: (0008844 - 303 - 381 - 381 - 381 - 381 - 381)Keith_Hodges	01-06-07 20:15edited on: 01-10-07 13:03	The StatsOpened counter is incremented by #register: and StatsClosed is incremented by #unregister: Counters are reset on initial network initialization."fix begin"Installer mantis bug: 5706 fix: 'SocketStats.6.cs'."fix test"Installer mantis bug: 5706 fix: 'SocketStatsTest.2.cs'."fix end"Files: #('SocketStats.2.cs' 'SocketStatsTest.2.cs' 'SocketStats.3.cs' 'SocketStats.4.cs' 'SocketStatsTest.1.cs' 'SocketStats.5.cs' 'SocketStats.6.cs' 'SocketStats.1.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/13/2009 04:28'!m05851RefactorSmalltalkImagesaveAsInstaller mantis bug: 5851 fix: 'SmalltalkImage-M5851.3.cs'.""""""Bug ID: 0005851Category: [Squeak] KernelSeverity: featureReproducibility: alwaysDate Submitted: 01-29-07 01:58Date Updated: 01-09-09 23:31Reporter: Keith_HodgesView Status: publicHandler: Keith_HodgesPriority: normalResolution: openStatus: resolvedProduct Version: 3.10Summary: 0005851: Refactor SmalltalkImage saveAsDescription: Refactor SmalltalkImage-#saveAs to pull out the code that actually saves the image under a new name, into #saveAs: newNameRefactor some other methods that duplicate the use of the same code, to use #saveAs:Additional Information: Notes: (0009762 - 76 - 76 - 76 - 76 - 76 - 76)Keith_Hodges	02-14-07 12:14SmalltalkImage.2.cs ensures that the resuming flag is returned from #saveAs:(0012290 - 84 - 116 - 116 - 116 - 116 - 116)matthewf	06-10-08 04:35"fix begin"Installer mantis bug: 5851 fix: 'SmalltalkImage-M5851.3.cs'."fix end"(0012291 - 58 - 58 - 58 - 58 - 58 - 58)matthewf	06-10-08 04:35SmalltalkImage-M5851.3.cs removes an underscore assignment(0012851 - 183 - 207 - 207 - 207 - 207 - 207)Keith_Hodges	12-16-08 17:39edited on: 12-16-08 18:52	Currently the code doesnt work if the given filename doesnt have .image on the end, perhaps we should ensure that it does, or append it.Fixed in M5851-SmalltalkImage-saveAs.1.csFiles: #('SmalltalkImage.1.cs' 'SmalltalkImage-M5851.3.cs' 'M5851-SmalltalkImage-saveAs.1.cs' 'SmalltalkImage.2.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/13/2009 04:28'!m06086CannotuseCrLfFileStreamonInstaller mantis bug: 6086 fix: 'MultiByteFileStream-M6086.2.cs'.""""""Bug ID: 0006086Category: [Squeak] FilesSeverity: minorReproducibility: alwaysDate Submitted: 02-15-07 03:49Date Updated: 01-19-09 20:13Reporter: Keith_HodgesView Status: publicHandler: cdegrootPriority: normalResolution: openStatus: resolvedProduct Version: 3.9Summary: 0006086: Cannot use CrLfFileStream on '/dev/stdout'Description: In the process of #detectLineEndConvention a primitive fails trying to obtain the position of '/dev/stdout'.Additional Information: Notes: (0009824 - 83 - 115 - 115 - 115 - 115 - 115)Keith_Hodges	02-15-07 04:21"fix begin"Installer mantis bug: 6086 fix: 'MultiByteFileStream.1.cs'."fix end"(0009825 - 171 - 183 - 183 - 183 - 183 - 183)Keith_Hodges	02-15-07 04:23MultiByteFileStream.1.csenables user to explicitly specify the lineEndConvention as an argument to #wantsLineEndConversion: doing so bypasses #detectLineEndConvention.(0012927 - 174 - 218 - 218 - 218 - 218 - 218)matthewf	01-19-09 20:13The previous changeset had an underscore assignment, and so won't load in Croquet"fix begin"Installer mantis bug: 6086 fix: 'MultiByteFileStream-M6086.2.cs'."fix end"Files: #('MultiByteFileStream-M6086.2.cs' 'MultiByteFileStream.1.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/13/2009 04:27'!m06466LazyListMorphlistChagedfixuplInstaller mantis bug: 6466 fix:  'LazyListMorph-listChanged.st'.""""""Bug ID: 0006466Category: [Squeak] MorphicSeverity: minorReproducibility: alwaysDate Submitted: 05-06-07 15:02Date Updated: 01-09-09 23:31Reporter: Keith_HodgesView Status: publicHandler: Priority: normalResolution: openStatus: resolvedProduct Version: 3.9Summary: 0006466: LazyListMorph-listChaged fixuploaded to squeak-devDescription: This fixes the fact that some list morphs need to be resized in order to be used, this is particularly noticable in 3.9 buy opening a PackagePaneBrowser, the left hand list is not scrollable.Additional Information: Notes: (0010668 - 88 - 120 - 120 - 120 - 120 - 120)Keith_Hodges	05-06-07 15:03"fix begin"Installer mantis bug: 6466 fix: 'LazyListMorph-listChanged.st'."fix end"(0010669 - 427 - 475 - 475 - 475 - 475 - 475)wiz	05-06-07 20:54Hi Keith,Tried it. Fix works for PackagePaneBrowsers.I did notice that the fileout uses unix line endings (lfs) which made the source look like it was all on one line on my Mac.I am also wondering what an appropriate test would be. Genning up a package browser and mucking around in its package list looking at scrollbars would seem to be excessive. I wonder if there is an easier way to demostrate the problem.(0010670 - 11 - 11 - 11 - 11 - 11 - 11)KenCausey	05-07-07 18:24categorized(0012845 - 41 - 41 - 41 - 41 - 41 - 41)Keith_Hodges	12-13-08 01:39uploaded file has had lf problem resolvedFiles: #('LazyListMorph-listChanged.st')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-fixed' stamp: 'auto 2/13/2009 04:27'!m06868SystemNavigationobsoleteBehavInstaller mantis bug: 6868 fix: 'SystemNavigation-obsoleteBehaviors.1.st'.""""""Bug ID: 0006868Category: [Squeak] SystemSeverity: minorReproducibility: alwaysDate Submitted: 01-21-08 22:30Date Updated: 01-10-09 03:42Reporter: Keith_HodgesView Status: publicHandler: Keith_HodgesPriority: normalResolution: fixedStatus: resolvedProduct Version: Summary: 0006868: SystemNavigation-#obsoleteBehaviours chokes on ProtoObjectsDescription: Traversing all objects in the system, breaks on ProtoObjects which do not implement #isBehaviorAdditional Information: Notes: (0011694 - 100 - 144 - 144 - 144 - 144 - 144)Keith_Hodges	01-21-08 22:36edited on: 01-22-08 11:37	"fix begin"Installer mantis bug: 6868 fix: 'SystemNavigation-obsoleteBehaviors.1.st'."fix end"(0011696 - 219 - 243 - 243 - 243 - 243 - 243)Keith_Hodges	01-22-08 00:01edited on: 01-22-08 11:08	SystemNavigation-obsoleteBehaviors.1.st is a reimplementation in terms of (obj inheritsFrom: Behavior)As an alternative ProtoObject-isBehavior.1.cs moves the implementation of isBehavior from Object to ProtoObjectFiles: #('SystemNavigation-obsoleteBehaviors.st' 'ProtoObject-isBehavior.1.cs' 'SystemNavigation-obsoleteBehaviors.1.st')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/13/2009 04:28'!m06980LoadingFFIkernelmakesNetNamInstaller mantis bug: 6980 fix: 'SystemDictionary-recreateSpecialObjectsArray-M6980.st'.""""""Bug ID: 0006980Category: [Squeak] FFISeverity: majorReproducibility: alwaysDate Submitted: 03-13-08 20:51Date Updated: 01-09-09 23:31Reporter: tbnView Status: publicHandler: andreasPriority: normalResolution: openStatus: resolvedProduct Version: 3.9Summary: 0006980: Loading FFI kernel makes NetNameResolver unresponsiveDescription: Image:  Squeak 3.10beta7159 and Squeak 3.9#7067VM:     Squeak 3.10.6 (from Aug 30, 2007) on Win VistaEvaluate:  NetNameResolver addressForName: 'www.squeaksource.com' timeout: 20this returns a ByteArray with the IP.After loading FFI 3.9.1 using Universe Browser the above code does notreturn. (you can only break using cmd-dot)This starts to happen directly after FFI-Kernel-ar-8.mcz is loadedvia install script from source.squeakfoundation.org/FFI(with FFI-Kernel-ar7.mcz leads to the same problem)When loading FFI-Kernel-ar6.mcz it works as expected - the IP is instantly returned. So the problem seems to depend on the change from version 6 to 7.Tested on a Squeak3.9 and Squeak3.10 image (see above)  Additional Information: Notes: (0011918 - 1791 - 2208 - 2208 - 2208 - 2208 - 2208)andreas	03-14-08 01:26How does one recreate that problem? I got stuck when trying to "update list from network" with UPackage>>decodeFromXMLElement: so I can't investigate the problem (stack below).UndefinedObject(Object)>>doesNotUnderstand: #contentsUPackage class>>getXMLPartNamed:from:UPackage class>>decodeFromXMLElement:[] in UPackage class>>decodePackagesFromXMLStream: {[:element | self decodeFromXMLElement: element]}- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -OrderedCollection>>collect:UPackage class>>decodePackagesFromXMLStream:UStandardUniverse>>updatePackagesViaWWW[] in UUniverseBrowser>>requestPackageList {[universe updatePackagesViaWWW]}[] in Utilities class>>informUser:during: {[aBlock value]}MVCMenuMorph>>displayAt:during:Utilities class>>informUser:during:UUniverseBrowser>>requestPackageListPluggableButtonMorph>>performAction[] in PluggableButtonMorph>>mouseUp: {[:m | (m containsPoint: evt cursorPoint) ifTrue: [m performAction]]}Array(SequenceableCollection)>>do:PluggableButtonMorph>>mouseUp:PluggableButtonMorph(Morph)>>handleMouseUp:MouseButtonEvent>>sentTo:PluggableButtonMorph(Morph)>>handleEvent:PluggableButtonMorph(Morph)>>handleFocusEvent:[] in HandMorph>>sendFocusEvent:to:clear: {[ActiveHand := self. ActiveEvent := anEvent. result := focusHolder han...]}[] in PasteUpMorph>>becomeActiveDuring: {[aBlock value]}BlockContext>>on:do:PasteUpMorph>>becomeActiveDuring:HandMorph>>sendFocusEvent:to:clear:HandMorph>>sendEvent:focus:clear:HandMorph>>sendMouseEvent:HandMorph>>handleEvent:HandMorph>>processEvents[] in WorldState>>doOneCycleNowFor: {[:h | ActiveHand := h. h processEvents. capturingGesture := capturingGest...]}Array(SequenceableCollection)>>do:WorldState>>handsDo:(0011919 - 1131 - 1389 - 1785 - 1785 - 1785 - 1785)tbn	03-14-08 07:31Even if the help -> about tells me "Squeak 3.10beta7159" as version it's the gamma package I downloaded.Please try: http://ftp.squeak.org/3.10alpha/Squeak3.10.gamma.7159.zip [^] andmake sure to use the image in a new directory.Steps I've done and that worked to reproduce: 1. World menu "Open" -> "Universe Browser Basic"2. Button "Update list from network"3. Select "System" and "FFI version 3.9.1" in the tree 4. Select "Select package" and "Install selections"If you have a problem with package universe browser again we should open another issue.However, the universe browser points to http://map.squeak.org/accountbyid/cf58c358-46ee-465e-b6db-2740e9b32a53/files/InstallFFI3.st [^]a simple script loading FFI-Kernel-ar-8.mcz first and then other packages.To reproduce you can also just add source.squeakfoundation.org/FFI asHTTP repo to Monticello and load FFI-Kernel-ar-8.mcz manually. After thatthe NetNameResolver addressForName: 'www.squeaksource.com' timeout: 20does not return anymore.If you load FFI-Kernel-ar6.mcz manually it still works as before loading the FFI Kernel.(0011962 - 718 - 932 - 1136 - 1136 - 1136 - 1136)tbn	03-27-08 21:27Andreas commented at http://lists.squeakfoundation.org/pipermail/squeak-dev/2008-March/127208.html [^]Yeah, I had forgotten about the problem. The issue comes from a call to Smalltalk>>recreateSpecialObjectsArray (which is required for the FFI to work correctly) and which accidentally nukes the external semaphore table. The fix is simple: Replace the following line in SystemDictionary>>recreateSpecialObjectsArraynewArray at: 39 put: Array new.by"Preserve external semaphores when recreating splObjs"newArray at: 39 put: (self specialObjectsArray at: 39).Also, saving and restarting the image after loading the FFI is good temporary workaround for this problem.Cheers,- Andreas(0012219 - 112 - 144 - 144 - 144 - 144 - 144)Keith_Hodges	05-29-08 15:43"fix begin"Installer mantis bug: 6980 fix: 'SystemDictionary-recreateSpecialObjectsArray-M6980.st'."fix end"Files: #('SystemDictionary-recreateSpecialObjectsArray-M6980.st')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/13/2009 04:28'!m07131SyntaxErrordialogsraisemoreInstaller mantis bug: 7131 fix: 'SyntaxErrorUsesNonInteractiveParser-M7131.1.cs'.""""""Bug ID: 0007131Category: [Squeak] CompilerSeverity: minorReproducibility: alwaysDate Submitted: 07-22-08 04:33Date Updated: 01-09-09 23:31Reporter: matthewfView Status: publicHandler: Priority: normalResolution: openStatus: resolvedProduct Version: Summary: 0007131: Syntax Error dialogs raise more errors than does the calling ParserDescription: A syntax error dialog is created to fix a very specific error in a non-interactive parser; however, it runs in interactive mode, so it rejects code that the calling parser would have accepted. The syntax error dialog should accept exactly the same code as the calling parser would have - no more, no less.Additional Information: In non-interactive mode, the following errors prompt for user interaction in the form of a SyntaxError dialog:- Syntax errorIn interactive mode, the following errors cause user interaction in the form of pop-ups and text prompts:- Syntax error- Unknown global variable/local variable/selector- Changing some special selectorsNotes: (0012400 - 97 - 97 - 97 - 97 - 97 - 97)matthewf	07-22-08 04:34The attached change set makes SyntaxError dialogs compile in non-interactive mode, fixing the bug(0012401 - 105 - 137 - 137 - 137 - 137 - 137)matthewf	07-22-08 04:36"fix begin"Installer mantis bug: 7131 fix: 'SyntaxErrorUsesNonInteractiveParser-M7131.1.cs'."fix end"Files: #('SyntaxErrorUsesNonInteractiveParser-M7131.1.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/13/2009 04:28'!m07166speedupallSelectorsaddallSelInstaller mantis bug: 7166 fix: 'Speedup-AllSelectors-M7166.1.cs'.""""""Bug ID: 0007166Category: [Squeak] KernelSeverity: tweakReproducibility: alwaysDate Submitted: 08-27-08 21:43Date Updated: 01-09-09 23:31Reporter: Keith_HodgesView Status: publicHandler: Priority: normalResolution: openStatus: resolvedProduct Version: 3.10.2Summary: 0007166: speedup allSelectors add allSelectorsBelow:Description: Firstly #allSelectors inefficiently creates multiple intermediate collections. Refactoring this yields a 27% speed improvement. Secondly many users of #allSelectors forget that when applied to the class side it doesnt stop at ProtoObject class, it continues to Class ClassDescription, Behavior, Object and ProtoObject. This is catered for by adding #allSelectorsBelow:Magritte and SUnit are heavy users which benefit.Additional Information: Notes: (0012533 - 88 - 120 - 120 - 120 - 120 - 120)Keith_Hodges	08-27-08 21:44"fix begin"Installer mantis bug: 7166 fix: 'Speedup-AllSelectors-M7166.cs'."fix end"(0012702 - 141 - 141 - 141 - 141 - 141 - 141)Damien Cassou	09-28-08 14:01I've sent that fix to PharoInbox. I replaced 'withAllSuperclasses do:' by 'withAllSuperclassDo:' to avoid the creation of another collection.(0012703 - 283 - 343 - 343 - 343 - 343 - 343)Damien Cassou	09-28-08 14:47I also added the following test:testAllSelectorsself assert: ProtoObject allSelectors = ProtoObject selectors.self assert: Object allSelectors = (Object selectors union: ProtoObject selectors).self assert: (Object allSelectorsBelow: ProtoObject) = (Object selectors).(0012704 - 90 - 122 - 122 - 122 - 122 - 122)Damien Cassou	09-28-08 16:26"fix begin"Installer mantis bug: 7166 fix: 'Speedup-AllSelectors-M7166.1.cs'."fix end"Files: #('Speedup-AllSelectors-M7166.1.cs' 'Speedup-AllSelectors-M7166.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-fixed' stamp: 'auto 2/13/2009 04:28'!m07205MonticelloSnapshotSpeedupviaInstaller mantis bug: 7205 fix: 'MethodReference-category-M7205.2.cs'.""""""Bug ID: 0007205Category: [Squeak] MonticelloSeverity: tweakReproducibility: N/ADate Submitted: 10-04-08 17:14Date Updated: 01-09-09 23:31Reporter: matthewfView Status: publicHandler: matthewfPriority: normalResolution: fixedStatus: resolvedProduct Version: Summary: 0007205: Monticello Snapshot Speedup via new MethodReference ivarDescription: Adding the ivar 'category' to methodReference allows a 25% speedup in Monticello snapshotting, after source caching. This capability is exploited as of PackageInfo-Base-mtf.56Additional Information: Notes: (0012717 - 96 - 140 - 140 - 140 - 140 - 140)matthewf	10-04-08 17:21edited on: 10-05-08 04:57	"fix begin"Installer mantis bug: 7205 fix: 'MethodReference-category-M7205.2.cs'."fix end"(0012718 - 60 - 60 - 60 - 60 - 60 - 60)matthewf	10-05-08 04:58oops; the changeset didn't actually have the class def. oopsFiles: #('MethodReference-category-M7205.2.cs' 'MethodReference-category-M7205.1.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/13/2009 04:28'!m07218ClassOrganizercategoriesbreakInstaller mantis bug: 7218 fix: 'EmptyCategoryList-M7218.2.cs'.""""""Bug ID: 0007218Category: [Squeak] KernelSeverity: minorReproducibility: alwaysDate Submitted: 10-26-08 02:01Date Updated: 01-19-09 20:21Reporter: Keith_HodgesView Status: publicHandler: Priority: normalResolution: openStatus: resolvedProduct Version: 3.10.2Summary: 0007218: ClassOrganizer categories breaks if given an empty arrayDescription: ClassOrganizer categories: attempts to ensure that the list of categories matches the existing ones. However if the class has no methods/elements this test fails.So if you call categorizer with an empty array, on a class with no elements/methods the net result is that the data structure is corrupted.categoryStops gets set to #() when it should be at least #(0)Additional Information: Notes: (0012752 - 84 - 116 - 116 - 116 - 116 - 116)Keith_Hodges	10-26-08 02:19"fix begin"Installer mantis bug: 7218 fix: 'Categorizer-categories.st'."fix end"(0012753 - 71 - 71 - 71 - 71 - 71 - 71)Keith_Hodges	10-26-08 02:22SystemEditor was the culprit that calls categories: with an empty array(0012928 - 172 - 216 - 216 - 216 - 216 - 216)matthewf	01-19-09 20:21The previous changeset had an underscore assignment, and so won't load in Croquet"fix begin"Installer mantis bug: 7218 fix: 'EmptyCategoryList-M7218.2.cs'."fix end"Files: #('Categorizer-categories.st' 'EmptyCategoryList-M7218.2.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/13/2009 04:28'!m07219ImproveStreamsUsageReadabiliInstaller mantis bug: 7219 fix: 'Stream-Readability.4.cs'.""""""Bug ID: 0007219Category: [Squeak] CollectionsSeverity: featureReproducibility: alwaysDate Submitted: 11-02-08 01:20Date Updated: 01-09-09 23:31Reporter: Keith_HodgesView Status: publicHandler: Keith_HodgesPriority: normalResolution: openStatus: resolvedProduct Version: 3.10.2Summary: 0007219: Improve Streams Usage ReadabilityDescription: For making code gen more readableUsed in Sake/Pacakges and Css generation code for much improved readability.Additional Information: Part of what was Kernel-Extensions for 3.10/LPF. Is now no longer needed for LPF, but is needed for Sake.Notes: (0012758 - 159 - 221 - 221 - 221 - 221 - 221)Keith_Hodges	11-02-08 01:21edited on: 12-12-08 02:17	3 - has methods categorized4 - added ByteArray-putOn: which got away."fix begin"Installer mantis bug: 7219 fix: 'Stream-Readability.4.cs'."fix end"Files: #('Stream-Readability.2.cs' 'Stream-Readability.3.cs' 'Stream-Readability.4.cs' 'Stream-Readability.1.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/13/2009 04:28'!m07244ImagecleanUpmethodsInstaller mantis bug: 7244 fix: 'M7244-CleanUps.3.cs'.""""""Bug ID: 0007244Category: [Squeak] KernelSeverity: majorReproducibility: alwaysDate Submitted: 12-12-08 03:03Date Updated: 02-12-09 23:50Reporter: Keith_HodgesView Status: publicHandler: Priority: highResolution: openStatus: resolvedProduct Version: 3.10.2Summary: 0007244: Image cleanUp methodsDescription: Methods implementingSmalltalkImage current cleanUpAll. &SmalltalkImage current freeSpace.Additional Information: Notes: (0012844 - 80 - 124 - 124 - 124 - 124 - 124)Keith_Hodges	12-12-08 03:05edited on: 02-12-09 23:42	"fix begin"Installer mantis bug: 7244 fix: 'M7244-CleanUps.3.cs'."fix end"(0012850 - 239 - 281 - 281 - 281 - 281 - 281)Keith_Hodges	12-15-08 21:56edited on: 02-12-09 23:43	CleanUps.2.cs - adds cleanUpAllExcept: aListOfClassNamesM7244-CleanUps.1.cs - fix to cleanUpAllExceptM7244-CleanUps.2.cs - lots more from JohnM7244-CleanUps.3.cs - May load into 3.9Fix intended for 3.10.2, included in 3.10.2-bc(0012960 - 54 - 54 - 54 - 54 - 54 - 54)Keith_Hodges	02-12-09 23:41Received complaint that this fix doesnt load in to 3.9Files: #('M7244-CleanUps.3.cs' 'M7244-CleanUps.2.cs' 'CleanUps.2.cs' 'M7244-CleanUps.1.cs' 'CleanUps.1.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-fixed' stamp: 'auto 2/13/2009 04:28'!m07272BlockContextequalitytestismInstaller mantis bug: 7272 fix: 'Block equality testing.1.cs'.""""""Bug ID: 0007272Category: [Squeak] KernelSeverity: minorReproducibility: alwaysDate Submitted: 01-21-09 14:56Date Updated: 01-21-09 15:36Reporter: Keith_HodgesView Status: publicHandler: Keith_HodgesPriority: normalResolution: fixedStatus: resolvedProduct Version: 3.10.2Summary: 0007272: BlockContext equality test is missingDescription: need #= and #hash, which are available in BlockClosureAdditional Information: Notes: (0012932 - 86 - 118 - 118 - 118 - 118 - 118)Keith_Hodges	01-21-09 14:57"fix begin"Installer mantis bug: 7272 fix: 'Block equality testing.1.cs'."fix end"(0012933 - 28 - 28 - 28 - 28 - 28 - 28)Keith_Hodges	01-21-09 14:58Will be included in 3.10.2bcFiles: #('Block equality testing.1.cs')! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:35'!fixesCategoryCollections	"Filter on 'Collections' category in Mantis"	^ self dependingOn: { 		" http://bugs.squeak.org/view.php?id=7242 "		self fixUnstable: '7242: Add Inplace Sort to OrderedCollection'.		self fix: '7219 Improve Streams Usage Readability'.				" http://bugs.squeak.org/view.php?id=6521 "		self fixUnstable: '6521: Target setting doesnt work for buttons and sliders'.		} ! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:35'!fixesCategoryCollectionsHmm	"Filter on 'Collections' category in Mantis"	"^ self dependingOn: { 		(self fix: 			'0007242: Add Inpace Sort to OrderedCollection').		(self date: '11-06-08'	fix:			'0007219: Improve Streams Usage Readability').		(self date: '09-16-08'	fixOneDay: 	'0007194: copyReplaceFrom:to:with: strange behavior with ill bounds').		(self date: '09-09-08'	fixUnstable:	'0007184: String>>asUnHtml use Character class>>nbsp, not Character class>>space').		(self date: '09-09-08'	fixUnstable:	'0007180: Interval method indexOf: / includes: incomplete fix in squeak3.10')							alsoFixes:	#(1602 1603).		(self date: '09-03-08'	fixUnstable:	'0007177: removeAll fails for Dictionaries'). 		(self date: '09-03-08'	fixUnstable:	'0007177: removeAll fails for Dictionaries'). 				(self fixUnstable: '0007175	1	Collections	minor	new	09-02-08	 CharacterSetComplement cannot printString').			(self fixUnstable: '6521: Target setting doesnt work for buttons and sliders').				(self date: '12-08-08'	fixNotNeeded: '0001603: [BUG][FIX] Interval method includes:')							fixedBy: 		'0007180: Interval method indexOf: / includes: incomplete fix in squeak3.10'.							(self date: '09-10-08'	fixNotNeeded: '0001602: [ENH] Interval method indexOf:'							fixedBy: 		'0007180: Interval method indexOf: / includes: incomplete fix in squeak3.10').							} "		"	"! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:35'!fixesFromCroquet	"https://lists.duke.edu/sympa/arc/croquet-dev/2007-05/msg00035.html"		^ self dependingOn: {}! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:35'!fixesKernelClasses		^ self dependingOn: {			 self fix: '7156 Behavior-initialize sends superclass: which can cause VM crash'.	 	}! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'test 1/10/2009 02:39'!fixesKernelStreams		^ self dependingOn: {		 	}! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:35'!fixesMasashiUmezawa	"Masashi Umezawa umejava@mars.dti.ne.jp"		"4 so far"	^ self dependingOn: { 				" http://bugs.squeak.org/view.php?id=6894 "		self fixUnstable: '6894 StartUpList order is broken due to the Delay patch'.		" http://bugs.squeak.org/view.php?id=6893 "		self fixUnstable: '6893 "Do it" log cannot be parsed if it includes leading spaces and multybyte string'.		" http://bugs.squeak.org/view.php?id=6892 "		self fixUnstable: '6892 Choosing default browser menu is not translated'.		" http://bugs.squeak.org/view.php?id=6861 "		self fixUnstable: '6861: Services menus/buttons are not translated'.		}  ! !!ManualFixesTemp class methodsFor: 'fixes - documentation' stamp: 'kph 12/10/2008 01:34'!fixesMotherOfDocumentation		^ self dependingOn: {				}! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:35'!fixesMotherOfFontIssues  		"Mother Page: http://bugs.squeak.org/view.php?id=6570 "	^ self dependingOn: {			self fixUnstable: '7071: Key values from Input Method are not converted correctly on new Unicode Windows VM'.	      		self fixUnstable: '7421 BDFFontReader doesnt call initialize'.	}! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:35'!fixesMotherOfIntervalIssues  		"Mother Page: http://bugs.squeak.org/view.php?id=7002 "	^ self dependingOn: { }! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:35'!fixesMotherOfKernel		^ self dependingOn: {			self fixesKernelChronology.		}! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:35'!fixesMotherOfMethodFinderIssues  		"Mother Page: http://bugs.squeak.org/view.php?id=7110 "	^ self dependingOn: { }! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:35'!fixesMotherOfNetwork		^ self dependingOn: {			self fix: '7199 Expose Socket timeout to ProtocolClients'. 		self fixUnstable: '7196 HTTPSocket User Agent hard-coded'.	 	}	 ! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:35'!fixesMotherOfRandomNumberGenerator	"Mother Page: http://bugs.squeak.org/view.php?id=7192 "	^ self dependingOn: { }! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:35'!fixesMotherOfRoundoffAndTruncationErrors.  		"Mother Page: http://bugs.squeak.org/view.php?id=7152 "	^ self dependingOn: { }! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:35'!fixesMotherOfUIAnnoyances	"Mother Page: http://bugs.squeak.org/view.php?id=6635 "	^ self dependingOn: { 			self fixEssential: '6466 LazyListMorph-listChanged'.			self fixUnstable: '7181 improve HandMorph>>shadowForm'.			self fixesMotherOfUITargeting.		} 		 ! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:36'!fixesMotherOfUIBalloonHelpIssues  		"Mother Page: http://bugs.squeak.org/view.php?id=6688 "	^ self dependingOn: { }! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:36'!fixesMotherOfUIGraphicalOffByOneReports	"Mother Page: http://bugs.squeak.org/view.php?id=6511 "	^ self dependingOn: { }! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:36'!fixesMotherOfUIMorphicCleanUp 	"Mother Page: http://bugs.squeak.org/view.php?id=6567 "	^ self dependingOn: { 			self fixesMotherOfUIMorphicWitler.	 		self fixesMotherOfUIAnnoyances.		 		self fixesMotherOfUIGraphicalOffByOneReports.			self fixesMotherOfUIBalloonHelpIssues.		} ! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:36'!fixesMotherOfUIMorphicWitler 	"Mother Page: http://bugs.squeak.org/view.php?id=6593 " 	^self dependingOn: { }! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:36'!fixesMotherOfUITargeting	"Mother Page: http://bugs.squeak.org/view.php?id=6530 "	^ self dependingOn: { 				" http://bugs.squeak.org/view.php?id=6521 "		self fixUnstable: '6521: Target setting doesnt work for buttons and sliders'.		} ! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:36'!fixesNicolasCellier	"nicolas cellier (nice) ncellier@ifrance.com"		"Too many fixes here (>36). It is necessary to split in sub-tasks"	^ self dependingOn: {		self fixesNicolasCellierCollectionsAndStreams.		self fixesNicolasCellierNumbers.		self fixesNicolasCellierTools.		self fixesNicolasCellierMisc.		}! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:36'!fixesNicolasCellierCollectionsAndStreams	"nicolas cellier (nice) ncellier@ifrance.com"		^ self dependingOn: {		" http://bugs.squeak.org/view.php?id=6778 "		'6778 SkipList copy is shallow...'.		" http://bugs.squeak.org/view.php?id=6777 "		'6777 CharacterSet copy is shallow...'.		" http://bugs.squeak.org/view.php?id=6366 "		'6366 [BUG] WideString findString:startingAt: and other matchTable problems'.		" http://bugs.squeak.org/view.php?id=6367 "		'6367 WideString substrings broken'.		" http://bugs.squeak.org/view.php?id=3574 "		'3574 (Wide)String-findFirstInString:inSet:startingAt: broke if last char'.		" http://bugs.squeak.org/view.php?id=5331 "		'5331 "abc" beginsWith: "ab" asWideString (returns wrong result)'.		" http://bugs.squeak.org/view.php?id=2701 "		'2701 DependentsArray might potentially be misused'.		" http://bugs.squeak.org/view.php?id=1602 "		'1602 [ENH] Interval method indexOf:'.		" http://bugs.squeak.org/view.php?id=6933 "		'6933 MultiByteFileStream>>upTo: fails for binary'.		" http://bugs.squeak.org/view.php?id=6535 "		"'6535 keyBlock and sortBlock are lost when creating a collection of the same species.'.		hangs when loading"		" http://bugs.squeak.org/view.php?id=7095 "		'7095 Dictionary>>collect: answers OrderedCollection not Dictionary'.		" http://bugs.squeak.org/view.php?id=7121 "		'7121 add:beforeIndex: and add:afterIndex: do not work as advertised'.		" http://bugs.squeak.org/view.php?id=7136 "		'7136 [BUG] LinkedList add:after: fails to update lastLink'.		" http://bugs.squeak.org/view.php?id=7175 "		'7175 CharacterSetComplement cannot printString'.		} ! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:36'!fixesNicolasCellierMisc	"nicolas cellier (nice) ncellier@ifrance.com"		^ self dependingOn: {		" http://bugs.squeak.org/view.php?id=6726 "		'6726 REQ: <raw>CompiledMethod</raw> print enhancement'.		" http://bugs.squeak.org/view.php?id=6732 "		'6732 Undo polygon painting cause drawing not functioning anymore'.		" http://bugs.squeak.org/view.php?id=6584 "		'6584 Symbol allInstances doesn''t work anymore'.		" http://bugs.squeak.org/view.php?id=1035 "		'1035 Strange behavior polygon morph added to a rectangle morph with proportional layout'.		} ! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:36'!fixesNicolasCellierNumbers	"nicolas cellier (nice) ncellier@ifrance.com"		^ self dependingOn: {		" http://bugs.squeak.org/view.php?id=6781 "		'6781: 0.0 raisedTo: -1.0 unexpected result'.		" http://bugs.squeak.org/view.php?id=6782 "		'6782: 1.0 / (FloatArray with: 2.0) unexpected result'.		" http://bugs.squeak.org/view.php?id=6729 "  		'6729: -Infinity closeTo: Infinity'.		" http://bugs.squeak.org/view.php?id=6796 "		'6796 A ScaledDecimal is a literal but not isLiteral'.			" http://bugs.squeak.org/view.php?id=6797 "		'6797 Compiler reduce ScaledDecimal with different scales to a single literal'.		" http://bugs.squeak.org/view.php?id=4378 " 		'4378 ScaledDecimal storeString uses printOn: and looses exactness'.		" http://bugs.squeak.org/view.php?id=7169 "		'7169 SqNumberParser does not parse ScaledDecimal with trailing zeros correctly'.		" http://bugs.squeak.org/view.php?id=6779 "		'6779 ScaledDecimal readFrom: ''5.3'' would not answer a ScaledDecimal'.		" http://bugs.squeak.org/view.php?id=6482 "		'6482 Interval storeOn: Incorrect for some ScaledDecimal'.		" http://bugs.squeak.org/view.php?id=6696 "		'6696 ScaledDecimal can read in base 16 but cannot print in base 16'.		" http://bugs.squeak.org/view.php?id=6695 "		'6695 Float storeStringBase: does not store the radix'.		" http://bugs.squeak.org/view.php?id=6697 "		'6697 Number>>storeOn:base: default implementation is wrong'.		" http://bugs.squeak.org/view.php?id=6873 "		'6873 [BUG] isPowerOfTwo incorrect for some LargeNegativeInteger'.		" http://bugs.squeak.org/view.php?id=6456 "		'6456 [BUG] Interval of Float do: infinite loop'.		" http://bugs.squeak.org/view.php?id=6990 "		'6990 0.0 significandAsInteger is too big'.		" http://bugs.squeak.org/view.php?id=5640 "		'5640 Number-i-printShowingDecimalPlaces:'.		" http://bugs.squeak.org/view.php?id=7114 "		'7114 [BUG] SmallInteger minVal highBitOfMagnitude'.		" http://bugs.squeak.org/view.php?id=7134 "		'7134 Float rounded is inexact'.		} ! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:36'!fixesNicolasCellierTools	"nicolas cellier (nice) ncellier@ifrance.com"		^ self dependingOn: {		" http://bugs.squeak.org/view.php?id=6812 "		'6812 Inspecting a changing WeakSet will raise a Debugger'.				" http://bugs.squeak.org/view.php?id=7007 "		'7007 toggle break on entry from method list pane does not work'.		} ! !!ManualFixesTemp class methodsFor: 'as yet unclassified' stamp: 'kph 12/10/2008 01:36'!fixesOthers		^ self dependingOn: { 					"Matthew Fulmer"						" http://bugs.squeak.org/view.php?id=1780 "			'1780: Stay up menus have a confusing and dangerous behavior when obscured.'. 			"kph: not sure this works as intended, menus cease to work at all if partially obscured"								" http://bugs.squeak.org/view.php?id=7059 "			'7059 In the Object Explorer, the menu item explore pointers is broken'.			"Tom Phoenix"						" http://bugs.squeak.org/view.php?id=6870 "			'6870 MessageCatcher considered harmful'. 			"proposer Andreas"			" http://bugs.squeak.org/view.php?id=6980 "			'6980 recreate special objects array'.			"proposer laza"			" http://bugs.squeak.org/view.php?id=6834 "			'6834 Delay class-#timeoutSemaphore:afterMSecs: doesnt'.						"proposer klaus" "this is already in kernel-extensions"			" http://bugs.squeak.org/view.php?id=6937 "			'6937 OrderedCollection-removeAll'.						"Keith Hodges"			" http://bugs.squeak.org/view.php?id=6868 "			'6868: System Navigation-#obsoleteBehaviours chokes on ProtoObjects'.					" http://bugs.squeak.org/view.php?id=7177 "			'7177 removeAll fails for Dictionaries'.						"proposer: Damien Cassou"			" http://bugs.squeak.org/view.php?id=6846 "			'6846 MenuMorphs can drop mouse focus'.			"proposer: Zulq"			" http://bugs.squeak.org/view.php?id=6859 "			'6859: Integer-parseFromString:base:ifFail:'.			"proposer: Göran Krampe"			" http://bugs.squeak.org/view.php?id=6843 "		"	'6843: Trivial fix in SMTPClient-#encodeString: exclude NULL chars'. "			"proposer: philb"			" http://bugs.squeak.org/view.php?id=7196 "			'7196 HTTPSocket User Agent hard-coded'.						"proposer: keith"			" http://bugs.squeak.org/view.php?id=7199 "			'7199: Expose Socket timeout to ProtocolClients'. 		} 	 ! !!ReleaseAfterSqueak310 commentStamp: 'kph 12/8/2008 18:31' prior: 0!This isStable and isNextReleaseself taskGenerate run.self taskCleanDeprecated run.self taskCleanExcess run.self taskCleanTests run.TODO:What to do about Complex?!!ReleaseAfterSqueak310Unstable commentStamp: 'kph 12/8/2008 18:32' prior: 0!This isUnstable and isNextRelease!!ReleaseAfterSqueak310kph commentStamp: 'kph 9/2/2008 04:42' prior: 0!this is what I am working on!!Squeak310MakeBuildCandidate commentStamp: 'kph 2/13/2009 04:29' prior: 0!self taskBuild run.self saveAll run.!"Tasks-Squeak310"!!ReleaseSqueak311 class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 18:12'!repository	^ ReleaseAfterSqueak310 repository! !!ReleaseSqueak311 class methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 17:40'!taskRELEASECANDIDATE	^ self define: [ :task |					task dependsOn: { 			PackageOrganizer 				taskSaveAllPackagesIn: self repository				withComment: 'Saved from release candidate'.			(Packages current named: 'Universes') unload.			 			(Packages current named: 'YAXO') unload.			 			(Packages current named: 'SqueakMap2 loader') unload.			 			(Packages current named: 'SqueakMap2 base') unload.				self taskRemoveTests.			self taskFinalize.		}.	].! !!ReleaseSqueak311 class methodsFor: 'as yet unclassified' stamp: 'kph 9/2/2008 13:01'!taskRemoveTests	^ self define: [ :task |		task action: [ 					Installer mc unload: '*.test'.	 		]	].! !!ReleaseSqueak311 class methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 18:12'!versionString	^ ReleaseAfterSqueak310 versionString! !"Tasks-Squeak311"!Installer install: 'Packages'. Packages beta load: 'Tasks'.!----End fileIn of a stream----!Installer install: 'Tasks'.!Squeak310MakeBuildCandidate removeSelector: #m06980LoadingFFIkernelmakesNetNam!Squeak310MakeBuildCandidate removeSelector: #m05851RefactorSmalltalkImagesaveAs!Squeak310MakeBuildCandidate removeSelector: #m07218ClassOrganizercategoriesbreak!Squeak310MakeBuildCandidate removeSelector: #m07166speedupallSelectorsaddallSel!Squeak310MakeBuildCandidate removeSelector: #m07244ImagecleanUpmethods!Squeak310MakeBuildCandidate removeSelector: #m06868SystemNavigationobsoleteBehav!Squeak310MakeBuildCandidate removeSelector: #m06466LazyListMorphlistChagedfixupl!Squeak310MakeBuildCandidate removeSelector: #m07272BlockContextequalitytestism!Squeak310MakeBuildCandidate removeSelector: #m06086CannotuseCrLfFileStreamon!Squeak310MakeBuildCandidate removeSelector: #m05669WorkspaceopenFileconvenience!Squeak310MakeBuildCandidate removeSelector: #m07219ImproveStreamsUsageReadabili!Squeak310MakeBuildCandidate removeSelector: #m07205MonticelloSnapshotSpeedupvia!Squeak310MakeBuildCandidate removeSelector: #m07131SyntaxErrordialogsraisemore!Squeak310MakeBuildCandidate removeSelector: #m05706Needminimalsocketstats!SMDefaultInstaller removeSelector: #fileIn!SMDependencyAnalysis removeSelector: #removeOlderReleasesIn:!SMInstallationProposal removeSelector: #collectConflictsIn:!SMInstallationRegistry removeSelector: #markInstalled:version:time:counter:!SMPackage removeSelector: #fullDescription!SMSqueakMap removeSelector: #categories!SMSqueakMap removeSelector: #synchWithDisk!SMPackageRelease removeSelector: #fullDescription!!SMDefaultInstaller methodsFor: 'private' stamp: 'KLC 4/27/2007 17:31'!fileIn	"Installing in the standard installer is simply filing in.	Both .st and .cs files will file into a ChangeSet of their own.	We let the user confirm filing into an existing ChangeSet	or specify another ChangeSet name if	the name derived from the filename already exists."		| fileStream |	(self class nonMultiSuffixes anySatisfy: [:each | unpackedFileName endsWith: (FileDirectory dot, each)])		ifTrue:[			fileStream := dir readOnlyFileNamed: unpackedFileName.			(fileStream respondsTo: #setConverterForCode) ifTrue: [fileStream setConverterForCode].			self fileIntoChangeSetNamed: (fileStream localName sansPeriodSuffix) fromStream: fileStream.			^self].	(self class multiSuffixes anySatisfy: [:each | unpackedFileName endsWith: (FileDirectory dot, each)])		ifTrue:[			fileStream := dir readOnlyFileNamed: unpackedFileName.			"Only images with converters should have multi suffixes"			fileStream converter: (Smalltalk at: #UTF8TextConverter) new.			self fileIntoChangeSetNamed: (fileStream localName sansPeriodSuffix) fromStream: fileStream.			^self].	self error: 'Filename should end with a proper extension'.! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'md 12/22/2006 14:31'!removeOlderReleasesIn: collectionOfReleases	"Remove older multiple releases of the same package.	2 scans to retain order."	| newestReleases rel |	newestReleases := Dictionary new.	collectionOfReleases do: [:r |		rel := newestReleases at: r package ifAbsentPut: [r].		(r newerThan: rel) ifTrue: [newestReleases at: r package put: r]].	^collectionOfReleases select: [:r |		(newestReleases at: r package) == r]! !!SMInstallationProposal methodsFor: 'initialize-release' stamp: 'md 12/22/2006 14:30'!collectConflictsIn: collectionOfReleases	"Collect all conflicts where there are either		- multiple releases of the same package and/or		- another release of the same package already installed	Return the conflicts as an IdentityDictionary with	the package as key and the value being a Set of releases."	| conflicts set |	conflicts := IdentityDictionary new.	collectionOfReleases do: [:r |		set := conflicts at: r package ifAbsentPut: [OrderedCollection new].		set add: r].	"Add the installed releases too"	conflicts keysAndValuesDo: [:key :value |		key isInstalled ifTrue: [value add: key installedRelease]].	"Prune release sets with only one member"	^conflicts select: [:releaseSet | releaseSet size > 1]! !!SMInstallationRegistry methodsFor: 'private' stamp: 'md 12/22/2006 14:30'!markInstalled: uuid version: version time: time counter: num	"Private. Mark the installation. SM2 uses an Association	to distinguish the automatic version from old versions."	| installs |	installedPackages ifNil: [installedPackages := Dictionary new].	installs := installedPackages at: uuid ifAbsentPut: [OrderedCollection new].	installs add:		(Array with: 2->version				with: time				with: num)! !!SMPackage methodsFor: 'accessing' stamp: 'dew 10/23/2006 19:08'!fullDescription	"Return a full textual description of the package. 	Most of the description is taken from the last release."	| s publishedRelease sqDescription |	s := TextStream on: (Text new: 400).	self		describe: name		withBoldLabel: 'Name:		'		on: s.	summary isEmptyOrNil		ifFalse: [self				describe: summary				withBoldLabel: 'Summary:	'				on: s ].	author isEmptyOrNil		ifFalse: [s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Author:'];				 tab;				 tab.			s				withAttribute: (PluggableTextAttribute						evalBlock: [self userInterface										sendMailTo: (SMUtilities stripEmailFrom: author)										regardingPackageRelease: self lastRelease])				do: [s nextPutAll: author];				 cr].	self owner		ifNotNil: [s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Owner:'];				 tab; tab.			s				withAttribute: (PluggableTextAttribute						evalBlock: [self userInterface										sendMailTo: self owner email										regardingPackageRelease: self lastRelease])				do: [s nextPutAll: self owner nameAndEmail];					 cr].	self maintainers isEmpty ifFalse: [		s withAttribute: TextEmphasis bold do: [s nextPutAll: 'Co-Maintainers:']; tab.		self maintainers do: [:com |			com = self maintainers first ifFalse: [s nextPutAll: ', '].			s				withAttribute:					(PluggableTextAttribute						evalBlock: [self userInterface									sendMailTo: com email									regardingPackageRelease: self lastRelease])				do: [s nextPutAll: com nameAndEmail]].				s cr].	description isEmptyOrNil		ifFalse: [sqDescription := description withSqueakLineEndings.			s cr.			s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Description:'].			s cr.			s				withAttribute: (TextIndent tabs: 1)				do: [s next: (sqDescription findLast: [ :c | c isSeparator not ]) putAll: sqDescription].			s cr ].	self describeCategoriesOn: s indent: 1.	s cr.	publishedRelease := self lastPublishedRelease.	self		describe: (self publishedVersion ifNil: ['<not published>'])		withBoldLabel: 'Published Version: '		on: s.	self isPublished ifTrue: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Created: ' ];			print: publishedRelease created;			cr.			self note isEmptyOrNil				ifFalse: [s					withAttribute: TextEmphasis bold					do: [s nextPutAll: 'Release Note:'].			s cr.			s				withAttribute: (TextIndent tabs: 1)				do: [s nextPutAll: publishedRelease note withSqueakLineEndings].			s cr ]].	url isEmptyOrNil		ifFalse: [s cr;				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Homepage: '];				withAttribute: (TextURL new url: url)				do: [s nextPutAll: url];				 cr].	packageInfoName isEmptyOrNil		ifFalse: [self				describe: packageInfoName				withBoldLabel: 'Package Info: '				on: s ].	^ s contents! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 2/13/2009 15:11'!categories	"Lazily maintain a cache of all known category objects."	categories ifNotNil: [^categories].	objects isNil ifTrue: [ ^ #() ].	categories := objects select: [:o | o isCategory].	^categories! !!SMSqueakMap methodsFor: 'public' stamp: 'gk 2/13/2009 09:12'!isPurged	"Is this instance purged (empty)?"		^checkpointNumber isZero! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 2/13/2009 09:14'!synchWithDisk	"Synchronize myself with the checkpoints on disk.	If there is a newer checkpoint than I know of, load it.	If there is no checkpoint or if I have a higher checkpoint number,	create a new checkpoint from me.	The end result is that I am in synch with the disk and we are both as	updated as possible."	| checkpointNumberOnDisk |	 "If there is no checkpoint, save one from me."	(self isCheckpointAvailable) ifFalse: [		"If I am purged - don't checkpoint, no point"		self isPurged ifTrue: [^self].		^self createCheckpointNumber: checkpointNumber].	"If the one on disk is newer, load it"	checkpointNumberOnDisk := self lastCheckpointNumberOnDisk.	(checkpointNumber < checkpointNumberOnDisk)		ifTrue: [^self reload].	"If I am newer, recreate me on disk"	(checkpointNumberOnDisk < checkpointNumber)		ifTrue: [^self createCheckpointNumber: checkpointNumber]! !!SMPackageRelease methodsFor: 'printing' stamp: 'dew 10/23/2006 18:52'!fullDescription	"Return a full textual description of the package release."	| s |	s := TextStream on: (Text new: 400).	self describe: self package name withBoldLabel: 'Package Name: ' on: s.	name isEmptyOrNil ifFalse:		[self describe: self name withBoldLabel: 'Release Name: ' on: s].	summary isEmptyOrNil ifFalse:		[self describe: self summary withBoldLabel: 'Release Summary: ' on: s].	self 		describe: self version		withBoldLabel: 'Version: '		on: s.	categories isEmptyOrNil 		ifFalse: 			[s				cr;				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Categories: '];				cr.			(self categories asSortedCollection: [:a :b | a path < b path])				do: [:c | 					s						tab;						withAttribute: TextEmphasis italic							do: 								[c parentsDo: 										[:p | 										s											nextPutAll: p name;											nextPutAll: '/'].								s nextPutAll: c name];						nextPutAll: ' - ' , c summary;						cr].			s cr].	created ifNotNil: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Created: ' ];			print: self created;			cr].	updated ifNotNil: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Modified: ' ];			print: self updated;			cr].	publisher ifNotNil: [		s			withAttribute: TextEmphasis bold			do: [s nextPutAll: 'Publisher: '].		s			withAttribute: (PluggableTextAttribute					evalBlock: [self userInterface									sendMailTo: self publisher email									regardingPackageRelease: self])			do: [s nextPutAll: self publisher nameAndEmail];				cr].	self note isEmptyOrNil 		ifFalse: 			[s				cr;				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Version Comment:'].			s cr.			s withAttribute: (TextIndent tabs: 1) do: [s nextPutAll: self note withSqueakLineEndings].			s				cr;				cr].	url isEmptyOrNil 		ifFalse: 			[s				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Homepage:'];				tab;				withAttribute: (TextURL new url: url) do: [s nextPutAll: url];				cr].	self downloadUrl isEmptyOrNil 		ifFalse: 			[s				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Download:'];				tab;				withAttribute: (TextURL new url: self downloadUrl)					do: [s nextPutAll: self downloadUrl];				cr].	^s contents.! !"SMBase"!!EToyProjectHistoryMorph class methodsFor: 'parts bin' stamp: 'sw 8/19/2001 21:15' prior: 20065278!descriptionForPartsBin	^ self partName: 	'ProjectHistory'		categories:		#('Navigation')		documentation:	'A tool that lets you navigate back to recently-visited projects'! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'ar 9/28/2000 13:53' prior: 33885913!closeMyFlapIfAny	| myFlap allTabs myTab myWorld |	myWorld := self world.	myFlap := self nearestOwnerThat: [ :each | each isFlap].	myFlap ifNil: [^self].	allTabs := myWorld submorphs select: [ :each | each isFlapTab].	myTab := allTabs detect: [ :each | each referent == myFlap] ifNone: [^self].	myTab hideFlap.	myWorld displayWorldSafely.	! !!EToyProjectHistoryMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34' prior: 20064151!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ #raised! !!EToyProjectHistoryMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:37' prior: 20064332!defaultBorderWidth	"answer the default border width for the receiver"	^ 4! !!EToyProjectHistoryMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:25' prior: 20064496!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightBrown! !!EToyProjectHistoryMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:46' prior: 20064673!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;		 layoutInset: 4;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 useRoundedCorners;		 rebuild ! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 12:02' prior: 33886357!jumpToProject	| selection |	selection := (Project buildJumpToMenu: CustomMenu new) startUp.	self closeMyFlapIfAny.	Project jumpToSelection: selection! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 07:25' prior: 20061019!mouseDown: evt in: aMorph	aMorph setProperty: #mouseDownPoint toValue: evt cursorPoint.! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 07:28' prior: 20061203!mouseLeave: evt in: aMorph	aMorph removeProperty: #mouseDownPoint.! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/27/2000 22:47' prior: 33886606!mouseMove: evt in: aMorph	| start tuple project url pvm |	start := aMorph valueOfProperty: #mouseDownPoint ifAbsent: [^self].	(start dist: evt cursorPoint) abs < 5 ifTrue: [^self].	aMorph removeProperty: #mouseDownPoint.	evt hand hasSubmorphs ifTrue: [^self].	tuple := aMorph valueOfProperty: #projectParametersTuple ifAbsent: [^self].	project := tuple fourth first.	(project notNil and: [project world notNil]) ifTrue: [		^evt hand attachMorph: (ProjectViewMorph on: project).	].	url := tuple third.	url isEmptyOrNil ifTrue: [^self].	pvm := ProjectViewMorph new.	pvm		project: (DiskProxy global: #Project selector: #namedUrl: args: {url});		lastProjectThumbnail: tuple second.	evt hand attachMorph: pvm.! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'nb 6/17/2003 12:25' prior: 33887422!mouseUp: evt in: aMorph	| tuple project url |	(aMorph boundsInWorld containsPoint: evt cursorPoint) ifFalse: [^self].	tuple := aMorph valueOfProperty: #projectParametersTuple ifAbsent: [^Beeper beep].	project := tuple fourth first.	(project notNil and: [project world notNil]) ifTrue: [self closeMyFlapIfAny. ^project enter].	url := tuple third.	url isEmptyOrNil ifTrue: [^Beeper beep].	self closeMyFlapIfAny.	ProjectLoading thumbnailFromUrl: url."---	newTuple := {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.---"! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'dgd 9/20/2003 18:52' prior: 33888087!rebuild	| history r1 |	history := ProjectHistory currentHistory mostRecentCopy.	changeCounter := ProjectHistory changeCounter.	self removeAllMorphs.	self rubberBandCells: false. "enable growing"	r1 := self addARow: {		self inAColumn: {			StringMorph new contents: 'Jump...' translated; lock.		}.	}.	r1 on: #mouseUp send: #jumpToProject to: self.	history do: [ :each |		(			self addARow: {				(self inAColumn: {					StretchyImageMorph new form: each second; minWidth: 35; minHeight: 35; lock				}) vResizing: #spaceFill.				self inAColumn: {					StringMorph new contents: each first; lock.					"StringMorph new contents: each third; lock."				}.			}		)			color: Color paleYellow;			borderWidth: 1;			borderColor: #raised;			vResizing: #spaceFill;			on: #mouseUp send: #mouseUp:in: to: self;			on: #mouseDown send: #mouseDown:in: to: self;			on: #mouseMove send: #mouseMove:in: to: self;			on: #mouseLeave send: #mouseLeave:in: to: self;			setProperty: #projectParametersTuple toValue: each;			setBalloonText: (each third isEmptyOrNil ifTrue: ['not saved'] ifFalse: [each third])	]."---	newTuple := {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.---"! !!EToyProjectHistoryMorph methodsFor: 'stepping and presenter' stamp: 'RAA 7/10/2000 23:07' prior: 20064986!step	changeCounter = ProjectHistory changeCounter ifTrue: [^self].	self rebuild.	! !!EToyGenericDialogMorph methodsFor: 'initialization' stamp: 'dgd 1/7/2005 19:18' prior: 20013060!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ ColorTheme current dialogBorderColor! !!EToyGenericDialogMorph methodsFor: 'initialization' stamp: 'dgd 1/7/2005 19:19' prior: 20013268!defaultBorderWidth	"answer the default border width for the receiver"	^ ColorTheme current dialogBorderWidth! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 7/12/2003 12:33' prior: 20011525!genericTextFieldNamed: aString 	| newField |	newField := ShowEmptyTextMorph new beAllFont: self myFont;				 extent: 400 @ 20;				 contentsWrapped: ''.	namedFields at: aString put: newField.	^ newField! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:18' prior: 20011824!inAColumnForText: someMorphs 	^ (self inAColumn: someMorphs) hResizing: #shrinkWrap;		 color: ColorTheme current dialogTextBoxColor;		 borderColor: ColorTheme current dialogTextBoxBorderColor;		 borderWidth: ColorTheme current dialogButtonBorderWidth;		 useRoundedCorners! !!EToyGenericDialogMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:54' prior: 33880942!initialize	"initialize the state of the receiver"super initialize.""	namedFields := Dictionary new.		self rebuild! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:13' prior: 20012193!lockedString: aString 	^ self lockedString: aString font: self myFont! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:13' prior: 20012356!lockedString: aString font: aFont	^ self inAColumn: {(StringMorph contents: aString font: aFont) lock}! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 7/12/2003 12:29' prior: 20012552!myFont	^ Preferences standardEToysFont! !!EToyGenericDialogMorph methodsFor: 'initialization' stamp: 'jam 3/9/2003 18:05' prior: 20013671!rebuild	"rebuilds the receiver"	^ self! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:53' prior: 20012684!rightLockedString: aString 	^ self rightLockedString: aString font: self myFont! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:54' prior: 20012857!rightLockedString: aString font: aFont 	^ self inARightColumn: {(StringMorph contents: aString font: aFont) lock}! !!EToyProjectDetailsMorph class methodsFor: 'as yet unclassified' stamp: 'tak 3/15/2005 15:52' prior: 33885406!getFullInfoFor: aProject ifValid: aBlock expandedFormat: expandedFormat	| me |	(me := self basicNew)		expandedFormat: expandedFormat;		project: aProject		actionBlock: [ :x | 			aProject world setProperty: #ProjectDetails toValue: x.			x at: 'projectname' ifPresent: [ :newName | 				aProject renameTo: newName.			].			me delete.			aBlock value.		];		initialize;		becomeModal;		openCenteredInWorld! !!EToyProjectDetailsMorph class methodsFor: 'as yet unclassified' stamp: 'mir 6/19/2001 10:17' prior: 20059538!test1: aProject"EToyProjectDetailsMorph test1: Project current"	(self basicNew)		project: aProject		actionBlock: [ :x | 			aProject world setProperty: #ProjectDetails toValue: x.			x at: 'projectname' ifPresent: [ :newName | 				aProject renameTo: newName.			]		];		initialize;		openCenteredInWorld! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2001 20:56' prior: 33883584!copyOutDetails	| newDetails |	newDetails := Dictionary new.	self fieldToDetailsMappings do: [ :each |		namedFields at: each first ifPresent: [ :field |			newDetails at: each second put: field contents string		].	].	namedFields at: 'projectname' ifPresent: [ :field |		newDetails at: 'projectname' put: field contents string withBlanksTrimmed.	].	^newDetails! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/20/2000 09:45' prior: 20055519!doExpand	self expandedFormat: true.	self copyOutDetails.	self rebuild.! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 12:43' prior: 20055689!doOK	self validateTheProjectName ifFalse: [^false].	actionBlock value: self copyOutDetails.	self delete.! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'yo 2/23/2005 17:24' prior: 20055890!expandButton	^self		buttonNamed: 'More' translated		action: #doExpand 		color: self buttonColor 		help: 'Show more info on this project.' translated.! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'dgd 3/16/2004 12:10' prior: 20056140!expandedFormat	^ Preferences expandedPublishing			or: [self valueOfProperty: #expandedFormat ifAbsent: [false]]! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/20/2000 09:40' prior: 20056350!expandedFormat: aBoolean	self setProperty: #expandedFormat toValue: aBoolean! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 13:33' prior: 20056523!fieldToDetailsMappings	^#(		(#description 'projectdescription' 'Description:' 100) 		(#author 'projectauthor' 'Author:' 20) 		(#category 'projectcategory' 'Category:' 20)		(#subCategory 'projectsubcategory' 'Sub-category:' 20)		(#keywords 'projectkeywords' 'Key words:' 20)	)! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 13:55' prior: 20056902!fillInDetails	theProject ifNotNil: [		namedFields at: 'projectname' ifPresent: [ :field |			field contentsWrapped: theProject name		].	].	projectDetails ifNotNil: [		self fieldToDetailsMappings do: [ :each |			namedFields at: each first ifPresent: [ :field |				projectDetails at: each second ifPresent: [ :data |					field contentsWrapped: data				].			].		].	].! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 12:45' prior: 33884049!project: aProject actionBlock: aBlock	theProject := aProject.	actionBlock := aBlock.	projectDetails := theProject world valueOfProperty: #ProjectDetails ifAbsent: [Dictionary new]! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 11:08' prior: 33884327!projectDetails: aDictionary	projectDetails := aDictionary.! !!EToyProjectDetailsMorph methodsFor: 'initialization' stamp: 'dgd 11/3/2004 17:55' prior: 33884476!rebuild	| bottomButtons |	self removeAllMorphs.	self addARow: {		self			lockedString: 'Please describe this project' translated			font: Preferences standardEToysTitleFont.	}.	self addARow: {self space }.	self addARow: {		self rightLockedString: 'Name:' translated.		self inAColumnForText: {self fieldForProjectName}	}.	self expandedFormat ifTrue: [		self fieldToDetailsMappings do: [ :each |			self addARow: {				self rightLockedString: each third translated.				self inAColumnForText: {(self genericTextFieldNamed: each first) height: each fourth}			}.		].	].	self addARow: {self space }.	bottomButtons := self expandedFormat		ifTrue: [ { self okButton. self cancelButton } ]		ifFalse: [ { self okButton. self expandButton. self cancelButton } ].	self addARow: bottomButtons.	self fillInDetails.! !!EToyProjectDetailsMorph methodsFor: 'initialization' stamp: 'dgd 11/3/2004 17:29' prior: 20058717!space	^ RectangleMorph new extent: 5 @ 5;		 color: Color transparent;		 borderWidth: 0 ! !!EToyProjectQueryMorph class methodsFor: 'as yet unclassified' stamp: 'tak 3/15/2005 16:37' prior: 33889602!onServer: aProjectServer	"EToyProjectQueryMorph onServer: SuperSwikiServer testOnlySuperSwiki"	| criteria clean |	(self basicNew)		project: nil		actionBlock: [ :x | 			criteria := OrderedCollection new.			x keysAndValuesDo: [ :k :v |				(clean := v withBlanksTrimmed) isEmpty					ifFalse: [criteria add: k,': *',clean,'*']].			aProjectServer queryProjectsAndShow: criteria];		initialize;		becomeModal;		openCenteredInWorld! !!EToyProjectQueryMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 10/18/2000 12:34' prior: 33890139!test1: aProject"EToyProjectQueryMorph test1: nil"	| criteria clean |	(self basicNew)		project: aProject		actionBlock: [ :x | 			criteria := OrderedCollection new.			x keysAndValuesDo: [ :k :v |				(clean := v withBlanksTrimmed) isEmpty ifFalse: [					criteria add: k,': *',clean,'*'				].			].			SuperSwikiServer testOnlySuperSwiki queryProjectsAndShow: criteria		];		initialize;		openCenteredInWorld! !!EToyProjectQueryMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:26' prior: 20066749!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0.545		g: 0.47		b: 0.621! !!EToyProjectQueryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/18/2000 12:16' prior: 20065706!doOK	actionBlock value: self copyOutDetails.	self delete.! !!EToyProjectQueryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/18/2000 12:17' prior: 20065859!fillInDetails	"leave them blank for now"! !!EToyProjectQueryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/18/2000 12:18' prior: 33889408!project: ignored actionBlock: aBlock	actionBlock := aBlock.	projectDetails := Dictionary new.! !!EToyProjectQueryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/18/2000 12:19' prior: 20066181!rebuild	self removeAllMorphs.	self addARow: {		self lockedString: 'Enter things to search for'.	}.	self addARow: {		self lockedString: 'Name:'.		self inAColumnForText: {self fieldForProjectName}	}.	self fieldToDetailsMappings do: [ :each |		self addARow: {			self lockedString: each third.			self inAColumnForText: {(self genericTextFieldNamed: each first) height: each fourth}		}.	].	self addARow: {		self okButton.		self cancelButton.	}.	self fillInDetails.! !!EToyProjectRenamerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 10/18/2000 12:35' prior: 20071981!validate: aProject andDo: aBlock	(self new)		project: aProject actionBlock: aBlock;		openCenteredInWorld! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/21/2000 15:01' prior: 20068303!buttonColor	^color darker! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:25' prior: 33890651!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f := SimpleButtonMorph new		target: self;		label: aString translated font: self myFont;		color: aColor;		borderColor: aColor muchDarker;		actionSelector: aSymbol;		setBalloonText: helpString translated.	col := (self inAColumn: {f}) hResizing: #spaceFill.	^col! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:24' prior: 20068864!cancelButton	^ self		buttonNamed: 'Cancel'		action: #doCancel		color: ColorTheme current cancelColor		help: 'Cancel this Publish operation.'! !!EToyProjectRenamerMorph methodsFor: 'initialization' stamp: 'dgd 11/2/2004 21:09' prior: 20071390!defaultColor	"answer the default color/fill style for the receiver"	^ ColorTheme current dialogColor! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/21/2000 15:06' prior: 20069103!doCancel	self delete.! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2001 20:55' prior: 20069219!doOK	self validateTheProjectName ifFalse: [^self].	self delete.	actionBlock value: (namedFields at: 'projectname') contents string withBlanksTrimmed.! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'yo 2/23/2005 17:25' prior: 33891092!fieldForProjectName	| tm |	tm := self genericTextFieldNamed: 'projectname'.	tm crAction: (MessageSend receiver: self selector: #doOK).	tm setBalloonText: 'Pick a name 24 characters or less and avoid the following characters: : < > | / \ ? * " .' translated.	^tm	! !!EToyProjectRenamerMorph methodsFor: 'initialization' stamp: 'dgd 1/7/2005 19:21' prior: 20071580!initialize	"initialize the state of the receiver"	super initialize.	""	self vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 layoutInset: 4;		 useRoundedCorners;		 rebuild! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:23' prior: 20069831!okButton	^ self		buttonNamed: 'OK'		action: #doOK		color: ColorTheme current okColor		help: 'Change my name and continue publishing.'! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 13:55' prior: 33891460!project: aProject actionBlock: aBlock	theProject := aProject.	actionBlock := aBlock.	(namedFields at: 'projectname') contentsWrapped: theProject name.! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 12:36' prior: 20070311!rebuild	self removeAllMorphs.	self addARow: {		self lockedString: 'Please name this project'.	}.	self addARow: {		self inAColumnForText: {self fieldForProjectName}	}.	self addARow: {		self okButton.		self cancelButton.	}.! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'pk 10/17/2006 09:39' prior: 33891708!validateTheProjectName	| proposed |	proposed _ (namedFields at: 'projectname') contents string withBlanksTrimmed.	proposed isEmpty ifTrue: [		self inform: 'I do need a name for the project' translated.		^false	].	proposed size > 24 ifTrue: [		self inform: 'Please make the name 24 characters or less' translated.		^false	].	(Project isBadNameForStoring: proposed) ifTrue: [		self inform: 'Please remove any funny characters from the name' translated.		^false	].	proposed = theProject name ifTrue: [^true].	(ChangesOrganizer changeSetNamed: proposed) ifNotNil: [		Utilities inform: 'Sorry that name is already used' translated.		^false	].	^true! !!EtoyUpdatingThreePhaseButtonMorph class methodsFor: 'instance creation' stamp: 'RAA 8/8/2000 13:34' prior: 20237321!checkBox	"Answer a button pre-initialized with checkbox images."	"(Form extent: 12@12 depth: 32) morphEdit"	CheckedForm ifNil: [		self setForms	].	^self new		onImage: CheckedForm;		pressedImage: MouseDownForm;		offImage: UncheckedForm;		extent: CheckedForm extent;		yourself! !!EtoyUpdatingThreePhaseButtonMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/8/2000 13:34' prior: 33901444!setFormsCheckedForm := (Form	extent: 12@12	depth: 32	fromArray: #( 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 4278190081 4278190081 4278190081 0 0 0 0 0 0 0 0 4278190081 2003331177 4278190081 4278190081 0 0 0 0 0 0 0 4278190081 2003331177 0 4278190081 4278190081 0 0 0 0 0 0 4278190081 2003331177 0 0 4278190081 4278190081 0 4278190081 0 0 0 4278190081 2003331177 0 0 0 4278190081 4278190081 0 2003331177 4278190081 0 4278190081 2003331177 0 0 0 0 4278190081 4278190081 0 0 2003331177 4278190081 2003331177 0 0 0 0 0 4278190081 4278190081 0 0 0 2003331177 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081)	offset: 0@0).MouseDownForm := UncheckedForm := (Form	extent: 12@12	depth: 32	fromArray: #( 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081)	offset: 0@0)! !!EtoyUpdatingThreePhaseButtonMorph methodsFor: 'stepping and presenter' stamp: 'RAA 7/11/2000 12:18' prior: 33901111!step	| newBoolean |	state == #pressed ifTrue: [^ self].	newBoolean := target perform: getSelector withArguments: arguments.	newBoolean == self isOn		ifFalse:			[self state: (newBoolean ifTrue: [#on] ifFalse: [#off])]! !!EToyProjectHistoryMorph commentStamp: '<historical>' prior: 20060093!EToyProjectHistoryMorph new openInWorldEToyProjectHistoryMorph provides a quick reference of the most recent projects. Click on one to go there.!!EtoyUpdatingThreePhaseButtonMorph commentStamp: '<historical>' prior: 20234853!A slight variation wherein the actionSelector and getSelector both take argument(s).!"Nebraska"!!KedamaMorph class methodsFor: 'class initialization' stamp: 'yo 9/2/2004 23:23' prior: 34043877!initialize	"Kedama initialize"	RandomSeed := 17.! !!KedamaMorph class methodsFor: 'class initialization' stamp: 'yo 9/14/2004 20:27' prior: 22552917!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #( 	(kedama (		(command addToPatchDisplayList: 'add patch to display list' Patch)		(command removeAllFromPatchDisplayList 'clear the patch display list')		(slot patchDisplayList 'patches to display' String readOnly Player getPatchesList unused unused)		(command addToTurtleDisplayList: 'add turtle to display list' Player)		(command removeAllFromTurtleDisplayList 'clear the turtle display list')		(slot turtleDisplayList 'turtles to display' String readOnly Player getTurtlesList unused unused)		(slot pixelsPerPatch 'the display scale' Number readWrite Player getPixelsPerPatch Player setPixelsPerPatch:)		(slot color 'The color of the object' Color readWrite Player getColor  Player  setColor:)		"(command makeTurtlesMap 'Internally create the map of turtles')"		(slot leftEdgeMode 'the mode of left edge' EdgeMode readWrite Player getLeftEdgeMode Player setLeftEdgeMode:)		(slot rightEdgeMode 'the mode of right edge' EdgeMode readWrite Player getRightEdgeMode Player setRightEdgeMode:)		(slot topEdgeMode 'the mode of top edge' EdgeMode readWrite Player getTopEdgeMode Player setTopEdgeMode:)		(slot bottomEdgeMode 'the mode of bottom edge' EdgeMode readWrite Player getBottomEdgeMode Player setBottomEdgeMode:)	))).! !!KedamaMorph class methodsFor: 'class initialization' stamp: 'yo 6/9/2004 11:09' prior: 22554435!cleanUp"	self cleanUp"	self allInstancesDo: [:e | e cleanUp].! !!KedamaMorph class methodsFor: 'class initialization' stamp: 'yo 6/17/2004 19:04' prior: 22554589!defaultDimensions	"Answer the dimensions of this StarSqueak simulation. Subclasses can override this method to define their own world size."	^ 100@100.! !!KedamaMorph class methodsFor: 'class initialization' stamp: 'yo 9/26/2005 22:58' prior: 22554833!defaultNameStemForInstances	^ 'KedamaWorld' translated.! !!KedamaMorph class methodsFor: 'global primitive backup' stamp: 'yo 10/11/2004 11:47' prior: 34044493!degreesToRadians: degrees	| deg q headingRadians |	deg := 90.0 - degrees.	q := (deg / 360.0) asInteger.	deg < 0.0 ifTrue: [q := q - 1].	headingRadians := (deg - (q * 360.0)) * 0.0174532925199433.	^ headingRadians.! !!KedamaMorph class methodsFor: 'class initialization' stamp: 'yo 9/13/2005 22:09' prior: 22554979!descriptionForPartsBin	^ self partName:	'KedamaWorld'		categories:		#('Kedama')		documentation:	'A tile scriptable particle system' translated! !!KedamaMorph class methodsFor: 'class initialization' stamp: 'yo 10/23/2005 20:33' prior: 34044018!newSet	| k p t s w |	k := self new.	p := k assuredPlayer getPatch costume renderedMorph.	t := k assuredPlayer newTurtleForSet.	s := SelectionMorph new.	w := PasteUpMorph new.	w extent: 400@400.	p position: 275@50.	t position: 300@175.	k position: 25@25.	w addMorph: k.	w addMorph: t.	w addMorph: p.	w addMorph: s.	s bounds: w bounds.	s selectSubmorphsOf: w.	^ s.! !!KedamaMorph class methodsFor: 'global primitive backup' stamp: 'yo 10/11/2004 12:45' prior: 34044806!radiansToDegrees: radians	| degrees deg |	degrees := radians / 0.0174532925199433.	deg := 90.0 - degrees.	deg > 0.0 ifFalse: [deg := deg + 360.0].	^ deg.! !!KedamaMorph class methodsFor: 'global primitive backup' stamp: 'yo 10/10/2004 09:07' prior: 34045059!scalarXAt: index xArray: xArray headingArray: headingArray value: val destWidth: destWidth leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode	| newX headingRadians |	newX := val.	newX < 0.0 ifTrue: [		leftEdgeMode = 1 ifTrue: [			"wrap"			newX := newX + destWidth.		].		leftEdgeMode = 2 ifTrue: [			"stick"			newX := 0.0.		].		leftEdgeMode = 3 ifTrue: [			"bounce"			newX := 0.0 - newX.			headingRadians := headingArray at: index.			headingRadians <  3.141592653589793				ifTrue: [headingArray at: index put: 3.141592653589793 - headingRadians]				ifFalse: [headingArray at: index put: 9.42477796076938 - headingRadians].		].	].	newX >= destWidth ifTrue: [		rightEdgeMode = 1 ifTrue: [			newX := newX - destWidth.		].		rightEdgeMode = 2 ifTrue: [			newX := destWidth - 0.000001.		].		rightEdgeMode = 3 ifTrue: [			newX := (destWidth - 0.000001) - (newX - destWidth).			headingRadians := headingArray at: index.			headingRadians < 3.141592653589793				ifTrue: [headingArray at: index put: (3.141592653589793 - headingRadians)]				ifFalse: [headingArray at: index put: (9.42477796076938 - headingRadians)].		]	].	xArray at: index put: newX.! !!KedamaMorph class methodsFor: 'global primitive backup' stamp: 'yo 10/10/2004 09:09' prior: 34046333!scalarYAt: index yArray: yArray headingArray: headingArray value: val destHeight: destHeight topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode	| newY |	newY := val.	newY < 0.0 ifTrue: [		topEdgeMode = 1 ifTrue: [			"wrap"			newY := newY + destHeight.		].		topEdgeMode = 2 ifTrue: [			"stick"			newY := 0.0.		].		topEdgeMode = 3 ifTrue: [			"bounce"			newY := 0.0 - newY.			headingArray at: index put: (6.283185307179586 - (headingArray at: index)).		].	].	newY >= destHeight ifTrue: [		bottomEdgeMode = 1 ifTrue: [			newY := newY - destHeight.		].		bottomEdgeMode = 2 ifTrue: [			newY := destHeight - 0.000001.		].		bottomEdgeMode = 3 ifTrue: [			newY := (destHeight - 0.000001) - (newY - destHeight).			headingArray at: index put: (6.283185307179586 - (headingArray at: index)).		]	].	yArray at: index put: newY.! !!KedamaMorph methodsFor: 'event handling' stamp: 'ar 7/8/2006 20:25' prior: 34031382!acceptDroppingMorph: morphToDrop event: evt	| f turtle |	(morphToDrop renderedMorph isKindOf: SketchMorph) ifFalse: [		^morphToDrop rejectDropMorphEvent: evt.	].	f := morphToDrop renderedMorph rotatedForm.	f := f magnify: f boundingBox by: (1.0 / self pixelsPerPatch asFloat) smoothing: 1.	turtle := self player newTurtleSilently.	turtle createTurtlesAsIn: f originAt: ((morphToDrop topLeft - self topLeft) / self pixelsPerPatch asFloat) asIntegerPoint.	"turtle isGroup: true."	turtle color: (self dominantColorWithoutTransparent: f).! !!KedamaMorph methodsFor: 'setup' stamp: 'yo 9/9/2004 15:24' prior: 34032424!addToPatchDisplayList: p	| a |	a := patchesToDisplay copyWithout: p.	patchesToDisplay := a copyWith: p.! !!KedamaMorph methodsFor: 'setup' stamp: 'yo 9/14/2004 20:24' prior: 34032599!addToTurtleDisplayList: p	| a |	(p isKindOf: KedamaExamplerPlayer) ifFalse: [^ self].	a := turtlesToDisplay copyWithout: p.	turtlesToDisplay := a copyWith: p.! !!KedamaMorph methodsFor: 'submorphs-accessing' stamp: 'yo 6/17/2004 19:45' prior: 22537799!allSubmorphNamesDo: aBlock	super allSubmorphNamesDo: aBlock.	aBlock value: self player getPatch externalName.! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 6/1/2004 16:53' prior: 22537981!areasRemainingToFill: aRectangle	"Drawing optimization. Since I completely fill my bounds with opaque pixels, this method tells Morphic that it isn't necessary to draw any morphs covered by me."		^ aRectangle areasOutside: self bounds! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 6/17/2004 09:51' prior: 22540562!bottomEdgeMode	^ bottomEdgeMode.! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 1/20/2005 19:52' prior: 34034695!bottomEdgeMode: aSymbol	bottomEdgeMode := aSymbol asSymbol.	bottomEdgeMode == #wrap ifTrue: [		bottomEdgeModeMnemonic := 1.		^ self	].	bottomEdgeMode == #stick ifTrue: [		bottomEdgeModeMnemonic := 2.		^ self	].	(bottomEdgeMode == #bounce or: [bottomEdgeMode == #bouncing]) ifTrue: [		bottomEdgeModeMnemonic := 3.		^ self	].! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 9/16/2004 18:59' prior: 22540668!bottomEdgeModeMnemonic	^ bottomEdgeModeMnemonic.! !!KedamaMorph methodsFor: 'turtles' stamp: 'KR 4/14/2006 15:52' prior: 34036938!calcTurtlesCount	turtleCount := 0.	turtlesDict do: [:a | turtleCount := turtleCount + a size].	SmalltalkImage current vmParameterAt: 5 put: ((turtleCount * 3) min: 16000 max: 4000).	SmalltalkImage current vmParameterAt: 6 put: ((turtleCount * 6) min: 32000 max: 8000).! !!KedamaMorph methodsFor: 'etoys' stamp: 'yo 6/11/2004 11:20' prior: 34041042!categoriesForViewer	"Answer a list of symbols representing the categories to offer in the viewer, in order"	^ super categoriesForViewer."	| aList |	aList := OrderedCollection new.	aList addAllFirstUnlessAlreadyPresent: (self class additionsToViewerCategories collect:				[:categorySpec | categorySpec first]).	^ aList"! !!KedamaMorph methodsFor: 'setup' stamp: 'yo 6/9/2004 11:09' prior: 22536979!cleanUp	self extension actorState: nil.	self extension player: nil.	self initializeTurtlesDict.! !!KedamaMorph methodsFor: 'setup' stamp: 'yo 9/27/2004 10:26' prior: 34032830!clearAll	"Reset this StarSqueak world. All patch variables are cleared, all turtles are removed, and all demons are turned off."	patchVarDisplayForm := Form extent: dimensions depth: 32.	self initializePatch.	self recreateMagnifiedDisplayForm.	self initializeTurtlesDict.	turtleCount := 0.	lastTurtleID := 0.	self color: Color black.! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 4/6/2005 12:59' prior: 34035103!colorAt: aLocalPoint	| pix |	pix := patchVarDisplayForm pixelValueAt: (aLocalPoint // pixelsPerPatch) asIntegerPoint.	^ Color colorFromPixelValue: (pix bitOr: 16rFF000000) depth: 32.! !!KedamaMorph methodsFor: 'deleting' stamp: 'yo 10/8/2004 11:11' prior: 34041439!delete	| c |	super delete.	turtlesDict keysDo: [:k |		self deleteAllTurtlesOfExampler: k.		c := k costume.		c ifNotNil: [c renderedMorph delete].	].! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/28/2004 14:12' prior: 22544392!deleteAllTurtlesOfExampler: examplerPlayer	turtlesDict removeKey: examplerPlayer ifAbsent: [].	self removeFromTurtleDisplayList: examplerPlayer.	self calcTurtlesCount.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 7/20/2005 22:34' prior: 34037282!deleteTurtleID: who of: examplerPlayer	"Delete the given turtle from this world."	| array |	array := examplerPlayer turtles.	array ifNil: [^ self].	turtlesDictSemaphore critical: [		array deleteTurtleID: who.	].	self calcTurtlesCount.	examplerPlayer costume renderedMorph privateTurtleCount: array size.	"examplerPlayer allOpenViewers do: [:v | v resetWhoIfNecessary]."! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 6/1/2004 16:53' prior: 22541450!dimensions	^ dimensions! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 6/17/2004 17:56' prior: 34033245!display	"Display this world on the Display. Used for debugging."	| c |	c := FormCanvas extent: (dimensions * pixelsPerPatch) depth: 32.	c := c copyOffset: bounds origin negated.	self drawOn: c.	c form display.! !!KedamaMorph methodsFor: 'event handling' stamp: 'ar 7/8/2006 20:25' prior: 34032005!dominantColorWithoutTransparent: aForm	| tally max maxi |	aForm depth > 16 ifTrue:		[^self dominantColorWithoutTransparent: (aForm asFormOfDepth: 16)].	tally := aForm tallyPixelValues.	max := maxi := 0.	tally withIndexDo: [:n :i | n > max ifTrue: [ i ~= 1 ifTrue: [max := n. maxi := i]]].	^ Color colorFromPixelValue: maxi - 1 depth: aForm depth! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 9/27/2004 10:28' prior: 34033531!drawOn: aCanvas	"Display this StarSqueak world."	| result |	"Time millisecondClockValue printString displayAt: 0@0."	self player ifNil: [^ aCanvas fillRectangle: (self bounds) color: self color].	patchVarDisplayForm fillColor: self color.	patchesToDisplay do: [:p |		p displayPatchVariableOn: patchVarDisplayForm.	].	self drawTurtlesOnForm: patchVarDisplayForm.	pixelsPerPatch = 1 ifTrue: [		aCanvas drawImage: patchVarDisplayForm at: bounds origin.	] ifFalse: [		result := self zoom: patchVarDisplayForm into: magnifiedDisplayForm factor: pixelsPerPatch.		result ifNil: [			aCanvas warpImage: patchVarDisplayForm transform: (MatrixTransform2x3 withScale: pixelsPerPatch) at: self innerBounds origin.		] ifNotNil: [			aCanvas drawImage: magnifiedDisplayForm at: bounds origin.		]	].	autoChanged ifTrue: [self changed].! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 9/27/2004 16:28' prior: 22539482!drawTurtlesOnForm: aForm	turtlesToDisplay do: [:exampler |		(self isVisible: exampler) ifTrue: [			turtlesDictSemaphore critical: [				exampler turtles drawOn: aForm.			].		].	].! !!KedamaMorph methodsFor: 'geometry' stamp: 'yo 6/1/2004 16:53' prior: 22549266!extent: aPoint	"Do nothing; my extent is determined by my StarSqueak world dimensions and pixelsPerPatch."! !!KedamaMorph methodsFor: 'utils' stamp: 'yo 8/18/2005 15:32' prior: 22552282!hasNoTurtleBreed	^ turtlesDict isEmpty.! !!KedamaMorph methodsFor: 'initialization' stamp: 'yo 9/17/2004 19:34' prior: 34041673!initialize	super initialize.	dimensions := self class defaultDimensions.  "dimensions of this StarSqueak world in patches"	wrapX := dimensions x asFloat.	wrapY := dimensions y asFloat.	pixelsPerPatch := 2.	super extent: dimensions * pixelsPerPatch.	self assuredPlayer assureUniClass.	self clearAll.  "be sure this is done once in case setup fails to do it"	autoChanged := true.	self leftEdgeMode: #wrap.	self rightEdgeMode: #wrap.	self topEdgeMode: #wrap.	self bottomEdgeMode: #wrap.	turtlesDictSemaphore := Semaphore forMutualExclusion.! !!KedamaMorph methodsFor: 'initialization' stamp: 'yo 9/9/2004 15:15' prior: 34042302!initializePatch	| f |	f := self player addPatchVarNamed: #patch.	patchesToDisplay := Array new: 0.	self addToPatchDisplayList: f.	^ f.! !!KedamaMorph methodsFor: 'initialization' stamp: 'yo 9/28/2004 14:12' prior: 34042519!initializeTurtlesDict	turtlesDict := IdentityDictionary new.	turtlesToDisplay := Array new.! !!KedamaMorph methodsFor: 'private' stamp: 'yo 9/14/2004 18:47' prior: 34042683!isVisible: examplerPlayer	| turtleMorph |	turtleMorph := examplerPlayer costume.	turtleMorph visible ifFalse: [^ false].	turtleMorph owner isRenderer ifFalse: [^ true].	^ turtleMorph owner visible.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/20/2004 09:28' prior: 34037732!lastWhoOf: exampler	| turtles |	turtles := turtlesDict at: exampler ifAbsent: [nil].	^ (turtles arrays first) at: turtles arrays first size.! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 6/17/2004 09:51' prior: 22541547!leftEdgeMode	^ leftEdgeMode.! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 1/20/2005 19:52' prior: 34035361!leftEdgeMode: aSymbol	leftEdgeMode := aSymbol asSymbol.	leftEdgeMode == #wrap ifTrue: [		leftEdgeModeMnemonic := 1.		^ self	].	leftEdgeMode == #stick ifTrue: [		leftEdgeModeMnemonic := 2.		^ self	].	(leftEdgeMode == #bounce or: [leftEdgeMode == #bouncing]) ifTrue: [		leftEdgeModeMnemonic := 3.		^ self	].! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 9/16/2004 18:59' prior: 22541649!leftEdgeModeMnemonic	^ leftEdgeModeMnemonic.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/14/2004 18:39' prior: 22545295!makePrototypeOfExampler: examplerPlayer	^ self makePrototypeOfExampler: examplerPlayer color: nil.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/27/2004 16:29' prior: 34037946!makePrototypeOfExampler: examplerPlayer color: cPixel	| array inst info |	array := examplerPlayer turtles.	info := array info.	array size > 0 ifTrue: [		inst := array makePrototypeFromFirstInstance.		cPixel ifNotNil: [inst at: (info at: #color) put: cPixel].		^ inst.	].	inst := Array new: array instSize.	info associationsDo: [:assoc |		inst at: (assoc value) put: (examplerPlayer perform: (Utilities getterSelectorFor: assoc key)).	].	cPixel ifNotNil: [inst at: (info at: #color) put: cPixel] ifNil: [inst at: (info at: #color) put: ((examplerPlayer getColor pixelValueForDepth: 32) bitAnd: 16rFFFFFF)].	inst at: (info at: #visible) put: ((inst at: (info at: #visible)) ifTrue: [1] ifFalse: [0]).	^ inst.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/27/2004 16:29' prior: 34038739!makeReplicatedTurtles: count examplerPlayer: tp color: c ofPrototype: prototype randomize: randomizeFlag	| array inst |	array := tp turtles.	inst := prototype ifNil: [self makePrototypeOfExampler: tp color: c].	turtlesDictSemaphore critical: [		array addTurtlesCount: count ofPrototype: inst for: self randomize: randomizeFlag.	].	self calcTurtlesCount.	self changed.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/28/2004 14:13' prior: 34039652!makeTurtles: count examplerPlayer: tp color: c ofPrototype: prototype turtles: turtles randomize: randomizeFlag	| array inst |	array := tp turtles.	(turtlesDict keys includes: tp) ifFalse: [		self addToTurtleDisplayList: tp.		turtlesDict at: tp put: (array := turtles).	].	inst := prototype ifNil: [self makePrototypeOfExampler: tp color: c].	turtlesDictSemaphore critical: [array setTurtlesCount: count prototype: inst for: self randomize: randomizeFlag].	self calcTurtlesCount.	self changed.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/28/2004 14:16' prior: 34039187!makeTurtlesAtPositionsIn: positionAndColorArray examplerPlayer: tp ofPrototype: prototype	| array inst |	array := tp turtles.	inst := prototype ifNil: [self makePrototypeOfExampler: tp].	turtlesDictSemaphore critical: [array addTurtlesCount: positionAndColorArray first size ofPrototype: inst for: self positionAndColorArray: positionAndColorArray].	self calcTurtlesCount.	self changed.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/14/2004 17:34' prior: 34040228!nextTurtleID	^ lastTurtleID := lastTurtleID + 1.! !!KedamaMorph methodsFor: 'menu' stamp: 'yo 8/18/2005 12:09' prior: 22551147!offerCostumeViewerMenu: aMenu	aMenu add: 'add a new patch variable' translated action: #newPatch.	aMenu balloonTextForLastItem: 'Add a new patch variable' translated.	aMenu add: 'add a new breed of turtle' translated action: #newTurtle.	aMenu balloonTextForLastItem: 'Add a new turtle' translated.	aMenu addLine.! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 6/4/2004 18:13' prior: 22539737!patchesToDisplayAsString	^ String streamContents: [:strm |		strm nextPutAll: '#('.		patchesToDisplay do: [:p |			strm nextPutAll: p externalName.			strm nextPut: Character space.		].		strm nextPutAll: ')'.	].! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 6/1/2004 16:53' prior: 22542153!pixelsPerPatch	^ pixelsPerPatch! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 6/11/2004 01:06' prior: 34035752!pixelsPerPatch: anInteger	"Set the width of one patch in pixels. Larger numbers scale up this StarSqueak world, but numbers larger than 2 or 3 result in a blocky look. The useful range is 1 to 10."	pixelsPerPatch := (anInteger rounded max: 1) min: 10.	super extent: dimensions * pixelsPerPatch.	self recreateMagnifiedDisplayForm! !!KedamaMorph methodsFor: 'private-primitives' stamp: 'yo 3/7/2005 13:27' prior: 22551850!primSetRandomSeed: seed	<primitive: 'kedamaSetRandomSeed' module: 'KedamaPlugin'>	^ nil.! !!KedamaMorph methodsFor: 'private-primitives' stamp: 'yo 6/18/2004 15:18' prior: 22552022!primZoom: src into: dst srcWidth: sWidth height: sHeight multX: xFactor y: yFactor	<primitive: 'zoomBitmap' module: 'KedamaPlugin'>	"^ KedamaSqueakPlugin doPrimitive: #zoomBitmap."	^ nil.! !!KedamaMorph methodsFor: 'utils' stamp: 'yo 3/23/2005 12:24' prior: 34043455!random: range	"Answer a random integer between 0 and range."	| r val |	<primitive: 'randomRange' module: 'KedamaPlugin'>	r := range < 0 ifTrue: [range negated] ifFalse: [range].	RandomSeed := ((RandomSeed * 1309) + 13849) bitAnd: 65535.	val := (RandomSeed * (r + 1)) >> 16.	^ range < 0 ifTrue: [val negated] ifFalse: [^ val].! !!KedamaMorph methodsFor: 'private' stamp: 'yo 6/6/2004 23:25' prior: 34042955!recreateMagnifiedDisplayForm	magnifiedDisplayForm := Form extent: self dimensions * pixelsPerPatch depth: 32.	self changed.! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 9/9/2004 15:16' prior: 34034441!removeAllFromPatchDisplayList	patchesToDisplay := #().! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 9/9/2004 15:19' prior: 34034566!removeAllFromTurtleDisplayList	turtlesToDisplay := #().! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/14/2004 20:28' prior: 34040348!removeFromTurtleDisplayList: examplerPlayer	turtlesToDisplay := turtlesToDisplay copyWithout: examplerPlayer.! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 6/17/2004 09:51' prior: 22542662!rightEdgeMode	^ rightEdgeMode.! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 1/20/2005 19:52' prior: 34036157!rightEdgeMode: aSymbol	rightEdgeMode := aSymbol asSymbol.	rightEdgeMode == #wrap ifTrue: [		rightEdgeModeMnemonic := 1.		^ self	].	rightEdgeMode == #stick ifTrue: [		rightEdgeModeMnemonic := 2.		^ self	].	(rightEdgeMode == #bounce or: [rightEdgeMode == #bouncing]) ifTrue: [		rightEdgeModeMnemonic := 3.		^ self	].! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 9/16/2004 18:59' prior: 22542766!rightEdgeModeMnemonic	^ rightEdgeModeMnemonic.! !!KedamaMorph methodsFor: 'menu' stamp: 'yo 6/16/2004 08:56' prior: 34043148!setScale	| reply |	reply := FillInTheBlank		request: 'Set the number of pixels per patch (a number between 1 and 10)?'		 initialAnswer: pixelsPerPatch printString.	reply isEmpty ifTrue: [^ self].	self pixelsPerPatch: reply asNumber.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/27/2004 16:30' prior: 34040529!setTurtlesCount: count examplerPlayer: tp color: cPixel	| prototype |	prototype := self makePrototypeOfExampler: tp color: cPixel.	turtlesDictSemaphore critical: [(tp turtles) setTurtlesCount: count prototype: prototype for: self randomize: true].	self calcTurtlesCount.! !!KedamaMorph methodsFor: 'setup' stamp: 'yo 6/1/2004 16:53' prior: 22537555!setup	"Subclasses should override this to setup the initial conditions of this StarSqueak world. The method should start with 'self clearAll'."	self clearAll.! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 6/17/2004 09:52' prior: 22543282!topEdgeMode	^ topEdgeMode.! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 1/20/2005 19:53' prior: 34036557!topEdgeMode: aSymbol	topEdgeMode := aSymbol asSymbol.	topEdgeMode == #wrap ifTrue: [		topEdgeModeMnemonic := 1.		^ self	].	topEdgeMode == #stick ifTrue: [		topEdgeModeMnemonic := 2.		^ self	].	(topEdgeMode == #bounce or: [topEdgeMode == #bouncing])  ifTrue: [		topEdgeModeMnemonic := 3.		^ self	].! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 9/16/2004 18:59' prior: 22543382!topEdgeModeMnemonic	^ topEdgeModeMnemonic.! !!KedamaMorph methodsFor: 'etoys' stamp: 'yo 6/2/2004 16:36' prior: 22548939!turtleCount	^ turtleCount.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/27/2004 16:30' prior: 34040874!turtlesCountOf: exampler	| array |	array := exampler turtles.	array ifNil: [^ 0].	^ array size.! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 9/9/2004 15:21' prior: 22540272!turtlesToDisplayAsString	^ String streamContents: [:strm |		strm nextPutAll: '#('.		turtlesToDisplay do: [:p |			strm nextPutAll: p externalName.			strm nextPut: Character space.		].		strm nextPutAll: ')'.	].! !!KedamaMorph methodsFor: 'event handling' stamp: 'yo 8/10/2004 12:23' prior: 22536434!wantsDroppedMorph: aMorph event: anEvent	^ aMorph isMemberOf: SketchMorph.! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 9/9/2004 15:08' prior: 22543876!wrapX	^ wrapX.! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 9/9/2004 15:08' prior: 22543963!wrapY	^ wrapY.! !!KedamaMorph methodsFor: 'private' stamp: 'yo 6/7/2004 12:04' prior: 22550917!zoom: src into: dst factor: f	src unhibernate.	dst unhibernate.	^ self primZoom: src bits into: dst bits srcWidth: src width height: src height multX: f y: f.! !!BookPageThumbnailMorph methodsFor: 'menus' stamp: 'dgd 8/30/2003 20:57' prior: 17695087!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'make a flex morph' translated selector: #makeFlexMorphFor: argument: aHandMorph.	flipOnClick		ifTrue: [aCustomMenu add: 'disable bookmark action' translated action: #toggleBookmark]		ifFalse: [aCustomMenu add: 'enable bookmark action' translated action: #toggleBookmark].	(bookMorph isKindOf: BookMorph)		ifTrue:			[aCustomMenu add: 'set page sound' translated action: #setPageSound:.			aCustomMenu add: 'set page visual' translated action: #setPageVisual:]! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 11:12' prior: 17688262!bookMorph	^bookMorph! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'tk 2/24/1999 00:01' prior: 17688376!computeThumbnail	| f scale |	self objectsInMemory.	f _ page imageForm.	scale _ (self height / f height).  "keep height invariant""(Sensor shiftPressed) ifTrue: [scale _ scale * 1.4]."	self form: (f magnify: f boundingBox by: scale@scale smoothing: 2).! !!BookPageThumbnailMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24' prior: 17694625!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'tk 2/24/1999 13:24' prior: 17688727!doPageFlip	"Flip to this page"	self objectsInMemory.	bookMorph ifNil: [^ self].	bookMorph goToPageMorph: page			transitionSpec: (self valueOfProperty: #transitionSpec).	(owner isKindOf: PasteUpMorph) ifTrue:		[owner cursor: (owner submorphs indexOf: self ifAbsent: [1])]! !!BookPageThumbnailMorph methodsFor: 'event handling' stamp: 'di 1/4/1999 12:19' prior: 17691805!handlesMouseDown: event	^ event shiftPressed or: [flipOnClick and: [event controlKeyPressed not]]! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'di 1/4/1999 12:52' prior: 17689096!inBook: book	bookMorph _ book! !!BookPageThumbnailMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:53' prior: 17694800!initialize	"initialize the state of the receiver"	| f |	super initialize.	""	flipOnClick _ false.		f _ Form extent: 60 @ 80 depth: Display depth.	f fill: f boundingBox fillColor: color.	self form: f! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/6/2000 16:36' prior: 17689218!makeFlexMorphFor: aHand	aHand grabMorph: (FlexMorph new originalMorph: page)! !!BookPageThumbnailMorph methodsFor: 'event handling' stamp: 'tk 7/25/2001 18:09' prior: 17691991!mouseDown: event	"turn the book to that page"	"May need to lie to it so mouseUp won't go to menu that may come up during fetch of a page in doPageFlip.  (Is this really true? --tk)"	self doPageFlip.! !!BookPageThumbnailMorph methodsFor: 'fileIn/Out' stamp: 'ar 4/10/2005 18:45' prior: 17692279!objectForDataStream: refStrm	"I am about to be written on an object file.  It would be bad to write a whole BookMorph out.  Store a string that is the url of the book or page in my inst var."	| clone bookUrl bb stem ind |	(bookMorph isString) & (page isString) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph isNil) & (page isString) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph isNil) & (page url notNil) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph isNil) & (page url isNil) ifTrue: [		self error: 'page should already have a url' translated.		"find page's book, and remember it"		"bookMorph _ "].		clone _ self clone.	(bookUrl _ bookMorph url)		ifNil: [bookUrl _ self valueOfProperty: #futureUrl].	bookUrl 		ifNil: [	bb _ RectangleMorph new.	"write out a dummy"			bb bounds: bounds.			refStrm replace: self with: bb.			^ bb]		ifNotNil: [clone instVarNamed: 'bookMorph' put: bookUrl].	page url ifNil: [			"Need to assign a url to a page that will be written later.			It might have bookmarks too.  Don't want to recurse deeply.  			Have that page write out a dummy morph to save its url on the server."		stem _ SqueakPage stemUrl: bookUrl.		ind _ bookMorph pages identityIndexOf: page.		page reserveUrl: stem,(ind printString),'.sp'].	clone instVarNamed: 'page' put: page url.	refStrm replace: self with: clone.	^ clone! !!BookPageThumbnailMorph methodsFor: 'fileIn/Out' stamp: 'ar 4/10/2005 18:45' prior: 17693761!objectsInMemory	"See if page or bookMorph need to be brought in from a server."	| bookUrl bk wld try |	bookMorph ifNil: ["fetch the page"		page isString ifFalse: [^ self].	"a morph"		try _ (SqueakPageCache atURL: page) fetchContents.		try ifNotNil: [page _ try].		^ self].	bookMorph isString ifTrue: [		bookUrl _ bookMorph.		(wld _ self world) ifNil: [wld _ Smalltalk currentWorld].		bk _ BookMorph isInWorld: wld withUrl: bookUrl.		bk == #conflict ifTrue: [			^ self inform: 'This book is already open in some other project' translated].		bk == #out ifTrue: [			(bk _ BookMorph new fromURL: bookUrl) ifNil: [^ self]].		bookMorph _ bk].	page isString ifTrue: [		page _ (bookMorph pages detect: [:pg | pg url = page] 					ifNone: [bookMorph pages first])].! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/17/97 17:30' prior: 17689387!page	^ page! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'di 1/4/1999 13:39' prior: 17689492!page: aMorph	page _ aMorph.	self computeThumbnail.	self setNameTo: aMorph externalName.	page fullReleaseCachedState.! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'di 1/4/1999 12:48' prior: 17689705!pageMorph: pageMorph inBook: book	page _ pageMorph.	bookMorph _ book! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'di 8/6/1998 23:45' prior: 17689866!pageNumber: n inBook: b	pageNumber _ n.	bookMorph _ b! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'di 12/20/1998 17:29' prior: 17690014!setPageSound: event	^ bookMorph menuPageSoundFor: self event: event! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'di 12/20/1998 17:29' prior: 17690176!setPageVisual: event	^ bookMorph menuPageVisualFor: self event: event! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'di 8/8/1998 14:06' prior: 17690338!smaller	self form: (self form copy: (0@0 extent: self form extent//2)).! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'di 12/23/1998 15:53' prior: 17690504!toggleBookmark	"Enable or disable sensitivity as a bookmark		enabled means that a normal click will cause a pageFlip		disabled means this morph can be picked up normally by the hand."	flipOnClick _ flipOnClick not! !!BookPageThumbnailMorph methodsFor: 'copying' stamp: 'tk 1/6/1999 19:35' prior: 17690802!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.page _ deepCopier references at: page ifAbsent: [page].bookMorph _ deepCopier references at: bookMorph ifAbsent: [bookMorph].! !!BookPageThumbnailMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:35' prior: 17691235!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."page _ page.		Weakly copied"pageNumber _ pageNumber veryDeepCopyWith: deepCopier."bookMorph _ bookMorph.		All weakly copied"flipOnClick _ flipOnClick veryDeepCopyWith: deepCopier. ! !!FlexMorph methodsFor: 'menus' stamp: 'dgd 8/30/2003 21:44' prior: 21142800!addCustomMenuItems: aCustomMenu hand: aHandMorph	"super addCustomMenuItems: aCustomMenu hand: aHandMorph."	aCustomMenu addLine.	aCustomMenu add: 'update from original' translated action: #updateFromOriginal.	aCustomMenu addList: {						{'border color...' translated. #changeBorderColor:}.						{'border width...' translated. #changeBorderWidth:}.						}.	aCustomMenu addLine.! !!FlexMorph methodsFor: 'accessing' stamp: 'di 1/11/1999 21:43' prior: 21139673!borderColor: aColor	borderColor _ aColor.	self updateFromOriginal! !!FlexMorph methodsFor: 'accessing' stamp: 'di 1/11/1999 21:43' prior: 21139809!borderWidth: width	borderWidth _ width asPoint.	self updateFromOriginal! !!FlexMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 18:52' prior: 21140100!changeBorderColor: evt	| aHand |	aHand _ evt ifNotNil: [evt hand] ifNil: [self primaryHand].	self changeColorTarget: self selector: #borderColor: originalColor: self borderColor hand: aHand.! !!FlexMorph methodsFor: 'as yet unclassified' stamp: 'di 8/30/2000 21:39' prior: 21140372!changeBorderWidth: evt	| handle origin aHand |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	handle _ HandleMorph new forEachPointDo:		[:newPoint | handle removeAllMorphs.		handle addMorph:			(LineMorph from: origin to: newPoint color: Color black width: 1).		self borderWidth: (newPoint - origin) r asInteger // 5].	aHand attachMorph: handle.	handle startStepping! !!FlexMorph methodsFor: 'drawing' stamp: 'di 1/11/1999 20:54' prior: 21141994!drawOn: aCanvas	originalForm _ nil.  "Aggressively uncache the originalForm"	^ super drawOn: aCanvas! !!FlexMorph methodsFor: 'geometry' stamp: 'di 1/11/1999 20:35' prior: 21142332!extent: newExtent	self loadOriginalForm.  "make sure it's not nil"	^ super extent: newExtent! !!FlexMorph methodsFor: 'accessing' stamp: 'di 1/11/1999 20:35' prior: 21139951!form	self loadOriginalForm.  "make sure it's not nil"	^ super form! !!FlexMorph methodsFor: 'drawing' stamp: 'di 1/11/1999 20:35' prior: 21142164!generateRotatedForm	self loadOriginalForm.  "make sure it's not nil"	^ super generateRotatedForm! !!FlexMorph methodsFor: 'initialization' stamp: 'di 1/11/1999 21:37' prior: 21142502!initialize	super initialize.	borderWidth _ 2@2.	borderColor _ Color black.! !!FlexMorph methodsFor: 'layout' stamp: 'di 1/11/1999 20:35' prior: 21142646!layoutChanged	self loadOriginalForm.  "make sure it's not nil"	^ super layoutChanged! !!FlexMorph methodsFor: 'as yet unclassified' stamp: 'di 1/11/1999 20:34' prior: 21140864!loadOriginalForm	originalForm ifNil: [self updateFromOriginal].! !!FlexMorph methodsFor: 'as yet unclassified' stamp: 'tk 2/25/1999 10:36' prior: 21141009!originalMorph	^ originalMorph! !!FlexMorph methodsFor: 'as yet unclassified' stamp: 'di 1/11/1999 20:19' prior: 21141119!originalMorph: aMorph	originalMorph _ aMorph.	scalePoint _ 0.25@0.25.	self updateFromOriginal.! !!FlexMorph methodsFor: 'caching' stamp: 'di 1/11/1999 19:44' prior: 21141681!releaseCachedState	"Clear cache of rotated, scaled Form."	originalForm _ Form extent: 10@10.  "So super hibernate won't have to work hard												but won't crash either."	super releaseCachedState.	rotatedForm _ nil.	originalForm _ nil.! !!FlexMorph methodsFor: 'as yet unclassified' stamp: 'di 1/11/1999 21:46' prior: 21141296!updateFromOriginal	| intermediateForm |	intermediateForm _ originalMorph imageForm offset: 0@0.	intermediateForm border: intermediateForm boundingBox		widthRectangle: (borderWidth corner: borderWidth+1)		rule: Form over fillColor: borderColor.	self form: intermediateForm.	originalMorph fullReleaseCachedState! !!MorphThumbnail methodsFor: 'menus' stamp: 'dgd 8/30/2003 21:53' prior: 25048093!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'reveal original morph' translated action: #revealOriginal.	aCustomMenu add: 'grab original morph' translated action: #grabOriginal.! !!MorphThumbnail methodsFor: 'as yet unclassified' stamp: 'sw 11/13/1998 09:53' prior: 25045389!computeThumbnail	"Assumption on entry:       The receiver's width represents the maximum width allowable.       The receiver's height represents the exact height desired."	| f scaleX scaleY |	f _ morphRepresented imageForm.	morphRepresented fullReleaseCachedState.	scaleY _ self height / f height.  "keep height invariant"	scaleX _ ((morphRepresented width * scaleY) <= self width)		ifTrue:			[scaleY]  "the usual case; same scale factor, to preserve aspect ratio"		ifFalse:			[self width / f width].	self form: (f magnify: f boundingBox by: (scaleX @ scaleY) smoothing: 2).	self extent: originalForm extent! !!MorphThumbnail methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28' prior: 25047670!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!MorphThumbnail methodsFor: 'as yet unclassified' stamp: 'sw 7/6/1998 22:08' prior: 25046094!grabOriginal	self primaryHand attachMorph: morphRepresented! !!MorphThumbnail methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:51' prior: 25047837!initialize	"initialize the state of the receiver"	| f |	super initialize.	""	f _ Form extent: 60 @ 80 depth: Display depth.	f fill: f boundingBox fillColor: color.	self form: f! !!MorphThumbnail methodsFor: 'naming' stamp: 'bf 3/31/1999 12:24' prior: 25048423!innocuousName	^ morphRepresented isNil		ifTrue: [super innocuousName]		ifFalse: [morphRepresented innocuousName]! !!MorphThumbnail methodsFor: 'parts bin' stamp: 'dgd 2/16/2003 21:37' prior: 25048614!isPartsDonor	"answer whether the receiver is PartsDonor"	^ self partRepresented isPartsDonor! !!MorphThumbnail methodsFor: 'parts bin' stamp: 'dgd 2/16/2003 21:40' prior: 25048783!isPartsDonor: aBoolean	"change the receiver's isPartDonor property"	self partRepresented isPartsDonor: aBoolean! !!MorphThumbnail methodsFor: 'thumbnail' stamp: 'jm 11/17/97 17:30' prior: 25049083!morphRepresented	^ morphRepresented! !!MorphThumbnail methodsFor: 'as yet unclassified' stamp: 'ar 10/7/2000 15:38' prior: 25046238!morphRepresented: aMorph	morphRepresented _ aMorph.	self computeThumbnail.! !!MorphThumbnail methodsFor: 'parts bin' stamp: 'ar 10/6/2000 22:46' prior: 25048970!partRepresented	^self morphRepresented! !!MorphThumbnail methodsFor: 'thumbnail' stamp: 'bf 3/31/1999 07:54' prior: 25049195!representativeNoTallerThan: maxHeight norWiderThan: maxWidth thumbnailHeight: thumbnailHeight	"Return a morph representing the receiver but which is no taller than aHeight.  If the receiver is already small enough, just return it, else return a MorphThumbnail companioned to the receiver, enforcing the maxWidth"	(self height <= maxHeight and: [self width <= maxWidth]) ifTrue: [^ self].	^ MorphThumbnail new		extent: maxWidth @ (thumbnailHeight min: self height);		morphRepresented: morphRepresented! !!MorphThumbnail methodsFor: 'as yet unclassified' stamp: 'md 10/22/2003 15:24' prior: 25046401!revealOriginal	((owner isKindOf: PasteUpMorph) and: [owner alwaysShowThumbnail]) 		ifTrue: [^Beeper beep].	morphRepresented owner isNil 		ifTrue: [^owner replaceSubmorph: self by: morphRepresented].	Beeper beep! !!MorphThumbnail methodsFor: 'as yet unclassified' stamp: 'sw 8/10/1998 07:05' prior: 25046700!smaller	self form: (self form copy: (0@0 extent: self form extent // 2))! !!MorphThumbnail methodsFor: 'copying' stamp: 'tk 1/8/1999 09:39' prior: 25046845!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.morphRepresented _ deepCopier references at: morphRepresented 		ifAbsent: [morphRepresented].! !!MorphThumbnail methodsFor: 'copying' stamp: 'tk 1/8/1999 09:39' prior: 25047237!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.morphRepresented _ morphRepresented.		"Weakly copied"! !!MethodMorph class methodsFor: 'as yet unclassified' stamp: 'dgd 8/26/2004 12:11' prior: 24452385!defaultNameStemForInstances	^ 'Method'! !!MethodMorph class methodsFor: 'new-morph participation' stamp: 'kfr 5/3/2000 12:52' prior: 24452516!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!MethodMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:25' prior: 24451310!initialize	"initialize the state of the receiver"	super initialize.	self useRoundedCorners! !!MethodMorph methodsFor: 'as yet unclassified' stamp: 'tk 9/7/2000 22:07' prior: 34201750!installRollBackButtons: target	| mine |	"If I don't already have such a button, put one in at the upper right.  Set its target to the furtherest enclosing book.  Send chooseAndRevertToVersion when clicked.  Stay in place via scrollBar install."	mine := self submorphNamed: #chooseAndRevertToVersion ifNone: [nil].	mine ifNil: [mine := SimpleButtonMorph new.		"mine height: mine height - 2."		mine label: 'Roll Back'; cornerStyle: #square.		mine color: Color white; borderColor: Color black.		mine actionSelector: #chooseAndRevertToVersion.		mine align: mine topRight with: (self findA: ScrollBar) topLeft +(1@1).		self addMorphFront: mine.		mine height: mine height - 5 "14"].	mine target: target.! !!MethodMorph methodsFor: 'scrolling' stamp: 'nk 4/28/2004 10:23' prior: 34202531!showScrollBar	"Copied down and modified to get rid of the ruinous comeToFront of the inherited version."	| scriptor |	(submorphs includes: scrollBar)		ifTrue: [^ self].	self vResizeScrollBar.	self privateAddMorph: scrollBar atIndex: 1.	retractableScrollBar		ifTrue:			["Bring the pane to the front so that it is fully visible"			"self comeToFront. -- thanks but no thanks"			(scriptor := self ownerThatIsA: ScriptEditorMorph)				ifNotNil:					[scriptor comeToFront]]		ifFalse: [self resetExtent]! !!MethodMorph methodsFor: 'stepping and presenter' stamp: 'sw 10/21/1999 09:41' prior: 24452070!step	model updateCodePaneIfNeeded! !!MethodMorph methodsFor: 'testing' stamp: 'sw 10/23/1999 23:03' prior: 24452175!stepTime	^ 3000! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'jm 6/17/1998 21:27' prior: 17682262!acceptSort	book acceptSortedContentsFrom: pageHolder.	self delete.! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'dgd 10/26/2003 13:21' prior: 17682423!addControls	| bb r aButton str |	r _ AlignmentMorph newRow color: Color transparent; borderWidth: 0; layoutInset: 0.	r wrapCentering: #center; cellPositioning: #topCenter; 			hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	bb _ SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (self wrapperFor: (bb label: 'Okay' translated;	actionSelector: #acceptSort)).	bb _ SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (self wrapperFor: (bb label: 'Cancel' translated;	actionSelector: #delete)).	r addTransparentSpacerOfSize: 8 @ 0.	r addMorphBack: (self wrapperFor: (aButton _ UpdatingThreePhaseButtonMorph checkBox)).	aButton		target: self;		actionSelector: #togglePartsBinStatus;		arguments: #();		getSelector: #getPartsBinStatus.	str _ StringMorph contents: 'Parts bin' translated.	r addMorphBack: (self wrapperFor: str lock).	self addMorphFront: r.! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/8/2000 22:49' prior: 17683449!book: aBookMorph morphsToSort: morphList	| innerBounds |	book _ aBookMorph.	pageHolder removeAllMorphs.	pageHolder addAllMorphs: morphList.	pageHolder extent: pageHolder width@pageHolder fullBounds height.	innerBounds _ Rectangle merging: (morphList collect: [:m | m bounds]).	pageHolder extent: innerBounds extent + pageHolder borderWidth + 6.! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/17/2003 19:56' prior: 17683891!changeExtent: aPoint 	self extent: aPoint.	pageHolder extent: self extent - self borderWidth! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'dgd 10/26/2003 13:22' prior: 17684076!closeButtonOnly	"Replace my default control panel with one that has only a close button."	| b r |	self firstSubmorph delete.  "remove old control panel"	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; layoutInset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r wrapCentering: #topLeft.	r addMorphBack: (b label: 'Close' translated; actionSelector: #delete).	self addMorphFront: r.! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/9/2000 21:11' prior: 17684657!columnWith: aMorph	^AlignmentMorph newColumn		color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		wrapCentering: #center;		cellPositioning: #topCenter;		layoutInset: 1;		addMorph: aMorph! !!BookPageSorterMorph methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:55' prior: 17686842!defaultBorderWidth"answer the default border width for the receiver"	^ 2! !!BookPageSorterMorph methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:55' prior: 17687001!defaultColor"answer the default color/fill style for the receiver"	^ Color lightGray! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 11:57' prior: 17684968!getPartsBinStatus	^pageHolder isPartsBin! !!BookPageSorterMorph methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:56' prior: 17687172!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: Display extent - 100;		 listDirection: #topToBottom;		 wrapCentering: #topLeft;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 layoutInset: 3.	pageHolder _ PasteUpMorph new behaveLikeHolder extent: self extent -self borderWidth.	pageHolder hResizing: #shrinkWrap.	"pageHolder cursor: 0."	"causes a walkback as of 5/25/2000"	self addControls.	self addMorphBack: pageHolder! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/17/97 16:46' prior: 17685098!pageHolder	^ pageHolder! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/9/2000 21:11' prior: 17685213!rowWith: aMorph	^AlignmentMorph newColumn		color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		wrapCentering: #center;		cellPositioning: #topCenter;		layoutInset: 1;		addMorph: aMorph! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 11:58' prior: 17685521!togglePartsBinStatus	pageHolder isPartsBin: pageHolder isPartsBin not! !!BookPageSorterMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:36' prior: 17685821!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals."super veryDeepFixupWith: deepCopier.book _ deepCopier references at: book ifAbsent: [book].! !!BookPageSorterMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:36' prior: 17686156!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."book _ book.		Weakly copied"pageHolder _ pageHolder veryDeepCopyWith: deepCopier.! !!BookPageSorterMorph methodsFor: 'dropping/grabbing' stamp: 'ar 9/18/2000 18:34' prior: 17686626!wantsToBeDroppedInto: aMorph	"Return true if it's okay to drop the receiver into aMorph"	^aMorph isWorldMorph "only into worlds"! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 12:10' prior: 17685682!wrapperFor: aMorph	^self columnWith: (self rowWith: aMorph)! !!BooklikeMorph class methodsFor: 'class initialization' stamp: 'sw 7/4/1998 15:59' prior: 17704437!initialize	"BooklikeMorph initialize"	PageFlipSoundOn _ true! !!BookMorph class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 10:31' prior: 17675453!initialize	FileList registerFileReader: self.	self registerInFlapsRegistry.	! !!BookMorph class methodsFor: 'url' stamp: 'tk 1/13/1999 09:07' prior: 17679632!alreadyInFromUrl: aUrl	"Does a bookMorph living in some world in this image represent the same set of server pages? If so, don't create another one.  It will steal pages from the existing one.  Go delete the first one."		self withAllSubclassesDo: [:cls |		cls allInstancesDo: [:aBook | 			 (aBook valueOfProperty: #url) = aUrl ifTrue: [				aBook world ifNotNil: [					self inform: 'This book is already open in some project'.					^ true]]]].	^ false! !!BookMorph class methodsFor: 'scripting' stamp: 'sw 3/6/1999 01:21' prior: 17678518!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book _ self new markAsPartsDonor.	book removeEverything; pageSize: 360@228; color: (Color gray: 0.9).	book borderWidth: 1; borderColor: Color black.	book beSticky.	book showPageControls; insertPage.	^ book! !!BookMorph class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 01:20' prior: 17678322!descriptionForPartsBin	^ self partName:	'Book'		categories:		#('Presentation')		documentation:	'Multi-page structures'! !!BookMorph class methodsFor: 'fileIn/Out' stamp: 'sd 2/6/2002 21:28' prior: 17676671!fileReaderServicesForFile: fullName suffix: suffix	^(suffix = 'bo') | (suffix = '*') 		ifTrue: [ Array with: self serviceLoadAsBook]		ifFalse: [#()]! !!BookMorph class methodsFor: 'url' stamp: 'sma 4/30/2000 10:36' prior: 17680160!grabURL: aURLString	"Create a BookMorph for this url and put it in the hand."	| book |	book _ self new fromURL: aURLString.	"If this book is already in, we will steal the pages out of it!!!!!!!!"	book goToPage: 1.	"install it"	HandMorph attach: book! !!BookMorph class methodsFor: 'url' stamp: 'tk 3/28/2000 13:30' prior: 17680485!isInWorld: aWorld withUrl: aUrl	| urls bks short |	"If a book with this url is in the that (current) world, return it.  Say if it is out or in another world."	urls _ OrderedCollection new.	bks _ OrderedCollection new.	aWorld allMorphsDo: [:aBook | (aBook isKindOf: BookMorph) ifTrue: [			bks add: aBook.			 (urls add: (aBook valueOfProperty: #url)) = aUrl ifTrue: [				aBook world == aWorld 					ifTrue: [^ aBook]]]]. 	"shortcut"			self withAllSubclassesDo: [:cls |		cls allInstancesDo: [:aBook | 			 (aBook valueOfProperty: #url) = aUrl ifTrue: [				aBook world == aWorld 					ifTrue: [^ aBook]					ifFalse: [						self inform: 'Book may be open in some other project'.						^ aBook]]]].	"if same book name, use it"	short _ (aUrl findTokens: '/') last.	urls withIndexDo: [:kk :ind | (kk findTokens: '/') last = short ifTrue: [			^ bks at: ind]].	^ #out! !!BookMorph class methodsFor: 'booksAsProjects' stamp: 'RAA 11/10/2000 11:26' prior: 17674775!makeBookOfProjects: aListOfProjects named: aString"BookMorph makeBookOfProjects: (Project allProjects select: [ :each | each world isMorph])"	| book pvm page |	book _ self new.	book setProperty: #transitionSpec toValue: {'silence'. #none. #none}.	aListOfProjects do: [ :each |		pvm _ ProjectViewMorph on: each.		page _ PasteUpMorph new addMorph: pvm; extent: pvm extent.		book insertPage: page pageSize: page extent	].	book goToPage: 1.	book deletePageBasic.	book setProperty: #nameOfThreadOfProjects toValue: aString.	book removeProperty: #transitionSpec.	book openInWorld! !!BookMorph class methodsFor: 'scripting' stamp: 'sw 6/13/2001 17:14' prior: 17678921!nextPageButton	"Answer a button that will take the user to the next page of its enclosing book"	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aButton; actionSelector: #nextOwnerPage; label: '->'; color: Color yellow.	aButton setNameTo: 'next'.	^ aButton! !!BookMorph class methodsFor: 'fileIn/Out' stamp: 'LEG 10/25/2001 00:06' prior: 17676902!openFromFile: fullName	"Reconstitute a Morph from the selected file, presumed to be represent	a Morph saved via the SmartRefStream mechanism, and open it in an	appropriate Morphic world"	| book aFileStream |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ FileStream oldFileNamed: fullName.	book _ BookMorph new.	book setProperty: #url toValue: aFileStream url.	book fromRemoteStream: aFileStream.	aFileStream close.	Smalltalk isMorphic 		ifTrue: [ActiveWorld addMorphsAndModel: book]		ifFalse:			[book isMorph ifFalse: [^self inform: 'Can only load a single morphinto an mvc project via this mechanism.'].			book openInWorld].	book goToPage: 1! !!BookMorph class methodsFor: 'scripting' stamp: 'sw 6/13/2001 17:13' prior: 17679271!previousPageButton	"Answer a button that will take the user to the previous page of its enclosing book"	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aButton; actionSelector: #previousOwnerPage; color: Color yellow; label: '<-'.	aButton setNameTo: 'previous'.	^ aButton! !!BookMorph class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 10:37' prior: 17675620!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(BookMorph		nextPageButton			'NextPage'		'A button that takes you to the next page')						forFlapNamed: 'PlugIn Supplies'.						cl registerQuad: #(BookMorph	previousPageButton 		'PreviousPage'	'A button that takes you to the previous page')						forFlapNamed: 'PlugIn Supplies'.						cl registerQuad: #(BookMorph	authoringPrototype		'Book'			'A multi-paged structure')						forFlapNamed: 'PlugIn Supplies'.						cl registerQuad: #(BookMorph		nextPageButton			'NextPage'		'A button that takes you to the next page')						forFlapNamed: 'Supplies'.						cl registerQuad: #(BookMorph	previousPageButton 		'PreviousPage'	'A button that takes you to the previous page')						forFlapNamed: 'Supplies'.						cl registerQuad: #(BookMorph	authoringPrototype		'Book'			'A multi-paged structure')						forFlapNamed: 'Supplies']! !!BookMorph class methodsFor: 'fileIn/Out' stamp: 'sd 2/1/2002 21:33' prior: 17677662!serviceLoadAsBook	^ SimpleServiceEntry 			provider: self 			label: 'load as book'			selector: #openFromFile:			description: 'open as bookmorph'! !!BookMorph class methodsFor: 'fileIn/Out' stamp: 'sd 2/1/2002 21:33' prior: 17677886!services	^ Array with: self serviceLoadAsBook! !!BookMorph methodsFor: 'submorphs-add/remove' stamp: 'tk 12/15/1998 14:32' prior: 17672539!abandon	"Like delete, but we really intend not to use this morph again.  Make the page cache release the page object."	| pg |	self delete.	pages do: [:aPage |		(pg _ aPage sqkPage) ifNotNil: [			pg contentsMorph == aPage ifTrue: [					pg contentsMorph: nil]]].! !!BookMorph methodsFor: 'layout' stamp: 'sw 10/18/97 18:03' prior: 17615317!acceptDroppingMorph: aMorph event: evt	"Allow the user to add submorphs just by dropping them on this morph."	(currentPage allMorphs includes: aMorph)		ifFalse: [currentPage addMorph: aMorph]! !!BookMorph methodsFor: 'sorting' stamp: 'ar 4/10/2005 18:42' prior: 17670150!acceptSortedContentsFrom: aHolder 	"Update my page list from the given page sorter."	| goodPages rejects toAdd sqPage |	goodPages := OrderedCollection new.	rejects := OrderedCollection new.	aHolder submorphs doWithIndex: 			[:m :i | 			toAdd := nil.			(m isKindOf: PasteUpMorph) ifTrue: [toAdd := m].			(m isKindOf: BookPageThumbnailMorph) 				ifTrue: 					[toAdd := m page.					m bookMorph == self 						ifFalse: 							["borrowed from another book. preserve the original"							toAdd := toAdd veryDeepCopy.							"since we came from elsewhere, cached strings are wrong"							self removeProperty: #allTextUrls.							self removeProperty: #allText]].			toAdd isString 				ifTrue: 					["a url"					toAdd := pages detect: [:aPage | aPage url = toAdd] ifNone: [toAdd]].			toAdd isString 				ifTrue: 					[sqPage := SqueakPageCache atURL: toAdd.					toAdd := sqPage contentsMorph 								ifNil: [sqPage copyForSaving	"a MorphObjectOut"]								ifNotNil: [sqPage contentsMorph]].			toAdd ifNil: [rejects add: m] ifNotNil: [goodPages add: toAdd]].	self newPages: goodPages.	goodPages isEmpty ifTrue: [self insertPage].	rejects notEmpty 		ifTrue: 			[self 				inform: rejects size printString , ' objects vanished in this process.']! !!BookMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 21:13' prior: 17615578!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' translated action: #previousPage.	subMenu add: 'next page' translated action: #nextPage.	subMenu add: 'goto page' translated action: #goToPage.	subMenu add: 'insert a page' translated action: #insertPage.	subMenu add: 'delete this page' translated action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue:			[subMenu add: 'hide page controls' translated action: #hidePageControls.			subMenu add: 'fewer page controls' translated action: #fewerPageControls]		ifFalse:			[subMenu add: 'show page controls' translated action: #showPageControls].	self isInFullScreenMode ifTrue: [		subMenu add: 'exit full screen' translated action: #exitFullScreen.	] ifFalse: [		subMenu add: 'show full screen' translated action: #goFullScreen.	].	subMenu addLine.	subMenu add: 'sound effect for all pages' translated action: #menuPageSoundForAll:.	subMenu add: 'sound effect this page only' translated action: #menuPageSoundForThisPage:.	subMenu add: 'visual effect for all pages' translated action: #menuPageVisualForAll:.	subMenu add: 'visual effect this page only' translated action: #menuPageVisualForThisPage:.	subMenu addLine.	subMenu add: 'sort pages' translated action: #sortPages:.	subMenu add: 'uncache page sorter' translated action: #uncachePageSorter.	(self hasProperty: #dontWrapAtEnd)		ifTrue: [subMenu add: 'wrap after last page' translated selector: #setWrapPages: argument: true]		ifFalse: [subMenu add: 'stop at last page' translated selector: #setWrapPages: argument: false].	subMenu addLine.	subMenu add: 'search for text' translated action: #textSearch.	(aHandMorph pasteBuffer class isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page' translated	action: #pasteBookPage].	subMenu add: 'send all pages to server' translated action: #savePagesOnURL.	subMenu add: 'send this page to server' translated action: #saveOneOnURL.	subMenu add: 'reload all from server' translated action: #reload.	subMenu add: 'copy page url to clipboard' translated action: #copyUrl.	subMenu add: 'keep in one file' translated action: #keepTogether.	subMenu add: 'save as new-page prototype' translated action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' translated action: #clearNewPagePrototype].	aMenu add: 'book...' translated subMenu: subMenu! !!BookMorph methodsFor: 'other' stamp: 'sw 6/6/2003 13:55' prior: 17663034!adjustCurrentPageForFullScreen	"Adjust current page to conform to whether or not I am in full-screen mode.  Also, enforce uniform page size constraint if appropriate"	self isInFullScreenMode		ifTrue:			[(currentPage hasProperty: #sizeWhenNotFullScreen) ifFalse:				[currentPage setProperty: #sizeWhenNotFullScreen toValue: currentPage extent].			currentPage extent: Display extent]		ifFalse:			[(currentPage hasProperty: #sizeWhenNotFullScreen) ifTrue:				[currentPage extent: (currentPage valueOfProperty: #sizeWhenNotFullScreen).				currentPage removeProperty: #sizeWhenNotFullScreen].			self uniformPageSize ifNotNilDo:				[:anExtent | currentPage extent: anExtent]].	(self valueOfProperty: #floatingPageControls) ifNotNilDo:		[:pc | pc isInWorld ifFalse: [pc openInWorld]]! !!BookMorph methodsFor: 'submorphs-accessing' stamp: 'tk 12/17/1998 11:19' prior: 17672036!allNonSubmorphMorphs	"Return a collection containing all morphs in this morph which are not currently in the submorph containment hierarchy.  Especially the non-showing pages in BookMorphs.    (As needed, make a variant of this that brings in all pages that are not in memory.)"	| coll |	coll _ OrderedCollection new.	pages do: [:pg |		pg isInMemory ifTrue: [			pg == currentPage ifFalse: [coll add: pg]]].	^ coll! !!BookMorph methodsFor: 'dropping/grabbing' stamp: '' prior: 17607065!allowSubmorphExtraction	^ false! !!BookMorph methodsFor: 'Postscript Canvases' stamp: '' prior: 17667160!asPostscript	^self asPostscriptPrintJob.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:03' prior: 17618180!bookmarkForThisPage	"If this book exists on a server, make the reference via a URL"	| bb url um |	(url _ self url) ifNil: [		bb _ SimpleButtonMorph new target: self.		bb actionSelector: #goToPageMorph:fromBookmark:.		bb label: 'Bookmark' translated.		bb arguments: (Array with: currentPage with: bb).		self primaryHand attachMorph: bb.		^ bb].	currentPage url ifNil: [currentPage saveOnURLbasic].	um _ URLMorph newForURL: currentPage url.	um setURL: currentPage url page: currentPage sqkPage.	(SqueakPage stemUrl: url) = (SqueakPage stemUrl: currentPage url) 		ifTrue: [um book: true]		ifFalse: [um book: url].  	"remember which book"	um isBookmark: true; label: 'Bookmark' translated.	um borderWidth: 1; borderColor: #raised.	um color: (Color r: 0.4 g: 0.8 b: 0.6).	self primaryHand attachMorph: um.	^ um! !!BookMorph methodsFor: 'navigation' stamp: 'ar 11/9/2000 20:37' prior: 17652276!buildFloatingPageControls	| pageControls |	pageControls _ self makePageControlsFrom: self fullControlSpecs.	pageControls borderWidth: 0; layoutInset: 4.	pageControls  setProperty: #pageControl toValue: true.	pageControls setNameTo: 'Page Controls'.	pageControls color: Color yellow.	^FloatingBookControlsMorph new addMorph: pageControls.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:04' prior: 17619071!buildThreadOfProjects	| thisPVM projectNames threadName |	projectNames _ pages collect: [ :each |		(thisPVM _ each findA: ProjectViewMorph) ifNil: [			nil		] ifNotNil: [			{thisPVM project name}.		].	].	projectNames _ projectNames reject: [ :each | each isNil].	threadName _ FillInTheBlank 		request: 'Please name this thread.' translated 		initialAnswer: (			self valueOfProperty: #nameOfThreadOfProjects ifAbsent: ['Projects on Parade' translated]		).	threadName isEmptyOrNil ifTrue: [^self].	InternalThreadNavigationMorph 		know: projectNames as: threadName;		openThreadNamed: threadName atIndex: nil.! !!BookMorph methodsFor: 'accessing' stamp: 'tk 12/12/2001 15:36' prior: 17604815!cardsOrPages	"The turnable and printable entities"	^ pages! !!BookMorph methodsFor: 'scripting' stamp: 'tk 9/7/2000 15:10' prior: 17667802!chooseAndRevertToVersion	| time which |	"Let the user choose an older version for all code in MethodMorphs in this book.  Run through that code and revert each one to that time."	self methodHolders.	"find them in me"	self methodHolderVersions.	which _ PopUpMenu withCaption: 					'Put all scripts in this book back the way they were at this time:' 				chooseFrom: #('leave as is'), VersionNames.	which <= 1 ifTrue: [^ self].	time _ VersionTimes at: which-1.	self revertToCheckpoint: time.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:05' prior: 17619762!copyUrl	"Copy this page's url to the clipboard"	| str |	str _ currentPage url ifNil: [str _ 'Page does not have a url.  Send page to server first.' translated].	Clipboard clipboardText: str asText.! !!BookMorph methodsFor: 'accessing' stamp: 'sw 10/16/1998 22:39' prior: 17604946!currentPage	(submorphs includes: currentPage) ifFalse: [currentPage _ nil].	^ currentPage! !!BookMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24' prior: 17607699!defaultColor	"answer the default color/fill style for the receiver"	^ Color white! !!BookMorph methodsFor: 'insert and delete' stamp: 'sw 10/13/2000 12:59' prior: 17611216!defaultNameStemForNewPages	"Answer a stem onto which to build default names for fresh pages"	^ 'page'! !!BookMorph methodsFor: 'halos and balloon help' stamp: 'ar 9/14/2000 16:46' prior: 17607436!defersHaloOnClickTo: aSubMorph	"If a cmd-click on aSubMorph would make it a preferred recipient of the halo, answer true"	^ currentPage notNil and:		[aSubMorph hasOwner: currentPage]	! !!BookMorph methodsFor: 'insert and delete' stamp: 'dgd 9/21/2003 17:45' prior: 17611399!deletePage	| message |	message _ 'Are you certain that youwant to delete this page andeverything that is on it? ' translated.	(self confirm: message) ifTrue: 			[self deletePageBasic].	! !!BookMorph methodsFor: 'insert and delete' stamp: 'di 9/7/1999 21:57' prior: 17611669!deletePageBasic	| thisPage |	thisPage _ self pageNumberOf: currentPage.	pages remove: currentPage.	currentPage delete.	currentPage _ nil.	pages isEmpty ifTrue: [^ self insertPage].	self goToPage: (thisPage min: pages size)! !!BookMorph methodsFor: 'other' stamp: 'RAA 8/23/2000 12:43' prior: 17663891!exitFullScreen	| floater |	self isInFullScreenMode ifFalse: [^self].	self setProperty: #fullScreenMode toValue: false.	floater _ self valueOfProperty: #floatingPageControls ifAbsent: [nil].	floater ifNotNil: [		floater delete.		self removeProperty: #floatingPageControls.	].	self position: 0@0.	self adjustCurrentPageForFullScreen.! !!BookMorph methodsFor: 'menu' stamp: 'md 9/27/2005 22:57' prior: 17620028!findText: wants	"Turn to the next page that has all of the strings mentioned on it.  Highlight where it is found.  allText and allTextUrls have been set.  Case insensitive search.	Resuming a search.  If container's text is still in the list and secondary keys are still in the page, (1) search rest of that container.  (2) search rest of containers on that page (3) pages till end of book, (4) from page 1 to this page again."	"Later sort wants so longest key is first"	| allText good thisWord here fromHereOn startToHere oldContainer oldIndex otherKeys strings |	allText _ self valueOfProperty: #allText ifAbsent: [#()].	here _ pages identityIndexOf: currentPage ifAbsent: [1].	fromHereOn _ here+1 to: pages size.	startToHere _ 1 to: here.		"repeat this page"	(self valueOfProperty: #searchKey ifAbsent: [#()]) = wants ifTrue: [		"does page have all the other keys?  No highlight if found!!"		otherKeys _ wants allButFirst.		strings _ allText at: here.		good _ true.		otherKeys do: [:searchString | "each key"			good ifTrue: [thisWord _ false.				strings do: [:longString |					(longString findString: searchString startingAt: 1 						caseSensitive: false) > 0 ifTrue: [							thisWord _ true]].				good _ thisWord]].		good ifTrue: ["all are on this page.  Look in rest for string again."			oldContainer _ self valueOfProperty: #searchContainer.			oldIndex _ self valueOfProperty: #searchOffset.			(self findText: (OrderedCollection with: wants first) inStrings: strings					startAt: oldIndex+1 container: oldContainer 				pageNum: here) ifTrue: [					self setProperty: #searchKey toValue: wants.					^ true]]]		ifFalse: [fromHereOn _ here to: pages size].	"do search this page"	"other pages"	allText ifNotEmpty: [		fromHereOn do: [:pageNum |			(self findText: wants inStrings: (allText at: pageNum) startAt: 1 container: nil 					pageNum: pageNum) 					ifTrue: [^ true]].		startToHere do: [:pageNum |			(self findText: wants inStrings: (allText at: pageNum) startAt: 1 container: nil 					pageNum: pageNum) 						ifTrue: [^ true]]].	"if fail"	self setProperty: #searchContainer toValue: nil.	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	^ false! !!BookMorph methodsFor: 'menu' stamp: 'gm 2/22/2003 13:17' prior: 17622327!findText: keys inStrings: rawStrings startAt: startIndex container: oldContainer pageNum: pageNum 	"Call once to search a page of the book.  Return true if found and highlight the text.  oldContainer should be NIL.  	(oldContainer is only non-nil when (1) doing a 'search again' and (2) the page is in memory and (3) keys has just one element.  oldContainer is a TextMorph.)"	| good thisWord index insideOf place container start wasIn strings old |	good := true.	start := startIndex.	strings := oldContainer ifNil: 					["normal case"					rawStrings]				ifNotNil: 					[(pages at: pageNum) isInMemory 						ifFalse: [rawStrings]						ifTrue: [(pages at: pageNum) allStringsAfter: oldContainer]].	keys do: 			[:searchString | 			"each key"			good 				ifTrue: 					[thisWord := false.					strings do: 							[:longString | 							(index := longString 										findString: searchString										startingAt: start										caseSensitive: false) > 0 								ifTrue: 									[thisWord not & (searchString == keys first) 										ifTrue: 											[insideOf := longString.											place := index].									thisWord := true].							start := 1].	"only first key on first container"					good := thisWord]].	good 		ifTrue: 			["all are on this page"			wasIn := (pages at: pageNum) isInMemory.			self goToPage: pageNum.			wasIn 				ifFalse: 					["search again, on the real current text.  Know page is in."					^self 						findText: keys						inStrings: ((pages at: pageNum) allStringsAfter: nil)						startAt: startIndex						container: oldContainer						pageNum: pageNum	"recompute"]].	(old := self valueOfProperty: #searchContainer) ifNotNil: 			[(old respondsTo: #editor) 				ifTrue: 					[old editor selectFrom: 1 to: 0.	"trying to remove the previous selection!!"					old changed]].	good 		ifTrue: 			["have the exact string object"			(container := oldContainer) ifNil: 					[container := self 								highlightText: keys first								at: place								in: insideOf]				ifNotNil: 					[container userString == insideOf 						ifFalse: 							[container := self 										highlightText: keys first										at: place										in: insideOf]						ifTrue: 							[(container isTextMorph) 								ifTrue: 									[container editor selectFrom: place to: keys first size - 1 + place.									container changed]]].			self setProperty: #searchContainer toValue: container.			self setProperty: #searchOffset toValue: place.			self setProperty: #searchKey toValue: keys.	"override later"			ActiveHand newKeyboardFocus: container.			^true].	^false! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/26/1999 22:39' prior: 17625008!forgetURLs	"About to save these objects in a new place.  Forget where stored now.  Must bring in all pages we don't have."| pg |pages do: [:aPage |	aPage yourself.	"bring it into memory"	(pg _ aPage valueOfProperty: #SqueakPage) ifNotNil: [		SqueakPageCache removeURL: pg url.		pg contentsMorph setProperty: #SqueakPage toValue: nil]].self setProperty: #url toValue: nil.! !!BookMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 23:10' prior: 17607857!fromRemoteStream: strm 	"Make a book from an index and a bunch of pages on a server.  NOT showing any page!!  Index and pages must live in the same directory.  If the book has moved, save the current correct urls for each of the pages.  Self must already have a url stored in property #url."	| remote dict bookUrl oldStem stem oldUrl endPart |	remote := strm fileInObjectAndCode.	bookUrl := (SqueakPage new)				url: (self valueOfProperty: #url);				url.	"expand a relative url"	oldStem := SqueakPage stemUrl: (remote second) url.	oldStem := oldStem copyUpToLast: $/.	stem := SqueakPage stemUrl: bookUrl.	stem := stem copyUpToLast: $/.	oldStem = stem 		ifFalse: 			["Book is in new directory, fix page urls"			2 to: remote size				do: 					[:ii | 					oldUrl := (remote at: ii) url.					endPart := oldUrl copyFrom: oldStem size + 1 to: oldUrl size.					(remote at: ii) url: stem , endPart]].	self initialize.	pages := OrderedCollection new.	2 to: remote size do: [:ii | pages add: (remote at: ii)].	currentPage		fullReleaseCachedState;		delete.	"the blank one"	currentPage := remote second.	dict := remote first.	self setProperty: #modTime toValue: (dict at: #modTime).	dict at: #allText		ifPresent: [:val | self setProperty: #allText toValue: val].	dict at: #allTextUrls		ifPresent: [:val | self setProperty: #allTextUrls toValue: val].	#(#color #borderWidth #borderColor #pageSize) 		with: #(#color: #borderWidth: #borderColor: #pageSize:)		do: [:key :sel | dict at: key ifPresent: [:val | self perform: sel with: val]].	^self! !!BookMorph methodsFor: 'initialization' stamp: 'ar 4/10/2005 18:42' prior: 17609497!fromURL: url	"Make a book from an index and a bunch of pages on a server.  NOT showing any page!!"	| strm |	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm isString ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	self setProperty: #url toValue: url.	self fromRemoteStream: strm.	^ self! !!BookMorph methodsFor: 'Postscript Canvases' stamp: 'mpw 9/13/1999 20:22' prior: 17667282!fullDrawPostscriptOn:aCanvas	^aCanvas fullDrawBookMorph:self.! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/26/1999 09:26' prior: 17625452!getAllText	"Collect the text for each page.  Just point at strings so don't have to recopy them.  Parallel array of urls for ID of pages.	allText = Array (pages size) of arrays (fields in it) of strings of text.	allTextUrls = Array (pages size) of urls or page numbers.	For any page that is out, text data came from .bo file on server.  	Is rewritten when one or all pages are stored."	| oldUrls oldStringLists allText allTextUrls aUrl which |	oldUrls _ self valueOfProperty: #allTextUrls ifAbsent: [#()].	oldStringLists _ self valueOfProperty: #allText ifAbsent: [#()].	allText _ pages collect: [:pg | OrderedCollection new].	allTextUrls _ Array new: pages size.	pages doWithIndex: [:aPage :ind | aUrl _ aPage url.  aPage isInMemory 		ifTrue: [(allText at: ind) addAll: (aPage allStringsAfter: nil).			aUrl ifNil: [aUrl _ ind].			allTextUrls at: ind put: aUrl]		ifFalse: ["Order of pages on server may be different.  (later keep up to date?)"			which _ oldUrls indexOf: aUrl.			allTextUrls at: ind put: aUrl.			which = 0 ifFalse: [allText at: ind put: (oldStringLists at: which)]]].	self setProperty: #allText toValue: allText.	self setProperty: #allTextUrls toValue: allTextUrls.	^ allText! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:06' prior: 17626731!getStemUrl	"Try to find the old place where this book was stored. Confirm with the 	user. Else ask for new place."	| initial pg url knownURL |	knownURL _ false.	initial _ ''.	(pg _ currentPage valueOfProperty: #SqueakPage)		ifNotNil: [pg contentsMorph == currentPage				ifTrue: [initial _ pg url.					knownURL _ true]].	"If this page has a url"	pages		doWithIndex: [:aPage :ind | initial isEmpty				ifTrue: [aPage isInMemory						ifTrue: [(pg _ aPage valueOfProperty: #SqueakPage)								ifNotNil: [initial _ pg url]]]].	"any page with a url"	initial isEmpty		ifTrue: [initial _ ServerDirectory defaultStemUrl , '1.sp'].	"A new legal place"	url _ knownURL		ifTrue: [initial]		ifFalse: [FillInTheBlank request: 'url of the place to store a typical page in this book.Must begin with file:// or ftp://' translated initialAnswer: initial].	^ SqueakPage stemUrl: url! !!BookMorph methodsFor: 'other' stamp: 'RAA 8/23/2000 12:42' prior: 17664301!goFullScreen	| floater |	self isInFullScreenMode ifTrue: [^self].	self setProperty: #fullScreenMode toValue: true.	self position: (currentPage topLeft - self topLeft) negated.	self adjustCurrentPageForFullScreen.	floater _ self buildFloatingPageControls.	self setProperty: #floatingPageControls toValue: floater.	floater openInWorld.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 12:59' prior: 17627683!goToPage	| pageNum |	pageNum _ FillInTheBlank request: 'Page?' translated initialAnswer: '0'.	pageNum isEmptyOrNil ifTrue: [^true].	self goToPage: pageNum asNumber.! !!BookMorph methodsFor: 'navigation' stamp: 'di 12/20/1998 10:18' prior: 17652693!goToPage: pageNumber	^ self goToPage: pageNumber transitionSpec: nil! !!BookMorph methodsFor: 'navigation' stamp: 'di 1/14/1999 12:07' prior: 17652833!goToPage: pageNumber transitionSpec: transitionSpec	| pageMorph |	pages isEmpty ifTrue: [^ self].	pageMorph _ (self hasProperty: #dontWrapAtEnd)		ifTrue: [pages atPin: pageNumber]		ifFalse: [pages atWrap: pageNumber].	^ self goToPageMorph: pageMorph transitionSpec: transitionSpec! !!BookMorph methodsFor: 'navigation' stamp: 'sw 11/8/2002 13:31' prior: 17653190!goToPage: pageNumber transitionSpec: transitionSpec runTransitionScripts: aBoolean	"Go the the given page number; use the transitionSpec supplied, and if the boolean parameter is true, run opening and closing scripts as appropriate"	| pageMorph |	pages isEmpty ifTrue: [^ self].	pageMorph _ (self hasProperty: #dontWrapAtEnd)		ifTrue: [pages atPin: pageNumber]		ifFalse: [pages atWrap: pageNumber].	^ self goToPageMorph: pageMorph transitionSpec: transitionSpec runTransitionScripts: aBoolean! !!BookMorph methodsFor: 'navigation' stamp: 'sw 11/8/2002 21:30' prior: 17653760!goToPageMorph: aMorph	"Set the given morph as the current page; run closing and opening scripts as appropriate"	self goToPageMorph: aMorph runTransitionScripts: true! !!BookMorph methodsFor: 'navigation' stamp: 'di 1/4/1999 12:37' prior: 17653997!goToPageMorph: aMorph fromBookmark: aBookmark	"This protocol enables sensitivity to a transitionSpec on the bookmark"		self goToPageMorph: aMorph		transitionSpec: (aBookmark valueOfProperty: #transitionSpec).! !!BookMorph methodsFor: 'navigation' stamp: 'sw 11/8/2002 13:34' prior: 17654280!goToPageMorph: aMorph runTransitionScripts: aBoolean	"Set the given morph as the current page.  If the boolean parameter is true, then opening and closing scripts will be run"	self goToPage: (pages identityIndexOf: aMorph ifAbsent: [^ self "abort"]) transitionSpec: nil runTransitionScripts: aBoolean! !!BookMorph methodsFor: 'navigation' stamp: 'dgd 2/22/2003 18:49' prior: 17654655!goToPageMorph: newPage transitionSpec: transitionSpec 	| pageIndex aWorld oldPageIndex ascending tSpec readIn |	pages isEmpty ifTrue: [^self].	self setProperty: #searchContainer toValue: nil.	"forget previous search"	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	pageIndex := pages identityIndexOf: newPage ifAbsent: [^self	"abort"].	readIn := newPage isInMemory not.	oldPageIndex := pages identityIndexOf: currentPage ifAbsent: [nil].	ascending := (oldPageIndex isNil or: [newPage == currentPage]) 				ifTrue: [nil]				ifFalse: [oldPageIndex < pageIndex].	tSpec := transitionSpec ifNil: 					["If transition not specified by requestor..."					newPage valueOfProperty: #transitionSpec						ifAbsent: 							[" ... then consult new page"							self transitionSpecFor: self	" ... otherwise this is the default"]].	self flag: #arNote.	"Probably unnecessary"	(aWorld := self world) ifNotNil: [self primaryHand releaseKeyboardFocus].	currentPage ifNotNil: [currentPage updateCachedThumbnail].	self currentPage notNil 		ifTrue: 			[(((pages at: pageIndex) owner isKindOf: TransitionMorph) 				and: [(pages at: pageIndex) isInWorld]) 					ifTrue: [^self	"In the process of a prior pageTurn"].			self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].			ascending ifNotNil: 					["Show appropriate page transition and start new page when done"					currentPage stopStepping.					(pages at: pageIndex) position: currentPage position.					^(TransitionMorph 						effect: tSpec second						direction: tSpec third						inverse: (ascending or: [transitionSpec notNil]) not) 							showTransitionFrom: currentPage							to: (pages at: pageIndex)							in: self							whenStart: [self playPageFlipSound: tSpec first]							whenDone: 								[currentPage									delete;									fullReleaseCachedState.								self insertPageMorphInCorrectSpot: (pages at: pageIndex).								self adjustCurrentPageForFullScreen.								self snapToEdgeIfAppropriate.								aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].								self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].								(aWorld := self world) ifNotNil: 										["WHY??"										aWorld displayWorld].								readIn 									ifTrue: 										[currentPage updateThumbnailUrlInBook: self url.										currentPage sqkPage computeThumbnail	"just store it"]]].			"No transition, but at least decommission current page"			currentPage				delete;				fullReleaseCachedState].	self insertPageMorphInCorrectSpot: (pages at: pageIndex).	self adjustCurrentPageForFullScreen.	self snapToEdgeIfAppropriate.	aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].	self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].	(aWorld := self world) ifNotNil: 			["WHY??"			aWorld displayWorld].	readIn 		ifTrue: 			[currentPage updateThumbnailUrl.			currentPage sqkPage computeThumbnail	"just store it"]! !!BookMorph methodsFor: 'navigation' stamp: 'dgd 2/22/2003 18:49' prior: 17657727!goToPageMorph: newPage transitionSpec: transitionSpec runTransitionScripts: aBoolean 	"Install the given page as the new current page; use the given transition spec, and if the boolean parameter is true, run closing and opening scripts on the outgoing and incoming players"	| pageIndex aWorld oldPageIndex ascending tSpec readIn |	pages isEmpty ifTrue: [^self].	self setProperty: #searchContainer toValue: nil.	"forget previous search"	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	pageIndex := pages identityIndexOf: newPage ifAbsent: [^self	"abort"].	readIn := newPage isInMemory not.	oldPageIndex := pages identityIndexOf: currentPage ifAbsent: [nil].	ascending := (oldPageIndex isNil or: [newPage == currentPage]) 				ifTrue: [nil]				ifFalse: [oldPageIndex < pageIndex].	tSpec := transitionSpec ifNil: 					["If transition not specified by requestor..."					newPage valueOfProperty: #transitionSpec						ifAbsent: 							[" ... then consult new page"							self transitionSpecFor: self	" ... otherwise this is the default"]].	self flag: #arNote.	"Probably unnecessary"	(aWorld := self world) ifNotNil: [self primaryHand releaseKeyboardFocus].	currentPage ifNotNil: [currentPage updateCachedThumbnail].	self currentPage notNil 		ifTrue: 			[(((pages at: pageIndex) owner isKindOf: TransitionMorph) 				and: [(pages at: pageIndex) isInWorld]) 					ifTrue: [^self	"In the process of a prior pageTurn"].			aBoolean 				ifTrue: [self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts]].			ascending ifNotNil: 					["Show appropriate page transition and start new page when done"					currentPage stopStepping.					(pages at: pageIndex) position: currentPage position.					^(TransitionMorph 						effect: tSpec second						direction: tSpec third						inverse: (ascending or: [transitionSpec notNil]) not) 							showTransitionFrom: currentPage							to: (pages at: pageIndex)							in: self							whenStart: [self playPageFlipSound: tSpec first]							whenDone: 								[currentPage									delete;									fullReleaseCachedState.								self insertPageMorphInCorrectSpot: (pages at: pageIndex).								self adjustCurrentPageForFullScreen.								self snapToEdgeIfAppropriate.								aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].								aBoolean 									ifTrue: [self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts]].								(aWorld := self world) ifNotNil: 										["WHY??"										aWorld displayWorld].								readIn 									ifTrue: 										[currentPage updateThumbnailUrlInBook: self url.										currentPage sqkPage computeThumbnail	"just store it"]]].			"No transition, but at least decommission current page"			currentPage				delete;				fullReleaseCachedState].	self insertPageMorphInCorrectSpot: (pages at: pageIndex).	self adjustCurrentPageForFullScreen.	self snapToEdgeIfAppropriate.	aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].	self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].	(aWorld := self world) ifNotNil: 			["WHY??"			aWorld displayWorld].	readIn 		ifTrue: 			[currentPage updateThumbnailUrl.			currentPage sqkPage computeThumbnail	"just store it"]! !!BookMorph methodsFor: 'navigation' stamp: 'dgd 2/21/2003 23:10' prior: 17661073!goToPageUrl: aUrl 	| pp short |	pp := pages detect: [:pg | pg url = aUrl] ifNone: [nil].	pp ifNil: 			[short := (aUrl findTokens: '/') last.			pp := pages detect: 							[:pg | 							pg url ifNil: [false] ifNotNil: [(pg url findTokens: '/') last = short]	"it moved"]						ifNone: [pages first]].	self goToPageMorph: pp! !!BookMorph methodsFor: 'navigation' stamp: 'sw 10/26/1998 15:41' prior: 17661472!goto: aPlayer	self goToPageMorph: aPlayer costume! !!BookMorph methodsFor: 'menu' stamp: 'gm 2/22/2003 13:17' prior: 17627916!highlightText: stringToHilite at: index in: insideOf 	"Find the container with this text and highlight it.  May not be able to do it for stringMorphs."	"Find the container with that text"	| container |	self 		allMorphsDo: [:sub | insideOf == sub userString ifTrue: [container := sub]].	container ifNil: 			[self 				allMorphsDo: [:sub | insideOf = sub userString ifTrue: [container := sub]]].	"any match"	container ifNil: [^nil].	"Order it highlighted"	(container isTextMorph) 		ifTrue: 			[container editor selectFrom: index to: stringToHilite size - 1 + index].	container changed.	^container! !!BookMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:09' prior: 17609896!initialize"initialize the state of the receiver"	super initialize.""	self setInitialState.	pages _ OrderedCollection new.	self showPageControls.	self class		turnOffSoundWhile: [self insertPage]! !!BookMorph methodsFor: 'parts bin' stamp: 'sw 8/2/2001 16:52' prior: 17667414!initializeToStandAlone	self initialize.	self removeEverything; pageSize: 360@228; color: (Color gray: 0.9).	self borderWidth: 1; borderColor: Color black.	self beSticky.	self showPageControls; insertPage.	^ self! !!BookMorph methodsFor: 'insert and delete' stamp: 'sw 10/12/97 21:48' prior: 17611975!insertPage: aPage pageSize: aPageSize	^ self insertPage: aPage pageSize: aPageSize atIndex: (pages size + 1)! !!BookMorph methodsFor: 'insert and delete' stamp: 'dgd 2/21/2003 23:10' prior: 17612162!insertPage: aPage pageSize: aPageSize atIndex: anIndex 	| sz predecessor |	sz := aPageSize 				ifNil: [currentPage isNil ifTrue: [pageSize] ifFalse: [currentPage extent]]				ifNotNil: [aPageSize].	aPage extent: sz.	(pages isEmpty | anIndex isNil or: [anIndex > pages size]) 		ifTrue: [pages add: aPage]		ifFalse: 			[anIndex <= 1 				ifTrue: [pages addFirst: aPage]				ifFalse: 					[predecessor := anIndex isNil 								ifTrue: [currentPage]								ifFalse: [pages at: anIndex].					self pages add: aPage after: predecessor]].	self goToPageMorph: aPage! !!BookMorph methodsFor: 'insert and delete' stamp: 'dgd 2/21/2003 23:11' prior: 17612809!insertPageColored: aColor 	"Insert a new page for the receiver, using the given color as its background color"	| sz newPage bw bc |	bc := currentPage isNil 				ifTrue: 					[sz := pageSize.					bw := 0.					Color blue muchLighter]				ifFalse: 					[sz := currentPage extent.					bw := currentPage borderWidth.					currentPage borderColor].	newPagePrototype ifNil: 			[newPage := (PasteUpMorph new)						extent: sz;						color: aColor.			newPage				borderWidth: bw;				borderColor: bc]		ifNotNil: [Cursor wait showWhile: [newPage := newPagePrototype veryDeepCopy]].	newPage setNameTo: self defaultNameStemForNewPages.	newPage vResizeToFit: false.	pages isEmpty 		ifTrue: [pages add: (currentPage := newPage)]		ifFalse: [pages add: newPage after: currentPage].	self nextPage! !!BookMorph methodsFor: 'insert and delete' stamp: 'ar 11/9/2000 21:10' prior: 17613684!insertPageLabel: labelString morphs: morphList	| m c labelAllowance |	self insertPage.	labelString ifNotNil:			[m _ (TextMorph new extent: currentPage width@20; contents: labelString).		m lock.		m position: currentPage position + (((currentPage width - m width) // 2) @ 5).		currentPage addMorph: m.		labelAllowance _ 40]		ifNil:			[labelAllowance _ 0].	"use a column to align the given morphs, then add them to the page"	c _ AlignmentMorph newColumn wrapCentering: #center; cellPositioning: #topCenter.	c addAllMorphs: morphList.	c position: currentPage position + (0 @ labelAllowance).	currentPage addAllMorphs: morphList.	^ currentPage! !!BookMorph methodsFor: 'navigation' stamp: 'RAA 11/20/2000 12:43' prior: 17661594!insertPageMorphInCorrectSpot: aPageMorph	self addMorphBack: (currentPage _ aPageMorph).! !!BookMorph methodsFor: 'insert and delete' stamp: 'dgd 2/21/2003 23:11' prior: 17614419!insertPageSilentlyAtEnd	"Create a new page at the end of the book.  Do not turn to it."	| sz newPage bw bc cc |	cc := currentPage isNil 				ifTrue: 					[sz := pageSize.					bw := 0.					bc := Color blue muchLighter.					color]				ifFalse: 					[sz := currentPage extent.					bw := currentPage borderWidth.					bc := currentPage borderColor.					currentPage color].	newPagePrototype ifNil: 			[newPage := (PasteUpMorph new)						extent: sz;						color: cc.			newPage				borderWidth: bw;				borderColor: bc]		ifNotNil: [Cursor wait showWhile: [newPage := newPagePrototype veryDeepCopy]].	newPage setNameTo: self defaultNameStemForNewPages.	newPage vResizeToFit: false.	pages isEmpty 		ifTrue: [pages add: (currentPage := newPage)	"had been none"]		ifFalse: [pages add: newPage after: pages last].	^newPage! !!BookMorph methodsFor: 'scripting' stamp: 'tk 9/8/2000 14:42' prior: 17668370!installRollBackButtons	| all |	"In each script in me, put a versions button it the upper right."	all _ IdentitySet new.	self allMorphsAndBookPagesInto: all.	all _ all select: [:mm | mm class = MethodMorph].	all do: [:mm | mm installRollBackButtons: self].! !!BookMorph methodsFor: 'menu' stamp: 'dgd 4/3/2006 13:08' prior: 17628591!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'Book' translated.	Preferences noviceMode		ifFalse:[aMenu addStayUpItem].	aMenu add: 'find...' translated action: #textSearch.	aMenu add: 'go to page...' translated action: #goToPage.	aMenu addLine.	aMenu addList: {		{'sort pages' translated.		#sortPages}.		{'uncache page sorter' translated.	#uncachePageSorter}}.	(self hasProperty: #dontWrapAtEnd)		ifTrue: [aMenu add: 'wrap after last page' translated selector: #setWrapPages: argument: true]		ifFalse: [aMenu add: 'stop at last page' translated selector: #setWrapPages: argument: false].	aMenu addList: {		{'make bookmark' translated.		#bookmarkForThisPage}.		{'make thumbnail' translated.		#thumbnailForThisPage}}.	aMenu addUpdating: #showingPageControlsString action: #toggleShowingOfPageControls.	aMenu addUpdating: #showingFullScreenString action: #toggleFullScreen.	aMenu addLine.	aMenu add: 'sound effect for all pages' translated action: #menuPageSoundForAll:.	aMenu add: 'sound effect this page only' translated action: #menuPageSoundForThisPage:.	aMenu add: 'visual effect for all pages' translated action: #menuPageVisualForAll:.	aMenu add: 'visual effect this page only' translated action: #menuPageVisualForThisPage:.	aMenu addLine.	(self primaryHand pasteBuffer class isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page' translated   action: #pasteBookPage].	aMenu add: 'save as new-page prototype' translated action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' translated action: #clearNewPagePrototype].	aMenu add: (self dragNDropEnabled ifTrue: ['close dragNdrop'] ifFalse: ['open dragNdrop']) translated			action: #toggleDragNDrop.	aMenu add: 'make all pages this size' translated action: #makeUniformPageSize.		aMenu		addUpdating: #keepingUniformPageSizeString		target: self		action: #toggleMaintainUniformPageSize.	aMenu addLine.	aMenu add: 'send all pages to server' translated action: #savePagesOnURL.	aMenu add: 'send this page to server' translated action: #saveOneOnURL.	aMenu add: 'reload all from server' translated action: #reload.	aMenu add: 'copy page url to clipboard' translated action: #copyUrl.	aMenu add: 'keep in one file' translated action: #keepTogether.	aMenu addLine.	aMenu add: 'load PPT images from slide #1' translated action: #loadImagesIntoBook.	aMenu add: 'background color for all pages...' translated action: #setPageColor.	aMenu add: 'make a thread of projects in this book' translated action: #buildThreadOfProjects.	aMenu popUpEvent: self world activeHand lastEvent in: self world! !!BookMorph methodsFor: 'other' stamp: 'RAA 8/23/2000 11:58' prior: 17664711!isInFullScreenMode	^self valueOfProperty: #fullScreenMode ifAbsent: [false]! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/2/1998 19:31' prior: 17631384!keepTogether	"Mark this book so that each page will not go into a separate file.  Do this when pages share referenes to a common Player.  Don't want many copies of that Player when bring in.  Do not write pages of book out.  Write the PasteUpMorph that the entire book lives in."	self setProperty: #keepTogether toValue: true.! !!BookMorph methodsFor: 'uniform page size' stamp: 'sw 3/3/2004 18:39' prior: 17672884!keepingUniformPageSizeString	"Answer a string characterizing whether I am currently maintaining uniform page size"	^ (self maintainsUniformPageSize		ifTrue: ['<yes>']		ifFalse: ['<no>']), 'keep all pages the same size' translated! !!BookMorph methodsFor: 'navigation' stamp: 'sw 8/4/97 12:05' prior: 17661751!lastPage	self goToPage: pages size! !!BookMorph methodsFor: 'menu' stamp: 'nk 6/12/2004 09:23' prior: 17631777!loadImagesIntoBook	"PowerPoint stores GIF presentations as individual slides named Slide1, Slide2, etc.	Load these into the book.  mjg 9/99"	| directory filenumber form newpage |	directory := ((StandardFileMenu oldFileFrom: FileDirectory default) 				ifNil: [^nil]) directory.	directory isNil ifTrue: [^nil].	"Start loading 'em up!!"	filenumber := 1.	[directory fileExists: 'Slide' , filenumber asString] whileTrue: 			[Transcript				show: 'Slide' , filenumber asString;				cr.			Smalltalk bytesLeft < 1000000 				ifTrue: 					["Make some room"					(self valueOfProperty: #url) isNil 						ifTrue: [self savePagesOnURL]						ifFalse: [self saveAsNumberedURLs]].			form := Form 						fromFileNamed: (directory fullNameFor: 'Slide' , filenumber asString).			newpage := PasteUpMorph new extent: form extent.			newpage addMorph: (World drawingClass withForm: form).			self pages addLast: newpage.			filenumber := filenumber + 1].	"After adding all, delete the first page."	self goToPage: 1.	self deletePageBasic.	"Save the book"	(self valueOfProperty: #url) isNil 		ifTrue: [self savePagesOnURL]		ifFalse: [self saveAsNumberedURLs]! !!BookMorph methodsFor: 'uniform page size' stamp: 'sw 6/6/2003 13:56' prior: 17673194!maintainsUniformPageSize	"Answer whether I am currently set up to maintain uniform page size"	^ self uniformPageSize notNil! !!BookMorph methodsFor: 'uniform page size' stamp: 'sw 6/6/2003 13:56' prior: 17673396!maintainsUniformPageSize: aBoolean	"Set the property governing whether I maintain uniform page size"	aBoolean		ifFalse:			[self removeProperty: #uniformPageSize]		ifTrue:			[self setProperty: #uniformPageSize toValue: currentPage extent]! !!BookMorph methodsFor: 'other' stamp: 'tk 2/19/2001 18:35' prior: 17664853!makeMinimalControlsWithColor: aColor title: aString	| aButton aColumn aRow but |	aButton _ SimpleButtonMorph new target: self; borderColor: Color black; 				color: aColor; borderWidth: 0.	aColumn _ AlignmentMorph newColumn.	aColumn color: aButton color; borderWidth: 0; layoutInset: 0.	aColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	aRow _ AlignmentMorph newRow.	aRow color: aButton color; borderWidth: 0; layoutInset: 0.	aRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	aRow addTransparentSpacerOfSize: 40@0.	aRow addMorphBack: (but _ aButton label: ' < ' ; actionSelector: #previousPage).		"copy is OK, since we just made it and it can't own any Players"	but setBalloonText: 'Go to previous page'.	aRow addTransparentSpacerOfSize: 82@0.	aRow addMorphBack: (StringMorph contents: aString) lock.	aRow addTransparentSpacerOfSize: 82@0.	aButton _ SimpleButtonMorph new target: self; borderColor: Color black; 				color: aColor; borderWidth: 0.	aRow addMorphBack: (but _ aButton label: ' > ' ; actionSelector: #nextPage).	but setBalloonText: 'Go to next page'.	aRow addTransparentSpacerOfSize: 40@0.	aColumn addMorphBack: aRow.	aColumn setNameTo: 'Page Controls'.		^ aColumn! !!BookMorph methodsFor: 'menu' stamp: 'nb 6/17/2003 12:25' prior: 17633004!makeUniformPageSize	"Make all pages be of the same size as the current page."	currentPage ifNil: [^ Beeper beep].	self resizePagesTo: currentPage extent.	newPagePrototype ifNotNil:		[newPagePrototype extent: currentPage extent]! !!BookMorph methodsFor: 'menu' stamp: 'em 3/30/2005 14:35' prior: 17633300!menuPageSoundFor: target event: evt	| tSpec menu |	tSpec _ self transitionSpecFor: target.	menu _ (MenuMorph entitled: 'Choose a sound(it is now ' translated, tSpec first translated, ')') defaultTarget: target.	SoundService default sampledSoundChoices do:		[:soundName |		menu add: soundName translated target: target			selector: #setProperty:toValue:			argumentList: (Array with: #transitionSpec								with: (tSpec copy at: 1 put: soundName; yourself))].	menu popUpEvent: evt in: self world! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 13:53' prior: 17633869!menuPageSoundForAll: evt	^ self menuPageSoundFor: self event: evt! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 13:55' prior: 17634001!menuPageSoundForThisPage: evt	currentPage ifNotNil:		[^ self menuPageSoundFor: currentPage event: evt]! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:39' prior: 17634172!menuPageVisualFor: target event: evt	| tSpec menu subMenu directionChoices |	tSpec _ self transitionSpecFor: target.	menu _ (MenuMorph entitled: ('Choose an effect(it is now {1})' translated format:{tSpec second asString translated})) defaultTarget: target.	TransitionMorph allEffects do:		[:effect |		directionChoices _ TransitionMorph directionsForEffect: effect.		directionChoices isEmpty		ifTrue: [menu add: effect asString translated target: target					selector: #setProperty:toValue:					argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: #none))]		ifFalse: [subMenu _ MenuMorph new.				directionChoices do:					[:dir |					subMenu add: dir asString translated target: target						selector: #setProperty:toValue:						argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: dir))].				menu add: effect asString translated subMenu: subMenu]].	menu popUpEvent: evt in: self world! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 17:16' prior: 17635237!menuPageVisualForAll: evt	^ self menuPageVisualFor: self event: evt! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 13:55' prior: 17635371!menuPageVisualForThisPage: evt	currentPage ifNotNil:		[^ self menuPageVisualFor: currentPage event: evt]! !!BookMorph methodsFor: 'scripting' stamp: 'tk 9/6/2000 23:31' prior: 17668700!methodHolderVersions	| arrayOfVersions vTimes strings |	"Create lists of times of older versions of all code in MethodMorphs in this book."	arrayOfVersions _ MethodHolders collect: [:mh | 		mh versions].	"equality, hash for MethodHolders?"	vTimes _ SortedCollection new.	arrayOfVersions do: [:versionBrowser |  		versionBrowser changeList do: [:cr | 			(strings _ cr stamp findTokens: ' ') size > 2 ifTrue: [				vTimes add: strings second asDate asSeconds + 						strings third asTime asSeconds]]].	VersionTimes _ Time condenseBunches: vTimes.	VersionNames _ Time namesForTimes: VersionTimes.! !!BookMorph methodsFor: 'scripting' stamp: 'tk 9/8/2000 14:41' prior: 17669374!methodHolders	| all |	"search for all scripts that are in MethodHolders.  These are the ones that have versions."	all _ IdentitySet new.	self allMorphsAndBookPagesInto: all.	all _ all select: [:mm | mm class = MethodMorph].	MethodHolders _ all asArray collect: [:mm | mm model].! !!BookMorph methodsFor: 'sorting' stamp: 'sw 3/5/1999 17:38' prior: 17671482!morphsForPageSorter	| i thumbnails |	'Assembling thumbnail images...'		displayProgressAt: self cursorPoint		from: 0 to: pages size		during:			[:bar | i _ 0.			thumbnails _ pages collect:				[:p | bar value: (i_ i+1).				pages size > 40 					ifTrue: [p smallThumbnailForPageSorter inBook: self]					ifFalse: [p thumbnailForPageSorter inBook: self]]].	^ thumbnails! !!BookMorph methodsFor: 'initialization' stamp: 'sw 6/24/1998 09:23' prior: 17610171!newPages: pageList	"Replace all my pages with the given list of BookPageMorphs.  After this call, currentPage may be invalid."	pages _ pages species new.	pages addAll: pageList! !!BookMorph methodsFor: 'initialization' stamp: 'jm 11/17/97 17:26' prior: 17610424!newPages: pageList currentIndex: index	"Replace all my pages with the given list of BookPageMorphs. Make the current page be the page with the given index."	pages _ pages species new.	pages addAll: pageList.	pages isEmpty ifTrue: [^ self insertPage].	self goToPage: index.! !!BookMorph methodsFor: 'navigation' stamp: 'dgd 2/21/2003 23:11' prior: 17661858!nextPage	currentPage isNil ifTrue: [^self goToPage: 1].	self goToPage: (self pageNumberOf: currentPage) + 1! !!BookMorph methodsFor: 'menu' stamp: 'sw 5/23/2000 02:14' prior: 17635542!pageControlsVisible	^ self hasSubmorphWithProperty: #pageControl! !!BookMorph methodsFor: 'accessing' stamp: 'tk 1/3/2001 08:54' prior: 17605105!pageNamed: aName	^ pages detect: [:p | p knownName = aName] ifNone: [nil]! !!BookMorph methodsFor: 'navigation' stamp: 'tk 12/24/1998 07:19' prior: 17662038!pageNumber	^ self pageNumberOf: currentPage! !!BookMorph methodsFor: 'accessing' stamp: 'tk 12/24/1998 07:27' prior: 17605249!pageNumberOf: aMorph	"Modified so that if the page IS in memory, other pages don't have to be brought in.  (This method may wrongly say a page is not here if pages has a tombstone (MorphObjectOut) and that tombstone would resolve to an object already in this image.  This is an unlikely case, and callers just have to tolerate it.)"	^ pages identityIndexOf: aMorph ifAbsent: [0]! !!BookMorph methodsFor: 'accessing' stamp: '' prior: 17605672!pages	^ pages! !!BookMorph methodsFor: 'accessing' stamp: 'tk 10/22/1998 15:47' prior: 17605758!pages: aMorphList	pages _ aMorphList asOrderedCollection.	"It is tempting to force the first page to be the current page.  But then, two pages might be shown at once!!  Just trust the copying mechanism and let currentPage be copied correctly. --Ted."! !!BookMorph methodsFor: 'printing' stamp: 'RAA 2/1/2001 17:41' prior: 17667700!pagesHandledAutomatically	^true! !!BookMorph methodsFor: 'menu' stamp: 'sw 5/14/1998 11:04' prior: 17635671!pasteBookPage	| aPage |	aPage _ self primaryHand objectToPaste.	self insertPage: aPage pageSize: aPage extent atIndex: ((pages indexOf: currentPage) - 1).	"self goToPageMorph: aPage"! !!BookMorph methodsFor: 'navigation' stamp: 'dgd 2/21/2003 23:11' prior: 17662154!previousPage	currentPage isNil ifTrue: [^self goToPage: 1].	self goToPage: (self pageNumberOf: currentPage) - 1! !!BookMorph methodsFor: 'menus' stamp: 'yo 7/2/2004 13:05' prior: 17651540!printPSToFile	"Ask the user for a filename and print this morph as postscript."	| fileName rotateFlag |	fileName _ ('MyBook') translated asFileName.	fileName _ FillInTheBlank request: 'File name? (".ps" will be added to end)' translated 			initialAnswer: fileName.	fileName isEmpty ifTrue: [^ Beeper beep].	(fileName endsWith: '.ps') ifFalse: [fileName _ fileName,'.ps'].	rotateFlag _ ((PopUpMenu labels:'portrait (tall)landscape (wide)' translated) 			startUpWithCaption: 'Choose orientation...' translated) = 2.	(FileStream newFileNamed: fileName asFileName)		nextPutAll: (DSCPostscriptCanvas morphAsPostscript: self rotated: rotateFlag); close.! !!BookMorph methodsFor: 'caching' stamp: 'tk 3/11/2002 12:05' prior: 17606549!releaseCachedState	"Release the cached state of all my pages."	super releaseCachedState.	self removeProperty: #allText.	"the cache for text search"	pages do: [:page | 		page == currentPage ifFalse: [page fullReleaseCachedState]].! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:14' prior: 17635924!reload	"Fetch the pages of this book from the server again.  For all pages that have not been modified, keep current ones.  Use new pages.  For each, look up in cache, if time there is equal to time of new, and its in, use the current morph.	Later do fancy things when a page has changed here, and also on the server."	| url onServer onPgs sq which |	(url _ self valueOfProperty: #url) ifNil: ["for .bo index file"	url _ FillInTheBlank 		request: 'url of the place where this book''s index is stored.Must begin with file:// or ftp://' translated		initialAnswer: (self getStemUrl, '.bo').	url notEmpty ifTrue: [self setProperty: #url toValue: url]				ifFalse: [^ self]].	onServer _ self class new fromURL: url.	"Later: test book times?"	onPgs _ onServer pages collect: [:out |		sq _ SqueakPageCache pageCache at: out url ifAbsent: [nil].		(sq notNil and: [sq contentsMorph isInMemory])			ifTrue: [((out sqkPage lastChangeTime > sq lastChangeTime) or: 					  [sq contentsMorph isNil]) 						ifTrue: [SqueakPageCache atURL: out url put: out sqkPage.							out]						ifFalse: [sq contentsMorph]]			ifFalse: [SqueakPageCache atURL: out url put: out sqkPage.				out]].	which _ (onPgs findFirst: [:pg | pg url = currentPage url]) max: 1.	self newPages: onPgs currentIndex: which.		"later stay at current page"	self setProperty: #modTime toValue: (onServer valueOfProperty: #modTime).	self setProperty: #allText toValue: (onServer valueOfProperty: #allText).	self setProperty: #allTextUrls toValue: (onServer valueOfProperty: #allTextUrls).! !!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:45' prior: 17610776!removeEverything	currentPage _ nil.	pages _ OrderedCollection new.	self removeAllMorphs! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:12' prior: 17637551!reserveUrls	"Save a dummy version of the book first, assign all pages URLs, write dummy files to reserve the url, and write the index.  Good when I have pages with interpointing bookmarks."	| stem |	(stem := self getStemUrl) isEmpty ifTrue: [^self].	pages doWithIndex: 			[:pg :ind | 			"does write the current page too"			pg url ifNil: [pg reserveUrl: stem , ind printString , '.sp']]	"self saveIndexOnURL."! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/25/1999 10:37' prior: 17638034!reserveUrlsIfNeeded	"See if this book needs to pre-allocate urls.  Harmless if have urls already.  Actually writes dummy files to reserve names."| baddies bad2 |pages size > 25 ifTrue: [^ self reserveUrls].baddies _ BookPageThumbnailMorph withAllSubclasses.bad2 _ FlexMorph withAllSubclasses.pages do: [:aPage |	aPage allMorphsDo: [:mm | 		(baddies includes: mm class) ifTrue: [^ self reserveUrls].		(bad2 includes: mm class) ifTrue: [			mm originalMorph class == aPage class ifTrue: [				^ self reserveUrls]]]].		! !!BookMorph methodsFor: 'other' stamp: 'sw 10/1/1998 13:40' prior: 17666157!resizePagesTo: anExtent	pages do:		[:aPage | aPage extent: anExtent]! !!BookMorph methodsFor: 'scripting' stamp: 'tk 9/7/2000 15:08' prior: 17669729!revertToCheckpoint: secsSince1901	| cngRecord |	"Put all scripts (that appear in MethodPanes) back to the way they were at an earlier time."	MethodHolders do: [:mh | 		cngRecord _ mh versions versionFrom: secsSince1901.		cngRecord ifNotNil: [			(cngRecord stamp: Utilities changeStamp) fileIn]].		"does not delete method if no earlier version"! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:12' prior: 17638627!saveAsNumberedURLs	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, name that page file by its page number.  Any pages that are already totally out will stay that way."	| stem list firstTime |	firstTime := (self valueOfProperty: #url) isNil.	stem := self getStemUrl.	"user must approve"	stem isEmpty ifTrue: [^self].	firstTime ifTrue: [self setProperty: #futureUrl toValue: stem , '.bo'].	self reserveUrlsIfNeeded.	pages doWithIndex: 			[:aPage :ind | 			"does write the current page too"			aPage isInMemory 				ifTrue: 					["not out now"					aPage presenter ifNotNil: [aPage presenter flushPlayerListCache].					aPage saveOnURL: stem , ind printString , '.sp']].	list := pages collect: [:aPage | aPage sqkPage prePurge].	"knows not to purge the current page"	list := (list select: [:each | each notNil]) asArray.	"do bulk become:"	(list collect: [:each | each contentsMorph]) 		elementsExchangeIdentityWith: (list 				collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).	self saveIndexOnURL.	self presenter ifNotNil: [self presenter flushPlayerListCache].	firstTime 		ifTrue: 			["Put a thumbnail into the hand"			URLMorph grabForBook: self.			self setProperty: #futureUrl toValue: nil	"clean up"]! !!BookMorph methodsFor: 'menu' stamp: 'ar 4/10/2005 18:42' prior: 17640062!saveIndexOfOnly: aPage	"Modify the index of this book on a server.  Read the index, modify the entry for just this page, and write back.  See saveIndexOnURL. (page file names must be unique even if they live in different directories.)"	| mine sf remoteFile strm remote pageURL num pre index after dict allText allTextUrls fName |	mine _ self valueOfProperty: #url.	mine ifNil: [^ self saveIndexOnURL].	Cursor wait showWhile: [strm _ (ServerFile new fullPath: mine)].	strm ifNil: [^ self saveIndexOnURL].	strm isString ifTrue: [^ self saveIndexOnURL].	strm exists ifFalse: [^ self saveIndexOnURL].	"write whole thing if missing"	strm _ strm asStream.	strm isString ifTrue: [^ self saveIndexOnURL].	remote _ strm fileInObjectAndCode.	dict _ remote first.	allText _ dict at: #allText ifAbsent: [nil].	"remote, not local"	allTextUrls _ dict at: #allTextUrls ifAbsent: [nil].	allText size + 1 ~= remote size ifTrue: [self error: '.bo size mismatch.  Please tell Ted what you just did to this book.' translated].	(pageURL _ aPage url) ifNil: [self error: 'just had one!!' translated].	fName _ pageURL copyAfterLast: $/.	2 to: remote size do: [:ii | 		((remote at: ii) url findString: fName startingAt: 1 						caseSensitive: false) > 0 ifTrue: [index _ ii].	"fast"		(remote at: ii) xxxReset].	index ifNil: ["new page, what existing page does it follow?"		num _ self pageNumberOf: aPage.		1 to: num-1 do: [:ii | (pages at: ii) url ifNotNil: [pre _ (pages at: ii) url]].		pre ifNil: [after _ remote size+1]			ifNotNil: ["look for it on disk, put me after"				pre _ pre copyAfterLast: $/.				2 to: remote size do: [:ii | 					((remote at: ii) url findString: pre startingAt: 1 								caseSensitive: false) > 0 ifTrue: [after _ ii+1]].				after ifNil: [after _ remote size+1]].		remote _ remote copyReplaceFrom: after to: after-1 with: #(1).		allText ifNotNil: [			dict at: #allText put: (allText copyReplaceFrom: after-1 to: after-2 with: #(())).			dict at: #allTextUrls put: (allTextUrls copyReplaceFrom: after-1 to: after-2 with: #(()))].		index _ after].	remote at: index put: (aPage sqkPage copyForSaving).	(dict at: #modTime ifAbsent: [0]) < Time totalSeconds ifTrue:		[dict at: #modTime put: Time totalSeconds].	allText ifNotNil: [		(dict at: #allText) at: index-1 put: (aPage allStringsAfter: nil).		(dict at: #allTextUrls) at: index-1 put: pageURL].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: remote.		"remoteFile close"].! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:12' prior: 17642701!saveIndexOnURL	"Make up an index to the pages of this book, with thumbnails, and store it on the server.  (aDictionary, aMorphObjectOut, aMorphObjectOut, aMorphObjectOut).  The last part corresponds exactly to what pages looks like when they are all out.  Each holds onto a SqueakPage, which holds a url and a thumbnail."	| dict list mine sf remoteFile urlList |	pages isEmpty ifTrue: [^self].	dict := Dictionary new.	dict at: #modTime put: Time totalSeconds.	"self getAllText MUST have been called at start of this operation."	dict at: #allText put: (self valueOfProperty: #allText).	#(#color #borderWidth #borderColor #pageSize) 		do: [:sel | dict at: sel put: (self perform: sel)].	self reserveUrlsIfNeeded.	"should already be done"	list := pages copy.	"paste dict on front below"	"Fix up the entries, should already be done"	list doWithIndex: 			[:out :ind | 			out isInMemory 				ifTrue: 					[(out valueOfProperty: #SqueakPage) ifNil: [out saveOnURLbasic].					list at: ind put: out sqkPage copyForSaving]].	urlList := list collect: [:ppg | ppg url].	self setProperty: #allTextUrls toValue: urlList.	dict at: #allTextUrls put: urlList.	list := (Array with: dict) , list.	mine := self valueOfProperty: #url.	mine ifNil: 			[mine := self getStemUrl , '.bo'.			self setProperty: #url toValue: mine].	sf := ServerDirectory new fullPath: mine.	Cursor wait showWhile: 			[remoteFile := sf fileNamed: mine.			remoteFile dataIsValid.			remoteFile fileOutClass: nil andObject: list			"remoteFile close"]! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:18' prior: 17644300!saveOnUrlPage: pageMorph	"Write out this single page in this book onto a server.  See savePagesOnURL.  (Don't compute the texts, only this page's is written.)"	| stem ind response rand newPlace dir |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.' translated.		^ self].	"Don't give the chance to put in a different place.  Assume named by number"	((self valueOfProperty: #url) isNil and: [pages first url notNil]) ifTrue: [		response _ (PopUpMenu labels: 'Old bookNew book sharing old pages' translated)				startUpWithCaption: 'Modify the old book, or make a newbook sharing its pages?' translated.		response = 2 ifTrue: [			"Make up new url for .bo file and confirm with user."  "Mark as shared"			[rand _ String new: 4.			1 to: rand size do: [:ii |				rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].			(newPlace _ self getStemUrl) isEmpty ifTrue: [^ self].			newPlace _ (newPlace copyUpToLast: $/), '/BK', rand, '.bo'.			dir _ ServerFile new fullPath: newPlace.			(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"			self setProperty: #url toValue: newPlace].		response = 0 ifTrue: [^ self]].	stem _ self getStemUrl.	"user must approve"	stem isEmpty ifTrue: [^ self].	ind _ pages identityIndexOf: pageMorph ifAbsent: [self error: 'where is the page?' translated].	pageMorph isInMemory ifTrue: ["not out now"			pageMorph saveOnURL: stem,(ind printString),'.sp'].	self saveIndexOfOnly: pageMorph.! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/12/1999 18:58' prior: 17645953!saveOneOnURL	"Write out this single page onto a server.  See savePagesOnURL.  (Don't compute the texts, only this page's is written.)"	^ self saveOnUrlPage: currentPage! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:20' prior: 17646190!savePagesOnURL	"Write out all pages in this book onto a server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are not in memory will stay that way.  The local disk could be the server."	| response list firstTime newPlace rand dir bookUrl |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.' translated.		^ self].	self getAllText.	"stored with index later"	response _ (PopUpMenu labels: 'Use page numbersType in file namesSave in a new place (using page numbers)Save in a new place (typing names)Save new book sharing old pages' translated)			startUpWithCaption: 'Each page will be a file on the server.  Do you want to page numbers be the names of the files? or name each one yourself?' translated.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].	response = 5 ifTrue: [		"Make up new url for .bo file and confirm with user."  "Mark as shared"		[rand _ String new: 4.		1 to: rand size do: [:ii |			rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].		(newPlace _ self getStemUrl) isEmpty ifTrue: [^ self].		newPlace _ (newPlace copyUpToLast: $/), '/BK', rand, '.bo'.		dir _ ServerFile new fullPath: newPlace.		(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"		self setProperty: #url toValue: newPlace.		self saveAsNumberedURLs. 		bookUrl _ self valueOfProperty: #url.		(SqueakPage stemUrl: bookUrl) = 			(SqueakPage stemUrl: currentPage url) ifTrue: [				bookUrl _ true].		"not a shared book"		(URLMorph grabURL: currentPage url) book: bookUrl.		^ self].	response = 0 ifTrue: [^ self]."self reserveUrlsIfNeeded.	Need two passes here -- name on one, write on second"pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage presenter ifNotNil: [aPage presenter flushPlayerListCache].		aPage saveOnURLbasic.		]].	"ask user if no url"list _ pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list _ (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).firstTime _ (self valueOfProperty: #url) isNil.self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].firstTime ifTrue: ["Put a thumbnail into the hand"	URLMorph grabForBook: self.	self setProperty: #futureUrl toValue: nil].	"clean up"! !!BookMorph methodsFor: 'accessing' stamp: 'mjg 9/28/1999 11:57' prior: 17606082!setAllPagesColor: aColor	"Set the color of all the pages to a new color"	self pages do: [:page | page color: aColor].! !!BookMorph methodsFor: 'other' stamp: 'sw 6/6/2003 17:21' prior: 17666291!setExtentFromHalo: anExtent	"The user has dragged the grow box such that the receiver's extent would be anExtent.  Do what's needed.  For a BookMorph, we assume any resizing attempt is a request that the book-page currently being viewed be resized accoringly; this will typically not affect unseen book pages, though there is a command that can be issued to harmonize all book-page sizes, and also an option to set that will maintain all pages at the same size no matter what."	currentPage isInWorld		ifFalse: "doubtful case mostly"			[super setExtentFromHalo: anExtent]		ifTrue:			[currentPage width: anExtent x.			currentPage height: (anExtent y - (self innerBounds height - currentPage height)).			self maintainsUniformPageSize ifTrue:				[self setProperty: #uniformPageSize toValue: currentPage extent]]! !!BookMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:07' prior: 17610941!setInitialState	self listDirection: #topToBottom;	  wrapCentering: #topLeft;	  hResizing: #shrinkWrap;	  vResizing: #shrinkWrap;	  layoutInset: 5.	pageSize _ 160 @ 300.	self enableDragNDrop! !!BookMorph methodsFor: 'menu' stamp: 'tk 8/13/1998 12:09' prior: 17649053!setNewPagePrototype	"Record the current page as the prototype to be copied when inserting new pages."	currentPage ifNotNil:		[newPagePrototype _ currentPage veryDeepCopy].! !!BookMorph methodsFor: 'menu' stamp: 'sw 9/6/2000 18:43' prior: 17649292!setPageColor	"Get a color from the user, then set all the pages to that color"	self currentPage ifNil: [^ self].	ColorPickerMorph new		choseModalityFromPreference;		sourceHand: self activeHand;		target: self;		selector: #setAllPagesColor:;		originalColor: self currentPage color;		putUpFor: self near: self fullBoundsInWorld! !!BookMorph methodsFor: 'navigation' stamp: 'di 1/14/1999 12:20' prior: 17662337!setWrapPages: doWrap	doWrap		ifTrue: [self removeProperty: #dontWrapAtEnd]		ifFalse: [self setProperty: #dontWrapAtEnd toValue: true].! !!BookMorph methodsFor: 'navigation' stamp: 'sw 5/23/2000 13:11' prior: 17662545!showMoreControls	self currentEvent shiftPressed		ifTrue:			[self hidePageControls]		ifFalse:			[self showPageControls: self fullControlSpecs]! !!BookMorph methodsFor: 'menu commands' stamp: 'di 1/4/1999 13:52' prior: 17651386!sortPages	currentPage ifNotNil: [currentPage updateCachedThumbnail].	^ super sortPages! !!BookMorph methodsFor: 'sorting' stamp: 'di 1/4/1999 12:12' prior: 17671922!sortPages: evt	^ self sortPages! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 12:58' prior: 17649692!textSearch	"search the text on all pages of this book"	| wanted wants list str |	list _ self valueOfProperty: #searchKey ifAbsent: [#()].	str _ String streamContents: [:strm | 			list do: [:each | strm nextPutAll: each; space]].	wanted _ FillInTheBlank request: 'words to search for.  Order is not important.Beginnings of words are OK.' translated		initialAnswer: str.	wants _ wanted findTokens: Character separators.	wants isEmpty ifTrue: [^ self].	self getAllText.		"save in allText, allTextUrls"	^ self findText: wants	"goes to the page and highlights the text"! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:14' prior: 17650334!textSearch: stringWithKeys 	"search the text on all pages of this book"	| wants |	wants := stringWithKeys findTokens: Character separators.	wants isEmpty ifTrue: [^self].	self getAllText.	"save in allText, allTextUrls"	^self findText: wants	"goes to the page and highlights the text"! !!BookMorph methodsFor: 'menu' stamp: 'di 1/4/1999 12:49' prior: 17650687!thumbnailForThisPage	self primaryHand attachMorph:		(currentPage thumbnailForPageSorter pageMorph: currentPage inBook: self)! !!BookMorph methodsFor: 'menu' stamp: 'RAA 8/23/2000 12:20' prior: 17650879!toggleFullScreen	self isInFullScreenMode		ifTrue:	[self exitFullScreen]		ifFalse:	[self goFullScreen]! !!BookMorph methodsFor: 'uniform page size' stamp: 'sw 6/6/2003 13:57' prior: 17673716!toggleMaintainUniformPageSize	"Toggle whether or not the receiver should maintain uniform page size"	self maintainsUniformPageSize: self maintainsUniformPageSize not! !!BookMorph methodsFor: 'menu' stamp: 'sw 5/23/2000 02:18' prior: 17651047!toggleShowingOfPageControls	self pageControlsVisible		ifTrue:	[self hidePageControls]		ifFalse:	[self showPageControls]! !!BookMorph methodsFor: 'navigation' stamp: 'di 12/21/1998 11:15' prior: 17662762!transitionSpecFor: aMorph	^ aMorph valueOfProperty: #transitionSpec  " check for special propety"		ifAbsent: [Array with: 'camera'  " ... otherwise this is the default"						with: #none						with: #none]! !!BookMorph methodsFor: 'menu' stamp: 'di 12/23/1998 14:55' prior: 17651234!uncachePageSorter	pages do: [:aPage | aPage removeProperty: #cachedThumbnail].! !!BookMorph methodsFor: 'uniform page size' stamp: 'sw 6/6/2003 13:57' prior: 17673960!uniformPageSize	"Answer the uniform page size to maintain, or nil if the option is not set"	^ self valueOfProperty: #uniformPageSize ifAbsent: [nil]! !!BookMorph methodsFor: 'copying' stamp: 'jm 7/1/97 17:06' prior: 17606850!updateReferencesUsing: aDictionary	super updateReferencesUsing: aDictionary.	pages do: [:page |		page allMorphsDo: [:m | m updateReferencesUsing: aDictionary]].! !!BookMorph methodsFor: 'accessing' stamp: 'tk 12/16/1998 12:05' prior: 17606272!userString	"Do I have a text string to be searched on?"	| list |	self getAllText.	list _ OrderedCollection new.	(self valueOfProperty: #allText ifAbsent: #()) do: [:aList |		list addAll: aList].	^ list! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/30/1998 10:38' prior: 17607175!wantsDroppedMorph: aMorph event: evt	(currentPage bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifFalse: [^ false].	^ super wantsDroppedMorph: aMorph event: evt! !!StoryboardBookMorph class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 12:53' prior: 31017628!descriptionForPartsBin	^ self partName:	'Storyboard'		categories:		#('Presentation')		documentation:	'A storyboard authoring tool'! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:37' prior: 31014739!changeTiltFactor: x	currentPage changeTiltFactor: x.	panAndTiltFactor _ x.! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:37' prior: 31014909!changeZoomFactor: x	currentPage changeZoomFactor: x.	zoomFactor _ x.! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:38' prior: 31015071!getTiltFactor	^panAndTiltFactor ifNil: [panAndTiltFactor _ 0.5].! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:38' prior: 31015228!getZoomFactor	^zoomFactor ifNil: [zoomFactor _ 0.5]! !!StoryboardBookMorph methodsFor: 'initialization' stamp: 'RAA 12/1/2000 15:22' prior: 31016134!initialize	newPagePrototype _ ZoomAndScrollMorph new extent: Display extent // 3.	zoomController _ ZoomAndScrollControllerMorph new			setBalloonText: 'Drag in here to zoom, tilt and pan the page above'.	super initialize.	self addMorphBack: zoomController.	alansSliders _ {		{#changeTiltFactor: . #getTiltFactor . 'Pan and tilt sensitivity'}.		{#changeZoomFactor: . #getZoomFactor . 'Zoom sensitivity'}.	} collect: [ :sData |		{			SimpleSliderMorph new				extent: 150@10;				color: Color orange;				sliderColor: Color gray;				target: self; 				actionSelector: sData first;				setBalloonText: sData third;				adjustToValue: (self perform: sData second).			sData second		}	].	alansSliders do: [ :each | self addMorphBack: each first]! !!StoryboardBookMorph methodsFor: 'navigation' stamp: 'sw 7/25/2003 16:47' prior: 31016973!insertPageMorphInCorrectSpot: aPageMorph	"Insert the page morph at the correct spot"		| place |	place _ submorphs size > 1 ifTrue: [submorphs second] ifFalse: [submorphs first].	"Old architecture had a tiny spacer morph as the second morph; now architecture does not"	self addMorph: (currentPage _ aPageMorph) behind: place.	self changeTiltFactor: self getTiltFactor.	self changeZoomFactor: self getZoomFactor.	zoomController target: currentPage.! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:41' prior: 31015372!offsetX	^currentPage offsetX! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:41' prior: 31015493!offsetX: aNumber	currentPage offsetX: aNumber! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:41' prior: 31015631!offsetY	^currentPage offsetY! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:41' prior: 31015752!offsetY: aNumber	currentPage offsetY: aNumber! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:35' prior: 31015890!scale	^currentPage scale! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:26' prior: 31016007!scale: aValue	currentPage scale: aValue! !!BookMorph class methodsFor: 'initialize-release' stamp: 'asm 4/11/2003 12:31' prior: 17678019!unload	"Unload the receiver from global registries"	self environment		at: #FileList		ifPresent: [:cl | cl unregisterFileReader: self].	self environment		at: #Flaps		ifPresent: [:cl | cl unregisterQuadsWithReceiver: self]! !!BooklikeMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/4/1998 16:43' prior: 17704173!turnOffSoundWhile: aBlock	"Turn off page flip sound during the given block."	| old |	old _ PageFlipSoundOn.	PageFlipSoundOn _ false.	aBlock value.	PageFlipSoundOn _ old! !!BooklikeMorph methodsFor: 'misc' stamp: 'dgd 8/30/2003 21:13' prior: 17698043!addBookMenuItemsTo: aCustomMenu hand: aHandMorph	(self hasSubmorphWithProperty: #pageControl)		ifTrue: [aCustomMenu add: 'hide page controls' translated action: #hidePageControls]		ifFalse: [aCustomMenu add: 'show page controls' translated action: #showPageControls]! !!BooklikeMorph methodsFor: 'menus' stamp: 'sw 7/4/1998 17:36' prior: 17697694!addCustomMenuItems: aCustomMenu hand: aHandMorph	"This factoring allows subclasses to have different menu yet still use the super call for the rest of the metamenu."	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self addBookMenuItemsTo: aCustomMenu hand: aHandMorph! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 6/6/2003 14:10' prior: 17699414!addPageControlMorph: aMorph	"Add the morph provided as a page control, at the appropriate place"	aMorph setProperty: #pageControl toValue: true.	self addMorph: aMorph asElementNumber: self indexForPageControls! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 15:39' prior: 17696590!clearNewPagePrototype	newPagePrototype _ nil! !!BooklikeMorph methodsFor: 'e-toy support' stamp: 'sw 8/11/1998 16:51' prior: 17696364!currentPlayerDo: aBlock	| aPlayer aPage |	(aPage _ self currentPage) ifNil: [^ self].	(aPlayer _ aPage player) ifNotNil:		[aBlock value: aPlayer]! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 5/23/2000 13:07' prior: 17699704!fewerPageControls	self currentEvent shiftPressed		ifTrue:			[self hidePageControls]		ifFalse:			[self showPageControls: self shortControlSpecs]! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 15:40' prior: 17696712!firstPage	self goToPage: 1! !!BooklikeMorph methodsFor: 'page controls' stamp: 'yo 1/14/2005 19:25' prior: 17699929!fullControlSpecs	^ {		#spacer.		#variableSpacer.		{'-'.		#deletePage.				'Delete this page' translated}.		#spacer.		{'«'.		#firstPage.				'First page' translated}.		#spacer.		{'<'. 		#previousPage.			'Previous page' translated}.		#spacer.		{'·'.		#invokeBookMenu. 		'Click here to get a menu of options for this book.' translated}.		#spacer.		{'>'.		#nextPage.				'Next page' translated}.		#spacer.		{ '»'.		#lastPage.				'Final page' translated}.		#spacer.		{'+'.		#insertPage.				'Add a new page after this one' translated}.		#variableSpacer.		{'³'.		#fewerPageControls.	'Fewer controls' translated}}! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 16:12' prior: 17700632!hidePageControls	"Delete all submorphs answering to the property #pageControl"	self deleteSubmorphsWithProperty: #pageControl! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 6/6/2003 17:00' prior: 17700835!indexForPageControls	"Answer which submorph should hold the page controls"	^ (submorphs size > 0 and: [submorphs first hasProperty: #header])		ifTrue:	[2]		ifFalse:	[1]! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 17:18' prior: 17696815!insertPage	self insertPageColored: self color! !!BooklikeMorph methodsFor: 'page controls' stamp: 'tk 2/19/2001 18:34' prior: 17701085!makePageControlsFrom: controlSpecs	"From the controlSpecs, create a set of page control and return them -- this method does *not* add the controls to the receiver."	| c col row b lastGuy |	c _ (color saturation > 0.1) ifTrue: [color slightlyLighter] ifFalse: [color slightlyDarker].	col _ AlignmentMorph newColumn.	col color: c; borderWidth: 0; layoutInset: 0.	col hResizing: #spaceFill; vResizing: #shrinkWrap; extent: 5@5.	row _ AlignmentMorph newRow.	row color: c; borderWidth: 0; layoutInset: 0.	row hResizing: #spaceFill; vResizing: #shrinkWrap; extent: 5@5.	controlSpecs do: [:spec |		spec == #spacer			ifTrue:				[row addTransparentSpacerOfSize: (10 @ 0)]			ifFalse:				[spec == #variableSpacer					ifTrue:						[row addMorphBack: AlignmentMorph newVariableTransparentSpacer]					ifFalse:						[b _ SimpleButtonMorph new target: self; borderWidth: 1; 								borderColor: Color veryLightGray; color: c.						b label: spec first;						actionSelector: spec second;						borderWidth: 0;	 					setBalloonText: spec third.						row addMorphBack: b.						(((lastGuy _ spec last asLowercase) includesSubString: 'menu') or:								[lastGuy includesSubString: 'designations'])							ifTrue: [b actWhen: #buttonDown]]]].  "pop up menu on mouseDown"		col addMorphBack: row.	^ col! !!BooklikeMorph methodsFor: 'misc' stamp: 'ar 10/10/2000 16:09' prior: 17698381!move	(owner isWorldMorph and:[self isSticky not]) ifTrue: [self activeHand grabMorph: self]! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 15:36' prior: 17698540!pageSize	^ pageSize! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 16:51' prior: 17698628!pageSize: aPoint	pageSize _ aPoint! !!BooklikeMorph methodsFor: 'misc' stamp: 'gk 2/24/2004 08:27' prior: 17698731!playPageFlipSound: soundName	self presenter ifNil: [^ self].  "Avoid failures when called too early"	PageFlipSoundOn  "mechanism to suppress sounds at init time"			ifTrue: [self playSoundNamed: soundName].! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 6/6/2003 22:44' prior: 17702468!setEventHandlerForPageControls: controls	"Set the controls' event handler if appropriate.  Default is to let the tool be dragged by the controls"	controls eventHandler: (EventHandler new on: #mouseDown send: #move to: self)! !!BooklikeMorph methodsFor: 'page controls' stamp: 'dgd 9/19/2003 11:35' prior: 17702772!shortControlSpecs^ {		#spacer.		#variableSpacer.		{'<'. 		#previousPage.			'Previous page' translated}.		#spacer.		{'·'.		#invokeBookMenu. 		'Click here to get a menu of options for this book.' translated}.		#spacer.		{'>'.		#nextPage.				'Next page' translated}.		#spacer.		#variableSpacer.		{'³'.		#showMoreControls.		'More controls' translated}}! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 3/2/1999 15:01' prior: 17703211!showPageControls	self showPageControls: self shortControlSpecs! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 6/6/2003 13:58' prior: 17703350!showPageControls: controlSpecs  	"Remove any existing page controls, and add fresh controls at the top of the receiver (or in position 2 if the receiver's first submorph is one with property #header).  Add a single column of controls."	| pageControls column |	self hidePageControls.	column _ AlignmentMorph newColumn beTransparent.	pageControls _ self makePageControlsFrom: controlSpecs.	pageControls borderWidth: 0; layoutInset: 4.	pageControls beSticky.	pageControls setNameTo: 'Page Controls'.	self setEventHandlerForPageControls: pageControls.	column addMorphBack: pageControls.	self addPageControlMorph: column! !!BooklikeMorph methodsFor: 'misc' stamp: 'dgd 9/19/2003 11:04' prior: 17699009!showingFullScreenString	^ (self isInFullScreenMode		ifTrue: ['exit full screen']		ifFalse: ['show full screen']) translated! !!BooklikeMorph methodsFor: 'misc' stamp: 'dgd 9/19/2003 11:04' prior: 17699204!showingPageControlsString	^ (self pageControlsVisible		ifTrue: ['hide page controls']		ifFalse: ['show page controls']) translated! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'tk 2/25/1999 11:04' prior: 17696938!sortPages	| sorter |	sorter _ BookPageSorterMorph new		book: self morphsToSort: self morphsForPageSorter.	sorter pageHolder cursor: self pageNumber.	"Align at bottom right of screen, but leave 20-pix margin."	self bottom + sorter height < Display height ifTrue: "Place it below if it fits"		[^ self world addMorphFront: (sorter align: sorter topLeft with: self bottomLeft)].	self right + sorter width < Display width ifTrue: "Place it below if it fits"		[^ self world addMorphFront: (sorter align: sorter bottomLeft with: self bottomRight)].	"Otherwise, place it at lower right of screen"	self world addMorphFront: (sorter position: Display extent - (20@20) - sorter extent).! !!FloatingBookControlsMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38' prior: 21236491!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!FloatingBookControlsMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:16' prior: 21236657!initialize	"initialize the state of the receiver"	super initialize.	""	self layoutInset: 0;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap ! !!FloatingBookControlsMorph methodsFor: 'WiW support' stamp: 'RAA 8/23/2000 12:47' prior: 21237274!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^23		"page controls are behind menus and balloons, but in front of most other stuff"! !!FloatingBookControlsMorph methodsFor: 'stepping and presenter' stamp: 'RAA 8/23/2000 12:48' prior: 21236906!step	owner == self world ifFalse: [^ self].	owner addMorphInLayer: self.! !!FloatingBookControlsMorph methodsFor: 'testing' stamp: 'RAA 8/23/2000 12:47' prior: 21237067!stepTime	^1000! !!FloatingBookControlsMorph methodsFor: 'testing' stamp: 'RAA 8/23/2000 12:47' prior: 21237167!wantsSteps	^true! !!KedamaMorph commentStamp: 'yo 6/18/2004 18:29' prior: 22535275!A tile-scriptable variant of StarSqueak.!!BookPageThumbnailMorph commentStamp: '<historical>' prior: 17687906!A small picture representing a page of a BookMorph here or somewhere else.  When clicked, make that book turn to the page and do a visual effect and a noise.page			either the morph of the page, or a urlpageNumberbookMorph		either the book, or a urlflipOnClick!!MorphThumbnail commentStamp: '<historical>' prior: 25045245!A morph whose appearance is a thumbnail of some other morph.!!BooklikeMorph commentStamp: '<historical>' prior: 17696238!A common superclass for BookMorph and WebBookMorph!!BookMorph commentStamp: '<historical>' prior: 17601999!A collection of pages, each of which is a place to put morphs.  Allows one or another page to show; orchestrates the page transitions; offers control panel for navigating among pages and for adding and deleting pages.To write a book out to the disk or to a file server, decide what folder it goes in.  Construct a url to a typical page:	file://myDisk/folder/myBook1.spor	ftp://aServer/folder/myBook1.spChoose "send all pages to server" from the book's menu (press the <> part of the controls).  Choose "use page numbers".  Paste in the url.To load an existing book, find its ".bo" file in the file list browser.  Choose "load as book".To load an existing book from its url, execute:¦(URLMorph grabURL: 'ftp://aServer/folder/myBook1.sp') book: true.Multiple people may modify a book.  If other people may have changed a book you have on your screen, choose "reload all from server".Add or modify a page, and choose "send this page to server".The polite thing to do is to reload before changing a book.  Then write one or all pages soon after making your changes.  If you store a stale book, it will wipe out changes that other people made in the mean time.Pages may be linked to each other.  To create a named link to a new page, type the name of the page in a text area in a page.  Select it and do Cmd-6.  Choose 'link to'.  A new page of that name will be added at the back of the book.  Clicking on the blue text flips to that page.  	To create a link to an existing page, first name the page.  Go to that page and Cmd-click on it.  The name of the page is below the page.  Click in it and backspace and type.  Return to the page you are linking from.  Type the name. Cmd-6, 'link to'.  Text search:  Search for a set of fragments.  allStrings collects text of fields.  Turn to page with all fragments on it and highlight the first one.  Save the container and offset in properties: #searchContainer, #searchOffset, #searchKey.  Search again from there.  Clear those at each page turn, or change of search key.  [rules about book indexes and pages:  Index and pages must live in the same directory. They have the same file prefix, followed by .bo for the index or 4.sp for a page (or x4.sp).  When a book is moved to a new directory, the load routine gets the new urls for all pages and saves those in the index.  Book stores index url in property #url.      Allow mulitple indexes (books) on the same shared set of pages.  If book has a url in same directory as pages, allow them to have different prefixes.	save all pages first time, save one page first time, fromRemoteStream: (first time)	save all pages normal , save one page normal, reload	where I check if same dir]URLMorph holds url of both page and book.!!StoryboardBookMorph commentStamp: '<historical>' prior: 31014385!A BookMorph variant whose pages are instances of ZoomAndScrollMorph. I have a control area where the user may pan, tilt and zoom over the image shown in the page.- drag up and down to zoom in and out- drag left and right to pan- shift-drag up and down to tilt.!"MorphicBooks"!TestCase class removeSelector: #shouldInheritSelectors!TestCase class removeSelector: #suite!TestCase class removeSelector: #sunitVersion!TestCase removeSelector: #debug!TestCase removeSelector: #printOn:!TestCase removeSelector: #run!TestCase removeSelector: #runCase!TestCase removeSelector: #runCaseAsFailure:!TestResult class removeSelector: #exError!TestResult removeSelector: #errors!TestResult removeSelector: #expectedPasses!TestResult removeSelector: #failures!TestResult removeSelector: #hasPassed!TestResult removeSelector: #passed!TestResult removeSelector: #printOn:!TestResult removeSelector: #runCase:!TestSuite removeSelector: #addTests:!TestSuite removeSelector: #run!TestSuite removeSelector: #tests!SimpleTestResourceTestCase class removeSelector: #resources!SUnitExtensionsTest removeSelector: #testExceptionWithMatchingString!SUnitExtensionsTest removeSelector: #testExceptionWithoutMatchingString!SUnitExtensionsTest removeSelector: #testNoExceptionWithMatchingString!SUnitExtensionsTest removeSelector: #testNoExceptionWithNoMatchingString!TestCase removeSelector: #shouldPass!TestCase removeSelector: #run:!TestCase removeSelector: #expectedFailures!TestCase class removeSelector: #testSelectors!TestCase class removeSelector: #suiteClass!TestCase class removeSelector: #buildSuiteFromSelectors!TestCase class removeSelector: #buildSuiteFromMethods:!TestCase class removeSelector: #buildSuiteFromLocalSelectors!TestCase class removeSelector: #buildSuiteFromAllSelectors!TestCase class removeSelector: #buildSuite!TestCase class removeSelector: #allTestSelectors!TestCase class removeSelector: #addToSuiteFromSelectors:!TestCase class removeSelector: #addToSuite:fromMethods:!TestCase class removeSelector: #addTestsFor:toSuite:!LongTestCaseTest removeSelector: #testLongTestCaseRun!LongTestCaseTest removeSelector: #testLongTestCaseDoNotRun!Smalltalk removeClassNamed: #LongTestCaseTest!LongTestCaseTestUnderTest removeSelector: #testWhenRunMarkTestedToTrue!LongTestCaseTestUnderTest class removeSelector: #markAsNotRun!LongTestCaseTestUnderTest class removeSelector: #hasRun!Smalltalk removeClassNamed: #LongTestCaseTestUnderTest!LongTestCase class removeSelector: #runLongTestCases!LongTestCase class removeSelector: #isAbstract!LongTestCase class removeSelector: #doNotRunLongTestCases!LongTestCase class removeSelector: #buildSuite!LongTestCase class removeSelector: #allTestSelectors!LongTestCase class removeSelector: #initialize!Smalltalk removeClassNamed: #LongTestCase!TestSuite removeSelector: #run:!TestResult removeSelector: #unexpectedPasses!TestResult removeSelector: #unexpectedPassCount!TestResult removeSelector: #unexpectedFailures!TestResult removeSelector: #unexpectedFailureCount!TestResult removeSelector: #unexpectedErrors!TestResult removeSelector: #unexpectedErrorCount!TestResult removeSelector: #expectedDefects!TestResult removeSelector: #expectedDefectCount!TestResult removeSelector: #correctCount!SUnitTest removeSelector: #testSelectorWithArg:!!SUnitTest methodsFor: 'testing' stamp: 'kph 12/18/2006 01:58'!testSelectorsMatchingCategory	| selectors |	selectors := self class in: self class selectorsMatchingCategory: 'acc*'.	self assert: selectors includes: #hasRun.	self assert: selectors includes: #hasSetup.	self assert: selectors size = 2.	! !!ClassClonerTestResource class methodsFor: 'as yet unclassified' stamp: 'auto 12/8/2008 10:28'!cloneOf: origClass	^ self current cloneOf: origClass! !!ClassClonerTestResource methodsFor: 'as yet unclassified' stamp: 'kph 12/20/2006 19:49'!cloneOf: origClass	^ clones at: origClass ifAbsentPut: [ self makeCloneOf: origClass ]! !!ClassClonerTestResource methodsFor: 'as yet unclassified' stamp: 'kph 12/20/2006 19:47'!makeCloneOf: origClass	| clone |	"copy the class"	clone := origClass copy.	origClass classPool keysAndValuesDo: [ :k :v | 		 clone classPool at: k deepCopy put: v deepCopy.	].  	clone compileAll. 	^clone! !!ClassClonerTestResource methodsFor: 'as yet unclassified' stamp: 'kph 12/20/2006 19:47'!setUpclones := IdentityDictionary new.! !!ClassClonerTestResource methodsFor: 'as yet unclassified' stamp: 'kph 12/20/2006 19:47'!tearDownclones := nil.! !!ClassClonerTestResourceTest class methodsFor: 'as yet unclassified' stamp: 'kph 12/20/2006 20:32'!initialize ClassVar := 'initialized'.! !!ClassClonerTestResourceTest class methodsFor: 'as yet unclassified' stamp: 'kph 12/20/2006 20:32'!changeClassVarClassVar := 'changed'.! !!ClassClonerTestResourceTest class methodsFor: 'as yet unclassified' stamp: 'kph 12/20/2006 20:32'!classVar^ ClassVar! !!ClassClonerTestResourceTest class methodsFor: 'as yet unclassified' stamp: 'kph 12/2/2006 05:11'!resources^ Set with: ClassClonerTestResource! !!ClassClonerTestResourceTest methodsFor: 'as yet unclassified' stamp: 'kph 12/20/2006 20:33'!setUporiginalClass := self class initialize.clonedClass := ClassClonerTestResource current cloneOf: originalClass.clonedClass initialize.! !!ClassClonerTestResourceTest methodsFor: 'as yet unclassified' stamp: 'kph 12/20/2006 20:05'!testChangeCloneclonedClass changeClassVar.self assert: (clonedClass classVar = 'changed').self assert: (originalClass classVar = 'initialized')! !!ClassClonerTestResourceTest methodsFor: 'as yet unclassified' stamp: 'kph 12/20/2006 20:04'!testInitialStateself assert: (clonedClass classVar = 'initialized').self assert: (originalClass classVar = 'initialized').self deny: (clonedClass classVar == originalClass classVar). self deny: ((clonedClass classPool at: #ClassVar) == (originalClass classPool at: #ClassVar)). ! !!SuiteBuildingTest class methodsFor: 'as yet unclassified' stamp: 'kph 8/28/2008 16:47'!allStandardTests	"Tests the standard release of this system."	^ super allStandardTests , (self suiteWithMethodCategoryMatching: 'standard tests')			 ! !!SuiteBuildingTest class methodsFor: 'as yet unclassified' stamp: 'kph 8/28/2008 17:01'!suiteFoodCategory	^ self suiteWithMethodCategoryMatching: 'food'! !!SuiteBuildingTest class methodsFor: 'as yet unclassified' stamp: 'kph 8/28/2008 17:01'!suiteFruitSelectors^ self suiteWithSelectorsMatching: 'fruit*'	! !!SuiteBuildingTest class methodsFor: 'as yet unclassified' stamp: 'kph 8/28/2008 17:06'!suiteVegFlag	^ self suiteWithFlagged: #Veg	! !!SuiteBuildingTest class methodsFor: 'as yet unclassified' stamp: 'kph 8/28/2008 17:01'!suiteVegSelectors^ self suiteWithSelectorsMatching: 'veg*'	! !!SuiteBuildingTest methodsFor: 'standard tests' stamp: 'kph 8/28/2008 16:53'!canGetAllFlaggedMethods		suite := self class suiteWithFlagged: 'flag:' asSymbol.	  	self assert: (suite tests size = 6).	 ! !!SuiteBuildingTest methodsFor: 'standard tests' stamp: 'kph 12/18/2006 08:45'!checkSuiteHasUniqueTestsOnly	suite := TestSuite new.	suite 		addTest: (self class selector: #noop);		addTest: (self class selector: #noop);		addTest: (self class selector: #noop).	self assert: (suite tests size = 1).	 ! !!SuiteBuildingTest methodsFor: 'standard tests' stamp: 'kph 8/28/2008 17:14'!excluding	suite := self class suiteFoodCategory - self class suiteFruitSelectors.	  	self assert: (suite tests size = 2).	 ! !!SuiteBuildingTest methodsFor: 'standard tests' stamp: 'kph 8/28/2008 17:23'!filterReject	filtered := TestSuite classes: (Array with: self class) suites: #(#suiteFoodCategory) select: nil reject: (Array with: #suiteFruitSelectors).	 	self assert: (filtered tests size = 2).	 ! !!SuiteBuildingTest methodsFor: 'standard tests' stamp: 'kph 8/28/2008 17:18'!filterSelect	 	filtered := TestSuite classes: (Array with: self class) suites: #(#suiteFoodCategory) select:  (Array with: #suiteFruitSelectors) reject: nil.	 	self assert: (filtered tests size = 3).	 ! !!SuiteBuildingTest methodsFor: 'standard tests' stamp: 'kph 8/28/2008 17:10'!flaggedWithFlag	self flag: #Flagged.		selectors := (self class suiteWithFlagged: #Flagged) tests collect: #selector.	self assert: selectors includes: #flaggedWithFlag.	self assert: selectors size = 1. ! !!SuiteBuildingTest methodsFor: 'standard tests' stamp: 'kph 8/28/2008 17:11'!flaggedWithLoneSymbol	#LoneSymbol.	selectors := (self class suiteWithFlagged: #LoneSymbol) tests collect: #selector.	self assert: selectors includes: #flaggedWithLoneSymbol.	self assert: selectors size = 1.! !!SuiteBuildingTest methodsFor: 'food' stamp: 'kph 12/19/2006 04:54'!fruitAppleself flag: #BugFix.self flag: #Fruit! !!SuiteBuildingTest methodsFor: 'food' stamp: 'kph 12/18/2006 08:15'!fruitBananaself flag: #Fruit! !!SuiteBuildingTest methodsFor: 'food' stamp: 'kph 12/18/2006 08:15'!fruitPearself flag: #Fruit! !!SuiteBuildingTest methodsFor: 'standard tests' stamp: 'kph 8/28/2008 17:08'!removeTestsFromSuite	suite := TestSuite new.	suite 		addTest: (self class selector: #noop);		removeTests: (Array with:(self class selector: #noop)).	self assert: (suite tests size = 0).! !!SuiteBuildingTest methodsFor: 'standard tests' stamp: 'kph 8/28/2008 17:05'!suiteFromCategory	  	self assert: (self class suiteFoodCategory tests size = 5).	 ! !!SuiteBuildingTest methodsFor: 'standard tests' stamp: 'kph 8/28/2008 17:06'!suiteFromFlag   	self assert: (self class suiteVegFlag tests size = 2).	 ! !!SuiteBuildingTest methodsFor: 'standard tests' stamp: 'kph 8/28/2008 17:09'!suiteFromSelector 	  	self assert: (self class suiteFruitSelectors tests size = 3).	 ! !!SuiteBuildingTest methodsFor: 'food' stamp: 'kph 12/18/2006 08:16'!vegCarrotself flag: #Veg! !!SuiteBuildingTest methodsFor: 'food' stamp: 'kph 12/18/2006 08:16'!vegPotatoeself flag: #Veg! !!TestCase class methodsFor: 'published suites' stamp: 'kph 8/28/2008 16:07'!allStandardTests	"Tests the standard release of this system."	^ self suiteWithSelectorsMatching: 'test*'			 ! !!TestCase class methodsFor: 'published suites' stamp: 'kph 8/28/2008 16:54'!bugFixes	"Tests specifically marked as #bugFix"	^ (self suiteWithSelectorsMatching: 'bug*') , (self suiteWithMethodCategoryMatching: 'bug fixes'), (self suiteWithFlagged: #BugFix)! !!TestCase class methodsFor: 'building suites' stamp: 'kph 11/2/2008 02:13'!classForSelector: selector	"Look up the given selector in my methodDictionary.	Return the corresponding class if found.	Otherwise chase the superclass chain and try again.	Return nil if no method is found."	| lookupClass |	lookupClass _ self.	[lookupClass == nil]		whileFalse: 			[(lookupClass includesSelector: selector)				ifTrue: [^ lookupClass ].			lookupClass _ lookupClass superclass].	^ nil! !!TestCase class methodsFor: 'published suites' stamp: 'kph 8/28/2008 16:54'!expectedFailures	"Tests explicitly flagged as expected failures"	^ (self suiteWithSelectorsMatching: 'bug*') , (self suiteWithMethodCategoryMatching: '(fail)*(expected)*'), (self suiteWithFlagged: #ExpectToFail)! !!TestCase class methodsFor: 'published suites' stamp: 'kph 8/28/2008 16:54'!longTests"Any tests that may take a long time, say more than 30 seconds"	^ (self suiteWithMethodCategoryMatching: '*(long)*') , (self suiteWithFlagged: #LongTest)! !!TestCase class methodsFor: 'published suites' stamp: 'kph 8/28/2008 00:25'!publishedFilters	^ #(#longTests #slowTests #expectedFailures #bugFixes #toDo #usesNetwork) ! !!TestCase class methodsFor: 'published suites' stamp: 'kph 12/18/2006 06:30'!publishedSuites	^ #(#allStandardTests)! !!TestCase class methodsFor: 'misc' stamp: 'kph 8/28/2008 16:15'!runner	^ Smalltalk at: #TestRunner ifAbsent: [ Smalltalk at: #TestReporter ]! !!TestCase class methodsFor: 'testing' stamp: 'kph 11/2/2006 02:14'!shouldInheritSelectors	"I should inherit from an Abstract superclass but not from a concrete	one by default, If a test case with selectors wants to inherit selectors 	from a concrete superclass, override this to true in that subclass."	^ self superclass isAbstract		and: [self superclass name ~= #TestCase]! !!TestCase class methodsFor: 'published suites' stamp: 'kph 8/28/2008 16:10'!slowTests"Any tests that may take a while, but not as long as a longTest, more than 2 seconds"	^ self suiteWithMethodCategoryMatching: '*(slow)*'! !!TestCase class methodsFor: 'building suites' stamp: 'kph 12/19/2006 00:45'!suite	^ self suite: #allStandardTests! !!TestCase class methodsFor: 'building suites' stamp: 'kph 8/28/2008 16:41'!suite: spec	(self respondsTo: spec) ifFalse: [ ^ TestSuite new ].		^ self perform: spec! !!TestCase class methodsFor: 'building suites' stamp: 'kph 11/2/2008 02:16'!suiteWithFlagged: literal 	^ TestSuite define: [ :suite |		self theClasses do: [ :testClass |			suite addTests: (testClass testsSelect: [ :selector | (testClass lookupSelector: selector) hasLiteral: literal ]). 				Smalltalk at: #Pragma ifPresent: [ :c |			suite addTests: (testClass testsSelect: [ :selector | (testClass lookupSelector: selector) pragmas anySatisfy: [ :p | (p keyword = #suite:) and: [ literal = (p argumentAt: 1) ] ] ]) 		] 	]]	 	  ! !!TestCase class methodsFor: 'building suites' stamp: 'kph 11/2/2008 02:16'!suiteWithMethodCategoryMatching: pattern 	^ TestSuite define: [ :suite |		self theClasses do: [ :testClass |			suite addTests: (testClass testsSelect: [ :selector | pattern match: ((testClass classForSelector: selector) organization categoryOfElement: selector) asString]) 		].	]	 ! !!TestCase class methodsFor: 'building suites' stamp: 'kph 8/28/2008 16:06'!suiteWithSelectorsMatching: pattern 	^ TestSuite define: [ :suite |				self theClasses do: [ :testClass | suite addTests: (testClass testsSelect: [ :sel | pattern match: sel ]) ] 	]	 ! !!TestCase class methodsFor: 'accessing' stamp: 'kph 8/28/2008 15:45'!sunitVersion	^ '3.3'! !!TestCase class methodsFor: 'building suites' stamp: 'kph 8/28/2008 00:01'!testsSelect: aBlock		^ self withInheritedSelectors 		select: [ :selector | selector last ~= $: and: [ aBlock value: selector ] ]		thenCollect: [ :s | self selector: s ]	! !!TestCase class methodsFor: 'building suites' stamp: 'kph 8/28/2008 15:58'!theClasses	^ self isAbstract 		ifTrue: [ self allSubclasses reject: [:c | c isAbstract] ] 		ifFalse: [ Array with: self ].! !!TestCase class methodsFor: 'published suites' stamp: 'kph 8/28/2008 16:54'!toDo	"Tests specifically marked as #ToDo"	^ (self suiteWithSelectorsMatching: 'todo*') , (self suiteWithMethodCategoryMatching: '*todo*') , (self suiteWithFlagged: #ToDo)			! !!TestCase class methodsFor: 'published suites' stamp: 'kph 8/28/2008 16:54'!usesNetwork"Any tests that are marked as using the network"	^ (self suiteWithMethodCategoryMatching: '*(net)*'), (self suiteWithFlagged: #UsesNetwork)! !!TestCase class methodsFor: 'building suites' stamp: 'kph 8/27/2008 23:27'!withInheritedSelectors 		^ self shouldInheritSelectors ifTrue: [ self allSelectorsBelow: TestCase ] ifFalse: [self selectors]			  ! !!TestCase methodsFor: 'equality' stamp: 'kph 12/16/2006 10:44'!<= aTestCase^(self printString <= aTestCase printString)! !!TestCase methodsFor: 'equality' stamp: 'kph 12/16/2006 07:32'!= aTestCase^(aTestCase class == self class) and: [ aTestCase selector == self selector ]	! !!TestCase methodsFor: 'categorization utilities' stamp: 'kph 12/21/2006 05:06'!addCategoryMark: aWord	"adds a (tag) to the category of this test method, e.g. 'tests (long)' "	self class methodDict at: self selector ifAbsent: [ ^ self ].	^self class organization classify: self selector under: (self category,'(', aWord,')'); removeEmptyCategories.! !!TestCase methodsFor: 'accessing' stamp: 'dc 4/2/2007 18:38'!assert: expected equals: actual	^ self		assert: (expected = actual)		description: (self comparingStringBetween: expected and: actual)! !!TestCase methodsFor: 'accessing' stamp: 'kph 11/2/2006 01:29'!assert: a includes: b 	^ self assert: (a includes: b)! !!TestCase methodsFor: 'categorization utilities' stamp: 'kph 12/18/2006 10:42'!category^ (self class organization categoryOfElement: self selector) ifNil: [ '' ]	! !!TestCase methodsFor: 'private' stamp: 'dc 4/2/2007 18:46'!comparingStringBetween: expected and: actual	^ String streamContents: [:stream |		stream			nextPutAll: 'Expected ';			nextPutAll: (expected printStringLimitedTo: 10);			nextPutAll: ' but was ';			nextPutAll: (actual printStringLimitedTo: 10);			nextPutAll: '.'		]! !!TestCase methodsFor: 'running' stamp: 'kph 3/13/2007 16:08'!debug	self resources do: [:res | 		res isAvailable ifFalse: [^res signalInitializationError]].	[		[ (self class selector: testSelector) runCase ]			on: Error do: [ :ex | 	UnhandledError signalForException: ex ].			] 		ensure: [self resources do: [:each | each reset]]			! !!TestCase methodsFor: 'equality' stamp: 'kph 2/22/2007 07:10'!hash^ (self class name, testSelector) hash! !!TestCase methodsFor: 'categorization utilities' stamp: 'kph 12/18/2006 10:43'!isCategoryMarkedWith: aWord	"tests to the presence of a (tag) in the category of this test method, e.g. 'tests (long)' "	^self category includesSubString: '(', aWord, ')'.! !!TestCase methodsFor: 'printing' stamp: 'kph 2/20/2007 14:06'!printForList	^ self class name, ' ', self selector! !!TestCase methodsFor: 'printing' stamp: 'kph 1/6/2007 04:55'!printOn: aStream	aStream		nextPutAll: self class printString;		nextPutAll: '>>#';		nextPutAll: testSelector;		nextPutAll: ' {';		nextPutAll: ((self class organization categoryOfElement: testSelector) ifNil: [ ' ' ]);		nextPutAll: '}'.			! !!TestCase methodsFor: 'categorization utilities' stamp: 'kph 12/21/2006 04:06'!removeCategoryMark: aWord	"removes a (tag) from the category of this test method, e.g. 'tests (long)' => 'tests' "	| categoryReader newCategory |	self class methodDict at: self selector ifAbsent: [ ^ self ].		categoryReader := ReadStream on: self category.	newCategory := (categoryReader upToAll: ('(',aWord,')')), categoryReader upToEnd.	^self class organization classify: self selector under: newCategory; removeEmptyCategories.! !!TestCase methodsFor: 'running' stamp: 'kph 11/1/2006 20:21'!run	| result |	result := TestResult new.	self runOn: result.	^ result! !!TestCase methodsFor: 'running' stamp: 'kph 9/13/2007 01:27'!runCase	self runCaseWith: [			 [self setUp.	  self performTest] ensure: [self tearDown] 	]			! !!TestCase methodsFor: 'running' stamp: 'kph 9/13/2007 01:27'!runCaseAsFailure: aSemaphore	self runCaseWith:		[				[self setUp.		self openDebuggerOnFailingTestMethod] ensure: [			self tearDown.			aSemaphore signal]		]! !!TestCase methodsFor: 'running' stamp: 'kph 9/13/2007 01:29'!runCaseWith: aBlock	"this method provides a place for subclasses to override in order to enclose running of test cases	within a testing context	e.g. PRCurrentContext value: self context during: aBlock"		^ aBlock value! !!TestCase methodsFor: 'running' stamp: 'kph 11/1/2006 20:20'!runOn: aResult 	aResult runCase: self! !!TestCase methodsFor: 'accessing' stamp: 'kph 3/11/2007 00:52'!suite: aSymbol"used to flag a test as being of a non standard test suite"! !!TestCaseVersioned class methodsFor: 'version filters' stamp: 'kph 8/29/2008 02:10'!filterFromList: versionList except: thisVersion"self notThisSqueakVersionFilter"	| time |		time := '*earlier*'.		^ 	 (TestSuite define: [ :suite | 		versionList do: [ :aVersion | 				aVersion = thisVersion 				ifTrue: [ time := '*later*' ]				ifFalse: [ suite ,  (self suiteWithMethodCategoryMatching: '*', aVersion, time), (self suiteWithMethodCategoryMatching: '*', aVersion, '*only*').].		]	])! !!TestCaseVersioned class methodsFor: 'platform filters' stamp: 'kph 8/29/2008 02:02'!nonMacOSTests	^ self suiteAllThePlatforms - (self suiteWithFlagged: #MacOsSpecificTest)! !!TestCaseVersioned class methodsFor: 'platform filters' stamp: 'kph 8/29/2008 02:02'!nonRiscOSTests	^ self suiteAllThePlatforms - (self suiteWithFlagged: #RiskOsSpecificTest) ! !!TestCaseVersioned class methodsFor: 'platform filters' stamp: 'kph 8/29/2008 02:02'!nonUnixTests	^ self suiteAllThePlatforms - (self suiteWithFlagged: #UnixSpecificTest)  ! !!TestCaseVersioned class methodsFor: 'platform filters' stamp: 'kph 8/29/2008 02:02'!nonWin32Tests	^ self suiteAllThePlatforms - (self suiteWithFlagged: #WindowsSpecificTest) ! !!TestCaseVersioned class methodsFor: 'platform filters' stamp: 'kph 8/29/2008 02:04'!notThisPlatformFilter 	^ self perform: ('non', (SmalltalkImage current platformName asLegalSelector capitalized), 'Tests') asSymbol! !!TestCaseVersioned class methodsFor: 'version filters' stamp: 'kph 8/29/2008 02:11'!notThisSqueakVersionFilter 	^ ( self filterFromList: self squeakVersions except: self thisSqueakVersion) - (self suiteWithMethodCategoryMatching: '*vm*' ) ! !!TestCaseVersioned class methodsFor: 'version filters' stamp: 'kph 8/29/2008 02:14'!notThisSqueakVmVersionFilter 	^ (self filterFromList: self squeakVmVersions except: self thisSqueakVmVersion) intersection: (self suiteWithMethodCategoryMatching: '*vm*' ) ! !!TestCaseVersioned class methodsFor: 'published suites' stamp: 'kph 8/29/2008 02:15'!notThisVersionOrPlatform	^ self notThisPlatformFilter , self notThisSqueakVersionFilter ,  self notThisSqueakVmVersionFilter! !!TestCaseVersioned class methodsFor: 'published suites' stamp: 'kph 8/29/2008 02:16'!publishedFilters	^ super publishedFilters, #( #notThisVersionOrPlatform #notThisPlatformFilters #notThisVersionFilters #notThisVmVersionFilters)  ! !!TestCaseVersioned class methodsFor: 'published suites' stamp: 'kph 3/11/2007 01:34'!publishedSuites	^ super publishedSuites  ! !!TestCaseVersioned class methodsFor: 'version filters' stamp: 'kph 8/29/2008 02:04'!squeakVersions^ #('Squeak3.6' 'Squeak3.7' 'Squeak3.8' 'Squeak3.9' 'Squeak3.10' 'Squeak3.11')! !!TestCaseVersioned class methodsFor: 'version filters' stamp: 'kph 8/29/2008 02:05'!squeakVmVersions^ #('Squeak3.6' 'Squeak3.7' 'Squeak3.8'  'Squeak3.8.1' 'Squeak3.9alpha')! !!TestCaseVersioned class methodsFor: 'platform filters' stamp: 'kph 8/29/2008 02:02'!suiteAllThePlatforms	^ #(#WindowsSpecificTest #UnixSpecificTest #MacOsSpecificTest #RiscOsSpecificTest) inject: (TestSuite new) into: [ :out :flag | out, (self suiteWithFlagged: flag) ].! !!TestCaseVersioned class methodsFor: 'version filters' stamp: 'kph 3/11/2007 17:51'!thisSqueakVersion	^SystemVersion current majorMinorVersion! !!TestCaseVersioned class methodsFor: 'version filters' stamp: 'kph 8/28/2008 16:16'!thisSqueakVmVersion	"self vmVersion"	^ (SmalltalkImage current vmVersion copyUpTo: $  )   ! !!TestCaseVersionedTest methodsFor: 'Squeak3.11 and later' stamp: 'kph 5/2/2007 02:35'!example311later! !!TestCaseVersionedTest methodsFor: 'Squeak3.6 Squeak3.7 only' stamp: 'kph 5/2/2007 02:37'!example36And37only! !!TestCaseVersionedTest methodsFor: 'Squeak3.6 earlier vm' stamp: 'kph 5/2/2007 02:55'!example36earlierVm! !!TestCaseVersionedTest methodsFor: 'Squeak3.7 and later' stamp: 'kph 5/2/2007 02:34'!example37later! !!TestCaseVersionedTest methodsFor: 'as yet unclassified' stamp: 'kph 5/2/2007 03:15'!testAll	self assert: ((self class suite: #notThisVersionOrPlatform) tests size = 3)! !!TestCaseVersionedTest methodsFor: 'as yet unclassified' stamp: 'kph 5/2/2007 03:15'!testSqueakVersion 	self assert: ((self class suite: #notThisSqueakVersionFilter) tests size = 2)! !!TestCaseVersionedTest methodsFor: 'as yet unclassified' stamp: 'kph 5/2/2007 03:15'!testSqueakVersionVm	self assert: ((self class suite: #notThisSqueakVmVersionFilter) tests size = 1)! !!TestReporter class methodsFor: 'defaults' stamp: 'kph 2/18/2007 03:56'!defaultDirectory^ 'tests' ! !!TestReporter class methodsFor: 'defaults' stamp: 'kph 3/12/2007 04:28'!defaultRejectFilters	^ #( #toDo #expectedFailures #notThisVersionOrPlatform) ! !!TestReporter class methodsFor: 'defaults' stamp: 'kph 2/18/2007 03:58'!defaultRunName^ 'tests' ! !!TestReporter class methodsFor: 'defaults' stamp: 'kph 2/22/2007 12:34'!defaultSelectFilters	^ #() ! !!TestReporter class methodsFor: 'defaults' stamp: 'kph 2/22/2007 12:34'!defaultSuites	^ #( #allStandardTests) ! !!TestReporter class methodsFor: 'instanciation' stamp: 'kph 2/20/2007 08:35'!new^self new: self defaultRunName to: self defaultDirectory	 ! !!TestReporter class methodsFor: 'instanciation' stamp: 'kph 2/20/2007 05:39'!new: testRunName to: directory^(self basicNew)	setDirectory: directory;	name: testRunName;	initialize;	yourself! !!TestReporter class methodsFor: 'filein' stamp: 'kph 2/20/2007 17:00'!read: runName^ (self new) name: runName; yourself! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/20/2007 06:04'!baseClasses	^Array with: TestCase ! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 08:43'!beginProgressFile	directory assureExistence.		(directory fileNamesMatching: (name,'-*.*')) do: [ :oldFileName |		directory deleteFileNamed: oldFileName.	].		stateFileExt := 'running'.	self progressFileChangeState.		 ! !!TestReporter methodsFor: 'runner interface' stamp: 'kph 2/18/2007 08:06'!beginRunSuite: aSuitetotalTestCount := aSuite tests size.testN := 0.self beginProgressFile.resultsFile := nil.! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/19/2007 23:49'!completeProgressFile	(stateFileExt = 'running')		ifTrue: [			stateFileExt := 'PASSED'.		].		stateFileExt := stateFileExt asUppercase.	self progressFileChangeState. ! !!TestReporter methodsFor: 'results interface' stamp: 'kph 4/4/2007 00:37'!error: test dueTo: reason	self next.	self progressRecordError.  		 self resultsFile 			nextPutAll: test class name;			nextPutAll: ' debug: #';			nextPutAll: test selector;			nextPutAll: '. "Error ';			nextPutAll: reason printString;			nextPut: $".							self resultsFileSizingTweak! !!TestReporter methodsFor: 'results interface' stamp: 'kph 4/4/2007 00:37'!fail: test dueTo: reason	self next.	self progressRecordFail.			 self resultsFile 			nextPutAll: test class name;			nextPutAll: ' debug: #';			nextPutAll: test selector;			nextPutAll: '. "Failure ';			nextPutAll: reason printString;			nextPut: $".				self resultsFileSizingTweak.! !!TestReporter methodsFor: 'testing' stamp: 'kph 2/18/2007 05:49'!isComplete^ testN == totalTestCount ! !!TestReporter methodsFor: 'running' stamp: 'kph 2/20/2007 06:09'!label: aString forSuite: aTestSuite	^ String streamContents: [ :stream |		stream nextPutAll: 'Running '; print: aTestSuite tests size; space; nextPutAll: aString.		aTestSuite tests size > 1 ifTrue: [ stream nextPut: $s ] ]. ! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 10:00'!name 	^name  ! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 03:55'!name: aName	name := aName! !!TestReporter methodsFor: 'results interface' stamp: 'kph 2/19/2007 23:56'!next	testN := testN + 1.	testN \\ 1000 == 0 ifTrue: [ self progressFileZero ]! !!TestReporter methodsFor: 'results interface' stamp: 'kph 2/18/2007 05:55'!pass: test	self next.	self progressRecordPass.! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/20/2007 05:55'!progressComment| thousands |self isComplete ifTrue: [ ^ self progressCommentWhenComplete ].thousands := testN // 1000.^ '(', totalTestCount printString,(thousands > 0 ifTrue: [ '-', thousands printString, 'k)' ] ifFalse: [')'] ) ! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/20/2007 07:45'!progressCommentWhenComplete	| fails errors |	fails := self results unexpectedFailureCount.	errors := self results unexpectedErrorCount.	(fails + errors = 0) ifTrue: [ ^totalTestCount printString, ' SUCCESS' ].		(errors = 0)	ifTrue: [ ^totalTestCount printString, ' RUN ', fails printString ].			^totalTestCount printString, ' RUN ', fails printString,' FAILURES ', errors printString.! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 09:40'!progressFile (progressFile notNil and: [ progressFile closed ]) ifTrue: [ self progressFileChangeState  ]. ^progressFile! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 08:07'!progressFileChangeState	[progressFile close.	directory rename: progressFile name toBe: self progressFileName] ifError: [].	progressFile := directory fileNamed: self progressFileName.	progressFile setToEnd.		^progressFile! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 08:42'!progressFileName^ name, '-', self progressComment,'.', stateFileExt  ! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/20/2007 01:28'!progressFileZero"we are using the progress file size as a progress indicator, but we can only use this up to about 1000 tests, so we  change the comment, and start the counter again"	[progressFile close.	directory rename: progressFile name toBe: self progressFileName] ifError: [].	progressFile := directory forceNewFileNamed: self progressFileName.		^progressFile! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 09:22'!progressRecordError	self progressFile nextPut: $E.((stateFileExt = 'running') | (stateFileExt = 'failures')) 	ifTrue: [ 		stateFileExt := 'errors'.		self progressFileChangeState. 	].! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 09:36'!progressRecordFail	self progressFile nextPut: $F.	stateFileExt = 'running' 	ifTrue: [ 		stateFileExt := 'failures'.		self progressFileChangeState. 	].	! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 09:37'!progressRecordPass	self progressFile nextPut: $..		 ! !!TestReporter methodsFor: 'results interface' stamp: 'kph 2/22/2007 15:25'!reporter: r  	"dummy method"! !!TestReporter methodsFor: 'file system' stamp: 'kph 5/2/2007 00:00'!results	^ results ifNil: [ runner result ] ! !!TestReporter methodsFor: 'file system' stamp: 'kph 5/2/2007 00:00'!results: aTestCaseResult	results := aTestCaseResult ! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 09:51'!resultsFile^ resultsFile ifNil: [ self resultsFileChangeState. self writeResultsFileHeader. resultsFile.]! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 08:07'!resultsFileChangeState	[progressFile close.	directory rename: resultsFile name toBe: self resultsFileName] ifError: [].	resultsFile := directory fileNamed: self resultsFileName.	resultsFile setToEnd.		^resultsFile! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 08:42'!resultsFileName^ name, '-results.st' ! !!TestReporter methodsFor: 'file system' stamp: 'testReporter 2/20/2007 06:54'!resultsFileSizingTweak	| request fails errors p | 	fails := self results unexpectedFailureCount.	errors := self results unexpectedErrorCount.	request := (fails * 100) + (errors * 101) - 1.		(p := self resultsFile position) < request ifTrue: [ self resultsFile nextPutAll: (String new: (request - p) withAll: $ ) ].		self resultsFile cr.	 ! !!TestReporter methodsFor: 'running' stamp: 'kph 4/4/2007 01:08'!runCategories: c " c - match string or array of match strings"	^ self runSuites: nil select: nil reject: nil categories: (c isString ifTrue: [ Array with: c] ifFalse: [ c ]) classes: nil.  ! !!TestReporter methodsFor: 'runner interface' stamp: 'kph 2/18/2007 04:25'!runComplete		self completeProgressFile! !!TestReporter methodsFor: 'running' stamp: 'test 3/13/2007 19:38'!runSuite: aTestSuite	| initials |		initials := Utilities authorInitialsPerSe.	self results: (TestResultTimed newTo: self).	[		Utilities setAuthorInitials: 'test'.		self beginRunSuite: aTestSuite.			aTestSuite resources do: [ :each |			each isAvailable				ifFalse: [ each signalInitializationError ] ].				aTestSuite tests asOrderedCollection do: [ :test | test runOn: self results ] displayingProgress: aTestSuite name	] 	ensure: [ 		Utilities setAuthorInitials: initials.		aTestSuite resources do: [ :each | each reset ]. 	].		self runComplete.	 ! !!TestReporter methodsFor: 'running' stamp: 'kph 4/4/2007 01:24'!runSuites: suites select: selectFilters reject: rejectFilters categories: someCategories classes: someClasses  	| classes categories   |	 	categories := Set new.	(someCategories ifNil: [ someClasses ifNil: [#('*')] ifNotNil: [#()] ])  		do: [ :spec | categories addAll: (Smalltalk organization categoriesMatching: spec) ].			classes := Set new.			categories do: [ : category | 		classes addAll: (SystemOrganization listAtCategoryNamed: category asSymbol) 	].		classes addAll: (someClasses ifNil:[ #() ]).		 	classes := classes collect: [ :className | Smalltalk at: className asSymbol ]. 			suite :=  TestSuite classes:classes 				suites:  (suites ifNil: [ self class defaultSuites ])				select: (selectFilters ifNil: [ self class defaultSelectFilters ])				reject: (rejectFilters ifNil: [ self class defaultRejectFilters ]).					suite name: (self label: 'Test' forSuite: suite).		self runSuite: suite.			^ self results	    ! !!TestReporter methodsFor: 'filein' stamp: 'kph 4/4/2007 00:50'!scanFrom: aStream	| str list class selector errorOrFail msg reason title  | 	list := OrderedCollection new.		str := aStream nextChunkText asString readStream.		[ str atEnd ] whileFalse: [ 		class := (str upToAll: ' debug: #') asString asSymbol. 		selector := (str upTo: $.) asString asSymbol.		errorOrFail := str skipTo: $"; upTo: $ .		reason := str upTo: $".		str nextLine.		msg := ''.		list add:	(MethodReference new 					setClass: (Smalltalk at: class ifAbsent: [ msg := '(not present)'. UndefinedObject ])					methodSymbol: selector 					stringVersion: errorOrFail asString, msg, ' ',class ,'>>', selector, ' ', reason).	].	list := list asSortedCollection: [:a :b | a stringVersion < b stringVersion ].	title := 'Results for run: ', self name.	Smalltalk at: #ToolSet ifPresent: [ :ms |  		 ms 	browseMessageSet: list				name: title 				autoSelect: nil.		^ nil	].							MessageSet		openMessageList: list 		name: title 		autoSelect: nil.	^ nil! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 04:07'!setDirectory: dir	directory := FileDirectory default directoryNamed: dir.! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 04:43'!setRunner: aRunner	runner := aRunner! !!TestReporter methodsFor: 'file system' stamp: 'kph 2/18/2007 08:14'!writeResultsFileHeader	resultsFile nextPutAll: '!!TestReporter read: ''', self name, '''!!'; cr! !!TestResult class methodsFor: 'exceptions' stamp: 'kph 3/13/2007 15:17'!exError   	^ Error			! !!TestResult methodsFor: 'accessing' stamp: 'kph 2/16/2007 08:05'!error: tc dueTo: msgerrors add: tc! !!TestResult methodsFor: 'compatibility' stamp: 'kph 12/6/2008 01:17'!errors	^ errors! !!TestResult methodsFor: 'accessing' stamp: 'kph 11/2/2008 02:32'!expectedPasses	^ passed ! !!TestResult methodsFor: 'accessing' stamp: 'kph 2/16/2007 08:05'!fail: a dueTo: msg	failures add: a! !!TestResult methodsFor: 'compatibility' stamp: 'kph 12/6/2008 01:17'!failures	^ failures! !!TestResult methodsFor: 'testing' stamp: 'kph 11/2/2008 02:22'!hasPassed	^self runCount = self passedCount! !!TestResult methodsFor: 'accessing' stamp: 'kph 2/16/2007 08:04'!pass: apassed add: a! !!TestResult methodsFor: 'compatibility' stamp: 'kph 11/2/2008 02:26'!passed	^ self expectedPasses ! !!TestResult methodsFor: 'printing' stamp: 'kph 12/6/2008 01:18'!printOn: aStream	aStream		nextPutAll: self runCount printString;		nextPutAll: ' run, ';		nextPutAll: self passedCount printString;		nextPutAll: ' passes, '; 		nextPutAll: self failureCount printString;		nextPutAll: ' failures, ';		nextPutAll: self errorCount printString;		nextPutAll:' errors, '. ! !!TestResult methodsFor: 'compatibility' stamp: 'kph 2/20/2007 17:11'!printResultFor: test	(self isError: test) ifTrue: [ ^ 'Error' ].	(self isFailure: test) ifTrue: [ ^ 'Failure' ].	(self isPassed: test) ifTrue:  [ ^ 'Pass' ].! !!TestResult methodsFor: 'running' stamp: 'kph 3/13/2007 15:21'!runCase: aTestCase	| testCasePassed |	testCasePassed := true.	[[aTestCase runCase] 			on: self class failure			do: 				[:signal | 				self fail: aTestCase dueTo: signal messageText.				testCasePassed := false.				signal return: false]]					on: self class error					do:						[:signal |						self error: aTestCase dueTo: signal messageText.						testCasePassed := false.						signal return: false].	testCasePassed ifTrue: [self pass: aTestCase]! !!TestResultTimed class methodsFor: 'file in/out' stamp: 'kph 2/22/2007 07:18'!exportAllOn: out	out nextPutAll:  ('!!',(self name), ' lastResults !!'); cr.			self lastResults exportAllOn: out.	 ! !!TestResultTimed class methodsFor: 'as yet unclassified' stamp: 'kph 2/22/2007 07:17'!freeSomeSpace	self resetLastResults! !!TestResultTimed class methodsFor: 'accessing' stamp: 'kph 2/20/2007 11:46'!lastResults ^ LastResults! !!TestResultTimed class methodsFor: 'accessing' stamp: 'kph 2/23/2007 17:19'!long ^ Long ifNil: [ 15000 ]! !!TestResultTimed class methodsFor: 'accessing' stamp: 'kph 2/20/2007 10:53'!long: secsLong := secs! !!TestResultTimed class methodsFor: 'as yet unclassified' stamp: 'kph 2/17/2007 04:12'!newTo: reporter^ self new reporter: reporter; yourself! !!TestResultTimed class methodsFor: 'as yet unclassified' stamp: 'kph 2/22/2007 20:04'!resetLastResults	LastResults := self new.! !!TestResultTimed class methodsFor: 'accessing' stamp: 'kph 2/23/2007 17:18'!slow^Slow ifNil: [ 3000 ]! !!TestResultTimed class methodsFor: 'accessing' stamp: 'kph 2/22/2007 10:41'!slow: secsSlow := secs! !!TestResultTimed class methodsFor: 'reports' stamp: 'kph 2/22/2007 15:57'!timingTotals	| all allN long slow longN short shortN slowN min |		all := long := slow := short := longN := slowN := shortN := 0.	self lastResults timings keysAndValuesDo: [ :test :timing | 			all := all + timing.		timing > self long 			ifTrue:[ long := long + timing. longN := longN + 1 ]			ifFalse:[ 				timing > self slow 					ifTrue: [ slow := slow + timing. slowN := slowN + 1 ]					ifFalse: [ short := short + timing. shortN := shortN + 1 ]			]	].	min := 60000.	allN := self lastResults tests size.	^ 'All ', allN printString ,' tests run in ', (all//min) printString,' minutes.', shortN printString,'(', (shortN * 100 // allN) printString,'%) short tests run in ', (short//min) printString, ' minutes', slowN printString, '(', (slowN * 100 // allN) printString,'%) slow tests run in ', (slow//min) printString, ' minutes', longN printString, '(', (longN * 100 // allN) printString,'%) long tests run in ', (long//min) printString, ' minutes'	 ! !!TestResultTimed methodsFor: 'as yet unclassified' stamp: 'kph 2/18/2007 01:56'!error: test dueTo: reason	super error: test dueTo: reason.	reporter error: test dueTo: reason.! !!TestResultTimed methodsFor: 'fileout' stamp: 'kph 2/20/2007 19:49'!export: test on: out	out nextPutAll: test printForList;		space;		nextPutAll: (self printResultFor: test);		space;		nextPutAll: (self timings at: test) printString;		space;		nextPutAll: ((self usesNetwork at: test) ifTrue: [ 'net' ] ifFalse: [ 'local' ]);		yourself. ! !!TestResultTimed methodsFor: 'fileout' stamp: 'kph 2/20/2007 19:12'!exportAllOn: out	^self tests do: [ :test | 		self export: test on: out. 		out cr.	 ].! !!TestResultTimed methodsFor: 'as yet unclassified' stamp: 'kph 2/18/2007 01:56'!fail: test dueTo: reason	super fail: test dueTo: reason.	reporter fail: test dueTo: reason.! !!TestResultTimed methodsFor: 'as yet unclassified' stamp: 'kph 2/20/2007 09:05'!initialize	 	super initialize.	usesNetwork := Dictionary new.	timings := Dictionary new.	LastResults := self. ! !!TestResultTimed methodsFor: 'auto-categorization' stamp: 'kph 2/21/2007 01:10'!markExpected: expected	(self failures, self errors) do: [ :test |		(test isCategoryMarkedWith: expected) ifFalse: [ test addCategoryMark: expected ]	]. 	self passed do: [ :test |		(test isCategoryMarkedWith: expected) ifTrue: [ test removeCategoryMark: expected ].	].  ! !!TestResultTimed methodsFor: 'auto-categorization' stamp: 'kph 2/22/2007 14:24'!markTestResultsFail: fail error: error pass: pass expected: expected	"we mark the errors and failures, 	 we ensure that expected is preserved but marked last	we unmark passed and remove any expected flag from passed tests"	self failures do: [ :test |		(test isCategoryMarkedWith: fail) ifFalse: [ test addCategoryMark: fail ].	].	self errors do: [ :test |		(test isCategoryMarkedWith: error) ifFalse: [ test addCategoryMark: error ].			].	self failures, self errors do: [ :test |		(test isCategoryMarkedWith: expected) 		 ifTrue: [ test removeCategoryMark: expected.			       test addCategoryMark: expected ].	].	self unmark: {fail. error. expected.} onTests: self result passed. 		 	! !!TestResultTimed methodsFor: 'auto-categorization' stamp: 'kph 2/21/2007 00:56'!markTestsUsingNetworkWith: netself usesNetwork keysAndValuesDo: [ :test :uses |	(test isCategoryMarkedWith: net) 		ifTrue: [ uses ifFalse: [ test removeCategoryMark: net ] ]		ifFalse: [ uses ifTrue: [ test addCategoryMark: net ] ]].! !!TestResultTimed methodsFor: 'auto-categorization' stamp: 'kph 2/22/2007 07:07'!markTestsWith: mark satisfying: aBlock	| ar |self timings keysAndValuesDo: [ :test :time |	ar := aBlock value: test value: time.	(test isCategoryMarkedWith: mark) 		ifTrue: [ ar ifFalse: [ test removeCategoryMark: mark ] ]		ifFalse: [ ar ifTrue: [ test addCategoryMark: mark ] ]].! !!TestResultTimed methodsFor: 'as yet unclassified' stamp: 'kph 2/18/2007 01:56'!pass: test	super pass: test.	reporter pass: test.! !!TestResultTimed methodsFor: 'as yet unclassified' stamp: 'kph 2/17/2007 04:11'!reporter: aTestReporter	reporter := aTestReporter! !!TestResultTimed methodsFor: 'as yet unclassified' stamp: 'test 3/13/2007 19:41'!runCase: aTestCase		| netUsed statsBefore |  	(Socket respondsTo: #statsOpened) ifTrue: [ statsBefore := Socket statsOpened ] .	self timings at: aTestCase put: ([ super runCase: aTestCase ] timeToRun).	(Socket respondsTo: #statsOpened) ifTrue: [ 		netUsed :=  statsBefore ~= Socket statsOpened.		self usesNetwork at: aTestCase put: netUsed.	]. ! !!TestResultTimed methodsFor: 'fileout' stamp: 'kph 2/22/2007 06:57'!scanFrom: str	| data test result |  	"tweak the stream to read file endings properly since FileList hasnt done it"     str next.	[ (str atEnd or: [(data := str nextLine) isEmpty ]) ] whileFalse: [ 	 		data := data findTokens: ' ' .		test :=  (Smalltalk at: (data at: 1) asSymbol ifAbsent: [ UndefinedObject ]).		(test respondsTo: #selector:) ifTrue: [			test := test selector: (data at: 2) asSymbol.			result := (data at: 3).			(result = 'Error') ifTrue: [ errors add: test ].			(result = 'Failure') ifTrue: [ failures add: test ].			(result = 'Pass') ifTrue: [ passed add: test ].			self timings at: test put: (data at: 4) asInteger.			self usesNetwork at: test put: ((data at: 5) = 'net').		].	].	str nextChunk.! !!TestResultTimed methodsFor: 'as yet unclassified' stamp: 'kph 1/6/2007 16:48'!timings	^ timings ! !!TestResultTimed methodsFor: 'as yet unclassified' stamp: 'kph 2/21/2007 01:03'!unmark: marks onTests: tests	tests do: [ :test |		marks do: [ :mark | 			(test isCategoryMarkedWith: mark) ifTrue: [ test removeCategoryMark: mark ].		]	].! !!TestResultTimed methodsFor: 'as yet unclassified' stamp: 'kph 2/21/2007 01:03'!unmarkTests: marks	self unmark: marks onTests: (self result failures, self result errors, self result passed) ! !!TestResultTimed methodsFor: 'as yet unclassified' stamp: 'kph 1/6/2007 16:48'!usesNetwork	^ usesNetwork! !!TestSuite class methodsFor: 'instance creation' stamp: 'test 8/28/2008 16:48'!classes: classes suites: suites select: selectFilters reject: rejectFilters	 ^self new fromClasses: classes suites: suites select: selectFilters reject: rejectFilters	! !!TestSuite class methodsFor: 'instance creation' stamp: 'kph 8/28/2008 16:03'!define: aBlock 	^ (self new) 		in: aBlock; 		yourself! !!TestSuite methodsFor: 'accessing' stamp: 'kph 8/28/2008 15:50'!, aSuite	self addTests: aSuite tests! !!TestSuite methodsFor: 'accessing' stamp: 'kph 8/28/2008 15:53'!- aSuite	self removeTests: aSuite tests! !!TestSuite methodsFor: 'accessing' stamp: 'kph 11/1/2006 20:24'!add: aTest 	self tests add: aTest! !!TestSuite methodsFor: 'accessing' stamp: 'kph 12/16/2006 05:20'!addTests: aCollection 	self tests addAll: aCollection		! !!TestSuite methodsFor: 'filtering' stamp: 'kph 8/28/2008 15:42'!fromClasses: classes suites: suites select: selectFilters reject: rejectFilters	classes do: [ :testClass | 		suites do: [ :suite | 			self addTests: (testClass suite: suite) tests.		].							(selectFilters isNil or:[ selectFilters isEmpty]) ifFalse: [ 				selectFilters do: [ :sf | tests := tests intersection: (testClass suite: sf) tests ].		].		(rejectFilters isNil or:[ rejectFilters isEmpty]) ifFalse: [ 				rejectFilters do: [ :rf | tests := tests difference: (testClass suite: rf) tests ].				]	].		^self ! !!TestSuite methodsFor: 'accessing' stamp: 'kph 8/29/2008 02:14'!intersection: aSuite	tests := tests intersection: aSuite tests! !!TestSuite methodsFor: 'accessing' stamp: 'kph 12/16/2006 07:21'!removeAllTests  tests := nil.! !!TestSuite methodsFor: 'accessing' stamp: 'kph 8/28/2008 00:30'!removeTests: aCollection 	tests removeAllFoundIn: aCollection		! !!TestSuite methodsFor: 'running' stamp: 'kph 11/1/2006 20:21'!run	| result |	result := TestResult new.	self resources		do: [:res | res isAvailable				ifFalse: [^ res signalInitializationError]].	[self runOn: result]		ensure: [self resources				do: [:each | each reset]].	^ result! !!TestSuite methodsFor: 'running' stamp: 'kph 11/1/2006 20:21'!runOn: aResult 	self tests		do: [:each | 			self changed: each.			each runOn: aResult]! !!TestSuite methodsFor: 'accessing' stamp: 'kph 12/16/2006 05:19'!tests	tests isNil ifTrue: [tests := Set new].	^tests			! !!SimpleTestResourceTestCase class methodsFor: 'Not categorized' stamp: 'kph 9/13/2007 18:22'!resources	^Set with: SimpleTestResource! !!SUnitExtensionsTest methodsFor: 'tests' stamp: 'md 4/2/2006 14:02'!testExceptionWithMatchingString	self should: [ Object obsolete ] raise: Error whoseDescriptionIncludes: 'NOT obsolete' description: 'tested obsoleting Object'! !!SUnitExtensionsTest methodsFor: 'tests' stamp: 'md 4/2/2006 14:02'!testExceptionWithoutMatchingString	self should: [ Object obsolete ] raise: Error whoseDescriptionDoesNotInclude: 'Zero' description: 'tested obsoleting Object'! !!SUnitExtensionsTest methodsFor: 'tests' stamp: 'md 4/2/2006 14:02'!testNoExceptionWithMatchingString	self shouldnt: [ Object obsolete ] raise: Error whoseDescriptionIncludes: 'Zero' description: 'tested obsoleting Object'! !!SUnitExtensionsTest methodsFor: 'tests' stamp: 'md 4/2/2006 14:02'!testNoExceptionWithNoMatchingString	self shouldnt: [ Object obsolete ] raise: Error whoseDescriptionDoesNotInclude: 'NOT' description: 'tested obsoleting Object'! !!ClassClonerTestResource commentStamp: 'kph 12/20/2006 20:01' prior: 0!To enable testing of class-side behaviour without disturbing the class, or its superclasses which are singletons in use.This TestResource provides a clone of an existing class on demand. Clones are created to behave in the same manner as the original class except that class vars are local copies, and its methods have been recompiled to reference them.usage: (in fixture setup)"obtain the clone"clonedClass := ClassClonerTestResource current cloneOf: DateAndTime."the clone needs to be explicitly reset to a known state as needed before each test."clonedClass initialize.!!TestCase commentStamp: 'kph 8/28/2008 18:29' prior: 32135897!A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.Modification Notes: KPH 16/12/06======================================Removed the magic that a TestCase subclass with no test selectors automatically inherits testSelectors. This can and should be explicitly set by overriding #shouldInheritSelectors to true so as to make the behaviour explicit.simplification/refactoring/enhancement:    All hard wired references to 'test*' have been removed from the suiteBuild protocol, indeed the suiteBuild protocol has been greatly simplified/removed.More flexible suite building API:Additional assertsadded #assert:equals and #assert:includes  Future:The expectedFailures mechanism may not be needed anymore, and needlessly complicates the results.    !!TestCaseVersioned commentStamp: 'kph 5/1/2007 18:30' prior: 0!TestCaseVersioned provides a set of mechanisms for marking tests for specific versions of squeak, the vm, or the platform on which squeak is running. These are made available to the user in TestRunner as a simple single filter "Not This Version Or Platform", enabling exclusion of any tests that are not expected to work with the current configuration.Platform Specific Tests:---------------------------Within a test use flags:self suite: #MacOsSpecificTestor self flag: #WindowsSpecificTestThe filter is constructed by including all of the platform specific tests, and then excluding the tests for the current platform. The result is a filter that will remove any tests marked for a platform that is not this one. This filter is part of the "Not This Version Or Platform".Squeak Version related tests--------------------------------These are flagged using the method categories.You can place a test in category, with the version, and various keywords.Keywords are: 'earlier' 'only' 'later' and 'vm'.e.g.Squeak3.8vm and earlier !!TestReporter commentStamp: 'kph 3/13/2007 20:39' prior: 0!TestReporter usageTo run with the default suites and filters:	TestReporter new runCategories: 'Rio-*'.Full results are written to directory 'tests', failures and errors list can be filed in from fileList.!"SUnit"!DTDEntityDeclaration class removeSelector: #initialize!DTDEntityDeclaration removeSelector: #name:!DTDEntityDeclaration removeSelector: #ndata:!DTDEntityDeclaration removeSelector: #value:!XMLStringNode removeSelector: #string:!XMLNode removeSelector: #firstTagNamed:!XMLNode removeSelector: #firstTagNamed:with:!XMLElement removeSelector: #addContent:!XMLElement removeSelector: #attributes!XMLElement removeSelector: #contentString!XMLElement removeSelector: #contents!XMLElement removeSelector: #contentsDo:!XMLElement removeSelector: #isEmpty!XMLElement removeSelector: #name:!XMLElement removeSelector: #printXMLOn:!XMLElement removeSelector: #setAttributes:!XMLNodeWithElements removeSelector: #addElement:!XMLNodeWithElements removeSelector: #elementAt:ifAbsent:!XMLNodeWithElements removeSelector: #elementUnqualifiedAt:ifAbsent:!XMLNodeWithElements removeSelector: #elements!XMLNodeWithElements removeSelector: #elementsDo:!XMLNodeWithElements removeSelector: #namespace:uri:!XMLNamespaceScope removeSelector: #namespaceAliases:!XMLNamespaceScope removeSelector: #validateAttributes:!XMLDocument removeSelector: #dtd:!XMLDocument removeSelector: #encoding:!XMLDocument removeSelector: #printCanonicalOn:!XMLDocument removeSelector: #requiredMarkup:!XMLDocument removeSelector: #version:!SAXHandler class removeSelector: #on:!SAXHandler class removeSelector: #parseDTDFrom:!SAXHandler class removeSelector: #parseDocumentFrom:!SAXHandler class removeSelector: #parseDocumentFromFileNamed:readIntoMemory:!SAXHandler class removeSelector: #parserOnFileNamed:readIntoMemory:!SAXHandler removeSelector: #document:!SAXHandler removeSelector: #driver:!SAXHandler removeSelector: #endDocument!SAXHandler removeSelector: #initialize!XMLTokenizer class removeSelector: #initialize!SAXDriver removeSelector: #handleEndTag:!SAXDriver removeSelector: #handlePCData:!SAXDriver removeSelector: #handleStartTag:attributes:namespaces:!SAXDriver removeSelector: #saxHandler:!SAXDriver removeSelector: #splitName:into:!XMLTokenizer class removeSelector: #addressBookXMLWithDTD!XMLTokenizer class removeSelector: #exampleAddressBook!XMLTokenizer class removeSelector: #exampleAddressBookWithDTD!XMLTokenizer class removeSelector: #isCharEscape:!XMLTokenizer removeSelector: #checkAndExpandReference:!XMLTokenizer removeSelector: #endParsingMarkup!XMLTokenizer removeSelector: #entities!XMLTokenizer removeSelector: #externalEntities!XMLTokenizer removeSelector: #fastStreamStringContents:!XMLTokenizer removeSelector: #handleEntity:in:!XMLTokenizer removeSelector: #initEntities!XMLTokenizer removeSelector: #initialize!XMLTokenizer removeSelector: #nestedStreams!XMLTokenizer removeSelector: #next!XMLTokenizer removeSelector: #nextAttributeInto:namespaces:!XMLTokenizer removeSelector: #nextAttributeValue!XMLTokenizer removeSelector: #nextCDataContent!XMLTokenizer removeSelector: #nextCDataOrConditional!XMLTokenizer removeSelector: #nextCharReference!XMLTokenizer removeSelector: #nextComment!XMLTokenizer removeSelector: #nextDocType!XMLTokenizer removeSelector: #nextDocTypeDecl!XMLTokenizer removeSelector: #nextEndTag!XMLTokenizer removeSelector: #nextEntity!XMLTokenizer removeSelector: #nextEntityDeclaration!XMLTokenizer removeSelector: #nextEntityValue!XMLTokenizer removeSelector: #nextExternalId!XMLTokenizer removeSelector: #nextIncludeSection:!XMLTokenizer removeSelector: #nextLiteral!XMLTokenizer removeSelector: #nextMarkupDeclaration!XMLTokenizer removeSelector: #nextName!XMLTokenizer removeSelector: #nextNode!XMLTokenizer removeSelector: #nextPCData!XMLTokenizer removeSelector: #nextPI!XMLTokenizer removeSelector: #nextTag!XMLTokenizer removeSelector: #nextTrimmedBlanksUpTo:!XMLTokenizer removeSelector: #nextUpTo:!XMLTokenizer removeSelector: #nextUpToAll:!XMLTokenizer removeSelector: #nextWhitespace!XMLTokenizer removeSelector: #nextXMLDecl!XMLTokenizer removeSelector: #parameterEntities!XMLTokenizer removeSelector: #peek!XMLTokenizer removeSelector: #popNestingLevel!XMLTokenizer removeSelector: #pushBack:!XMLTokenizer removeSelector: #readNumberBase:!XMLTokenizer removeSelector: #skipSeparators!XMLTokenizer removeSelector: #skipUpTo:!XMLTokenizer removeSelector: #startParsingMarkup!XMLTokenizer removeSelector: #stream:!XMLTokenizer removeSelector: #unpeek!XMLTokenizer removeSelector: #validating:!DTDParameterEntityDeclaration class removeSelector: #initialize!XMLWriter removeSelector: #canonical:!XMLWriter removeSelector: #endTag!XMLWriter removeSelector: #endTag:!XMLWriter removeSelector: #initialize!XMLWriter removeSelector: #popTag:!XMLWriter removeSelector: #startTag:!XMLWriter removeSelector: #stream:!XMLWriter removeSelector: #xmlDeclaration:encoding:!XMLPI removeSelector: #data:!XMLPI removeSelector: #target:!DTDExternalEntityDeclaration class removeSelector: #initialize!XMLDOMParser class removeSelector: #addressBookXMLWithDTD!XMLDOMParser class removeSelector: #parseDocumentFrom:!XMLDOMParser removeSelector: #characters:!XMLDOMParser removeSelector: #documentAttributes:!XMLDOMParser removeSelector: #endElement:!XMLDOMParser removeSelector: #endElement:namespace:namespaceURI:qualifiedName:!XMLDOMParser removeSelector: #incremental:!XMLDOMParser removeSelector: #initialize!XMLDOMParser removeSelector: #nextEntity!XMLDOMParser removeSelector: #pop!XMLDOMParser removeSelector: #processingInstruction:data:!XMLDOMParser removeSelector: #push:!XMLDOMParser removeSelector: #startElement:attributeList:!XMLDOMParser removeSelector: #startElement:namespaceURI:namespace:attributeList:!SAXHandler class removeSelector: #new!XMLTokenizer class removeSelector: #new!!String methodsFor: '*xml-parser' stamp: 'mir 7/14/2006 11:54'!applyLanguageInfomation: languageEnvironment		| leadingChar |	leadingChar := languageEnvironment leadingChar.	self withIndexDo: [:each :idx |		each asciiValue > 255			ifTrue: [self at: idx put: (Character leadingChar: leadingChar code: each asUnicode)]]! !!DTDEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/15/2002 18:02'!initialize	"DTDEntityDeclaration initialize"	contextBehavior := Dictionary new.	contextBehavior		at: #content put: #include ;		at: #attributeValueContent put: #includedInLiteral ;		at: #attributeValue put: #forbidden ;		at: #entityValue put: #bypass ;		at: #dtd put: #forbidden ! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:25'!name: aString	name := aString asSymbol! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:22'!ndata: aString	ndata := aString! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 11/16/2000 10:55'!value: aString	value := aString! !!XMLStringNode methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:28'!string: aString	string := aString! !!XMLNode methodsFor: 'enumerating' stamp: 'mir 10/31/2007 18:02'!elementsAndContentsDo: aBlock	self elementsDo: aBlock! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:52'!firstTagNamed: aSymbol 	"Return the first encountered node with the specified tag. Pass the message on"	| answer |	self elementsDo: [:node | (answer := node firstTagNamed: aSymbol) ifNotNil: [^answer]].	^nil! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!firstTagNamed: aSymbol with: aBlock	"Return the first encountered node with the specified tag that	allows the block to evaluate to true. Pass the message on"	| answer |	self elementsDo: [:node |		(answer := node firstTagNamed: aSymbol with: aBlock) ifNotNil: [^answer]].	^nil! !!XMLElement methodsFor: 'initialize' stamp: 'mir 10/31/2007 17:55'!addContent: contentString	self addElement: contentString! !!XMLElement methodsFor: 'accessing' stamp: 'mas 10/15/2003 09:18'!attributes	^attributes ifNil: [attributes := Dictionary new]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 10/31/2007 18:25'!contentString	| contentElements |	contentElements := self elementsAndContents.	^(contentElements size == 1		and: [contentElements first isText])		ifTrue: [contentElements first string]		ifFalse: ['']! !!XMLElement methodsFor: 'accessing' stamp: 'mir 10/31/2007 18:24'!contents	^self elementsAndContents select: [:each | each isText]! !!XMLElement methodsFor: 'enumerating' stamp: 'mir 10/31/2007 18:25'!contentsDo: aBlock	self elementsAndContentsDo: [:each | each isText ifTrue: [aBlock value: each]]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 10/31/2007 18:25'!elements	^self elementsAndContents select: [:each | each isText not]! !!XMLElement methodsFor: 'enumerating' stamp: 'mir 1/3/2008 14:18'!elementsAndContentsDo: aBlock	self elementsAndContents do: aBlock! !!XMLElement methodsFor: 'enumerating' stamp: 'mir 10/31/2007 18:25'!elementsDo: aBlock	self elementsAndContentsDo: [:each | each isText ifFalse: [aBlock value: each]]! !!XMLElement methodsFor: 'testing' stamp: 'mir 10/31/2007 17:55'!isEmpty	^self elements isEmpty! !!XMLElement methodsFor: 'initialize' stamp: 'mir 1/17/2002 15:24'!name: aString	name := aString asSymbol! !!XMLElement methodsFor: 'accessing' stamp: 'gc 6/28/2007 21:32'!parent	^ parent! !!XMLElement methodsFor: 'accessing' stamp: 'gc 6/28/2007 21:32'!parent: anXMLElement	parent := anXMLElement ! !!XMLElement methodsFor: 'printing' stamp: 'mir 10/31/2007 18:19'!printXMLOn: writer	writer startElement: self name attributeList: self attributes.	(writer canonical not		and: [self isEmpty and: [self attributes isEmpty not]])		ifTrue: [writer endEmptyTag: self name]		ifFalse: [			writer endTag.			self elementsAndContentsDo: [:content | content printXMLOn: writer].			writer endTag: self name]! !!XMLElement methodsFor: 'initialize' stamp: 'mir 3/7/2000 16:43'!setAttributes: newAttributes	attributes := newAttributes! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:25'!addElement: element	self elementsAndContents add: element! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:23'!elementAt: entityName ifAbsent: aBlock	elementsAndContents		ifNil: [^aBlock value].	^self elements detect: [:each | each isProcessingInstruction not and: [each name = entityName or: [each localName = entityName]]] ifNone: [^aBlock value]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:23'!elementUnqualifiedAt: entityName ifAbsent: aBlock	elementsAndContents		ifNil: [^aBlock value].	^self elements detect: [:each | each localName = entityName] ifNone: [^aBlock value]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:13'!elements	^self elementsAndContents! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:13'!elementsAndContents	elementsAndContents ifNil: [elementsAndContents := OrderedCollection new].	^elementsAndContents! !!XMLNodeWithElements methodsFor: 'enumerating' stamp: 'mir 11/14/2007 17:21'!elementsDo: aBlock	self elements do: [:each | aBlock value: each]! !!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/16/2003 16:21'!namespace: ns uri: u	namespace := ns.	uri := u! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/5/2003 19:32'!namespaceAliases: namespace	"Locate all namespaces that are aliases of the given URI."	| aliases uri |	aliases := Set new.	uri := self namespaceURIOf: namespace ifAbsent: [self parseError: 'Attribute refers to undefined namespace ' , namespace asString ].	currentBindings keysAndValuesDo: [:ns :u |		(u = uri			and: [ns ~= namespace])			ifTrue: [aliases add: ns]].	^ aliases! !!XMLNamespaceScope methodsFor: 'validation' stamp: 'mir 6/5/2003 17:16'!validateAttributes: attributeList	"check all attribute namespaces are defined and not duplicated by aliasing"	| namespace localName |	attributeList keysDo: [:attrName |		self splitName: attrName into: [:ns :ln |			namespace := ns.			localName := ln].		namespace ifNotNil: [			(self namespaceAliases: namespace) do: [:alias |				(attributeList includesKey: alias , ':' , localName)					ifTrue: [self parseError: 'Attributes ' , attrName , ' and ' , alias , ':' , localName , ' are aliased to namespace ' , (self namespaceURIOf: namespace) ]]]]! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 11/30/2000 17:48'!dtd: aDTD	dtd := aDTD! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!encoding: aString		encoding := aString! !!XMLDocument methodsFor: 'printing' stamp: 'mir 1/17/2002 16:44'!printCanonicalOn: aStream	| writer |	writer := XMLWriter on: aStream.	writer canonical: true.	self printXMLOn: writer! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!requiredMarkup: aString		requiredMarkup := aString! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 11/29/2007 14:42'!root	"return my root element"	^ self topElement ! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!version: aString		version := aString! !!SAXHandler class methodsFor: 'instance creation' stamp: 'sd 5/23/2003 15:19'!on: aStream	| driver parser |	driver := SAXDriver on: aStream.	driver validating: true.	parser := self new driver: driver.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'cwp 5/28/2003 02:08'!parseDTDFrom: aStream	| driver parser |	driver := SAXDriver on: aStream.	driver validating: true.	driver startParsingMarkup.	parser := self new driver: driver.	parser startDocument.	parser parseDocument.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:24'!parseDocumentFrom: aStream	^self parseDocumentFrom: aStream useNamespaces: false! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:26'!parseDocumentFrom: aStream useNamespaces: aBoolean	|  parser |	parser := self on: aStream.	parser useNamespaces: aBoolean.	parser startDocument.	parser parseDocument.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 1/8/2002 15:55'!parseDocumentFromFileNamed: fileName readIntoMemory: readIntoMemory	| stream xmlDoc |	stream := FileDirectory default readOnlyFileNamed: fileName.	readIntoMemory		ifTrue: [stream := stream contentsOfEntireFile readStream].	[xmlDoc := self parseDocumentFrom: stream]		ensure: [stream close].	^xmlDoc! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 19:14'!parserOnFileNamed: fileName readIntoMemory: readIntoMemory	| stream  |	stream := FileDirectory default readOnlyFileNamed: fileName.	readIntoMemory		ifTrue: [stream := stream contentsOfEntireFile readStream].	^self on: stream! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 11/30/2000 18:12'!document: aDocument	document := aDocument! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:34'!driver: aDriver	driver := aDriver.	driver saxHandler: self! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:26'!endDocument	"This call corresponds to the Java SAX call	endDocument()."	eod := true! !!SAXHandler methodsFor: 'initialize' stamp: 'mir 1/8/2002 18:18'!initialize	eod := false! !!XMLTokenizer class methodsFor: 'class initialization' stamp: 'mir 10/31/2007 17:22'!initialize	"XMLTokenizer initialize"	CharEscapes := CharacterSet newFrom: #( $& $" $' $> $< ).	SeparatorTable  := CharacterSet new.	#(9 10 12 13 32) do: [:each | SeparatorTable add: each asCharacter].	LiteralChars := CharacterSet newFrom: #( $: $- $: $= $.).	0 to: 255 do: [:i | 		| char |		char := i asCharacter.		(char isDigit or: [char isLetter])		ifTrue: [LiteralChars add: char]].	NameDelimiters := CharacterSet new.	#(9 10 12 13 32 61 "$= asInteger 61" 62 "$> asInteger" 47 "$/ asInteger")		do: [:each | NameDelimiters add: each asCharacter].	DigitTable := Array new: 256.	DigitTable atAllPut: -1.	($0 to: $9) do: [:each | DigitTable at: each asciiValue put: each digitValue].	($a to: $f) do: [:each | DigitTable at: each asciiValue put: each digitValue].	($A to: $F) do: [:each | DigitTable at: each asciiValue put: each digitValue].! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 6/24/2003 13:36'!handleEndTag: elementName	| namespace localName namespaceURI qualifiedName |	self usesNamespaces		ifTrue: [			self splitName: elementName into: [:ns :ln |				namespace := ns.				localName := ln].			"ensure our namespace is defined"			namespace				ifNil: [					namespace := self scope defaultNamespace.					qualifiedName := namespace , ':' , elementName]				ifNotNil: [					namespaceURI := self scope namespaceURIOf: namespace.					namespaceURI						ifNil: [self parseError: 'Start tag ' , elementName , ' refers to undefined namespace ' , namespace asString].					qualifiedName := elementName].			"call the handler"			self saxHandler				checkEOD; 				endElement: localName namespace: namespace namespaceURI: namespaceURI qualifiedName: qualifiedName.			self scope leaveScope]		ifFalse: [			"call the handler"			self saxHandler				checkEOD; 				endElement: elementName namespace: nil namespaceURI: nil qualifiedName: elementName]! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 7/14/2006 11:55'!handlePCData: aString	self languageEnvironment		ifNotNil: [aString applyLanguageInfomation: self languageEnvironment].	self saxHandler		checkEOD; 		characters: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 7/14/2006 11:49'!handleStartTag: elementName attributes: attributeList namespaces: namespaces	| localName namespace namespaceURI |	(attributeList includesKey: 'xml:lang')		ifTrue: [languageEnvironment := LanguageEnvironment localeID: (LocaleID isoString: (attributeList at: 'xml:lang'))].	self usesNamespaces		ifTrue: [			self scope enterScope.				"declare any namespaces"					namespaces keysAndValuesDo: [:ns :uri |					self scope declareNamespace: ns uri: uri].			self splitName: elementName into: [:ns :ln |				namespace := ns.				localName := ln].			"ensure our namespace is defined"			namespace				ifNil: [namespace := self scope defaultNamespace]				ifNotNil: [					namespaceURI := self scope namespaceURIOf: namespace.					namespaceURI						ifNil: [self parseError: 'Start tag ' , elementName , ' refers to undefined namespace ' , namespace asString]].			self validatesAttributes				ifTrue: [self scope validateAttributes: attributeList].			"call the handler"			self saxHandler				checkEOD; 				startElement: localName namespaceURI: namespaceURI namespace: namespace attributeList: attributeList]		ifFalse: [			"call the handler"			self saxHandler				checkEOD; 				startElement: elementName namespaceURI: nil namespace: nil attributeList: attributeList]! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 7/14/2006 11:48'!languageEnvironment	^languageEnvironment! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 8/11/2000 17:52'!saxHandler: aHandler	saxHandler := aHandler! !!SAXDriver methodsFor: 'namespaces' stamp: 'mir 6/16/2003 13:09'!splitName: aName into: twoArgsBlock	"Split the name into namespace and local name (the block arguments).	Handle both qualified and unqualified names using the default name space"	| i ns ln |	i := aName lastIndexOf: $:.	i = 0		ifTrue: [			ns := nil.			ln := aName]		ifFalse: [			ns := aName copyFrom: 1 to: (i - 1).			ln := aName copyFrom: i+1 to: aName size].	twoArgsBlock value: ns value: ln! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 7/12/2006 16:49'!addressBookXMLWithDTD	^'<?xml version="1.0" encoding="UTF-8"?><!!DOCTYPE addressbook SYSTEM "addressbook.dtd"><?xml-stylesheet type="text/xsl" href="demo.xsl"?><addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 11:41'!exampleAddressBook	| tokenizer |	"XMLTokenizer exampleAddressBook"	tokenizer := XMLTokenizer on: self addressBookXML readStream.	[tokenizer next notNil]		whileTrue: []! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 16:23'!exampleAddressBookWithDTD	| tokenizer |	"XMLTokenizer exampleAddressBookWithDTD"	tokenizer := XMLTokenizer on: self addressBookXMLWithDTD readStream.	[tokenizer next notNil]		whileTrue: []! !!XMLTokenizer class methodsFor: 'accessing' stamp: 'mir 11/23/2007 15:50'!isCharEscape: entityValue	^entityValue size = 1		and: [CharEscapes includes: entityValue first]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:12'!checkAndExpandReference: parsingContext	| referenceString nextChar |	nextChar := self peek.	self validating		ifFalse: [^nil].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [^self pushStream: (ReadStream on: self nextCharReference asString)].			referenceString := self nextLiteral.			self next == $;				ifFalse: [self errorExpected: ';'].			self handleEntity: referenceString in: parsingContext ]		ifFalse: [			((nextChar == $%				and: [self parsingMarkup])				and: [parsingContext == #entityValue])				ifTrue: [					self skipSeparators.					referenceString := self nextLiteral.					self handleEntity: referenceString in: parsingContext]].	self atEnd ifTrue: [self errorExpected: 'Character expected.'].	^nextChar! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!endParsingMarkup	parsingMarkup := false! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 15:06'!entities	entities ifNil: [entities := self initEntities].	^entities! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 17:59'!externalEntities	externalEntities ifNil: [externalEntities := Dictionary new].	^externalEntities! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 3/14/2003 23:09'!fastStreamStringContents: writeStream	| newSize |	newSize := writeStream position.	^(String new: newSize)		replaceFrom: 1		to: newSize		with: writeStream originalContents		startingAt: 1! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/17/2002 18:12'!handleEntity: referenceString in: parsingContext 	| entity entityValue |	entity := self entity: referenceString.	entityValue := entity valueForContext: parsingContext.	(self class isCharEscape: entityValue)		ifTrue: [entityValue := entity reference].	self pushStream: (ReadStream on: entityValue asString)! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/23/2007 15:45'!initEntities	| ents |	ents := Dictionary new.	ents		at: 'amp' put: (DTDEntityDeclaration name: 'amp' value: '&');		at: 'quot' put: (DTDEntityDeclaration name: 'quot' value: '"');		at: 'apos' put: (DTDEntityDeclaration name: 'apos' value: '''');		at: 'gt' put: (DTDEntityDeclaration name: 'gt' value: '>');		at: 'lt' put: (DTDEntityDeclaration name: 'lt' value: '<').	^ents! !!XMLTokenizer methodsFor: 'initialize' stamp: 'mir 3/14/2003 19:27'!initialize	parsingMarkup := false.	validating := false.	attributeBuffer := WriteStream on: (String new: 128).	nameBuffer := WriteStream on: (String new: 128)! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 11/23/2007 18:16'!match: subCollection into: resultStream	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."	| pattern startMatch |	pattern _ ReadStream on: subCollection.	startMatch _ nil.	[pattern atEnd] whileFalse: 		[self atEnd ifTrue: [^ false].		(self next) = (pattern next) 			ifTrue: [pattern position = 1 ifTrue: [startMatch _ self position]]			ifFalse: [pattern position: 0.					startMatch ifNotNil: [						self position: startMatch.						startMatch _ nil]]].	^ true! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:54'!nestedStreams	nestedStreams ifNil: [nestedStreams := OrderedCollection new].	^nestedStreams! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:04'!next	"Return the next character from the current input stream. If the current stream is at end pop to next nesting level if there is one.	Due to the potential nesting of original document, included documents and replacment texts the streams are held in a stack representing the nested streams. The current stream is the top one."	| nextChar |	peekChar		ifNil: [			nestedStreams ifNotNil: [self checkNestedStream].			^nextChar := stream next]		ifNotNil: [			nextChar := peekChar.			peekChar := nil.			^nextChar].	! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 16:32'!nextAttributeInto: attributes namespaces: namespaces	| attrName attrValue |	attrName := self nextName.	self skipSeparators.	self next == $=		ifFalse: [self errorExpected: '='].	self skipSeparators.	attrValue := self nextAttributeValue.	(self usesNamespaces		and: [(attrName findString: 'xmlns') = 1])		ifTrue: [attrName size > 6			ifTrue: [namespaces at: (attrName copyFrom: 7 to: attrName size) put: attrValue]			ifFalse: [namespaces at: attrName put: attrValue]]		ifFalse: [attributes at: attrName put: attrValue]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/23/2007 17:51'!nextAttributeValue	| delimiterChar attributeValueStream nextChar nextPeek referenceString entity entityValue |	delimiterChar := self next.	(delimiterChar == $"		or: [delimiterChar == $'])		ifFalse: [self errorExpected: 'Attribute value delimiter expected.'].	attributeValueStream := attributeBuffer reset.	[	nextPeek := nextChar := self next.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self peek == $#				ifTrue: [					nextPeek := nil.					nextChar := self nextCharReference]				ifFalse: [					referenceString := self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity := self entity: referenceString.					entityValue := entity valueForContext: #content.					(self class isCharEscape: entityValue)						ifTrue: [							nextPeek := nil.							nextChar := entityValue first]						ifFalse: [							entityValue := entityValue asString.							entityValue isEmpty								ifTrue: [nextPeek := nextChar := nil]								ifFalse: [									self pushStream: (ReadStream on: entityValue asString).									nextPeek := nextChar := self next]]]].	nextPeek == delimiterChar]		whileFalse: [			nextChar ifNotNil: [attributeValueStream nextPut: nextChar]].	^self fastStreamStringContents: attributeValueStream"	^attributeValueStream contents"! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 17:00'!nextCDataContent	| cdata |	"Skip $[ "	self next.	cdata := self nextUpToAll: ']]>'.	self handleCData: cdata! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 12/6/2000 14:29'!nextCDataOrConditional	| nextChar conditionalKeyword |	"Skip ["	self next.	self skipSeparators.	nextChar := self peek.	nextChar == $%		ifTrue: [			self checkAndExpandReference: (self parsingMarkup ifTrue: [#dtd] ifFalse: [#content]).			conditionalKeyword := self nextLiteral.			self skipSeparators.			^self next == $[				ifTrue: [						self skipSeparators.						self nextIncludeSection: (self conditionalInclude: conditionalKeyword)]				ifFalse: [self errorExpected: '[' ]].	nextChar == $C		ifTrue: [			^self nextLiteral = 'CDATA'				ifTrue: [self peek == $[							ifTrue: [self nextCDataContent]							ifFalse: [self errorExpected: '[' ]]				ifFalse: [self errorExpected: 'CData']].	self errorExpected: 'CData or declaration'! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mu 11/14/2005 14:07'!nextCharReference	| base charValue |	self next == $#		ifFalse: [self errorExpected: 'character reference'].	base := self peek == $x		ifTrue: [			self next.			16]		ifFalse: [10].	charValue := [self readNumberBase: base] on: Error do: [:ex | self errorExpected: 'Number.'].	(self next) == $;		ifFalse: [self errorExpected: '";"'].	^Unicode value: charValue! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/28/2000 17:54'!nextComment	| string |	"Skip first -"	self next.	self next == $-		ifFalse: [self errorExpected: 'second comment $-'].	string := self nextUpToAll: '-->'.	self handleComment: string! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/8/2002 13:54'!nextDocType	| declType |	declType := self nextLiteral.	declType = 'DOCTYPE'		ifTrue: [			self startParsingMarkup.			^self nextDocTypeDecl].	self errorExpected: 'markup declaration, not ' , declType printString! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 17:29'!nextDocTypeDecl	| nextChar |	self skipSeparators.	self nextLiteral.	self skipSeparators.	self peek == $[		ifFalse: [[nextChar := self peek.				nextChar == $> or: [nextChar == $[ ]] whileFalse: [self next]].	self peek == $[		ifTrue: [			self next.			[self skipSeparators.			self peek == $]] whileFalse: [				self checkAndExpandReference: #dtd.				self nextNode].			self next == $] 				ifFalse: [self errorExpected: ']' ]].	self skipSeparators.	self next == $>		ifFalse: [self errorExpected: '>' ].	self endParsingMarkup! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/23/2007 17:48'!nextEndTag	| tagName |	"Skip /"	self next.	tagName := self nextName.	self skipSeparators.	(self nextTrimmedBlanksUpTo: $>)		ifNotEmpty: [self parseError: 'XML invalid end tag ' , tagName].	self handleEndTag: tagName! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'gvc 6/6/2007 13:17'!nextEntity	"return the next XMLnode, or nil if there are no more.	Fixed to retain leading whitespace when PCDATA is detected."	|whitespace|	"branch, depending on what the first character is"	whitespace := self nextWhitespace.	self atEnd ifTrue: [self handleEndDocument. ^ nil].	self checkAndExpandReference: (self parsingMarkup ifTrue: [#dtd] ifFalse: [#content]).	^self peek = $<		ifTrue: [self nextNode]		ifFalse: [whitespace isEmpty					ifFalse: [self pushBack: whitespace].				self nextPCData]! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 14:24'!nextEntityDeclaration	| entityName entityDef referenceClass reference |	self skipSeparators.	referenceClass := self peek == $%		ifTrue: [			self next.			self skipSeparators.			DTDParameterEntityDeclaration]		ifFalse: [DTDEntityDeclaration].	entityName := self nextLiteral.	self skipSeparators.	entityDef := (self peek == $" or: [self peek == $'])		ifTrue: [self nextEntityValue]		ifFalse: [self nextExternalId].	self skipUpTo: $>.	reference := referenceClass name: entityName value: entityDef.	reference registerIn: self.	^reference! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:14'!nextEntityValue	| delimiterChar entityValueStream nextChar nextPeek referenceString entity entityValue |	delimiterChar := self next.	(delimiterChar == $"		or: [delimiterChar == $'])		ifFalse: [self errorExpected: 'Entity value delimiter expected.'].	entityValueStream := WriteStream on: (String new).	[	nextPeek := nextChar := self peek.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [					nextPeek := nil.					nextChar := self nextCharReference]				ifFalse: [					referenceString := self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity := self entity: referenceString.					entityValue := entity valueForContext: #entityValue.					self pushStream: (ReadStream on: entityValue asString).					nextPeek := nextChar := self next]]		ifFalse: [			nextChar == $%				ifTrue: [					self skipSeparators.					referenceString := self nextLiteral.					nextChar := self handleEntity: referenceString in: #entityValue.					nextPeek := nextChar := self next]				ifFalse: [self next]].	nextPeek == delimiterChar]		whileFalse: [			nextChar ifNotNil: [entityValueStream nextPut: nextChar]].	^entityValueStream contents! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'rkris 7/28/2004 12:35'!nextExternalId	| extDefType systemId dir |	extDefType := self nextLiteral.	extDefType = 'PUBLIC'		ifTrue: [			self skipSeparators.			self nextPubidLiteral.			self skipSeparators.			self peek == $>				ifFalse: [					systemId := self nextSystemLiteral]].	extDefType = 'SYSTEM'		ifTrue: [			self skipSeparators.			systemId := self nextSystemLiteral].	systemId		ifNil: [^nil].	"The rest of this method only applies if we're reading aFileStream"	(self topStream isKindOf: FileStream)		ifFalse: [^''].	dir := self topStream directory.	^(dir fileExists: systemId)		ifTrue: [(dir readOnlyFileNamed: systemId) contentsOfEntireFile]		ifFalse: ['']! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/28/2001 16:38'!nextIncludeSection: parseSection	| section |	"Read the file up to the next include section delimiter and parse it if parseSection is true"		section := self nextUpToAll: ']]>'.	parseSection		ifTrue: [			self pushStream: (ReadStream on: section)]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 10/31/2007 16:19'!nextLiteral	| resultStream nextChar resultString |	resultStream := (String new: 10) writeStream.	((nextChar := self peek) isLetter		or: [nextChar == $_])		ifFalse: [self errorExpected: 'Name literal.'].	[nextChar := self peek.	(LiteralChars includes: nextChar)		ifTrue: [			nextChar == $&				ifTrue: [					nextChar := self next.					resultStream nextPut: (self peek == $#						ifTrue: [self nextCharReference]						ifFalse: [^resultStream contents])]				ifFalse: [					resultStream nextPut: self next]]		ifFalse: [resultString := resultStream contents.			resultString isEmpty				ifTrue: [self errorExpected: 'Name literal']				ifFalse: [^resultString]]] repeat! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 13:49'!nextMarkupDeclaration	| declType |	declType := self nextLiteral.	self validating		ifFalse: [^self skipMarkupDeclaration].	declType = 'ENTITY'		ifTrue: [self nextEntityDeclaration]		ifFalse: [self skipMarkupDeclaration]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 10/31/2007 16:20'!nextName	| nextChar |	nameBuffer reset.	self peek == $.		ifTrue: [self malformedError: 'Character expected.'].	[(nextChar := self peek)		ifNil: [self errorExpected: 'Character expected.'].	NameDelimiters includes: nextChar] whileFalse: [			nameBuffer nextPut: self next].	^self fastStreamStringContents: nameBuffer! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/28/2000 17:52'!nextNode	| nextChar |	"Skip < "	self next.	nextChar := self peek.	nextChar == $!! ifTrue: [		"Skip !!"		self next.		nextChar := self peek.		nextChar == $- ifTrue: [^self nextComment].		nextChar == $[ ifTrue: [^self nextCDataOrConditional].		^self parsingMarkup			ifTrue: [self nextMarkupDeclaration]			ifFalse: [self nextDocType]].	nextChar == $? ifTrue: [^self nextPI].	^self nextTag! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/23/2007 17:52'!nextPCData	| resultStream nextChar referenceString entity entityValue nextPeek |	resultStream := (String new: 10) writeStream.	self validating		ifFalse: [			[self peek == $<]				whileFalse: [resultStream nextPut: self next].			^self handlePCData: resultStream contents].	[	nextPeek := nextChar := self peek.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [					nextPeek := nil.					nextChar := self nextCharReference]				ifFalse: [					referenceString := self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity := self entity: referenceString.					entityValue := entity valueForContext: #content.					(self class isCharEscape: entityValue)						ifTrue: [							nextPeek := nil.							nextChar := entityValue first]						ifFalse: [							entityValue := entityValue asString.							entityValue isEmpty								ifTrue: [nextPeek := nextChar := nil]								ifFalse: [									self pushStream: (ReadStream on: entityValue asString).									nextPeek := nextChar := self peek]]]]		ifFalse: [nextPeek == $< ifFalse: [self next]].	nextPeek == $<]		whileFalse: [			nextChar ifNotNil: [resultStream nextPut: nextChar]].	self handlePCData: resultStream contents! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 13:00'!nextPI	| piTarget piData |	"Skip ?"	self next.	piTarget := self nextLiteral.	piTarget asUppercase = 'XML'		ifTrue: [^self nextXMLDecl].	self skipSeparators.	piData := self nextUpToAll: '?>'.	self handlePI: piTarget data: piData! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 22:37'!nextTag	| tagName attributes nextChar namespaces |	(self peek = $/)		ifTrue: [^self nextEndTag].	tagName := self nextName.	self skipSeparators.	attributes := Dictionary new: 33.	namespaces := Dictionary new: 5.	[(nextChar := self peek) == $> or: [nextChar == $/]] whileFalse: [		self checkAndExpandReference: #content.		self nextAttributeInto: attributes namespaces: namespaces.		self skipSeparators.].	self handleStartTag: tagName attributes: attributes namespaces: namespaces.	self next == $/		ifTrue: [			self handleEndTag: tagName.			self next].	! !!XMLTokenizer methodsFor: 'streaming' stamp: 'bf 4/27/2006 17:55'!nextTrimmedBlanksUpTo: delimiter	| resultStream nextChar |	resultStream := WriteStream on: (String new: 10).	nextChar := nil.	[(nextChar := self next) == delimiter]		whileFalse: [			nextChar == $  ifFalse: [				resultStream nextPut: nextChar]].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found'].	^resultStream contents! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 5/14/2003 18:44'!nextUpTo: delimiter	| resultStream nextChar |	resultStream := WriteStream on: (String new: 10).	[self atEnd or: [(nextChar := self next) == delimiter]]		whileFalse: [resultStream nextPut: nextChar].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found'].	^resultStream contents! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 11/23/2007 19:42'!nextUpToAll: delimitingString	| string |	self unpeek.	string := self upToAll: delimitingString.	string		ifNil: [self parseError: 'XML no delimiting ' , delimitingString printString , ' found'].	^string! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 10/31/2007 17:49'!nextWhitespace	| nextChar resultStream resultString|	resultStream := (String new: 10) writeStream.	[((nextChar := self peek) ~~ nil)		and: [SeparatorTable includes: nextChar]]		whileTrue: [resultStream nextPut: nextChar. self next].	(nestedStreams == nil or: [self atEnd not])		ifFalse: [self checkNestedStream.				self nextWhitespace].	resultString := resultStream contents.	resultString isEmpty ifFalse: [self handleWhitespace: resultString].	^resultString! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'thf 9/2/2005 15:04'!nextXMLDecl	| attributes nextChar namespaces |	self skipSeparators.	attributes := Dictionary new.	namespaces := Dictionary new.	[(nextChar := self peek) == $?] whileFalse: [		self nextAttributeInto: attributes namespaces: namespaces.		self skipSeparators.].	self next.	self next == $>		ifFalse: [self errorExpected: '> expected.'].	(attributes includesKey: 'encoding') ifTrue: [self streamEncoding: (attributes at: 'encoding')].	self handleXMLDecl: attributes namespaces: namespaces	! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:20'!parameterEntities	parameterEntities ifNil: [parameterEntities := Dictionary new].	^parameterEntities! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:05'!peek	"Return the next character from the current input stream. If the current stream poop to next nesting level if there is one.	Due to the potential nesting of original document, included documents and replacment texts the streams are held in a stack representing the nested streams. The current stream is the top one."	peekChar		ifNil: [			nestedStreams ifNotNil: [self checkNestedStream].			^peekChar := stream next]		ifNotNil: [^peekChar]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 6/29/2001 00:36'!popNestingLevel	self hasNestedStreams		ifTrue: [			self stream close.			self stream: self nestedStreams removeLast.			self nestedStreams size > 0				ifFalse: [nestedStreams := nil]]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'gvc 6/6/2007 13:13'!pushBack: aString	"Fixed to push the string before the peek char (if any)."		| pushBackString |	pushBackString := peekChar		ifNil: [aString]		ifNotNil: [aString, peekChar asString].	peekChar := nil.	self pushStream: (ReadStream on: pushBackString)! !!XMLTokenizer methodsFor: 'private' stamp: 'mu 11/14/2005 14:12'!readNumberBase: base	"Read a hex number from stream until encountering $; "	| value digit |	base = 10 ifFalse: [	| numberString | 		numberString := self nextUpTo: $;.		self stream skip: -1.		^Integer readFrom: numberString asUppercase readStream base: base. 	].	value := 0.	digit := DigitTable at: self peek asciiValue.	digit < 0		ifTrue: [self error: 'At least one digit expected here'].	self next.	value := digit.	[digit := DigitTable at: self peek asciiValue.	digit < 0		ifTrue: [^value]		ifFalse: [			self next.			value := value * base + digit]		] repeat.	^ value! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 10/31/2007 16:33'!skipSeparators	| nextChar |	[((nextChar := self peek) ~~ nil)		and: [SeparatorTable includes: nextChar]]		whileTrue: [self next].	(nestedStreams == nil or: [self atEnd not])		ifFalse: [			self checkNestedStream.			self skipSeparators]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/16/2002 10:42'!skipUpTo: delimiter	| nextChar |	self unpeek.	[self atEnd or: [(nextChar := self next) == delimiter]]		whileFalse: [].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found']! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!startParsingMarkup	parsingMarkup := true! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:50'!stream: newStream	"Continue parsing from the new nested stream."	stream := newStream! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 11/23/2007 19:40'!stream: aStream upToAll: aCollection	"Answer a subcollection from the current access position to the occurrence (not inclusive) of aCollection. If aCollection is not in the stream, answer nil."	| startPos endMatch result |	startPos := aStream position.	(aStream  match: aCollection) 		ifTrue: [endMatch := aStream position.			aStream position: startPos.			result := aStream next: endMatch - startPos - aCollection size.			aStream position: endMatch.			^ result]		ifFalse: [			aStream position: startPos.			^nil]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 7/12/2006 17:46'!streamEncoding: encodingString	| converterClass |	Smalltalk at: #TextConverter ifPresent: [:tc | 		(stream respondsTo: #converter:) ifTrue: [			converterClass := tc defaultConverterClassForEncoding: encodingString asLowercase.			converterClass ifNotNil: [stream converter: converterClass new]]]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'gvc 6/6/2007 13:19'!unpeek	"Fixed to use nested stream since multi-byte streams	do not properly override pushBack: to deal with multi-byte	characters."		peekChar ifNotNil: [self pushBack: '']! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 11/23/2007 20:00'!upToAll: delimitingString	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of delimitingString. If delimitingString is not in the stream, answer the entire rest of the stream."	| result |	self hasNestedStreams		ifFalse: [			result := self stream: self stream upToAll: delimitingString.			result				ifNil: [self parseError: 'XML no delimiting ' , delimitingString printString , ' found'].			^result].	result := self stream: self stream upToAll: delimitingString.	result		ifNotNil: [^result].	result := String streamContents: [:resultStream |		resultStream nextPutAll: self stream upToEnd.		self atEnd			ifTrue: [self parseError: 'XML no delimiting ' , delimitingString printString , ' found'].		self stream position timesRepeat: [			self atEnd				ifFalse: [					resultStream nextPut: self next]]].	self pushBack: result.	^self upToAll: delimitingString! !!XMLTokenizer methodsFor: 'accessing' stamp: 'mir 1/14/2002 17:51'!validating: aBoolean	validating := aBoolean! !!DTDParameterEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/14/2002 18:15'!initialize	"DTDParameterEntityDeclaration initialize"	contextBehavior := Dictionary new.	contextBehavior		at: #content put: #notRecognized: ;		at: #attributeValueContent put: #notRecognized: ;		at: #attributeValue put: #notRecognized: ;		at: #entityValue put: #include: ;		at: #dtd put: #includePE:! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:54'!canonical: aBoolean	canonical := aBoolean! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 7/12/2006 16:07'!endTag	self stream nextPutAll: '>'.	self indent.	"self canonical		ifFalse: [self stream space]"! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 7/12/2006 17:02'!endTag: tagName	self outdent.	self endTag: tagName xmlns: nil! !!XMLWriter methodsFor: 'private' stamp: 'mir 7/12/2006 16:52'!indent	currentIndent		ifNotNil: [currentIndent := currentIndent +1]! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 7/12/2006 16:08'!indentString: aString	currentIndent := 0.	indentString := aString! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 7/12/2006 16:08'!indentTab	self indentString: (String with: Character tab)! !!XMLWriter methodsFor: 'initialize' stamp: 'mir 7/12/2006 15:54'!initialize	stack := OrderedCollection new.	canonical := false.	scope := XMLNamespaceScope new! !!XMLWriter methodsFor: 'private' stamp: 'mir 7/12/2006 17:05'!outdent	currentIndent		ifNotNil: [			stream cr.			currentIndent := currentIndent-1.			self writeIndent.			currentIndent := currentIndent-1.]! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/7/2000 16:23'!popTag: tagName	| stackTop |	stackTop := self stack isEmpty		ifTrue: ['<empty>']		ifFalse: [self stack last].	^stackTop = tagName		ifTrue: [self stack removeLast]		ifFalse: [self error: 'Closing tag "' , tagName , '" does not match "' , stackTop]! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 7/12/2006 16:08'!startTag: tagName	self writeIndent.	self startTag: tagName xmlns: nil! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:54'!stream: aStream	stream := aStream! !!XMLWriter methodsFor: 'private' stamp: 'mir 7/12/2006 16:58'!writeIndent	currentIndent ifNotNil: [		currentIndent timesRepeat: [self stream nextPutAll: indentString]]! !!XMLWriter methodsFor: 'writing xml' stamp: 'thf 9/2/2005 14:08'!xmlDeclaration: versionString encoding: encodingString	self canonical		ifFalse: [			self				startPI: 'xml';				attribute: 'version' value: versionString;				attribute: 'encoding' value: encodingString;				endPI.			self stream flush]! !!ByteString methodsFor: '*xml-parser' stamp: 'mir 7/14/2006 11:54'!applyLanguageInfomation: languageEnvironment! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!data: aString	data := aString! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!target: aString	target := aString! !!DTDExternalEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/14/2002 18:15'!initialize	"DTDExternalEntityDeclaration initialize"	contextBehavior := Dictionary new.	contextBehavior		at: #content put: #include ;		at: #attributeValueContent put: #includedInLiteral ;		at: #attributeValue put: #forbidden ;		at: #entityValue put: #bypass ;		at: #dtd put: #forbidden ! !!XMLDOMParser class methodsFor: 'examples' stamp: 'mir 7/12/2006 16:26'!addressBookXMLWithDTD	"XMLDOMParser addressBookXMLWithDTD"	^self parseDocumentFrom: XMLTokenizer addressBookXMLWithDTD readStream useNamespaces: true! !!XMLDOMParser class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:25'!parseDocumentFrom: aStream	^self parseDocumentFrom: aStream useNamespaces: false! !!XMLDOMParser class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:25'!parseDocumentFrom: aStream useNamespaces: aBoolean	^(super parseDocumentFrom: aStream useNamespaces: aBoolean) document! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 10/25/2000 11:30'!characters: aString	| newElement |	newElement := XMLStringNode string: aString.	self top addContent: newElement.! !!XMLDOMParser methodsFor: 'content' stamp: 'thf 9/2/2005 14:09'!documentAttributes: attributeList	self document version: (attributeList at: 'version' ifAbsent: [nil]).	self document encoding: (attributeList at: 'encoding' ifAbsent: [nil]).	self document requiredMarkup: (attributeList at: 'requiredMarkup' ifAbsent: [nil]).! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 1/8/2002 18:11'!endElement: elementName	| currentElement |	currentElement := self pop.	currentElement name = elementName		ifFalse: [self driver errorExpected: 'End tag "', elementName , '" doesn''t match "' , currentElement name , '".']! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 6/24/2003 14:53'!endElement: localName namespace: namespace namespaceURI: uri qualifiedName: qualifiedName	| currentElement |	currentElement := self pop.	(currentElement namespace isNil		or: [currentElement namespace = self defaultNamespace])		ifTrue: [			currentElement localName = localName				ifFalse: [self driver errorExpected: 'End tag "', localName , '" doesn''t match "' , currentElement localName  , '".']]		ifFalse: [			currentElement qualifiedName = qualifiedName				ifFalse: [self driver errorExpected: 'End tag "', qualifiedName , '" doesn''t match "' , currentElement qualifiedName  , '".']]! !!XMLDOMParser methodsFor: 'accessing' stamp: 'mir 1/8/2001 12:05'!incremental: aBoolean	incremental := aBoolean! !!XMLDOMParser methodsFor: 'initialize' stamp: 'mir 1/8/2001 12:05'!initialize	super initialize.	stack := OrderedCollection new.	incremental := false! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 6/28/2001 18:45'!nextEntity	| currentTop |	currentTop := self top.	[self driver nextEntity isNil		or: [self top ~~ currentTop]] whileTrue.	^entity! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 12:04'!pop	| oldTop |	oldTop := self stack removeLast.	entity := oldTop.	^oldTop! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 3/6/2002 10:49'!processingInstruction: piName data: dataString	| newElement |	newElement := XMLPI target: piName data: dataString.	self top addElement: newElement! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 12:02'!push: anObject	self stack add: anObject.	entity := anObject! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 3/6/2002 10:49'!startElement: elementName attributeList: attributeList	| newElement |	newElement := XMLElement named: elementName attributes: attributeList.	self incremental		ifFalse: [self stack isEmpty			ifFalse: [self top addElement: newElement]].	self push: newElement! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 6/24/2003 18:52'!startElement: localName namespaceURI: namespaceUri namespace: namespace attributeList: attributeList	| newElement |	"newElement := namespace = self defaultNamespace		ifTrue: [XMLElement named: localName namespace: nil uri: nil attributes: attributeList]		ifFalse: [XMLElement named: localName namespace: namespace uri: namespaceUri attributes: attributeList]."	newElement := XMLElement named: localName namespace: namespace uri: namespaceUri attributes: attributeList.	self incremental		ifFalse: [self stack isEmpty			ifFalse: [self top addElement: newElement]].	self push: newElement! !"XML-Parser"!TestRunner removeSelector: #baseClass!TestRunner removeSelector: #basicRunSuite:do:!TestRunner removeSelector: #buildClassesWith:!TestRunner removeSelector: #buildErrorListWith:!TestRunner removeSelector: #buildFailureListWith:!TestRunner removeSelector: #buildWith:!TestRunner removeSelector: #categoryAt:put:!TestRunner removeSelector: #categorySelected!TestRunner removeSelector: #classAt:put:!TestRunner removeSelector: #findCategories!TestRunner removeSelector: #findClassesForCategories:!TestRunner removeSelector: #initialize!TestRunner removeSelector: #reset!TestRunner removeSelector: #runSuite:!TestRunner removeSelector: #runTest:!TestRunner removeSelector: #suiteAll!TestRunner removeSelector: #update!TestRunner removeSelector: #updateClasses!TestRunner removeSelector: #updateResults!!String methodsFor: '*sunitgui' stamp: 'kph 12/14/2006 03:20'!asReadableText	"Split up a camelCased string"	^ String		streamContents: [:str | self				inject: true				into: [:firstTime :char | 					firstTime						ifTrue: [ str nextPut: char asUppercase ]						ifFalse: [char isUppercase									ifTrue: [str space].								str nextPut: char.].										false]]				"  	'HelloWorldHereICome' asReadableText	"! !!TestRunner class methodsFor: 'defaults' stamp: 'kph 2/22/2007 12:41'!defaultRejectFilters	^ TestReporter defaultRejectFilters! !!TestRunner class methodsFor: 'defaults' stamp: 'kph 2/22/2007 12:40'!defaultSelectFilters	^ TestReporter defaultSelectFilters! !!TestRunner class methodsFor: 'defaults' stamp: 'kph 2/22/2007 12:41'!defaultSuites	^ TestReporter defaultSuites! !!TestRunner class methodsFor: 'installer-launcher' stamp: 'kph 2/27/2007 18:58'!launchFrom: launcher ^ TestReporter launch: self with: launcher getParameters.  ! !!TestRunner class methodsFor: 'installer-launcher' stamp: 'kph 2/20/2007 16:51'!launchHelp^ TestReporter launchHelp! !!TestRunner class methodsFor: 'installer-launcher' stamp: 'kph 2/22/2007 15:31'!openReportTo: reporter	 | runner |	runner := self open model.	runner reporter: reporter.	^runner ! !!TestRunner methodsFor: 'accessing' stamp: 'kph 12/16/2006 08:32'!baseClass	^Array with: TestCase ! !!TestRunner methodsFor: 'accessing' stamp: 'kph 10/29/2006 01:15'!baseClasses	^Array with: TestCase ! !!TestRunner methodsFor: 'processing' stamp: 'kph 12/21/2006 08:38'!basicRunSuite: aTestSuite do: aBlock	self basicSetUpSuite: aTestSuite.	[ aTestSuite name isEmptyOrNil		ifTrue: [ aTestSuite tests do: aBlock ]		ifFalse: [ aTestSuite tests do: aBlock displayingProgress: aTestSuite name ] ]			ensure: [ self basicTearDownSuite: aTestSuite ].	! !!TestRunner methodsFor: 'null reporter' stamp: 'kph 2/18/2007 02:55'!beginRunSuite: aSuite! !!TestRunner methodsFor: 'building' stamp: 'dc 2/11/2007 14:56'!buildClassesWith: aBuilder	^ aBuilder pluggableMultiSelectionListSpec new		model: self;		list: #classList;		menu: #classMenu:;		getIndex: #classSelected;		setIndex: #classSelected:;		getSelectionList: #classAt:;		setSelectionList: #classAt:put:;		keyPress: #keyPressed:;		yourself.! !!TestRunner methodsFor: 'building' stamp: 'kph 12/21/2006 03:33'!buildErrorListWith: aBuilder	^ aBuilder pluggableListSpec new		model: self;		name: 'Error List';		list: #errorList; 		getIndex: #errorSelected; 		setIndex: #errorSelected:;		yourself.! !!TestRunner methodsFor: 'building' stamp: 'kph 12/21/2006 03:33'!buildFailureListWith: aBuilder	^ aBuilder pluggableListSpec new		model: self;		name: 'Failure List';		list: #failedList; 		getIndex: #failedSelected; 		setIndex: #failedSelected:;		yourself.! !!TestRunner methodsFor: 'building' stamp: 'kph 10/29/2006 01:37'!buildSuitesWith: aBuilder	^ aBuilder pluggableMultiSelectionListSpec new		model: self;		list: #suitesList;		menu: #suitesMenu:;		getIndex: #suitesSelected;		setIndex: #suitesSelected:;		getSelectionList: #suitesAt:;		setSelectionList: #suitesAt:put:;		yourself.! !!TestRunner methodsFor: 'building' stamp: 'kph 2/22/2007 13:41'!buildWith: aBuilder	| window |	window := aBuilder pluggableWindowSpec new		model: self; label: self label; extent: self extent;		children: (OrderedCollection new 			add: ((self buildSuitesWith: aBuilder)				frame: (0.00 @ 0.00 corner: 0.25 @ 0.20 );				yourself);			add: ((self buildCategoriesWith: aBuilder)				frame: (0.00 @ 0.20 corner: 0.25 @ 0.92 );				yourself);							add: ((self buildClassesWith: aBuilder)				frame: (0.25 @ 0.00 corner: 0.50 @ 0.92 );				yourself);			add: ((self buildStatusWith: aBuilder)				frame: (0.50 @ 0.00 corner: 1.00 @ 0.08);				yourself);			add: ((self buildFailureListWith: aBuilder)				frame: (0.50 @ 0.08 corner: 1.00 @ 0.50);				yourself);			add: ((self buildErrorListWith: aBuilder)				frame: (0.50 @ 0.50 corner: 1.00 @ 0.92);				yourself);			add: ((self buildButtonsWith: aBuilder)				frame: (0.00 @ 0.92 corner: 1.00 @ 1.00);				yourself);			yourself);		yourself.	^ aBuilder build: window.! !!TestRunner methodsFor: 'command line params' stamp: 'kph 1/6/2007 05:00'!categoriesSelectedFrom: list 		categoriesSelected := categories select: [ :each | list includes: each ].		self updateClasses.! !!TestRunner methodsFor: 'accessing-categories' stamp: 'kph 10/30/2006 01:16'!categoryAt: anInteger put: aBoolean 	categoriesSelected := categoriesSelected				perform: (aBoolean						ifTrue: [#copyWith:]						ifFalse: [#copyWithout:])				with: (categories						at: anInteger						ifAbsent: [^ self]).	self changed: #categorySelected;		 updateClasses		  ! !!TestRunner methodsFor: 'accessing-categories' stamp: 'kph 12/16/2006 08:58'!categorySelected	 	^ 0! !!TestRunner methodsFor: 'accessing-classes' stamp: 'kph 12/16/2006 08:20'!classAt: anInteger put: aBoolean 	classesSelected := classesSelected				perform: (aBoolean						ifTrue: [#copyWith:]						ifFalse: [#copyWithout:])				with: (classes						at: anInteger						ifAbsent: [^ self]).	self changed: #classSelected;		 changed: #hasRunnable.! !!TestRunner methodsFor: 'command line params' stamp: 'kph 1/6/2007 05:01'!classesSelectedFrom: listOfClassNames 	classesSelected := classes select: [:each | listOfClassNames includes: each name].	self updateClasses.! !!TestRunner methodsFor: 'null reporter' stamp: 'kph 2/18/2007 01:54'!error: test dueTo: reason! !!TestRunner methodsFor: 'accessing' stamp: 'kph 12/21/2006 06:27'!externalObjectUsed: anObject! !!TestRunner methodsFor: 'null reporter' stamp: 'kph 2/18/2007 01:54'!fail: test dueTo: reason! !!TestRunner methodsFor: 'utilities' stamp: 'kph 12/19/2006 02:02'!findCategories	| visible |	visible := Set new.	self withAllTestClassesDo: [ :each |				(each publishedSuites includesAnyOf:  suitesSelected)			ifTrue: [ each category ifNotNilDo: [ :category | visible add: category ] ].	].	^ Array streamContents: [ :stream |		Smalltalk organization categories do: [ :each |			(visible includes: each)				ifTrue: [ stream nextPut: each ] ] ].! !!TestRunner methodsFor: 'accessing' stamp: 'kph 12/19/2006 02:03'!findClassesForCategories: aCollection	| theCategories items |	theCategories := aCollection isEmpty		ifTrue: [ categories ]		ifFalse: [ aCollection ].	items := theCategories gather: [ :category |		((Smalltalk organization listAtCategoryNamed: category)			collect: [ :each | Smalltalk at: each ])			select: [ :each | self baseClasses anySatisfy: [ :bc | each includesBehavior: bc ] ] ].	^(items select: [ :each | each publishedSuites includesAnyOf: suitesSelected ]) asSet.! !!TestRunner methodsFor: 'processing' stamp: 'kph 2/22/2007 13:14'!findSuitesAndFilters	|  visible |	allSuites := Set new.	allFilters := Set new.		selectFilters ifNil: [ selectFilters := self class defaultSelectFilters asOrderedCollection ].	rejectFilters ifNil: [ rejectFilters := self class defaultRejectFilters asOrderedCollection ].		self withAllTestClassesDo: [:each | 								allSuites addAll: each publishedSuites.			allFilters addAll: each publishedFilters. 	].	visible := OrderedCollection new.		allSuites := allSuites asSortedCollection.		visible addAll: allSuites.	visible add: ('-- filters (select) --').	visible addAll: selectFilters.	visible add: ('-- filters (reject) --').	visible addAll: rejectFilters.		^visible! !!TestRunner methodsFor: 'utilities' stamp: 'dc 2/11/2007 15:40'!findTestClass	"Let the user search for a test class in the system. Answer the class or nil."		| pattern class |	pattern := UIManager default request: 'Class name or fragment?'.	class := Utilities classFromPattern: pattern withCaption: 'Select a class:'.	class ifNil: [^ nil].	"A possible enhancement would be to only display test classes in the list. However, this would request a refactoring of #Utilities>>classFromPattern:withCaption:"	^ (class inheritsFrom: TestCase)		ifTrue: class		ifFalse: [Smalltalk at: (class name, 'Test') asSymbol ifAbsent: nil].	! !!TestRunner methodsFor: 'processing' stamp: 'kph 12/15/2006 02:40'!getSuiteCommentFor: aSuite in: aClass collateIn: collated	| comment |		comment := (aClass class firstPrecodeCommentFor: aSuite) ifNil: [ ^self ]. 	(collated at: comment ifAbsentPut: [ OrderedCollection new ]) add: aClass name.	! !!TestRunner methodsFor: 'initialization' stamp: 'kph 2/18/2007 01:55'!initialize	super initialize.	reporter := self. "I am a null reporter" 	failedList := errorList := Array new.	SystemChangeNotifier uniqueInstance 		notify: self ofSystemChangesOfItem: #class change: #Added using: #update;		notify: self ofSystemChangesOfItem: #category change: #Added using: #update;		notify: self ofSystemChangesOfItem: #class change: #Removed using: #update;		notify: self ofSystemChangesOfItem: #category change: #Removed using: #update;		notify: self ofSystemChangesOfItem: #class change: #Renamed using: #update;		notify: self ofSystemChangesOfItem: #category change: #Renamed using: #update;		notify: self ofSystemChangesOfItem: #class change: #Recategorized using: #update;		notify: self ofSystemChangesOfItem: #category change: #Recategorized using: #update.	self update; reset! !!TestRunner methodsFor: 'utilities' stamp: 'dc 2/11/2007 15:36'!keyPressed: aKey	| class |	aKey = $f		ifTrue: [					class := self findTestClass.				class ifNil: [^ self].				self selectClass: class.			]! !!TestRunner methodsFor: 'accessing-classes' stamp: 'kph 2/16/2007 00:21'!listOfSelectedTests^ (self suiteAll tests asSortedCollection collect: [ :test | 				| method  string category time timing ext |				method := test class lookupSelector: test selector.				category := method methodClass organization categoryOfElement: test selector.				string := (test class == method methodClass) 						ifTrue: [''] 						ifFalse: [ ' (inherited from ', method methodClass name,')' ].				timing := self result timings at: test ifAbsent: [ nil ].				timing ifNotNil: 					[ 					time := timing printString, ' ms'.					(timing > self long) ifTrue: [ time := time, ' **long**' ].					] 					ifNil: 					[ time :=  '' ].				ext := (self result usesNetwork at: test ifAbsent: [ false ]) ifTrue: [ ' (net)' ] ifFalse: [ '' ].				MethodReference new 					setClass: (method methodClass) 					methodSymbol: test selector 					stringVersion: (test class name),'>>', test selector printString,						' {', category,'} ', time , ext, string.   ])		! !!TestRunner methodsFor: 'accessing' stamp: 'kph 2/20/2007 11:25'!long  ^ TestResultTimed long! !!TestRunner methodsFor: 'accessing' stamp: 'kph 2/20/2007 11:25'!long: vTestResultTimed long: v! !!TestRunner methodsFor: 'accessing-classes' stamp: 'kph 2/22/2007 12:58'!menuRejectFilters	| subMenu |			 	subMenu _ MenuMorph new defaultTarget: self.     allFilters do: [ :filter |		subMenu add: filter asReadableText selector: #rejectFiltersAddOrRemove: argument: filter.	].	^subMenu  ! !!TestRunner methodsFor: 'accessing-classes' stamp: 'kph 2/22/2007 12:57'!menuSelectFilters	| subMenu |			 	subMenu _ MenuMorph new defaultTarget: self.     allFilters do: [ :filter |		subMenu add: filter asReadableText selector: #selectFiltersAddOrRemove: argument: filter.	].	^subMenu  ! !!TestRunner methodsFor: 'null reporter' stamp: 'kph 2/18/2007 01:54'!pass: test! !!TestRunner methodsFor: 'accessing-classes' stamp: 'kph 2/22/2007 13:16'!rejectFiltersAddOrRemove: filter	(rejectFilters includes: filter)		ifTrue: [ rejectFilters remove: filter ]		ifFalse: [ rejectFilters add: filter.				  selectFilters remove: filter ifAbsent: [].				].		self updateSuitesAndFilters! !!TestRunner methodsFor: 'accessing' stamp: 'kph 2/17/2007 04:01'!reporter 	^reporter  ! !!TestRunner methodsFor: 'accessing' stamp: 'kph 2/18/2007 04:55'!reporter: aReporterreporter := aReporter setRunner: self! !!TestRunner methodsFor: 'actions' stamp: 'kph 2/17/2007 04:12'!reset	self result: (TestResultTimed newTo: reporter); updateResults.! !!TestRunner methodsFor: 'null reporter' stamp: 'kph 2/18/2007 02:55'!runComplete! !!TestRunner methodsFor: 'actions' stamp: 'kph 2/23/2007 17:28'!runSuite: aTestSuite		| init |		init := Utilities authorInitialsPerSe.		reporter beginRunSuite: aTestSuite.	[		Utilities setAuthorInitials: 'test'.		self basicRunSuite: aTestSuite do: [ :each | self runTest: each ].	] ensure: [ Utilities setAuthorInitials: init ].	reporter runComplete.		self updateResults.! !!TestRunner methodsFor: 'actions' stamp: 'kph 2/23/2007 17:28'!runSuites: suites select: sFilters reject: rFilters categories: someCategories classes: someClasses   	self suitesSelectedFrom: suites.			selectFilters := sFilters.	rejectFilters := rFilters.		someCategories 		ifNil: [ self selectAllCategories ]		ifNotNil: [ 			categories := Set new.			someCategories do: [ :spec | categories add: (Smalltalk organization categoriesMatching: spec) ].			self categoriesSelectedFrom: categories 		].		someClasses 		ifNil: [ self  selectAllClasses ]		ifNotNil: [ self classesSelectedFrom: someClasses ].		   self runAll  ! !!TestRunner methodsFor: 'actions' stamp: 'kph 12/21/2006 08:40'!runTest: aTestCase 		aTestCase runOn: result.	self updateStatus: true! !!TestRunner methodsFor: 'accessing-categories' stamp: 'dc 4/2/2007 19:03'!selectCategory: aCategory	self categoryAt: (self categoryList indexOf: aCategory) put: true! !!TestRunner methodsFor: 'accessing-classes' stamp: 'dc 2/11/2007 15:36'!selectClass: aClass	self selectCategory: aClass category.	self classAt: (classes indexOf: aClass) put: true.! !!TestRunner methodsFor: 'accessing-classes' stamp: 'kph 2/22/2007 13:17'!selectFiltersAddOrRemove: filter(selectFilters includes: filter)	ifTrue: [ selectFilters remove: filter ]	ifFalse: [ selectFilters add: filter.		  	  rejectFilters remove: filter ifAbsent: []. ].		self updateSuitesAndFilters! !!TestRunner methodsFor: 'accessing-suites' stamp: 'kph 12/16/2006 08:21'!selectNoSuites	suitesSelected := Set new.	self changed: #suitesSelected.! !!TestRunner methodsFor: 'accessing' stamp: 'kph 2/22/2007 11:01'!slow ^ TestResultTimed slow! !!TestRunner methodsFor: 'accessing' stamp: 'kph 2/22/2007 11:01'!slow: vTestResultTimed slow: v! !!TestRunner methodsFor: 'private' stamp: 'kph 2/22/2007 13:50'!suiteAll	| suite |	suite :=  TestSuite 	classes: classesSelected 				suites: suitesSelected  				select: selectFilters  				reject: rejectFilters.					suite name: (self label: 'Test' forSuite: suite).		^suite			  ! !!TestRunner methodsFor: 'accessing-suites' stamp: 'kph 12/19/2006 01:55'!suitesAt: anIndex	^ suitesSelected includes: (suitesAndFilters at: anIndex ifAbsent: [ ^ false ]).! !!TestRunner methodsFor: 'accessing-suites' stamp: 'kph 2/22/2007 13:38'!suitesAt: anInteger put: aBoolean	| selectedItem |	selectedItem := allSuites at: anInteger ifAbsent: [ ^self ]. 	suitesSelected := suitesSelected		perform: (aBoolean ifTrue: [ #copyWith: ] ifFalse: [ #copyWithout: ])		with: selectedItem.			self changed: #suitesSelected.! !!TestRunner methodsFor: 'accessing-classes' stamp: 'kph 2/16/2007 00:23'!suitesBrowseChosenMethods	| tests |	ToolSet 		browseMessageSet: (tests := self listOfSelectedTests)		name: ('Tests:', suitesSelected asArray printString, ' [', tests size printString, ']' )		autoSelect: nil.							! !!TestRunner methodsFor: 'accessing-suites' stamp: 'kph 12/19/2006 07:07'!suitesDefineLong| answer |answer := FillInTheBlank request: 'what is long (ms)' initialAnswer: self long printString.[ answer := answer asInteger.   self long: answer  ] on: Error do: [ :ex | ^ self ].! !!TestRunner methodsFor: 'accessing-suites' stamp: 'kph 2/22/2007 13:24'!suitesDefineSlow| answer |answer := FillInTheBlank request: 'what is slow (ms)' initialAnswer: self slow printString.[ answer := answer asInteger.   self slow: answer  ] on: Error do: [ :ex | ^ self ].! !!TestRunner methodsFor: 'accessing-suites' stamp: 'kph 12/15/2006 03:02'!suitesExplain	self inform:  suitesComments! !!TestRunner methodsFor: 'accessing-suites' stamp: 'kph 12/19/2006 01:54'!suitesList	^ suitesAndFilters collect: [ :suiteSelector | suiteSelector asReadableText ]! !!TestRunner methodsFor: 'accessing' stamp: 'kph 2/21/2007 01:11'!suitesMarkExpected	self suitesMarkResults.	self result markExpected: 'expected'.		self updateFailuresList.	self updateErrorsList.! !!TestRunner methodsFor: 'long tests management' stamp: 'kph 2/22/2007 11:02'!suitesMarkLongSlowTests	self result markTestsWith: 'long' satisfying: [ :test :time | time > self long ].	self result markTestsWith: 'slow' satisfying: [ :test :time | time between: self slow and: self long ].	self updateFailuresList.	self updateErrorsList.! !!TestRunner methodsFor: 'long tests management' stamp: 'kph 2/21/2007 00:57'!suitesMarkNetworkTests	self result markTestsUsingNetworkWith: 'net'.	self updateFailuresList.	self updateErrorsList.! !!TestRunner methodsFor: 'accessing' stamp: 'kph 2/21/2007 01:01'!suitesMarkResults	self results markTestResultsFail: 'fail' error: 'error' pass: 'pass' expected: 'expected'.		self updateFailuresList.	self updateErrorsList.! !!TestRunner methodsFor: 'accessing-classes' stamp: 'kph 2/22/2007 12:46'!suitesMenu: aMenu 	^aMenu		title: 'Suites';		add: 'Refresh' action: #update;		add: 'Select none' action: #selectNoSuites;		addLine;		add: 'Browse Chosen Methods' action: #suitesBrowseChosenMethods;		add: 'Explain Suites' action: #suitesExplain;		addLine;		add: 'Select Filters' subMenu: self menuSelectFilters;		add: 'Reject Filters' subMenu: self menuRejectFilters;		addLine;		add: 'Define long...' action: #suitesDefineLong;		add: 'Define slow...' action: #suitesDefineSlow;		add: 'Mark Long+Slow Tests' action: #suitesMarkLongSlowTests;		add: 'Mark Network Tests' action: #suitesMarkNetworkTests;		add: 'Mark Results' action: #suitesMarkResults;		add: 'Mark Results As Expected' action: #suitesMarkExpected;		add: 'Unmark Tests' action: #suitesUnmarkTests;		yourself.				 	 ! !!TestRunner methodsFor: 'accessing-classes' stamp: 'kph 12/16/2006 09:06'!suitesSelected	self updateCategories; updateClasses.	^ 0! !!TestRunner methodsFor: 'accessing-suites' stamp: 'kph 10/29/2006 01:55'!suitesSelected: anInteger	self changed: #suitesSelected.! !!TestRunner methodsFor: 'command line params' stamp: 'kph 1/6/2007 05:01'!suitesSelectedFrom: list	suitesSelected := suitesAndFilters select: [:each | list includes: each].					self updateSuitesAndFilters.! !!TestRunner methodsFor: 'accessing' stamp: 'kph 2/22/2007 11:05'!suitesUnmarkTests 	self result unmark: #('fail' 'error' 'expected' 'long' 'slow' )  				onTests: (self result failures, self result errors, self result passed).					self updateFailuresList.	self updateErrorsList.! !!TestRunner methodsFor: 'updating' stamp: 'kph 12/19/2006 01:58'!update	self updateSuitesAndFilters; updateSuiteComments; updateCategories; updateClasses.! !!TestRunner methodsFor: 'updating' stamp: 'kph 12/16/2006 08:55'!updateClasses	| classesForCategories |	classesForCategories := self findClassesForCategories: categoriesSelected.	classes := classesForCategories asArray				sort: [:a :b | self sortClass: a before: b].	classesSelected := classesSelected isNil				ifTrue: [classesForCategories]				ifFalse: [classesSelected						select: [:each | classesForCategories includes: each]].	self changed: #classList;		 changed: #classSelected;		 changed: #hasRunnable.! !!TestRunner methodsFor: 'updating' stamp: 'kph 12/21/2006 05:37'!updateErrorsList	errorList := result errors asArray			sort: [ :a :b | a printString <= b printString ].		errorSelected := nil.		self 			changed: #errorList; 			changed: #errorSelected;			changed: #hasErrors ! !!TestRunner methodsFor: 'updating' stamp: 'kph 12/21/2006 05:36'!updateFailuresList	failedList := result failures asArray			sort: [ :a :b | a printString <= b printString ].		failedSelected := nil.		self 			changed: #failedList; 			changed: #failedSelected;			changed: #hasFailures 						 ! !!TestRunner methodsFor: 'updating' stamp: 'kph 12/21/2006 05:37'!updateResults	"<lint: #expect rule: #guardingClause>"	"<lint: #expect rule: #longMethods>"	self updateStatus: false.	failedList size = result failures size ifFalse: [ self updateFailuresList ].	errorList size = result errors size ifFalse: [ self updateErrorsList ].	 ! !!TestRunner methodsFor: 'accessing' stamp: 'kph 3/19/2007 02:41'!updateSuiteComments	| collated comments |	comments := Dictionary new. 		self withAllTestClassesDo: [ :eachClass |		(eachClass publishedSuites, eachClass publishedFilters) do: [ :eachSuite |			collated := comments at: eachSuite ifAbsentPut: [ Dictionary new ].			self getSuiteCommentFor: eachSuite in: eachClass collateIn: collated.		].	].		suitesComments := String streamContents: [ :display |		comments keys asSortedCollection do: [ :suite |			display nextPutAll: suite; nextPutAll: ': '.				(comments at: suite) keysAndValuesDo: [ :theComment :theClasses |					display nextPutAll: theComment; 							nextPut: $(;							nextPutAll: (theClasses asArray printString) "joinUsing: ', ')"; 							nextPutAll: ' et al.)';							cr.				].			]		].  ! !!TestRunner methodsFor: 'updating' stamp: 'kph 2/23/2007 17:20'!updateSuitesAndFilters	 	suitesAndFilters := self findSuitesAndFilters.	suitesSelected isNil				ifTrue: [ suitesSelected := Set new].	self changed: #suitesList;		 changed: #suitesSelected! !!TestRunner methodsFor: 'accessing' stamp: 'kph 12/16/2006 08:30'!withAllTestClassesDo: aBlock	self baseClasses do: [ :baseClass | 		baseClass withAllSubclassesDo: aBlock			]! !!TestRunner class methodsFor: 'initialization' stamp: 'kph 1/21/2008 19:02'!unload	self environment at: #Flaps ifPresent: [:cl | cl unregisterQuadsWithReceiver: self]. 	TheWorldMenu unregisterOpenCommandWithReceiver: self.! !!TestRunner commentStamp: '<historical>' prior: 32170296!<lint: #ignore rule: #classNotReferenced rational: 'this view is only accessed from menus'>!"SUnitGUI"!SMPackageWrapper removeSelector: #=!SMPackageWrapper removeSelector: #asString!SMPackageWrapper removeSelector: #contents!SMPackageWrapper removeSelector: #hash!SMPackageWrapper removeSelector: #printOn:!SMLoader class removeSelector: #initialize!SMLoader removeSelector: #addFiltersToMenu:!SMLoader removeSelector: #browseCacheDirectory!SMLoader removeSelector: #buildMorphicCategoriesList!SMLoader removeSelector: #buildMorphicPackagesList!SMLoader removeSelector: #buildPackagePane!SMLoader removeSelector: #buildSearchPane!SMLoader removeSelector: #categorySpecificOptions!SMLoader removeSelector: #categoryWrapperList!SMLoader removeSelector: #changeFilters:!SMLoader removeSelector: #createWindow!SMLoader removeSelector: #defaultButtonPaneHeight!SMLoader removeSelector: #emailPackageMaintainers!SMLoader removeSelector: #filterSpecs!SMLoader removeSelector: #findPackage:notifying:!SMLoader removeSelector: #generalOptions!SMLoader removeSelector: #help!SMLoader removeSelector: #installPackageRelease!SMLoader removeSelector: #openAsMorph!SMLoader removeSelector: #packageList!SMLoader removeSelector: #packageSpecificOptions!SMLoader removeSelector: #packagesListIndex:!SMLoader removeSelector: #perform:orSendTo:!SMLoader removeSelector: #reOpen!SMLoader removeSelector: #selectedCategory!SMLoader removeSelector: #selectedCategoryWrapper:!SMLoader removeSelector: #selectedItemWrapper:!SMLoader removeSelector: #selectedPackageOrRelease!SMLoader removeSelector: #updateLabel:!SMLoader removeSelector: #upgradeInstalledPackages!SMLoader removeSelector: #upgradeInstalledPackagesConfirm:!SMLoader class removeSelector: #unload!SMPackageReleaseWrapper removeSelector: #asString!SMCategoryWrapper removeSelector: #=!SMCategoryWrapper removeSelector: #asString!SMCategoryWrapper removeSelector: #category!SMCategoryWrapper removeSelector: #contents!SMCategoryWrapper removeSelector: #hash!SMLoader removeSelector: #paneColorOld!SMLoader removeSelector: #addPackagesTo:at:plus:!!SMPackageWrapper methodsFor: 'comparing' stamp: 'dvf 9/21/2003 16:25'!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMPackageWrapper methodsFor: 'converting' stamp: 'btr 11/22/2006 00:54'!asString	| string |	string := item name, ' (', item versionLabel, ')'.	item isInstalled ifTrue: [string := string asText allBold].	"(string includesSubString: '->') ifTrue: [string := string asText color: Color green]."	^ string! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'dvf 10/14/2003 18:58'!contents	^item releases reversed collect: [:e | SMPackageReleaseWrapper with: e]! !!SMPackageWrapper methodsFor: 'testing' stamp: 'dvf 9/21/2003 16:25'!hash	^self withoutListWrapper hash! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:55'!help	^ 'This shows all packages with their releases that should be displayed according the current filter.'! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49'!label	^ self asString! !!SMPackageWrapper methodsFor: 'printing' stamp: 'dvf 9/21/2003 16:22'!printOn: aStream	aStream nextPutAll: 'wrapper for: ', item printString! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 12/1/2006 15:47'!initialize	"Hook us up in the world menu."	"self initialize"	Smalltalk		at: #ToolBuilder		ifAbsent: [self registerInFlapsRegistry.			(Preferences windowColorFor: #SMLoader) = Color white				ifTrue: ["not set"					Preferences						setWindowColorFor: #SMLoader						to: (Color colorFrom: self windowColorSpecification brightColor)].			(TheWorldMenu respondsTo: #registerOpenCommand:)				ifTrue: [| oldCmds |					oldCmds := TheWorldMenu registry select: [:cmd | cmd first includesSubString: 'Package Loader'].					oldCmds do: [:cmd | TheWorldMenu unregisterOpenCommand: cmd first].					TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52'!openMenuString	^ 'SqueakMap Catalog'! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:08'!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:15'!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease ifNil: [^ nil].	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:52'!buildButtonBar	| aRow btn |	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	self buttonSpecs do: [:spec |		btn := self buildButtonNamed: spec first helpText: spec third action: spec second.		aRow addMorphBack: btn]		separatedBy: [aRow addTransparentSpacerOfSize: 3@0].	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:27'!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 19:04'!buildMorphicCategoriesList	"Create the hierarchical list holding the category tree."	| list |	list := (SimpleHierarchicalListMorph				on: self				list: #categoryWrapperList				selected: #selectedCategoryWrapper				changeSelected: #selectedCategoryWrapper:				menu: #categoriesMenu:				keystroke: nil) autoDeselect: true;				 enableDrag: false;				 enableDrop: true;				 yourself.	list setBalloonText: 'The categories are structured in a tree. Packages and package releases belong to several categories.You can add one or more categories as filters and enable them in the menu.'.	"list scroller submorphs do:[:each| list expandAll: each]."	list adjustSubmorphPositions.	^ list! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 00:22'!buildMorphicPackagesList	"Create the hierarchical list holding the packages and releases."	^(SimpleHierarchicalListMorph 		on: self		list: #packageWrapperList		selected: #selectedItemWrapper		changeSelected: #selectedItemWrapper:		menu: #packagesMenu:		keystroke: nil)		autoDeselect: false;		enableDrag: false;		enableDrop: true;		setBalloonText: 'This shows all packages with their releases that should be displayed according the current filter.';		yourself! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:13'!buildPackageButtonBar	| aRow |	"Somewhat patterned after IRCe's buttonRow method."	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'gk 5/5/2006 02:05'!buildPackagePane	"Create the text area to the right in the loader."	| ptm |	ptm := PluggableTextMorph 		on: self 		text: #contents		accept: nil		readSelection: nil "#packageSelection "		menu: nil.	ptm setBalloonText: 'This is where the selected package or package release is displayed.'.	ptm lock.	^ptm! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:08'!buildSearchPane	"Cribbed from MessageNames>>inMorphicWindowWithInitialSearchString:"	| typeInView searchButton typeInPane |	typeInView := PluggableTextMorph				on: self				text: nil				accept: #findPackage:notifying:				readSelection: nil				menu: nil.	typeInView acceptOnCR: true;		 vResizing: #spaceFill;		 hResizing: #spaceFill;		 setTextMorphToSelectAllOnMouseEnter;		 askBeforeDiscardingEdits: false;		 setProperty: #alwaysAccept toValue: true.	(typeInView respondsTo: #hideScrollBarsIndefinitely)		ifTrue: [typeInView hideScrollBarsIndefinitely]		ifFalse: [typeInView hideScrollBarIndefinitely].	searchButton := SimpleButtonMorph new target: typeInView;				 color: Color white;				 label: 'Search';				 actionSelector: #accept;				 arguments: #(); yourself.	typeInPane := AlignmentMorph newRow.	typeInPane vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 listDirection: #leftToRight;		 addMorphFront: searchButton;		 addTransparentSpacerOfSize: 6 @ 0;		 addMorphBack: typeInView;		 setBalloonText: 'Type into the pane, then press Search (or hit RETURN) to visit the next package matching what you typed.'.	^ typeInPane! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:24'!buttonSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.')		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.')		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.')		('Update' loadUpdates 'Update the package index from the servers.')		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (confirming each).')		('Help' help 'What is this?'))! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:11'!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoader methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01'!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (model categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list		collect: [:cat | SMCategoryWrapper with: cat model: self]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:45'!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 17:30'!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.3.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0.0 @ 0.0 corner: 1.0 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0.0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (0.0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0.0 @ horizDivide corner: vertDivide @ 1.0).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1.0 @ 1.0).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self! !!SMLoader methodsFor: 'interface' stamp: 'gk 7/12/2004 11:14'!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:01'!defaultLabel	^'SqueakMap Package Loader'! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/22/2006 01:14'!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoader methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 00:14'!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('Installed packages' #filterInstalled 'Display only packages that are installed.')	#('Published packages' #filterPublished 'Display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'Packages in ', (model object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 19:27'!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or description."	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty ifTrue: [^self].	descriptions _ self packageWrapperList collect: [:e | e withoutListWrapper description].	index + 1 to: list size		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	"wrap around"	1 to: index		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:05'!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 00:48'!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by (installed version -> latest version).If there is no arrow, your installed version of the package is the latest.Installed packages and releases are also in bold.The checkbox menu items at the bottom let you modify which packages you''ll see. Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.If you like a package or have comments on it, please contactthe author or the squeak mailing list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://minnow.cc.gatech.edu/squeak/2726' asUrl]! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/22/2006 01:13'!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease ifNil: [^ nil].	item isPackageRelease		ifTrue: [			(item isPublished or: [self confirm: 'Selected release is not published yet, install anyway?'])				ifTrue: [^self installPackageRelease: item]]		ifFalse: [			release := item lastPublishedReleaseForCurrentSystemVersion.			release ifNil: [				(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')					ifTrue: [						release := item lastPublishedRelease.						release ifNil: [							(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')								ifTrue: [release := item lastRelease]]]].			release ifNotNil: [^self installPackageRelease: release]]! !!SMLoader methodsFor: 'initialization' stamp: 'gk 4/5/2005 21:17'!openAsMorph	"Open the loader as a Morphic window."	"SMLoader new openAsMorph"		^self createWindow openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45'!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				(filters ifNil: [#()]) allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNotNil:		[selectedCategory := selectedCategoryWrapper category.		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/22/2006 14:30'!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [		choices add: self buttonSpecs first].	(packageOrRelease isDownloadable and: [packageOrRelease isCached]) ifTrue: [		choices add: self buttonSpecs third].	(packageOrRelease isPackageRelease and: [packageOrRelease isDownloadable]) ifTrue: [		choices add: #('Copy from cache' #cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' ).		choices add: #('Force download into cache' #downloadPackageRelease 'Force a download of the selected release into the cache.' )].	choices add: self buttonSpecs second.	^ choices! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:56'!packagesListIndex: anObject 	self		selectedItemWrapper: (anObject ifNotNil: [anObject = 0				ifFalse: [self packageWrapperList at: anObject]])! !!SMLoader methodsFor: 'interface' stamp: 'gk 4/5/2005 21:43'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!SMLoader methodsFor: 'private' stamp: 'btr 11/26/2006 23:22'!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	self delete.	(Smalltalk at: self class name) open! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 19:17'!selectedCategory	"Return selected category."	^selectedCategoryWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'accessing' stamp: 'btr 12/1/2006 15:51'!selectedCategoryWrapper: aWrapper	selectedCategoryWrapper := aWrapper.	(aWrapper notNil and:		[aWrapper withoutListWrapper objects includes: selectedItemWrapper withoutListWrapper])		ifFalse: [self selectedItemWrapper: nil].	self changed: #selectedCategoryWrapper.	self changed: #packageWrapperList.! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/22/2006 19:13'!selectedItemWrapper: aWrapper	selectedItemWrapper := aWrapper.	self changed: #selectedItemWrapper.	self contentsChanged! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:10'!selectedPackageOrRelease	"Return selected package or package release."	^self selectedItemWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:02'!updateLabel: packagesShown	"Update the label of the window."	self setLabel: self defaultLabel , ' (',			(packagesShown size < model packages size ifTrue: [packagesShown size printString,			' shown out of '] ifFalse: ['']) , model packages size printString, ' packages)'! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 21:03'!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:03'!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06'!initialize	Smalltalk at: #ToolBuilder ifAbsent: [	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58'!buildMorphicInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #installedPackageNameList		selected: #installedPackagesListIndex		changeSelected: #installedPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58'!buildMorphicNotInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #notInstalledPackageNameList		selected: #notInstalledPackagesListIndex		changeSelected: #notInstalledPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 20:06'!createFancyWindow	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicNotInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (horizDivide / 2)).	self addMorph: (self buildMorphicInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setUpdatablePanesFrom: #(#installedPackageNameList #notInstalledPackageNameList ).	currentPackageList := #notInstalled.	self setLabel: 'Categorical SqueakMap Package Loader'! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 20:01'!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setLabel: 'Categorical SqueakMap Package Loader'! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 17:27'!currentPackageList	^currentPackageList! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'btr 11/30/2006 17:44'!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 19:14'!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['No removing yet']! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20'!installedPackageNameList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58'!installedPackagesListIndex	self currentPackageList = #installed		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35'!installedPackagesListIndex: anObject 	packagesListIndex _ anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 15:09'!isOn	^false! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20'!notInstalledPackageNameList	^self packageList select: [:e | e isInstalled not]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58'!notInstalledPackagesListIndex	self currentPackageList = #notInstalled		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35'!notInstalledPackagesListIndex: anObject 	packagesListIndex _ anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategorical methodsFor: 'private' stamp: 'btr 11/30/2006 20:21'!noteChanged	self changed: #installedPackageNameList.	self changed: #notInstalledPackageNameList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45'!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 12/1/2006 15:47'!initialize	"Hook us up in the world menu."		"self initialize"	Smalltalk at: #ToolBuilder ifPresent: [:tb |		self registerInFlapsRegistry.		(Preferences windowColorFor: #SMLoader) = Color white "not set"			ifTrue: [ Preferences setWindowColorFor: #SMLoader to: (Color colorFrom: self windowColorSpecification brightColor) ].		 (TheWorldMenu respondsTo: #registerOpenCommand:)	         ifTrue: [| oldCmds |				oldCmds := TheWorldMenu registry select: [:cmd | cmd first includesSubString: 'Package Loader'].				oldCmds do: [:cmd | TheWorldMenu unregisterOpenCommand: cmd first].			TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06'!initialize	Smalltalk at: #ToolBuilder ifPresent: [:tb |		(TheWorldMenu respondsTo: #registerOpenCommand:)			ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:59'!buildFancyWith: aBuilder	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	window := aBuilder build: (aBuilder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: aBuilder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: aBuilder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: aBuilder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)); yourself);				add: ((self buildNotInstalledPackagesListWith: aBuilder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ (horizDivide / 2)); yourself);				add: ((self buildInstalledPackagesListWith: aBuilder)					frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide); yourself);				add: ((self buildPackagePaneWith: aBuilder)					frame: (0 @ horizDivide corner: 1 @ 1); yourself); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	self setUpdatablePanesFrom: #(#installedPackageList #notInstalledPackageList ).	currentPackageList := #notInstalled.	window extent: 500@500.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:56'!buildInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #installedPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:52'!buildNotInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #notInstalledPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:47'!buildWith: aBuilder	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	window := aBuilder build: (aBuilder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: aBuilder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: aBuilder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: aBuilder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)); yourself);				add: ((self buildPackagesListWith: aBuilder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide); yourself);				add: ((self buildPackagePaneWith: aBuilder)					frame: (0 @ horizDivide corner: 1 @ 1); yourself); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: 500@500.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!currentPackageList	^currentPackageList! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 18:01'!defaultLabel	^ 'Catgorical ' , super defaultLabel! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:34'!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['No removing yet']! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:52'!installedPackageList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02'!installedPackagesListIndex	^ self currentPackageList = #installed		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!installedPackagesListIndex: anObject 	packagesListIndex _ anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!isOn	^false! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:53'!notInstalledPackageList	^self packageList reject: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02'!notInstalledPackagesListIndex	^ self currentPackageList = #notInstalled		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:03'!notInstalledPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategoricalPlus methodsFor: 'private' stamp: 'btr 12/1/2006 17:53'!noteChanged	self changed: #installedPackageList.	self changed: #notInstalledPackageList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:34'!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoaderPlus class methodsFor: 'parts bin' stamp: 'btr 11/22/2006 15:02'!descriptionForPartsBin	^self partName: 'Package Loader'		categories: #(Tools)		documentation: 'SqueakMap UI'! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16'!initializedInstance	^ (ToolBuilder open: self new) extent: 400@400! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02'!new	"Create a SqueakMap loader on the default map."	^self newOn: SMSqueakMap default! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02'!newOn: aMap	"Create a SqueakMap loader on given map."	^super new on: aMap; yourself! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16'!newStandAlone	^ ToolBuilder open: self new! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:13'!open	"Create and open a SqueakMap Loader."		"SMLoaderPlus open"	^ (Smalltalk at: #ToolBuilder) open: self new! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50'!openMenuString	^ 'SqueakMap Catalog'! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:21'!openOn: aSqueakMap	"Create and open a SqueakMap Loader on a given map."	"self openOn: SqueakMap default"	^ (Smalltalk at: #ToolBuilder) open: (self newOn: aSqueakMap)! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:18'!prototypicalToolWindow	^ ToolBuilder open: self new; applyModelExtent; yourself! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:02'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry."	self environment		at: #Flaps		ifPresent: [:cl | (cl respondsTo: #registerQuad:forFlapNamed:)				ifTrue: [cl registerQuad: #(#SMLoader #prototypicalToolWindow 'Package Loader' 'The SqueakMap Package Loader' ) forFlapNamed: 'Tools']]! !!SMLoaderPlus class methodsFor: 'window color' stamp: 'btr 11/22/2006 15:02'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference."	^WindowColorSpec		classSymbol: self name		wording: 'Package Loader'		brightColor: Color yellow muchLighter duller		pastelColor: Color yellow veryMuchLighter duller		helpMessage: 'The SqueakMap Package Loader'! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!addSelectedCategoryAsFilter	"Add a new filter that filters on the currently selected category.	Make it enabled as default."	categoriesToFilterIds add: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 16:11'!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := map isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(map directory directoryEntryFor: map lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:43'!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease				ifNil: [^ nil].	dir := item isPackage				ifTrue: [map cache directoryForPackage: item]				ifFalse: [map cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir.	"withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/23/2006 12:20'!buildButtonBarWith: aBuilder	^ aBuilder pluggablePanelSpec new		model: self;		layout: #horizontal;		children: (self commandSpecs select: [ :spec | spec fourth includes: #all]				thenCollect: [ :spec |					aBuilder pluggableActionButtonSpec new						model: self;						label: spec first;						action: spec second;						help: spec third;						enabled: ((spec fourth includes: #item) ifTrue: [#hasSelectedItem]);						yourself]);			yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02'!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:48'!buildCategoriesListWith: aBuilder 	"Create the hierarchical list holding the category tree."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #categoryList;		 getSelectedPath: #selectedCategoryPath;		 getChildren: #categoryChildren:;		 hasChildren: #categoryHasChildren:;		 setSelected: #selectedCategory:;		 menu: #categoriesMenu:;		 label: #categoryLabel:;		 autoDeselect: true;		 wantsDrop: true;		 yourself"help: #help;"! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:19'!buildPackageButtonBarWith: aBuilder	^ AlignmentMorph newRow beSticky;		color: Color transparent;		clipSubmorphs: true;		yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 19:56'!buildPackagePaneWith: aBuilder	"Create the text area to the right in the loader."	^ aBuilder pluggableTextSpec new model: self; getText: #itemDescription; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:17'!buildPackagesListWith: aBuilder 	"Create the hierarchical list holding the packages and releases."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #packageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself"help: #help;"! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/23/2006 12:44'!buildSearchPaneWith: aBuilder	^ aBuilder pluggableInputFieldSpec new model: self;		selection: #searchSelection;		getText: #searchText; setText: #findPackage:notifying:; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/30/2006 17:43'!buildWith: aBuilder 	"Create the package loader window."	| buttonBarHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	vertDivide := 0.6.	horizDivide := 0.3.	window := aBuilder build: (aBuilder pluggableWindowSpec new model: self;					 label: #label;					 children: (OrderedCollection new add: ((self buildButtonBarWith: aBuilder)							frame: (0 @ 0 corner: 1 @ buttonBarHeight);							 yourself);						 add: ((self buildSearchPaneWith: aBuilder)							frame: (0 @ buttonBarHeight corner: horizDivide @ (buttonBarHeight * 2));							 yourself);						 add: ((self buildPackagesListWith: aBuilder)							frame: (0 @ (buttonBarHeight * 2) corner: horizDivide @ vertDivide);							 yourself);						 add: ((self buildCategoriesListWith: aBuilder)							frame: (0 @ vertDivide corner: horizDivide @ 1);							 yourself);												add: ((self buildPackagePaneWith: aBuilder)								frame: (horizDivide @ buttonBarHeight corner: 1 @ 1));						 yourself);					 yourself).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: 500 @ 400.	^ window! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38'!cachePackageReleaseAndOfferToCopy	"Cache package release, then offer to copy it somewhere.	Answer the chosen file's location after copy,	or the cache location if no directory was chosen."	| release installer newDir newName newFile oldFile oldName |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	installer := SMInstaller forPackageRelease: release.	[UIManager default informUser: 'Caching ' , release asString during: [installer cache]] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs.		^nil ].	installer isCached ifFalse: [self inform: 'Download failed, see transcript for details'. ^nil].	oldName := installer fullFileName.	newDir := FileList2 modalFolderSelector: installer directory.	newDir ifNil: [ ^oldName ].	newDir = installer directory ifTrue: [ ^oldName ].	newName := newDir fullNameFor: installer fileName.	newFile := FileStream newFileNamed: newName.	newFile ifNil: [ ^oldName ].	newFile binary.	oldFile := FileStream readOnlyFileNamed: oldName.	oldFile ifNil: [ ^nil ].	oldFile binary.	[[ newDir copyFile: oldFile toFile: newFile ] ensure: [ oldFile close. newFile close ]] on: Error do: [ :ex | ^oldName ].	^newName! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!categoriesMenu: aMenu 	"Answer the categories-list menu."	self selectedCategory 		ifNotNil: [aMenu addList: self categorySpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:44'!categoryChildren: aCategory	^ aCategory subCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45'!categoryHasChildren: aCategory	^ aCategory hasSubCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:46'!categoryLabel: aCategory	^ aCategory name! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01'!categoryList	"Create the category list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (map categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/22/2006 15:02'!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:01'!commandSpecFor: selector	^ self commandSpecs detect: [:spec | spec second = selector]! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:00'!commandSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.' (item all))		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.' (item all))		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.' (item all))		('Copy from cache' cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' (item))		('Force download into cache' downloadPackageRelease 'Force a download of the selected release into the cache.' (item))		('Update' loadUpdates 'Update the package index from the servers.' (all))		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (conf8irming each).' (all))		('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm '' (item))		('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm '' (item))		('Copy list' listInPasteBuffer 'Puts the list as text into the clipboard.' (all))		('Save filters' saveFiltersAsDefault 'Saves the current filters as default.' (all))		('Help' help 'What is this?' (all)))! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02'!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!defaultLabel	^ 'SqueakMap Package Loader'! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38'!downloadPackageRelease	"Force a download of the selected package release into the cache."	| release |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	[UIManager default informUser: 'Downloading ' , release asString during: [		(SMInstaller forPackageRelease: release) download]	] on: Error do: [:ex |		| msg | 		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filterAdd: anObject	self changeFilters: (self filters copyWith: anObject)! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterAutoInstall	^[:package | package isInstallable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42'!filterAvailable	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterInstalled	^[:package | package isInstalled]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterNotInstalledYet	^[:package | package isInstalled not]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42'!filterNotUptoDate	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterPublished	^[:package | package isPublished]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filterRemove: anObject	self changeFilters: (self filters copyWithout: anObject)! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43'!filterSafelyAvailable	^[:package | package isSafelyAvailable]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/30/2006 21:07'!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically') #('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.') #('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.') #('Installed packages' #filterInstalled 'Display only packages that are installed.') #('Published packages' #filterPublished 'Display only packages that have at least one published release.') ) asOrderedCollection.	categoriesToFilterIds		do: [:catId | specs add: {'Packages in ' , (map object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43'!filterVersion	"Ignore spaces in the version string, they're sometimes spurious.	Not used anymore."	^[:package | package categories anySatisfy:  		[:cat | (cat name, '*') match: (Smalltalk version copyWithout: $ ) ]]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filters	^filters! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/24/2006 13:49'!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or	description. "	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty		ifTrue: [^ self].	descriptions := self packageList collect: [:e | e description].	index + 1		to: list size		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	"wrap around"	1		to: index		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 18:36'!hasSelectedItem	^ self selectedPackageOrRelease notNil! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44'!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by versions: (installed -> latest).If there is no arrow, your installed version of the package is the latest.Bold packages and releases have been installed.The checkbox menu items modify which packages you''ll see.Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.Comment on a package by emailing the author or the squeak list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://wiki.squeak.org/2726' asUrl]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02'!informException: ex msg: msg 	"Tell the user that an error has occurred.	Offer to open debug notifier."	(self confirm: msg, 'Would you like to open a debugger?')		ifTrue: [ex pass]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease ifNil: [^ nil].	item isPackageRelease		ifTrue: [			(item isPublished or: [self confirm: 'Selected release is not published yet, install anyway?'])				ifTrue: [^self installPackageRelease: item]]		ifFalse: [			release := item lastPublishedReleaseForCurrentSystemVersion.			release ifNil: [				(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')					ifTrue: [						release := item lastPublishedRelease.						release ifNil: [							(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')								ifTrue: [release := item lastRelease]]]].			release ifNotNil: [^self installPackageRelease: release]]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:53'!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease installer |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	installer := SMInstaller forPackageRelease: aRelease.	[UIManager default informUser: 'Downloading ' , aRelease asString during:		[installer download].	UIManager default informUser: 'Installing ' , aRelease asString during: [		installer install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02'!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:44'!itemChildren: anItem 	^ anItem isPackage		ifTrue: [anItem releases]		ifFalse: [#()]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 19:56'!itemDescription	^ self selectedPackageOrRelease		ifNil: ['<No package selected>']		ifNotNilDo: [:item | item fullDescription]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45'!itemHasChildren: anItem 	^ anItem isPackage and: [anItem releases notEmpty]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44'!itemLabel: anItem 	| label |	label := anItem isPackage				ifTrue: [anItem name						, (anItem versionLabel								ifEmpty: ['']								ifNotEmptyDo: [:lbl | ' (' , anItem versionLabel , ')'])]				ifFalse: [anItem smartVersion].	^ anItem isInstalled		ifTrue: [label asText allBold]		ifFalse: [label]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/24/2006 17:17'!label	^ self		labelForShown: (packagesList				ifNil: [self packageList])! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!labelForFilter: aFilterSymbol 	^(self filterSpecs detect: [:fs | fs second = aFilterSymbol]) first! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!labelForShown: packagesShown	"Update the label of the window."	^ self defaultLabel , ' (',		(packagesShown size < map packages size ifTrue: [packagesShown size printString,		' shown out of '] ifFalse: ['']) , map packages size printString, ' packages)'! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!listInPasteBuffer	"Useful when talking with people etc.	Uses the map to produce a nice String."	Clipboard clipboardText:		(String streamContents: [:s |			packagesList do: [:p |				s nextPutAll: p nameWithVersionLabel; cr ]]) asText! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:31'!loadUpdates	[UIManager default informUser: 'Loading Updates' during: [		map loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/24/2006 14:05'!noteChanged	filters		ifNil: [^ self reOpen].	map		ifNotNil: [packagesList := nil.			selectedCategory := nil.			self changed: #categoryList.			self changed: #packageList.			self changed: #packagesListIndex.			"update my selection"			self contentsChanged]! !!SMLoaderPlus methodsFor: 'initialization' stamp: 'btr 11/22/2006 16:11'!on: aSqueakMap 	"Initialize instance."	map := aSqueakMap.	map synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!package: aPackage filteredByCategory: aCategory	"Answer true if the package should be shown	if we filter on <aCategory>. It should be shown	if itself or any of its releases has the category."	| releases |	releases := aPackage releases.	^(aPackage hasCategoryOrSubCategoryOf: aCategory) or: [			releases anySatisfy: [:rel |				rel hasCategoryOrSubCategoryOf: aCategory]]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49'!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list |	list := packagesList ifNil: [packagesList := self packageListCalculated].	selectedCategory ifNotNil: [		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^ list! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49'!packageListCalculated	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	^ self packages select: [:p |		filters allSatisfy: [:currFilter |			currFilter isSymbol				ifTrue: [(self perform: currFilter) value: p]				ifFalse: [self package: p filteredByCategory: (map object: currFilter)]]]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!packageNameList	^ self packageList collect: [:e | e name]! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:30'!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [		choices add: (self commandSpecFor: #installPackageRelease)].	(packageOrRelease isDownloadable and: [packageOrRelease isCached]) ifTrue: [		choices add: (self commandSpecFor: #browseCacheDirectory)].	(packageOrRelease isPackageRelease and: [packageOrRelease isDownloadable]) ifTrue: [		choices add: (self commandSpecFor: #cachePackageReleaseAndOfferToCopy).		choices add: (self commandSpecFor: #downloadPackageRelease)].	choices add: (self commandSpecFor: #emailPackageMaintainers).	^ choices! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 16:11'!packages	"We request the packages as sorted by name by default."	^map packagesByName asArray! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01'!packagesListIndex	^ self packageList indexOf: self selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01'!packagesListIndex: anObject 	self		selectedItem: (anObject = 0				ifFalse: [self packageList at: anObject])! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!packagesMenu: aMenu 	"Answer the packages-list menu."	self selectedPackageOrRelease 		ifNotNil: [aMenu addList: self packageSpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:45'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	^ (self respondsTo: selector)		ifTrue: [self perform: selector]		ifFalse: [super perform: selector orSendTo: otherTarget]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/26/2006 23:22'!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	window delete.	(Smalltalk at: self class name) open! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!removeCategoryFilters	"Remove all category filters."	categoriesToFilterIds := OrderedCollection new! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!removeSelectedCategoryAsFilter	"Remove the filter that filters on the currently selected category."	categoriesToFilterIds remove: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!saveFiltersAsDefault	"Save the current filters as default so that they	are selected the next time the loader is opened."	DefaultFilters := filters copy.	DefaultCategoriesToFilterIds := categoriesToFilterIds copy! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35'!searchSelection	"Selects all of the default search text so that a type-in overwrites it."	^ {1. self searchText size}! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35'!searchText	"A dummy default search text so that the field describes its purpose."	^ 'Search packages'! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02'!selectedCategory	"Return selected category."	^ selectedCategory! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:37'!selectedCategory: anSMCategory 	"Change the selected category."	selectedCategory := anSMCategory.	selectedCategory		ifNotNil: [(selectedCategory objects includes: self selectedItem)			ifFalse: [self selectedItem: nil]].	self changed: #selectedCategory.	self changed: #packageList! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:52'!selectedCategoryPath	"Return selected category's path."	| path |	path := #().	selectedCategory		ifNotNil: [selectedCategory parent				ifNotNilDo: [:p | path := path copyWith: p].			path := path copyWith: selectedCategory].	^ path		collect: [:cat | self categoryLabel: cat]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02'!selectedItem	^ selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:27'!selectedItem: anItem	"This == workaround protects us from recursion since ToolBuilder's tree widgets will always tell us that the selection has been updated when we tell it that the selection path has been updated. Cleaner solutions invited."	anItem == selectedItem ifFalse: [		selectedItem := anItem.		self changed: #selectedItemPath.		self changed: #itemDescription.		self changed: #hasSelectedItem]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:16'!selectedItemPath	| path |	path := #().	(selectedItem isKindOf: SMPackageRelease)		ifTrue: [path := path copyWith: selectedItem package].	selectedItem		ifNotNil: [path := path copyWith: selectedItem].	^ path! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:03'!selectedPackageOrRelease	"Return selected package or package release."	^ selectedItem! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!showFilterString: aFilterSymbol 	^(self stateForFilter: aFilterSymbol), (self labelForFilter: aFilterSymbol)! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!stateForFilter: aFilterSymbol 	^(self filters includes: aFilterSymbol) ifTrue: ['<yes>'] ifFalse: ['<no>']! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!toggleFilterState: aFilterSymbol 	^(self filters includes: (aFilterSymbol)) 		ifTrue: [self filterRemove: aFilterSymbol]		ifFalse: [self filterAdd: aFilterSymbol]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!uncheckFilters	"Uncheck all filters."		filters := OrderedCollection new.	self noteChanged! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!updateLabel: packagesShown	"Update the label of the window."	window ifNotNilDo: [:w | w setLabel: (self labelForShown: packagesShown)]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:29'!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during: [				map upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!upgradeInstalledPackagesConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. Confirms on each upgrade."	^ self upgradeInstalledPackagesConfirm: true! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:29'!upgradeInstalledPackagesConfirm: confirmEach 	"Tries to upgrade all installed packages to the latest published release for	this version of Squeak. If confirmEach is true we ask for every	upgrade. "	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty		ifTrue: [^ self inform: 'All ' , installed size printString , ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty		ifTrue: [^ self inform: 'None of the ' , old size printString , ' old packages of the ' , installed size printString , ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size		ifTrue: ['Of the ' , old size printString , ' old packages only ' , toUpgrade size printString , ' can be upgraded.The following packages will not be upgraded:'						, (String								streamContents: [:s | (old removeAll: toUpgrade;										 yourself)										do: [:p | s nextPutAll: p nameWithVersionLabel;												 cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info , 'About to upgrade the following packages:'				, (String						streamContents: [:s | toUpgrade								do: [:p | s nextPutAll: p nameWithVersionLabel;										 cr]]) , 'Proceed?')		ifTrue: [myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during:					[confirmEach						ifTrue: [map								upgradeOldPackagesConfirmBlock: [:p | self confirm: 'Upgrade ' , p installedRelease packageNameWithVersion , ' to ' , (p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName , '?']]						ifFalse: [map upgradeOldPackages].					self inform: toUpgrade size printString , ' packages successfully processed.'.					myRelease = self installedReleaseOfMe						ifTrue: [self noteChanged]						ifFalse: [self reOpen]]]				on: Error				do: [:ex | self informException: ex msg: ('Error occurred when upgrading old packages:\' , ex messageText , '\') withCRs]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!upgradeInstalledPackagesNoConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. No confirmation on each upgrade."	^ self upgradeInstalledPackagesConfirm: false! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMPackageReleaseWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 21:30'!asString	"Show installed releases with a trailing asterisk."	| string |	string := item smartVersion.	"Older SMBase versions don't have isInstalled.'"	(item respondsTo: #isInstalled) ifTrue:		[item isInstalled ifTrue: [string := (string , ' *') asText allBold]].	^ string! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 17:14'!contents	^ #()! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49'!label	^ self asString	! !!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13'!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMCategoryWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 18:53'!asString	^ item name , ' (' , self numberOfObjects printString , ')'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'ar 2/9/2004 02:35'!category	^item! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 21:02'!contents	^ item subCategories		collect: [:n | self class with: n model: n]! !!SMCategoryWrapper methodsFor: 'model access' stamp: 'btr 11/30/2006 21:02'!getList	^ Array		with: (self class with: self contents model: model)! !!SMCategoryWrapper methodsFor: 'testing' stamp: 'btr 11/30/2006 18:53'!hasContents	^ item hasSubCategories! !!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13'!hash	^self withoutListWrapper hash! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:56'!help	^ 'The categories are structured in a tree. Packages and package releases belong to several categories. You can add one or more categories as filters and enable them in the menu.'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'BJP 11/22/2002 14:17'!model	^model! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:53'!numberOfObjects"	| total |	total _ 0.	model allCategoriesDo: [:c |		total _ total + c objects size].	^total"	^item objects size! !!SMLoader commentStamp: 'btr 11/30/2006 18:00' prior: 34591533!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance).You can open one with:	SMLoader open!!SMLoaderCategorical commentStamp: 'btr 12/1/2006 15:16' prior: 0!A variant package loader that uses a more-or-less standard Smalltalk-80 browser perspective of selecting categories in one pane and then selecting items within in the next pane.You can open one with:	SMLoaderCategorical open!!SMLoaderPlus commentStamp: 'btr 12/1/2006 15:16' prior: 0!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance). It uses ToolBuilder to construct its window. You can open one with:	SMLoaderPlus openInstance Variables	categoriesToFilterIds:		<OrderedCollection> The set of categories to filter the packages list.	filters:				<OrderedCollection> The set of filters to apply to the packages list.	map:				<SMSqueakMap> The model SqueakMap.	packagesList:		<OrderedCollection> The list of packages from the map.	selectedCategory:	<SMCategory> The current category.	selectedItem:			<SMPackage> The selected package or release.	window:			<PluggableSystemWindow> The window, held only so we can reOpen.!"SMLoader"!UUniverseEditor removeSelector: #newPackageVersion!UGlobalInstaller removeSelector: #doInstall!UGlobalInstaller removeSelector: #requestPackageList!UUniverseServer removeSelector: #acceptConnectionOn:!UUniverseServer removeSelector: #checkForNewConnections!UPackageEditor removeSelector: #homepageString!UPackageEditor removeSelector: #urlString!UPackage removeSelector: #=!UPackage removeSelector: #install!UPackage removeSelector: #stringArrayEncoding!UPackage removeSelector: #xmlForExport!UUniverseClient removeSelector: #processIO!UUniverseBrowser class removeSelector: #initialize!UUniverseBrowser removeSelector: #requestPackageList!UUniverseBrowser class removeSelector: #unload!UUniverseMultiServer removeSelector: #acceptConnectionOn:!UUniverseMultiServer removeSelector: #checkForNewConnections!UIMonticello removeSelector: #installFileNamed:!UIProject removeSelector: #installFileNamed:!UISar removeSelector: #installFileNamed:!StringSocket class removeSelector: #spaceToEncode:!StringSocket class removeSelector: #encodeStringArray:!StringSocket class removeSelector: #decodeStringArray:!UPackageInstaller removeSelector: #installFileNamed:!UPackageInstaller class removeSelector: #installFileNamed:!!UPackageInstaller class methodsFor: 'instance creation' stamp: 'kph 2/17/2009 16:55'!installFileNamed: filename fromURL: anUrl 	(self installerForFilename: anUrl asString) installFileNamed: filename		fromURL: anUrl! !!UPackageInstaller methodsFor: 'installing' stamp: 'lr 11/12/2007 18:19'!installFileNamed: filename fromURL: anUrl 	| stream baseName |	stream := FileStream readOnlyFileNamed: filename.	baseName := (FileDirectory splitName: filename to: [ :path :base | base ]) 				copyUpTo: $..	self install: stream usingBaseName: baseName.	stream close! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 11/25/2007 22:28'!testIncrement	self should: [ '1.5.0' asUVersion increment asString = '1.5.1'].	self should: [ '1' asUVersion increment asString = '2'].	self should: [ '3-SNAPSHOT' asUVersion increment asString = '4-SNAPSHOT'].	self should: [ 'lr-84' asUVersion increment asString = 'lr-85'].	self should: [ 'lr-125.mcz' asUVersion increment asString = 'lr-126.mcz'].	self should: [ 'strange' asUVersion increment asString = 'strangenew'].	self should: [ '' asUVersion increment asString = 'new'].! !!UUniverseEditor methodsFor: 'package editing' stamp: 'pmm 11/22/2007 09:19'!newPackageVersion	| package editor newPackage |	self anyPackageSelected ifFalse: [ ^self ].	self acceptFields.	package _ self selectedPackage.		newPackage _ package deepCopy.	newPackage version: newPackage version increment.	editor _ UPackageEditor package: newPackage whenComplete: [ :p |		self acceptFields.		self sendMessage: (UMAddPackage username: username password: password package: p) ].	editor openInMorphic.	packageEditors add: editor.! !!ObjectSocketStream class methodsFor: 'as yet unclassified' stamp: 'dc 6/17/2008 14:48'!on: aSocket	^self basicNew initialize: aSocket! !!ObjectSocketStream methodsFor: 'encoding/decoding' stamp: 'dc 6/17/2008 14:48'!addToInBuf: aString	| newAlloc |	newAlloc := aString size * 2 max: 8000.	inBuf ifNil: [		inBuf := String new: newAlloc.		inBufIndex := 1.		inBufLastIndex := 0.	].	aString size > (inBuf size - inBufLastIndex) ifTrue: [		inBuf := inBuf , (String new: newAlloc)	].	inBuf 		replaceFrom: inBufLastIndex + 1 		to: inBufLastIndex + aString size		with: aString 		startingAt: 1.	inBufLastIndex := inBufLastIndex + aString size.! !!ObjectSocketStream methodsFor: 'as yet unclassified' stamp: 'dc 6/17/2008 14:48'!destroy	socket destroy.	socket := nil.! !!ObjectSocketStream methodsFor: 'private-initialization' stamp: 'dc 6/17/2008 14:48'!initialize: aSocket	socket := aSocket.	inBuf := String new: 1000.	inBufIndex := 1.	inBufLastIndex := 0.	outBuf := nil.	inObjects := OrderedCollection new.	outObjects := OrderedCollection new.! !!ObjectSocketStream methodsFor: 'as yet unclassified' stamp: 'dc 6/17/2008 14:48'!isConnected	^socket notNil and: [socket isConnected]! !!ObjectSocketStream methodsFor: 'stream protocol' stamp: 'dc 6/17/2008 14:48'!next	^inObjects removeFirst	! !!ObjectSocketStream methodsFor: 'stream protocol' stamp: 'dc 6/17/2008 14:48'!nextOrNil	inObjects isEmpty		ifTrue: [ ^nil ]		ifFalse: [ ^inObjects removeFirst ]! !!ObjectSocketStream methodsFor: 'stream protocol' stamp: 'dc 6/17/2008 14:48'!nextPut: anObject	outObjects addLast: anObject! !!ObjectSocketStream methodsFor: 'as yet unclassified' stamp: 'dc 6/17/2008 14:48'!processIO	"do some as much network IO as possible"	self processOutput.	self processInput.! !!ObjectSocketStream methodsFor: 'encoding/decoding' stamp: 'dc 6/17/2008 14:48'!processOutput	"loop sending data as long as there is data to send, and the socket is ready to receive more data"	[ socket sendDone and: [ outBuf notNil or: [ outObjects isEmpty not ] ] ] whileTrue: [		| amountSent |		outBuf isNil ifTrue: [			| nextSize |			"no data in the current buffer; make a new buffer and encode some more"			outBuf := String new: ((self spaceToEncode: outObjects first) max: 8000).			outBufIndex := 1.			outBufSize := 0.			[	outObjects isEmpty not and: [					nextSize := self spaceToEncode: outObjects first.					nextSize <= (outBuf size - outBufSize + 1) ]			] whileTrue: [				self encodeObject: outObjects first into: outBuf startingAt: outBufSize+1.				outBufSize := outBufSize + nextSize.				outObjects removeFirst ] ].		"at this point, the buffer definitely has data in it to send.  Send some"		amountSent := socket sendSomeData: outBuf startIndex: outBufIndex count: (outBufSize - outBufIndex + 1).		outBufIndex := outBufIndex + amountSent.		outBufIndex > outBufSize ifTrue: [ outBuf := nil ]  ].! !!ObjectSocketStream methodsFor: 'as yet unclassified' stamp: 'dc 6/17/2008 14:48'!remoteAddress	self isConnected ifFalse: [^nil].	^socket remoteAddress! !!ObjectSocketStream methodsFor: 'encoding/decoding' stamp: 'dc 6/17/2008 14:48'!shrinkInBuf	inBuf ifNil: [^self].	inBufLastIndex < inBufIndex ifTrue: [		inBufLastIndex := 0.		inBufIndex := 1.		inBuf size > 20000 ifTrue: [inBuf := nil].	"if really big, kill it"		^self	].	inBuf := inBuf copyFrom: inBufIndex to: inBufLastIndex.	inBufLastIndex := inBuf size.	inBufIndex := 1.! !!StringSocketStream class methodsFor: 'as yet unclassified' stamp: 'dc 6/17/2008 14:37'!clearRatesSeen"self clearRatesSeen"	MaxRatesSeen := nil ! !!StringSocketStream class methodsFor: 'as yet unclassified' stamp: 'dc 6/17/2008 14:37'!compareFiles"self compareFiles"	| data1 data2 |	data1 := (FileStream fileNamed: 'Macintosh HD:bob:nebraska test:58984048.1')			contentsOfEntireFile.	data2 := (FileStream fileNamed: 'BobsG3:squeak:dsqueak:DSqueak2.7 folder:58795431.3')			contentsOfEntireFile.	1 to: (data1 size min: data2 size) do: [ :i |		(data1 at: i) = (data2 at: i) ifFalse: [self halt].	].! !!StringSocketStream class methodsFor: 'as yet unclassified' stamp: 'dc 6/17/2008 14:32'!decodeStringArray: aString	| idx numStrings |	idx _ 1.	numStrings _ aString getInteger32: idx.	idx _ idx + 4.	numStrings < 0 ifTrue: [ ^self error: 'invalid string socket encoding' ].	numStrings > 10000000 ifTrue: [ self error: 'refusing to decode humongous string socket' ].		^(1 to: numStrings) collect: [ :ignored |		| size str |		size _ aString getInteger32: idx.		idx _ idx + 4.		str _ aString copyFrom: idx to: idx+size-1.		idx _ idx + size.		str ]	! !!StringSocketStream class methodsFor: 'as yet unclassified' stamp: 'dc 6/17/2008 14:32'!encodeStringArray: stringArray	| size outBuf outBufIndex |	size _ self spaceToEncode: stringArray.		outBuf _ String new: size.	outBufIndex _ 1.	outBuf putInteger32: stringArray size at: outBufIndex.	outBufIndex _ outBufIndex + 4.	stringArray do: [ :each |		outBuf putInteger32: each size at: outBufIndex.		outBufIndex _ outBufIndex + 4.		outBuf 			replaceFrom: outBufIndex 			to: outBufIndex + each size - 1 			with: each 			startingAt: 1.		outBufIndex _ outBufIndex + each size.	].		^outBuf! !!StringSocketStream class methodsFor: 'as yet unclassified' stamp: 'dc 6/17/2008 14:37'!showRatesSeen"self showRatesSeen"	| answer |	MaxRatesSeen ifNil: [^Beeper beep].	answer := WriteStream on: String new.	MaxRatesSeen keys asSortedCollection do: [ :key |		answer nextPutAll: key printString,'  ',((MaxRatesSeen at: key) // 10000) printString; cr	].	StringHolder new contents: answer contents; openLabel: 'send rates at 10 second intervals'.! !!StringSocketStream class methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!spaceToEncode: stringArray	^stringArray inject: 4 into: [ :sum :array |		sum + (array size + 4) ].! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!addToInBuf: aString	| newAlloc |	newAlloc _ aString size * 2 max: 80000.	inBuf ifNil: [		inBuf _ String new: newAlloc.		inBufIndex _ 1.		inBufLastIndex _ 0.	].	aString size > (inBuf size - inBufLastIndex) ifTrue: [		inBuf _ inBuf , (String new: newAlloc)	].	inBuf 		replaceFrom: inBufLastIndex + 1 		to: inBufLastIndex + aString size		with: aString 		startingAt: 1.	inBufLastIndex _ inBufLastIndex + aString size.! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:57'!addToOutBuf: arrayToWrite	| size newAlloc |	size := self spaceToEncode: arrayToWrite.	newAlloc := size * 2 max: 8000.	"gives us room to grow"	outBuf ifNil: [		outBuf := String new: newAlloc.		outBufIndex := 1.	].	outBuf size - outBufIndex + 1 < size ifTrue: [		outBuf := outBuf , (String new: newAlloc).	].	Smalltalk at: #CanvasEncoder ifPresent: [ :canvasEncoder | canvasEncoder at: 1 count:  arrayToWrite size + 1 ].	outBuf putInteger32: arrayToWrite size at: outBufIndex.	outBufIndex := outBufIndex + 4.	arrayToWrite do: [ :each |		outBuf putInteger32: each size at: outBufIndex.		outBufIndex := outBufIndex + 4.		outBuf 			replaceFrom: outBufIndex 			to: outBufIndex + each size - 1 			with: each 			startingAt: 1.		outBufIndex := outBufIndex + each size.	].	^size! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!backlog	^bytesInOutputQueue + extraUnsentBytes! !!StringSocketStream methodsFor: 'as yet unclassified' stamp: 'dc 6/17/2008 14:32'!destroy	socketWriterProcess ifNotNil: [socketWriterProcess terminate. socketWriterProcess := nil].	outputQueue := nil.	bytesInOutputQueue := 0.	socket ifNotNil: [socket destroy. socket := nil.].! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!gotSomething	numStringsInNextArray ifNil: [^self tryForNumStringsInNextArray ].	numStringsInNextArray = 0 ifTrue: [		inObjects add: #().		numStringsInNextArray := nil.		^true ].	nextStringSize ifNil: [^ self tryForNextStringSize ].	^self tryForString! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!inBufNext: anInteger		| answer |	answer := inBuf copyFrom: inBufIndex to: inBufIndex + anInteger - 1.	inBufIndex := inBufIndex + anInteger.	^answer! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!inBufSize	inBuf ifNil: [^0].	^inBufLastIndex - inBufIndex + 1! !!StringSocketStream methodsFor: 'as yet unclassified' stamp: 'dc 6/17/2008 14:32'!initialize: aSocket	transmissionError := false.	super initialize: aSocket.	outputQueue := SharedQueue new.	extraUnsentBytes := bytesInOutputQueue := 0.	socketWriterProcess := [		[self transmitQueueNext] whileTrue.		socketWriterProcess := nil.		outputQueue := nil.		bytesInOutputQueue := 0.	] forkAt: Processor lowIOPriority.! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!isConnected	^super isConnected and: [socketWriterProcess notNil]! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!nextPut: anObject	socketWriterProcess ifNil: [^self].	outObjects addLast: anObject.	"return the argument - added by kwl"	^ anObject! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!processIO	"do some as much network IO as possible"	socketWriterProcess ifNil: [^self].	self processOutput.	self processInput.! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 15:02'!processInput	| totalReceived chunkOfData |	"do as much input as possible"	self flag: #XXX.  "should have resource limits here--no more than X objects and Y bytes"	chunkOfData _ socket receiveAvailableDataIntoBuffer: self readBuffer.	self addToInBuf: chunkOfData.	totalReceived _ chunkOfData size.	totalReceived > 0 ifTrue: [		Smalltalk at: #NebraskaDebug ifPresent: [:debug | debug at: #SendReceiveStats add: {'GET'. totalReceived}].	].	[ self gotSomething ] whileTrue: [].		"decode as many string arrays as possible"	self shrinkInBuf.! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 15:03'!processOutput	| arrayToWrite size bytesSent timeStartSending t itemsSent now timeSlot bucketAgeInMS bytesThisSlot |	outBufIndex := 1.	itemsSent := bytesSent := 0.	timeStartSending := Time millisecondClockValue.	[outObjects isEmpty not and: [self isConnected]] whileTrue: [		arrayToWrite := outObjects removeFirst.		size := self addToOutBuf: arrayToWrite.		bytesSent := bytesSent + size.		itemsSent := itemsSent + 1.		outBufIndex > 10000 ifTrue: [self queueOutBufContents].	].	outBufIndex > 1 ifTrue: [self queueOutBufContents].	bytesSent > 0 ifTrue: [		MaxRatesSeen ifNil: [MaxRatesSeen := Dictionary new].		now := Time millisecondClockValue.		t := now - timeStartSending.		timeSlot := now // 10000.	"ten second buckets"		bucketAgeInMS := now \\ 10.		bytesThisSlot := (MaxRatesSeen at: timeSlot ifAbsent: [0]) + bytesSent.		MaxRatesSeen 			at: timeSlot 			put: bytesThisSlot.		Smalltalk at: #NebraskaDebug ifPresent: [:debug | debug			at: #SendReceiveStats 			add: {'put'. bytesSent. t. itemsSent. bytesThisSlot // (bucketAgeInMS max: 100)}].	].! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!purgeOutputQueue	bytesInOutputQueue := 0.	[outputQueue nextOrNil notNil] whileTrue.! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:59'!queueOutBufContents	bytesInOutputQueue := bytesInOutputQueue + outBufIndex - 1.	outputQueue nextPut: {outBuf. outBufIndex - 1}.	Smalltalk at: #NebraskaDebug ifPresent: [:nebraskaDebug | nebraskaDebug at: #queuedbufferSizes add: {outBufIndex - 1}].	outBufIndex := 1.	outBuf := String new: 11000.	! !!StringSocketStream methodsFor: 'as yet unclassified' stamp: 'dc 6/17/2008 14:32'!readBuffer	^ readBuffer ifNil: [readBuffer _ String new: 20000].! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!sendDataCautiously: aStringOrByteArray bytesToSend: bytesToSend	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent. Try not to send too much at once since this seemed to cause problems talking to a port on the same machine"	| bytesSent count |	bytesSent := 0.	[bytesSent < bytesToSend] whileTrue: [		extraUnsentBytes := bytesToSend - bytesSent.		count := socket 			sendSomeData: aStringOrByteArray 			startIndex: bytesSent + 1  			count: (bytesToSend - bytesSent min: 6000).		bytesSent := bytesSent + count.		(Delay forMilliseconds: 1) wait.	].	extraUnsentBytes := 0.	^ bytesSent! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!shrinkInBuf	inBuf ifNil: [^self].	inBufLastIndex < inBufIndex ifTrue: [		inBufLastIndex := 0.		inBufIndex := 1.		inBuf size > 20000 ifTrue: [inBuf := nil].	"if really big, kill it"		^self	].	inBuf := inBuf copyFrom: inBufIndex to: inBufLastIndex.	inBufLastIndex := inBuf size.	inBufIndex := 1.! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!spaceToEncode: anArray	"return the number of characters needed to encode the given string array"	^anArray inject: 4 into: [ :sum :array |		sum + (array size + 4) ].! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!transmitQueueNext	| bufTuple |	bufTuple := outputQueue next.	bytesInOutputQueue := bytesInOutputQueue - bufTuple second max: 0.	[		self 			sendDataCautiously: bufTuple first 			bytesToSend: bufTuple second.	]		on: Error		do: [ :ex |			transmissionError := true.		].	^transmissionError not! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!tryForNextStringSize	"grab the size of the next string, if it's available"	self inBufSize >= 4 ifFalse: [^false].	nextStringSize := inBuf getInteger32: inBufIndex.	"nextStringSize > 100000 ifTrue: [self barf]."	inBufIndex := inBufIndex + 4.		nextStringSize < 0 ifTrue: [		socket disconnect.		^false ].		^true! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!tryForNumStringsInNextArray	"input numStringsInNextARray, if 4 bytes are available"	self inBufSize >= 4 ifFalse: [^false].	numStringsInNextArray := inBuf getInteger32: inBufIndex.	"(numStringsInNextArray > 100 or: [numStringsInNextArray < 1]) ifTrue: [self barf]."	inBufIndex := inBufIndex + 4.	numStringsInNextArray < 0 ifTrue: [		socket disconnect.		^false ].		stringsForNextArray := Array new: numStringsInNextArray.	stringCounter := 0.	nextStringSize := nil. 	^true! !!StringSocketStream methodsFor: 'private-IO' stamp: 'dc 6/17/2008 14:32'!tryForString	"try to grab an actual string"	self inBufSize >= nextStringSize ifFalse: [^false].	stringsForNextArray 		at: (stringCounter := stringCounter + 1)		put: (self inBufNext: nextStringSize) asString.	stringCounter = numStringsInNextArray ifTrue: [	"we have finished another array!!"		inObjects addLast: stringsForNextArray.		stringCounter := stringsForNextArray := numStringsInNextArray := nextStringSize := nil.	] ifFalse: [	"still need more strings for this array"		nextStringSize := nil.	].	^true! !!UGlobalInstaller methodsFor: 'as yet unclassified' stamp: 'damiencassou 12/23/2008 11:10'!addDependent: anObject	^ self universe addDependent: anObject! !!UGlobalInstaller methodsFor: 'actions' stamp: 'ms 10/3/2008 13:21'!doInstall	| orderedPackages |	self anyPackageSelected not ifTrue: [^self].	orderedPackages := self orderPackagesByDependency: selectedPackageVersions.	orderedPackages		do: [ :p | 				UIManager default informUser: 'installing ', p printString						during: [configuration installPackage: p] ].	self initializeSelectedPackageVersions.! !!UGlobalInstaller methodsFor: 'actions' stamp: 'pmm 9/24/2008 16:12'!requestPackageList	UIManager default		informUser: 'Updating Package List...'		during:  [ universe updatePackagesViaWWW ]! !!UVersion methodsFor: 'conversion' stamp: 'pmm 11/22/2007 09:16'!increment	| lastInteger |	self components isEmpty ifTrue: [		^self class readFromString: 'new' ].		lastInteger := 0.	self components withIndexDo: [ :each :index |		each isInteger ifTrue: [			lastInteger := index ] ].	^self class fromComponents: (lastInteger = 0		ifTrue: [			self components copy				at: self components size				put: (self components at: self components size), 'new']		ifFalse: [			self components copy				at: lastInteger				put: (self components at: lastInteger) + 1;				yourself ])	! !!UUniverseServer methodsFor: 'networking' stamp: 'dc 6/17/2008 14:36'!acceptConnectionOn: socket	self acceptConnection: (StringSocketStream on: socket).	! !!UUniverseServer methodsFor: 'networking' stamp: 'dc 6/17/2008 14:35'!checkForNewConnections	connectionQueue ifNil: [ ^self ].	[ connections size < 10 ] whileTrue: [		| newSocket |		newSocket := connectionQueue getConnectionOrNil.		newSocket ifNil: [ ^self ].		connections add: (StringSocketStream on: newSocket) ].	! !!UPackageEditor methodsFor: 'accessors' stamp: 'dc 9/26/2008 16:41'!homepageString	^package homepage		ifNil: [ '' ]		ifNotNil: [ package homepage asString ]! !!UPackageEditor methodsFor: 'accessors' stamp: 'dc 9/26/2008 16:42'!urlString	^package url ifNotNil: [ package url asString ]! !!UPackage methodsFor: 'comparing' stamp: 'dc 9/26/2008 16:42'!= anotherPackage	self hash = anotherPackage hash ifFalse: [ ^false ].	self name = anotherPackage name ifFalse: [ ^false ].	self version = anotherPackage version ifFalse: [ ^false ].	self category = anotherPackage category ifFalse: [ ^false ].	self depends = anotherPackage depends ifFalse: [ ^false ].	self provides = anotherPackage provides ifFalse: [ ^false ].	self squeakMapID = anotherPackage squeakMapID ifFalse: [ ^false ].	self url asString = anotherPackage url asString ifFalse: [ ^false ].	self maintainer = anotherPackage maintainer ifFalse: [ ^false ].	self homepage isNil = anotherPackage homepage isNil ifFalse: [ ^false ].	(self homepage isNil or: [ 		self homepage asText = anotherPackage homepage asString]) ifFalse: [ ^false ].	self description = anotherPackage description ifFalse:[ ^false ].	^true! !!UPackage methodsFor: 'installing' stamp: 'lr 11/12/2007 18:19'!install	self url ifNil: [ ^ self ].	UPackageInstaller installFileNamed: self cachedCopyFilename fromURL: self url! !!UPackage methodsFor: '*universes-messages' stamp: 'dc 9/26/2008 16:41'!stringArrayEncoding	^Array streamContents: [ :str |		str			nextPut: self name;			nextPut: self version printString;			nextPut: self description;			nextPut: (self url ifNil: [ '(no download url)' ] ifNotNil: [ self url asString ]);			nextPut: (self homepage ifNil: [ '' ] ifNotNil: [ self homepage asString ]);			nextPut: self maintainer;			nextPut: self provides size printString;			nextPutAll: self provides;			nextPut: self depends size printString;			nextPutAll: self depends;			nextPut: 0 printString;  "legacy conflicts field"			nextPut: self category printString;			nextPut: (self squeakMapID ifNil: [''] ifNotNil: [self squeakMapID asString])].! !!UPackage methodsFor: 'serializing' stamp: 'dc 9/26/2008 16:41'!xmlForExport	^String streamContents: [ :str |		str			nextPutAll: '<package>'; cr;			nextPutAll: '<name>'; nextPutAll: self name escapeEntities; nextPutAll: '</name>'; cr;			nextPutAll: '<version>'; nextPutAll:  self version printString escapeEntities; nextPutAll: '</version>'; cr;			nextPutAll: '<category>'; print: self category; nextPutAll: '</category>'; cr;			nextPutAll: '<description>'; nextPutAll: self description escapeEntities; nextPutAll: '</description>'; cr.		self url ifNotNil: [			str nextPutAll: '<url>'; nextPutAll: self url asString escapeEntities; nextPutAll: '</url>'; cr ].		self homepage ifNotNil: [			str nextPutAll: '<homepage>'; nextPutAll:  self homepage asString escapeEntities; nextPutAll: '</homepage>'; cr ].		str nextPutAll: '<maintainer>'; nextPutAll: self maintainer escapeEntities; nextPutAll: '</maintainer>'; cr.					str nextPutAll: '<provides>'.		self printXMLPackageList: self provides on: str.		str nextPutAll: '</provides>'.		str nextPutAll: '<depends>'.		self printXMLPackageList: self depends on: str.		str nextPutAll: '</depends>'.		squeakMapID ifNotNil: [			str nextPutAll: '<squeakMapID>'.			str nextPutAll: squeakMapID asString.			str nextPutAll: '</squeakMapID>'.			].		str nextPutAll: '</package>'; cr. ]! !!UUniverseClient methodsFor: 'networking' stamp: 'dc 6/17/2008 14:35'!processIO	| rawMsg |	(stringSocket notNil and: [ stringSocket isConnected not ]) ifTrue: [		"connection has died"		stringSocket destroy.		stringSocket := nil ].		(outMessages isEmpty not and: [ socket isNil and: [ stringSocket isNil ] ]) ifTrue: [		"there are outgoing messages queued but there is no stringSocket"		(DateAndTime now - lastConnectionStart) > (Duration minutes: 1) ifTrue: [			self startConnecting ] ].		socket ifNotNil: [		"a connection is in progress"				socket isConnected ifTrue: [			"connection completed"			stringSocket := StringSocketStream on: socket.			universe shortName ifNotNil: [				outMessages addFirst: (UMProtocolVersion version: 1).				outMessages addFirst: (UMSelectServer shortName: universe shortName) ].			socket := nil. ]		ifFalse: [			socket isWaitingForConnection ifFalse: [				"the connection failed"				inMessages add: (UMConnectionFailed description: 'connection failed').				^self disconnect ] ] ].		stringSocket ifNil: [ ^self ].			[ outMessages isEmpty ] whileFalse: [		stringSocket nextPut: outMessages removeFirst asStringArray ].		stringSocket processIO.		[	rawMsg := stringSocket nextOrNil.		rawMsg isNil not	] whileTrue: [ 		self newInMessage: (UMessage fromStringArray: rawMsg) ]! !!UISar methodsFor: 'installing' stamp: 'lr 11/12/2007 18:20'!installFileNamed: filename fromURL: anUrl 	SARInstaller installSAR: filename! !!UUniverse methodsFor: 'printing' stamp: 'pmm 9/4/2008 18:39'!printOn: aStream	super printOn: aStream.	self shortName isNil ifTrue: [ ^self ].	aStream		nextPut: $(;		nextPutAll: self shortName;		nextPut: $)! !!UIMonticello methodsFor: 'installing' stamp: 'lr 11/12/2007 18:20'!installFileNamed: filename fromURL: anUrl	(filename asLowercase endsWith: '.mcm') 		ifTrue: [ ^ self mcmReader loadVersionFile: filename ].	Smalltalk at: #MCMczReader ifPresent: [ :reader | 		reader loadVersionFile: filename.		Smalltalk at: #MCRepositoryGroup ifPresent: [ :group |			group default 				addRepository: (MCHttpRepository					location: (anUrl asString						copyUpToLast: $/) 					user: ''password: '') ].		^ self ].	MczInstaller installFileNamed: filename fromURL: nil! !!UUniverseBrowser class methodsFor: 'class initialization' stamp: 'kph 1/22/2008 00:53'!initialize	 	self unload.		TheWorldMenu registerOpenCommand: {'Universe Browser (basic)'. {self. #open}}.	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UUniverseBrowser methodsFor: 'server communication' stamp: 'pmm 9/18/2008 07:14'!requestPackageList	UIManager default		informUser: 'updating package list...'		during: [ universe updatePackagesViaWWW ]! !!UUniverseBrowser class methodsFor: 'class initialization' stamp: 'kph 1/22/2008 00:53'!unload	#('Package Browser (basic)'  'Package Universe Browser' 'Universe Browser' 'Universe Browser (basic)') do: [:oldName |		TheWorldMenu unregisterOpenCommand: oldName ]. ! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'dc 6/17/2008 14:35'!acceptConnectionOn: socket	self acceptConnection: (StringSocketStream on: socket).	! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'dc 6/17/2008 14:35'!checkForNewConnections	connectionQueue ifNil: [ ^self ].	[ connections size < 100 ] whileTrue: [		| newSocket |		newSocket := connectionQueue getConnectionOrNil.		newSocket ifNil: [ ^self ].		connections add: (StringSocketStream on: newSocket) ].	! !!UIProject methodsFor: 'installing' stamp: 'lr 11/12/2007 18:20'!installFileNamed: filename fromURL: anUrl 	FileDirectory splitName: filename		to: 			[ :path :base | 						[ ProjectViewMorph openFromDirectory: (FileDirectory on: path)				andFileName: base ] 					on: ProjectEntryNotification					do: [ :ex |  ] ]! !"Universes"!!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/21/2009 02:23'!m05706NeedminimalsocketstatsInstaller mantis bug: 5706 fix: 'SocketStats.6.cs'."fix test"Installer mantis bug: 5706 fix: 'SocketStatsTest.2.cs'.""""""Bug ID: 0005706Category: [Squeak] NetworkSeverity: minorReproducibility: alwaysDate Submitted: 01-06-07 20:13Date Updated: 01-09-09 23:31Reporter: Keith_HodgesView Status: publicHandler: Keith_HodgesPriority: normalResolution: openStatus: resolvedProduct Version: 3.10Summary: 0005706: Need minimal socket statsDescription: There is no way to easily work out whether a particular block of code accessed the network. Simple StatsOpened and StatsClosed counters would solve this problem. This is needed to categorize tests that do make use of the network.Additional Information: Notes: (0008844 - 303 - 381 - 381 - 381 - 381 - 381)Keith_Hodges	01-06-07 20:15edited on: 01-10-07 13:03	The StatsOpened counter is incremented by #register: and StatsClosed is incremented by #unregister: Counters are reset on initial network initialization."fix begin"Installer mantis bug: 5706 fix: 'SocketStats.6.cs'."fix test"Installer mantis bug: 5706 fix: 'SocketStatsTest.2.cs'."fix end"Files: #('SocketStats.2.cs' 'SocketStatsTest.2.cs' 'SocketStats.3.cs' 'SocketStats.4.cs' 'SocketStatsTest.1.cs' 'SocketStats.5.cs' 'SocketStats.6.cs' 'SocketStats.1.cs')! !'From Squeak3.9 of 7 November 2006 [latest update: #7067] on 10 January 2007 at 9:43:25 am'!!NetNameResolver class methodsFor: 'network initialization' stamp: 'kph 1/7/2007 00:54' prior: 25388162!initializeNetwork	"Initialize the network drivers and record the semaphore to be used by the resolver. Do nothing if the network is already initialized. Evaluate the given block if network initialization fails."	"NetNameResolver initializeNetwork"	| semaIndex |	self resolverStatus = ResolverUninitialized		ifFalse: [^HaveNetwork _ true].  "network is already initialized"	HaveNetwork _ false.	"in case abort"	self resetNetworkStats.	ResolverSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: ResolverSemaphore.	"result is nil if network initialization failed, self if it succeeds"	(self primInitializeNetwork: semaIndex)		ifNil: [NoNetworkError signal: 'failed network initialization']		ifNotNil: [HaveNetwork _ true].! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'kph 1/7/2007 00:54'!resetNetworkStats	Socket resetStats.! !!OldSocket class methodsFor: 'registry' stamp: 'kph 1/8/2007 12:34' prior: 26041876!register: anObject	self stats statsIncrementOpened.	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!OldSocket class methodsFor: 'registry' stamp: 'kph 1/9/2007 10:58'!stats^ Socket! !!OldSocket class methodsFor: 'registry' stamp: 'kph 1/8/2007 12:34' prior: 26042901!unregister: anObject	self stats statsIncrementClosed.	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !!Socket class methodsFor: 'class initialization' stamp: 'kph 1/7/2007 00:55' prior: 30388285!initialize	"Socket initialize"	"Socket Types"	TCPSocketType _ 0.	UDPSocketType _ 1.	"Socket Status Values"	InvalidSocket _ -1.	Unconnected _ 0.	WaitingForConnection _ 1.	Connected _ 2.	OtherEndClosed _ 3.	ThisEndClosed _ 4.	RegistryThreshold _ 100. "# of sockets"		"stats"	self resetStats! !!Socket class methodsFor: 'instance creation' stamp: 'kph 1/8/2007 12:42' prior: 30392779!register: anObject	self stats  statsIncrementOpened.	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!Socket class methodsFor: 'network initialization' stamp: 'kph 1/7/2007 00:54'!resetStats	"stats"	StatsOpened _ 0.	StatsClosed _ 0.! !!Socket class methodsFor: 'registry' stamp: 'kph 1/8/2007 12:42' prior: 30393792!unregister: anObject	self stats statsIncrementClosed.	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !!Socket class methodsFor: 'stats' stamp: 'kph 1/10/2007 09:42'!stats ^ self! !!Socket class methodsFor: 'stats' stamp: 'kph 1/8/2007 12:36'!statsClosed	^ StatsClosed! !!Socket class methodsFor: 'stats' stamp: 'kph 1/8/2007 12:35'!statsIncrementClosed  "allows other classes (OldSocket) to contribute to stats total."	StatsClosed := StatsClosed + 1! !!Socket class methodsFor: 'stats' stamp: 'kph 1/8/2007 12:35'!statsIncrementOpened  "allows others (OldSocket) to contribute to stats total."	StatsOpened := StatsOpened + 1! !!Socket class methodsFor: 'stats' stamp: 'kph 1/8/2007 12:22'!statsOpen 	^ self statsOpened - self statsClosed! !!Socket class methodsFor: 'stats' stamp: 'kph 1/8/2007 12:35'!statsOpened	^ StatsOpened! !Socket initialize!----End fileIn of a stream----!'From Squeak3.9 of 7 November 2006 [latest update: #7067] on 8 January 2007 at 1:14:07 pm'!TestCase subclass: #SocketStatsTest	instanceVariableNames: 'socket opened closed '	classVariableNames: ''	poolDictionaries: ''	category: 'NetworkTests-Kernel'!!SocketStatsTest methodsFor: 'support' stamp: 'kph 1/8/2007 12:43'!stats	^ Socket	! !!SocketStatsTest methodsFor: 'support' stamp: 'kph 1/8/2007 12:53'!testOpen: socketOpeningBlock close: socketClosingBlock	| beforeOpened beforeClosed socket  |		beforeOpened := self stats statsOpened.	beforeClosed := self stats statsClosed.		socket := socketOpeningBlock value.		self assert: (self stats statsOpened = (beforeOpened + 1)). 	self assert: (self stats statsClosed = beforeClosed). 		socketClosingBlock value: socket.	self assert: (self stats statsOpened = (beforeOpened + 1)). 	self assert: (self stats statsClosed = (beforeClosed + 1)). 		! !!SocketStatsTest methodsFor: 'standard tests(net)' stamp: 'kph 1/8/2007 12:58'!testHttpSocketself testOpen: [ HTTPSocket new ] close: [ :s | s destroy ].! !!SocketStatsTest methodsFor: 'standard tests(net)' stamp: 'kph 1/8/2007 12:57'!testOldSocketself testOpen: [ OldSocket new ] close: [ :s | s destroy ].! !!SocketStatsTest methodsFor: 'standard tests(net)' stamp: 'kph 1/8/2007 12:57'!testSocketself testOpen: [ Socket new ] close: [ :s | s destroy ].! !SocketStatsTest removeSelector: #test:!TestCase subclass: #SocketStatsTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'NetworkTests-Kernel'!----End fileIn of a stream----!Installer mantis bug: 5706 fix: 'SocketStats.6.cs'."fix test"Installer mantis bug: 5706 fix: 'SocketStatsTest.2.cs'.!----End fileIn of a stream----!!Squeak310MakeBuildCandidate methodsFor: 'resolved-fixed' stamp: 'auto 2/21/2009 02:23'!m06868SystemNavigationobsoleteBehavInstaller mantis bug: 6868 fix: 'SystemNavigation-obsoleteBehaviors.1.st'.""""""Bug ID: 0006868Category: [Squeak] SystemSeverity: minorReproducibility: alwaysDate Submitted: 01-21-08 22:30Date Updated: 01-10-09 03:42Reporter: Keith_HodgesView Status: publicHandler: Keith_HodgesPriority: normalResolution: fixedStatus: resolvedProduct Version: Summary: 0006868: SystemNavigation-#obsoleteBehaviours chokes on ProtoObjectsDescription: Traversing all objects in the system, breaks on ProtoObjects which do not implement #isBehaviorAdditional Information: Notes: (0011694 - 100 - 144 - 144 - 144 - 144 - 144)Keith_Hodges	01-21-08 22:36edited on: 01-22-08 11:37	"fix begin"Installer mantis bug: 6868 fix: 'SystemNavigation-obsoleteBehaviors.1.st'."fix end"(0011696 - 219 - 243 - 243 - 243 - 243 - 243)Keith_Hodges	01-22-08 00:01edited on: 01-22-08 11:08	SystemNavigation-obsoleteBehaviors.1.st is a reimplementation in terms of (obj inheritsFrom: Behavior)As an alternative ProtoObject-isBehavior.1.cs moves the implementation of isBehavior from Object to ProtoObjectFiles: #('SystemNavigation-obsoleteBehaviors.st' 'ProtoObject-isBehavior.1.cs' 'SystemNavigation-obsoleteBehaviors.1.st')! !'From Squeak3.10 of 22 July 2007 [latest update: #7159] on 22 January 2008 at 11:05:25 am'!!SystemNavigation methodsFor: 'query' stamp: 'kph 1/22/2008 11:05' prior: 31771017!obsoleteBehaviors	"SystemNavigation default obsoleteBehaviors inspect"	"Find all obsolete behaviors including meta classes"	Smalltalk garbageCollect.	^ self allObjectsSelect: [:obj | (obj class inheritsFrom: Behavior) and: [obj isObsolete] ]. ! !----End fileIn of a stream----!Installer mantis bug: 6868 fix: 'SystemNavigation-obsoleteBehaviors.1.st'.!----End fileIn of a stream----!!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/21/2009 02:23'!m06466LazyListMorphlistChagedfixuplInstaller mantis bug: 6466 fix:  'LazyListMorph-listChanged.st'.""""""Bug ID: 0006466Category: [Squeak] MorphicSeverity: minorReproducibility: alwaysDate Submitted: 05-06-07 15:02Date Updated: 01-09-09 23:31Reporter: Keith_HodgesView Status: publicHandler: Priority: normalResolution: openStatus: resolvedProduct Version: 3.9Summary: 0006466: LazyListMorph-listChaged fixuploaded to squeak-devDescription: This fixes the fact that some list morphs need to be resized in order to be used, this is particularly noticable in 3.9 buy opening a PackagePaneBrowser, the left hand list is not scrollable.Additional Information: Notes: (0010668 - 88 - 120 - 120 - 120 - 120 - 120)Keith_Hodges	05-06-07 15:03"fix begin"Installer mantis bug: 6466 fix: 'LazyListMorph-listChanged.st'."fix end"(0010669 - 427 - 475 - 475 - 475 - 475 - 475)wiz	05-06-07 20:54Hi Keith,Tried it. Fix works for PackagePaneBrowsers.I did notice that the fileout uses unix line endings (lfs) which made the source look like it was all on one line on my Mac.I am also wondering what an appropriate test would be. Genning up a package browser and mucking around in its package list looking at scrollbars would seem to be excessive. I wonder if there is an easier way to demostrate the problem.(0010670 - 11 - 11 - 11 - 11 - 11 - 11)KenCausey	05-07-07 18:24categorized(0012845 - 41 - 41 - 41 - 41 - 41 - 41)Keith_Hodges	12-13-08 01:39uploaded file has had lf problem resolvedFiles: #('LazyListMorph-listChanged.st')! !'From Squeak3.10.2bc-beta of 13 December 2008 [latest update: #7179] on 13 December 2008 at 1:37:07 am'!!LazyListMorph methodsFor: 'list management' stamp: 'kph 12/13/2008 01:37' prior: 22958866!listChanged	"set newList to be the list of strings to display"		listItems := Array new: self getListSize withAll: nil.	maxWidth := nil.	selectedRow := nil.	selectedRows := PluggableSet integerSet.	self adjustHeight.	self adjustWidth.	self changed.! !----End fileIn of a stream----!Installer mantis bug: 6466 fix:  'LazyListMorph-listChanged.st'.!----End fileIn of a stream----!!Squeak310MakeBuildCandidate methodsFor: 'resolved-fixed' stamp: 'auto 2/21/2009 02:23'!m05669WorkspaceopenFileconvenienceInstaller mantis bug: 5669 fix: 'M5669-Workspace-openFile.2.cs'.""""""Bug ID: 0005669Category: [Squeak] ToolsSeverity: featureReproducibility: alwaysDate Submitted: 12-23-06 06:21Date Updated: 01-09-09 23:31Reporter: Keith_HodgesView Status: publicHandler: Priority: normalResolution: fixedStatus: resolvedProduct Version: Summary: 0005669: Workspace openFile: convenience methodDescription: There is no convenience method for opening a workspace on text.Nor is there a way of saving a file such that it opens a workspace.And Workspace always adds '.text' to the name even if it already has itAdditional Information: Notes: (0008755 - 397 - 469 - 469 - 697 - 697 - 697)wiz	12-25-06 08:46See 0002993 and the recomplaint #4656.You can actually ask to put a file in a workspace thusly:In a file list read a text file. Using the menu (from the text pane)select read text into workspace.The problem is in 3.9 it doesn't quite work. and the fix in 0002993 never got in nor was a substitute fix ever created.The fix AFAIK works quite well.Yours in service, --Jerome Peace(0008756 - 43 - 43 - 43 - 43 - 43 - 43)Keith_Hodges	12-25-06 22:21But there are STILL no convenience methods.(0008757 - 631 - 719 - 719 - 719 - 719 - 719)wiz	12-26-06 01:51Cool, I piped up because I knew some things that were relevant.What do you mean by convenience methods?What do you see. And where do you see it being?In other words, in positive terms, what is the users story?The complaint here may make perfect sense to you. But how is the reader to understand what you mean? Please don't assume I have the same body of knowledge or vocabulary as you. In truth this is the first time I've come across the term "convenience methods" and I am totally at sea (i.e. pretty dang ignorant) as to what special meaning that has in this context.Yours in curiosity, -- Jerome Peace(0011294 - 163 - 205 - 205 - 205 - 205 - 205)Keith_Hodges	10-10-07 23:03ok exampleA := Workspace open.is A useful for addressing the workspace?A := Workspace withContents: 'test'.A := Workspace fromFile: 'test.txt'. etc(0011305 - 430 - 496 - 496 - 496 - 496 - 496)wiz	10-12-07 04:39Hi Keith, Your examples start to get there. What I really want to see is the user story in the formcontext: I wanted to do this( where you descirbe this generally and specifially enough that you give the reader of what you want)problem: Why this can't be done yetsolution: Add these methods to here and its done. (Be inclusive of most all you want done.)Then later you or others can upload the solution code.(0011988 - 344 - 356 - 356 - 356 - 356 - 356)kbrown	04-10-08 05:04Here's an example of how to read text from a file into an appropriately named Workspace so you can use the Workspace windowbar menu to save the contents of the Workspace back into the same file easily.(SHWorkspace new openLabel: 'myWorkspace') contents: ((FileStream fileNamed: 'myWorkspace.text') contentsOfEntireFile); changed: #contents.(0012842 - 90 - 134 - 134 - 134 - 134 - 134)Keith_Hodges	12-11-08 16:49edited on: 12-18-08 02:01	"fix begin"Installer mantis bug: 5669 fix: 'M5669-Workspace-openFile.2.cs'."fix end"(0012843 - 65 - 71 - 71 - 71 - 71 - 71)Keith_Hodges	12-11-08 17:42w := Workspace openFile: 'Readme.txt'.w label: 'Welcome to...'.(0012846 - 153 - 187 - 187 - 187 - 187 - 187)Keith_Hodges	12-13-08 01:47edited on: 12-15-08 20:31	Included Workspace-openFile.1.cs in 081214-0249-Squeak3.10.2bc-betaWorkspace-openFile.2.cs - adds "open..." menu item to provide a file opening UI.(0012862 - 37 - 37 - 37 - 37 - 37 - 37)Keith_Hodges	12-18-08 02:00allow to cancel out of opening a fileFiles: #('Workspace-openFile.1.cs' 'Workspace-openFile.2.cs' 'M5669-Workspace-openFile.1.cs' 'M5669-Workspace-openFile.2.cs')! !'From Squeak3.10.2bc-beta of 16 December 2008 [latest update: #7179] on 18 December 2008 at 1:59:11 am'!!Model methodsFor: 'dependents' stamp: 'kph 12/11/2008 16:41' prior: 24536358!containingWindow	"Answer the window that holds the receiver.  The dependents technique is odious and may not be airtight, if multiple windows have the same model."	^ self dependents detect:		[:d | d isSystemWindow and: [d model == self]] ifNone: [nil]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'kph 12/11/2008 16:37' prior: 26454616!saveContentsInFile	"Save the receiver's contents string to a file, prompting the user for a file-name.  Suggest a reasonable file-name."	self saveContentsInFile: self suggestedFileName! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'kph 12/11/2008 18:24'!saveContentsInFile: aFileName	"Save the receiver's contents string to a file, prompting the user for a file-name.  Suggest a reasonable file-name."	|  stringToSave fileName |	fileName := UIManager default request: 'File name?' translated					initialAnswer: aFileName.	(self model respondsTo: #fileName:)		ifTrue: [ self model fileName: fileName ].	stringToSave := paragraph text string.	stringToSave size == 0 ifTrue: [ ^ self inform: 'nothing to save.'].	fileName isEmptyOrNil	 ifFalse:		[(FileStream newFileNamed: fileName) nextPutAll: stringToSave; close]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'kph 12/10/2008 16:42' prior: 26457334!sendContentsToPrinter	| textToPrint printer |		textToPrint := paragraph text.	textToPrint size == 0 ifTrue: [^self inform: 'nothing to print.'].	printer := TextPrinter defaultTextPrinter.		self model containingWindow 		ifNil: [printer documentTitle: 'Untitled']		ifNotNilDo: [ :window  | printer documentTitle: window label].	printer printText: textToPrint! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'kph 12/11/2008 16:40'!suggestedFileName	"If the model has a fileName use that, otherwise derive a reasonable file-name from the window label"	| labelToUse suggestedName lastIndex |	(self model respondsTo: #fileName) 		ifTrue: [ self model fileName ifNotNilDo: [ :f | ^ f ] ]. 							labelToUse := self model containingWindow 		ifNil: ['Untitled']		ifNotNilDo:	[ :window |  window label ].			suggestedName := nil.	#(	('Decompressed contents of: '		'.gz')) do:  "can add more here..."		[:leaderTrailer |			(labelToUse beginsWith: leaderTrailer first) ifTrue:				[suggestedName := labelToUse copyFrom: leaderTrailer first size + 1 to: labelToUse size.				(labelToUse endsWith: leaderTrailer last)					ifTrue:						[suggestedName := suggestedName copyFrom: 1 to: suggestedName size - leaderTrailer last size]					ifFalse:						[lastIndex := suggestedName lastIndexOf: $. ifAbsent: [0].						(lastIndex = 0 or: [lastIndex = 1]) ifFalse:							[suggestedName := suggestedName copyFrom: 1 to: lastIndex - 1]]]].	^ suggestedName ifNil: [suggestedName := labelToUse, '.text'].			! !!StringHolder class methodsFor: 'instance creation' stamp: 'kph 12/11/2008 16:44' prior: 31307927!open	^ (Smalltalk at: #Workspace ifAbsent:[self]) new openLabel: 'Workspace'		"Not to be confused with our own class var 'Workspace'"! !!Workspace methodsFor: 'accessing' stamp: 'kph 12/10/2008 17:47' prior: 50916219!acceptContents: aString	(fileName notNil and: [ fileName endsWith: '.auto' ])		ifTrue: [ self saveContentsInFileNoConfirm ].	acceptAction ifNotNil:[acceptAction value: aString].	^super acceptContents: aString.! !!Workspace methodsFor: 'accessing' stamp: 'kph 12/11/2008 16:55'!contents: aString	super contents: aString.		self changed: #contents.! !!Workspace methodsFor: 'accessing' stamp: 'kph 12/11/2008 16:21'!controller	"A bit of a hack to pass along this message to the controller or morph.  (Possibly this Workspace menu item could be deleted, since it's now in the text menu.)"	| textMorph textView |	textMorph := self dependents detect: [:dep | dep isKindOf: PluggableTextMorph] ifNone: [nil].	textMorph notNil ifTrue: [^ textMorph ].	textView := self dependents detect: [:dep | dep isKindOf: PluggableTextView] ifNone: [nil].	textView notNil ifTrue: [^ textView controller ].! !!Workspace methodsFor: 'accessing' stamp: 'kph 12/11/2008 16:23'!fileName	"Answer the value of fileName"	^ fileName! !!Workspace methodsFor: 'accessing' stamp: 'kph 12/11/2008 16:23'!fileName: anObject	"Set the value of fileName"	fileName := anObject! !!Workspace methodsFor: 'accessing' stamp: 'kph 12/16/2008 13:02'!fileOpen: aFileName 	^ self open; fileRead: aFileName; yourself! !!Workspace methodsFor: 'accessing' stamp: 'kph 12/18/2008 01:59'!fileRead: aFileName	aFileName isEmptyOrNil ifTrue: [ ^ self ].	^ self fileName: aFileName;		label: aFileName;		contents: ((FileStream oldFileOrNoneNamed: aFileName) 						ifNil: [ '' ] 						ifNotNilDo: [ :f | f contentsOfEntireFile]); 		yourself! !!Workspace methodsFor: 'accessing' stamp: 'kph 12/15/2008 20:06'!fileRevert	self fileRead: fileName! !!Workspace methodsFor: 'accessing' stamp: 'kph 12/15/2008 20:02'!label: aString	self class hiddenFileExtensions do: [ :ext |			(aString endsWith: ext) ifTrue: [ ^  self containingWindow setLabel:  (aString allButLast: ext size) ].			].		self containingWindow setLabel: aString		! !!Workspace methodsFor: 'as yet unclassified' stamp: 'kph 12/15/2008 19:56'!fileAskToOpen	self fileRead: (UIManager default request: 'File name?' translated				initialAnswer: (fileName ifNil: [ '' ])).! !!Workspace methodsFor: 'as yet unclassified' stamp: 'kph 12/11/2008 16:37' prior: 50917035!saveContentsInFile	self controller saveContentsInFile! !!Workspace methodsFor: 'as yet unclassified' stamp: 'kph 12/11/2008 16:28'!saveContentsInFileNoConfirm	^  [ self saveContentsInFile ] on: Notification 		do: [ :ex | 						ex resume: ((ex messageText endsWith: '?') ifTrue: [#default] ifFalse: [ true ]) ].					! !!Workspace methodsFor: 'initialize-release' stamp: 'kph 12/11/2008 16:28' prior: 50920010!initialize		super initialize.	acceptDroppedMorphs := false.	mustDeclareVariables := false.! !!Workspace methodsFor: 'initialize-release' stamp: 'kph 12/15/2008 20:03'!open		self openLabel: 'Workspace'! !!Workspace methodsFor: 'initialize-release' stamp: 'kph 12/15/2008 20:04'!openFile: aFileName 	^ self	open;		  	readFile: aFileName;			yourself! !!Workspace methodsFor: 'initialize-release' stamp: 'kph 12/15/2008 20:05'!readFile: aFileName 	^ self 		fileName: aFileName;		label: aFileName;		contents: ((FileStream oldFileOrNoneNamed: aFileName) 						ifNil: [ '' ] 						ifNotNilDo: [ :f | f contentsOfEntireFile]); 		changed: #contents;		yourself! !!Workspace methodsFor: 'menu commands' stamp: 'kph 12/15/2008 19:55' prior: 50920177!addModelItemsToWindowMenu: aMenu 		aMenu addLine.	aMenu		add: 'open...'		target: self		action: #fileAskToOpen.	aMenu		add: 'save contents to file...'		target: self		action: #saveContentsInFile.		fileName ifNotNil: [ 		aMenu			add: 'revert'			target: self			action: #fileRevert.			].	aMenu		add: 'reset variables'		target: self		action: #initializeBindings.	aMenu		addUpdating: #mustDeclareVariableWording		target: self		action: #toggleVariableDeclarationMode.	aMenu		addUpdating: #acceptDroppedMorphsWording		target: self		action: #toggleDroppingMorphForReference! !!Workspace class methodsFor: 'instance creation' stamp: 'kph 12/11/2008 17:19'!openContents: aString	^ self new open; contents: aString; yourself! !!Workspace class methodsFor: 'file support' stamp: 'kph 12/11/2008 18:12'!hiddenFileExtensions		"these extensions are the defaults which do not show in the title"	^ #( '.text' '.txt' )! !!Workspace class methodsFor: 'file support' stamp: 'kph 12/11/2008 16:25'!openFile: aFileName	^ self new fileOpen: aFileName! !----End fileIn of a stream----!Installer mantis bug: 5669 fix: 'M5669-Workspace-openFile.2.cs'.!----End fileIn of a stream----!!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/21/2009 02:24'!m07244ImagecleanUpmethodsInstaller mantis bug: 7244 fix: 'M7244-CleanUps.4.cs'.""""""Bug ID: 0007244Category: [Squeak] KernelSeverity: majorReproducibility: alwaysDate Submitted: 12-12-08 03:03Date Updated: 02-20-09 06:21Reporter: Keith_HodgesView Status: publicHandler: Priority: highResolution: openStatus: resolvedProduct Version: 3.10.2Summary: 0007244: Image cleanUp methodsDescription: Methods implementingSmalltalkImage current cleanUpAll. &SmalltalkImage current freeSpace.Additional Information: Notes: (0012844 - 80 - 124 - 124 - 124 - 124 - 124)Keith_Hodges	12-12-08 03:05edited on: 02-21-09 02:03	"fix begin"Installer mantis bug: 7244 fix: 'M7244-CleanUps.4.cs'."fix end"(0012850 - 309 - 363 - 363 - 363 - 363 - 363)Keith_Hodges	12-15-08 21:56edited on: 02-20-09 06:19	CleanUps.2.cs - adds cleanUpAllExcept: aListOfClassNamesM7244-CleanUps.1.cs - fix to cleanUpAllExceptM7244-CleanUps.2.cs - lots more from JohnM7244-CleanUps.3.cs - May load into 3.9M7244-CleanUps.4.cs - Ensure that initials dialog isn't needed Fix intended for 3.10.2, included in 3.10.2-build(0012960 - 54 - 54 - 54 - 54 - 54 - 54)Keith_Hodges	02-12-09 23:41Received complaint that this fix doesnt load in to 3.9Files: #('M7244-CleanUps.3.cs' 'M7244-CleanUps.1.cs' 'M7244-CleanUps.2.cs' 'CleanUps.1.cs' 'CleanUps.2.cs' 'M7244-CleanUps.4.cs')! !'From Squeak3.10.2-build of 2009-02-20T05:58:09.163+00:00 [latest update: #7179] on 20 February 2009 at 6:17:29 am'!!Object methodsFor: 'flexibility' stamp: 'kph 12/12/2008 02:43'!askFor: selector     "returns true or false, for testing #isSomething without having to add method to Object"		^ ((self class canUnderstand: selector) ifFalse: [ nil ] ifTrue: [ self perform: selector ]) == true! !!ChangeSet methodsFor: 'clean up' stamp: 'mtf 7/25/2008 20:20'!cleanUp	self deleteUnusedChangeSets! !!ChangeSet methodsFor: 'clean up' stamp: 'mtf 7/25/2008 20:20'!deleteUnusedChangeSets"Delete all changesets except those currently used by existing projects. Copied from ReleaseBuilder >> cleanUpChanges"	| projectChangeSetNames |	projectChangeSetNames := Project allSubInstances collect: [:proj | proj changeSet name].	ChangeSet removeChangeSetsNamedSuchThat:		[:cs | (projectChangeSetNames includes: cs) not].! !!Class methodsFor: 'clean up' stamp: 'mtf 7/24/2008 12:16'!fixObsoleteSuperclass	| newSuper |	superclass ifNil: [^ self].	superclass isObsolete ifFalse: [^ self].	newSuper := [superclass nonObsoleteClass] ifError: [^ self].	ClassBuilder new		name: name		inEnvironment: self environment		subclassOf: newSuper		type: self typeOfClass		instanceVariableNames: self instanceVariablesString		classVariableNames: self classVariablesString		poolDictionaries: self poolDictionaryNames		category: self category! !!Class methodsFor: 'clean up' stamp: 'mtf 7/25/2008 17:51'!removeDuplicateSubclassEntries	| count class |	subclasses ifNil: [^ self].	(IdentityBag newFrom: subclasses) sortedCounts do: [:assoc |		count := assoc key. class := assoc value.		count = 1 ifTrue: [^ self].		self removeSubclass: class.		self addSubclass: class]! !!AppRegistry class methodsFor: 'clean up' stamp: 'kph 12/12/2008 02:09'!freeSomeSpace	self removeObsolete! !!AppRegistry class methodsFor: 'clean up' stamp: 'kph 2/12/2009 17:31' prior: 16979730!removeObsolete	"AppRegistry removeObsoleteClasses"	self registeredClasses copy do:[:cls| 		(cls class isObsolete or:[cls isBehavior and:[cls isObsolete]]) 			ifTrue:[self unregister: cls]].! !!Behavior class methodsFor: 'clean up' stamp: 'kph 12/12/2008 02:10'!cleanUp	^ self flushObsoleteSubclasses ! !!Behavior class methodsFor: 'clean up' stamp: 'kph 12/12/2008 02:10' prior: 17370041!flushObsoleteSubclasses	"Behavior flushObsoleteSubclasses"	ObsoleteSubclasses finalizeValues.! !!Browser class methodsFor: 'clean up' stamp: 'mtf 7/25/2008 20:12'!cleanUp	self initialize.! !!ChangeSet class methodsFor: 'clean up' stamp: 'kph 2/12/2009 15:20'!cleanUp	| projectChangeSetNames |	projectChangeSetNames := Project allSubInstances collect: [:proj | proj changeSet name].	self removeChangeSetsNamedSuchThat:		[:cs | (projectChangeSetNames includes: cs) not].		self resetCurrentToNewUnnamedChangeSet  ! !!ChangeSorter class methodsFor: 'clean up' stamp: 'kph 2/12/2009 23:33'!cleanUp	self askFor: #initializeChangeSetCategories! !!ChangesOrganizer class methodsFor: 'clean up' stamp: 'kph 2/12/2009 23:32'!cleanUp	self askFor: #initializeChangeSetCategories! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'kph 2/20/2009 06:16' prior: 33750313!belongsInMyInitials: aChangeSet	"Answer whether a change set belongs in the MyInitials category. 	if the initials are not set then return false"	Utilities authorInitialsPerSe ifEmpty: [ ^ false ].	^ aChangeSet name endsWith: ('-', Utilities authorInitialsPerSe)! !!Class class methodsFor: 'clean up' stamp: 'mtf 7/25/2008 17:50'!freeSomeSpace"Fix some problems with classes. Use Smalltalk allClassesDo: since it does not use the subclass list, which we may be modifying during this iteration"	Smalltalk allClassesDo: [:ea |		ea fixObsoleteSuperclass.		ea removeDuplicateSubclassEntries]! !!CommandHistory class methodsFor: 'clean up' stamp: 'kph 2/12/2009 15:16'!cleanUp	self allInstancesDo: [ :ea | ea initialize ]! !!DataStream class methodsFor: 'clean up' stamp: 'kph 1/18/2008 11:52'!cleanUp	^ self initialize! !!DataStream class methodsFor: 'notification' stamp: 'kph 5/31/2008 03:30'!classRemoved: aClass	^ TypeMap removeKey: aClass ifAbsent: nil.! !!EventManager class methodsFor: 'clean up' stamp: 'kph 12/12/2008 02:24'!cleanUp	 	 	 ActionMaps := nil.		 ! !!FileList class methodsFor: 'clean up' stamp: 'mtf 7/22/2008 15:58'!freeSomeSpace	self removeObsolete! !!FileServices class methodsFor: 'clean up' stamp: 'mtf 7/22/2008 15:59'!freeSomeSpace	self removeObsolete! !!GradientFillStyle class methodsFor: 'class initialization' stamp: 'kph 2/12/2009 15:01'!freeSomeSpace	^ self initPixelRampCache! !!ImageMorph class methodsFor: 'clean up' stamp: 'kph 2/12/2009 15:08'!cleanUp	DefaultForm := Form extent: 1@1 depth: 1 ! !!MethodChangeRecord class methodsFor: 'clean up' stamp: 'kph 1/18/2008 12:10'!cleanUp	MethodChangeRecord allInstancesDo: [:each | each noteNewMethod: nil].! !!ModelExtension class methodsFor: 'clean up' stamp: 'kph 2/12/2009 15:24'!cleanUp	self initialize! !!NaturalLanguageFormTranslator class methodsFor: 'accessing' stamp: 'kph 2/12/2009 15:02'!freeSomeSpace	CachedTranslations := nil! !!NaturalLanguageTranslator class methodsFor: 'class initialization' stamp: 'kph 2/12/2009 15:03'!freeSomeSpace	self resetCaches! !!PaintBoxMorph class methodsFor: 'as yet unclassified' stamp: 'kph 2/12/2009 15:06'!freeSomeSpace	ColorChart := nil.	Prototype := nil.! !!PartsBin class methodsFor: 'clean up' stamp: 'kph 5/21/2008 00:59'!freeSomeSpace	self clearThumbnailCache! !!Project class methodsFor: 'clean up' stamp: 'mtf 7/25/2008 20:28'!cleanUp	self removeAllButCurrent.! !!ProjectHistory class methodsFor: 'clean up' stamp: 'kph 2/12/2009 15:14'!cleanUp	self currentHistory initialize! !!RequiredSelectors class methodsFor: 'clean up' stamp: 'kph 1/18/2008 11:58'!cleanUp	^ self current ensureClean! !!ScrollBar class methodsFor: 'class initialization' stamp: 'kph 2/12/2009 15:00'!freeSomeSpace	self initializeImagesCache! !!SendCaches class methodsFor: 'clean up' stamp: 'kph 2/12/2009 15:26'!cleanUp	self initializeAllInstances! !!SmalltalkImage methodsFor: 'clean up' stamp: 'kph 12/15/2008 21:50'!cleanUpAll	"this method runs #cleanUp on all classes which implement it	It is intended to reset the image to a clean but non-operational state. i.e	Servers will be stopped, caches flushed etc.		see #freeSpace for 'non-destructive' version"		self cleanUpAllExcept: #()! !!SmalltalkImage methodsFor: 'clean up' stamp: 'kph 12/16/2008 12:39'!cleanUpAllExcept: aListOfClassNames	| exclude |	exclude := aListOfClassNames asSet.	self freeSpace.		self class environment 			select: [ :ea | (exclude includes: ea name) not and: [ ea respondsTo: #cleanUp] ]			thenDo: [ :ea | ea cleanUp ]! !!SmalltalkImage methodsFor: 'clean up' stamp: 'kph 10/17/2007 14:17'!freeSpace	Smalltalk do: [ :class | class askFor: #freeSomeSpace ]! !!SmalltalkImage class methodsFor: 'clean up' stamp: 'kph 1/18/2008 12:11'!cleanUp	Undeclared removeUnreferencedKeys. 	self current fixObsoleteReferences.! !!StandardScriptingSystem class methodsFor: 'clean up' stamp: 'kph 2/12/2009 15:13'!cleanUp	self initialize.	ScriptingSystem deletePrivateGraphics.	ScriptingSystem stripGraphicsForExternalRelease.! !!StandardScriptingSystem class methodsFor: 'clean up' stamp: 'mtf 7/25/2008 13:41'!freeSomeSpace	self removeUnreferencedPlayers! !!Symbol class methodsFor: 'clean up' stamp: 'kph 1/18/2008 12:12'!cleanUp	3 timesRepeat: [		Smalltalk garbageCollect.		Symbol compactSymbolTable.	].! !!SystemDictionary methodsFor: 'class and trait names' stamp: 'kph 5/31/2008 03:31' prior: 31625714!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	DataStream classRemoved: aClass.	self flushClassNameCache! !!SystemDictionary class methodsFor: 'clean up' stamp: 'kph 12/12/2008 02:47'!cleanUp	Smalltalk removeEmptyMessageCategories.	Smalltalk removeNormalCruft.	Smalltalk flushClassNameCache.	! !!SystemOrganizer class methodsFor: 'clean up' stamp: 'kph 2/12/2009 16:03'!cleanUp	SystemOrganization removeEmptyCategories.	Smalltalk forgetDoIts! !!TheWorldMenu class methodsFor: 'clean up' stamp: 'mtf 6/2/2008 09:44'!freeSomeSpace	self removeObsolete! !!Utilities class methodsFor: 'clean up' stamp: 'kph 2/12/2009 15:15'!cleanUp	self zapUpdateDownloader! !!Utilities class methodsFor: 'clean up' stamp: 'kph 10/17/2007 13:50'!freeSomeSpace	"#freeSomeSpace is a new protocol for signalling those methods	which can be used to clean up an image before saving or deployment"	self cleanseOtherworldlySteppers! !!WorldState class methodsFor: 'clean up' stamp: 'kph 12/12/2008 02:58'!cleanUp	WorldState allInstances do: [ :ea | ea clearCommandHistory ].	! !----End fileIn of a stream----!Installer mantis bug: 7244 fix: 'M7244-CleanUps.4.cs'.!----End fileIn of a stream----!!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/21/2009 02:24'!m06980LoadingFFIkernelmakesNetNamInstaller mantis bug: 6980 fix: 'SystemDictionary-recreateSpecialObjectsArray-M6980.st'.""""""Bug ID: 0006980Category: [Squeak] FFISeverity: majorReproducibility: alwaysDate Submitted: 03-13-08 20:51Date Updated: 01-09-09 23:31Reporter: tbnView Status: publicHandler: andreasPriority: normalResolution: openStatus: resolvedProduct Version: 3.9Summary: 0006980: Loading FFI kernel makes NetNameResolver unresponsiveDescription: Image:  Squeak 3.10beta7159 and Squeak 3.9#7067VM:     Squeak 3.10.6 (from Aug 30, 2007) on Win VistaEvaluate:  NetNameResolver addressForName: 'www.squeaksource.com' timeout: 20this returns a ByteArray with the IP.After loading FFI 3.9.1 using Universe Browser the above code does notreturn. (you can only break using cmd-dot)This starts to happen directly after FFI-Kernel-ar-8.mcz is loadedvia install script from source.squeakfoundation.org/FFI(with FFI-Kernel-ar7.mcz leads to the same problem)When loading FFI-Kernel-ar6.mcz it works as expected - the IP is instantly returned. So the problem seems to depend on the change from version 6 to 7.Tested on a Squeak3.9 and Squeak3.10 image (see above)  Additional Information: Notes: (0011918 - 1791 - 2208 - 2208 - 2208 - 2208 - 2208)andreas	03-14-08 01:26How does one recreate that problem? I got stuck when trying to "update list from network" with UPackage>>decodeFromXMLElement: so I can't investigate the problem (stack below).UndefinedObject(Object)>>doesNotUnderstand: #contentsUPackage class>>getXMLPartNamed:from:UPackage class>>decodeFromXMLElement:[] in UPackage class>>decodePackagesFromXMLStream: {[:element | self decodeFromXMLElement: element]}- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -OrderedCollection>>collect:UPackage class>>decodePackagesFromXMLStream:UStandardUniverse>>updatePackagesViaWWW[] in UUniverseBrowser>>requestPackageList {[universe updatePackagesViaWWW]}[] in Utilities class>>informUser:during: {[aBlock value]}MVCMenuMorph>>displayAt:during:Utilities class>>informUser:during:UUniverseBrowser>>requestPackageListPluggableButtonMorph>>performAction[] in PluggableButtonMorph>>mouseUp: {[:m | (m containsPoint: evt cursorPoint) ifTrue: [m performAction]]}Array(SequenceableCollection)>>do:PluggableButtonMorph>>mouseUp:PluggableButtonMorph(Morph)>>handleMouseUp:MouseButtonEvent>>sentTo:PluggableButtonMorph(Morph)>>handleEvent:PluggableButtonMorph(Morph)>>handleFocusEvent:[] in HandMorph>>sendFocusEvent:to:clear: {[ActiveHand := self. ActiveEvent := anEvent. result := focusHolder han...]}[] in PasteUpMorph>>becomeActiveDuring: {[aBlock value]}BlockContext>>on:do:PasteUpMorph>>becomeActiveDuring:HandMorph>>sendFocusEvent:to:clear:HandMorph>>sendEvent:focus:clear:HandMorph>>sendMouseEvent:HandMorph>>handleEvent:HandMorph>>processEvents[] in WorldState>>doOneCycleNowFor: {[:h | ActiveHand := h. h processEvents. capturingGesture := capturingGest...]}Array(SequenceableCollection)>>do:WorldState>>handsDo:(0011919 - 1131 - 1389 - 1785 - 1785 - 1785 - 1785)tbn	03-14-08 07:31Even if the help -> about tells me "Squeak 3.10beta7159" as version it's the gamma package I downloaded.Please try: http://ftp.squeak.org/3.10alpha/Squeak3.10.gamma.7159.zip [^] andmake sure to use the image in a new directory.Steps I've done and that worked to reproduce: 1. World menu "Open" -> "Universe Browser Basic"2. Button "Update list from network"3. Select "System" and "FFI version 3.9.1" in the tree 4. Select "Select package" and "Install selections"If you have a problem with package universe browser again we should open another issue.However, the universe browser points to http://map.squeak.org/accountbyid/cf58c358-46ee-465e-b6db-2740e9b32a53/files/InstallFFI3.st [^]a simple script loading FFI-Kernel-ar-8.mcz first and then other packages.To reproduce you can also just add source.squeakfoundation.org/FFI asHTTP repo to Monticello and load FFI-Kernel-ar-8.mcz manually. After thatthe NetNameResolver addressForName: 'www.squeaksource.com' timeout: 20does not return anymore.If you load FFI-Kernel-ar6.mcz manually it still works as before loading the FFI Kernel.(0011962 - 718 - 932 - 1136 - 1136 - 1136 - 1136)tbn	03-27-08 21:27Andreas commented at http://lists.squeakfoundation.org/pipermail/squeak-dev/2008-March/127208.html [^]Yeah, I had forgotten about the problem. The issue comes from a call to Smalltalk>>recreateSpecialObjectsArray (which is required for the FFI to work correctly) and which accidentally nukes the external semaphore table. The fix is simple: Replace the following line in SystemDictionary>>recreateSpecialObjectsArraynewArray at: 39 put: Array new.by"Preserve external semaphores when recreating splObjs"newArray at: 39 put: (self specialObjectsArray at: 39).Also, saving and restarting the image after loading the FFI is good temporary workaround for this problem.Cheers,- Andreas(0012219 - 112 - 144 - 144 - 144 - 144 - 144)Keith_Hodges	05-29-08 15:43"fix begin"Installer mantis bug: 6980 fix: 'SystemDictionary-recreateSpecialObjectsArray-M6980.st'."fix end"Files: #('SystemDictionary-recreateSpecialObjectsArray-M6980.st')! !'From Squeak3.10beta of 22 July 2007 [latest update: #7159] on 27 March 2008 at 10:28:21 pm'!!SystemDictionary methodsFor: 'special objects' stamp: 'tbn 3/27/2008 22:28' prior: 31716266!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used	by the	Squeak virtual machine. Its contents are critical and	unchecked, so don't even think of playing here unless you	know what you are doing."	| newArray |	newArray := Array new: 50.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray		at: 4		put: (self associationAt: #Processor).	"Numerous classes below used for type checking and	instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray		at: 18		put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	"The process that signaled the low space semaphore."	newArray at: 23 put: nil.	"An array of the 32 selectors that are compiled as special	bytecodes, paired alternately with the number of arguments	each takes."	newArray at: 24 put: #(#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1 #* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1 #at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0 #blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order."	newArray		at: 25		put: ((0 to: 255)				collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have	compact headers"	newArray at: 29 put: self compactClassesArray.	newArray		at: 30		put: (self specialObjectsArray at: 30).	"(delay Semaphore)"	newArray		at: 31		put: (self specialObjectsArray at: 31).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"	newArray		at: 32		put: (Float new: 2).	newArray		at: 33		put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context	prototypes"	newArray		at: 36		put: (self specialObjectsArray at: 36).	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 37 put: nil.	newArray		at: 38		put: (self specialObjectsArray at: 38).	"(BlockContext new: CompiledMethod fullFrameSize)."	"Preserve external semaphores when recreating splObjs"	newArray at: 39 put: (self specialObjectsArray at: 39).	"array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	newArray at: 41 put: TranslatedMethod.	"finalization Semaphore"	newArray		at: 42		put: ((self specialObjectsArray at: 42)				ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	Note: Written so that one can actually completely remove the	FFI."	newArray		at: 44		put: (self				at: #ExternalAddress				ifAbsent: []).	newArray		at: 45		put: (self				at: #ExternalStructure				ifAbsent: []).	newArray		at: 46		put: (self				at: #ExternalData				ifAbsent: []).	newArray		at: 47		put: (self				at: #ExternalFunction				ifAbsent: []).	newArray		at: 48		put: (self				at: #ExternalLibrary				ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"Now replace the interpreter's reference in one atomic	operation"	self specialObjectsArray become: newArray! !----End fileIn of a stream----!Installer mantis bug: 6980 fix: 'SystemDictionary-recreateSpecialObjectsArray-M6980.st'.!----End fileIn of a stream----!!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/21/2009 02:24'!m07131SyntaxErrordialogsraisemoreInstaller mantis bug: 7131 fix: 'SyntaxErrorUsesNonInteractiveParser-M7131.1.cs'.""""""Bug ID: 0007131Category: [Squeak] CompilerSeverity: minorReproducibility: alwaysDate Submitted: 07-22-08 04:33Date Updated: 01-09-09 23:31Reporter: matthewfView Status: publicHandler: Priority: normalResolution: openStatus: resolvedProduct Version: Summary: 0007131: Syntax Error dialogs raise more errors than does the calling ParserDescription: A syntax error dialog is created to fix a very specific error in a non-interactive parser; however, it runs in interactive mode, so it rejects code that the calling parser would have accepted. The syntax error dialog should accept exactly the same code as the calling parser would have - no more, no less.Additional Information: In non-interactive mode, the following errors prompt for user interaction in the form of a SyntaxError dialog:- Syntax errorIn interactive mode, the following errors cause user interaction in the form of pop-ups and text prompts:- Syntax error- Unknown global variable/local variable/selector- Changing some special selectorsNotes: (0012400 - 97 - 97 - 97 - 97 - 97 - 97)matthewf	07-22-08 04:34The attached change set makes SyntaxError dialogs compile in non-interactive mode, fixing the bug(0012401 - 105 - 137 - 137 - 137 - 137 - 137)matthewf	07-22-08 04:36"fix begin"Installer mantis bug: 7131 fix: 'SyntaxErrorUsesNonInteractiveParser-M7131.1.cs'."fix end"Files: #('SyntaxErrorUsesNonInteractiveParser-M7131.1.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-fixed' stamp: 'auto 2/21/2009 02:24'!m07205MonticelloSnapshotSpeedupviaInstaller mantis bug: 7205 fix: 'MethodReference-category-M7205.2.cs'.""""""Bug ID: 0007205Category: [Squeak] MonticelloSeverity: tweakReproducibility: N/ADate Submitted: 10-04-08 17:14Date Updated: 01-09-09 23:31Reporter: matthewfView Status: publicHandler: matthewfPriority: normalResolution: fixedStatus: resolvedProduct Version: Summary: 0007205: Monticello Snapshot Speedup via new MethodReference ivarDescription: Adding the ivar 'category' to methodReference allows a 25% speedup in Monticello snapshotting, after source caching. This capability is exploited as of PackageInfo-Base-mtf.56Additional Information: Notes: (0012717 - 96 - 140 - 140 - 140 - 140 - 140)matthewf	10-04-08 17:21edited on: 10-05-08 04:57	"fix begin"Installer mantis bug: 7205 fix: 'MethodReference-category-M7205.2.cs'."fix end"(0012718 - 60 - 60 - 60 - 60 - 60 - 60)matthewf	10-05-08 04:58oops; the changeset didn't actually have the class def. oopsFiles: #('MethodReference-category-M7205.2.cs' 'MethodReference-category-M7205.1.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/21/2009 02:24'!m07218ClassOrganizercategoriesbreakInstaller mantis bug: 7218 fix: 'EmptyCategoryList-M7218.2.cs'.""""""Bug ID: 0007218Category: [Squeak] KernelSeverity: minorReproducibility: alwaysDate Submitted: 10-26-08 02:01Date Updated: 01-19-09 20:21Reporter: Keith_HodgesView Status: publicHandler: Priority: normalResolution: openStatus: resolvedProduct Version: 3.10.2Summary: 0007218: ClassOrganizer categories breaks if given an empty arrayDescription: ClassOrganizer categories: attempts to ensure that the list of categories matches the existing ones. However if the class has no methods/elements this test fails.So if you call categorizer with an empty array, on a class with no elements/methods the net result is that the data structure is corrupted.categoryStops gets set to #() when it should be at least #(0)Additional Information: Notes: (0012752 - 84 - 116 - 116 - 116 - 116 - 116)Keith_Hodges	10-26-08 02:19"fix begin"Installer mantis bug: 7218 fix: 'Categorizer-categories.st'."fix end"(0012753 - 71 - 71 - 71 - 71 - 71 - 71)Keith_Hodges	10-26-08 02:22SystemEditor was the culprit that calls categories: with an empty array(0012928 - 172 - 216 - 216 - 216 - 216 - 216)matthewf	01-19-09 20:21The previous changeset had an underscore assignment, and so won't load in Croquet"fix begin"Installer mantis bug: 7218 fix: 'EmptyCategoryList-M7218.2.cs'."fix end"Files: #('Categorizer-categories.st' 'EmptyCategoryList-M7218.2.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/21/2009 02:24'!m07166speedupallSelectorsaddallSelInstaller mantis bug: 7166 fix: 'Speedup-AllSelectors-M7166.1.cs'.""""""Bug ID: 0007166Category: [Squeak] KernelSeverity: tweakReproducibility: alwaysDate Submitted: 08-27-08 21:43Date Updated: 01-09-09 23:31Reporter: Keith_HodgesView Status: publicHandler: Priority: normalResolution: openStatus: resolvedProduct Version: 3.10.2Summary: 0007166: speedup allSelectors add allSelectorsBelow:Description: Firstly #allSelectors inefficiently creates multiple intermediate collections. Refactoring this yields a 27% speed improvement. Secondly many users of #allSelectors forget that when applied to the class side it doesnt stop at ProtoObject class, it continues to Class ClassDescription, Behavior, Object and ProtoObject. This is catered for by adding #allSelectorsBelow:Magritte and SUnit are heavy users which benefit.Additional Information: Notes: (0012533 - 88 - 120 - 120 - 120 - 120 - 120)Keith_Hodges	08-27-08 21:44"fix begin"Installer mantis bug: 7166 fix: 'Speedup-AllSelectors-M7166.cs'."fix end"(0012702 - 141 - 141 - 141 - 141 - 141 - 141)Damien Cassou	09-28-08 14:01I've sent that fix to PharoInbox. I replaced 'withAllSuperclasses do:' by 'withAllSuperclassDo:' to avoid the creation of another collection.(0012703 - 283 - 343 - 343 - 343 - 343 - 343)Damien Cassou	09-28-08 14:47I also added the following test:testAllSelectorsself assert: ProtoObject allSelectors = ProtoObject selectors.self assert: Object allSelectors = (Object selectors union: ProtoObject selectors).self assert: (Object allSelectorsBelow: ProtoObject) = (Object selectors).(0012704 - 90 - 122 - 122 - 122 - 122 - 122)Damien Cassou	09-28-08 16:26"fix begin"Installer mantis bug: 7166 fix: 'Speedup-AllSelectors-M7166.1.cs'."fix end"Files: #('Speedup-AllSelectors-M7166.1.cs' 'Speedup-AllSelectors-M7166.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'assigned-open' stamp: 'auto 2/21/2009 02:24'!m07291MC15overridesmethodsinHTTPInstaller mantis bug: 7291 fix: 'MergingMonticello15OverridesOnHTTPSocket-M7291.1.cs'.""""""Bug ID: 0007291Category: [Squeak] NetworkSeverity: minorReproducibility: alwaysDate Submitted: 02-17-09 09:38Date Updated: 02-17-09 11:53Reporter: Damien CassouView Status: publicHandler: Keith_HodgesPriority: normalResolution: openStatus: assignedProduct Version: 3.10.2bcSummary: 0007291: MC1.5 overrides methods in HTTPSocketDescription: In order to add digest and md5 to HTTPSocket class, Monticello1.5-impl overrides different methods. Attached changeset implements the overrides in the base HTTPSocket class thus making the overrides unnecessary.Additional Information: Notes: (0012976 - 110 - 142 - 142 - 142 - 142 - 142)Damien Cassou	02-17-09 09:45"fix begin"Installer mantis bug: 7291 fix: 'MergingMonticello15OverridesOnHTTPSocket-M7291.1.cs'."fix end"(0012978 - 261 - 309 - 309 - 399 - 399 - 399)Damien Cassou	02-17-09 11:53I've just pushed the following commit:Name: Monticello.impl-kph.634Author: kphTime: 17 February 2009, nilUUID: 89183e80-a85c-4d01-8a33-853ee0dc09a1Ancestors: Monticello.impl-kph.631- Removes overrides that are now part of changeset at bug 0007291.Files: #('MergingMonticello15OverridesOnHTTPSocket-M7291.1.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/21/2009 02:24'!m06086CannotuseCrLfFileStreamonInstaller mantis bug: 6086 fix: 'MultiByteFileStream-M6086.2.cs'.""""""Bug ID: 0006086Category: [Squeak] FilesSeverity: minorReproducibility: alwaysDate Submitted: 02-15-07 03:49Date Updated: 01-19-09 20:13Reporter: Keith_HodgesView Status: publicHandler: cdegrootPriority: normalResolution: openStatus: resolvedProduct Version: 3.9Summary: 0006086: Cannot use CrLfFileStream on '/dev/stdout'Description: In the process of #detectLineEndConvention a primitive fails trying to obtain the position of '/dev/stdout'.Additional Information: Notes: (0009824 - 83 - 115 - 115 - 115 - 115 - 115)Keith_Hodges	02-15-07 04:21"fix begin"Installer mantis bug: 6086 fix: 'MultiByteFileStream.1.cs'."fix end"(0009825 - 171 - 183 - 183 - 183 - 183 - 183)Keith_Hodges	02-15-07 04:23MultiByteFileStream.1.csenables user to explicitly specify the lineEndConvention as an argument to #wantsLineEndConversion: doing so bypasses #detectLineEndConvention.(0012927 - 174 - 218 - 218 - 218 - 218 - 218)matthewf	01-19-09 20:13The previous changeset had an underscore assignment, and so won't load in Croquet"fix begin"Installer mantis bug: 6086 fix: 'MultiByteFileStream-M6086.2.cs'."fix end"Files: #('MultiByteFileStream-M6086.2.cs' 'MultiByteFileStream.1.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/21/2009 02:24'!m05851RefactorSmalltalkImagesaveAsInstaller mantis bug: 5851 fix: 'SmalltalkImage-M5851.3.cs'.""""""Bug ID: 0005851Category: [Squeak] KernelSeverity: featureReproducibility: alwaysDate Submitted: 01-29-07 01:58Date Updated: 01-09-09 23:31Reporter: Keith_HodgesView Status: publicHandler: Keith_HodgesPriority: normalResolution: openStatus: resolvedProduct Version: 3.10Summary: 0005851: Refactor SmalltalkImage saveAsDescription: Refactor SmalltalkImage-#saveAs to pull out the code that actually saves the image under a new name, into #saveAs: newNameRefactor some other methods that duplicate the use of the same code, to use #saveAs:Additional Information: Notes: (0009762 - 76 - 76 - 76 - 76 - 76 - 76)Keith_Hodges	02-14-07 12:14SmalltalkImage.2.cs ensures that the resuming flag is returned from #saveAs:(0012290 - 84 - 116 - 116 - 116 - 116 - 116)matthewf	06-10-08 04:35"fix begin"Installer mantis bug: 5851 fix: 'SmalltalkImage-M5851.3.cs'."fix end"(0012291 - 58 - 58 - 58 - 58 - 58 - 58)matthewf	06-10-08 04:35SmalltalkImage-M5851.3.cs removes an underscore assignment(0012851 - 183 - 207 - 207 - 207 - 207 - 207)Keith_Hodges	12-16-08 17:39edited on: 12-16-08 18:52	Currently the code doesnt work if the given filename doesnt have .image on the end, perhaps we should ensure that it does, or append it.Fixed in M5851-SmalltalkImage-saveAs.1.csFiles: #('SmalltalkImage.1.cs' 'SmalltalkImage-M5851.3.cs' 'M5851-SmalltalkImage-saveAs.1.cs' 'SmalltalkImage.2.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-open' stamp: 'auto 2/21/2009 02:24'!m07219ImproveStreamsUsageReadabiliInstaller mantis bug: 7219 fix: 'Stream-Readability.4.cs'.""""""Bug ID: 0007219Category: [Squeak] CollectionsSeverity: featureReproducibility: alwaysDate Submitted: 11-02-08 01:20Date Updated: 01-09-09 23:31Reporter: Keith_HodgesView Status: publicHandler: Keith_HodgesPriority: normalResolution: openStatus: resolvedProduct Version: 3.10.2Summary: 0007219: Improve Streams Usage ReadabilityDescription: For making code gen more readableUsed in Sake/Pacakges and Css generation code for much improved readability.Additional Information: Part of what was Kernel-Extensions for 3.10/LPF. Is now no longer needed for LPF, but is needed for Sake.Notes: (0012758 - 159 - 221 - 221 - 221 - 221 - 221)Keith_Hodges	11-02-08 01:21edited on: 12-12-08 02:17	3 - has methods categorized4 - added ByteArray-putOn: which got away."fix begin"Installer mantis bug: 7219 fix: 'Stream-Readability.4.cs'."fix end"Files: #('Stream-Readability.2.cs' 'Stream-Readability.3.cs' 'Stream-Readability.4.cs' 'Stream-Readability.1.cs')! !!Squeak310MakeBuildCandidate methodsFor: 'resolved-fixed' stamp: 'auto 2/21/2009 02:24'!m07272BlockContextequalitytestismInstaller mantis bug: 7272 fix: 'Block equality testing.1.cs'.""""""Bug ID: 0007272Category: [Squeak] KernelSeverity: minorReproducibility: alwaysDate Submitted: 01-21-09 14:56Date Updated: 01-21-09 15:36Reporter: Keith_HodgesView Status: publicHandler: Keith_HodgesPriority: normalResolution: fixedStatus: resolvedProduct Version: 3.10.2Summary: 0007272: BlockContext equality test is missingDescription: need #= and #hash, which are available in BlockClosureAdditional Information: Notes: (0012932 - 86 - 118 - 118 - 118 - 118 - 118)Keith_Hodges	01-21-09 14:57"fix begin"Installer mantis bug: 7272 fix: 'Block equality testing.1.cs'."fix end"(0012933 - 28 - 28 - 28 - 28 - 28 - 28)Keith_Hodges	01-21-09 14:58Will be included in 3.10.2bcFiles: #('Block equality testing.1.cs')! !PartsBin removeSelector: #listDirection:quadList:buttonClass:!Squeak310MakeBuildCandidate taskBuild run.	!self halt. Preferences setPreference: #logTranscriptToFile toValue: false.!----SNAPSHOT----an Array(21 February 2009 2:24:58 am) 090221-0203_Squeak3.10.2-build.image priorSource: 1846940!----QUIT/NOSAVE----an Array(21 February 2009 2:24:59 am) 090221-0203_Squeak3.10.2-build.image priorSource: 3628499!