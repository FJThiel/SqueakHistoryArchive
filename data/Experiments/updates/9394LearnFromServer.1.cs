'From Squeak3.11alpha of 13 February 2010 [latest update: #9483] on 9 March 2010 at 11:11:24 am'!!SmartRefStream methodsFor: 'class changed shape' stamp: 'edc 7/11/2008 07:37'!writeClassRenameMethod: sel was: oldName fromInstVars: oldList	"The class coming is unknown.  Ask the user for the existing class it maps to.  If got one, write a method, and restart the obj fileIn.  If none, write a dummy method and get the user to complete it later.  "| tell choice  newName answ code |	self flag: #bobconv.	tell := 'Reading an instance of ', oldName, '.Which modern class should it translate to?'.answ := (UIManager default 		chooseFrom: #('Let me type the name now' 'Let me think about it''Let me find this on the server') 		title: tell). answ = 1 ifTrue: [	tell := 'Name of the modern class {1} should translate to:' translated format: {oldName}.	choice := UIManager default request: tell.		"class name"	(choice size = 0) 		ifTrue: [answ := 'conversion method needed']		ifFalse: [newName := choice.			answ := Smalltalk at: newName asSymbol 				ifAbsent: ['conversion method needed'].			answ isString ifFalse: [renamed at: oldName asSymbol put: answ name]]].(answ = 3) | (answ = 0) ifTrue: [self close.		^ Object lookForClass:oldName ].answ = 2 ifTrue: [answ := 'conversion method needed'].answ = 'conversion method needed' ifTrue: [		self close.  		newName := 'PutNewClassHere'].code := WriteStream on: (String new: 500).code nextPutAll: sel; cr.code cr; tab; nextPutAll: '^ ', newName.	"Return new class"self class compile: code contents classified: 'conversion'.newName = 'PutNewClassHere' ifTrue: [	self inform: 'Please complete the following method and then read-in the object file again.'.	SystemNavigation default browseAllImplementorsOf: sel asSymbol]. 	"The class version number only needs to change under one specific circumstance.  That is when the first letters of the instance variables have stayed the same, but their meaning has changed.  A conversion method is needed, but this system does not know it.  	If this is true for class Foo, define classVersion in Foo class.  	Beware of previous object fileouts already written after the change in meaning, but before bumping the version number.  They have the old (wrong) version number, say 2.  If this is true, your method must be able to test the data and successfully read files that say version 2 but are really 3."	^ answ! !!SmartRefStream methodsFor: 'read write' stamp: 'edc 12/30/2009 10:38'!verifyStructure	"Compare the incoming inst var name lists with the existing classes.	Prepare tables that will help to restructure those who need it	(renamed, reshaped, steady). If all superclasses are recorded in the	file, only compare inst vars of this class, not of superclasses. They	will get their turn."	| newClass newList oldList converting |	self flag: #bobconv.	converting := OrderedCollection new.	structures		keysDo: [:nm | 			 Smalltalk						at: nm						ifAbsent: [							Object lookForClass: nm].			"an old className (symbol)"			"For missing classes, there needs to be a method in			SmartRefStream like 			#rectangleoc2 that returns the new class."			newClass := self mapClass: nm.			"does (renamed at: nm put: newClass name)"			newClass isString				ifTrue: [^ newClass].			"error, fileIn needed"			newList := (Array with: newClass classVersion)						, newClass allInstVarNames.			oldList := structures at: nm.			newList = oldList				ifTrue: [steady add: newClass					"read it in as written"]				ifFalse: [converting add: newClass name]].	false & converting isEmpty not		ifTrue: ["debug"			self inform: 'These classes are being converted from existing methods:\' withCRs , converting asArray printString]! !