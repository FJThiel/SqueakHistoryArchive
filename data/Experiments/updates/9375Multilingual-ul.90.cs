'From Squeak3.11alpha of 13 February 2010 [latest update: #9483] on 9 March 2010 at 11:11:24 am'!ImageMorph subclass: #BatMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!BatMorph methodsFor: 'as yet unclassified' stamp: 'edc 8/11/2005 08:22'!stepself center:Sensor peekMousePt.! !!BatMorph methodsFor: 'as yet unclassified' stamp: 'edc 8/11/2005 18:14'!stepTime^30000! !!MCConfiguration methodsFor: 'actions' stamp: 'edc 3/6/2010 11:26'!upgrade	^self depsSatisfying: [:dep | dep isFulfilledByAncestors not]		versionDo: [:ver | 			(Preferences upgradeIsMerge and: [self mustMerge: ver])				ifFalse: [ver load]				ifTrue: [[ver merge]					on: MCMergeResolutionRequest do: [:request |						request merger conflicts isEmpty							ifTrue: [request resume: true]							ifFalse: [request pass]]]]		displayingProgress: 'upgrading packages'! !!MCMcmUpdater class methodsFor: 'updating' stamp: 'edc 3/6/2010 11:05'!updateFromRepositories: repositoryUrls	"MCMcmUpdater updateFromRepositories: #(		'http://squeaksource.com/MCUpdateTest'	)"	| repos config |	Preferences enable: #upgradeIsMerge.	LastUpdateMap ifNil:[LastUpdateMap := Dictionary new].	"The list of repositories to consult in order"	repos := repositoryUrls collect:[:url| 		MCRepositoryGroup default repositories 			detect:[:r| r description = url]			ifNone:[ | r |				r := MCHttpRepository location: url user: '' password: ''.				MCRepositoryGroup default addRepository: r.				r]].	"The list of updates-author.version.mcm sorted by version"	repos do:[:r| r cacheAllFileNamesDuring:[		| minVersion updateList allNames |		updateList := SortedCollection new.		minVersion := LastUpdateMap at: r description ifAbsent:[0].		"Find all the updates-author.version.mcm files"		'Checking ', r description			displayProgressAt: Sensor cursorPoint			from: 0 to: 1 during:[:bar| 				bar value: 0.				allNames := r allFileNames.			].		allNames do:[:versionedName| | version base parts author type |			parts := versionedName findTokens: '.-'.			parts size = 4 ifTrue:[				base := parts at: 1.				author := parts at: 2.				version := [(parts at: 3) asNumber] on: Error do:[:ex| ex return: 0].				type := parts at: 4.			].			(base = 'update' and:[version >= minVersion and:[type = 'mcm']]) 				ifTrue:[updateList add: version -> versionedName]].				"Proceed only if there are updates available at all."		updateList ifNotEmpty: [			"Now process each update file. Check if we have all dependencies and if not,			load the entire configuration (this is mostly to skip older updates quickly)"			updateList do:[:assoc|				ProgressNotification signal: '' extra: 'Processing ', assoc value.				config := r versionFromFileNamed: assoc value.				(config dependencies allSatisfy:[:dep| dep isFulfilled]) 					ifFalse:[config upgrade].				LastUpdateMap at: r description put: assoc key.			] displayingProgress: 'Processing configurations'.			"We've loaded all the provided update configurations.			Use the latest configuration to update all the remaining packages."			config updateFromRepositories.			config upgrade.		]].	].	^config! !!MultiByteFileStream methodsFor: 'fileIn/Out' stamp: 'ul 2/7/2010 04:41'!nextChunkText	"Deliver the next chunk as a Text.  Decode the following ]style[ chunk if present.  Position at start of next real chunk."		^converter nextChunkTextFromStream: self! !