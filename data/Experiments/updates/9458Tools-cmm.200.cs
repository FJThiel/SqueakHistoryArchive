'From Squeak3.11alpha of 13 February 2010 [latest update: #9483] on 9 March 2010 at 11:11:23 am'!CodeHolder subclass: #DependencyBrowser	instanceVariableNames: 'packageList packageDeps classDeps classList messageList packageListIndex packageDepsIndex classDepsIndex classListIndex messageListIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!DependencyBrowser commentStamp: 'ar 3/2/2010 22:19' prior: 0!A simple dependency browser showing five panes:[1]: Packages: The list of available packages in the system.[2]: Package Dependencies: The dependent packages of the currently selected package.[3]: Class Dependencies: The classes causing the dependencies.[4]: Class List: The classes introducing the dependencies.[5]: Messages: The messages introducing the dependencies.!MessageSet subclass: #MessageTrace	instanceVariableNames: 'autoSelectStrings messageSelections anchorIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!MessageTrace commentStamp: 'cmm 3/2/2010 20:26' prior: 0!A MessageTrace is a MessageSet allowing efficient sender/implementor message following.  With implementors indented below, and senders outdended above, message flow is succinctly expressed, hierarchically.My autoSelectStrings and messageSelections are Arrays of Booleans, parallel to my messageList.  Each boolean indicates whether that message is selected.  Each autoSelectStrings indicates which string should be highlighted in the code for each method in my messageList.!!Object methodsFor: '*Tools-MessageSets' stamp: 'cmm 2/19/2010 15:51'!browseAllCallsOn: selectorSymbol	"Models get the first chance to handle this, so a message-tracer can be built..  Not all Tool 'models' inherit from Model, otherwise this would be there."	self systemNavigation browseAllCallsOn: selectorSymbol! !!Object methodsFor: '*Tools-MessageSets' stamp: 'cmm 2/18/2010 21:51'!browseAllImplementorsOf: selectorSymbol	"Models get first chance to handle browseAllImplementorsOf:, so a tracing-messages browser can be built..  Not all Tool 'models' inherit from Model, otherwise this would be there."	self systemNavigation browseAllImplementorsOf: selectorSymbol! !!Model methodsFor: '*Tools' stamp: 'cmm 2/17/2010 22:03'!addItem: classAndMethod	"Make a linked message list and put this method in it"		self flag: #mref.	"classAndMethod is a String"	MessageSet 		parse: classAndMethod  		toClassAndSelector: [ :class :sel | | list |			class ifNil: [^self].			list := OrderedCollection with: (				MethodReference new					setClass: class  					methodSymbol: sel 					stringVersion: classAndMethod			).			ToolSet 				browseMessageSet: list 				name: 'Linked by HyperText'				autoSelect: nil		]! !!CodeHolder methodsFor: 'message list menu' stamp: 'cmm 2/19/2010 15:55'!messageListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also	have a listView that has a list of methods.  The view knows how to get	the list and selection."	| sel class |	aChar == $D ifTrue: [^ self toggleDiffing].	sel := self selectedMessageName.	aChar == $m ifTrue:  "These next two put up a type in if no message selected"		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: self ].	aChar == $n ifTrue: 		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: self ].	"The following require a class selection"	(class := self selectedClassOrMetaClass) ifNil: [^ self arrowKey: aChar from: view].	aChar == $b ifTrue: [^ Browser fullOnClass: class selector: sel].	aChar == $N ifTrue: [^ self browseClassRefs].	aChar == $i ifTrue: [^ self methodHierarchy].	aChar == $h ifTrue: [^ self classHierarchy].	aChar == $p ifTrue: [^ self browseFullProtocol].	"The following require a method selection"	sel ifNotNil: 		[aChar == $o ifTrue: [^ self fileOutMessage].		aChar == $c ifTrue: [^ self copySelector].		aChar == $v ifTrue: [^ self browseVersions].		aChar == $O ifTrue: [^ self openSingleMessageBrowser].		aChar == $x ifTrue: [^ self removeMessage].		aChar == $d ifTrue: [^ self removeMessageFromBrowser].		(aChar == $C and: [self canShowMultipleMessageCategories])			ifTrue: [^ self showHomeCategory]].	^ self arrowKey: aChar from: view! !!CodeHolder methodsFor: 'toolbuilder' stamp: 'laza 3/2/2010 09:20'!addCodeProvenanceButtonTo: panelSpec using: builder	panelSpec children add: (self buildCodeProvenanceButtonWith: builder)! !!CodeHolder methodsFor: 'toolbuilder' stamp: 'laza 3/2/2010 09:20'!buildOptionalButtonsWith: builder	| panelSpec |	panelSpec := builder pluggablePanelSpec new.	panelSpec children: OrderedCollection new.	self optionalButtonPairs do:[:spec|		| buttonSpec |		buttonSpec := builder pluggableActionButtonSpec new.		buttonSpec model: self.		buttonSpec label: spec first.		buttonSpec action: spec second.		spec second == #methodHierarchy ifTrue:[			buttonSpec color: #inheritanceButtonColor.		]. 		spec size > 2 ifTrue:[buttonSpec help: spec third].		panelSpec children add: buttonSpec.	].	"What to show"	self addCodeProvenanceButtonTo: panelSpec using: builder.	panelSpec layout: #horizontal. "buttons"	^panelSpec! !!Browser methodsFor: 'message list' stamp: 'cmm 3/2/2010 16:49'!reformulateList	"If the receiver has a way of reformulating its message list, here is a chance for it to do so"	super reformulateList.	messageListIndex > self messageList size ifTrue: [ self messageListIndex: self messageList size ]! !!ChangeList methodsFor: 'menu actions' stamp: 'cmm 2/17/2010 22:00'!browseCurrentVersionsOfSelections	"Opens a message-list browser on the current in-memory versions of all methods that are currently seleted"	| aList |	aList := OrderedCollection new.	Cursor read showWhile: [		1 to: changeList size do: [:i |			(listSelections at: i) ifTrue: [				| aClass aChange |				aChange := changeList at: i.				(aChange type = #method					and: [(aClass := aChange methodClass) notNil					and: [aClass includesSelector: aChange methodSelector]])						ifTrue: [							aList add: (								MethodReference new									setStandardClass: aClass  									methodSymbol: aChange methodSelector							)						]]]].	aList size == 0 ifTrue: [^ self inform: 'no selected methods have in-memory counterparts'].	ToolSet		browseMessageSet: aList		name: 'Current versions of selected methods in ', file localName		autoSelect: nil! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'cmm 2/17/2010 22:02'!browseMethodConflicts	"Check to see if any other change set also holds changes to any methods in the selected change set; if so, open a browser on all such."	| aList |	aList := myChangeSet 		messageListForChangesWhich: [ :aClass :aSelector |			(ChangesOrganizer allChangeSetsWithClass: aClass selector: aSelector) size > 1		]		ifNone: [^ self inform: 'No other change set has changesfor any method in this change set.'].		ToolSet		browseMessageSet: aList 		name: 'Methods in "', myChangeSet name, '" that are also in other change sets (', aList size printString, ')'		autoSelect: nil! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'laza 3/3/2010 11:16'!findCngSet 	"Search for a changeSet by name.  Pop up a menu of all changeSets whose name contains the string entered by the user.  If only one matches, then the pop-up menu is bypassed"	| index pattern candidates nameList |	self okToChange ifFalse: [^ self].	pattern := UIManager default request: 'ChangeSet name or fragment?'.	pattern isEmpty ifTrue: [^ self].	nameList := self changeSetList asSet.	candidates := ChangeSet allChangeSets select:			[:c | (nameList includes: c name) and: 				[c name includesSubstring: pattern caseSensitive: false]].	candidates size = 0 ifTrue: [^ Beeper beep].	candidates size = 1 ifTrue:		[^ self showChangeSet: candidates first].	index := UIManager default chooseFrom: (candidates collect: [:each | each name]).	index = 0 ifFalse: [self showChangeSet: (candidates at: index)].! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'cmm 2/17/2010 22:02'!methodConflictsWithOtherSide	"Check to see if the change set on the other side shares any methods with the selected change set; if so, open a browser on all such."	| aList other |	self checkThatSidesDiffer: [^ self].	other := (parent other: self) changeSet.	aList := myChangeSet 		messageListForChangesWhich: [ :aClass :aSelector |			aClass notNil and: [(other methodChangesAtClass: aClass name) includesKey: aSelector]		]		ifNone:  [^ self inform: 'There are no methods that appearboth in this change set andin the one on the other side.'].		ToolSet 		browseMessageSet: aList 		name: 'Methods in "', myChangeSet name, '" that are also in ', other name,' (', aList size printString, ')'		autoSelect: nil! !!Debugger methodsFor: 'toolbuilder' stamp: 'laza 3/2/2010 09:22'!addCodeProvenanceButtonTo: panelSpec using: builder	"No thanks!!"! !!DependencyBrowser methodsFor: 'contents' stamp: 'ar 3/2/2010 22:16'!aboutToStyle: aStyler	"This is a notification that aStyler is about to re-style its text.	Set the classOrMetaClass in aStyler, so that identifiers	will be resolved correctly.	Answer true to allow styling to proceed, or false to veto the styling"	| selectedClass |	selectedClass := self classListSelection ifNil:[^false].	aStyler classOrMetaClass: ((self messageListSelection == #Definition) ifFalse:[Smalltalk classNamed: selectedClass]).	^true! !!DependencyBrowser methodsFor: 'contents' stamp: 'ar 3/2/2010 22:13'!selectedMessage	"Source code for currently selected message"	| className methodName mref |	className := self classListSelection.	methodName := self messageListSelection.	mref := (classDeps at: self classDepsSelection ifAbsent:[#()])		detect:[:mr| mr classSymbol = className 						and:[mr methodSymbol = methodName]]		ifNone:[nil].	mref ifNil:[^''].	mref methodSymbol == #Definition ifTrue:[^mref actualClass definition].	^mref sourceCode! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'ar 3/2/2010 21:28'!buildClassDepsWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #classDeps; 		getIndex: #classDepsIndex; 		setIndex: #classDepsIndex:; 		menu: #classDepsMenu:; 		keyPress: #classDepsKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'ar 3/2/2010 21:28'!buildClassListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #classList; 		getIndex: #classListIndex; 		setIndex: #classListIndex:; 		menu: #classListMenu:; 		keyPress: #classListKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'ar 3/2/2010 21:29'!buildMessageListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #messageList; 		getIndex: #messageListIndex; 		setIndex: #messageListIndex:; 		menu: #messageListMenu:; 		keyPress: #messageListKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'ar 3/2/2010 21:28'!buildPackageDepsWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #packageDeps; 		getIndex: #packageDepsIndex; 		setIndex: #packageDepsIndex:; 		menu: #packageDepsMenu:; 		keyPress: #packageDepsKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'ar 3/2/2010 21:27'!buildPackageListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #packageList; 		getIndex: #packageListIndex; 		setIndex: #packageListIndex:; 		menu: #packageListMenu:; 		keyPress: #packageListKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'ar 3/2/2010 21:33'!buildWith: builder	"Create the ui for the browser"	| windowSpec max |	max := self wantsOptionalButtons ifTrue:[0.42] ifFalse:[0.5].	windowSpec := self buildWindowWith: builder specs: {		(0@0 corner: 0.2@max) -> [self buildPackageListWith: builder].		(0.2@0 corner: 0.4@max) -> [self buildPackageDepsWith: builder].		(0.4@0 corner: 0.6@max) -> [self buildClassDepsWith: builder].		(0.6@0 corner: 0.8@max) -> [self buildClassListWith: builder].		(0.8@0 corner: 1.0@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}.	^builder build: windowSpec! !!DependencyBrowser methodsFor: 'class deps' stamp: 'ar 3/2/2010 22:09'!classDeps	"Class dependencies for the currently selected package"	^(packageDeps at: self packageDepsSelection ifAbsent:[#()]) sort! !!DependencyBrowser methodsFor: 'class deps' stamp: 'ar 3/2/2010 22:10'!classDepsIndex	"Class dependency selection"	^classDepsIndex ifNil:[0]! !!DependencyBrowser methodsFor: 'class deps' stamp: 'ar 3/2/2010 22:10'!classDepsIndex: idx	"Class dependency selection"	classDepsIndex := idx.	self classListIndex: 0.	self changed: #classDepsIndex.	self changed: #classList.! !!DependencyBrowser methodsFor: 'class deps' stamp: 'ar 3/2/2010 22:10'!classDepsSelection	"Class dependency selection"	^(self classDepsIndex between: 1 and: self classDeps size)		ifTrue:[self classDeps at: self classDepsIndex].! !!DependencyBrowser methodsFor: 'class list' stamp: 'ar 3/2/2010 22:10'!classList	"List of classes that refer to dependencies"	^((classDeps at: self classDepsSelection ifAbsent:[#()]) 		collect:[:mref| mref classSymbol] as: Set) asArray sort! !!DependencyBrowser methodsFor: 'class list' stamp: 'ar 3/2/2010 22:10'!classListIndex	"Class list selection"	^classListIndex ifNil:[0]! !!DependencyBrowser methodsFor: 'class list' stamp: 'ar 3/2/2010 22:10'!classListIndex: idx	"Class list selection"	classListIndex := idx.	self messageListIndex: 0.	self changed: #classListIndex.	self changed: #messageList.! !!DependencyBrowser methodsFor: 'class list' stamp: 'ar 3/2/2010 22:10'!classListSelection	"Class list selection"	^(self classListIndex between: 1 and: self classList size)		ifTrue:[self classList at: self classListIndex]! !!DependencyBrowser methodsFor: 'package deps' stamp: 'ar 3/2/2010 21:52'!computePackageDependencies: pkgName	"Compute the dependencies for the given package"	| pi |	classDeps := Dictionary new.	packageDeps := Dictionary new.	pkgName ifNil:[^self].	pi := PackageOrganizer default packageNamed: pkgName ifAbsent:[^self]. "unloaded"	pi classes do:[:pkgClass| 		(classDeps at: (pkgClass superclass ifNil:[ProtoObject]) name			ifAbsentPut:[OrderedCollection new]) add: 				(MethodReference class: pkgClass selector: #Definition)].	pi methods do:[:mref| | cm |		cm := mref compiledMethod.		1 to: cm numLiterals do:[:i| | lit |			((lit := cm literalAt: i) isVariableBinding and:[lit value isBehavior]) ifTrue:[				(classDeps at: lit value name ifAbsentPut:[OrderedCollection new])					add: (MethodReference class: cm methodClass selector: cm selector)]]].	classDeps keys do:[:className| | aClass pkg |		aClass := Smalltalk classNamed: className.		pkg := PackageOrganizer default packageOfClass: aClass ifNone:[nil].		pkg ifNil:[			Transcript cr; show: 'WARNING: No package for ', className.			(classDeps removeKey: className) do:[:each| Transcript crtab; show: each].		] ifNotNil:[			(packageDeps at: pkg name ifAbsentPut:[OrderedCollection new]) add: className.		].	].	(packageDeps removeKey: pkgName ifAbsent:[#()]) do:[:each|		classDeps removeKey: each ifAbsent:[].	].! !!DependencyBrowser methodsFor: 'package deps' stamp: 'ar 3/2/2010 22:09'!packageDeps	"Package dependencies for the currently selected package"	packageDeps ifNil:[		packageDeps := Dictionary new.		Cursor wait showWhile:[			self computePackageDependencies: self packageListSelection.		].	].	^packageDeps keys sort! !!DependencyBrowser methodsFor: 'package deps' stamp: 'ar 3/2/2010 22:09'!packageDepsIndex	"Current package dependencies selection"	^packageDepsIndex ifNil:[0]! !!DependencyBrowser methodsFor: 'package deps' stamp: 'ar 3/2/2010 22:09'!packageDepsIndex: aNumber	"Current package dependencies selection"	packageDepsIndex := aNumber.	self classDepsIndex: 0.	self changed: #packageDepsIndex.	self changed: #classDeps.! !!DependencyBrowser methodsFor: 'package deps' stamp: 'ar 3/2/2010 22:09'!packageDepsSelection	"Current package dependencies selection"	^(self packageDepsIndex between: 1 and: self packageDeps size)		ifTrue:[self packageDeps at: self packageDepsIndex]! !!DependencyBrowser methodsFor: 'message list' stamp: 'ar 3/2/2010 22:10'!messageList	"List of messages creating dependencies"	| selectedClass |	selectedClass := self classListSelection.	^((classDeps at: self classDepsSelection ifAbsent:[#()]) 		select:[:each| each classSymbol = selectedClass]		thenCollect:[:mref| mref methodSymbol]) asArray sort! !!DependencyBrowser methodsFor: 'message list' stamp: 'ar 3/2/2010 22:10'!messageListIndex	"Message list selection"	^messageListIndex ifNil:[0]! !!DependencyBrowser methodsFor: 'message list' stamp: 'ar 3/2/2010 22:10'!messageListIndex: idx	"Message list selection"	messageListIndex := idx.	self changed: #messageListIndex.	self changed: #contents.! !!DependencyBrowser methodsFor: 'message list' stamp: 'ar 3/2/2010 22:10'!messageListSelection	"Message list selection"	^(self messageListIndex between: 1 and: self messageList size)		ifTrue:[self messageList at: self messageListIndex]! !!DependencyBrowser methodsFor: 'package list' stamp: 'ar 3/2/2010 22:08'!packageList	"The base list of packages in the system"	^packageList ifNil:[packageList := (MCWorkingCopy allManagers collect:[:each| each packageName]) sort]! !!DependencyBrowser methodsFor: 'package list' stamp: 'ar 3/2/2010 22:08'!packageListIndex	"Current package list selection"	^packageListIndex ifNil:[0]! !!DependencyBrowser methodsFor: 'package list' stamp: 'ar 3/2/2010 22:08'!packageListIndex: aNumber	"Current package list selection"	packageListIndex := aNumber.	self changed: #packageListIndex.	self packageDepsIndex: 0.	packageDeps := nil.	self changed: #packageDeps.! !!DependencyBrowser methodsFor: 'package list' stamp: 'ar 3/2/2010 22:09'!packageListSelection	"Current package list selection"	^(self packageListIndex between: 1 and: self packageList size)		ifTrue:[self packageList at: self packageListIndex]! !!DependencyBrowser class methodsFor: 'opening' stamp: 'ar 3/2/2010 22:19'!open	"DependencyBrowser open"	^ToolBuilder open: self! !!MessageSet methodsFor: 'message functions' stamp: 'cmm 2/18/2010 12:27'!browseAllImplementorsOf: selectorSymbol	self systemNavigation browseAllImplementorsOf: selectorSymbol! !!MessageSet methodsFor: 'message functions' stamp: 'cmm 3/2/2010 16:48'!reformulateList	"The receiver's messageList has been changed; rebuild it"	super reformulateList.	self changed: #messageList.	self changed: #messageListIndex.	self contentsChanged! !!MessageSet methodsFor: 'message list' stamp: 'cmm 2/16/2010 17:37'!addExtraShiftedItemsTo: aMenu	"The shifted selector-list menu is being built.  Add items specific to MessageSet"	self growable ifTrue:		[aMenu addList: #(			-			('remove from this browser'		removeMessageFromBrowser)			('filter message list...'			filterMessageList))].	aMenu 		add: 'sort by date' 		action: #sortByDate! !!MessageSet methodsFor: 'message list' stamp: 'cmm 2/18/2010 22:48'!messageListIndex: anInteger 	"Set the index of the selected item to be anInteger."	messageListIndex := anInteger.	contents := 		messageListIndex ~= 0			ifTrue: [self selectedMessage]			ifFalse: [''].	self changed: #messageListIndex.	 "update my selection"	self editSelection: #editMessage.	self contentsChanged.	(messageListIndex ~= 0 and: [ autoSelectString notNil and: [ self contents notEmpty ] ]) ifTrue: [ self changed: #autoSelect ].	self decorateButtons! !!MessageTrace methodsFor: 'building' stamp: 'cmm 3/2/2010 15:15'!addChildMessages: methodReferences autoSelectString: aString 	| currentIndentionLevel addables selectables selectableString |	selectableString := aString keywords 		ifEmpty: [ String empty ] 		ifNotEmptyDo: [ : keywords | keywords first ].	[ (messageListIndex between: 1 and: autoSelectStrings size) ]		whileFalse:			[ autoSelectStrings add: selectableString ].	autoSelectStrings 		at: messageListIndex		put: selectableString.	currentIndentionLevel := self indentionsIn: self selection asStringOrText.	"Don't add mulitple copies of the same method, if a method is already in the list we will merely select it."	addables := methodReferences reject: [ : each | messageList includes: each ].	addables do: 		[ : each | 		each stringVersion: (self indentionPrefixOfSize: currentIndentionLevel + 1) , each asStringOrText.		messageList 			add: each			afterIndex: self messageListIndex.		autoSelectStrings 			add: nil			afterIndex: self messageListIndex.		messageSelections 			add: false			afterIndex: self messageListIndex ].	selectables := 		addables copy			addAll: (methodReferences select: [ : each | messageList includes: each ]) ;			yourself.	self deselectAll.	selectables do:		[ : each |		self			messageAt: (messageList indexOf: each) 			beSelected: true ].	self changed: #messageList.	"Select the first child method."	self messageListIndex: 		(selectables size > 0			ifTrue: [ messageList indexOf: selectables last ]			ifFalse: [ messageList ifEmpty: [ 0 ] ifNotEmpty: [ 1 ] ])! !!MessageTrace methodsFor: 'building' stamp: 'cmm 2/22/2002 01:22'!addChildMethodsNamed: selectorSymbol	| methodsReferences |	messageListIndex = 0 		ifTrue:			[ ^(PopUpMenu labels: ' OK ')				startUpWithCaption: 'Please reselect a method.' ].	(methodsReferences := self filteredSelectorsNamed: selectorSymbol) isEmpty		ifTrue:			[ ^(PopUpMenu labels: ' OK ')				startUpWithCaption: 'There are no methods named ', selectorSymbol ]		ifFalse:			[ self				addChildMessages: methodsReferences				autoSelectString: selectorSymbol ]! !!MessageTrace methodsFor: 'building' stamp: 'cmm 3/2/2010 15:37'!addParentMessages: methodReferences autoSelectString: aString 	| currentIndentionLevel addables selectables |	addables := methodReferences reject: [ : each | messageList includes: each ].	selectables := addables copy		addAll: (methodReferences select: [ : each | messageList includes: each ]) ;		yourself.	currentIndentionLevel := self indentionsIn: self selection stringVersion.	(currentIndentionLevel = 0 and: [ addables notEmpty ]) ifTrue: 		[ self indentEverything.		currentIndentionLevel := 1 ].	addables do: 		[ : each | 		each stringVersion: (self indentionPrefixOfSize: currentIndentionLevel - 1) , each asStringOrText.		messageList 			add: each			afterIndex: self messageListIndex - 1.		autoSelectStrings 			add: aString			afterIndex: self messageListIndex - 1.		messageSelections 			add: false			afterIndex: self messageListIndex - 1 ].	self deselectAll.	selectables do:		[ : each | | messageIndex |		messageIndex := messageList indexOf: each.		self			messageAt: messageIndex 			beSelected: true.		autoSelectStrings			at: messageIndex			put: aString ].	self changed: #messageList.	selectables size > 0 ifTrue:		[ self messageListIndex: (messageList indexOf: selectables first) ]! !!MessageTrace methodsFor: 'building' stamp: 'cmm 2/19/2010 17:42'!addParentMethodsSending: selectorSymbol	| methodsList |	(methodsList := self filteredSelectorsSending: selectorSymbol) isEmpty		ifTrue:			[ ^(PopUpMenu labels: ' OK ')				startUpWithCaption: 'There are no methods that send ', selectorSymbol ]		ifFalse:			[ self				addParentMessages: methodsList				autoSelectString: selectorSymbol ]! !!MessageTrace methodsFor: 'building' stamp: 'cm 1/9/2002 14:27'!autoSelectString: aString	super autoSelectString: aString.	autoSelectStrings := messageList collect: [ :each | aString ]! !!MessageTrace methodsFor: 'building' stamp: 'cmm 1/30/2002 00:53'!deleteFromMessageList: aMethodReference	"Delete the given message from the receiver's message list"	| index |	autoSelectStrings removeAt: (index := messageList indexOf: aMethodReference).	messageSelections removeAt: index.	super deleteFromMessageList: aMethodReference.	anchorIndex ifNotNil:		[ anchorIndex := anchorIndex min: messageList size ]! !!MessageTrace methodsFor: 'building' stamp: 'cmm 3/2/2010 16:02'!removeMessageFromBrowser	| indexToSelect |	indexToSelect := (messageSelections indexOf: true) max: 1.	self selectedMessages do: [ :eachMethodReference | self deleteFromMessageList: eachMethodReference ].	self deselectAll.	messageSelections ifNotEmpty:		[ messageSelections 			at: (indexToSelect min: messageSelections size)  "safety"			put: true ].	anchorIndex := indexToSelect.	self reformulateList! !!MessageTrace methodsFor: 'actions' stamp: 'cmm 2/19/2010 16:08'!browseAllCallsOn: selectorSymbol	(self hasUnacceptedEdits or: [ Preferences traceMessages not ])		ifTrue: [ super browseAllCallsOn: selectorSymbol ]		ifFalse: [ self addParentMethodsSending: selectorSymbol ]! !!MessageTrace methodsFor: 'actions' stamp: 'cmm 2/19/2010 16:08'!browseAllImplementorsOf: selectorSymbol	| selectorToBrowse |	selectorToBrowse := self selection 		ifNil: [ selectorSymbol ] 		ifNotNil: [ self getImplementorNamed: selectorSymbol ].	(self hasUnacceptedEdits or: [ Preferences traceMessages not ])		ifTrue: [ super browseAllImplementorsOf: selectorToBrowse ]		ifFalse: [ self addChildMethodsNamed: selectorToBrowse ]! !!MessageTrace methodsFor: 'actions' stamp: 'cmm 3/2/2010 15:27'!deselectAll	self messageListIndex: 0.	1 to: messageSelections size do: [ :index | messageSelections at: index put: false ]! !!MessageTrace methodsFor: 'actions' stamp: 'cmm 2/19/2010 16:21'!messageAt: indexInteger beSelected: aBoolean	^ indexInteger isZero ifFalse:		[ messageSelections			at: indexInteger			put: aBoolean ]! !!MessageTrace methodsFor: 'actions' stamp: 'cmm 2/19/2010 17:45'!messageListIndex: anInteger	autoSelectStrings notEmpty ifTrue: 		[ autoSelectString :=			anInteger = 0				ifTrue: [ '' ]				ifFalse:					[ messageListIndex := anInteger.  "setting the window label, below, can't wait for this.."					self containingWindow setLabel: (self windowLabelAt: anInteger).					(autoSelectStrings at: anInteger) ifNotNilDo: [ : fullSelector | fullSelector keywords first ] ] ].	anInteger > 0 ifTrue:		[ self			messageAt: anInteger			beSelected: true ].	super messageListIndex: anInteger! !!MessageTrace methodsFor: 'actions' stamp: 'cmm 3/2/2010 17:01'!removeMessage	"Remove the selected messages from the system."	self selectedMessages size = 0 ifTrue: [ ^self ].	self selectedMessages size = 1 ifTrue: [ ^super removeMessage ].	(self confirm: 'Are you certain you want to remove all of the selected methods from the image?') ifFalse: [ ^self ].	self selectedMessages do:		[ :each | 		each actualClass removeSelector: each methodSymbol.		self deleteFromMessageList: each ]! !!MessageTrace methodsFor: 'actions' stamp: 'cmm 1/22/2002 23:30'!toggleSelectionAt: currentPosition shifted: isShifted controlled: isControlled	currentPosition = 0 ifTrue: [ ^nil ].	isControlled		ifTrue: 			[ isShifted				ifTrue:					[ self selectAllBetweenAnchorAnd: currentPosition ]				ifFalse:					[ self toggleMessageSelectionAt: currentPosition.					anchorIndex := currentPosition ] ]		ifFalse: 			[ self deselectAll.			isShifted				ifTrue:					[ self selectAllBetweenAnchorAnd: currentPosition ]				ifFalse:					[ self 						messageAt: currentPosition						beSelected: true.					anchorIndex := currentPosition ] ].	self messageListIndex: currentPosition! !!MessageTrace methodsFor: 'private initializing' stamp: 'cmm 2/19/2010 15:12'!buildMessageListWith: builder	| listSpec |	listSpec := builder pluggableAlternateMultiSelectionListSpec new.	listSpec 		model: self ;		list: #messageList ;		getIndex: #messageListIndex ;		setIndex: #toggleSelectionAt:shifted:controlled: ;		menu: #messageListMenu:shifted: ; 		getSelectionList: #isMessageSelectedAt: ;		setSelectionList: #messageAt:beSelected: ;		keyPress: #messageListKey:from:.	Preferences browseWithDragNDrop 		ifTrue: [ listSpec dragItem: #dragFromMessageList: ].	^ listSpec! !!MessageTrace methodsFor: 'private initializing' stamp: 'cmm 1/17/2002 22:33'!initialize	super initialize.	messageSelections := OrderedCollection new.	autoSelectStrings := OrderedCollection new! !!MessageTrace methodsFor: 'private initializing' stamp: 'cmm 3/2/2010 14:43'!initializeMessageList: anArray	messageSelections := (Array new: anArray size withAll: false) asOrderedCollection.	super initializeMessageList: anArray.	self 		messageAt: messageListIndex		beSelected: true.	"autoSelectStrings is initialized right after this method, in autoSelectString:"! !!MessageTrace methodsFor: 'private actions' stamp: 'cmm 1/18/2002 15:17'!deselectAllBetweenLastSelectionAnd: indexPosition	| lower higher |	lower := messageListIndex min: indexPosition.	higher := messageListIndex max: indexPosition.	lower = 0 ifTrue: [ ^nil ].	lower to: higher do:		[ :index | messageSelections at: index put: false ]! !!MessageTrace methodsFor: 'private actions' stamp: 'cmm 1/22/2002 16:04'!selectAllBetweenAnchorAnd: indexPosition	| lower higher |	self deselectAllBetweenLastSelectionAnd: indexPosition.	anchorIndex ifNil: [ anchorIndex := indexPosition ].	lower := anchorIndex min: indexPosition.	higher := anchorIndex max: indexPosition.	lower to: higher do:		[ :index | messageSelections at: index put: true ]! !!MessageTrace methodsFor: 'private actions' stamp: 'cmm 1/18/2002 11:28'!selectedMessages	| answer |	answer := OrderedCollection new.	messageSelections withIndexDo:		[ :eachSelection :index |		eachSelection ifTrue: [ answer add: (messageList at: index) ] ].	^answer! !!MessageTrace methodsFor: 'private actions' stamp: 'cmm 1/18/2002 15:19'!toggleMessageSelectionAt: anInteger	messageSelections 		at: anInteger 		put: (messageSelections at: anInteger) not! !!MessageTrace methodsFor: 'filtering' stamp: 'cmm 1/17/2002 22:24'!filterFrom: aBlock	"Filter the receiver's list down to only those items that satisfy aBlock, which takes a class an a selector as its arguments."	| newList newAutoSelectStrings newMessageSelections |	newList := messageList class new.	newAutoSelectStrings := autoSelectStrings class new.	newMessageSelections := messageSelections class new.	messageList withIndexDo:		[ :each :index |		(self class parse: each toClassAndSelector: aBlock)			ifTrue:				[ newList add: each.				newAutoSelectStrings add: (autoSelectStrings at: index).				newMessageSelections add: (messageSelections at: index) ] ].	autoSelectStrings := newAutoSelectStrings.	self setFilteredList: newList.! !!MessageTrace methodsFor: 'filtering' stamp: 'cmm 7/3/2003 12:33'!filteredSelectorsNamed: selectorSymbol	^SystemNavigation new allImplementorsOf: selectorSymbol! !!MessageTrace methodsFor: 'filtering' stamp: 'cmm 3/2/2010 16:12'!filteredSelectorsSending: selectorSymbol	^ self systemNavigation allCallsOn: selectorSymbol! !!MessageTrace methodsFor: 'private accessing' stamp: 'cmm 12/14/2007 13:03'!getImplementorNamed: selectorSymbol	 | allPossibilities |	allPossibilities := (((self selection compiledMethod messages 		select: [ :eachSelector | eachSelector beginsWith: selectorSymbol ])		copyWith: selectorSymbol)		select: [ :each | Symbol hasInterned: each ifTrue: [ :s | ] ])		asSet asSortedCollection asOrderedCollection.	(allPossibilities includes: selectorSymbol) ifTrue:		[ allPossibilities addFirst: (allPossibilities remove: selectorSymbol) ].	^allPossibilities size > 1		ifTrue: 			[ | selectionIndex |			selectionIndex := (PopUpMenu labelArray: allPossibilities lines: #(1))				startUpWithCaption: 					'Browse implementors of					which message?'.			selectionIndex = 0 ifTrue: [ selectorSymbol ] ifFalse: [ allPossibilities at: selectionIndex ] ]		ifFalse: [ allPossibilities isEmpty			ifTrue: [ selectorSymbol ]			ifFalse: [ allPossibilities first ] ]! !!MessageTrace methodsFor: 'private accessing' stamp: 'cm 1/9/2002 17:26'!windowLabelAt: anInteger	| str |	^(str := autoSelectStrings at: anInteger)		ifNil:			[ 'Implementors of ',				(self class					parse: self selection					toClassAndSelector: [ :class :selector | selector ]) ]		ifNotNil:			[ 'Senders of ', str ]! !!MessageTrace methodsFor: 'indenting' stamp: 'cmm 1/13/2002 00:02'!indentEverything	messageList do: [ :each | each stringVersion: (self indentionPrefixOfSize: 1), each stringVersion ]! !!MessageTrace methodsFor: 'indenting' stamp: 'cm 1/8/2002 17:50'!indentionPrefixOfSize: levelInteger	| answer |	answer := String new: levelInteger * self indentionSize.	answer atAllPut: $ . "space"	^answer! !!MessageTrace methodsFor: 'indenting' stamp: 'cm 1/8/2002 17:34'!indentionSize	^2  "that is, 2 spaces.."! !!MessageTrace methodsFor: 'indenting' stamp: 'cm 1/8/2002 17:50'!indentionsIn: aString	aString		withIndexDo: 			[ :eachChar :index | 			eachChar = $  "space" ifFalse: [ ^(index-1) / self indentionSize ] ].	^0! !!MessageTrace methodsFor: 'testing' stamp: 'cmm 3/2/2004 23:40'!isMessageSelectedAt: anInteger	^messageSelections at: anInteger ifAbsent: [ false ]! !!MessageTrace methodsFor: 'accessing' stamp: 'cmm 3/2/2010 15:46'!noteSelectionIndex: anInteger for: aSymbol	aSymbol == #messageList		ifTrue:			[ messageListIndex := anInteger.			self 				messageAt: messageListIndex				beSelected: true ].	super		noteSelectionIndex: anInteger		for: aSymbol! !!MessageTrace class methodsFor: 'initializing' stamp: 'cmm 1/28/2003 22:20'!initialize	self setUpPreferencesPanel! !!MessageTrace class methodsFor: 'initializing' stamp: 'cmm 3/2/2010 20:39'!setUpPreferencesPanel	Preferences		addPreference: #traceMessages		category: #browsing		default: false		balloonHelp: 'If true, browsing senders or implementors in a methods browser will add to the methods in that browser instead of opening a new browser.'! !!StandardToolSet class methodsFor: 'browsing' stamp: 'cmm 3/2/2010 17:23'!browseMessageSet: messageList name: title autoSelect: autoSelectString	"Open a message set or message-trace browser, depending on the #traceMessages setting."	^ Preferences traceMessages		ifTrue:			[ MessageTrace				openMessageList: messageList 				name: title 				autoSelect: autoSelectString ]		ifFalse:			[ MessageSet				openMessageList: messageList 				name: title 				autoSelect: autoSelectString ]! !MessageTrace initialize!MessageSet removeSelector: #augmentMessageList!