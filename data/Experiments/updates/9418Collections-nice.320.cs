'From Squeak3.11alpha of 13 February 2010 [latest update: #9483] on 9 March 2010 at 11:11:23 am'!Stream subclass: #NullStream	instanceVariableNames: 'binary position'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!NullStream commentStamp: 'ar 2/25/2010 14:49' prior: 0!NullStream is a stream generating and consuming an infinite number of elements. It can be used as an equivalent of /dev/null or for performance benchmarks.!Collection subclass: #WeakRegistry	instanceVariableNames: 'valueDictionary accessLock objectsToFinalize '	classVariableNames: 'Default '	poolDictionaries: ''	category: 'Collections-Weak'!!WeakRegistry commentStamp: '<historical>' prior: 0!I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.See also:	Object executor	Object actAsExecutor	Object finalize!!ByteArray methodsFor: 'initialize' stamp: 'nice 2/26/2010 00:04'!readHexFrom: aStream	"Initialize the receiver from a hexadecimal string representation"	| map v ch value |	map := '0123456789abcdefABCDEF'.	1 to: self size do:[:i|		ch := aStream next.		v := (map indexOf: ch) - 1.		((v between: 0 and: 15) or: [((v:= v - 6) between: 0 and: 15)]) ifFalse:[^self error: 'Hex digit expected'].		value := v bitShift: 4.		ch := aStream next.		v := (map indexOf: ch) - 1.		((v between: 0 and: 15) or: [((v:= v - 6) between: 0 and: 15)]) ifFalse:[^self error: 'Hex digit expected'].		value := value + v.		self at: i put: value.	].! !!NullStream methodsFor: 'accessing' stamp: 'ar 2/25/2010 04:18'!ascii	"Switches the stream to ascii mode"	binary := false.! !!NullStream methodsFor: 'accessing' stamp: 'ar 2/25/2010 04:18'!binary	"Switches the stream to binary mode"	binary := true! !!NullStream methodsFor: 'accessing' stamp: 'ar 2/25/2010 04:18'!collectionSpecies	"The type of collection returned by the stream"	^binary ifTrue:[ByteArray] ifFalse:[ByteString]! !!NullStream methodsFor: 'accessing' stamp: 'ar 2/25/2010 03:35'!contents	"Answer all of the contents of the receiver."	self shouldNotImplement! !!NullStream methodsFor: 'accessing' stamp: 'ar 2/25/2010 04:18'!element	"The element returned by the stream"	^binary ifTrue:[0] ifFalse:[Character value: 0]! !!NullStream methodsFor: 'testing' stamp: 'ar 2/25/2010 04:19'!atEnd	"Answer whether the receiver can access any more objects."	^false! !!NullStream methodsFor: 'testing' stamp: 'ar 2/25/2010 04:19'!isBinary	"Return true if the receiver is a binary byte stream"	^binary! !!NullStream methodsFor: 'testing' stamp: 'ar 2/25/2010 04:19'!isEmpty	"Answer whether the receiver's contents has no elements."	^false! !!NullStream methodsFor: 'initialize' stamp: 'ar 2/25/2010 14:45'!initialize	"Initialize the receiver"	binary := false.	position := 0.! !!NullStream methodsFor: 'reading' stamp: 'ar 2/25/2010 14:48'!next	"Answer the next object accessible by the receiver."	position := position +1.	^self element! !!NullStream methodsFor: 'reading' stamp: 'ar 2/25/2010 14:48'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override 	because default uses self contents species, which might involve a large 	collection."	position := position +anInteger.	^self collectionSpecies new: anInteger! !!NullStream methodsFor: 'reading' stamp: 'ar 2/25/2010 04:19'!next: n into: aCollection	"Read n objects into the given collection.	Return aCollection or a partial copy if less than	n elements have been read."	^self next: n into: aCollection startingAt: 1! !!NullStream methodsFor: 'reading' stamp: 'ar 2/25/2010 14:48'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	position := position +n.	^aCollection! !!NullStream methodsFor: 'reading' stamp: 'ar 2/25/2010 04:19'!nextInto: aCollection	"Read the next elements of the receiver into aCollection.	Return aCollection or a partial copy if less than aCollection	size elements have been read."	^self next: aCollection size into: aCollection startingAt: 1.! !!NullStream methodsFor: 'reading' stamp: 'ar 2/25/2010 04:19'!nextInto: aCollection startingAt: startIndex	"Read the next elements of the receiver into aCollection.	Return aCollection or a partial copy if less than aCollection	size elements have been read."	^self next: (aCollection size - startIndex+1) into: aCollection startingAt: startIndex.! !!NullStream methodsFor: 'writing' stamp: 'ar 2/25/2010 04:19'!next: anInteger putAll: aCollection	"Store the next anInteger elements from the given collection."	^self next: anInteger putAll: aCollection startingAt: 1! !!NullStream methodsFor: 'writing' stamp: 'ar 2/25/2010 14:48'!next: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	position := position + anInteger.	^aCollection! !!NullStream methodsFor: 'writing' stamp: 'ar 2/25/2010 14:48'!nextPut: anObject 	"Insert the argument, anObject, as the next object accessible by the 	receiver. Answer anObject."	position := position +1.	^anObject! !!NullStream methodsFor: 'writing' stamp: 'ar 2/25/2010 14:48'!nextPutAll: aCollection 	"Append the elements of aCollection to the sequence of objects accessible 	by the receiver. Answer aCollection."	position := position + aCollection size.	^aCollection! !!NullStream methodsFor: 'writing' stamp: 'ar 2/25/2010 04:20'!peek	"Answer what would be returned if the message next were sent to the 	receiver. If the receiver is at the end, answer nil."	^self element! !!NullStream methodsFor: 'positioning' stamp: 'ar 2/25/2010 14:47'!position	"Answer the current position of accessing the sequence of objects."	^position! !!NullStream methodsFor: 'positioning' stamp: 'ar 2/25/2010 14:47'!position: anInteger 	"Set the current position for accessing the objects to be anInteger, as long 	as anInteger is within the bounds of the receiver's contents. If it is not, 	create an error notification."	(anInteger >= 0)		ifTrue: [position := anInteger]		ifFalse: [self positionError]! !!NullStream methodsFor: 'positioning' stamp: 'ar 2/25/2010 14:47'!reset	"Set the receiver's position to the beginning of the sequence of objects."	position := 0! !!NullStream methodsFor: 'positioning' stamp: 'ar 2/25/2010 14:47'!skip: anInteger 	"Set the receiver's position to be the current position+anInteger. A 	subclass might choose to be more helpful and select the minimum of the 	receiver's size and position+anInteger, or the maximum of 1 and 	position+anInteger for the repositioning."	self position: position + anInteger! !!NullStream class methodsFor: 'instance creation' stamp: 'ar 2/25/2010 04:20'!new	"Creates a new instance"	^self basicNew initialize! !!RunArray class methodsFor: 'instance creation' stamp: 'ar 2/24/2010 18:18'!scanFrom: strm	"Read the style section of a fileOut or sources file.  nextChunk has already been done.  We need to return a RunArray of TextAttributes of various kinds.  These are written by the implementors of writeScanOn:"	| runs values attrList char |	(strm peekFor: $( ) ifFalse: [^ nil].	runs := OrderedCollection new.	[strm skipSeparators.	 strm peekFor: $)] whileFalse: 		[runs add: (Number readFrom: strm)].	values := OrderedCollection new.	"Value array"	attrList := OrderedCollection new.	"Attributes list"	[(char := strm next) == nil] whileFalse: [		char == $, ifTrue: [values add: attrList asArray.  attrList := OrderedCollection new].		char == $a ifTrue: [attrList add: 			(TextAlignment new alignment: (Integer readFrom: strm ifFail: [0]))].		char == $f ifTrue: [attrList add: 			(TextFontChange new fontNumber: (Integer readFrom: strm ifFail: [0]))].		char == $F ifTrue: [attrList add: (TextFontReference toFont: 			(StrikeFont familyName: (strm upTo: $#) size: (Integer readFrom: strm ifFail: [0])))].		char == $b ifTrue: [attrList add: (TextEmphasis bold)].		char == $i ifTrue: [attrList add: (TextEmphasis italic)].		char == $u ifTrue: [attrList add: (TextEmphasis underlined)].		char == $= ifTrue: [attrList add: (TextEmphasis struckOut)].		char == $n ifTrue: [attrList add: (TextEmphasis normal)].		char == $- ifTrue: [attrList add: (TextKern kern: -1)].		char == $+ ifTrue: [attrList add: (TextKern kern: 1)].		char == $c ifTrue: [attrList add: (TextColor scanFrom: strm)]. "color"		char == $L ifTrue: [attrList add: (TextLink scanFrom: strm)].	"L not look like 1"		char == $R ifTrue: [attrList add: (TextURL scanFrom: strm)].				"R capitalized so it can follow a number"		char == $q ifTrue: [attrList add: (TextSqkPageLink scanFrom: strm)].		char == $p ifTrue: [attrList add: (TextSqkProjectLink scanFrom: strm)].		char == $P ifTrue: [attrList add: (TextPrintIt scanFrom: strm)].		char == $d ifTrue: [attrList add: (TextDoIt scanFrom: strm)].		"space, cr do nothing"		].	values add: attrList asArray.	^ self runs: runs asArray values: (values copyFrom: 1 to: runs size) asArray"RunArray scanFrom: (ReadStream on: '(14 50 312)f1,f1b,f1LInteger +;i')"! !!String methodsFor: 'accessing' stamp: 'nice 2/26/2010 00:53'!findAnySubStr: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."	^delimiters inject: 1 + self size into: [:min :delim |		"delim may be a char, a string of length 1, or a substring"		| ind |		ind := delim isCharacter 			ifTrue: [self indexOf: delim						startingAt: start ifAbsent: [min]]			ifFalse: [self indexOfSubCollection: delim 						startingAt: start ifAbsent: [min]].		min min: ind]! !!WeakRegistry methodsFor: 'finalization' stamp: 'ul 2/22/2010 14:23'!finalizeValues	"Some of our elements may have gone away. Look for those and activate the associated executors."		self protected: [ valueDictionary finalizeValues ]! !!WeakRegistry methodsFor: 'copying' stamp: 'ul 2/26/2010 14:54'!postCopy	self protected: [ "Uses the original accessLock"		accessLock := Semaphore forMutualExclusion.		valueDictionary := valueDictionary copy.		valueDictionary associationsDo: [ :each |			each value class == ObjectFinalizerCollection 				ifTrue: [ each value: each value copy ] ].		self installFinalizer ]! !Collection subclass: #WeakRegistry	instanceVariableNames: 'valueDictionary accessLock'	classVariableNames: 'Default'	poolDictionaries: ''	category: 'Collections-Weak'!