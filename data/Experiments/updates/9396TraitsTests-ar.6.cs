'From Squeak3.11alpha of 13 February 2010 [latest update: #9483] on 9 March 2010 at 11:11:23 am'!TestResource subclass: #TraitsResource	instanceVariableNames: 'createdClassesAndTraits t1 t2 t3 t4 t5 t6 c1 c2 c3 c4 c5 c6 c7 c8 dirty'	classVariableNames: 'SetUpCount'	poolDictionaries: ''	category: 'TraitsTests-Kernel'!TestCase subclass: #TraitsTestCase	instanceVariableNames: 'createdClassesAndTraits'	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!TraitsTestCase subclass: #ClassTraitTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!TraitsTestCase subclass: #PureBehaviorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!TraitsTestCase subclass: #TraitCompositionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!TraitsTestCase subclass: #TraitFileOutTest	instanceVariableNames: 'ca cb ta tb tc td'	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!TraitsTestCase subclass: #TraitMethodDescriptionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!TraitsTestCase subclass: #TraitSystemTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!TraitsTestCase subclass: #TraitTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraitsTests-Kernel'!!TraitsResource methodsFor: 'as yet unclassified' stamp: 'dvf 8/30/2005 11:47'!categoryName	^self class category! !!TraitsResource methodsFor: 'as yet unclassified' stamp: 'nice 1/1/2010 21:48'!codeChangedEvent: anEvent	(anEvent isDoIt not		and: [anEvent itemClass notNil		and: [self createdClassesAndTraits includes: anEvent itemClass instanceSide]]) ifTrue: [self setDirty] ! !!TraitsResource methodsFor: 'as yet unclassified' stamp: 'dvf 8/30/2005 11:47'!createClassNamed: aSymbol superclass: aClass uses: aTraitComposition	| class |	class := aClass		subclass: aSymbol		uses: aTraitComposition		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''				category: self categoryName.	self createdClassesAndTraits add: class.	^class! !!TraitsResource methodsFor: 'as yet unclassified' stamp: 'ar 12/31/2009 15:17'!createTraitNamed: aSymbol uses: aTraitComposition	| trait |	trait := Trait		named: aSymbol		uses: aTraitComposition		category: self categoryName		env: Smalltalk.	self createdClassesAndTraits add: trait.	^trait! !!TraitsResource methodsFor: 'as yet unclassified' stamp: 'dvf 8/30/2005 11:47'!createdClassesAndTraits	createdClassesAndTraits ifNil: [		createdClassesAndTraits := OrderedCollection new].	^createdClassesAndTraits! !!TraitsResource methodsFor: 'as yet unclassified' stamp: 'ar 12/31/2009 15:26'!setUp	"Please note, that most tests rely on this setup of traits and	classes - and that especially the order of the definitions matters."	"SetUpCount := SetUpCount + 1."	dirty := false.	SystemChangeNotifier uniqueInstance doSilently: 			[self t1: (self createTraitNamed: #T1						uses: { }).			self t1 comment: 'I am the trait T1'.			self t2: (self createTraitNamed: #T2						uses: { }).			self t2 compile: 'm21 ^21' classified: #cat1.			self t2 compile: 'm22 ^22' classified: #cat2.			self t2 classSide compile: 'm2ClassSide: a ^a'.			self t3: (self createTraitNamed: #T3						uses: { }).			self t3 compile: 'm31 ^31' classified: #cat1.			self t3 compile: 'm32 ^32' classified: #cat2.			self t3 compile: 'm33 ^33' classified: #cat3.			self t4: (self createTraitNamed: #T4						uses: { (self t1). (self t2) }).			self t4 compile: 'm11 ^41' classified: #catX.	"overrides T1>>m11"			self t4 compile: 'm42 ^42' classified: #cat2.			self t5: (self createTraitNamed: #T5 uses: self t1 + self t2).			self t5 compile: 'm51 ^super foo' classified: #cat1.			self t5 compile: 'm52 ^ self class bar' classified: #cat1.			self t5 compile: 'm53 ^ self class bar' classified: #cat1.			self t6: (self createTraitNamed: #T6						uses: (self t1 + self t2) @ { (#m22Alias -> #m22) }).			self c1: (self 						createClassNamed: #C1						superclass: Object						uses: { }).			self c1 compile: 'foo ^true' classified: #accessing.			self t1 compile: 'm11 ^11' classified: #cat1.			self t1 compile: 'm12 ^12' classified: #cat2.			self t1 compile: 'm13 ^self m12' classified: #cat3.			self c2: (self 						createClassNamed: #C2						superclass: self c1						uses: self t5 - { #m11 }).			self c2 compile: 'foo ^false' classified: #private.			self c2 compile: 'bar ^self foo' classified: #private.			self setUpTrivialRequiresFixture.			self setUpTwoLevelRequiresFixture.			self setUpTranslatingRequiresFixture].	SystemChangeNotifier uniqueInstance notify: self ofAllSystemChangesUsing: #codeChangedEvent:! !!TraitsResource methodsFor: 'as yet unclassified' stamp: 'ar 12/31/2009 15:33'!setUpTranslatingRequiresFixture	self c6: (self 				createClassNamed: #C6				superclass: ProtoObject				uses: { }).	ProtoObject removeSubclass: self c6.	self c6 superclass: nil.	self c7: (self 				createClassNamed: #C7				superclass: self c6				uses: { }).	self c8: (self 				createClassNamed: #C8				superclass: self c7				uses: { }).	self c6 compile: 'foo ^self x' classified: #accessing.	self c7 compile: 'foo ^3' classified: #accessing.	self c7 compile: 'bar ^super foo' classified: #accessing.	self c8 compile: 'bar ^self blah' classified: #accessing! !!TraitsResource methodsFor: 'as yet unclassified' stamp: 'ar 12/31/2009 15:33'!setUpTrivialRequiresFixture	self c3: (self 				createClassNamed: #C3				superclass: ProtoObject				uses: { }).	ProtoObject removeSubclass: self c3.	self c3 superclass: nil.	self c3 compile: 'foo ^self bla' classified: #accessing! !!TraitsResource methodsFor: 'as yet unclassified' stamp: 'ar 12/31/2009 15:33'!setUpTwoLevelRequiresFixture	self c4: (self 				createClassNamed: #C4				superclass: ProtoObject				uses: { }).	ProtoObject removeSubclass: self c4.	self c4 superclass: nil.	self c5: (self 				createClassNamed: #C5				superclass: self c4				uses: { }).	self c4 compile: 'foo ^self blew' classified: #accessing.	self c5 compile: 'foo ^self blah' classified: #accessing! !!TraitsResource methodsFor: 'as yet unclassified' stamp: 'nice 1/1/2010 18:00'!tearDown		SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self.	self createdClassesAndTraits do: 			[:aClassOrTrait | | behaviorName | 			behaviorName := aClassOrTrait name.			Smalltalk at: behaviorName				ifPresent: [:classOrTrait | classOrTrait removeFromSystem].			ChangeSet current removeClassChanges: behaviorName].	createdClassesAndTraits := self t1: (self 						t2: (self t3: (self 										t4: (self t5: (self 														t6: (self c1: (self 																		c2: (self c3: (self c4: (self c5: (self c6: (self c7: (self c8: nil)))))))))))))! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c1	^c1! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c1: anObject	^c1 := anObject! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c2	^c2! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c2: anObject	^c2 := anObject! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c3	^c3! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c3: anObject	^c3 := anObject! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c4	^c4! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c4: anObject	^c4 := anObject! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c5	^c5! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c5: anObject	^c5 := anObject! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c6	^c6! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c6: anObject	^c6 := anObject! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c7	^c7! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:00'!c7: anObject	^c7 := anObject! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:01'!c8	^c8! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 14:01'!c8: anObject	^c8 := anObject! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 15:19'!isDirty	^dirty! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 15:19'!setDirty	dirty := true! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 13:58'!t1	^t1! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 13:58'!t1: anObject	^t1 := anObject! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 13:59'!t2	^t2! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 13:59'!t2: anObject	^t2 := anObject! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 13:59'!t3	^t3! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 13:59'!t3: anObject	^t3 := anObject! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 13:59'!t4	^t4! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 13:59'!t4: anObject	^t4 := anObject! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 13:59'!t5	^t5! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 13:59'!t5: anObject	^t5 := anObject! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 13:59'!t6	^t6! !!TraitsResource methodsFor: 'accessing' stamp: 'dvf 8/30/2005 13:59'!t6: anObject	^t6 := anObject! !!TraitsResource class methodsFor: 'as yet unclassified' stamp: 'dvf 8/30/2005 16:57'!resetIfDirty	self current isDirty ifTrue: [self reset]! !!TraitsTestCase methodsFor: 'utility' stamp: 'al 12/16/2003 22:16'!assertPrints: aString like: anotherString 	self assert: (aString copyWithout: $ )		= (anotherString copyWithout: $ )! !!TraitsTestCase methodsFor: 'utility' stamp: 'dvf 8/30/2005 14:44'!createClassNamed: aSymbol superclass: aClass uses: aTraitComposition	| class |	class := aClass		subclass: aSymbol		uses: aTraitComposition		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''				category: self categoryName.	self createdClassesAndTraits add: class.	^class! !!TraitsTestCase methodsFor: 'utility' stamp: 'ar 12/31/2009 15:17'!createTraitNamed: aSymbol uses: aTraitComposition	| trait |	trait := Trait		named: aSymbol		uses: aTraitComposition		category: self categoryName		env: Smalltalk.	self createdClassesAndTraits add: trait.	^trait! !!TraitsTestCase methodsFor: 'utility' stamp: 'dvf 8/30/2005 14:44'!createdClassesAndTraits	createdClassesAndTraits ifNil: [		createdClassesAndTraits := OrderedCollection new].	^createdClassesAndTraits! !!TraitsTestCase methodsFor: 'utility' stamp: 'ar 12/31/2009 15:20'!resourceClassesAndTraits	^TraitsResource current createdClassesAndTraits! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:20'!c1	^TraitsResource current c1! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:21'!c2	^TraitsResource current c2! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:20'!c3	^TraitsResource current c3! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:21'!c4	^TraitsResource current c4! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:21'!c5	^TraitsResource current c5! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:20'!c6	^TraitsResource current c6! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:20'!c7	^TraitsResource current c7! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:20'!c8	^TraitsResource current c8! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:20'!t1	^TraitsResource current t1! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:20'!t2	^TraitsResource current t2! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:20'!t3	^TraitsResource current t3! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:21'!t4	^TraitsResource current t4! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:21'!t5	^TraitsResource current t5! !!TraitsTestCase methodsFor: 'accessing' stamp: 'ar 12/31/2009 15:20'!t6	^TraitsResource current t6! !!TraitsTestCase methodsFor: 'running' stamp: 'al 4/25/2004 16:31'!categoryName	^self class category! !!TraitsTestCase methodsFor: 'running' stamp: 'nice 1/1/2010 18:00'!tearDown		TraitsResource resetIfDirty.	self createdClassesAndTraits do: 			[:aClassOrTrait | | behaviorName | 			behaviorName := aClassOrTrait name.			Smalltalk at: behaviorName				ifPresent: [:classOrTrait | classOrTrait removeFromSystem].			ChangeSet current removeClassChanges: behaviorName].	createdClassesAndTraits := nil! !!ClassTraitTest methodsFor: 'testing' stamp: 'ar 12/20/2009 03:32'!testChanges	"Test the most important features to ensure that	general functionality of class traits are working."	"self run: #testChanges"	| classTrait |	classTrait := self t1 classTrait.	classTrait compile: 'm1ClassSide ^17' classified: 'mycategory'.	"local selectors"	self assert: (classTrait includesLocalSelector: #m1ClassSide).	self deny: (classTrait includesLocalSelector: #otherSelector).	"propagation"	self assert: (self t5 classSide methodDict includesKey: #m1ClassSide).	self assert: (self c2 class methodDict includesKey: #m1ClassSide).	self shouldnt: [self c2 m1ClassSide] raise: Error.	self assert: self c2 m1ClassSide = 17.	"category"	self assert: (self c2 class organization categoryOfElement: #m1ClassSide) 				= 'mycategory'.	"conflicts"	self t2 classSide compile: 'm1ClassSide' classified: 'mycategory'.	self assert: (self c2 class methodDict includesKey: #m1ClassSide).	self deny: (self c2 class includesLocalSelector: #m1ClassSide).	self should: [self c2 m1ClassSide] raise: Error.	"conflict category"	self assert: (self c2 class organization categoryOfElement: #m1ClassSide) 				=  #mycategory! !!ClassTraitTest methodsFor: 'testing' stamp: 'ar 12/31/2009 15:21'!testConflictsAliasesAndExclusions	"conflict"	self t1 classTrait compile: 'm2ClassSide: x ^99' classified: 'mycategory'.	self assert: (self t1 classTrait includesLocalSelector: #m2ClassSide:).	self assert: (self t5 classTrait >> #m2ClassSide:) isConflict.	self assert: (self c2 class >> #m2ClassSide:) isConflict.	"exclusion and alias"	self assert: self t5 classSide traitComposition asString 				= 'T1 classTrait + T2 classTrait'.	self t5 classSide 		uses: (self t1 classTrait @ { (#m2ClassSideAlias1: -> #m2ClassSide:) } 				+ self t2 classTrait) @ { (#m2ClassSideAlias2: -> #m2ClassSide:) } 				- { #m2ClassSide: }.	self deny: (self t5 classTrait >> #m2ClassSide:) isConflict.	self deny: (self c2 class >> #m2ClassSide:) isConflict.	self assert: (self c2 m2ClassSideAlias1: 13) = 99.	self assert: (self c2 m2ClassSideAlias2: 13) = 13! !!ClassTraitTest methodsFor: 'testing' stamp: 'dvf 8/30/2005 16:17'!testInitialization	"self run: #testInitialization"	| classTrait |	classTrait := self t1 classTrait.	self assert: self t1 hasClassTrait.	self assert: self t1 classTrait == classTrait.	self assert: classTrait isClassTrait.	self assert: classTrait classSide == classTrait.	self deny: classTrait isBaseTrait.	self assert: classTrait baseTrait == self t1.	"assert classtrait methods are propagated to users when setting traitComposition"	self assert: self t4 hasClassTrait.	self assert: self t5 hasClassTrait.	self assert: (self t2 classSide includesLocalSelector: #m2ClassSide:).	self assert: (self t4 classSide methodDict includesKey: #m2ClassSide:).	self assert: (self t5 classSide methodDict includesKey: #m2ClassSide:).	self assert: (self c2 m2ClassSide: 17) = 17! !!ClassTraitTest methodsFor: 'testing' stamp: 'ar 12/27/2009 21:49'!testUsers	self assert: self t2 classSide users size = 3.	self assert: (self t2 classSide users includesAllOf: {						(self t4 classTrait).		(self t5 classTrait).		(self t6 classTrait) }).	self assert: self t5 classSide users size = 1.	self assert: self t5 classSide users anyOne = self c2 class.	self c2 uses: self t1 + self t5.	self assert: self t5 classSide users size = 1.	self assert: self t5 classSide users anyOne = self c2 class.	self c2 uses: self t2 asTraitComposition.	self assert: self t5 classSide users isEmpty! !!PureBehaviorTest methodsFor: 'testing-applying trait composition' stamp: 'ar 2/2/2010 14:48'!testChangeSuperclass	"self run: #testChangeSuperclass"	"Test that when the superclass of a class is changed the non-local methods	of the class sending super are recompiled to correctly store the new superclass."	| aC2 newSuperclass |	aC2 := self c2 new.	"C1 is current superclass of C2"	self assert: aC2 m51.	self assert: self c2 superclass == self c1.	self deny: (self c2 localSelectors includes: #m51).	self deny: (self c2 >> #m52) == (self t5 >> #m52). "no sharing!!"	self assert: self c2 traitCompositionString = 'T5 - {#m11}'.	self assert: self c2 selectors sort =  #(bar foo m12 m13 m21 m22 m51 m52 m53).	self assert: self c2 localSelectors sort =  #(bar foo).	"change superclass of C2 from C1 to X"	newSuperclass := self createClassNamed: #X superclass: Object uses: {}.	newSuperclass		subclass: self c2 name		uses: self c2 traitComposition		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self c2 category.	self assert: self c2 superclass == newSuperclass.	newSuperclass compile: 'foo ^17'.	self assert: aC2 m51 = 17.	self deny: (self c2 localSelectors includes: #m51).	self c2 compile: 'm51 ^19'.	self assert: aC2 m51 = 19.	self deny: (self c2 >> #m52) == (self t5 >> #m52). "no sharing!!"	self assert: self c2 traitCompositionString = 'T5 - {#m11}'.	self assert: self c2 selectors sort =  #(bar foo m12 m13 m21 m22 m51 m52 m53).	self assert: self c2 localSelectors sort =  #(bar foo m51).		"change superclass of C2 back to C1"	self c1		subclass: self c2 name		uses: self c2 traitComposition		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self c2 category.	self assert: (aC2 m51 = 19).	self assert: self c2 superclass == self c1.	self assert: (self c2 localSelectors includes: #m51).	self deny: (self c2 >> #m52) == (self t5 >> #m52). "no sharing!!"	self assert: self c2 traitCompositionString = 'T5 - {#m11}'.	self assert: self c2 selectors sort =  #(bar foo m12 m13 m21 m22 m51 m52 m53).	self assert: self c2 localSelectors sort =  #(bar foo m51).! !!PureBehaviorTest methodsFor: 'testing-applying trait composition' stamp: 'ar 12/31/2009 15:30'!testClassesWithTraits	"self debug: #testClassesWithTraits"	self assert: (self c1 methodDict includesKey: #foo).	self assert: (self c2 methodDict includesKey: #bar).	self assert: (self c2 methodDict includesKey: #m51).	self assert: (self c2 methodDict includesKey: #m12).	self assert: (self c2 methodDict includesKey: #m13).	self assert: (self c2 methodDict includesKey: #m21).	self assert: (self c2 methodDict includesKey: #m22).		self deny: self c1 class hasTraitComposition.	self assert: self c2 class hasTraitComposition.	self assert: (self c2 class traitComposition size = 1).	self assert: (self c2 class includesTrait: self t5 classTrait)! !!PureBehaviorTest methodsFor: 'testing-applying trait composition' stamp: 'ar 12/31/2009 15:34'!testOwnMethodsTakePrecedenceOverTraitsMethods	"First create a trait with no subtraits and then	add subtrait t1 which implements m11 as well."	| trait |	trait := self createTraitNamed: #TraitsTestTrait				uses: { }.	trait compile: 'm11 ^999'.	self assert: trait methodDict size = 1.	self assert: (trait methodDict at: #m11) decompileString = 'm11	^ 999'.	self createTraitNamed: #TraitsTestTrait uses: self t1.	self assert: trait methodDict size = 3.	self assert: (trait methodDict keys includesAllOf: #(#m11 #m12 #m13 )).	self assert: (trait methodDict at: #m11) decompileString = 'm11	^ 999'.	self assert: (trait methodDict at: #m12) decompileString = 'm12	^ 12'! !!PureBehaviorTest methodsFor: 'testing-applying trait composition' stamp: 'dvf 8/26/2005 14:32'!testPropagationOfChangesInTraits	| aC2 |	aC2 := self c2 new.	self assert: self c2 methodDict size = 9.	self t1 compile: 'zork ^false'.	self assert: self c2 methodDict size = 10.	self deny: aC2 zork.	self t1 removeSelector: #m12.	self assert: self c2 methodDict size = 9.	self should: [aC2 m12] raise: MessageNotUnderstood.	self assert: aC2 m21 = 21.	self t2 compile: 'm21 ^99'.	self assert: aC2 m21 = 99! !!PureBehaviorTest methodsFor: 'testing-applying trait composition' stamp: 'ar 12/31/2009 15:33'!testPropagationOfChangesInTraitsToAliasMethods	| anObject |	anObject := (self 				createClassNamed: #TraitsTestAliasTestClass				superclass: Object				uses: self t6) new.	self assert: anObject m22Alias = 22.	"test update alias method"	self t2 compile: 'm22 ^17'.	self assert: anObject m22Alias = 17.	"removing original method should also remove alias method"	self t2 removeSelector: #m22.	self should: [anObject m22Alias] raise: MessageNotUnderstood! !!PureBehaviorTest methodsFor: 'testing-applying trait composition' stamp: 'ar 12/31/2009 15:32'!testPropagationOfChangesInTraitsToAliasMethodsWhenOriginalMethodIsExcluded	"Assert that alias method is updated although	the original method is excluded from this user."	| anObject |	anObject := (self 				createClassNamed: #TraitsTestAliasTestClass				superclass: Object				uses: self t1 @ { (#aliasM11 -> #m11) } - { #m11 }) new.	self assert: anObject aliasM11 = 11.	self deny: (anObject class methodDict includesKey: #m11).	self t1 compile: 'm11 ^17'.	self assert: anObject aliasM11 = 17! !!PureBehaviorTest methodsFor: 'testing-applying trait composition' stamp: 'ar 12/31/2009 15:34'!testPropagationWhenTraitCompositionModifications	"Test that the propagation mechanism works when	setting new traitCompositions."	self assert: self c2 methodDict size = 9.	"2 + (3+(3+2))-1"	"removing methods"	self createTraitNamed: #T5		uses: self t1 + self t2 - { #m21. #m22 }.	self assert: self c2 methodDict size = 7.	"adding methods"	self createTraitNamed: #T2 uses: self t3.	self assert: self c2 methodDict size = 10.	self assert: (self c2 methodDict keys includesAllOf: #(#m31 #m32 #m33 ))! !!PureBehaviorTest methodsFor: 'testing-applying trait composition' stamp: 'ar 2/2/2010 11:14'!testReshapeClass	"self run: #testReshapeClass"	"Ensure that reshaping a class has no impact on its traits"	self assert: self c2 traitCompositionString = 'T5 - {#m11}'.	self assert: self c2 selectors sort =  #(bar foo m12 m13 m21 m22 m51 m52 m53).	self assert: self c2 localSelectors sort =  #(bar foo).	self c2 addInstVarName: 'foobar'.	self assert: self c2 traitCompositionString = 'T5 - {#m11}'.	self assert: self c2 selectors sort =  #(bar foo m12 m13 m21 m22 m51 m52 m53).	self assert: self c2 localSelectors sort =  #(bar foo).	self c2 removeInstVarName: 'foobar'.	self assert: self c2 traitCompositionString = 'T5 - {#m11}'.	self assert: self c2 selectors sort =  #(bar foo m12 m13 m21 m22 m51 m52 m53).	self assert: self c2 localSelectors sort =  #(bar foo).! !!PureBehaviorTest methodsFor: 'testing-applying trait composition' stamp: 'dvf 8/26/2005 14:32'!testSuperSends	| aC2 |	aC2 := self c2 new.	self assert: aC2 m51.	self deny: aC2 foo.	self deny: aC2 bar! !!PureBehaviorTest methodsFor: 'testing-applying trait composition' stamp: 'ar 12/27/2009 21:51'!testTraitCompositionModifications	self assert: self t6 methodDict size = 6.	self assert: (self t6 sourceCodeAt: #m22Alias) asString = 'm22Alias ^22'.	self t6 uses: self t2 asTraitComposition.	self assert: self t6 methodDict size = 2.	self deny: (self t6 methodDict includesKey: #m22Alias).	self t6 uses: self t1 @ { (#m13Alias -> #m13) } - { #m11. #m12 } 				+ self t2.	self assert: self t6 methodDict size = 4.	self assert: (self t6 methodDict keys includesAllOf: #(#m13 #m13Alias #m21 #m22 )).	self assert: (self t6 sourceCodeAt: #m13Alias) asString = 'm13Alias ^self m12'! !!PureBehaviorTest methodsFor: 'testing-applying trait composition' stamp: 'ar 12/27/2009 21:51'!testTraitCompositionWithCycles	self should: [self t1 uses: self t1 asTraitComposition]		raise: Error.	self t2 uses: self t3 asTraitComposition.	self should: [self t3 uses: self t5 asTraitComposition]		raise: Error! !!PureBehaviorTest methodsFor: 'testing-applying trait composition' stamp: 'dvf 8/26/2005 14:32'!testUpdateWhenLocalMethodRemoved	| aC2 |	aC2 := self c2 new.	self t5 compile: 'foo ^123'.	self deny: aC2 foo.	self c2 removeSelector: #foo.	self assert: aC2 foo = 123! !!PureBehaviorTest methodsFor: 'testing' stamp: 'ar 12/27/2009 21:49'!testIsAliasSelector	self deny: (self t1 isAliasSelector: #m11).	self deny: (self t1 isAliasSelector: #foo).	"directly"	self assert: (self t6 isAliasSelector: #m22Alias).	self deny: (self t6 isAliasSelector: #m22).	"indirectly"	self c1 uses: self t6.	self assert: (self c1 isAliasSelector: #m22Alias).	self deny: (self c1 isAliasSelector: #m22)! !!PureBehaviorTest methodsFor: 'testing' stamp: 'ar 12/27/2009 21:51'!testIsLocalAliasSelector	self deny: (self t1 isLocalAliasSelector: #m11).	self deny: (self t1 isLocalAliasSelector: #foo).	"directly"	self assert: (self t6 isLocalAliasSelector: #m22Alias).	self deny: (self t6 isLocalAliasSelector: #m22).	"indirectly"	self c1 uses: self t6 asTraitComposition.	self deny: (self c1 isLocalAliasSelector: #m22Alias).	self deny: (self c1 isLocalAliasSelector: #m22)! !!PureBehaviorTest methodsFor: 'testing' stamp: 'dvf 8/26/2005 14:32'!testLocalSelectors	"self run: #testLocalSelectors"	self assert: self t3 localSelectors size = 3.	self assert: (self t3 localSelectors includesAllOf: #(#m31 #m32 #m33 )).	self assert: (self t3 includesLocalSelector: #m32).	self deny: (self t3 includesLocalSelector: #inexistantSelector).	self assert: self t5 localSelectors size = 3.	self assert: (self t5 localSelectors includes: #m51).	self assert: (self t5 includesLocalSelector: #m51).	self deny: (self t5 includesLocalSelector: #m11).	self t5 removeSelector: #m51.	self deny: (self t3 includesLocalSelector: #m51).	self deny: (self t5 includesLocalSelector: #m11).	self assert: self t5 localSelectors size = 2.	self t5 compile: 'm52 ^self'.	self assert: self t5 localSelectors size = 2.	self assert: (self t5 localSelectors includes: #m52).	"test that propagated methods do not get in as local methods"	self t2 compile: 'local2 ^self'.	self deny: (self t5 includesLocalSelector: #local2).	self assert: self t5 localSelectors size = 2.	self assert: (self t5 localSelectors includes: #m52).	self assert: self c2 localSelectors size = 2.	self assert: (self c2 localSelectors includesAllOf: #(#foo #bar ))! !!PureBehaviorTest methodsFor: 'testing' stamp: 'dvf 8/26/2005 14:32'!testMethodCategoryReorganization	"self run: #testMethodCategory"	self t1 compile: 'm1' classified: 'category1'.	self assert: (self t5 organization categoryOfElement: #m1) = #category1.	self assert: (self c2 organization categoryOfElement: #m1) = #category1.	self t1 organization 		classify: #m1		under: #category2		suppressIfDefault: true.	self assert: (self t5 organization categoryOfElement: #m1) = #category2.	self assert: (self c2 organization categoryOfElement: #m1) = #category2! !!PureBehaviorTest methodsFor: 'testing' stamp: 'dvf 8/26/2005 14:32'!testRemovingMethods	"When removing a local method, assure that the method	from the trait is installed instead and that the users are 	updated."	"self run: #testRemovingMethods"	"Classes"	self c2 compile: 'm12 ^0' classified: #xxx.	self assert: (self c2 includesLocalSelector: #m12).	self c2 removeSelector: #m12.	self deny: (self c2 includesLocalSelector: #m12).	self assert: (self c2 selectors includes: #m12).	"Traits"	self t5 compile: 'm12 ^0' classified: #xxx.	self assert: self c2 new m12 = 0.	self t5 removeSelector: #m12.	self deny: (self t5 includesLocalSelector: #m12).	self assert: (self t5 selectors includes: #m12).	self assert: self c2 new m12 = 12! !!PureBehaviorTest methodsFor: 'testing' stamp: 'ar 12/28/2009 00:31'!traitOrClassOfSelector	"self run: #traitOrClassOfSelector"	"locally defined in trait or class"	self assert: (self t1 >> #m12) originalTraitOrClass = self t1.	self assert: (self c1 >> #foo) originalTraitOrClass = self c1.	"not locally defined - simple"	self assert: (self t4 >> #m21) originalTraitOrClass = self t2.	self assert: (self c2 >> #m51) originalTraitOrClass = self t5.	"not locally defined - into nested traits"	self assert: (self c2 >> #m22) originalTraitOrClass = self t2.	"not locally defined - aliases"	self assert: (self t6 >> #m22Alias) originalTraitOrClass = self t2.	"class side"	self assert: (self t2 classSide >> #m2ClassSide:) originalTraitOrClass				= self t2 classSide.	self assert: (self t6 classSide >> #m2ClassSide:) originalTraitOrClass				= self t2 classSide! !!TraitCompositionTest methodsFor: 'testing-basic' stamp: 'ar 12/31/2009 15:18'!testAliasCompositions	"unary"	self 		shouldnt: [self t2 uses: self t1 @ { (#aliasM11 -> #m11) }]		raise: TraitCompositionException.	self 		should: [self t2 uses: self t1 @ { (#alias: -> #m11) }]		raise: TraitCompositionException.	self 		should: [self t2 uses: self t1 @ { (#alias:x:y: -> #m11) }]		raise: TraitCompositionException.	"binary"	self t1 compile: '= anObject'.	self 		shouldnt: [self t2 uses: self t1 @ { (#equals: -> #=) }]		raise: TraitCompositionException.	self shouldnt: [self t2 uses: self t1 @ { (#% -> #=) }]		raise: TraitCompositionException.	self 		should: [self t2 uses: self t1 @ { (#equals -> #=) }]		raise: TraitCompositionException.	self 		should: [self t2 uses: self t1 @ { (#equals:x: -> #=) }]		raise: TraitCompositionException.	"keyword"	self t1 compile: 'x: a y: b z: c'.	self 		should: [self t2 uses: self t1 @ { (#'==' -> #x:y:z:) }]		raise: TraitCompositionException.	self 		should: [self t2 uses: self t1 @ { (#x -> #x:y:z:) }]		raise: TraitCompositionException.	self 		should: [self t2 uses: self t1 @ { (#x: -> #x:y:z:) }]		raise: TraitCompositionException.	self 		should: [self t2 uses: self t1 @ { (#x:y: -> #x:y:z:) }]		raise: TraitCompositionException.	self shouldnt: 			[self t2 uses: self t1 @ { (#myX:y:z: -> #x:y:z:) }]		raise: TraitCompositionException.	"alias same as selector"	self 		should: [self t2 uses: self t1 @ { (#m11 -> #m11) }]		raise: TraitCompositionException.	"same alias name used twice"	self should: 			[self t2 				uses: self t1 @ { (#alias -> #m11). (#alias -> #m12) }]		raise: TraitCompositionException.	"aliasing an alias"	self should: 			[self t2 				uses: self t1 @ { (#alias -> #m11). (#alias2 -> #alias) }]		raise: TraitCompositionException! !!TraitCompositionTest methodsFor: 'testing-basic' stamp: 'ar 12/31/2009 15:18'!testCompositionFromArray	| composition |	composition := TraitComposition withAll: { (self t1) }.	self assert: (composition isKindOf: TraitComposition).	self assert: (composition traits includes: self t1).	self assert: composition traits size = 1.	composition := TraitComposition withAll: { (self t1). self t2 }.	self assert: (composition isKindOf: TraitComposition).	self assert: (composition traits includes: self t1).	self assert: (composition traits includes: self t2).	self assert: composition traits size = 2! !!TraitCompositionTest methodsFor: 'testing-basic' stamp: 'ar 12/31/2009 15:18'!testEmptyTrait	| composition |	composition := TraitComposition withAll: {}.		self assert: (composition isKindOf: TraitComposition)."	self assert: composition transformations isEmpty.	"	self assert: composition traits isEmpty! !!TraitCompositionTest methodsFor: 'testing-basic' stamp: 'ar 12/31/2009 15:18'!testInvalidComposition	self shouldnt: [self t1 @ { (#a -> #b) } @ { (#x -> #y) }]		raise: TraitCompositionException.	self shouldnt: [(self t1 + self t2) @ { (#a -> #b) } @ { (#x -> #y) }]		raise: TraitCompositionException.	self shouldnt: [self t1 - { #a } - { #b }] raise: TraitCompositionException.	self shouldnt: [self t1 + self t2 - { #a } - { #b }]		raise: TraitCompositionException.	self should: [(self t1 - { #x }) @ { (#a -> #b) }]		raise: TraitCompositionException.	self should: [(self t1 + self t2 - { #x }) @ { (#a -> #b) }]		raise: TraitCompositionException.	self should: [self t1 + self t1] raise: TraitCompositionException.	self should: [(self t1 + self t2) @ { (#a -> #b) } + self t1]		raise: TraitCompositionException.	self should: [self t1 @ { (#a -> #m11). (#a -> #m12) }]		raise: TraitCompositionException.	self should: [self t1 @ { (#a -> #m11). (#b -> #a) }]		raise: TraitCompositionException! !!TraitCompositionTest methodsFor: 'testing-basic' stamp: 'ar 12/31/2009 15:21'!testPrinting	| composition1 composition2 |	composition1 := ((self t1 - { #a } + self t2) @ { (#z -> #c) } - { #b. #c } 				+ self t3 - { #d. #e } 				+ self t4) @ { (#x -> #a). (#y -> #b) }.	composition2 := self t4 @ { (#x -> #a). (#y -> #b) } + self t1 - { #a } 				+ self t3 - { #d. #e } 				+ self t2 - { #b. #c }.	self assertPrints: composition1 printString		like: 'T1 - {#a} + T2 @ {#z->#c} - {#b. #c} + T3 - {#d. #e} + T4 @ {#x->#a. #y->#b}'.	self assertPrints: composition2 printString		like: 'T4 @ {#x->#a. #y->#b} + T1 - {#a} + T3 - {#d. #e} + T2 - {#b. #c}'! !!TraitCompositionTest methodsFor: 'testing-basic' stamp: 'ar 12/31/2009 15:18'!testSum	| composition |	composition := self t1 + self t2 + self t3.	self assert: (composition isKindOf: TraitComposition).	self assert: (composition traits includes: self t1).	self assert: (composition traits includes: self t2).	self assert: (composition traits includes: self t3).	self assert: composition traits size = 3! !!TraitCompositionTest methodsFor: 'testing-basic' stamp: 'ar 12/31/2009 15:18'!testSumWithParenthesis	| composition |	composition := self t1 + (self t2 + self t3).	self assert: (composition isKindOf: TraitComposition).	self assert: (composition traits includes: self t1).	self assert: (composition traits includes: self t2).	self assert: (composition traits includes: self t3).	self assert: composition traits size = 3.	self assert: composition size = 3! !!TraitCompositionTest methodsFor: 'testing-enquiries' stamp: 'dvf 8/26/2005 14:31'!testClassMethodsTakePrecedenceOverTraitsMethods	| keys |	keys := Set new.	self t4 methodDict bindingsDo: [:each | keys add: each key].	self assert: keys size = 6.	self 		assert: (keys includesAllOf: #(						#m12						#m13						#m13						#m21						#m22						#m11						#m42					)).	self assert: (self t4 methodDict at: #m11) decompileString = 'm11	^ 41'! !!TraitCompositionTest methodsFor: 'testing-enquiries' stamp: 'ar 12/31/2009 15:34'!testProvidedMethodBindingsWithConflicts	| traitWithConflict methodDict |	traitWithConflict := self createTraitNamed: #TraitsTestTraitWithConflict				uses: self t1 + self t4.	methodDict := traitWithConflict methodDict.	self assert: methodDict size = 6.	self 		assert: (methodDict keys includesAllOf: #(						#m11						#m12						#m13						#m21						#m22						#m42					)).	self 		assert: (methodDict at: #m11) decompileString = 'm11	^ self traitConflict'! !!TraitFileOutTest methodsFor: 'running' stamp: 'ar 12/31/2009 15:55'!categoryName	^'TraitsTests-FileOut'! !!TraitFileOutTest methodsFor: 'running' stamp: 'ar 12/31/2009 15:31'!setUp	super setUp.	SystemOrganization addCategory: self categoryName.		td := self createTraitNamed: #TD uses: {}.			td compile: 'd' classified: #cat1.	tc := self createTraitNamed: #TC uses: td.			tc compile: 'c' classified: #cat1.	tb := self createTraitNamed: #TB uses: td.			tb compile: 'b' classified: #cat1.	ta := self createTraitNamed: #TA uses: tb + tc @ {#cc->#c} - {#c}.	ta compile: 'a' classified: #cat1.		ca := self createClassNamed: #CA superclass: Object uses: {}.	ca compile: 'ca' classified: #cat1.	cb := self createClassNamed: #CB superclass: ca uses: ta.	cb compile: 'cb' classified: #cat1.		"make the class of cb also use tc:"	cb class uses: ta classTrait + tc instanceVariableNames: ''.! !!TraitFileOutTest methodsFor: 'running' stamp: 'dvf 8/30/2005 15:07'!tearDown	| dir |	dir := FileDirectory default.	self createdClassesAndTraits, self resourceClassesAndTraits  do: [:each |		dir deleteFileNamed: each asString , '.st' ifAbsent: []].	dir deleteFileNamed: self categoryName , '.st' ifAbsent: [].	SystemOrganization removeSystemCategory: self categoryName.	super tearDown! !!TraitFileOutTest methodsFor: 'testing' stamp: 'ar 12/31/2009 15:17'!fileIn: fileName	| prior file result |	prior := ClassDescription traitImpl.	[		ClassDescription traitImpl: Trait.		file := FileStream readOnlyFileNamed: fileName.		result := file fileIn	] ensure: [		file ifNotNil:[file close].		ClassDescription traitImpl: prior.	].	^result! !!TraitFileOutTest methodsFor: 'testing' stamp: 'ar 3/5/2010 20:43'!testFileOutCategory	"File out whole system category, delete all classes and traits and then	file them in again."	"self run: #testFileOutCategory"	| |	SystemOrganization fileOutCategory: self categoryName.	SystemOrganization removeSystemCategory: self categoryName.	self deny: (Smalltalk globals keys includesAnyOf: #(CA CB TA TB TC TD)).		self fileIn: self categoryName , '.st'..	self assert: (Smalltalk globals keys includesAllOf: #(CA CB TA TB TC TD)).	ta := Smalltalk at: #TA.	self assert: (ta isKindOf: Trait).	self assert: ta traitComposition asString = 'TB + TC @ {#cc->#c} - {#c}'.	self assert: (ta methodDict keys includesAllOf: #(a b cc)).	cb := Smalltalk at: #CB.	self assert: (cb isKindOf: Class).	self assert: cb traitComposition asString = 'TA'.	self assert: (cb methodDict keys includesAllOf: #(cb a b cc)).	"test classSide traitComposition of CB"	self assert: cb classSide traitComposition asString =  'TA classTrait + TC'.	self assert: (cb classSide methodDict keys includesAllOf: #(d c))! !!TraitFileOutTest methodsFor: 'testing' stamp: 'ar 12/31/2009 15:22'!testFileOutTrait	"fileOut trait T6, remove it from system and then file it in again"	"self run: #testFileOutTrait"	| fileName |	self t6 compile: 'localMethod: argument ^argument'.	self t6 classSide compile: 'localClassSideMethod: argument ^argument'.	self t6 fileOut.	fileName := self t6 asString , '.st'.	self resourceClassesAndTraits remove: self t6.	self t6 removeFromSystem.		self fileIn: fileName.	self assert: (Smalltalk includesKey: #T6).	TraitsResource current t6: (Smalltalk at: #T6).	self resourceClassesAndTraits add: self t6.	self assert: (self t6 isKindOf: Trait).	self assert: self t6 traitComposition asString = 'T1 + T2 @ {#m22Alias->#m22}'.	self assert: (self t6 methodDict keys includesAllOf: #(						#localMethod:						#m11						#m12						#m13						#m21						#m22						#m22Alias					)).	self assert: self t6 classSide methodDict size = 2.	self assert: (self t6 classSide methodDict keys includesAllOf: #(#localClassSideMethod: #m2ClassSide: ))! !!TraitFileOutTest methodsFor: 'testing' stamp: 'dvf 8/26/2005 14:32'!testRemovingMethods	"When removing a local method, assure that the method	from the trait is installed instead and that the users are 	updated."	"self run: #testRemovingMethods"	"Classes"	self c2 compile: 'm12 ^0' classified: #xxx.	self assert: (self c2 includesLocalSelector: #m12).	self c2 removeSelector: #m12.	self deny: (self c2 includesLocalSelector: #m12).	self assert: (self c2 selectors includes: #m12).	"Traits"	self t5 compile: 'm12 ^0' classified: #xxx.	self assert: self c2 new m12 = 0.	self t5 removeSelector: #m12.	self deny: (self t5 includesLocalSelector: #m12).	self assert: (self t5 selectors includes: #m12).	self assert: self c2 new m12 = 12! !!TraitMethodDescriptionTest methodsFor: 'running' stamp: 'ar 12/20/2009 02:41'!testArgumentNames	self t1 compile: 'zork1: myArgument zork2: mySecondArgument ^true'.	self t2 compile: 'zork1: myArgument zork2: somethingElse ^false'.	self assert: ((self t5 sourceCodeAt: #zork1:zork2:) asString 				beginsWith: 'zork1: arg1 zork2: arg2').	self t1 compile: 'zork1: myArgument zork2: mySecondArgument ^true'.	self t2 compile: 'zork1: somethingElse zork2: myArgument ^false'.	self assert: ((self t5 sourceCodeAt: #zork1:zork2:) asString 				beginsWith: 'zork1: arg1 zork2: arg2')! !!TraitMethodDescriptionTest methodsFor: 'running' stamp: 'ar 12/20/2009 03:39'!testCategories	self assert: (self t4 organization categoryOfElement: #m21) = #cat1.	self assert: (self t4 organization categoryOfElement: #m22) = #cat2.	self assert: (self t4 organization categoryOfElement: #m11) = #catX.	self assert: (self t4 organization categoryOfElement: #m12) = #cat2.	self assert: (self t4 organization categoryOfElement: #m13) = #cat3.	self assert: (self t6 organization categoryOfElement: #m22Alias) = #cat2.	self t2 organization classify: #m22 under: #catX.	self assert: (self t4 organization categoryOfElement: #m22) = #catX.	self assert: (self t6 organization categoryOfElement: #m22Alias) = #catX.	self t6 organization classify: #m22 under: #catY.	self t6 organization classify: #m22Alias under: #catY.	self t2 organization classify: #m22 under: #catZ.	"XXX: The following test is commented out for now. The policy is to *always*	reclassify the method if the base method is reclassified. That results from	the requirement that the base construction should always be repeatable	(in fact, one could argue that reclassification of methods from traits is	invalid without some explicit transformation)."false ifTrue:[	self assert: (self t6 organization categoryOfElement: #m22) = #catY.	self assert: (self t6 organization categoryOfElement: #m22Alias) = #catY.].	self t1 compile: 'mA' classified: #catA.	self assert: (self t4 organization categoryOfElement: #mA) = #catA.	self t1 organization classify: #mA under: #cat1.	self assert: (self t4 organization categories includes: #catA) not! !!TraitMethodDescriptionTest methodsFor: 'running' stamp: 'ar 12/20/2009 02:46'!testConflictMethodCreation	"Generate conflicting methods between t1 and t2	and check the resulting method in Trait t5 (or c2).	Also test selectors like foo:x (without space) or selectors with CRs."	"unary"	self t2 compile: 'm12 ^false'.	self assert: ((self t5 sourceCodeAt: #m12) asString beginsWith: 'm12').	self should: [self c2 new m12] raise: Error.	"binary"	self t1 compile: '@ myArgument ^true'.	self t2 compile: '@myArgument ^false'.	self 		assert: ((self t5 sourceCodeAt: #@) asString beginsWith: '@ arg1').	self should: [self c2 new @ 17] raise: Error.	"keyword"	self t1 compile: 'zork: myArgument		^true'.	self t2 compile: 'zork: myArgument ^false'.	self assert: ((self t5 sourceCodeAt: #zork:) asString 				beginsWith: 'zork: arg1').	self should: [self c2 new zork: 17] raise: Error.	self t1 compile: 'zork:myArgument ^true'.	self t2 compile: 'zork:myArgument ^false'.	self assert: ((self t5 sourceCodeAt: #zork:) asString 				beginsWith: 'zork: arg1').	self should: [self c2 new zork: 17] raise: Error.	self t1 compile: 'zork1: myArgument zork2: mySecondArgument ^true'.	self t2 compile: 'zork1: anObject zork2: anotherObject ^false'.	self assert: ((self t5 sourceCodeAt: #zork1:zork2:) asString 				beginsWith: 'zork1: arg1 zork2: arg2').	self should: [self c2 new zork1: 1 zork2: 2] raise: Error! !!TraitMethodDescriptionTest methodsFor: 'running' stamp: 'ar 12/31/2009 15:34'!testConflictingCategories	| t7 t8 |	self t2 compile: 'm11' classified: #catY.	self assert: (self t4 organization categoryOfElement: #m11) = #catX.	self assert: (self t5 organization categoryOfElement: #m11) =  #'conflict methods'. "was: #cat1"	t7 := self createTraitNamed: #T7 uses: self t1 + self t2.	self assert: (t7 organization categoryOfElement: #m11) 				=  #'conflict methods'. "was: ClassOrganizer ambiguous"	self t1 removeSelector: #m11.	self assert: (self t4 organization categoryOfElement: #m11) = #catX.	self assert: (self t5 organization categoryOfElement: #m11) = #catY.	self assert: (t7 organization categoryOfElement: #m11) = #catY.	self deny: (t7 organization categories includes: #'conflict methods' "was: ClassOrganizer ambiguous").	self t1 compile: 'm11' classified: #cat1.	t8 := self createTraitNamed: #T8 uses: self t1 + self t2.	t8 organization classify: #m11 under: #cat1.	self t1 organization classify: #m11 under: #catZ.	self assert: (self t4 organization categoryOfElement: #m11) = #catX.	self assert: (self t5 organization categoryOfElement: #m11) =  #'conflict methods'. "was: #catY"	self assert: (t8 organization categoryOfElement: #m11) =  #'conflict methods'. "was: #catZ"! !!TraitSystemTest methodsFor: 'testing' stamp: 'al 4/9/2006 15:22'!testAllClassesAndTraits	"self debug: #testAllClassesAndTraits"		| trait |	trait := self t1.	self assert: (Smalltalk allClassesAndTraits includes: trait).	self deny: (Smalltalk allClasses includes: trait).	! !!TraitSystemTest methodsFor: 'testing' stamp: 'al 1/13/2006 12:27'!testAllImplementedMessagesWithout	"self debug: #testAllImplementedMessagesWithout"	self t6 compile: 'das2qwdqwd'.	self assert: (SystemNavigation default allImplementedMessages includes: #das2qwdqwd).	self deny: (SystemNavigation default allImplementedMessages includes: #qwdqwdqwdc).! !!TraitSystemTest methodsFor: 'testing' stamp: 'al 1/13/2006 11:49'!testAllSentMessages	"self debug: #testAllSentMessages"	self t1 compile: 'foo 1 dasoia'.	self assert: (SystemNavigation default allSentMessages includes: 'dasoia' asSymbol).	self deny: (SystemNavigation default allSentMessages includes: 'nioaosi' asSymbol).! !!TraitTest methodsFor: 'testing' stamp: 'dvf 8/26/2005 14:32'!testAddAndRemoveMethodsFromSubtraits	| aC2 |	aC2 := self c2 new.	self assert: aC2 m51.	self t5 removeSelector: #m51.	self should: [aC2 m51] raise: MessageNotUnderstood.	self t1 compile: 'foo ^true'.	self deny: aC2 foo.	self t1 compile: 'm51 ^self'.	self shouldnt: [aC2 m51] raise: MessageNotUnderstood.	self assert: aC2 m51 == aC2! !!TraitTest methodsFor: 'testing' stamp: 'dvf 8/26/2005 14:32'!testAddAndRemoveMethodsInClassOrTrait	| aC2 |	aC2 := self c2 new.	self assert: aC2 m51.	self c2 compile: 'm51 ^123'.	self assert: aC2 m51 = 123.	self c2 removeSelector: #m51.	self shouldnt: [aC2 m51] raise: MessageNotUnderstood.	self assert: aC2 m51.	self t4 removeSelector: #m11.	self assert: (self t4 methodDict includesKey: #m11)! !!TraitTest methodsFor: 'testing' stamp: 'ms 5/8/2007 19:23'!testAllClassVarNames			self assert: self t1 allClassVarNames isEmpty! !!TraitTest methodsFor: 'testing' stamp: 'ul 1/11/2010 08:12'!testCompositionCopy	| t6compositionCopyFirst c2compositionCopy |	self assert: (self t1 + self t2) allTraits 				= (self t1 + self t2) copyTraitExpression allTraits.	self assert: (self t1 classTrait + self t2 classTrait) allTraits 				= (self t1 classTrait + self t2 classTrait) copyTraitExpression allTraits.	self assert: self t6 traitComposition allTraits 				= self t6 traitComposition copyTraitExpression allTraits.	self 		assert: self t6 asTraitComposition copyTraitExpression allTraits = { (self t1). (self t2). (self t6) }.	"make no undue sharing happens of exclusions and aliases after an expression copy"	t6compositionCopyFirst := self t6 traitComposition copyTraitExpression.	t6compositionCopyFirst at: 1 put: #m22Alias -> #m33.	self 		assert: self t6 traitComposition second aliases first value 				= #m22.	c2compositionCopy := self c2 traitComposition copyTraitExpression.	c2compositionCopy first exclusions add: #m4.	self assert: self c2 traitComposition first exclusions = #(#m11) asSet.! !!TraitTest methodsFor: 'testing' stamp: 'ar 12/20/2009 02:47'!testExplicitRequirement	"self run: #testExplicitRequirement"	self t1 compile: 'm self explicitRequirement'.	self t2 compile: 'm ^true'.	self deny: (self t4 >> #m) == (self t2 >> #m). "no sharing!!"	self assert: self c2 new m.	self t2 removeSelector: #m.	self deny: (self t5 >> #m) == (self t1 >> #m). "no sharing!!"	self should: [self c2 new m] raise: Error! !!TraitTest methodsFor: 'testing' stamp: 'al 2/13/2006 17:41'!testMarkerMethods	"self debug: #testMarkerMethods"	self t1 compile: 'm1 self foo bar'.	self assert: (self t1 >> #m1) markerOrNil isNil.	self t1 compile: 'm2 self requirement'.	self assert: (self t1 >> #m2) markerOrNil == #requirement.		self t1 compile: 'm3 ^self requirement'.	self assert: (self t1 >> #m3) markerOrNil == #requirement.! !!TraitTest methodsFor: 'testing' stamp: 'ar 1/2/2010 03:41'!testPrinting	self assertPrints: self t6 definition		like: 'Trait named: #T6	uses: T1 + T2 @ {#m22Alias->#m22}	category: ''TraitsTests-Kernel'''! !!TraitTest methodsFor: 'testing' stamp: 'ar 1/2/2010 03:41'!testPrintingClassSide	"self run: #testPrintingClassSide"		self assertPrints: self t6 classSide definition		like: 'T6 classTrait	uses: T1 classTrait + T2 classTrait'! !!TraitTest methodsFor: 'testing' stamp: 'ar 12/31/2009 15:22'!testRemoveFromSystem	self t4 removeFromSystem.	self deny: (Smalltalk includesKey: #T4).	self assert: self t4 name = 'AnObsoleteT4'.	self assert: self t4 methodDict isEmpty.	self deny: (self t1 users includes: self t4)! !!TraitTest methodsFor: 'testing' stamp: 'ar 12/20/2009 02:48'!testRequirement	"self run: #testRequirement"	self t1 compile: 'm self requirement'.	self t2 compile: 'm ^true'.	self deny: (self t4 >> #m) == (self t2 >> #m). "no sharing!!"	self assert: self c2 new m.	self t2 removeSelector: #m.	self deny: (self t5 >> #m) == (self t1 >> #m). "no sharing!!"	self should: [self c2 new m] raise: Error! !!TraitTest methodsFor: 'testing' stamp: 'ar 12/31/2009 15:22'!testTraitFromPattern	| newTrait |	newTrait := self createTraitNamed: #TTraitTestBaseTrait uses: {}.	self assert: (Utilities classFromPattern: 'TTraitTestBaseT' withCaption: '') = newTrait.! !!TraitTest methodsFor: 'testing' stamp: 'ar 12/31/2009 15:35'!testTraitMethodClass	"Tests that the #methodClass of a trait method isn't screwed up"	| baseTrait classA methodA classB methodB traitMethod |	baseTrait := self createTraitNamed: #TraitTestBaseTrait uses:{}.	baseTrait compileSilently: 'traitMethod' classified: 'tests'.	traitMethod := baseTrait compiledMethodAt: #traitMethod.	self assert: traitMethod methodClass == baseTrait.	classA := self createClassNamed: #TraitTestMethodClassA superclass: Object uses: baseTrait.	methodA := classA compiledMethodAt: #traitMethod.	self assert: traitMethod methodClass == baseTrait.	self assert: methodA methodClass == classA.	classB := self createClassNamed: #TraitTestMethodClassB superclass: Object uses: baseTrait.	methodB := classB compiledMethodAt: #traitMethod.	self assert: traitMethod methodClass == baseTrait.	self assert: methodA methodClass == classA.	self assert: methodB methodClass == classB.! !!TraitTest methodsFor: 'testing' stamp: 'ar 12/31/2009 15:35'!testTraitMethodSelector	"Tests that the #selector of a trait method isn't screwed up when aliasing traits"	| baseTrait classA methodA classB methodB traitMethod |	baseTrait := self createTraitNamed: #TraitTestBaseTrait uses:{}.	baseTrait compileSilently: 'traitMethod' classified: 'tests'.	traitMethod := baseTrait compiledMethodAt: #traitMethod.	self assert: traitMethod selector == #traitMethod.	classA := self createClassNamed: #TraitTestMethodClassA superclass: Object					uses: {baseTrait @ {#methodA -> #traitMethod}}.	methodA := classA compiledMethodAt: #methodA.	self assert: traitMethod selector == #traitMethod.	self assert: methodA selector == #methodA.	classB := self createClassNamed: #TraitTestMethodClassB superclass: Object					uses: {baseTrait @ {#methodB -> #traitMethod}}.	methodB := classB compiledMethodAt: #methodB.	self assert: traitMethod selector == #traitMethod.	self assert: methodA selector == #methodA.	self assert: methodB selector == #methodB.! !!TraitTest methodsFor: 'testing' stamp: 'ar 12/27/2009 21:51'!testUsers	self assert: self t1 users size = 3.	self assert: (self t1 users includesAllOf: {self t4. self t5. self t6 }).	self assert: self t3 users isEmpty.	self assert: self t5 users size = 1.	self assert: self t5 users anyOne = self c2.	self c2 uses: self t1 + self t5.	self assert: self t5 users size = 1.	self assert: self t5 users anyOne = self c2.	self c2 uses: self t2 asTraitComposition.	self assert: self t5 users isEmpty! !!TraitsTestCase class methodsFor: 'as yet unclassified' stamp: 'ar 12/31/2009 15:21'!resources	^{TraitsResource}! !