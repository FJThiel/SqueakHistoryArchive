'From Squeak3.11alpha of 13 February 2010 [latest update: #9483] on 9 March 2010 at 11:11:23 am'!!Object methodsFor: 'private' stamp: 'dtl 2/27/2010 10:34'!primitiveError: aString 	"This method is called when the error handling results in a recursion in 	calling on error: or halt or halt:."	(String		streamContents: 			[:s |			| context |			s nextPutAll: '***System error handling failed***'.			s cr; nextPutAll: aString.			context := thisContext sender sender.			20 timesRepeat: [context == nil ifFalse: [s cr; print: (context := context sender)]].			s cr; nextPutAll: '-------------------------------'.			s cr; nextPutAll: 'Type CR to enter an emergency evaluator.'.			s cr; nextPutAll: 'Type any other character to restart.'])		displayAt: 0 @ 0.	[Sensor keyboardPressed] whileFalse.	Sensor keyboard = Character cr ifTrue: [Transcripter emergencyEvaluator].	Project current resetDisplay! !!Behavior methodsFor: 'initialize-release' stamp: 'ar 2/26/2010 20:02'!cleanUp	"Clean out any caches and other state that should be flushed when trying to get an image into a pristine state. Subclasses may override #cleanUp: to provide different levels of cleanliness"! !!Behavior methodsFor: 'initialize-release' stamp: 'ar 2/26/2010 23:01'!cleanUp: aggressive	"Clean out any caches and other state that should be flushed when trying to get an image into a pristine state. The argument should be used to indicate how aggressive the cleanup should be. Some subclasses may act differently depending on its value - for example, ChangeSet will only delete all unused and reinitialize the current change set if we're asking it to be aggressive."	^self cleanUp! !!Behavior class methodsFor: 'class initialization' stamp: 'ar 2/26/2010 23:02'!cleanUp	"Flush the obsolete subclasses."	self flushObsoleteSubclasses! !!ClassOrganizer class methodsFor: 'class initialization' stamp: 'ar 2/26/2010 23:01'!cleanUp: aggressive	"Remove empty method categories when cleaning aggressively"	aggressive ifTrue:[Smalltalk removeEmptyMessageCategories].! !!MethodDictionary methodsFor: 'private' stamp: 'ar 2/26/2010 19:26'!compactCopyFrom: sourceMD	"Copy the contents of source dictionary without growing"	sourceMD keysAndValuesDo:[:key :value| | index |		index := self scanFor: key.		(self basicAt: index) ifNotNil:[self error: 'Something is horribly broken'].		self basicAt: index put: key.		array at: index put: value.		tally := tally + 1.	].	self size = self capacity ifTrue:[self grow]. "grow only if we reach capacity"! !!MethodDictionary class methodsFor: 'initialization' stamp: 'ar 2/26/2010 23:12'!cleanUp: aggressive	"Compact method dictionaries when aggressively cleaning up"	aggressive ifTrue:[self compactAllInstances].! !!MethodDictionary class methodsFor: 'initialization' stamp: 'ar 2/26/2010 19:25'!compactAllInstances	"MethodDictionary compactAllInstances"	"Compacts all MethodDictionaries to save space"	| oldInstances newInstances |	oldInstances := self allInstances.	newInstances := oldInstances collect:[:md|		(self new: md size) 			compactCopyFrom: md;			yourself].	oldInstances elementsForwardIdentityTo: newInstances.! !