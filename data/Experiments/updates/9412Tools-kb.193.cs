'From Squeak3.11alpha of 13 February 2010 [latest update: #9483] on 9 March 2010 at 11:11:23 am'!StringHolder subclass: #Workspace	instanceVariableNames: 'bindings acceptDroppedMorphs acceptAction mustDeclareVariables shouldStyle '	classVariableNames: 'ShouldStyle '	poolDictionaries: ''	category: 'Tools-Base'!!Workspace commentStamp: 'ls 10/14/2003 12:13' prior: 0!A Workspace is a text area plus a lot of support for executable code.  It is a great place to execute top-level commands to compute something useful, and it is a great place to develop bits of a program before those bits get put into class methods.To open a new workspace, execute:	Workspace openA workspace can have its own variables, called "workspace variables", to hold intermediate results.  For example, if you type into a workspace "x := 5" and do-it, then later you could type in "y := x * 2" and y would become 10.Additionally, in Morphic, a workspace can gain access to morphs that are on the screen.  If acceptDroppedMorphss is turned on, then whenever a morph is dropped on the workspace, a variable will be created which references that morph.  This functionality is toggled with the window-wide menu of a workspace.The instance variables of this class are:	bindings  -  holds the workspace variables for this workspace	acceptDroppedMorphss - whether dropped morphs should create new variables!!Debugger methodsFor: 'private' stamp: 'ar 3/5/2010 20:31'!process: aProcess controller: aController context: aContext	super initialize.	Smalltalk at: #MessageTally ifPresent:[:tally| tally terminateTimerProcess].	contents := nil. 	interruptedProcess := aProcess.	interruptedController := aController.	contextStackTop := aContext.	self newStack: (contextStackTop stackOfSize: 1).	contextStackIndex := 1.	externalInterrupt := false.	selectingPC := true.	Smalltalk isMorphic ifTrue:		[errorWasInUIProcess := false]! !!FileList2 methodsFor: 'private' stamp: 'ul 2/22/2010 22:32'!okHit	ok := true.	currentDirectorySelected		ifNil: [ Beeper beep ]		ifNotNil: [			self class lastSelDir: directory.			modalView delete ]! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'ul 2/22/2010 22:21'!modalFolderSelector	^self modalFolderSelector: self lastSelDir	! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'ul 2/22/2010 22:28'!modalFolderSelector: aDir	| window fileModel |	window _ self morphicViewFolderSelector: aDir.	fileModel _ window model.	window openInWorld: self currentWorld extent: 300@400.	self modalLoopOn: window.	^fileModel getSelectedDirectory withoutListWrapper! !!FileList2 class methodsFor: 'morphic ui' stamp: 'ul 2/22/2010 22:22'!morphicViewFileSelectorForSuffixes: aList 	"Answer a morphic file-selector tool for the given suffix list."		^self morphicViewFileSelectorForSuffixes: aList directory: self lastSelDir! !!FileList2 class methodsFor: 'accessing' stamp: 'ul 2/22/2010 22:32'!lastSelDir	"Return the last selected directory or the default directory if no directory was selected so far."	^lastSelDir ifNil: [ lastSelDir := FileDirectory default ]! !!FileList2 class methodsFor: 'accessing' stamp: 'ul 2/22/2010 22:34'!lastSelDir: aFileDirectory	"Store the last selected directory. This will be selected as default in newly opened file or folder selectors"		^lastSelDir := aFileDirectory! !!TimeProfileBrowser methodsFor: 'private' stamp: 'jmv 2/19/2010 14:42'!runBlock: aBlock pollingEvery: pollPeriod 	| stream list result |	block := MessageSend 				receiver: self				selector: #runBlock:pollingEvery:				arguments: { 						aBlock.						pollPeriod}.	"so we can re-run it"	tally := MessageTally new.	tally		reportOtherProcesses: false;		maxClassNameSize: 1000;		maxClassPlusSelectorSize: 1000;		maxTabs: 100.	result := tally spyEvery: pollPeriod on: aBlock.	stream := ReadWriteStream 				with: (String streamContents: [ :s | 					tally report: s]).	stream reset.	list := OrderedCollection new.	[stream atEnd] whileFalse: [list add: stream nextLine].	self initializeMessageList: list.	self changed: #messageList.	self changed: #messageListIndex.	^result! !!TimeProfileBrowser methodsFor: 'private' stamp: 'jmv 2/19/2010 14:42'!runProcess: aProcess forMilliseconds: msecDuration pollingEvery: pollPeriod 	| stream list result |	block := MessageSend 				receiver: self				selector: #runProcess:forMilliseconds:pollingEvery: 				arguments: { 						aProcess.						msecDuration.						pollPeriod}.	"so we can re-run it"	tally := MessageTally new.	tally		reportOtherProcesses: false;		maxClassNameSize: 1000;		maxClassPlusSelectorSize: 1000;		maxTabs: 100.	result := tally 				spyEvery: pollPeriod				onProcess: aProcess				forMilliseconds: msecDuration.	stream := ReadWriteStream 				with: (String streamContents: [ :s | 							tally report: s]).	stream reset.	list := OrderedCollection new.	[stream atEnd] whileFalse: [list add: stream nextLine].	self initializeMessageList: list.	self changed: #messageList.	self changed: #messageListIndex.	^result! !!Workspace methodsFor: 'binding' stamp: 'kb 2/22/2010 22:29'!hasBindingOf: aString 		^bindings notNil and: [ bindings includesKey: aString ]! !!Workspace methodsFor: 'binding' stamp: 'kb 2/22/2010 22:18'!hasBindingThatBeginsWith: aString 		bindings ifNil: [ ^false ].	bindings keysDo: [ :each |		(each beginsWith: aString) ifTrue: [ ^true ] ].	^false! !!Workspace methodsFor: 'code pane' stamp: 'kb 2/22/2010 23:58'!aboutToStyle: aStyler	self shouldStyle ifFalse: [ ^false ].	aStyler 		classOrMetaClass: nil;		workspace: self.	^true! !!Workspace methodsFor: 'code pane menu' stamp: 'kb 2/22/2010 23:53'!addToggleStylingMenuItemTo: aMenu		aMenu		addUpdating: #toggleStylingLabel		target: self		action: #toggleStyling! !!Workspace methodsFor: 'code pane menu' stamp: 'kb 2/22/2010 23:53'!shouldStyle	^shouldStyle ifNil: [ self class shouldStyle ]! !!Workspace methodsFor: 'code pane menu' stamp: 'kb 2/23/2010 00:44'!toggleStyling	shouldStyle := self shouldStyle not.	" Ugly hack, to restyle our contents. "	self codeTextMorph in: [ :codeTextMorph |		codeTextMorph setText:			codeTextMorph textMorph text asString asText ]! !!Workspace methodsFor: 'code pane menu' stamp: 'ar 2/26/2010 01:19'!toggleStylingLabel	^self shouldStyle 		ifTrue: [ '<on> syntax highlighting' ]		ifFalse: [ '<off> syntax highlighting' ]! !!Workspace methodsFor: 'toolbuilder' stamp: 'kb 2/22/2010 22:12'!buildCodePaneWith: builder	| textSpec |	textSpec := builder pluggableCodePaneSpec new.	textSpec 		model: self;		getText: #contents; 		setText: #contents:notifying:; 		selection: #contentsSelection; 		menu: #codePaneMenu:shifted:.	^textSpec! !!Workspace class methodsFor: 'preferences' stamp: 'kb 2/22/2010 23:57'!shouldStyle	<preference: 'Shout styling in Workspace' 		category: 'browsing' 		description: 'After enabled, new workspaces use shout to style their contents.' 		type: #Boolean>	^ShouldStyle ifNil: [ ^true ]! !!Workspace class methodsFor: 'preferences' stamp: 'kb 2/22/2010 23:56'!shouldStyle: aBoolean	ShouldStyle := aBoolean! !StringHolder subclass: #Workspace	instanceVariableNames: 'bindings acceptDroppedMorphs acceptAction mustDeclareVariables shouldStyle'	classVariableNames: 'ShouldStyle'	poolDictionaries: ''	category: 'Tools-Base'!