'From Squeak3.11alpha of 13 February 2010 [latest update: #9483] on 9 March 2010 at 11:11:23 am'!!NumberParser commentStamp: 'nice 2/25/2010 02:34' prior: 0!NumberParser is an abstract class for parsing and building numbers from string/stream.It offers a framework with utility methods and exception handling.Number syntax is not defined and should be subclassResponsibility.Instance variables:sourceStream <Stream> the stream of characters from which the number is readbase <Integer> the radix in which to interpret digitsneg <Boolean> true in case of minus signintegerPart <Integer> the integer part of the numberfractionPart <Integer> the fraction part of the number if anyexponent <Integer> the exponent used in scientific notation if anyscale <Integer> the scale used in case of ScaledDecimal number if anynDigits <Integer> number of digits read to form an IntegerlasNonZero <Integer> position of last non zero digit, starting at 1 from left, 0 if all digits are zerorequestor <TextEditor | nil> can be used to insert an error message in the requestorfailBlock <BlockClosure> Block to execute whenever an error occurs.	The fail block can have 0, 1 or 2 arguments (errorString and source position)!!Object methodsFor: 'finalization' stamp: 'ul 2/26/2010 14:04'!toFinalizeSend: aSelector to: aFinalizer with: aResourceHandle	"When I am finalized (e.g., garbage collected) close the associated resource handle by sending aSelector to the appropriate finalizer (the guy who knows how to get rid of the resource).	WARNING: Neither the finalizer nor the resource handle are allowed to reference me. If they do, then I will NEVER be garbage collected. Since this cannot be validated here, it is up to the client to make sure this invariant is not broken."	self == aFinalizer ifTrue:[self error: 'I cannot finalize myself'].	self == aResourceHandle ifTrue:[self error: 'I cannot finalize myself'].	^self finalizationRegistry add: self executor:		(ObjectFinalizer			receiver: aFinalizer			selector: aSelector			argument: aResourceHandle)! !!NumberParser methodsFor: 'error' stamp: 'nice 2/25/2010 02:39'!expected: aString 	| errorString |	errorString := aString , ' expected'.	requestor isNil		ifFalse: [requestor				notify: errorString				at: sourceStream position + 1				in: sourceStream].	failBlock ifNotNil: [^failBlock cull: errorString cull: sourceStream position + 1].	self error: 'Reading a number failed: ' , errorString! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'jmv 2/23/2010 14:27'!critical: mutuallyExcludedBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in	the process of running the critical: message. If the receiver is, evaluate	mutuallyExcludedBlock after the other critical: message is finished."		| caught |	"We need to catch eventual interruptions very carefully. 	The naive approach of just doing, e.g.,:		self wait.		aBlock ensure:[self signal].	will fail if the active process gets terminated while in the wait.	However, the equally naive:		[self wait.		aBlock value] ensure:[self signal].	will fail too, since the active process may get interrupted while	entering the ensured block and leave the semaphore signaled twice.	To avoid both problems we make use of the fact that interrupts only	occur on sends (or backward jumps) and use an assignment (bytecode)	right before we go into the wait primitive (which is not a real send and	therefore not interruptable either)."	caught := false.	^[		caught := true.		self wait.		mutuallyExcludedBlock value	] ensure: [ caught ifTrue: [self signal] ]! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'jmv 2/23/2010 11:52'!critical: mutuallyExcludedBlock ifLocked: alternativeBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."		"Note: The following is tricky and depends on the fact that the VM will not switch between processes while executing byte codes (process switches happen only in real sends). The following test is written carefully so that it will result in bytecodes only."	excessSignals == 0 ifTrue:[		"If we come here, then the semaphore was locked when the test executed. 		Evaluate the alternative block and answer its result."		^alternativeBlock value 	].	^self critical: mutuallyExcludedBlock! !NumberParser removeSelector: #fail!