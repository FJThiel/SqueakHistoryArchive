'From Squeak3.11alpha of 13 February 2010 [latest update: #9483] on 9 March 2010 at 11:11:23 am'!ClassDescription subclass: #TraitBehavior	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!!TraitBehavior commentStamp: 'ar 12/29/2009 18:15' prior: 0!Stub class for backward compatibility. Allows past extension methods in TraitBehavior to continue to work.!OrderedCollection subclass: #TraitComposition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!!TraitComposition commentStamp: 'ar 12/29/2009 18:13' prior: 0!A trait composition is a collection of Traits or TraitTransformations.!Error subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!!TraitCompositionException commentStamp: 'ar 12/29/2009 18:13' prior: 0!Signals invalid trait compositions.!TraitBehavior subclass: #TraitDescription	instanceVariableNames: 'users'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!!TraitDescription commentStamp: 'ar 12/29/2009 18:15' prior: 0!TraitDescription combines common behavior for both (instance) traits and (meta) class traits.!TraitDescription subclass: #ClassTrait	instanceVariableNames: 'baseTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!!ClassTrait commentStamp: 'ar 12/29/2009 18:16' prior: 0!The class of some trait. Just like the Class - Metaclass relationship.!TraitDescription subclass: #Trait	instanceVariableNames: 'name environment classTrait category'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!!Trait commentStamp: 'ar 12/29/2009 18:16' prior: 0!Defines a trait in the system. Like Class, I concretize my superclass by providing instance variables for the name and the environment.!AdditionalMethodState variableSubclass: #TraitMethodState	instanceVariableNames: 'originalTraitMethod'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!!TraitMethodState commentStamp: 'ar 12/29/2009 18:13' prior: 0!Additional method state for trait provided methods.!ClassOrganizer subclass: #TraitOrganizer	instanceVariableNames: 'traitComposition'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!!TraitOrganizer commentStamp: 'ar 1/9/2010 17:56' prior: 0!A class organizer containing state for traits.!Object subclass: #TraitTransformation	instanceVariableNames: 'subject users'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!!TraitTransformation commentStamp: 'ar 12/29/2009 18:14' prior: 0!A trait transformation is an instance of one of my concrete subclasses, TraitAlias or TraitExclusion. These represent a transformation of a trait, specified by the alias and exclusion operators. I define an instance variable named subject which holds the object that is transformed.  Thus, an alias transformation has as its subject a trait, and a trait exclusion has as its subject either a trait alias or a trait. Each of the concrete transformation classes implement the method allSelectors according to the transformation it represents. !TraitTransformation subclass: #TraitAlias	instanceVariableNames: 'aliases'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!!TraitAlias commentStamp: 'ar 12/29/2009 18:14' prior: 0!A trait transformation representing the alias (->) operator.!TraitTransformation subclass: #TraitExclusion	instanceVariableNames: 'exclusions'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!!TraitExclusion commentStamp: 'ar 12/29/2009 18:13' prior: 0!A trait transformation representing the exclusion (-) operator.!!AdditionalMethodState methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/22/2009 08:15'!originalTraitMethod	"The original method from the trait.	Only available in TraitMethodState."	^nil! !!AdditionalMethodState methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/28/2009 00:30'!originalTraitOrClass	"The original trait for this method"	^method methodClass! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/27/2009 14:26'!allTraits	"Answer all the traits that are used by myself without their transformations"	^self traitComposition isEmpty 		ifTrue:[#()]		ifFalse:[self traitComposition allTraits].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'nice 1/10/2010 17:46'!assembleTraitMethodsFrom: aTraitComposition	"Assemble the resulting methods for installing the given trait composition.	Returns a Dictionary instead of a MethodDictionary for speed (MDs grow by #become:)"	| methods |	methods := Dictionary new.	"Stick in the local methods first, since this avoids generating conflict methods unnecessarily"	self selectorsAndMethodsDo:[:sel :newMethod|		(self isLocalMethod: newMethod)			ifTrue:[methods at: sel put:newMethod]].	"Now assemble the traits methods"	aTraitComposition do:[:trait|		trait selectorsAndMethodsDo:[:sel :newMethod| | oldMethod |			oldMethod := methods at: sel ifAbsentPut:[newMethod].			newMethod == oldMethod ifFalse:["a conflict"				(self isLocalMethod: oldMethod) ifFalse:[					methods at: sel put: (self resolveTraitsConflict: sel from: oldMethod to: newMethod)]]]].	^methods! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 00:06'!basicRemoveSelector: aSelector	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Update the trait composition."	| oldMethod |	oldMethod := super basicRemoveSelector: aSelector.	oldMethod ifNotNil:[self updateTraits].	^oldMethod! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 12:52'!classify: selector under: heading from: category trait: aTrait	"Update the organization for a trait. the dumb, unoptimized version"	self updateTraits.! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 12:59'!hasTraitComposition	^self traitComposition notEmpty! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 17:37'!includesLocalSelector: selector	^(self compiledMethodAt: selector ifAbsent:[^false]) methodHome == self! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/31/2009 15:29'!includesTrait: aTrait	^self traitComposition anySatisfy:[:each| each includesTrait: aTrait]! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'nice 1/10/2010 17:46'!installTraitMethodDict: methods	"After having assembled the trait composition, install its methods."	| oldCategories removals |	"Apply the changes. We first add the new or changed methods."	oldCategories := Set new.	methods keysAndValuesDo:[:sel :newMethod| | oldMethod |		oldMethod := self compiledMethodAt: sel ifAbsent:[nil].		oldMethod == newMethod ifFalse:[			self traitAddSelector: sel withMethod: newMethod.			(self organization categoryOfElement: sel) ifNotNil:[:cat| oldCategories add: cat].			self organization classify: sel under: 				(newMethod methodHome organization categoryOfElement: newMethod selector)]].	"Now remove the old or obsoleted ones"	removals := OrderedCollection new.	self selectorsDo:[:sel| (methods includesKey: sel) ifFalse:[removals add: sel]].	removals do:[:sel| self traitRemoveSelector: sel].	"Clean out empty categories"	oldCategories do:[:cat|		(self organization isEmptyCategoryNamed: cat)			ifTrue:[self organization removeCategory: cat]].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 1/2/2010 03:50'!installTraitsFrom: aTraitComposition	"Install the traits from the given composition. This method implements	the core composition method - all others are just optimizations for	particular cases. Consequently, the optimized versions can always fall	back to this method when things get too hairy."	| allTraits methods |	(self traitComposition isEmpty and: [aTraitComposition isEmpty]) ifTrue: [^self].	"Check for cycles"	allTraits := aTraitComposition gather: [:t | t allTraits copyWith: t].	(allTraits includes: self) ifTrue:[^self error: 'Cyclic trait definition detected'].	self traitComposition: aTraitComposition.	methods := self assembleTraitMethodsFrom: aTraitComposition.	self installTraitMethodDict: methods.	self isMeta ifFalse:[self classSide updateTraitsFrom: aTraitComposition].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'nice 1/1/2010 21:46'!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^(self includesLocalSelector: aSymbol) not		and: [self hasTraitComposition		and: [self traitComposition isAliasSelector: aSymbol]]! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'nice 1/1/2010 21:46'!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^(self includesLocalSelector: aSymbol) not		and: [self hasTraitComposition		and: [self traitComposition isLocalAliasSelector: aSymbol]]! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 11/28/2007 20:51'!isLocalMethod: aCompiledMethod	"Answer true if the method is a local method, e.g., defined in the receiver instead of a trait."	^aCompiledMethod methodHome == self! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 17:51'!localSelectors	^self selectors select:[:sel| self includesLocalSelector: sel]! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 2/2/2010 15:29'!recompile: selector from: oldClass	"Preserve the originalTraitMethod (if any) after recompiling a selector"	| oldMethod |	oldMethod := oldClass compiledMethodAt: selector.	super recompile: selector from: oldClass.	oldMethod originalTraitMethod ifNotNil:[:traitMethod|		(self compiledMethodAt: selector) originalTraitMethod: traitMethod.	].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/19/2009 21:14'!replaceSelector: originalSelector withAlias: aliasSelector in: source	"replaces originalSelector with aliasSelector in in given source code"	| oldKeywords newKeywords args selectorWithArgs s |	oldKeywords := originalSelector keywords.	newKeywords := aliasSelector keywords.	oldKeywords size = newKeywords size ifFalse:[self error: 'Keyword mismatch'].	args := (self parserClass new parseArgsAndTemps: source asString notifying: nil) 				copyFrom: 1 to: originalSelector numArgs.	selectorWithArgs := String streamContents: [:stream |		newKeywords keysAndValuesDo: [:index :keyword |			stream nextPutAll: keyword.			stream space.			args size >= index ifTrue: [				stream nextPutAll: (args at: index); space]]].	s := source asString readStream.	oldKeywords do: [ :each | s match: each ].	args isEmpty ifFalse: [ s match: args last ].	^selectorWithArgs withBlanksTrimmed asText , s upToEnd! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 18:22'!resolveTraitsConflict: aSelector from: oldMethod to: newMethod	"Resolve a traits conflict. Rules:		- If one method is required the other one wins		- Otherwise we compile a traits conflict	"	| marker selector |	oldMethod methodHome == newMethod methodHome ifTrue:[^oldMethod].	marker := oldMethod markerOrNil.	(#(requirement explicitRequirement subclassResponsibility shouldNotImplement) includes: marker)		ifTrue:[^newMethod].	marker := newMethod markerOrNil.	(#(requirement explicitRequirement subclassResponsibility shouldNotImplement) includes: marker)		ifTrue:[^oldMethod].	"Create a conflict marker"	selector := #(conflict conflict: conflict:with: conflict:with:with: conflict:with:with:with:	conflict:with:with:with:with: conflict:with:with:with:with:with: conflict:with:with:with:with:with:with:	conflict:with:with:with:with:with:with:with:) at: oldMethod numArgs+1.	^TraitDescription class compiledMethodAt: selector.! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 17:20'!setTraitComposition: aTraitComposition	"OBSOLETE. Use Class uses: aTraitComposition instead."	^self uses: aTraitComposition! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 17:20'!setTraitCompositionFrom: aTraitComposition	"OBSOLETE. Use Class uses: aTraitComposition instead."	^self uses: aTraitComposition! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/22/2009 10:02'!traitAddSelector: selector withMethod: traitMethod	"Add a method inherited from a trait. 	Recompiles to avoid sharing and implement aliasing."	| oldMethod source methodNode newMethod originalSelector |	oldMethod := self compiledMethodAt: selector ifAbsent:[nil].	oldMethod ifNotNil:[		"The following is an important optimization as it prevents exponential		growth in recompilation. If T1 is used by T2 and T2 by T3 then (without		this optimization) any change in T1 would cause all methods in T2 to be		recompiled and each recompilation of a method in T2 would cause T3		to be fully recompiled. The test eliminates all such situations."		(oldMethod sameTraitCodeAs: traitMethod) ifTrue:[^oldMethod].	].	originalSelector := traitMethod selector.	source := traitMethod methodClass sourceCodeAt: originalSelector.	originalSelector == selector ifFalse:[		"Replace source selectors for aliases"		source := self replaceSelector: originalSelector withAlias: selector in: source.	].	methodNode := self compilerClass new 		compile: source in: self classified: nil notifying: nil ifFail:[^nil].	newMethod := methodNode generate: self defaultMethodTrailer.	newMethod putSource: source fromParseNode: methodNode inFile: 2		withPreamble: [:f | f cr; nextPut: $!!; nextChunkPut: 'Trait method'; cr].	newMethod originalTraitMethod: traitMethod.	^super addSelectorSilently: selector withMethod: newMethod.! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/30/2009 02:48'!traitComposition	"Answer my trait composition"	^self organization traitComposition! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 1/2/2010 03:38'!traitComposition: aTraitComposition	"Install my trait composition"	self traitComposition do:[:tc|  tc removeTraitUser: self].	aTraitComposition isEmptyOrNil ifTrue:[		self organization isTraitOrganizer 			ifTrue:[self organization: (ClassOrganizer newFrom: self organization)].	] ifFalse:[		self organization isTraitOrganizer 			ifFalse:[self organization: (TraitOrganizer newFrom: self organization)].		self organization traitComposition: aTraitComposition.		aTraitComposition do:[:tc| tc addTraitUser: self].	].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/28/2009 01:06'!traitCompositionString	"Answer the trait composition string for the receiver"	^self traitComposition isEmpty 		ifTrue:['{}'] 		ifFalse:[self traitComposition asString].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 03:13'!traitRemoveSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."	| priorMethod priorProtocol | 	priorMethod := self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol := self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance doSilently: [		self organization removeElement: selector].	super basicRemoveSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.	(self organization isEmptyCategoryNamed: priorProtocol)		ifTrue:[self organization removeCategory: priorProtocol].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/21/2009 15:13'!traits	"Answer an array of my traits"	^self traitComposition asArray collect:[:composed| composed trait]! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 18:18'!updateTraits	"Recompute my local traits composition"	self installTraitsFrom: self traitComposition.! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'nice 1/10/2010 17:46'!updateTraitsFrom: instanceTraits	"ClassTrait/Metaclass only. Update me from the given instance traits"	| map newTraits |	self isMeta ifFalse:[self error: 'This is a metaclass operation'].	map := Dictionary new.	self traitComposition do:[:composed| map at: composed trait put: composed].	newTraits := (instanceTraits collect:[:composed| | trait |		trait := composed trait classTrait.		map at: trait ifAbsent:[trait]] 	), (self traitComposition select:[:comp| comp trait isBaseTrait]).	self installTraitsFrom: newTraits! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/19/2009 23:43'!users	^#()! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 18:34'!uses: aTraitComposition	self installTraitsFrom: aTraitComposition asTraitComposition.! !!ClassOrganizer methodsFor: '*Traits-Kernel' stamp: 'ar 12/30/2009 02:46'!isTraitOrganizer	"Answer true if this is a TraitOrganizer"	^false! !!ClassOrganizer methodsFor: '*Traits-Kernel' stamp: 'ar 12/30/2009 02:46'!traitComposition	"Answer the receiver's trait composition"	^#()! !!SequenceableCollection methodsFor: '*Traits' stamp: 'ar 12/27/2009 14:20'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [ClassDescription newTraitComposition]! !!CompiledMethod methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/22/2009 08:23'!originalTraitMethod	"Remember the original trait method for the receiver."	^self properties originalTraitMethod! !!CompiledMethod methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 18:22'!originalTraitMethod: aCompiledMethod	"Remember the original trait method for the receiver."	| methodState |	methodState := TraitMethodState newFrom: self properties.	methodState originalTraitMethod: aCompiledMethod.	self penultimateLiteral:  methodState.! !!CompiledMethod methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/28/2009 00:30'!originalTraitOrClass	"The original trait for this method"	^self properties originalTraitOrClass! !!CompiledMethod methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/22/2009 10:04'!sameTraitCodeAs: method	"Answer whether the receiver implements the same code as the 	argument, method. Does not look at properties/pragmas since they	do not affect the resulting code."	| numLits |	(method isKindOf: CompiledMethod) ifFalse: [^false].	self methodHome == method methodHome ifFalse:[^false].	(self properties analogousCodeTo: method properties) ifFalse:[^false].	self size = method size ifFalse: [^false].	self header = method header ifFalse: [^false].	self initialPC to: self endPC do:[:i | (self at: i) = (method at: i) ifFalse: [^false]].	(numLits := self numLiterals) ~= method numLiterals ifTrue: [^false].	1 to: numLits-2 do:[:i| | lit1 lit2 |		lit1 := self literalAt: i.		lit2 := method literalAt: i.		lit1 = lit2 ifFalse:[			(i = 1 and: [#(117 120) includes: self primitive]) ifTrue: [				lit1 isArray ifTrue:[					(lit2 isArray and: [lit1 allButLast = lit2 allButLast]) ifFalse:[^false]				] ifFalse: "ExternalLibraryFunction"					[(lit1 analogousCodeTo: lit2) ifFalse:[^false]].			] ifFalse:[				lit1 isFloat 					ifTrue:[(lit1 closeTo: lit2) ifFalse: [^false]]					ifFalse:["any other discrepancy is a failure"^ false]]]].	^true! !!TraitComposition methodsFor: 'converting' stamp: 'ar 12/29/2009 18:21'!+ aTrait	self traitsDo:[:t| (t == aTrait trait) ifTrue:[^TraitCompositionException			signal: 'Trait ' , aTrait trait asString, ' already in composition']].	self addLast: aTrait.	^self! !!TraitComposition methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!- anArray	"the modifier operators #@ and #- bind stronger than +.	Thus, #@ or #- sent to a sum will only affect the most right summand"		self addLast: (self removeLast - anArray)! !!TraitComposition methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!@ anArrayOfAssociations	"the modifier operators #@ and #- bind stronger than +.	Thus, #@ or #- sent to a sum will only affect the most right summand"	self addLast: (self removeLast @ anArrayOfAssociations)! !!TraitComposition methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!asTraitComposition	^self! !!TraitComposition methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!printOn: aStream	"Answer the trait composition string (used for class definitions)"	aStream nextPutAll: self traitCompositionString.! !!TraitComposition methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!allTraits	^self gather:[:each| each allTraits copyWith: each trait]! !!TraitComposition methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!traits	^Array streamContents:[:s| self traitsDo:[:t| s nextPut: t]]! !!TraitComposition methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!traitsDo: aBlock	^self do:[:each| each traitsDo: aBlock]! !!TraitComposition methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!copyTraitExpression	"Copy all except the actual traits"	^self collect:[:each| each copyTraitExpression].! !!TraitComposition methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!isAliasSelector: selector	"enumerates all selectors and methods in a trait composition"	^self anySatisfy:[:any| any isAliasSelector: selector]! !!TraitComposition methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!isLocalAliasSelector: selector	"Return true if the selector aSymbol is an alias defined in the receiver."	^self anySatisfy:[:any| any isTraitTransformation and:[any isLocalAliasSelector: selector]]! !!TraitComposition methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	self do:[:each| each selectorsAndMethodsDo: aBlock].! !!TraitComposition methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!traitCompositionString	"Answer the trait composition string (used for class definitions)"	self size = 0 ifTrue:[^'{}'].	self  size = 1 ifTrue:[^self first asString].	^String streamContents:[:s|		self do:[:each| s nextPutAll: each asString] separatedBy:[s nextPutAll: ' + '].	].! !!TraitComposition methodsFor: 'testing' stamp: 'ar 12/29/2009 18:11'!isTraitTransformation	"Polymorphic with TraitTransformation"	^false! !!TraitDescription methodsFor: 'operations' stamp: 'ar 12/29/2009 18:20'!+ aTrait	"Creates a composition with the receiver and aTrait"	aTrait traitsDo:[:t| self == t ifTrue:[TraitCompositionException			signal: 'Trait ' , self asString, ' already in composition']].	^TraitComposition withAll: {self}, aTrait asTraitComposition! !!TraitDescription methodsFor: 'operations' stamp: 'ar 12/29/2009 18:22'!- anArrayOfSelectors	"Creates an exclusion"	^TraitExclusion		with: self		exclusions: anArrayOfSelectors! !!TraitDescription methodsFor: 'operations' stamp: 'ar 12/29/2009 18:17'!@ anArrayOfAssociations 	"Creates an alias"	^TraitAlias with: self aliases: anArrayOfAssociations! !!TraitDescription methodsFor: 'operations' stamp: 'ar 12/19/2009 23:56'!addSelectorSilently: selector withMethod: compiledMethod	"Overridden to update the users of this trait"	super addSelectorSilently: selector withMethod: compiledMethod.	self users do:[:each| each updateTraits].! !!TraitDescription methodsFor: 'operations' stamp: 'ar 12/19/2009 23:54'!installTraitsFrom: aTraitComposition	super installTraitsFrom: aTraitComposition.	self users do:[:each| each updateTraits].! !!TraitDescription methodsFor: 'operations' stamp: 'ar 12/20/2009 00:52'!notifyOfRecategorizedSelector: element from: oldCategory to: newCategory	super notifyOfRecategorizedSelector: element from: oldCategory to: newCategory.	self users do:[:each| each classify: element under: newCategory from: oldCategory trait: self].! !!TraitDescription methodsFor: 'operations' stamp: 'ar 11/28/2007 20:59'!traitsDo: aBlock	aBlock value: self.! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 12/20/2009 00:42'!addTraitUser: aTrait	users := self users copyWith: aTrait.! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:57'!allClassVarNames	"Traits have no class var names"	^#()! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:58'!classPool	"Traits have no class pool"	^ Dictionary new! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 12/20/2009 00:39'!removeTraitUser: aTrait	users := self users copyWithout: aTrait.! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:58'!sharedPools	"Traits have no shared pools"	^ Dictionary new! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 12/21/2009 15:13'!trait	^self! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:55'!users	^users ifNil:[#()]! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:55'!users: aCollection	users := aCollection! !!TraitDescription methodsFor: 'converting' stamp: 'ar 12/29/2009 18:20'!asTraitComposition	^TraitComposition with: self! !!TraitDescription methodsFor: 'copying' stamp: 'ar 11/28/2007 20:55'!copy 	self error: 'Traits cannot be trivially copied'! !!TraitDescription methodsFor: 'copying' stamp: 'ar 11/28/2007 20:55'!copyTraitExpression	"Copy all except the actual traits"	^self! !!TraitDescription methodsFor: 'fileIn/Out' stamp: 'ar 12/19/2009 16:09'!fileOut	"Create a file whose name is the name of the receiver with '.st' as the 	extension, and file a description of the receiver onto it."	^ self fileOutAsHtml: false! !!TraitDescription methodsFor: 'fileIn/Out' stamp: 'ar 12/19/2009 16:08'!fileOutAsHtml: useHtml	"File a description of the receiver onto a new file whose base name is the name of the receiver."	| internalStream |	internalStream := WriteStream on: (String new: 100).	internalStream header; timeStamp.	self fileOutOn: internalStream moveSource: false toFile: 0.	internalStream trailer.	FileStream writeSourceCodeFrom: internalStream baseName: self name isSt: true useHtml: useHtml.! !!TraitDescription methodsFor: 'testing' stamp: 'ar 12/20/2009 02:35'!includesTrait: aTrait	^self == aTrait or:[super includesTrait: aTrait]! !!TraitDescription methodsFor: 'testing' stamp: 'ar 11/28/2007 21:01'!isBaseTrait	^false! !!TraitDescription methodsFor: 'testing' stamp: 'ar 11/28/2007 21:01'!isClassTrait	^false! !!TraitDescription methodsFor: 'testing' stamp: 'ar 11/28/2007 20:56'!isTrait	^true! !!TraitDescription methodsFor: 'testing' stamp: 'ar 11/28/2007 20:56'!isTraitTransformation	"Polymorphic with TraitTransformation"	^false! !!TraitDescription methodsFor: 'printing' stamp: 'ar 12/27/2009 19:14'!printHierarchy	"For hierarchy view in the browser; print the users of a trait"	^String streamContents:[:s| self printUsersOf: self on: s level: 0].! !!TraitDescription methodsFor: 'printing' stamp: 'ar 12/27/2009 19:16'!printUsersOf: aClass on: aStream level: indent	aStream crtab: indent.	aStream nextPutAll: aClass name.	aClass isTrait ifTrue:[		aClass users do:[:each| self printUsersOf: aClass on: aStream level: indent+1].	].! !!ClassTrait methodsFor: 'monticello' stamp: 'ar 12/22/2009 08:49'!asMCDefinition	^Smalltalk at: #MCClassTraitDefinition ifPresent:[:aClass|		aClass			baseTraitName: self baseTrait name			classTraitComposition: self traitCompositionString	].! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 23:00'!baseTrait	^baseTrait! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 12/30/2009 01:59'!baseTrait: aTrait	baseTrait ifNotNil:[self error: 'Already initialized'].	baseTrait := aTrait.! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 13:08'!classSide	^self! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 03:55'!definition	^String streamContents: [:stream |		stream nextPutAll: self name.		stream cr; tab; nextPutAll: 'uses: ';				nextPutAll: self traitComposition asString.	].! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 5/11/2008 01:51'!instanceSide	^self baseTrait! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 21:44'!name	^baseTrait name, ' classTrait'! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 12/19/2009 18:38'!soleInstance	^baseTrait! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 02:55'!theMetaClass	^self! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 14:29'!theNonMetaClass	"Sent to a class or metaclass, always return the class"	^baseTrait! !!ClassTrait methodsFor: 'compiling' stamp: 'ar 12/21/2009 20:18'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	^baseTrait bindingOf: varName! !!ClassTrait methodsFor: 'testing' stamp: 'ar 11/18/2007 22:59'!isClassTrait	^true! !!ClassTrait methodsFor: 'testing' stamp: 'ar 11/18/2007 22:21'!isMeta	^true! !!ClassTrait methodsFor: 'testing' stamp: 'ar 12/30/2009 02:43'!isObsolete	^baseTrait == nil or:[baseTrait isObsolete]! !!ClassTrait methodsFor: 'initialize' stamp: 'ar 12/29/2009 18:38'!uses: aTraitComposition	| newTraits |	newTraits := aTraitComposition asTraitComposition.	newTraits traitsDo:[:t|		(t isBaseTrait and:[t classSide hasMethods]) 			ifTrue:[self error: 'Cannot add: ', t].		(t isClassTrait and:[(baseTrait includesTrait: t baseTrait) not]) 			ifTrue:[self error: 'Cannot add: ', t].	].	self installTraitsFrom: newTraits.! !!Trait methodsFor: 'monticello' stamp: 'ar 12/22/2009 08:48'!asClassDefinition	^Smalltalk at: #MCTraitDefinition ifPresent:[:aClass|		aClass			name: self name			traitComposition: self traitCompositionString			category: self category 			comment: self organization classComment asString			commentStamp: self organization commentStamp].! !!Trait methodsFor: 'monticello' stamp: 'nice 1/1/2010 21:49'!classDefinitions	| definitions |	definitions := OrderedCollection with: self asClassDefinition.	(self hasClassTrait		and: [self classTrait hasTraitComposition		and: [self classTrait traitComposition isEmpty not]])			ifTrue: [definitions add: self classTrait asMCDefinition].	^definitions asArray! !!Trait methodsFor: 'converting' stamp: 'ar 12/29/2009 18:34'!asTraitComposition	"Convert me into a trait composition"	^TraitComposition with: self! !!Trait methodsFor: 'accessing' stamp: 'ar 12/21/2009 19:49'!baseTrait	^self! !!Trait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	category ifNotNilDo: [ :symbol |		((SystemOrganization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	category := (result := SystemOrganization categoryOfElement: self name).	^result! !!Trait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:38'!category: aString 	"Categorize the receiver under the system category, aString, removing it from 	any previous categorization."	| oldCategory |	oldCategory := category.	aString isString		ifTrue: [			category := aString asSymbol.			SystemOrganization classify: self name under: category ]		ifFalse: [self errorCategoryName].	SystemChangeNotifier uniqueInstance		class: self recategorizedFrom: oldCategory to: category! !!Trait methodsFor: 'accessing' stamp: 'ar 12/30/2009 02:31'!classTrait	^classTrait! !!Trait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!environment	^environment! !!Trait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!environment: anObject	environment := anObject! !!Trait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!name	^name! !!Trait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!name: aSymbol	name := aSymbol! !!Trait methodsFor: 'accessing' stamp: 'ar 12/30/2009 01:55'!theMetaClass	^self classTrait! !!Trait methodsFor: 'compiling' stamp: 'ar 12/21/2009 20:17'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	^self environment bindingOf: varName asSymbol.! !!Trait methodsFor: 'initialize' stamp: 'ar 12/27/2009 19:40'!definition	^String streamContents: [:stream |		stream nextPutAll: 'Trait named: ';				store: self name.		stream cr; tab; nextPutAll: 'uses: ';				nextPutAll: self traitComposition asString.		stream cr; tab; nextPutAll: 'category: ';				store: self category asString].! !!Trait methodsFor: 'initialize' stamp: 'ar 12/30/2009 01:59'!initialize	super initialize.	classTrait := ClassTrait for: self.! !!Trait methodsFor: 'initialize' stamp: 'nice 1/1/2010 22:06'!isValidTraitName: aSymbol	^(aSymbol isEmptyOrNil		or: [aSymbol first isLetter not		or: [aSymbol anySatisfy: [:character | character isAlphaNumeric not]]]) not! !!Trait methodsFor: 'initialize' stamp: 'ar 12/30/2009 01:55'!obsolete	self name: ('AnObsolete' , self name) asSymbol.	self classTrait obsolete.	super obsolete! !!Trait methodsFor: 'initialize' stamp: 'ar 11/28/2007 21:00'!removeFromSystem	self removeFromSystem: true! !!Trait methodsFor: 'initialize' stamp: 'ar 11/28/2007 21:00'!removeFromSystem: logged	self environment forgetClass: self logged: logged.	self obsolete! !!Trait methodsFor: 'initialize' stamp: 'ar 11/18/2007 15:41'!rename: aString 	"The new name of the receiver is the argument, aString."	| newName |	(newName := aString asSymbol) ~= self name		ifFalse: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	self environment renameClass: self as: newName.	name := newName! !!Trait methodsFor: 'initialize' stamp: 'ar 3/4/2010 21:11'!setName: aSymbol andRegisterInCategory: categorySymbol environment: aSystemDictionary	(self isValidTraitName: aSymbol) ifFalse: [self error:'Invalid trait name'].	(self environment == aSystemDictionary		and: [self name = aSymbol			and: [self category = categorySymbol]]) ifTrue: [^self].			((aSystemDictionary includesKey: aSymbol) and: [(aSystemDictionary at: aSymbol) ~~ self])		ifTrue: [self error: 'The name ''' , aSymbol , ''' is already used'].	(self environment notNil and: [self name notNil and: [self name ~= aSymbol]]) ifTrue: [		self environment renameClass: self as: aSymbol].		self name: aSymbol.	self environment: aSystemDictionary.		self environment at: self name put: self.	self environment organization classify: self name under: categorySymbol.	^ true! !!Trait methodsFor: 'fileIn/Out' stamp: 'ar 12/19/2009 18:06'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex	super fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex.	self classSide hasMethods ifTrue:[		aFileStream cr; nextPutAll: '"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!!'; cr; cr.			self classSide				fileOutOn: aFileStream				moveSource: moveSource				toFile: fileIndex].! !!Trait methodsFor: 'testing' stamp: 'ar 5/11/2008 01:57'!hasClassTrait	^true! !!Trait methodsFor: 'testing' stamp: 'ar 11/18/2007 22:59'!isBaseTrait	^true! !!Trait methodsFor: 'testing' stamp: 'ar 11/18/2007 15:41'!isObsolete	"Return true if the receiver is obsolete."	^(self environment at: name ifAbsent: [nil]) ~~ self! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:47'!conflict	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7 with: arg8	"This method has a trait conflict"	^self traitConflict! !!ClassTrait class methodsFor: 'instance creation' stamp: 'ar 12/30/2009 01:58'!for: baseTrait	^self new baseTrait: baseTrait! !!Trait class methodsFor: 'public' stamp: 'ar 12/30/2009 02:00'!allTraitsDo: aBlock	"Evaluate aBlock with all the instance and class traits present in the system"	Trait allInstances do: [:aTrait|		aBlock value: aTrait instanceSide.		aBlock value: aTrait classSide.	].! !!Trait class methodsFor: 'public' stamp: 'ar 12/27/2009 14:12'!named: aSymbol uses: aTraitCompositionOrCollection category: aString	"Dispatch through ClassDescription for alternative implementations"	^ClassDescription newTraitNamed: aSymbol uses: aTraitCompositionOrCollection category: aString! !!Trait class methodsFor: 'public' stamp: 'ar 12/27/2009 19:07'!newTemplateIn: categoryString	^String streamContents: [:stream |		stream			nextPutAll: 'Trait named: #NameOfTrait';			cr; tab;			nextPutAll: 'uses: {}';			cr; tab;			nextPutAll: 'category: ';			nextPut: $';			nextPutAll: categoryString;			nextPut: $' ]! !!Trait class methodsFor: 'public' stamp: 'ar 12/29/2009 18:20'!newTraitComposition	"Creates a new TraitComposition"	^TraitComposition new! !!Trait class methodsFor: 'public' stamp: 'ar 12/27/2009 14:11'!newTraitNamed: aSymbol uses: aTraitCompositionOrCollection category: aString	"Creates a new trait."	| env |	env := self environment.	^self		named: aSymbol		uses: aTraitCompositionOrCollection		category: aString		env: env! !!Trait class methodsFor: 'load-unload' stamp: 'ar 3/5/2010 21:10'!convertClassToTrait: aClass	"Convert the given class to a trait"	| aTrait |	"Move the class out of the way"	aClass environment removeKey: aClass name.	"Create the trait in its place"	aTrait := Trait named: aClass name				uses: {}				category: aClass category.	aClass organization commentRemoteStr ifNotNil:[		aTrait classComment: aClass organization classComment 				stamp: aClass organization commentStamp].	aClass selectorsAndMethodsDo:[:sel :meth|		aTrait compile: (aClass sourceCodeAt: sel)			classified: (aClass organization categoryOfElement: sel)			withStamp: (aClass compiledMethodAt: sel) timeStamp			notifying: nil].	aClass classSide selectorsAndMethodsDo:[:sel :meth|		aTrait classSide compile: (aClass classSide sourceCodeAt: sel)			classified: (aClass classSide organization categoryOfElement: sel)			withStamp: (aClass classSide compiledMethodAt: sel) timeStamp			notifying: nil].	aClass obsolete.	^aTrait! !!Trait class methodsFor: 'load-unload' stamp: 'ar 3/5/2010 21:11'!convertTraitToClass: aTrait	"Convert the given trait to a class"	| aClass |	"Move the trait out of the way"	aTrait environment removeKey: aTrait name.	"Create the class in its place"	aClass := Object subclass: aTrait name				instanceVariableNames: ''				classVariableNames: ''				poolDictionaries: ''				category: aTrait category.	aTrait organization commentRemoteStr ifNotNil:[		aClass classComment: aTrait organization classComment 				stamp: aTrait organization commentStamp].	aTrait selectorsAndMethodsDo:[:sel :meth|		aClass compile: (aTrait sourceCodeAt: sel)			classified: (aTrait organization categoryOfElement: sel)			withStamp: (aTrait compiledMethodAt: sel) timeStamp			notifying: nil].	aTrait classSide selectorsAndMethodsDo:[:sel :meth|		aClass classSide compile: (aTrait classSide sourceCodeAt: sel)			classified: (aTrait classSide organization categoryOfElement: sel)			withStamp: (aTrait classSide compiledMethodAt: sel) timeStamp			notifying: nil].	aTrait obsolete.	^aClass! !!Trait class methodsFor: 'load-unload' stamp: 'nice 1/10/2010 17:46'!flattenTraitMethodsInClass: aClass	"Flatten all the trait methods in the given class"		(aClass isTrait or:[aClass hasTraitComposition]) ifFalse:[^self].	self storeTraitInfoInClass: aClass.	aClass selectorsAndMethodsDo:[:sel :meth| | oldClass |		(aClass includesLocalSelector: sel) ifFalse:[			oldClass := meth methodHome.			aClass compile: (aClass sourceCodeAt: sel)				classified: (aClass organization categoryOfElement: sel)				withStamp: (oldClass compiledMethodAt: sel ifAbsent:[meth]) timeStamp				notifying: nil]].	aClass traitComposition: #().! !!Trait class methodsFor: 'load-unload' stamp: 'ar 1/1/2010 20:09'!initialize	"Install after loading"	self install.! !!Trait class methodsFor: 'load-unload' stamp: 'ar 1/1/2010 20:09'!install	"Make me the default Trait implementation"	ClassDescription traitImpl: self.	"And restore any previously flattened traits"	self restoreAllTraits.! !!Trait class methodsFor: 'load-unload' stamp: 'ar 1/1/2010 18:52'!removeAllTraits		"Trait removeAllTraits"	"Removes all traits currently in use. 	Preserves enough information so that traits can be recovered."	| converted remain |	converted := Set new.	Smalltalk allClasses do:[:aClass|		self flattenTraitMethodsInClass: aClass classSide.		self flattenTraitMethodsInClass: aClass.		converted add: aClass.	] displayingProgress: 'Flattening classes'.	remain := Smalltalk allTraits asSet.	(1 to: remain size) do:[:i| | trait |		trait := remain 			detect:[:any| any users allSatisfy:[:aClass| converted includes: aClass]]			ifNone:[self error: 'Cyclic traits detected'].		remain remove: trait.		self flattenTraitMethodsInClass: trait classSide.		self flattenTraitMethodsInClass: trait.		converted add: trait.	] displayingProgress: 'Flattening traits'.	"Convert all traits to classes"	Smalltalk allTraits		do:[:trait| self convertTraitToClass: trait] 		displayingProgress:[:trait| 'Converting ', trait name].! !!Trait class methodsFor: 'load-unload' stamp: 'nice 1/10/2010 17:46'!restoreAllTraits		"Trait restoreAllTraits"	"Restores traits that had been previously removed.	This is the inverse operation to removeAllTraits."	| classes |	classes := Smalltalk allClasses select:[:aClass| aClass includesSelector: #traitInfo].	classes do:[:aClass| | method |		method := aClass compiledMethodAt: #traitInfo.		(method pragmaAt: #traitDefinition:) ifNotNil:[:pragma| 			pragma arguments first				ifTrue:[self convertClassToTrait: aClass]].	] displayingProgress:[:aClass| 'Creating trait ', aClass name].	classes := Smalltalk allClassesAndTraits select:[:aClass| 		(aClass includesSelector: #traitInfo) 			or:[aClass classSide includesSelector: #traitInfo]].	classes do:[:aClass|		self restoreCompositionOf: aClass.		self restoreCompositionOf: aClass classSide.	] displayingProgress:[:aClass| 'Updating ', aClass name].! !!Trait class methodsFor: 'load-unload' stamp: 'ar 1/1/2010 18:24'!restoreCompositionOf: aClass	"Restore the trait composition for the given class"	| method requires composition |	method := aClass compiledMethodAt: #traitInfo ifAbsent:[^self].	aClass removeSelector: #traitInfo.	requires := (method pragmaAt: #traitRequires:) 		ifNil:[#()]		ifNotNil:[:pragma| pragma arguments first].	(requires allSatisfy:[:tn| (Smalltalk at: tn ifAbsent:[nil]) isKindOf: Trait])		ifFalse:[^self inform: 'Cannot restore composition of ', aClass name].	composition := (method pragmaAt: #traitComposition:) 		ifNil:[^self]		ifNotNil:[:pragma| Compiler evaluate: pragma arguments first].	aClass uses: composition.	aClass traitComposition selectorsAndMethodsDo:[:sel :meth|		| oldMethod newMethod |		newMethod := meth methodHome compiledMethodAt: sel.		oldMethod := aClass compiledMethodAt: sel ifAbsent:[newMethod].		oldMethod timeStamp = newMethod timeStamp				ifTrue:[aClass removeSelector: sel]].! !!Trait class methodsFor: 'load-unload' stamp: 'ar 1/1/2010 17:01'!storeTraitInfoInClass: aClass	"Store trait information in the given class"	| code |	code := WriteStream on: (String new: 100).	code nextPutAll: 'traitInfo	"This method contains information to restore the trait structure	for the receiver when traits are loaded or unloaded"'.	aClass isTrait ifTrue:[		code crtab; nextPutAll: '"This class was originally a trait"'.		code crtab; nextPutAll: '<traitDefinition: true>'.	].	aClass hasTraitComposition ifTrue:[		code crtab; nextPutAll: '"The trait composition for the receiver"'.		code crtab; nextPutAll: '<traitComposition: ', aClass traitCompositionString storeString,'>'.		code crtab; nextPutAll: '"The required traits for this trait"'.		code crtab; nextPutAll: '<traitRequires: ', (aClass traits collect:[:t| t baseTrait name]),'>'.	].	aClass compile: code contents.! !!Trait class methodsFor: 'load-unload' stamp: 'ul 1/3/2010 06:27'!unloadTraits	"Trait unloadTraits"	Trait traitImpl == self ifTrue:[Trait traitImpl: nil].	self removeAllTraits.	Behavior compileSilently: 'updateTraits' classified: 'accessing'.	ClassDescription removeSelectorSilently: #updateTraits.	ClassOrganizer organization classify: #traitComposition under: 'accessing'.	(MCPackage named: 'Traits') unload.	ClassOrganizer removeSelectorSilently: #traitComposition.	Behavior removeSelectorSilently: #updateTraits.	Compiler recompileAll.! !!Trait class methodsFor: 'instance creation' stamp: 'ar 12/30/2009 02:00'!named: aSymbol uses: aTraitComposition category: aString env: anEnvironment	| trait oldTrait systemCategory oldCategory |	systemCategory := aString asSymbol.	oldTrait := anEnvironment at: aSymbol ifAbsent: [nil].	oldTrait ifNil:[		trait := Trait new.	] ifNotNil:[		oldCategory := oldTrait category.		trait := oldTrait.	].	(trait isMemberOf: Trait) ifFalse: [		^self error: trait name , ' is not a Trait'].	trait		setName: aSymbol		andRegisterInCategory: systemCategory		environment: anEnvironment.	trait uses: aTraitComposition.		"... notify interested clients ..."	oldTrait ifNil:[		SystemChangeNotifier uniqueInstance classAdded: trait inCategory: systemCategory.	] ifNotNil:[		systemCategory = oldCategory  ifFalse:[			SystemChangeNotifier uniqueInstance class: trait 				recategorizedFrom: oldTrait category to: systemCategory].	].	^ trait! !!TraitMethodState methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!methodHome	"The behavior (trait/class) this method was originally defined in. 	Derived from the originalTraitMethod if any."	^originalTraitMethod ifNil:[super methodHome] ifNotNil:[:m| m methodHome]! !!TraitMethodState methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!originalTraitMethod	"The original method from the trait"	^originalTraitMethod! !!TraitMethodState methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!originalTraitMethod: aCompiledMethod	"The original method from the trait"	originalTraitMethod := aCompiledMethod! !!TraitMethodState methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!originalTraitOrClass	"The original trait for this method"	^originalTraitMethod originalTraitOrClass! !!TraitOrganizer methodsFor: 'testing' stamp: 'ar 12/30/2009 02:48'!isTraitOrganizer	"Answer true if this is a TraitOrganizer"	^true! !!TraitOrganizer methodsFor: 'accessing' stamp: 'ar 12/30/2009 02:47'!traitComposition	"Answer the receiver's trait composition"	^traitComposition ifNil:[traitComposition := TraitComposition new]! !!TraitOrganizer methodsFor: 'accessing' stamp: 'ar 12/30/2009 02:48'!traitComposition: aTraitComposition	"Install the receiver's trait composition"	traitComposition := aTraitComposition.! !!TraitTransformation methodsFor: 'converting' stamp: 'ar 12/29/2009 18:20'!+ aTrait	"Just like ordered collection"	^TraitComposition withAll: {self. aTrait}! !!TraitTransformation methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!- anArrayOfSelectors	^self subclassResponsibility! !!TraitTransformation methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!@ anArrayOfAssociations	^self subclassResponsibility! !!TraitTransformation methodsFor: 'converting' stamp: 'ar 12/29/2009 18:20'!asTraitComposition	^TraitComposition with: self! !!TraitTransformation methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!asTraitTransform	^self! !!TraitTransformation methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!addTraitUser: aTrait	users := users copyWith: aTrait.	subject addTraitUser: aTrait.! !!TraitTransformation methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!allTraits	^subject allTraits! !!TraitTransformation methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!removeTraitUser: aTrait	users := users copyWithout: aTrait.	subject removeTraitUser: aTrait.! !!TraitTransformation methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!subject: aSubject	subject := aSubject.! !!TraitTransformation methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!trait	^subject trait! !!TraitTransformation methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!traitsDo: aBlock	^subject traitsDo: aBlock! !!TraitTransformation methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!copyTraitExpression	"Copy all except the actual traits"	^self subclassResponsibility! !!TraitTransformation methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	^self subclassResponsibility! !!TraitTransformation methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!updateSelector: aSelector withTraitMethod: compiledMethod from: aTrait	"broadcasts the change of a selector to all users of a trait"	^self subclassResponsibility! !!TraitTransformation methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!updateTraits	"Recompute my users traits composition"	users do:[:each| each updateTraits].! !!TraitTransformation methodsFor: 'testing' stamp: 'ar 12/29/2009 18:11'!includesTrait: aTrait	^subject includesTrait: aTrait! !!TraitTransformation methodsFor: 'testing' stamp: 'ar 12/29/2009 18:11'!isAliasSelector: selector	^subject isAliasSelector: selector! !!TraitTransformation methodsFor: 'testing' stamp: 'ar 12/29/2009 18:11'!isLocalAliasSelector: selector	^false! !!TraitTransformation methodsFor: 'testing' stamp: 'ar 12/29/2009 18:11'!isTraitTransformation	"Polymorphic with Trait"	^true! !!TraitTransformation methodsFor: 'initialize' stamp: 'ar 12/29/2009 18:11'!initialize	super initialize.	users := #().! !!TraitAlias methodsFor: 'converting' stamp: 'ar 12/29/2009 18:22'!- anArrayOfSelectors	^TraitExclusion		with: self		exclusions: anArrayOfSelectors! !!TraitAlias methodsFor: 'converting' stamp: 'ar 12/29/2009 18:17'!@ anArrayOfAssociations 	^TraitAlias 		with: subject		aliases: (anArrayOfAssociations, self aliases)! !!TraitAlias methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:14'!aliases	"Collection of associations where key is the	alias and value the original selector."	^aliases! !!TraitAlias methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:14'!aliases: aCollection	"Collection of associations where key is the	alias and value the original selector."	aliases := aCollection! !!TraitAlias methodsFor: 'operations' stamp: 'ar 12/29/2009 18:17'!copyTraitExpression	"Copy all except the actual traits"	^TraitAlias 		with: subject		aliases: aliases! !!TraitAlias methodsFor: 'operations' stamp: 'ar 12/29/2009 18:14'!includesSelector: selector	"Answers true if the receiver provides the selector"	^(subject includesSelector: selector) or:[aliases anySatisfy:[:assoc| assoc key == selector]]! !!TraitAlias methodsFor: 'operations' stamp: 'ar 12/29/2009 18:14'!printOn: s	"Answer the trait composition string (used for class definitions)"	s nextPutAll: subject asString.	s nextPutAll: ' @ {'.	aliases do:[:assoc| s print: assoc] separatedBy:[s nextPutAll:'. '].	s nextPutAll: '}'.! !!TraitAlias methodsFor: 'operations' stamp: 'ar 12/29/2009 18:14'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	subject selectorsAndMethodsDo:[:sel :meth|		aBlock value: sel value: meth.	].	aliases do:[:assoc| | method |		"Method can be nil during removals"		method := subject compiledMethodAt: assoc value ifAbsent:[nil].		method ifNotNil:[aBlock value: assoc key value: method].	].! !!TraitAlias methodsFor: 'initialize-release' stamp: 'ar 12/29/2009 18:14'!initialize	super initialize.	aliases := #().! !!TraitAlias methodsFor: 'initialize-release' stamp: 'ar 12/29/2009 18:21'!initializeFrom: anArrayOfAssociations	| newNames |	newNames := (anArrayOfAssociations collect: [:each | each key]) asIdentitySet.	newNames size < anArrayOfAssociations size ifTrue: [		TraitCompositionException signal: 'Cannot use the same alias name twice'].	anArrayOfAssociations do: [:each |		(newNames includes: each value) ifTrue: [			TraitCompositionException signal: 'Cannot define an alias for an alias']].	aliases := anArrayOfAssociations.! !!TraitAlias methodsFor: 'testing' stamp: 'ar 12/29/2009 18:14'!isAliasSelector: selector	^(self isLocalAliasSelector: selector) or:[super isAliasSelector: selector]! !!TraitAlias methodsFor: 'testing' stamp: 'ar 12/29/2009 18:14'!isLocalAliasSelector: selector	^(aliases anySatisfy:[:assoc| assoc key == selector])! !!TraitAlias class methodsFor: 'instance creation' stamp: 'ar 12/29/2009 18:21'!assertValidAliasDefinition: anArrayOfAssociations	"Throw an exceptions if the alias definition is not valid.	It is expected to be a collection of associations and	the number of arguments of the alias selector has to	be the same as the original selector."	((anArrayOfAssociations isKindOf: Collection) and: [		anArrayOfAssociations allSatisfy: [:each |			each isKindOf: Association]]) ifFalse: [		self error: 'Invalid alias definition: Not a collection of associations.'].		(anArrayOfAssociations allSatisfy: [:association |		(association key numArgs = association value numArgs and: [			(association key numArgs = -1) not])]) ifFalse: [		TraitCompositionException signal: 'Invalid alias definition: Alias and original selector have to have the same number of arguments.']! !!TraitAlias class methodsFor: 'instance creation' stamp: 'ar 12/29/2009 18:14'!with: aTraitComposition aliases: anArrayOfAssociations	self assertValidAliasDefinition: anArrayOfAssociations.	^self new		subject: aTraitComposition;		initializeFrom: anArrayOfAssociations;		yourself! !!TraitExclusion methodsFor: 'converting' stamp: 'ar 12/29/2009 18:22'!- anArrayOfSelectors	^TraitExclusion		with: subject		exclusions: (anArrayOfSelectors, exclusions asArray)! !!TraitExclusion methodsFor: 'converting' stamp: 'ar 12/29/2009 18:21'!@ anArrayOfAssociations 	TraitCompositionException signal: 'Invalid trait exclusion. Aliases have to be specified before exclusions.'! !!TraitExclusion methodsFor: 'composition' stamp: 'ar 12/29/2009 18:22'!copyTraitExpression	"Copy all except the actual traits"	^TraitExclusion 		with: subject		exclusions: exclusions asArray! !!TraitExclusion methodsFor: 'composition' stamp: 'ar 12/29/2009 18:11'!includesSelector: selector	"Answers true if the receiver provides the selector"	^(subject includesSelector: selector) and:[(exclusions includes: selector) not]! !!TraitExclusion methodsFor: 'composition' stamp: 'ar 12/29/2009 18:11'!printOn: aStream	"Answer the trait composition string (used for class definitions)"	aStream nextPutAll: subject asString.	aStream nextPutAll: ' - {'.	exclusions asArray sort do:[:exc| aStream store: exc] separatedBy:[aStream nextPutAll: '. '].	aStream nextPutAll: '}'.! !!TraitExclusion methodsFor: 'composition' stamp: 'ar 12/29/2009 18:11'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	^subject selectorsAndMethodsDo:[:sel :meth|		(exclusions includes: sel) ifFalse:[aBlock value: sel value: meth].	].! !!TraitExclusion methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!exclusions	^exclusions! !!TraitExclusion methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!exclusions: aCollection	exclusions := Set withAll: aCollection! !!TraitExclusion methodsFor: 'initialize' stamp: 'ar 12/29/2009 18:11'!initialize	super initialize.	exclusions := Set new.! !!TraitExclusion class methodsFor: 'instance creation' stamp: 'ar 12/29/2009 18:11'!with: aTraitComposition exclusions: anArrayOfSelectors	^self new		subject: aTraitComposition;		exclusions: anArrayOfSelectors;		yourself! !Trait initialize!