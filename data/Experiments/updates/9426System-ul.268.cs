'From Squeak3.11alpha of 13 February 2010 [latest update: #9483] on 9 March 2010 at 11:11:23 am'!OrderedCollection subclass: #ObjectFinalizerCollection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Finalization'!!ObjectFinalizerCollection commentStamp: 'ul 2/26/2010 14:23' prior: 0!An ObjectFinalizerCollection is simple collection which is intended to hold ObjectFinalizers and be used by WeakRegistry.!Object subclass: #TextDiffBuilder	instanceVariableNames: 'xLines yLines '	classVariableNames: 'InsertTextAttributes NormalTextAttributes RemoveTextAttributes IgnoreLineEndings '	poolDictionaries: ''	category: 'System-FilePackage'!!TextDiffBuilder commentStamp: 'klub 12/28/2009 05:06' prior: 0!I implement the diff algorithm. I can show the differences between two texts. See my method comments for further information.Instance Variables	xLines:		<Array>	yLines:		<Array>xLines	- an Array of DiffElement which is created from the first input textyLines	- an Array of DiffElement which is created from the second input text!!CodeLoader methodsFor: 'installing' stamp: 'ar 12/22/1999 15:02'!installSourceFiles	"Install the previously loaded source files"	sourceFiles == nil ifTrue:[^self].	sourceFiles do:[:req| self installSourceFile: req contentStream].	sourceFiles := nil.! !!MessageTally class methodsFor: 'spying' stamp: 'ul 2/24/2010 00:06'!spyOn: aBlock toFileNamed: fileName reportOtherProcesses: aBoolean	"Spy on the evaluation of aBlock. Write the data collected on a file	named fileName."	| value node |	node := self new.	node reportOtherProcesses: aBoolean.	value := node spyEvery: self defaultPollPeriod on: aBlock.	FileStream newFileNamed: fileName do: [ :file |		node report: file ].	^value! !!MessageTally class methodsFor: 'spying' stamp: 'ul 2/24/2010 00:06'!spyOnProcess: aProcess forMilliseconds: msecDuration toFileNamed: fileName reportOtherProcesses: aBoolean	"Spy on the evaluation of aProcess. Write the data collected on a file  	named fileName. Will overwrite fileName"	| node |	node := self new.	node reportOtherProcesses: aBoolean.	node		spyEvery: self defaultPollPeriod		onProcess: aProcess		forMilliseconds: msecDuration.	FileStream fileNamed: fileName do: [ :file |		node report: file ]! !!MessageTally class methodsFor: 'spying' stamp: 'ul 2/24/2010 00:06'!tallySendsTo: receiver inBlock: aBlock showTree: treeOption	"	MessageTally tallySends: [3.14159 printString]	"	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. If receiver is not nil, then only sends	to that receiver are tallied.	Results are presented as leaves, sorted by frequency,	preceded, optionally, by the whole tree."	| prev tallies startTime totalTime |	startTime := Time millisecondClockValue.	tallies := MessageTally new class: aBlock receiver class method: aBlock method.	tallies reportOtherProcesses: true.	"Do NOT filter nodes with nil process"	prev := aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep: [ :current |			current == prev ifFalse: [ "call or return"				prev sender == nil ifFalse: [ "call only"					(receiver == nil or: [ current receiver == receiver ])						ifTrue: [ tallies tally: current by: 1 ] ].				prev := current ] ].	totalTime := Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.	(StringHolder new contents:		(String streamContents:			[:s |			s nextPutAll: 'This simulation took ' , totalTime printString							, ' seconds.'; cr.			treeOption				ifTrue: [ tallies fullPrintExactOn: s ]				ifFalse: [ tallies leavesPrintExactOn: s ] ]))		openLabel: 'Spy Results'! !!ObjectFinalizerCollection methodsFor: 'finalization' stamp: 'ul 2/25/2010 16:53'!finalize	"Finalize all elements in this collection. The elements are expected to be ObjectFinalizers, but can be any object which understands #finalize."	self do: #finalize! !!Project methodsFor: 'file in/out' stamp: 'nice 1/18/2010 19:07'!writeFileNamed: localFileName fromDirectory: localDirectory toServer: primaryServerDirectory	| local resp gifFileName f |	local := localDirectory oldFileNamed: localFileName.	resp := primaryServerDirectory upLoadProject: local named: localFileName resourceUrl: self resourceUrl retry: false.	local close.	resp == true ifFalse: [		"abandon resources that would've been stored with the project"		self resourceManager abandonResourcesThat:			[:loc| loc urlString beginsWith: self resourceUrl].		self error: 'the primary server of this project seems to be down (',							resp printString,')'. 		^ self	].	gifFileName := self name,'.gif'.	localDirectory deleteFileNamed: gifFileName ifAbsent: [].	local := localDirectory fileNamed: gifFileName.	thumbnail ifNil: [		(thumbnail := Form extent: 100@80) fillColor: Color orange	] ifNotNil: [		thumbnail unhibernate.	].	f := thumbnail colorReduced.  "minimize depth"	f depth > 8 ifTrue: [		f := thumbnail asFormOfDepth: 8	].	GIFReadWriter putForm: f onStream: local.	local close.	[local := StandardFileStream readOnlyFileNamed: (localDirectory fullNameFor: gifFileName).	(primaryServerDirectory isKindOf: FileDirectory)		ifTrue: [primaryServerDirectory deleteFileNamed: gifFileName ifAbsent: []].	primaryServerDirectory putFile: local named: gifFileName retry: false.	] on: Error do: [:ex |].	local close.	primaryServerDirectory updateProjectInfoFor: self.	primaryServerDirectory sleep.	"if ftp, close the connection"! !!SARInstaller methodsFor: 'client services' stamp: 'nice 1/18/2010 19:08'!fileInGenieDictionaryNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as Genie gesture dictionaries.	Answers a dictionary."	| member object crDictionary stream |	crDictionary := Smalltalk at: #CRDictionary ifAbsent: [ ^self error: 'Genie not installed' ].	"don't know how to recursively load"	member := self memberNamed: memberName.	member ifNil: [ ^self errorNoSuchMember: memberName ].	stream := ReferenceStream on: member contentStream.	object := [ stream next ]		on: Error do: 		[:ex |  stream close.		self inform: 'Error on loading: ' , ex description. ^ nil ].	stream close.	(object notNil and: [object name isEmptyOrNil])		ifTrue: [object := crDictionary name: object storedName].	self installed: member.	^ object! !!SARInstaller methodsFor: 'fileIn' stamp: 'nice 1/13/2010 08:46'!fileIn	"File in to a change set named like my file"	directory readOnlyFileNamed: fileName do: [:stream |		| newCS |		newCS := self class withCurrentChangeSetNamed: fileName			do: [:cs | self fileInFrom: stream].		newCS isEmpty ifTrue: [ ChangeSet removeChangeSet: newCS ]]! !!SecureHashAlgorithm methodsFor: 'public' stamp: 'ar 2/25/2010 23:40'!hashStream: aPositionableStream	"Hash the contents of the given stream from the current position to the end using the Secure Hash Algorithm. The SHA algorithm is defined in FIPS PUB 180-1. It is also described on p. 442 of 'Applied Cryptography: Protocols, Algorithms, and Source Code in C' by Bruce Scheier, Wiley, 1996."	"SecureHashAlgorithm new hashStream: (ReadStream on: 'foo')"	| startPosition buf bitLength |	self initializeTotals.	"(SecureHashAlgorithm new hashMessage: '') radix: 16 		=> 'DA39A3EE5E6B4B0D3255BFEF95601890AFD80709'"	aPositionableStream atEnd ifTrue: [self processFinalBuffer: #() bitLength: 0].	startPosition := aPositionableStream position.	[aPositionableStream atEnd] whileFalse: [		buf := aPositionableStream next: 64.		(aPositionableStream atEnd not and: [buf size = 64])			ifTrue: [self processBuffer: buf]			ifFalse: [				bitLength := (aPositionableStream position - startPosition) * 8.				self processFinalBuffer: buf bitLength: bitLength]].	^ self finalHash! !!SharedPool class methodsFor: 'name lookup' stamp: 'nice 2/8/2010 09:43'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		| poolBinding |		poolBinding := pool bindingOf: aSymbol.		poolBinding ifNotNil:[^poolBinding].	].	"subclassing and environment are not preserved"	^nil! !!TextDiffBuilder methodsFor: 'private' stamp: 'nice 2/25/2010 03:58'!split: aString	"I return an Array of strings which are the lines extracted from aString. All lines contain the line separator characters, or not depending on preference."	^Array streamContents: [ :stream |		self class ignoreLineEndings			ifTrue: [aString lineIndicesDo: [ :start :endWithoutSeparators :end |				stream nextPut: (aString copyFrom: start to: endWithoutSeparators) ] ]			ifFalse: [aString lineIndicesDo: [ :start :endWithoutSeparators :end |				stream nextPut: (aString copyFrom: start to: end) ] ] ]! !!TextDiffBuilder class methodsFor: 'preferences' stamp: 'nice 2/25/2010 04:07'!ignoreLineEndings	"Answer a boolean telling if line endings differences should be ignored or emphasized"		<preference: 'ignoreLineEndings'		category: 'TextDiff'		description: 'When enabled, source code differences in line endings will be ignored.'		type: #Boolean>	^IgnoreLineEndings ifNil: [ false ]! !!TextDiffBuilder class methodsFor: 'preferences' stamp: 'nice 2/25/2010 03:57'!ignoreLineEndings: aBoolean	"Set the preference telling if line endings differences should be ignored or emphasized"		IgnoreLineEndings := aBoolean! !Object subclass: #TextDiffBuilder	instanceVariableNames: 'xLines yLines'	classVariableNames: 'IgnoreLineEndings InsertTextAttributes NormalTextAttributes RemoveTextAttributes'	poolDictionaries: ''	category: 'System-FilePackage'!CodeLoader removeSelector: #installLastMonticelloFor:!CodeLoader removeSelector: #installMonticelloFor:!CodeLoader removeSelector: #lookLastVersion:!CodeLoader removeSelector: #lookMonticelloVersion:!CodeLoader removeSelector: #segments!CodeLoader removeSelector: #tryVersion:!