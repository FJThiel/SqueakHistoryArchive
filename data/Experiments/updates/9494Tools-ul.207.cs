'From Squeak3.11alpha of 13 February 2010 [latest update: #9499] on 15 March 2010 at 8:32:30 am'!!Browser methodsFor: 'metaclass' stamp: 'laza 3/9/2010 15:54'!indicateClassMessages	"Indicate that the message selection should come from the metaclass 	messages."	self okToChange ifTrue: [		self metaClassIndicated: true]! !!Browser methodsFor: 'metaclass' stamp: 'laza 3/9/2010 15:54'!indicateInstanceMessages	"Indicate that the message selection should come from the class (instance) 	messages."	self okToChange ifTrue: [		self metaClassIndicated: false]! !!DependencyBrowser methodsFor: 'package list' stamp: 'ul 3/8/2010 01:41'!packageList	"The base list of packages in the system"	^packageList ifNil:[packageList := (PackageInfo allPackages collect: [ :each | each packageName]) sort]! !!MessageSet methodsFor: 'filtering' stamp: 'cmm 3/9/2010 09:23'!filterToCurrentAuthor	"Filter down only to messages with my initials as most recent author"	self filterFrom:		[:aClass :aSelector | | aMethod aTimeStamp |			(aClass notNil and: [aSelector notNil]) and:							[aMethod := aClass compiledMethodAt: aSelector ifAbsent: [nil].				aMethod notNil and:					[(aTimeStamp := Utilities timeStampForMethod: aMethod) notNil and:						[aTimeStamp beginsWith: Utilities authorInitials]]]]! !!MessageSet methodsFor: 'filtering' stamp: 'cmm 3/9/2010 14:57'!filterToNotCurrentAuthor	"Filter down only to messages not stamped with my initials"	self filterFrom:		[:aClass :aSelector | | aTimeStamp aMethod |			(aClass notNil and: [aSelector notNil]) and:							[aMethod := aClass compiledMethodAt: aSelector ifAbsent: [nil].				aMethod notNil and:					[(aTimeStamp := Utilities timeStampForMethod: aMethod) isNil or:						[(aTimeStamp beginsWith: Utilities authorInitials) not]]]]! !!MessageSet methodsFor: 'private' stamp: 'cmm 3/4/2010 19:46'!setFilteredList: newList 	"Establish newList as the new list if appropriate, and adjust the window title accordingly; if the new list is of the same size as the old, warn and do nothing"	newList size == 0 ifTrue:		[ self inform: 'Nothing would be left in the list if you did that'.		^false ].	newList size == messageList size ifTrue:		[ self inform: 'That leaves the list unchanged'.		^false ].	self		 initializeMessageList: newList ;		 adjustWindowTitleAfterFiltering.	^true! !!MessageTrace methodsFor: 'building' stamp: 'cmm 3/8/2010 14:44'!removeMessageFromBrowser	| indexToSelect |	indexToSelect := (messageSelections indexOf: true) max: 1.	self selectedMessages do: [ :eachMethodReference | self deleteFromMessageList: eachMethodReference ].	self deselectAll.	messageSelections ifNotEmpty:		[ messageSelections 			at: (indexToSelect min: messageSelections size)  "safety"			put: true ].	anchorIndex := messageListIndex := indexToSelect.	self reformulateList! !!MessageTrace methodsFor: 'filtering' stamp: 'cmm 3/4/2010 19:47'!filterFrom: aBlock	"Filter the receiver's list down to only those items that satisfy aBlock, which takes a class an a selector as its arguments."	| newList newAutoSelectStrings newMessageSelections |	newList := messageList class new.	newAutoSelectStrings := autoSelectStrings class new.	newMessageSelections := messageSelections class new.	messageList withIndexDo:		[ :each :index |		(self class parse: each toClassAndSelector: aBlock)			ifTrue:				[ newList add: each.				newAutoSelectStrings add: (autoSelectStrings at: index).				newMessageSelections add: (messageSelections at: index) ] ].	(self setFilteredList: newList)		ifTrue: [ autoSelectStrings := newAutoSelectStrings ]! !