'From Squeak3.11alpha of 13 February 2010 [latest update: #9483] on 9 March 2010 at 11:11:23 am'!!ClassDescription methodsFor: 'private' stamp: 'ar 3/4/2010 23:39'!logMethodSource: aText forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor	| priorMethodOrNil newText |	priorMethodOrNil := self compiledMethodAt: aCompiledMethodWithNode selector ifAbsent: [].	newText := (requestor notNil						and: [Preferences confirmFirstUseOfStyle])			ifTrue: [aText askIfAddStyle: priorMethodOrNil req: requestor]			ifFalse: [aText].	aCompiledMethodWithNode method putSource: newText		fromParseNode: aCompiledMethodWithNode node		class: self category: category withStamp: changeStamp 		inFile: 2 priorMethod: priorMethodOrNil.! !!Process methodsFor: 'changing process state' stamp: 'ar 3/3/2010 17:53'!terminate 	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."	| ctxt unwindBlock oldList |	self isActiveProcess ifTrue: [		ctxt := thisContext.		[	ctxt := ctxt findNextUnwindContextUpTo: nil.			ctxt isNil		] whileFalse: [			(ctxt tempAt: 2) ifNil:[				ctxt tempAt: 2 put: nil.				unwindBlock := ctxt tempAt: 1.				thisContext terminateTo: ctxt.				unwindBlock value].		].		thisContext terminateTo: nil.		self suspend.	] ifFalse:[		"Always suspend the process first so it doesn't accidentally get woken up"		oldList := self suspend.		suspendedContext ifNotNil:[			"Figure out if we are terminating the process while waiting in Semaphore>>critical:			In this case, pop the suspendedContext so that we leave the ensure: block inside			Semaphore>>critical: without signaling the semaphore."			(oldList class == Semaphore and:[				suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue:[					suspendedContext := suspendedContext home.			].			"If we are terminating a process halfways through an unwind, try			to complete that unwind block first."			(suspendedContext findNextUnwindContextUpTo: nil) ifNotNil:[:outer|				(suspendedContext findContextSuchThat:[:c| c closure == (outer tempAt: 1)]) ifNotNil:[:inner|					"This is an unwind block currently under evaluation"					suspendedContext runUntilErrorOrReturnFrom: inner.				].			].			ctxt := self popTo: suspendedContext bottomContext.			ctxt == suspendedContext bottomContext ifFalse: [				self debug: ctxt title: 'Unwind error during termination']].	].! !