'From Squeak3.9alpha of 4 July 2005 [latest update: #7054] on 7 September 2006 at 11:22:45 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."Smalltalk condenseSources.SystemVersion current version: 'Squeak3.9gamma'; date: '23 July 2006'.self inform: 'The version number for this image hasnow been advanced to Squeak3.9gamma.'!----End fileIn of a stream----!"empty cs to bump cs number to 7056"!----End fileIn of a stream----!----SNAPSHOT----an Array(7 September 2006 11:23:23 pm) Squeak3.9b-7053.image priorSource: 0!----QUIT/NOSAVE----an Array(7 September 2006 11:23:29 pm) Squeak3.9b-7053.image priorSource: 670!----STARTUP----an Array(7 September 2006 11:23:48 pm) as Macintosh:Users:ducasse:Desktop:Squeak3.9b-7053:Squeak3.9b-7053.image!----SNAPSHOT----an Array(7 September 2006 11:28:13 pm) Squeak3.9b-7056.image priorSource: 670!----QUIT/NOSAVE----an Array(7 September 2006 11:28:23 pm) Squeak3.9b-7056.image priorSource: 993!----STARTUP----an Array(7 September 2006 11:28:50 pm) as Macintosh:Users:ducasse:Desktop:Squeak3.9g-7056:Squeak3.9b-7056.image!----SNAPSHOT----an Array(7 September 2006 11:28:55 pm) Squeak3.9g-7056.image priorSource: 993!----QUIT/NOSAVE----an Array(7 September 2006 11:29 pm) Squeak3.9g-7056.image priorSource: 1318!----STARTUP----an Array(7 September 2006 11:29:10 pm) as Macintosh:Users:ducasse:Desktop:Squeak3.9g-7056:Squeak3.9g-7056.image!----QUIT----an Array(7 September 2006 11:30 pm) Squeak3.9g-7056.image priorSource: 1318!----STARTUP----an Array(10 September 2006 8:06:33 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7057/Squeak3.9g-7056.image!!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/8/2006 20:59'!cleaningCS	"self new cleaningCS" 	 	ChangeSorter removeChangeSetsNamedSuchThat: [:each | true].	ChangeSet resetCurrentToNewUnnamedChangeSet ! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/8/2006 20:59' prior: 29494449!currentPackages	"ScriptLoader new currentPackages" 			| copies |	copies := MCWorkingCopy allManagers asSortedCollection:		[ :a :b | a package name <= b package name ].	^ copies select: [:each | '*Plus*' match: each package name ].! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 21:06'!script84	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.96.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 20:55'!script84Log	"adding way to reset current CS"! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/8/2006 20:53'!updateFrom7056	"self new updateFrom7056"			self script84.	"include changeset extension"	self cleaningCS.		self flushCaches.! !"ScriptLoader"!!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 9/8/2006 21:05'!resetCurrentToNewUnnamedChangeSet 	current := self new.  	self newChanges: current ! !"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.305.mcz') load.ScriptLoader new updateFrom7056.!----End fileIn of a stream----!----SNAPSHOT----an Array(10 September 2006 8:13:08 pm) Squeak3.9g-7056.image priorSource: 1641!----SNAPSHOT----an Array(10 September 2006 8:13:23 pm) Squeak3.9g-7057.image priorSource: 4851!----QUIT----an Array(10 September 2006 8:13:29 pm) Squeak3.9g-7057.image priorSource: 4948!----STARTUP----an Array(14 September 2006 9:30:35 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7057/Squeak3.9g-7057.image!!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/14/2006 20:33' prior: 29495067!generateCS: extensionAndNumber fromUpdate: updateNumber on: st		st nextPutAll:'"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: ''http://source.squeakfoundation.org/39a''                user: ''''                password: ''''.(repository loadVersionFromFileNamed:' .	st nextPut: $' ; nextPutAll: 'ScriptLoader', extensionAndNumber, '.mcz'') load.'; cr.	st nextPutAll: 'ScriptLoader new updateFrom', (updateNumber-1) asString; nextPutAll: '.' ; cr.	st nextPutAll: '!!'.	^ st contents! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/14/2006 20:33'!script85	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.97.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/14/2006 21:10'!updateFrom7057	"self new updateFrom7057"			self script85.	"fix windowColorRegistry"	ServicePreferences wipe.	ServiceRegistry rebuild.	WindowColorRegistry refresh.	self cleaningCS.		self flushCaches.! !"ScriptLoader"!!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:07' prior: 50891697!refresh	"This is a one-time only method for bootstraping the new registry. Here we will scan all classes for #windowColorSpecification methods and register those to the registry"	registry := nil.	((self systemNavigation allClassesImplementing: #windowColorSpecification)		collect: [:aClass | aClass theNonMetaClass windowColorSpecification])		do: [:spec | self registerColorSpecification: spec toClassNamed: spec classSymbol ].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11' prior: 50892769!registry	^registry ifNil: [registry := Dictionary new].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11'!unregisterColorSpecificationForClassNamed: aClassName		self registry removeKey: aClassName asSymbol ! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:12' prior: 27893618!setWindowColorFor: modelSymbol to: incomingColor	| aColor aPrefSymbol aColorSpec |	aColorSpec := WindowColorRegistry registeredWindowColorSpecFor: modelSymbol.	aColorSpec ifNil: [^self].	aColor := incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor or: [aColor = Color black]) 		ifTrue: [^ self].		aPrefSymbol :=  self windowColorPreferenceForClassNamed: aColorSpec classSymbol.	self 		addPreference: aPrefSymbol  		categories:  { #'window colors' }		default:  aColor 		balloonHelp: aColorSpec helpMessage translated		projectLocal: false		changeInformee: nil		changeSelector: nil		viewRegistry: (PreferenceViewRegistry registryOf: #windowColorPreferences)! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:13' prior: 27894402!windowColorFor: aModelClassName	| classToCheck prefSymbol |	self checkForWindowColors.	classToCheck := Smalltalk at: aModelClassName.	prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name.	[(classToCheck ~~ Object) and: [(self preferenceAt: prefSymbol) isNil]]		whileTrue: 				[classToCheck := classToCheck superclass.				prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name].	^self valueOfPreference: prefSymbol ifAbsent: [Color white].! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:14' prior: 27896694!windowSpecificationPanel	"Put up a panel for specifying window colors"	"Preferences windowSpecificationPanel"	| aPanel buttonRow aButton aRow aSwatch aColor aWindow aMiniWorld aStringMorph |	aPanel := AlignmentMorph newColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap;		layoutInset: 0.	aPanel addMorph: (buttonRow := AlignmentMorph newRow color: (aColor := Color tan lighter)).		buttonRow addTransparentSpacerOfSize: 2@0.	buttonRow addMorphBack: (SimpleButtonMorph new label: '?'; target: self; actionSelector: #windowColorHelp; setBalloonText: 'Click for an explanation of this panel'; color: Color veryVeryLightGray; yourself).	buttonRow addTransparentSpacerOfSize: 8@0.	#(	('Bright' 	installBrightWindowColors	yellow					'Use standard bright colors for all windows.')		('Pastel'		installPastelWindowColors	paleMagenta					'Use standard pastel colors for all windows.')		('White'	installUniformWindowColors		white					'Use white backgrounds for all standard windows.')) do:		[:quad |			aButton := (SimpleButtonMorph new target: self)				label: quad first;				actionSelector: quad second;				color: (Color colorFrom: quad third);				setBalloonText: quad fourth;				yourself.			buttonRow addMorphBack: aButton.			buttonRow addTransparentSpacerOfSize: 10@0].	self windowColorTable do:		[:colorSpec | 			aRow _ AlignmentMorph newRow color: aColor.			aSwatch _ ColorSwatch new				target: self;				getSelector: #windowColorFor:;				putSelector: #setWindowColorFor:to:;				argument: colorSpec classSymbol;				extent: (40 @ 20);				setBalloonText: 'Click here to change the standard color to be used for ', colorSpec wording, ' windows.';				yourself.			aRow addMorphFront: aSwatch.			aRow addTransparentSpacerOfSize: (12 @ 1).			aRow addMorphBack: (aStringMorph := StringMorph contents: colorSpec wording font: TextStyle defaultFont).			aStringMorph setBalloonText: colorSpec helpMessage.			aPanel addMorphBack: aRow].	 Smalltalk isMorphic                ifTrue:                        [aWindow := aPanel wrappedInWindowWithTitle: 'Window Colors'.					" don't allow the window to be picked up by clicking inside "					aPanel on: #mouseDown send: #yourself to: aPanel.					self currentWorld addMorphCentered: aWindow.					aWindow activateAndForceLabelToShow ]                ifFalse:                        [(aMiniWorld := MVCWiWPasteUpMorph newWorldForProject: nil)						addMorph: aPanel.                           aMiniWorld startSteppingSubmorphsOf: aPanel.                        MorphWorldView openOn: aMiniWorld                                label: 'Window Colors'                                extent: aMiniWorld fullBounds extent]! !"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.309.mcz') load.ScriptLoader new updateFrom7057.!----End fileIn of a stream----!----SNAPSHOT----an Array(14 September 2006 9:32:22 pm) Squeak3.9g-7058.image priorSource: 5045!----QUIT/NOSAVE----an Array(14 September 2006 9:32:27 pm) Squeak3.9g-7058.image priorSource: 13446!----STARTUP----an Array(22 September 2006 2:45:56 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7058 2/Squeak3.9g-7058.image!!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/18/2006 13:29'!updateFrom7058	"self new updateFrom7058"			(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . ! !"ScriptLoader"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.310.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7059] on 18 September 2006 at 1:43:17 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . !----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46' prior: 33568303!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !"ScriptLoader"!!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'wiz 8/13/2006 17:55'!testInitialChangeSet	"Run this to assure the initial changeset is named. Checks bug found in 3.9 7052."	"self new testInitialChangeSet"	"self run:  #testInitialChangeSet"	self deny: (ChangeSet current printString = 'a ChangeSet named <no name -- garbage?>') .	^true! !!ChangeSet class methodsFor: 'current changeset' stamp: 'wiz 9/19/2006 03:21' prior: 18299908!current	"return the current changeset	assure first that we have a named changeset. To cure mantis #4535. "	current isMoribund		ifTrue: [(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed'))] .	^ current! !!RequiredSelectors methodsFor: 'access to cache' stamp: 'dvf 9/18/2006 22:04' prior: 28614021!calculateForClass: aClass 	| rscc |	self clearOut: aClass.	rscc := RequiredSelectorsChangesCalculator onModificationOf: { aClass }				withTargets: { aClass }.	rscc doWork! !!ATestCase methodsFor: 'as yet unclassified' stamp: 'dvf 9/18/2006 21:28'!testRequirement  "  self debug: #testRequirement  "  | class |  class := Object            subclass: #AClassForTest            instanceVariableNames: ''            classVariableNames: ''            poolDictionaries: ''            category: self class category.  [   class compile: 'call                    ^ self isCalled'.   self assert: (class requiredSelectors includes: #isCalled).   class compile: 'isCalled                    ^ 1'.   "Fail here:"   self deny: (class requiredSelectors includes: #isCalled)]  ensure: [class removeFromSystem] ! !"System"!"Tests"!"Traits"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.311.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!!AClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 9/22/2006 14:49'!call                    ^ self isCalled! !!AClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 9/22/2006 14:49'!isCalled                    ^ 1! !Smalltalk removeClassNamed: #AClassForTest!testRequirement  "  self debug: #testRequirement!!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/18/2006 13:29' prior: 33570915!updateFrom7058	"self new updateFrom7058"			(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . ! !ScriptLoader removeSelector: #script86!"ScriptLoader"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.310.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7059] on 18 September 2006 at 1:43:17 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . !----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46' prior: 33573645!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !"ScriptLoader"!----QUIT/NOSAVE----an Array(22 September 2006 2:53:01 pm) Squeak3.9g-7058.image priorSource: 13446!----STARTUP----an Array(22 September 2006 2:53:09 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7058 2/Squeak3.9g-7058.image!!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/18/2006 13:29'!updateFrom7058	"self new updateFrom7058"			(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . ! !"ScriptLoader"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.310.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7059] on 18 September 2006 at 1:43:17 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . !----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46' prior: 33576725!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !"ScriptLoader"!!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'wiz 8/13/2006 17:55'!testInitialChangeSet	"Run this to assure the initial changeset is named. Checks bug found in 3.9 7052."	"self new testInitialChangeSet"	"self run:  #testInitialChangeSet"	self deny: (ChangeSet current printString = 'a ChangeSet named <no name -- garbage?>') .	^true! !!ChangeSet class methodsFor: 'current changeset' stamp: 'wiz 9/19/2006 03:21' prior: 18299908!current	"return the current changeset	assure first that we have a named changeset. To cure mantis #4535. "	current isMoribund		ifTrue: [(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed'))] .	^ current! !!RequiredSelectors methodsFor: 'access to cache' stamp: 'dvf 9/18/2006 22:04' prior: 28614021!calculateForClass: aClass 	| rscc |	self clearOut: aClass.	rscc := RequiredSelectorsChangesCalculator onModificationOf: { aClass }				withTargets: { aClass }.	rscc doWork! !!ATestCase methodsFor: 'as yet unclassified' stamp: 'dvf 9/18/2006 21:28'!testRequirement  "  self debug: #testRequirement  "  | class |  class := Object            subclass: #AClassForTest            instanceVariableNames: ''            classVariableNames: ''            poolDictionaries: ''            category: self class category.  [   class compile: 'call                    ^ self isCalled'.   self assert: (class requiredSelectors includes: #isCalled).   class compile: 'isCalled                    ^ 1'.   "Fail here:"   self deny: (class requiredSelectors includes: #isCalled)]  ensure: [class removeFromSystem] ! !"System"!"Tests"!"Traits"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.311.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!----SNAPSHOT----an Array(22 September 2006 2:56:15 pm) Squeak3.9g-7061.image priorSource: 13446!----SNAPSHOT----an Array(22 September 2006 2:56:23 pm) Squeak3.9g-7061.image priorSource: 27219!----QUIT/NOSAVE----an Array(22 September 2006 2:56:29 pm) Squeak3.9g-7061.image priorSource: 27317!----STARTUP----an Array(14 October 2006 10:29:19 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7061/Squeak3.9g-7061.image!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 13 October 2006 at 1:46:42 pm'!----End fileIn of a stream----!"Installed SUnit auto version 14".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '26bea8bf-733f-4715-b188-fa6d848984ad' autoVersion: '14' asVersion atSeconds: 3338274597 number: 3]!!SMLoader commentStamp: '<historical>' prior: 28830228!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:14' prior: 28832242!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := model isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(model directory directoryEntryFor: model lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'gui building' stamp: 'gk 9/25/2006 23:13' prior: 28845150!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:12' prior: 28850838!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((model categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 9/25/2006 23:13' prior: 28841017!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (model object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:41' prior: 28856889!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:25' prior: 28856648!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:12' prior: 28837324!loadUpdates	[Cursor wait showWhile: [		model loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 01:02' prior: 28857752!noteChanged	filters ifNil: [^self reOpen].	model ifNotNil: [		packagesList := nil.		selectedCategoryWrapper := nil.		self changed: #categoryWrapperList.		self changed: #packageWrapperList.		self changed: #packagesListIndex.	"update my selection"		self contentsChanged]! !!SMLoader methodsFor: 'initialization' stamp: 'gk 9/25/2006 23:12' prior: 28850564!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 28851422!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'private' stamp: 'gk 9/25/2006 23:12' prior: 28858069!packages	"We request the packages as sorted by name by default."	^model packagesByName asArray! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 28852607!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', model packages size printString, ')'! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/26/2006 00:40' prior: 28838431!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:40' prior: 28858774!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !"SMLoader"!"Installed SqueakMap2 loader auto version 10".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3' autoVersion: '10' asVersion atSeconds: 3338274602 number: 4]!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."SMSqueakMap default loadUpdates; upgradeOldPackages; purge.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87Log	"Name: KernelTests-lr.49Author: lrTime: 5 October 2006, 10:16:34 amUUID: 762d5c23-0364-4c26-ba13-129327ea7f39Ancestors: KernelTests-lr.48- merged code to fix unknown pragma selectors and binary selectors in pragmas- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmas- added some testsName: Compiler-lr.56Author: lrTime: 5 October 2006, 10:14:04 amUUID: f429f722-c39f-4acf-9d8c-c8a38320eaa8Ancestors: Compiler-lr.55- merged code to fix unknown pragma selectors- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmasMorphic fix duplicateChange Set:		ToggleBreakFix39Date:			26 September 2006Author:			tim@rowledge.orgPutative fix for Mantis http://bugs.impara.de/view.php?id=5123Fix Squeakmap"! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/13/2006 19:19'!updateFrom7061	"self new updateFrom7061"	self script87.	self flushCaches.	! !"ScriptLoader"!!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:48' prior: 26575366!addPragma: aPragma	self properties addPragma: aPragma! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47' prior: 26575484!pragmaLiteral	"Read a pragma literal."	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])		ifTrue: [ ^ self advance ].	(here == $# and: [ tokenType == #word ])		ifTrue: [ ^ self advance ].	(here == #- and: [ tokenType == #number ])		ifTrue: [ ^ (self advance; advance) negated ].	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])		ifTrue: [ ^ Compiler evaluate: self advance ].	^ self expected: 'Literal constant'! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 10:04' prior: 26576048!pragmaPrimitives	| pragmas primitives |	self properties pragmas isEmpty		ifTrue: [ ^ 0 ].	pragmas := Pragma allNamed: #primitive from: self class to: Parser.	primitives := self properties pragmas select: [ :prim |		pragmas anySatisfy: [ :prag | 			prag selector = prim keyword ] ].	primitives isEmpty 		ifTrue: [ ^ 0 ].	primitives size = 1 		ifFalse: [ ^ self notify: 'Ambigous primitives' ].	^ primitives first message sendTo: self! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47' prior: 26576424!pragmaSequence	"Parse a sequence of method pragmas."		[ true ] whileTrue: [		(self matchToken: #<)			ifFalse: [ ^ self ].		self pragmaStatement.		(self matchToken: #>)			ifFalse: [ ^ self expected: '>' ] ]! !!Parser methodsFor: 'pragmas' stamp: 'lr 8/19/2006 20:39' prior: 26576701!pragmaStatement	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."		| selector arguments words index keyword |	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])		ifFalse: [  ^ self expected: 'pragma declaration' ].	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "	(here = #apicall: or: [ here = #cdecl: ])		ifTrue: [ ^ self externalFunctionDeclaration ].	selector := String new.	arguments := OrderedCollection new.	words := OrderedCollection new.	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [		index := self startOfNextToken + requestorOffset.		selector := selector , self advance.		words add: (index to: self endOfLastToken + requestorOffset).		(selector last = $: or: [ selector first isLetter not ])			ifTrue: [ arguments add: self pragmaLiteral ] ].	selector numArgs ~= arguments size		ifTrue: [ ^ self expected: 'pragma argument' ].	(Symbol hasInterned: selector 		ifTrue: [ :value | keyword := value]) 		ifFalse: [ 			keyword := self 				correctSelector: selector wordIntervals: words				exprInterval: (words first first to: words last last)				ifAbort: [ ^ self fail ] ].	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).	^ true! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:50' prior: 26580110!primitive: anIntegerOrString	"Create indexed primitive."		<primitive>	^ anIntegerOrString isInteger		ifTrue: [ anIntegerOrString ]		ifFalse: [ 			anIntegerOrString isString				ifTrue: [ self primitive: anIntegerOrString module: nil ]				ifFalse: [ self expected: 'Indexed primitive' ] ]! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:51' prior: 26580460!primitive: aNameString module: aModuleStringOrNil	"Create named primitive."		<primitive>	(aNameString isString and: [ aModuleStringOrNil isNil or: [ aModuleStringOrNil isString ] ])		ifFalse: [ ^ self expected: 'Named primitive' ].	self allocateLiteral: (Array 		with: (aModuleStringOrNil isNil 			ifFalse: [ aModuleStringOrNil asSymbol ])		with: aNameString asSymbol		with: 0 with: 0).	^ 117! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47' prior: 26577682!properties	^ properties ifNil: [ properties := MethodProperties new ]! !!BreakpointManager class methodsFor: 'install-uninstall' stamp: 'tpr 9/26/2006 16:14' prior: 17771108!installInClass: aClass selector: aSymbol 	"Install a new method containing a breakpoint.	The receiver will remember this for unstalling it later"	| breakMethod |	breakMethod _ self compilePrototype: aSymbol in: aClass.	breakMethod isNil		ifTrue: [^ nil].	self installed at: breakMethod put: aClass >> aSymbol. "old method"	aClass class basicAddSelector: aSymbol withMethod: breakMethod.! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 8/19/2006 20:44'!testCompileBinary	self assertPragma: ' = 1' givesKeyword: #= arguments: #( 1 ).	self assertPragma: ' , 3' givesKeyword: #, arguments: #( 3 ).	self assertPragma: ' > 4' givesKeyword: #> arguments: #( 4 ).	self assertPragma: ' < 5' givesKeyword: #< arguments: #( 5 ).	self assertPragma: ' == 1' givesKeyword: #== arguments: #( 1 ).	self assertPragma: ' <> 3' givesKeyword: #<> arguments: #( 3 ).	self assertPragma: ' >< 4' givesKeyword: #>< arguments: #( 4 ).	self assertPragma: ' ** 5' givesKeyword: #** arguments: #( 5 )! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 10:15' prior: 24466852!testCompileInvalid	"Invalid pragmas should properly raise an error."	self should: [ self compile: '<>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<#123>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo bar>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo 1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar zork>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar 1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: bar:>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: #bar: zork:>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<<1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<=2>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 = >' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 =2 >' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: String>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: Pragma>' selector: #zork ] raise: SyntaxErrorNotification! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 09:49' prior: 24469260!testCompileValue	self assertPragma: 'foo: true' givesKeyword: #foo: arguments: #( true ).	self assertPragma: 'foo: false' givesKeyword: #foo: arguments: #( false ).	self assertPragma: 'foo: nil' givesKeyword: #foo: arguments: #( nil )! !!SMLoader commentStamp: '<historical>' prior: 33582520!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!SMLoader methodsFor: 'actions' stamp: 'gk 5/5/2006 02:05' prior: 33582749!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := squeakMap isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(squeakMap directory directoryEntryFor: squeakMap lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'gui building' stamp: 'gk 5/5/2006 02:05' prior: 33583415!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [squeakMap cache directoryForPackage: item]				ifFalse: [squeakMap cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/12/2004 01:16' prior: 33583905!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((squeakMap categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/13/2004 15:49' prior: 33584511!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (squeakMap object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'private' stamp: 'gk 7/11/2004 04:07' prior: 33585646!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe ifFalse: [self reOpen].		self noteChanged]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 7/11/2004 03:58' prior: 33586541!installedReleaseOfMe	"Return the release of the installed package loader."	^squeakMap installedReleaseOf: (squeakMap packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/10/2004 18:51' prior: 33586817!loadUpdates	[Cursor wait showWhile: [		squeakMap loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 7/13/2004 17:07' prior: 33587103!noteChanged	packagesList := nil.	selectedCategoryWrapper := nil.	filters ifNil: [^self reOpen].	self changed: #categoryWrapperList.	self changed: #packageWrapperList.	self changed: #packagesListIndex.	"update my selection"	self contentsChanged! !!SMLoader methodsFor: 'initialization' stamp: 'gk 5/5/2006 02:05' prior: 33587467!on: aSqueakMap 	"Initialize instance."	squeakMap := aSqueakMap.	squeakMap synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/13/2004 17:10' prior: 33587747!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (squeakMap object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'private' stamp: 'gk 11/18/2003 02:24' prior: 33588552!packages	"We request the packages as sorted by name by default."	^squeakMap packagesByName asArray! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/13/2004 17:10' prior: 33588729!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', squeakMap packages size printString, ')'! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/13/2004 15:25' prior: 33588995!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := squeakMap installedPackages.	old := squeakMap oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := squeakMap upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				squeakMap upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe ifFalse: [self reOpen].				self noteChanged]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'gk 5/5/2006 02:05' prior: 33590719!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := squeakMap installedPackages.	old := squeakMap oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := squeakMap upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					squeakMap upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [squeakMap upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe ifFalse: [self reOpen].				self noteChanged]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!Morph methodsFor: 'halos and balloon help' stamp: 'zz 9/28/2006 18:53' prior: 24733634!balloonHelpTextForHandle: aHandle 	"Answer a string providing balloon help for the	given halo handle"	| itsSelector |	itsSelector := aHandle eventHandler firstMouseSelector.	itsSelector == #doRecolor:with:		ifTrue: [^ Preferences propertySheetFromHalo				ifTrue: ['Open a property sheet.']				ifFalse: ['Change color']].	itsSelector == #mouseDownInDimissHandle:with:		ifTrue: [^ Preferences preserveTrash				ifTrue: ['Move to trash']				ifFalse: ['Remove from screen']].	#(#(#addFullHandles 'More halo handles') #(#addSimpleHandles 'Fewer halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#dismiss 'Remove') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMakeSibling:with: 'Make a sibling') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#editButtonsScript 'See the script for this button') #(#editDrawing 'Repaint') #(#doDupOrMakeSibling:with: 'Duplicate (press shift to make a sibling)') #(#doMakeSiblingOrDup:with: 'Make a sibling (press shift to make simple duplicate)') #(#makeNascentScript 'Make a scratch script') #(#makeNewDrawingWithin 'Paint new object') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#openViewerForArgument 'Open a Viewer for me. Press shift for a snapshot.') #(#openViewerForTarget:with: 'Open a Viewer for me. Press shift for a snapshot.') #(#paintBackground 'Paint background') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#presentViewMenu 'Present the Viewing menu') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#tearOffTile 'Make a tile representing this object') #(#tearOffTileForTarget:with: 'Make a tile representing this object') #(#trackCenterOfRotation:with: 'Set center of rotation') )		do: [:pair | itsSelector == pair first				ifTrue: [^ pair last]].	^ 'unknown halo handle'translated! !"Compiler"!"KernelTests"!"Morphic"!"SMLoader"!"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.316.mcz') load.ScriptLoader new updateFrom7061.!----End fileIn of a stream----!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 13 October 2006 at 1:46:42 pm'!----End fileIn of a stream----!----SNAPSHOT----an Array(14 October 2006 10:37 am) Squeak3.9-RC2-7063.image priorSource: 27317!----SNAPSHOT----an Array(14 October 2006 10:38:53 am) Squeak3.9-RC2-7063.image priorSource: 61467!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7061] on 5 October 2006 at 12:48:11 pm'!----End fileIn of a stream----!----SNAPSHOT----an Array(14 October 2006 10:40:44 am) Squeak3.9-RC2-7063.image priorSource: 61564!----QUIT/NOSAVE----an Array(14 October 2006 10:41:14 am) Squeak3.9-RC2-7063.image priorSource: 61797!----STARTUP----an Array(14 October 2006 10:41:44 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7063/Squeak3.9-RC2-7063.image!----QUIT/NOSAVE----an Array(14 October 2006 10:41:52 am) Squeak3.9-RC2-7063.image priorSource: 61797!----STARTUP----an Array(14 October 2006 10:58:15 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7063/Squeak3.9-RC2-7063.image!----QUIT/NOSAVE----an Array(14 October 2006 11:03:12 am) Squeak3.9-RC2-7063.image priorSource: 61797!----STARTUP----an Array(14 October 2006 11:03:23 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7063/Squeak3.9-RC2-7063.image!installingDefaultRepositoriesToPackages	"self new installingDefaultRepositoriesToPackages!!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:07' prior: 29509092!installRepository: aString for: packageName	(MCWorkingCopy allManagers select: [:each | each package name = packageName])		first repositoryGroup		addRepository: (MCHttpRepository new location: aString ; user: 'squeak' ; password: 'squeak')		! !installingDefaultRepositoriesToPackages	"self new installingDefaultRepositoriesToPackages!!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:08' prior: 29508560!installInBoxAnd39	"self new installInBoxAnd39"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/39a' ; user: ''; password: '');			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/inbox' ; user: '' ; password: '')].		! !installInBoxAnd39	"self new installInBoxAnd39!installInBoxAnd39	"self new installInBoxAnd39"		MCWorkingCopy allManagers!!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:12' prior: 29503230!cleanOldRepositories	"self new cleanOldRepositories"	"does not work since the interface of the repository group is not made for removing a repository only based on name"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			removeRepository: (MCHttpRepository new location: 'http://kilana.unibe.ch:8888/Monticello');			removeRepository: (MCHttpRepository new location: 'http://modules.squeakfoundation.org/People/gk/')].	! !"ScriptLoader"!----SNAPSHOT----an Array(14 October 2006 11:15:30 am) Squeak3.9-RC2-7063.image priorSource: 61797!----QUIT/NOSAVE----an Array(14 October 2006 11:15:37 am) Squeak3.9-RC2-7063.image priorSource: 64335!----STARTUP----an Array(15 October 2006 11:15:59 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7064/Squeak3.9-RC2-7063.image!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/15/2006 11:11'!script88	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/15/2006 11:11'!updateFrom7063	"self new updateFrom7063"		self script88.	SMSqueakMap default noteInstalledPackageNamed: 'SqueakMap2 loader'autoVersion: '10'.	self flushCaches.	! !"ScriptLoader"!!SMLoader commentStamp: '<historical>' prior: 33602792!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:14' prior: 33603020!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := model isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(model directory directoryEntryFor: model lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'gui building' stamp: 'gk 9/25/2006 23:13' prior: 33603697!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:12' prior: 33604195!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((model categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 9/25/2006 23:13' prior: 33604805!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (model object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:41' prior: 33605944!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:25' prior: 33606822!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:12' prior: 33607078!loadUpdates	[Cursor wait showWhile: [		model loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 01:02' prior: 33607368!noteChanged	filters ifNil: [^self reOpen].	model ifNotNil: [		packagesList := nil.		selectedCategoryWrapper := nil.		self changed: #categoryWrapperList.		self changed: #packageWrapperList.		self changed: #packagesListIndex.	"update my selection"		self contentsChanged]! !!SMLoader methodsFor: 'initialization' stamp: 'gk 9/25/2006 23:12' prior: 33607705!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 33607993!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'private' stamp: 'gk 9/25/2006 23:12' prior: 33608803!packages	"We request the packages as sorted by name by default."	^model packagesByName asArray! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 33608984!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', model packages size printString, ')'! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/26/2006 00:40' prior: 33609254!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:40' prior: 33610978!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !"SMLoader"!"Installed SqueakMap2 loader auto version 10".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3' autoVersion: '10' asVersion atSeconds: 3338363798 number: 5]!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.318.mcz') load.ScriptLoader new updateFrom7063.!----End fileIn of a stream----!----SNAPSHOT----an Array(15 October 2006 11:23:41 am) Squeak3.9-RC2-7063.image priorSource: 64335!----QUIT/NOSAVE----an Array(15 October 2006 11:23:46 am) Squeak3.9-RC2-7063.image priorSource: 77325!----STARTUP----an Array(15 October 2006 11:24 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7064/Squeak3.9-RC2-7063.image!----SNAPSHOT----an Array(15 October 2006 11:24:06 am) Squeak3.9-RC2-7064.image priorSource: 77325!----QUIT/NOSAVE----an Array(15 October 2006 11:24:10 am) Squeak3.9-RC2-7064.image priorSource: 77689!----STARTUP----an Array(20 October 2006 9:37:38 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7064/Squeak3.9-RC2-7064.image!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/18/2006 11:37'!script89	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.114.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/18/2006 11:37'!updateFrom7064	"self new updateFrom7064"		self script89.	self flushCaches.	! !"ScriptLoader"!!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57' prior: 31820324!initialize	"Initialize a system window. Add label, stripes, etc., if desired"	super initialize.	allowReframeHandles _ true.	labelString ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	borderColor _ Color lightGray.	borderWidth _ 1.	self color: Color lightGray lighter lighter lighter.	self layoutPolicy: ProportionalLayout new.		self initializeLabelArea.					self addCornerGrips.	self extent: 300 @ 200.	mustNotClose _ false.	updatablePanes _ Array new.			Preferences menuAppearance3d		ifTrue: [			self				addDropShadow;				shadowColor: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.333);				shadowOffset: 1@1.		].					! !!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57' prior: 31822124!initializeLabelArea	"Initialize the label area (titlebar) for the window."	label _ StringMorph new contents: labelString;						 font: Preferences windowTitleFont emphasis: 0.			"Add collapse box so #labelHeight will work"			collapseBox _ self createCollapseBox.			stripes _ Array						with: (RectangleMorph newBounds: bounds)						with: (RectangleMorph newBounds: bounds).			"see extent:"			self addLabelArea.			self setLabelWidgetAllowance.			self addCloseBox.			self addMenuControl.			labelArea addMorphBack: (Morph new extent: self class borderWidth @ 0).			labelArea addMorphBack: label.			self wantsExpandBox				ifTrue: [self addExpandBox].			labelArea addMorphBack: collapseBox.			self setFramesForLabelArea.			Preferences clickOnLabelToEdit				ifTrue: [label						on: #mouseDown						send: #relabel						to: self].			Preferences noviceMode				ifTrue: [closeBox						ifNotNil: [closeBox setBalloonText: 'close window'].					menuBox						ifNotNil: [menuBox setBalloonText: 'window menu'].					collapseBox						ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].! !!Compiler methodsFor: 'public access' stamp: 'md 10/16/2006 09:53' prior: 19127422!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	| methodNode method value toLog itsSelectionString itsSelection |	class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	method selector ifNil: [method selector: #DoIt].	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ])		executeMethod: method.	logFlag ifTrue:		[toLog := ((requestor respondsTo: #selection)  and:			[(itsSelection := requestor selection) notNil] and:			[(itsSelectionString := itsSelection asString) isEmptyOrNil not] )			ifTrue: 				[itsSelectionString]			ifFalse:				[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext ].	^ value.! !"Compiler"!"Morphic"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.319.mcz') load.ScriptLoader new updateFrom7064.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/20/2006 21:30'!script90	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.149.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.114.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/20/2006 21:31'!updateFrom7065	"self new updateFrom7065"		self script90.	self flushCaches.	! !"ScriptLoader"!!ClassRenameFixTest methodsFor: 'Tests' stamp: 'cmm 8/7/2005 18:21' prior: 18689065!renameClassUsing: aBlock	| createdClass foundClasses |	originalName := self newUniqueClassName.	createdClass := Object 		subclass: originalName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'ClassRenameFix-GeneradClass'.	newClassName := self newUniqueClassName.	aBlock value: createdClass value: newClassName.	self assert: (Smalltalk classNamed: originalName) isNil.	self assert: (Smalltalk classNamed: newClassName) notNil.	foundClasses := Smalltalk organization listAtCategoryNamed: 'ClassRenameFix-GeneradClass'.	self assert: (foundClasses notEmpty).	self assert: (foundClasses includes: newClassName).	self assert: (createdClass name = newClassName).! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'cmm 8/7/2005 18:20' prior: 18688108!setUp	previousChangeSet := ChangeSet current.	testsChangeSet := ChangeSet new.	ChangeSet newChanges: testsChangeSet.	SystemChangeNotifier uniqueInstance		notify: self		ofSystemChangesOfItem: #class		change: #Renamed		using: #verifyRenameEvent:.	super setUp! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'cmm 8/7/2005 18:21' prior: 18688450!tearDown	self removeEverythingInSetFromSystem: testsChangeSet.	ChangeSet newChanges: previousChangeSet.	ChangeSorter removeChangeSet: testsChangeSet.	previousChangeSet := nil.	testsChangeSet := nil.	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self.	super tearDown.! !!SystemDictionary methodsFor: 'class and trait names' stamp: 'rw 10/7/2006 08:34' prior: 31627640!renameClass: aClass as: newName 	"Rename the class, aClass, to have the title newName."	"Original one I want to keep but needs to be fixed"		| oldref i oldName category |	oldName := aClass name.	category := aClass category.	SystemOrganization classify: newName under: aClass category.	SystemOrganization removeElement: aClass name.	oldref _ self associationAt: aClass name.	self removeKey: aClass name.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i _ list indexOf: aClass name ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemDictionary methodsFor: 'class names' stamp: 'rw 10/17/2006 23:07'!renameClass: aClass from: oldName 	"Rename the class, aClass, to have the title newName."	| oldref i newName category |	newName := aClass name.	category := SystemOrganization categoryOfElement: oldName.	SystemOrganization classify: newName under: category.	SystemOrganization removeElement: oldName.	oldref := self associationAt: oldName.	self removeKey: oldName.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i := list indexOf: oldName ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemChangeNotifierTest commentStamp: 'rw 4/3/2006 17:19' prior: 31614888!A SystemChangeNotifierTest is a test class that tests whether the triggering of changes indeed results in the intended changes to be sent to registered object. The basic mechanism for each test is fairly simple:	- register the receiver as the one to get the change notifier.	- manually trigger a change (so the system is not polluted just to see whether we get the needed event).	- the method #event: is invoked and remembers the change event.	- the change event is checked to see whether it was the intended one.Instance Variables	capturedEvent:		Remembers the captured event!!SystemChangeNotifierTest methodsFor: 'Running' stamp: 'rw 10/19/2006 17:21'!setUp	super setUp.	notifier := SystemChangeNotifier createInstance.! !!SystemChangeNotifierTest methodsFor: 'Private' stamp: 'rw 10/19/2006 17:23'!systemChangeNotifier	"The notifier to use. Do not use the one in the system so that the fake events triggered in the tests perturb clients of the system's change notifier (e.g. the changes file then shows fake entries)."	^notifier! !!SystemChangeNotifierTest methodsFor: 'Running' stamp: 'rw 10/19/2006 17:23' prior: 31617204!tearDown	super tearDown.	self capturedEvent: nil.	notifier releaseAll.	notifier := nil! !!SystemChangeNotifierTest methodsFor: 'Testing-system triggers' stamp: 'rw 10/19/2006 17:24' prior: 31619179!testClassRenamedEvent	"self run: #testClassRenamedEvent"	self systemChangeNotifier notify: self ofAllSystemChangesUsing: #event:.	self systemChangeNotifier 		classRenamed: self class		from: #OldFooClass		to: #NewFooClass		inCategory: #FooCat.	self		checkEventForClass: self class		category: #FooCat		change: #Renamed."	self assert: capturedEvent oldName = #OldFooClass.	self assert: capturedEvent newName = #NewFooClass"! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/17/2006 22:26' prior: 18241916!event: anEvent	"Hook for SystemChangeNotifier"	anEvent itemKind = SystemChangeNotifier classKind ifTrue: [		anEvent isRemoved 			ifTrue: [self noteRemovalOf: anEvent item].		anEvent isAdded 			ifTrue: [self addClass: anEvent item].		anEvent isModified 			ifTrue: [anEvent anyChanges ifTrue: [self changeClass: anEvent item from: anEvent oldItem]].		anEvent isCommented 			ifTrue: [self commentClass: anEvent item].		anEvent isRenamed 			ifTrue: [self renameClass: anEvent item from: anEvent oldName to: anEvent newName].		anEvent isReorganized			ifTrue: [self reorganizeClass: anEvent item].		anEvent isRecategorized			ifTrue: [self changeClass: anEvent item from: anEvent item].	].	anEvent itemKind = SystemChangeNotifier methodKind ifTrue: [		anEvent isAdded			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: nil].		anEvent isModified			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: anEvent oldItem].		anEvent isRemoved			ifTrue: [self removeSelector: anEvent itemSelector class: anEvent itemClass priorMethod: anEvent item lastMethodInfo: {anEvent item sourcePointer. anEvent itemProtocol}].		anEvent isRecategorized			ifTrue: [self reorganizeClass: anEvent itemClass].	].! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/19/2006 17:52'!renameClass: class from: oldName to: newName 	"Include indication that a class has been renamed."	| recorder oldMetaClassName newMetaClassName |	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet renameClass: class as: newName].	(recorder _ self changeRecorderFor: oldName)		noteChangeType: #rename;		noteNewName: newName asSymbol.			"store under new name (metaclass too)"	changeRecords at: newName put: recorder.	changeRecords removeKey: oldName.	self noteClassStructure: class.	newMetaClassName := newName, ' class'.	oldMetaClassName := oldName, ' class'.	recorder _ changeRecords at: oldMetaClassName ifAbsent: [^ nil].	changeRecords at: newMetaClassName put: recorder.	changeRecords removeKey: oldMetaClassName.	recorder noteNewName: newMetaClassName! !!Class methodsFor: 'class name' stamp: 'rw 10/7/2006 08:30' prior: 18519182!rename: aString 	"The new name of the receiver is the argument, aString."	| oldName newName |	(newName _ aString asSymbol) = (oldName _ self name)		ifTrue: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	name _ newName.	self environment renameClass: self from: oldName! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57' prior: 18691219!deleteClass	| cl |	cl := Smalltalk at: className ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57'!deleteRenamedClass	| cl |	cl := Smalltalk at: renamedName ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:05' prior: 18691426!setUp	className := #TUTU.	renamedName := #RenamedTUTU.	self deleteClass.	self deleteRenamedClass.	Object subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'KernelTests-Classes'! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:08' prior: 18691687!tearDown	self deleteClass.	self deleteRenamedClass! !!ClassTest methodsFor: 'testing' stamp: 'rw 10/17/2006 22:13' prior: 18692104!testRenaming	"self debug: #testRenaming"	"self run: #testRenaming"		| oldName newMetaclassName class |	oldName := className.	newMetaclassName := (renamedName, #' class') asSymbol.	class := Smalltalk at: oldName.	class class compile: 'dummyMeth'.	class rename: renamedName.	self assert: class name = renamedName.	self assert: (ChangeSet current changedClassNames includes: renamedName). 	self assert: (ChangeSet current changedClassNames includes: newMetaclassName).	! !ChangeSet removeSelector: #renameClass:as:!"Kernel"!"KernelTests"!"System"!"SystemChangeNotification-Tests"!"Tests"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.320.mcz') load.ScriptLoader new updateFrom7065.!----End fileIn of a stream----!----SNAPSHOT----an Array(20 October 2006 9:43:06 pm) Squeak3.9-RC3-7066.image priorSource: 77689!----QUIT/NOSAVE----an Array(20 October 2006 9:43:18 pm) Squeak3.9-RC3-7066.image priorSource: 95470!----STARTUP----an Array(7 November 2006 11:57:51 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC3-7066/Squeak3.9-RC3-7066.image!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 11/6/2006 20:38'!script91	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.150.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.115.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 11/7/2006 11:50'!updateFrom7066	"self new updateFrom7066"		self script91.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	SystemVersion newVersion: 'Squeak3.9'.	self flushCaches.	! !"ScriptLoader"!!Complex methodsFor: 'comparing' stamp: 'hmm 11/1/2006 23:29' prior: 19144324!= anObject	anObject isNumber ifFalse: [^false].	anObject isComplex		ifTrue: [^ (real = anObject real) & (imaginary = anObject imaginary)]		ifFalse: [^ anObject adaptToComplex: self andSend: #=]! !!Complex methodsFor: 'testing' stamp: 'hmm 11/1/2006 23:34'!isNumber	^ true! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:22'!testAddAction	"MVCToolBuilder does not implement #buildPluggableMenu:"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:22'!testAddTargetSelectorArgumentList	"MVCToolBuilder does not implement #buildPluggableMenu:"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:23'!testButtonFiresBlock	"MVC buttons only support action Symbols"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:23'!testButtonFiresMessage	"MVC buttons only support action Symbols, not MessageSends"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testButtonInitiallyDisabled	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testButtonInitiallyDisabledSelector	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testGetButtonColor	"MVC buttons do not have color"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testGetButtonEnabled	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:18'!testGetButtonSideEffectFree	"MVC button ask for their state on any change notification"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:19'!testGetInputFieldColor	"MVC input fields do not have color"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:20'!testGetPanelChildren	"MVC panels do not allow changing children"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetTextColor	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetWindowChildren	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetWindowLabel	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeExpandPath	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeExpandPathFirst	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeGetSelectionPath	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeRoots	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeWidgetID	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:25'!testWindowCloseAction	"This can only work if we're actually run in MVC"	World isNil ifTrue: [super testWindowCloseAction]! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36' prior: 17737741!addCornerGrips	self		addMorphBack: (TopLeftGripMorph new target: self; position: self position).	self		addMorphBack: (TopRightGripMorph new target: self; position: self position).	self		addMorphBack: (BottomLeftGripMorph new target: self;position: self position).	self		addMorphBack: (BottomRightGripMorph new target: self;position: self position)! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36' prior: 17738079!addPaneHSplitterBetween: topMorph and: bottomMorphs	| targetY minX maxX splitter |	targetY _ topMorph layoutFrame bottomFraction.	minX _ (bottomMorphs detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.	maxX _ (bottomMorphs detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.	splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.	splitter layoutFrame: (LayoutFrame		fractions: (minX @ targetY corner: maxX @ targetY)		offsets: (((topMorph layoutFrame leftOffset ifNil: [0]) @ 0 corner: (topMorph layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (topMorph layoutFrame bottomOffset ifNil: [0]))).	self addMorphBack: (splitter position: self position).! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:34' prior: 17738876!addPaneSplitters	| splitter remaining target targetX sameX minY maxY targetY sameY minX maxX |	self removePaneSplitters.	self removeCornerGrips.	remaining _ submorphs reject: [:each | each layoutFrame rightFraction = 1].	[remaining notEmpty] whileTrue:		[target _ remaining first.		targetX _ target layoutFrame rightFraction.		sameX _ submorphs select: [:each | each layoutFrame rightFraction = targetX].		minY _ (sameX detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.		maxY _ (sameX detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.		splitter layoutFrame: (LayoutFrame			fractions: (targetX @ minY corner: targetX @ maxY)			offsets: ((0 @ (target layoutFrame topOffset ifNil: [0]) corner: 4 @ (target layoutFrame bottomOffset ifNil: [0])) translateBy: (target layoutFrame rightOffset ifNil: [0]) @ 0)).		self addMorphBack: (splitter position: self position).		remaining _ remaining copyWithoutAll: sameX].	remaining _ submorphs copy reject: [:each | each layoutFrame bottomFraction = 1].	[remaining notEmpty]		whileTrue: [target _ remaining first.			targetY _ target layoutFrame bottomFraction.			sameY _ submorphs select: [:each | each layoutFrame bottomFraction = targetY].			minX _ (sameY detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.			maxX _ (sameY detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.			splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.			splitter layoutFrame: (LayoutFrame				fractions: (minX @ targetY corner: maxX @ targetY)				offsets: (((target layoutFrame leftOffset ifNil: [0]) @ 0 corner: (target layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (target layoutFrame bottomOffset ifNil: [0]))).			self addMorphBack: (splitter position: self position).			remaining _ remaining copyWithoutAll: sameY].	self linkSubmorphsToSplitters.	self splitters do: [:each | each comeToFront].! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:37' prior: 17740940!addPaneVSplitterBetween: leftMorph and: rightMorphs 	| targetX minY maxY splitter |	targetX _ leftMorph layoutFrame rightFraction.	minY _ (rightMorphs detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.	maxY _ (rightMorphs detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.	splitter layoutFrame: (LayoutFrame		fractions: (targetX @ minY corner: targetX @ maxY)		offsets: ((0 @ (leftMorph layoutFrame topOffset ifNil: [0]) corner: (4@ (leftMorph layoutFrame bottomOffset ifNil: [0]))) translateBy: (leftMorph layoutFrame rightOffset ifNil: [0]) @ 0)).	self addMorphBack: (splitter position: self position).! !"Kernel"!"Morphic"!"ToolBuilder-MVC"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.324.mcz') load.ScriptLoader new updateFrom7066.!----End fileIn of a stream----!----SNAPSHOT----an Array(7 November 2006 12:05:35 pm) Squeak3.9-final-7067.image priorSource: 95470!----QUIT/NOSAVE----an Array(7 November 2006 12:05:44 pm) Squeak3.9-final-7067.image priorSource: 105817!----STARTUP----an Array(2 March 2008 5:56:06 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-final-7067/Squeak3.9-final-7067.image!"Change Set:		advance391Date:			14 feb 2008Author:			S. DucasseAdvance the version to 3.9.1. Subsequent updates will lead to version 3.9.1"!"Postscript:Advance the version number to 3.9.1a ."SystemVersion newVersion: 'Squeak3.9.1a'.SystemVersion current date: '14 Feb 2008'.self inform: 'You may now save this Version 3.9.1 alpha image.Subsequent updates will lead to 3.9.1.'.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 2/4/2008 16:21'!VersionText^ 'Welcome to the finale version of 3.9 of 7 of November 2006You will find more recent versions at http://www.squeak.org/This image will be used to produce other distributions such as a developer image and a fun with Squeak image. We hope that you will really appreciate this version and that Squeak will help you making your projects reality.You can also participate to Squeak at different kinds of levels. This can be as simple as:		- asking questions in the beginner list (beginners@lists.squeakfoundation.org) 		or in the dev list (squeak-dev@lists.squeakfoundation.org)		- answering questions 		- finding and reporting bugs at:		http://bugs.impara.de	- fixing them, testing fixes and commenting them	- writing tests for uncovered parts		- helping for the website	- creating new cool products, frameworks, applications in squeak	- writing articles....	We wish you a lot of fun and we would like to thanks all the persons that participated to make this release a really good one.We know who you are!!	Stephane Ducasse and Marcus Denker	stephane.ducasse@free.fr and denker@iam.unibe.ch'! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 2/4/2008 16:21'!WelcomeText	^ 'Welcome to Squeak - an open Smalltalk system.What is this?Squeak is an open source implementation of Smalltalk with an expansive and rapidly developing world of objects included. Squeak includes a fully integrated development environment, networking, sound synthesis and sampling, speech synthesis, 2 & 3D graphics, arithmetic and data structure libraries.The SqueakMap tool (click on -> "SMLoader open" to start it) tool provides easy access to a large range of packages and projects.Even the tools to produce the its own virtual machine (VM) are available so that you can build your own - and most of the VM is written in Smalltalk. Not only is all the Smalltalk source code included and changeable at will, it is also completely open and free. The Squeak system image runs bit-identically across all platforms, and VMs are available for just about every computer and operating system available. To find out exactly which version of Squeak this is click on -> "SystemVersion current" Further DocumentationThe primary website for Squeak is 	http://www.squeak.organd a large amount of online information is linked to from there. There are several very active mailing lists that you might consider joining.The Squeak Swiki at Georgia Tech is currently the primary source of online documentation and community information regarding Squeak.  It contains a FAQ, tutorials, and much more.  Visit it at:	http://minnow.cc.gatech.edu/squeakSqueak depends on the involvement and contributions of people like you. Please take a look around the website, join the mail list, report bugs, offer suggestions and most of all have fun with it.The Squeak LicenseSqueak is distributed for use and modification subject to a liberal open source license.  See the main Squeak website for details.  Unless stated to the contrary, works submitted for incorporation into or for distribution with Squeak shall be presumed subject to the same license.Portions of Squeak are:Copyright (c) 1996 Apple Computer, Inc.Copyright (c) 1997-2001 Walt Disney Company, and/orCopyrighted works of many other contributors.All rights reserved.'! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 2/4/2008 16:09'!openWindow: contents label: aLabel	StringHolder new 		contents: contents ;		openLabel: aLabel! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 2/14/2008 20:12'!script92	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.150.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.115.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.22.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/14/2008 20:13'!updateFrom7067	"self new updateFrom7067"		self script92. "loading multilingual is sync"	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/14/2008 20:13'!updateFrom7068	"self new updateFrom7067"			"SystemWindow allInstances do: [:each | each delete]."	self script92.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	SystemVersion newVersion: 'Squeak3.9.1'.	self flushCaches.	! !"ScriptLoader"!!FontTest methodsFor: 'testing' stamp: 'sd 2/4/2008 21:10' prior: 21250151!testDisplay	"self debug: #testDisplay"	| text font bb destPoint width |	text := 'test' asText.	font := TextStyle default fontOfSize: 21.	text addAttribute: (TextFontReference toFont: font).	bb := (Form extent: 100 @ 30) getCanvas privatePort.	bb combinationRule: Form paint.	font installOn: bb foregroundColor: Color black backgroundColor: Color white.	destPoint := font displayString: text on: bb from: 1 to: 4 at: 0@0 kern: 1.	width := text inject: 0 into: [:max :char | max + (font widthOf: char)].	self assert: destPoint x = (width + 4).	"bb destForm asMorph openInHand."! !!FontTest methodsFor: 'testing' stamp: 'sd 2/4/2008 21:10' prior: 21250802!testFallback	"self debug: #testFallback"	| text font bb destPoint |	text := (Character value: 257) asString asText.	font := TextStyle default fontOfSize: 21.	text addAttribute: (TextFontReference toFont: font).	bb := (Form extent: 100 @ 30) getCanvas privatePort.	bb combinationRule: Form paint.	font installOn: bb foregroundColor: Color black backgroundColor: Color white.	destPoint := font displayString: text on: bb from: 1 to: 1 at: 0@0 kern: 1.	"bb destForm asMorph openInHand."	self assert: destPoint x = ((font widthOf: $?) + 1).! !!FontTest methodsFor: 'testing' stamp: 'sd 2/4/2008 21:11' prior: 21254867!testResetAfterEmphasized	"self debug: #testResetAfterEmphasized"	| normal derivative |	normal := TextStyle defaultFont.	derivative := normal emphasized: 3.	self assert: (normal derivativeFonts at: 3) == derivative.	normal reset.	self assert: normal derivativeFonts isEmpty! !!MultiTextComposer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 25319628!composeEachRectangleIn: rectangles	| myLine lastChar |	1 to: rectangles size do: [:i | 		currCharIndex <= theText size ifFalse: [^false].		myLine := scanner 			composeFrom: currCharIndex 			inRectangle: (rectangles at: i)							firstLine: isFirstLine 			leftSide: i=1 			rightSide: i=rectangles size.		lines addLast: myLine.		presentationLines addLast: scanner getPresentationLine.		presentation ifNil: [presentation := scanner getPresentation]			ifNotNil: [presentation := presentation, scanner getPresentation].		actualHeight := actualHeight max: myLine lineHeight.  "includes font changes"		currCharIndex := myLine last + 1.		lastChar := theText at: myLine last.		lastChar = Character cr ifTrue: [^#cr].		wantsColumnBreaks ifTrue: [			lastChar = TextComposer characterForColumnBreak ifTrue: [^#columnBreak].		].	].	^false! !!MultiTextComposer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 25320718!multiComposeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY textStyle: argTextStyle text: argText container: argContainer wantsColumnBreaks: argWantsColumnBreaks	wantsColumnBreaks := argWantsColumnBreaks.	lines := argLinesCollection.	presentationLines := argLinesCollection copy.	theTextStyle := argTextStyle.	theText := argText.	theContainer := argContainer.	deltaCharIndex := argDelta.	currCharIndex := startCharIndex := argStart.	stopCharIndex := argStop.	prevLines := argPriorLines.	currentY := argStartY.	defaultLineHeight := theTextStyle lineGrid.	maxRightX := theContainer left.	possibleSlide := stopCharIndex < theText size and: [theContainer isMemberOf: Rectangle].	nowSliding := false.	prevIndex := 1.	scanner := MultiCompositionScanner new text: theText textStyle: theTextStyle.	scanner wantsColumnBreaks: wantsColumnBreaks.	isFirstLine := true.	self composeAllLines.	isFirstLine ifTrue: ["No space in container or empty text"		self 			addNullLineWithIndex: startCharIndex			andRectangle: (theContainer topLeft extent: 0@defaultLineHeight)	] ifFalse: [		self fixupLastLineIfCR	].	^{lines asArray. maxRightX}! !!MultiCharacterBlockScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25265616!buildCharacterBlockIn: para	| lineIndex runLength lineStop done stopCondition |	"handle nullText"	(para numberOfLines = 0 or: [text size = 0])		ifTrue:	[^ CharacterBlock new stringIndex: 1  "like being off end of string"					text: para text					topLeft: (para leftMarginForDisplayForLine: 1 alignment: (alignment ifNil:[textStyle alignment]))								@ para compositionRectangle top					extent: 0 @ textStyle lineGrid].	"find the line"	lineIndex := para lineIndexOfTop: characterPoint y.	destY := para topAtLineIndex: lineIndex.	line := para lines at: lineIndex.	rightMargin := para rightMarginForDisplay.	(lineIndex = para numberOfLines and:		[(destY + line lineHeight) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					self characterPointSetX: rightMargin]			ifFalse:	[characterPoint y < (para compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint := (para compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[self characterPointSetX: rightMargin]].	destX := (leftMargin := para leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment])).	nextLeftMargin:= para leftMarginForDisplayForLine: lineIndex+1 alignment: (alignment ifNil:[textStyle alignment]).	lastIndex := line first.	self setStopConditions.		"also sets font"	runLength := (text runLengthFor: line first).	characterIndex == nil		ifTrue:	[lineStop := line last  "characterBlockAtPoint"]		ifFalse:	[lineStop := characterIndex  "characterBlockForIndex"].	(runStopIndex := lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex := lineStop].	lastCharacterExtent := 0 @ line lineHeight.	spaceCount := 0. done  := false.	self handleIndentation.	[done]	whileFalse:	[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.	"see setStopConditions for stopping conditions for character block 	operations."	self lastCharacterExtentSetX: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition) ifTrue:		[characterIndex == nil			ifTrue: ["characterBlockAtPoint"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + (font descentKern @ 0)						extent: lastCharacterExtent]			ifFalse: ["characterBlockForIndex"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + ((font descentKern) - kern @ 0)						extent: lastCharacterExtent]]]! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25252218!characterBlockAtPoint: aPoint in: aParagraph	"Answer a CharacterBlock for character in aParagraph at point aPoint. It 	is assumed that aPoint has been transformed into coordinates appropriate 	to the text's destination form rectangle and the composition rectangle."	self initializeFromParagraph: aParagraph clippedBy: aParagraph clippingRectangle.	characterPoint := aPoint.	^self buildCharacterBlockIn: aParagraph! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25255478!characterBlockForIndex: targetIndex in: aParagraph 	"Answer a CharacterBlock for character in aParagraph at targetIndex. The 	coordinates in the CharacterBlock will be appropriate to the intersection 	of the destination form rectangle and the composition rectangle."	self 		initializeFromParagraph: aParagraph 		clippedBy: aParagraph clippingRectangle.	characterIndex := targetIndex.	characterPoint := 		aParagraph rightMarginForDisplay @ 			(aParagraph topAtLineIndex: 				(aParagraph lineIndexOfCharacterIndex: characterIndex)).	^self buildCharacterBlockIn: aParagraph! !!MultiCharacterBlockScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25268248!characterPointSetX: xVal	characterPoint := xVal @ characterPoint y! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25258309!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY := destY +  line lineHeight.				baselineY := line lineHeight.				lastCharacter := nil.				characterPoint := (nextLeftMargin ifNil: [leftMargin]) @ destY.				lastIndex := lastIndex + 1.				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter := CR.		characterPoint := destX @ destY.		self lastCharacterExtentSetX: rightMargin - destX.		^true! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25259341!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| leadingTab currentX |	characterIndex == nil ifFalse: [		"If the last character of the last line is a space,		and it crosses the right margin, then locating		the character block after it is impossible without this hack."		characterIndex > text size ifTrue: [			lastIndex := characterIndex.			characterPoint := (nextLeftMargin ifNil: [leftMargin]) @ (destY + line lineHeight).			^true]].	characterPoint x <= (destX + (lastCharacterExtent x // 2))		ifTrue:	[lastCharacter := (text at: lastIndex).				characterPoint := destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter := (text at: line last).				characterPoint := destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex := lastIndex + 1.	lastCharacter := text at: lastIndex.	currentX := destX + lastCharacterExtent x + kern.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint := currentX @ destY.	lastCharacter = Space ifFalse: [^ true].	"Yukky if next character is space or tab."	alignment = Justified ifTrue:		[self lastCharacterExtentSetX:			(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1))).		^ true].	true ifTrue: [^ true].	"NOTE:  I find no value to the following code, and so have defeated it - DI"	"See tabForDisplay for illumination on the following awfulness."	leadingTab := true.	line first to: lastIndex - 1 do:		[:index | (text at: index) ~= Tab ifTrue: [leadingTab := false]].	(alignment ~= Justified or: [leadingTab])		ifTrue:	[self lastCharacterExtentSetX: (textStyle nextTabXFrom: currentX					leftMargin: leftMargin rightMargin: rightMargin) -						currentX]		ifFalse:	[self lastCharacterExtentSetX:  (((currentX + (textStyle tabWidth -						(line justifiedTabDeltaFor: spaceCount))) -							currentX) max: 0)].	^ true! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25261447!endOfRun	"Before arriving at the cursor location, the selection has encountered an 	end of run. Answer false if the selection continues, true otherwise. Set 	up indexes for building the appropriate CharacterBlock."	| runLength lineStop |	(((characterIndex ~~ nil and:		[runStopIndex < characterIndex and: [runStopIndex < text size]])			or:	[characterIndex == nil and: [lastIndex < line last]]) or: [				((lastIndex < line last)				and: [((text at: lastIndex) leadingChar ~= (text at: lastIndex+1) leadingChar)					and: [lastIndex ~= characterIndex]])])		ifTrue:	["We're really at the end of a real run."				runLength := (text runLengthFor: (lastIndex := lastIndex + 1)).				characterIndex ~~ nil					ifTrue:	[lineStop := characterIndex	"scanning for index"]					ifFalse:	[lineStop := line last			"scanning for point"].				(runStopIndex := lastIndex + (runLength - 1)) > lineStop					ifTrue: 	[runStopIndex := lineStop].				self setStopConditions.				^false].	lastCharacter := text at: lastIndex.	characterPoint := destX @ destY.	((lastCharacter = Space and: [alignment = Justified])		or: [lastCharacter = Tab and: [lastSpaceOrTabExtent notNil]])		ifTrue: [lastCharacterExtent := lastSpaceOrTabExtent].	characterIndex ~~ nil		ifTrue:	["If scanning for an index and we've stopped on that index,				then we back destX off by the width of the character stopped on				(it will be pointing at the right side of the character) and return"				runStopIndex = characterIndex					ifTrue:	[self characterPointSetX: destX - lastCharacterExtent x.							^true].				"Otherwise the requested index was greater than the length of the				string.  Return string size + 1 as index, indicate further that off the				string by setting character to nil and the extent to 0."				lastIndex :=  lastIndex + 1.				lastCharacter := nil.				self lastCharacterExtentSetX: 0.				^true].	"Scanning for a point and either off the end of the line or off the end of the string."	runStopIndex = text size		ifTrue:	["off end of string"				lastIndex :=  lastIndex + 1.				lastCharacter := nil.				self lastCharacterExtentSetX: 0.				^true].	"just off end of line without crossing x"	lastIndex := lastIndex + 1.	^true! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25256145!indentationLevel: anInteger	super indentationLevel: anInteger.	nextLeftMargin := leftMargin.	indentationLevel timesRepeat: [		nextLeftMargin := textStyle nextTabXFrom: nextLeftMargin					leftMargin: leftMargin					rightMargin: rightMargin]! !!MultiCharacterBlockScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25268399!lastCharacterExtentSetX: xVal	lastCharacterExtent := xVal @ lastCharacterExtent y! !!MultiCharacterBlockScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25268565!lastSpaceOrTabExtentSetX: xVal	lastSpaceOrTabExtent := xVal @ lastSpaceOrTabExtent y! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25263755!paddedSpace	"When the line is justified, the spaces will not be the same as the font's 	space character. A padding of extra space must be considered in trying 	to find which character the cursor is pointing at. Answer whether the 	scanning has crossed the cursor."	| pad |	pad := 0.	spaceCount := spaceCount + 1.	pad := line justifiedPadFor: spaceCount.	lastSpaceOrTabExtent := lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX:  spaceWidth + pad.	(destX + lastSpaceOrTabExtent x)  >= characterPoint x		ifTrue: [lastCharacterExtent := lastSpaceOrTabExtent copy.				^self crossedX].	lastIndex := lastIndex + 1.	destX := destX + lastSpaceOrTabExtent x.	^ false! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25256474!placeEmbeddedObject: anchoredMorph	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	specialWidth := anchoredMorph width.	^ true! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25256824!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| encoding f nextDestX maxAscii startEncoding char charValue |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		char := (sourceString at: lastIndex).		charValue := char charCode.		charValue > maxAscii ifTrue: [charValue := maxAscii].		(encoding = 0 and: [(stopConditions at: charValue + 1) ~~ nil]) ifTrue: [			^ stops at: charValue + 1		].		nextDestX := destX + (self widthOf: char inFont: font).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25264523!setFont	specialWidth := nil.	super setFont! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25264921!tab	| currentX |	currentX := (alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse:			[textStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastSpaceOrTabExtent := lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX: (currentX - destX max: 0).	currentX >= characterPoint x		ifTrue: 			[lastCharacterExtent := lastSpaceOrTabExtent copy.			^ self crossedX].	destX := currentX.	lastIndex := lastIndex + 1.	^false! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31993038!discardDefault"	self discardDefault"	| ttc |	ttc := TTCFontDescription default.	ttc ifNotNil: [		TextConstants removeKey: ttc name asSymbol ifAbsent: [].	].! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31993287!familyName: n pointSize: s	"(self familyName: 'MultiMSGothic' pointSize: 14) pointSize"	| t ret index |	t := self registry at: n asSymbol ifAbsent: [#()].	t isEmpty ifTrue: [		t := (TextConstants at: #DefaultTextStyle) fontArray.		ret := t first.		ret pointSize >= s ifTrue: [^ ret].		index := 2.		[index <= t size and: [(t at: index) pointSize <= s]] whileTrue: [			ret := t at: index.			index := index + 1.		].		^ ret.	].	^ (TextStyle named: n) addNewFontSize: s.! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31993849!initialize"	self initialize"	| tt |	tt := TTCFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31994211!newTextStyleFromTT: descriptionArray	| array f textStyle styleName arrayOfArray |	arrayOfArray := self pointSizes collect: [:pt |		descriptionArray collect: [:ttc |			ttc ifNil: [nil] ifNotNil: [				f := (ttc size > 256)					ifTrue: [MultiTTCFont new initialize]					ifFalse: [TTCFont new initialize].				f ttcDescription: ttc.				f pointSize: pt.			].		].	].	array := arrayOfArray collect: [:fonts |		self newFontArray: fonts.	].	styleName := (array at: 1) familyName asSymbol.	textStyle := TextStyle fontArray: array.	TextConstants at: styleName put: textStyle.	self register: array at: styleName.	^ TextConstants at: styleName.! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31994949!newTextStyleFromTTFile: fileName"	TTCFontReader encodingTag: JapaneseEnvironment leadingChar.	self newTextStyleFromTTFile: 'C:\WINDOWS\Fonts\msmincho.TTC'	TTCFontReader encodingTag: 0.	self newTextStyleFromTTFile: 'C:\WINDOWS\Fonts\symbol.ttf'"	| description |	description := TTCFontDescription addFromTTFile: fileName.	^ self newTextStyleFromTT: description.! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31995877!removeStyleName: aString	| style symName |	symName := aString asSymbol.	style := TextConstants removeKey: symName ifAbsent: [].	style ifNotNil: [self unregister: symName].	TTCFontDescription removeDescriptionNamed: aString asString.! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31996200!setDefault"	self setDefault"	| tt |	tt := TTCFontDescription default.	tt ifNil: [TTCFontDescription setDefault].	tt := TTCFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31986994!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| destPoint font form encoding glyphInfo char charCode destY |	destPoint := aPoint.	glyphInfo := Array new: 5.	startIndex to: stopIndex do: [:charIndex |		char := aString at: charIndex.		encoding := char leadingChar + 1.		charCode := char charCode.		font := fontArray at: encoding.		((charCode between: font minAscii and: font maxAscii) not) ifTrue: [			charCode := font maxAscii].		self glyphInfoOf: char into: glyphInfo.		form := glyphInfo first.		(glyphInfo fifth ~= aBitBlt lastFont) ifTrue: [			glyphInfo fifth installOn: aBitBlt.		].		destY := baselineY - glyphInfo fourth. 		aBitBlt sourceForm: form.		aBitBlt destX: destPoint x.		aBitBlt destY: destY.		aBitBlt sourceOrigin: 0 @ 0.		aBitBlt width: form width.		aBitBlt height: form height.		aBitBlt copyBits.		destPoint := destPoint + (form width + kernDelta @ 0).	].	^ destPoint.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31988043!displayStringR2L: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	| destPoint font form encoding char charCode glyphInfo |	destPoint := aPoint.	glyphInfo := Array new: 5.	startIndex to: stopIndex do: [:charIndex |		char := aString at: charIndex.		encoding := char leadingChar + 1.		charCode := char charCode.		font := fontArray at: encoding.		((charCode between: font minAscii and: font maxAscii) not) ifTrue: [			charCode := font maxAscii].		self glyphInfoOf: char into: glyphInfo.		form := glyphInfo first.			(glyphInfo size > 4 and: [glyphInfo fifth notNil and: [glyphInfo fifth ~= aBitBlt lastFont]]) ifTrue: [				glyphInfo fifth installOn: aBitBlt.			].		aBitBlt sourceForm: form.		aBitBlt destX: destPoint x - form width.		aBitBlt destY: destPoint y.		aBitBlt sourceOrigin: 0 @ 0.		aBitBlt width: form width.		aBitBlt height: form height.		aBitBlt copyBits.		destPoint := destPoint - (form width + kernDelta @ 0).	].! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31989713!glyphInfoOf: aCharacter into: glyphInfoArray	| index f code |	index := aCharacter leadingChar + 1.	fontArray size < index ifTrue: [^ self questionGlyphInfoInto: glyphInfoArray].	(f := fontArray at: index) ifNil: [^ self questionGlyphInfoInto: glyphInfoArray].	code := aCharacter charCode.	((code between: f minAscii and: f maxAscii) not) ifTrue: [		^ self questionGlyphInfoInto: glyphInfoArray.	].	f glyphInfoOf: aCharacter into: glyphInfoArray.	glyphInfoArray at: 5 put: self.	^ glyphInfoArray.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31990417!initializeWithFontArray: anArray	fontArray := anArray.	"name := anArray first name."! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31990730!installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor	foregroundColor := fgColor.	fontArray do: [:s | s ifNotNil: [s installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor]].! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31991249!maxAsciiFor: encoding	| f |	f := (fontArray at: encoding+1).	f ifNotNil: [^ f maxAscii].	^ 0.! !!TTCFontSet methodsFor: 'objects from disk' stamp: 'sd 2/4/2008 21:20' prior: 31992515!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write areference to a known FontSet in the other system instead."	"a path to me"	dp := DiskProxy global: #TTCFontSet selector: #familyName:pointSize:			args: {self familyName. self pointSize}.	refStrm replace: self with: dp.	^ dp.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31991678!questionGlyphInfoInto: glyphInfoArray	| f form |	f := fontArray at: 1.	form := f formOf: $?.	glyphInfoArray at: 1 put: form;		at: 2 put: 0;		at: 3 put: form width;		at: 4 put: self.	^ glyphInfoArray.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31992312!widthOf: aCharacter	| encoding |	encoding := aCharacter leadingChar.	^ (fontArray at: encoding + 1) widthOf: aCharacter.! !!CombinedChar class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 19030333!parseCompositionMappingFrom: stream"	self halt.	self parseCompositionMapping"	| line fieldEnd point fieldStart compositions toNumber diacritical result |	toNumber := [:quad | ('16r', quad) asNumber].	Compositions := IdentityDictionary new: 2048.	Decompositions := IdentityDictionary new: 2048.	Diacriticals := IdentitySet new: 2048.	[(line := stream upTo: Character cr) size > 0] whileTrue: [		fieldEnd := line indexOf: $; startingAt: 1.		point := ('16r', (line copyFrom: 1 to: fieldEnd - 1)) asNumber.		2 to: 6 do: [:i |			fieldStart := fieldEnd + 1.			fieldEnd := line indexOf: $; startingAt: fieldStart.		].		compositions := line copyFrom: fieldStart to: fieldEnd - 1.		(compositions size > 0 and: [compositions first ~= $<]) ifTrue: [			compositions := compositions substrings collect: toNumber.			compositions size > 1 ifTrue: [				diacritical := compositions first.				Diacriticals add: diacritical.				result := compositions second.				(Decompositions includesKey: point) ifTrue: [					self error: 'should not happen'.				] ifFalse: [					Decompositions at: point put: (Array with: diacritical with: result).				].				(Compositions includesKey: diacritical) ifTrue: [					(Compositions at: diacritical) at: result put: point.				] ifFalse: [					Compositions at: diacritical						put: (IdentityDictionary new at: result put: point; yourself).				].			].		].	].! !!CombinedChar methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 19029505!add: char	| dict elem |	codes ifNil: [codes := Array with: char. combined := char. ^ true].	dict := Compositions at: combined charCode ifAbsent: [^ false].	elem := dict at: combined charCode ifAbsent: [^ false].	codes := codes copyWith: char.	combined := elem.	^ true.! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25307960!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	lastIndex:= lastIndex + 1.	^false! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25305124!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos |	line := textLine.	morphicOffset := offset.	lineY := line top + offset y.	lineHeight := line lineHeight.	rightMargin := line rightMargin + offset x.	lastIndex := line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	destX := runX := leftMargin.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: line width left height: lineHeight; copyBits].	lastIndex := line first.	leftInRun <= 0		ifTrue: [nowLeftInRun := text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun := leftInRun].	baselineY := lineY + line baseline.	destY := baselineY - font ascent.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	done := false.	string := text string.	[done] whileFalse:[		startIndex := lastIndex.		lastPos := destX@destY.		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex to: lastIndex at: lastPos kern: kern baselineY: baselineY].		"see setStopConditions for stopping conditions for displaying."		done := self perform: stopCondition.		"lastIndex > runStopIndex ifTrue: [done := true]."	].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!MultiDisplayScanner methodsFor: 'MVC-compatibility' stamp: 'sd 2/4/2008 21:22' prior: 25299915!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun startIndex string lastPos |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	morphicOffset := 0@0.	leftInRun := 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges := false.	paragraph := aParagraph.	foregroundColor := paragraphColor := aParagraph foregroundColor.	backgroundColor := aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt := nil]		ifFalse: [fillBlt := bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin := aParagraph rightMarginForDisplay.	lineY := aParagraph topAtLineIndex: linesInterval first.	bitBlt destForm deferUpdatesIn: visibleRectangle while: [		linesInterval do: 			[:lineIndex | 			leftMargin := aParagraph leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment]).			destX := (runX := leftMargin).			line := aParagraph lines at: lineIndex.			lineHeight := line lineHeight.			fillBlt == nil ifFalse:				[fillBlt destX: visibleRectangle left destY: lineY					width: visibleRectangle width height: lineHeight; copyBits].			lastIndex := line first.			leftInRun <= 0				ifTrue: [self setStopConditions.  "also sets the font"						leftInRun := text runLengthFor: line first].			baselineY := lineY + line baseline.			destY := baselineY - font ascent.  "Should have happened in setFont"			runLength := leftInRun.			runStopIndex := lastIndex + (runLength - 1) min: line last.			leftInRun := leftInRun - (runStopIndex - lastIndex + 1).			spaceCount := 0.			done := false.			string := text string.			self handleIndentation.			[done] whileFalse:[				startIndex := lastIndex.				lastPos := destX@destY.				stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex							in: string rightX: rightMargin stopConditions: stopConditions							kern: kern.				lastIndex >= startIndex ifTrue:[					font displayString: string on: bitBlt 						from: startIndex to: lastIndex at: lastPos kern: kern baselineY: baselineY].				"see setStopConditions for stopping conditions for displaying."				done := self perform: stopCondition].			fillBlt == nil ifFalse:				[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].			lineY := lineY + lineHeight]]! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25308673!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	lastIndex = line last ifTrue: [^true].	runX := destX.	runLength := text runLengthFor: (lastIndex := lastIndex + 1).	runStopIndex := lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!MultiDisplayScanner methodsFor: 'MVC-compatibility' stamp: 'sd 2/4/2008 21:22' prior: 25302890!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	super initializeFromParagraph: aParagraph clippedBy: clippingRectangle.	bitBlt := BitBlt asGrafPort toForm: aParagraph destinationForm.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt combinationRule: Form paint.	bitBlt colorMap:		(Bitmap with: 0      "Assumes 1-bit deep fonts"				with: (bitBlt destForm pixelValueFor: aParagraph foregroundColor)).	bitBlt clipRect: clippingRectangle.! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25309180!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	spaceCount := spaceCount + 1.	destX := destX + spaceWidth + (line justifiedPadFor: spaceCount).	lastIndex := lastIndex + 1.	^ false! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25307163!placeEmbeddedObject: anchoredMorph	anchoredMorph relativeTextAnchorPosition ifNotNil:[		anchoredMorph position: 			anchoredMorph relativeTextAnchorPosition +			(anchoredMorph owner textBounds origin x @ 0)			- (0@morphicOffset y) + (0@lineY).		^true	].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph ifTrue: [		anchoredMorph position: ((destX - anchoredMorph width)@lineY) - morphicOffset	] ifFalse: [		destY := lineY.		baselineY := lineY + anchoredMorph height..		runX := destX.		anchoredMorph 			displayOn: bitBlt destForm 			at: destX - anchoredMorph width @ destY			clippingBox: bitBlt clipRect			rule: Form blend			fillColor: Color white 	].	^ true! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25309690!plainTab	| oldX |	oldX := destX.	super plainTab.	fillBlt == nil ifFalse:		[fillBlt destX: oldX destY: destY width: destX - oldX height: font height; copyBits]! !!MultiDisplayScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25310518!presentationText: t	text := t.! !!MultiDisplayScanner methodsFor: 'multilingual scanning' stamp: 'sd 2/4/2008 21:22' prior: 25303653!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| encoding f nextDestX maxAscii startEncoding char charValue |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		char := (sourceString at: lastIndex).		charValue := char charCode.		charValue > maxAscii ifTrue: [charValue := maxAscii].		(encoding = 0 and: [(stopConditions at: charValue + 1) ~~ nil]) ifTrue: [			^ stops at: charValue + 1		].		nextDestX := destX + (self widthOf: char inFont: font).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!MultiDisplayScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25310744!setFont 	foregroundColor := paragraphColor.	super setFont.  "Sets font and emphasis bits, and maybe foregroundColor"	font installOn: bitBlt foregroundColor: foregroundColor backgroundColor: Color transparent.	text ifNotNil:[		baselineY := lineY + line baseline.		destY := baselineY - font ascent].! !!MultiDisplayScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25311123!setPort: aBitBlt	"Install the BitBlt to use"	bitBlt := aBitBlt.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt sourceForm: nil. "Make sure font installation won't be confused"! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25309938!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	self setConditionArray: (alignment = Justified ifTrue: [#paddedSpace])."	alignment = Justified ifTrue: [		stopConditions == DefaultStopConditions 			ifTrue:[stopConditions := stopConditions copy].		stopConditions at: Space asciiValue + 1 put: #paddedSpace]"! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25310384!tab	self plainTab.	lastIndex := lastIndex + 1.	^ false! !!MultiDisplayScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25311435!text: t textStyle: ts foreground: foreColor background: backColor fillBlt: blt ignoreColorChanges: shadowMode	text := t.	textStyle := ts. 	foregroundColor := paragraphColor := foreColor.	(backgroundColor := backColor) isTransparent ifFalse:		[fillBlt := blt.		fillBlt fillColor: backgroundColor].	ignoreColorChanges := shadowMode! !!MultiDisplayScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25311842!textColor: textColor	ignoreColorChanges ifTrue: [^ self].	foregroundColor := textColor! !!XTableForFixedFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 50983724!maxAscii: anInteger	maxCode := anInteger.! !!XTableForFixedFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 50984175!width: anInteger	width := anInteger.! !!MultiCharacterScanner class methodsFor: 'class initialization' stamp: 'sd 2/4/2008 21:22' prior: 25286574!initialize"	MultiCharacterScanner initialize"	| a |	a := Array new: 258.	a at: 1 + 1 put: #embeddedObject.	a at: Tab asciiValue + 1 put: #tab.	a at: CR asciiValue + 1 put: #cr.	a at: EndOfRun put: #endOfRun.	a at: CrossedX put: #crossedX.	NilCondition := a copy.	DefaultStopConditions := a copy.	PaddedSpaceCondition := a copy.	PaddedSpaceCondition at: Space asciiValue + 1 put: #paddedSpace.		SpaceCondition := a copy.	SpaceCondition at: Space asciiValue + 1 put: #space.! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25283851!addEmphasis: code	"Set the bold-ital-under-strike emphasis."	emphasisCode := emphasisCode bitOr: code! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25284033!addKern: kernDelta	"Set the current kern amount."	kern := kern + kernDelta! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'sd 2/4/2008 21:22' prior: 25270454!basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable, indexed by map. 	If dextX would exceed rightX, then return stops at: 258. 	Advance destX by the width of the character. If stopIndex has been	reached, then return stops at: 257. Optional. 	See Object documentation whatIsAPrimitive."	| ascii nextDestX char |	<primitive: 103>	lastIndex := startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[char := (sourceString at: lastIndex).			ascii := char asciiValue + 1.			(stops at: ascii) == nil ifFalse: [^stops at: ascii].			"Note: The following is querying the font about the width			since the primitive may have failed due to a non-trivial			mapping of characters to glyphs or a non-existing xTable."			nextDestX := destX + (font widthOf: char).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			destX := nextDestX + kernDelta.			lastIndex := lastIndex + 1].	lastIndex := stopIndex.	^stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25280079!embeddedObject	| savedIndex |	savedIndex := lastIndex.	text attributesAt: lastIndex do:[:attr| 		attr anchoredMorph ifNotNil:[			"Following may look strange but logic gets reversed.			If the morph fits on this line we're not done (return false for true) 			and if the morph won't fit we're done (return true for false)"			(self placeEmbeddedObject: attr anchoredMorph) ifFalse:[^true]]].	lastIndex := savedIndex + 1. "for multiple(!!) embedded morphs"	^false! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25280996!indentationLevel: anInteger	"set the number of tabs to put at the beginning of each line"	indentationLevel := anInteger! !!MultiCharacterScanner methodsFor: 'initialize' stamp: 'sd 2/4/2008 21:22' prior: 25269221!initialize	destX := destY := leftMargin := 0.! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25284188!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	text := aParagraph text.	textStyle := aParagraph textStyle. ! !!MultiCharacterScanner methodsFor: 'initialize' stamp: 'sd 2/4/2008 21:22' prior: 25269347!initializeStringMeasurer	stopConditions := Array new: 258.	stopConditions at: CrossedX put: #crossedX.	stopConditions at: EndOfRun put: #endOfRun.! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25281418!measureString: aString inFont: aFont from: startIndex to: stopIndex	"WARNING: In order to use this method the receiver has to be set up using #initializeStringMeasurer"	destX := destY := lastIndex := 0.	baselineY := aFont ascent.	xTable := aFont xTable.	font := aFont.  " added Dec 03, 2004 ""	map := aFont characterToGlyphMap."	self scanCharactersFrom: startIndex to: stopIndex in: aString rightX: 999999 stopConditions: stopConditions kern: 0.	^destX! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25281953!placeEmbeddedObject: anchoredMorph	"Place the anchoredMorph or return false if it cannot be placed.	In any event, advance destX by its width."	| w |	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	destX := destX + (w := anchoredMorph width).	(destX > rightMargin and: [(leftMargin + w) <= rightMargin])		ifTrue: ["Won't fit, but would on next line"				^ false].	lastIndex := lastIndex + 1.	self setFont.  "Force recalculation of emphasis for next run"	^ true! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25282574!plainTab	"This is the basic method of adjusting destX for a tab."	destX := (alignment == Justified and: [self leadingTab not])		ifTrue:		"embedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin]! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25283026!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isByteString) ifTrue: [^ self basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isWideString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].		startEncoding :=  (sourceString at: startIndex) leadingChar.		selector := (EncodedCharSet charsetAt: startEncoding) scanSelector.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stopConditions with: kernDelta).	].		^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'sd 2/4/2008 21:22' prior: 25272234!scanJapaneseCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		"xTable := f xTable.		maxAscii := xTable size - 2."		spaceWidth := f widthOf: Space.	] ifFalse: [		(font isMemberOf: HostFont) ifTrue: [			f := font.			maxAscii := f maxAscii.			spaceWidth := f widthOf: Space.		] ifFalse: [			maxAscii := font maxAscii.		].	].	[lastIndex <= stopIndex] whileTrue: [		"self halt."		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		ascii := (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii := maxAscii].		(encoding = 0 and: [(stopConditions at: ascii + 1) ~~ nil]) ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: (EncodedCharSet charsetAt: encoding)) ifTrue: [			self registerBreakableIndex.		].		nextDestX := destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [firstDestX ~= destX ifTrue: [^ stops at: CrossedX]].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'sd 2/4/2008 21:22' prior: 25274038!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| charCode encoding f maxAscii startEncoding combining combined combiningIndex c |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := font widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.		spaceWidth := font widthOf: Space.	].	combining := nil.	[lastIndex <= stopIndex] whileTrue: [		charCode := (sourceString at: lastIndex) charCode.		c := (sourceString at: lastIndex).		combining ifNil: [			combining := CombinedChar new.			combining add: c.			combiningIndex := lastIndex.			lastIndex := lastIndex + 1.		] ifNotNil: [			(combining add: c) ifFalse: [				self addCharToPresentation: (combined := combining combined).				combining := CombinedChar new.				combining add: c.				charCode := combined charCode.				encoding := combined leadingChar.				encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1.					(encoding = 0 and: [(stopConditions at: charCode + 1) ~~ nil]) ifTrue: [						^ stops at: charCode + 1					] ifFalse: [						 ^ stops at: EndOfRun					].				].				charCode > maxAscii ifTrue: [charCode := maxAscii].				""				(encoding = 0 and: [(stopConditions at: charCode + 1) ~~ nil]) ifTrue: [					combining ifNotNil: [						self addCharToPresentation: (combining combined).					].					^ stops at: charCode + 1				].				(self isBreakableAt: lastIndex in: sourceString in: Latin1Environment) ifTrue: [					self registerBreakableIndex.				].						destX > rightX ifTrue: [					destX ~= firstDestX ifTrue: [						lastIndex := combiningIndex.						self removeLastCharFromPresentation.						^ stops at: CrossedX]].				combiningIndex := lastIndex.				lastIndex := lastIndex + 1.			] ifTrue: [				lastIndex := lastIndex + 1.				numOfComposition := numOfComposition + 1.			].		].	].	lastIndex := stopIndex.	combining ifNotNil: [		combined := combining combined.		self addCharToPresentation: combined.		"assuming that there is always enough space for at least one character".		destX := destX + (self widthOf: combined inFont: font).	].	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'sd 2/4/2008 21:22' prior: 25276712!scanMultiCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		ascii := (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii := maxAscii].		(encoding = 0 and: [ascii < stopConditions size and: [(stopConditions at: ascii + 1) ~~ nil]]) ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: Latin1Environment) ifTrue: [			self registerBreakableIndex.		].		nextDestX := destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [destX ~= firstDestX ifTrue: [^ stops at: CrossedX]].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'sd 2/4/2008 21:22' prior: 25278328!scanMultiCharactersR2LFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Note that 'rightX' really means 'endX' in R2L context.  Ie.  rightX is usually smaller than destX."	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		ascii := (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii := maxAscii].		(encoding = 0 and: [(stopConditions at: ascii + 1) ~~ nil]) ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: Latin1Environment) ifTrue: [			self registerBreakableIndex.		].		nextDestX := destX - (font widthOf: (sourceString at: lastIndex)).		nextDestX < rightX ifTrue: [^ stops at: CrossedX].		destX := nextDestX - kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25284395!setActualFont: aFont	"Set the basal font to an isolated font reference."	font := aFont! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25284563!setAlignment: style	alignment := style.	! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25284684!setConditionArray: aSymbol	aSymbol == #paddedSpace ifTrue: [^stopConditions := PaddedSpaceCondition "copy"].	"aSymbol == #space ifTrue: [^stopConditions := SpaceCondition copy]."	aSymbol == nil ifTrue: [^stopConditions := NilCondition "copy"].	self error: 'undefined stopcondition for space character'.! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25285070!setFont	| priorFont |	"Set the font and other emphasis."	priorFont := font.	text == nil ifFalse:[		emphasisCode := 0.		kern := 0.		indentationLevel := 0.		alignment := textStyle alignment.		font := nil.		(text attributesAt: lastIndex forStyle: textStyle)			do: [:att | att emphasizeScanner: self]].	font == nil ifTrue:		[self setFont: textStyle defaultFontIndex].	font := font emphasized: emphasisCode.	priorFont ifNotNil: [destX := destX + priorFont descentKern].	destX := destX - font descentKern.	"NOTE: next statement should be removed when clipping works"	leftMargin ifNotNil: [destX := destX max: leftMargin].	kern := kern - font baseKern.	"Install various parameters from the font."	spaceWidth := font widthOf: Space.	xTable := font xTable."	map := font characterToGlyphMap."	stopConditions := DefaultStopConditions.! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25286181!text: t textStyle: ts	text := t.	textStyle := ts! !!MultiCharacterScanner methodsFor: 'initialize' stamp: 'sd 2/4/2008 21:22' prior: 25269579!wantsColumnBreaks: aBoolean	wantsColumnBreaks := aBoolean! !!SparseXTable methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:12' prior: 30580940!tableFor: code	| div t table |	div := code // 65536.	t := xTables at: div ifAbsent: [table := Array new: 65536 withAll: 0. xTables at: div put: table. table].	^ t.! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:32' prior: 19956837!additionalRangesForJapanese	| basics |	basics := {		Array with: 16r5C with: 16rFF3C.		Array with: 16r3013 with: 16rFFFD.	}.	^ basics! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:32' prior: 19957073!additionalRangesForKorean	| basics |	basics := {		Array with: 16rA1 with: 16rFFE6C.		Array with: 16r3000 with: 16rFFFD.	}.	^ basics! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:33' prior: 19957308!override: chars with: otherFileName ranges: pairArray transcodingTable: table additionalRange: additionalRange	| other rangeStream currentRange newChars code form u newArray j |	other := BDFFontReader readOnlyFileNamed: otherFileName.	rangeStream := ReadStream on: pairArray.	currentRange := rangeStream next.	newChars := PluggableSet new.	newChars hashBlock: [:elem | (elem at: 2) hash].	newChars equalBlock: [:a :b | (a at: 2) = (b at: 2)].	other readChars do: [:array | 		code := array at: 2.		"code printStringHex printString displayAt: 0@0."		code > currentRange last ifTrue: [			[rangeStream atEnd not and: [currentRange := rangeStream next. currentRange last < code]] whileTrue.			rangeStream atEnd ifTrue: [				newChars addAll: chars.				^ newChars.			].		].		(code between: currentRange first and: currentRange last) ifTrue: [			form := array at: 1.			form ifNotNil: [				j := array at: 2.				u := table at: (((j // 256) - 33 * 94 + ((j \\ 256) - 33)) + 1).				u ~= -1 ifTrue: [					array at: 2 put: u.					newChars add: array.					additionalRange do: [:e |						e first = (array at: 2) ifTrue: [							newArray := array clone.							newArray at: 2 put: e second.							newChars add: newArray						].					]				].			].		].	].	self error: 'should not reach here'.! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:34' prior: 19959006!rangesForJapanese	| basics etc |	basics := {		Array with: 16r5C with: 16r5C.		Array with: 16rA2 with: 16rA3.		Array with: 16rA7 with: 16rA8.		Array with: 16rAC with: 16rAC.		Array with: 16rB0 with: 16rB1.		Array with: 16rB4 with: 16rB4.		Array with: 16rB6 with: 16rB6.		Array with: 16rD7 with: 16rD7.		Array with: 16rF7 with: 16rF7	}.	etc := {		Array with: 16r370 with: 16r3FF. "greek"		Array with: 16r400 with: 16r52F. "cyrillic"		Array with: 16r1D00 with: 16r1D7F. "phonetic"		Array with: 16r1E00 with: 16r1EFF. "latin extended additional"		Array with: 16r2000 with: 16r206F. "general punctuation"		Array with: 16r20A0 with: 16r20CF. "currency symbols"		Array with: 16r2100 with: 16r214F. "letterlike"		Array with: 16r2150 with: 16r218F. "number form"		Array with: 16r2190 with: 16r21FF. "arrows"		Array with: 16r2200 with: 16r22FF. "math operators"		Array with: 16r2300 with: 16r23FF. "misc tech"		Array with: 16r2460 with: 16r24FF. "enclosed alnum"		Array with: 16r2500 with: 16r257F. "box drawing"		Array with: 16r2580 with: 16r259F. "box elem"		Array with: 16r25A0 with: 16r25FF. "geometric shapes"		Array with: 16r2600 with: 16r26FF. "misc symbols"		Array with: 16r2700 with: 16r27BF. "dingbats"		Array with: 16r27C0 with: 16r27EF. "misc math A"		Array with: 16r27F0 with: 16r27FF. "supplimental arrow A"		Array with: 16r2900 with: 16r297F. "supplimental arrow B"		Array with: 16r2980 with: 16r29FF. "misc math B"		Array with: 16r2A00 with: 16r2AFF. "supplimental math op"		Array with: 16r2900 with: 16r297F. "supplimental arrow B"		Array with: 16r2E80 with: 16r2EFF. "cjk radicals suppliment"		Array with: 16r2F00 with: 16r2FDF. "kangxi radicals"		Array with: 16r3000 with: 16r303F. "cjk symbols"		Array with: 16r3040 with: 16r309F. "hiragana"		Array with: 16r30A0 with: 16r30FF. "katakana"		Array with: 16r3190 with: 16r319F. "kanbun"		Array with: 16r31F0 with: 16r31FF. "katakana extension"		Array with: 16r3200 with: 16r32FF. "enclosed CJK"		Array with: 16r3300 with: 16r33FF. "CJK compatibility"		Array with: 16r3400 with: 16r4DBF. "CJK unified extension A"		Array with: 16r4E00 with: 16r9FAF. "CJK ideograph"		Array with: 16rF900 with: 16rFAFF. "CJK compatiblity ideograph"		Array with: 16rFE30 with: 16rFE4F. "CJK compatiblity forms"		Array with: 16rFF00 with: 16rFFEF. "half and full"		Array with: 16rFFFF with: 16rFFFF. "sentinel"	}.	^ basics, etc.! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:34' prior: 19961521!rangesForKorean	| basics etc |	basics := {		Array with: 16rA1 with: 16rFF	}.	etc := {		Array with: 16r100 with: 16r17F. "extended latin"		Array with: 16r370 with: 16r3FF. "greek"		Array with: 16r400 with: 16r52F. "cyrillic"		Array with: 16r2000 with: 16r206F. "general punctuation"		Array with: 16r2100 with: 16r214F. "letterlike"		Array with: 16r2150 with: 16r218F. "number form"		Array with: 16r2190 with: 16r21FF. "arrows"		Array with: 16r2200 with: 16r22FF. "math operators"		Array with: 16r2300 with: 16r23FF. "misc tech"		Array with: 16r2460 with: 16r24FF. "enclosed alnum"		Array with: 16r2500 with: 16r257F. "box drawing"		Array with: 16r2580 with: 16r259F. "box elem"		Array with: 16r25A0 with: 16r25FF. "geometric shapes"		Array with: 16r2600 with: 16r26FF. "misc symbols"		Array with: 16r3000 with: 16r303F. "cjk symbols"		Array with: 16r3040 with: 16r309F. "hiragana"		Array with: 16r30A0 with: 16r30FF. "katakana"		Array with: 16r3190 with: 16r319F. "kanbun"		Array with: 16r31F0 with: 16r31FF. "katakana extension"		Array with: 16r3200 with: 16r32FF. "enclosed CJK"		Array with: 16r3300 with: 16r33FF. "CJK compatibility"		Array with: 16r4E00 with: 16r9FAF. "CJK ideograph"		Array with: 16rAC00 with: 16rD7AF. "Hangul Syllables"		Array with: 16rF900 with: 16rFAFF. "CJK compatiblity ideograph"		Array with: 16rFF00 with: 16rFFEF. "half and full"	}.	^ basics, etc.! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:35' prior: 19963337!readCharactersInRanges: ranges storeInto: chars	| array form code rangeStream currentRange |	rangeStream := ReadStream on: ranges.	currentRange := rangeStream next.	[true] whileTrue: [		array := self readOneCharacter.		array second ifNil: [^ self].		code := array at: 2.		code > currentRange last ifTrue: [			[rangeStream atEnd not and: [currentRange := rangeStream next. currentRange last < code]] whileTrue.			rangeStream atEnd ifTrue: [^ self].		].		(code between: currentRange first and: currentRange last) ifTrue: [			form := array at: 1.			form ifNotNil: [				chars add: array.			].		].	].! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:09' prior: 19964043!readRanges: ranges	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx width blt lastAscii pointSize ret lastValue start end |	form := encoding := bbx := nil.	self initialize.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	(properties includesKey: 'POINT_SIZE' asSymbol) ifTrue: [		pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.	] ifFalse: [		pointSize := (ascent + descent) * 72 // 96.	].	maxWidth := 0.	minAscii := 16r200000.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	self readCharactersInRanges: ranges storeInto: chars.	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum := chars size. "undefined encodings make this different"	chars do: [:array |		encoding := array at: 2.		bbx := array at: 3..		width := bbx at: 1.		maxWidth := maxWidth max: width.		minAscii := minAscii min: encoding.		maxAscii := maxAscii max: encoding.		strikeWidth := strikeWidth + width.	].	glyphs := Form extent: strikeWidth@height.	blt := BitBlt toForm: glyphs.	start := (ranges collect: [:r | r first]) min.	end := (ranges collect: [:r | r second]) max + 3.	xTable := SparseLargeTable new: end chunkSize: 64 arrayClass: Array base: start +1 defaultValue: -1.	lastAscii := start.	xTable at: lastAscii + 2 put: 0.	1 to: charsNum do: [:i |		form := (chars at: i) first.		encoding := (chars at: i) second.		bbx := (chars at: i) third.		"lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)]."		lastValue := xTable at: lastAscii + 1 + 1.		xTable at: encoding + 1 put: lastValue.		blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))				extent: (bbx at: 1)@(bbx at: 2))			from: 0@0 in: form.		xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).		lastAscii := encoding.	].	xTable at: xTable size put: (xTable at: xTable size - 1).	xTable zapDefaultOnlyEntries.	ret := Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:39' prior: 19966694!readRanges: ranges overrideWith: otherFileName otherRanges: otherRanges additionalOverrideRange: additionalRange	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx width blt lastAscii pointSize ret lastValue start end |	form := encoding := bbx := nil.	self initialize.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	(properties includesKey: 'POINT_SIZE' asSymbol) ifTrue: [		pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.	] ifFalse: [		pointSize := (ascent + descent) * 72 // 96.	].				maxWidth := 0.	minAscii := 16r200000.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	self readCharactersInRanges: ranges storeInto: chars.	chars := self override: chars with: otherFileName ranges: otherRanges transcodingTable: (UCSTable jisx0208Table) additionalRange: additionalRange.	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum := chars size. "undefined encodings make this different"		chars do: [:array |		encoding := array at: 2.		bbx := array at: 3..		width := bbx at: 1.		maxWidth := maxWidth max: width.		minAscii := minAscii min: encoding.		maxAscii := maxAscii max: encoding.		strikeWidth := strikeWidth + width.	].	glyphs := Form extent: strikeWidth@height.	blt := BitBlt toForm: glyphs.	start := ((ranges collect: [:r | r first]), (additionalRange collect: [:r2 | r2 first])) min.	end := ((ranges collect: [:r | r second]), (additionalRange collect: [:r2 | r2 second])) max + 3.	"xRange := Array with: (Array with: ((ranges collect: [:r | r first]), (additionalRange collect: [:r2 | r2 first])) min						with: (((ranges collect: [:r | r second]), (additionalRange collect: [:r2 | r2 second])) max + 2))."	"xTable := XTableForUnicodeFont new		ranges: xRange."	xTable := SparseLargeTable new: end chunkSize: 64 arrayClass: Array base: start defaultValue: -1.	lastAscii := start.	xTable at: lastAscii + 2 put: 0.	1 to: charsNum do: [:i |		form := (chars at: i) first.		encoding := (chars at: i) second.		bbx := (chars at: i) third.		"lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)]."		lastValue := xTable at: lastAscii + 1 + 1.		xTable at: encoding + 1 put: lastValue.		blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))				extent: (bbx at: 1)@(bbx at: 2))			from: 0@0 in: form.		xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).		lastAscii := encoding.	].	xTable at: xTable size put: (xTable at: xTable size - 1).	xTable zapDefaultOnlyEntries.	ret := Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!XTableForUnicodeFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 50984465!at: indexPlusOne	| index |	index := indexPlusOne.	ranges with: xTables do: [:range :xTable |		(range first <= index and: [index <= range last]) ifTrue: [			^ xTable at: index - range first + 1.		].	].	^ 0.! !!XTableForUnicodeFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 50985056!ranges: pairArray	xTables := Array new: 0.	pairArray do: [:range |		xTables := xTables copyWith: (Array new: range last - range first + 1 withAll: 0).	].	ranges := pairArray.! !!StrikeFontFixer class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31127894!initialize"	StrikeFontFixer initialize"	| d |	self initializeNoFontTable.	d := Array new: 256.	0 to: 127 do: [:i | d at: i+1 put: i].	16r80 to: 16r9F do: [:i | d at: i+1 put: nil].	d at: 16rA0+1 put: 16r20.	d at: 16rA1+1 put: 16rC1.	d at: 16rA2+1 put: 16rA2.	d at: 16rA3+1 put: 16rA3.	d at: 16rA4+1 put: 16rA9. "CURRENCY SIGN"	d at: 16rA5+1 put: 16rB4.	d at: 16rA6+1 put: 16r7C. "BROKEN BAR"	d at: 16rA7+1 put: 16rA4.	d at: 16rA8+1 put: 16r80. "DIAERESIS"	d at: 16rA9+1 put: 16rA9.	d at: 16rAA+1 put: 16rBB.	d at: 16rAB+1 put: 16rC7.	d at: 16rAC+1 put: 16rD1. "NOT SIGN"	d at: 16rAD+1 put: 16rD0.	d at: 16rAE+1 put: 16rA8.	d at: 16rAF+1 put: 16rD1. "MACRON"	d at: 16rB0+1 put: 16rA1.	d at: 16rB1+1 put: 16r2B. "PLUS-MINUS SIGN"	d at: 16rB2+1 put: 16rAB. "SUPERSCRIPT TWO"	d at: 16rB3+1 put: 16rAB. "SUPERSCRIPT THREE"	d at: 16rB4+1 put: 16rAB.	d at: 16rB5+1 put: 16r75. "MICRO SIGN"	d at: 16rB6+1 put: 16rA6.	d at: 16rB7+1 put: 16rA5.	d at: 16rB8+1 put: 16r82. "CEDILLA"	d at: 16rB9+1 put: 16rAB. "SUPERSCRIPT ONE"	d at: 16rBA+1 put: 16rBC.	d at: 16rBB+1 put: 16rC8.	d at: 16rBC+1 put: 16r4D. "VULGAR FRACTION ONE QUARTER"	d at: 16rBD+1 put: 16r4D. "VULGAR FRACTIOIN ONE HALF"	d at: 16rBE+1 put: 16r4D. "VALGAR FRACTION THREE QUARTERS"	d at: 16rBF+1 put: 16rC0.	d at: 16rC0+1 put: 16rCB.	d at: 16rC1+1 put: 16rCB. "CAPITAL A WITH ACUTE"	d at: 16rC2+1 put: 16rCB. "CAPITAL A WITH CIRCUMFLEX"	d at: 16rC3+1 put: 16rCC.	d at: 16rC4+1 put: 16r80.	d at: 16rC5+1 put: 16r81.	d at: 16rC6+1 put: 16rAE.	d at: 16rC7+1 put: 16r82.	d at: 16rC8+1 put: 16r83. "CAPITAL E WITH GRAVE"	d at: 16rC9+1 put: 16r83.	d at: 16rCA+1 put: 16r83. "CAPITAL E WITH CIRCUMFLEX"	d at: 16rCB+1 put: 16r83. "CAPITAL E WITH DIAERESIS"	d at: 16rCC+1 put: 16r49. "CAPITAL I WITH GRAVE"	d at: 16rCD+1 put: 16r49. "CAPITAL I WITH ACUTE"	d at: 16rCE+1 put: 16r49. "CAPITAL I WITH CIRCUMFLEX"	d at: 16rCF+1 put: 16r49. "CAPITAL I WITH DIAERESIS"	d at: 16rD0+1 put: 16r44. "CAPITAL ETH"	d at: 16rD1+1 put: 16r84.	d at: 16rD2+1 put: 16rCD. "CAPITAL O WITH GRAVE"	d at: 16rD3+1 put: 16rCD. "CAPITAL O WITH ACUTE"	d at: 16rD4+1 put: 16rCD. "CAPITAL O WITH CIRCUMFLEX"	d at: 16rD5+1 put: 16rCD.	d at: 16rD6+1 put: 16r85.	d at: 16rD7+1 put: 16r2B. "MULTIPLICATION SIGN"	d at: 16rD8+1 put: 16rBF.	d at: 16rD9+1 put: 16r86. "CAPITAL U WITH GRAVE"	d at: 16rDA+1 put: 16r86. "CAPITAL U WITH ACUTE"	d at: 16rDB+1 put: 16r86. "CAPITAL U WITH CIRCUMFLEX"	d at: 16rDC+1 put: 16r86. "CAPTIAL U WITH DIAERESIS"	d at: 16rDD+1 put: 16r59. "CAPITAL Y WITH ACUTE"	d at: 16rDE+1 put: 16r50. "CAPITAL THORN"	d at: 16rDF+1 put: 16rA7.	d at: 16rE0+1 put: 16r88.	d at: 16rE1+1 put: 16r87.	d at: 16rE2+1 put: 16r89.	d at: 16rE3+1 put: 16r8B.	d at: 16rE4+1 put: 16r8A.	d at: 16rE5+1 put: 16r8C.	d at: 16rE6+1 put: 16rBE.	d at: 16rE7+1 put: 16r8D.	d at: 16rE8+1 put: 16r8F.	d at: 16rE9+1 put: 16r8E.	d at: 16rEA+1 put: 16r90.	d at: 16rEB+1 put: 16r91.	d at: 16rEC+1 put: 16r93.	d at: 16rED+1 put: 16r92.	d at: 16rEE+1 put: 16r94.	d at: 16rEF+1 put: 16r95.	d at: 16rF0+1 put: 16r64. "SMALL ETH"	d at: 16rF1+1 put: 16r96.	d at: 16rF2+1 put: 16r98.	d at: 16rF3+1 put: 16r97.	d at: 16rF4+1 put: 16r99.	d at: 16rF5+1 put: 16r9B.	d at: 16rF6+1 put: 16r9A.	d at: 16rF7+1 put: 16r2D. "DIVISION SIGN"	d at: 16rF8+1 put: 16rBF.	d at: 16rF9+1 put: 16r9D.	d at: 16rFA+1 put: 16r9C.	d at: 16rFB+1 put: 16r9E.	d at: 16rFC+1 put: 16r9F.	d at: 16rFD+1 put: 16rD8. "SMALL Y WITH ACUTE"	d at: 16rFE+1 put: 16r70. "SMALL THORN"	d at: 16rFF+1 put: 16rD8.	MappingTable := d.! !!StrikeFontFixer class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31131578!initializeNoFontTable	| n |	n := #(	16rA4 "CURRENCY SIGN"	16rA6 "BROKEN BAR"	16rA8 "DIAERESIS"	16rAC "NOT SIGN"	16rAF "MACRON"	16rB1 "PLUS-MINUS SIGN"	16rB2 "SUPERSCRIPT TWO"	16rB3 "SUPERSCRIPT THREE"	16rB5 "MICRO SIGN"	16rB8 "CEDILLA"	16rB9 "SUPERSCRIPT ONE"	16rBC "VULGAR FRACTION ONE QUARTER"	16rBD "VULGAR FRACTIOIN ONE HALF"	16rBE "VALGAR FRACTION THREE QUARTERS"	16rC1 "CAPITAL A WITH ACUTE"	16rC2 "CAPITAL A WITH CIRCUMFLEX"	16rC8 "CAPITAL E WITH GRAVE"	16rCA "CAPITAL E WITH CIRCUMFLEX"	16rCB "CAPITAL E WITH DIAERESIS"	16rCC "CAPITAL I WITH GRAVE"	16rCD "CAPITAL I WITH ACUTE"	16rCE "CAPITAL I WITH CIRCUMFLEX"	16rCF "CAPITAL I WITH DIAERESIS"	16rD0 "CAPITAL ETH"	16rD2 "CAPITAL O WITH GRAVE"	16rD3 "CAPITAL O WITH ACUTE"	16rD4 "CAPITAL O WITH CIRCUMFLEX"	16rD7 "MULTIPLICATION SIGN"	16rD9 "CAPITAL U WITH GRAVE"	16rDA "CAPITAL U WITH ACUTE"	16rDB "CAPITAL U WITH CIRCUMFLEX"	16rDD "CAPITAL Y WITH ACUTE"	16rDE "CAPITAL THORN"	16rF0 "SMALL ETH"	16rF7 "DIVISION SIGN"	16rFD "SMALL Y WITH ACUTE"	16rFE "SMALL THORN"	).	NoFontTable := n.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:12' prior: 31125604!characterFormAt: aCharacter at: aPoint	| f |	f := charForms at: aCharacter asciiValue + 1.	(f magnifyBy: 3) displayAt: aPoint.	^ f.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:13' prior: 31125825!displayOn: aDisplayObject at: aPoint magnifyBy: aNumber	| form hStep vStep bb source nextPoint |	hStep := (strikeFont maxWidth * aNumber * 1.2) asInteger.	vStep := (strikeFont height * aNumber *  1.2) asInteger.		form := Form extent: (hStep * 16)@(vStep * 16).	bb := BitBlt toForm: form.	0 to: 15 do: [:i |		1 to: 16 do: [:j |			source := ((charForms at: (i * 16 + j)) magnifyBy: aNumber).			nextPoint := (hStep * (j - 1)@(vStep * i)).			bb copy: ((nextPoint+((hStep@vStep - source extent) // 2)) extent: source extent)				from: 0@0 in: source fillColor: Color black rule: Form over.		].	].	form displayOn: aDisplayObject at: aPoint.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:13' prior: 31126554!font: aStrikeFont	strikeFont := aStrikeFont.	self forms.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:13' prior: 31126895!initialize	charForms := Array new: 256.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:13' prior: 31127137!storeEditedGlyphsOn: aStream	| n |	NoFontTable do: [:i |		n := strikeFont name.		(n beginsWith: 'NewYork') ifTrue: [n := 'NewYork'].		aStream nextPutAll: '((StrikeFont familyName: ''', n, ''' size: ',			strikeFont height asString, ')'.		aStream nextPutAll: ' characterFormAt: '.		aStream nextPutAll: '(Character value: ', i asString, ')'.		aStream nextPutAll: ' put: '.		(strikeFont characterFormAt: (Character value: i)) storeOn: aStream base: 2.		aStream nextPutAll: ')!!'.		aStream nextPut: Character cr.		aStream nextPut: Character cr.	].! !!ImmX11 methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:21' prior: 22084117!keyboardFocusForAMorph: aMorph	| left bottom pos |	aMorph ifNil: [^ self].	[		pos := aMorph preferredKeyboardPosition.		left := (pos x min: Display width max: 0) asInteger.		bottom := (pos y min: Display height max: 0) asInteger			 + (aMorph paragraph				characterBlockForIndex: aMorph editor selectionInterval first) height.		self setCompositionWindowPositionX: left y: bottom	] on: Error	do: [:ex |].! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:11' prior: 25316581!access: char at: index	| wcache entry |	wcache := self cache.	entry := wcache at: index.	wcache replaceFrom: index to: wcache size - 1 with: wcache startingAt: index + 1.	wcache at: wcache size put: entry.! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:11' prior: 25316874!at: char put: form	| wcache |	wcache := self cache.	wcache replaceFrom: 1 to: wcache size - 1 with: wcache startingAt: 2.	wcache at: wcache size		put: (Array with: char asciiValue with: foregroundColor with: form).! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:12' prior: 25317356!formOf: char	| newForm |	self hasCached: char ifTrue: [:form :index |		self access: char at: index.		^ form.	].	newForm := self computeForm: char.	self at: char put: newForm.	^ newForm.! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:12' prior: 25317632!glyphInfoOf: char into: glyphInfoArray	| newForm |	self hasCached: char ifTrue: [:form :index |		self access: char at: index.		glyphInfoArray at: 1 put: form;			at: 2 put: 0;			at: 3 put: form width;			at: 4 put: (self ascentOf: char);			at: 5 put: self.		^ glyphInfoArray.	].	newForm := self computeForm: char.	self at: char put: newForm.	glyphInfoArray at: 1 put: newForm;		at: 2 put: 0;		at: 3 put: newForm width;		at: 4 put: (self ascentOf: char);		at: 5 put: self.	^ glyphInfoArray.! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:12' prior: 25318223!hasCached: char ifTrue: twoArgBlock	| value elem |	value := char asciiValue.	self cache size to: 1 by: -1 do: [:i |		elem := self cache at: i.		(elem first = value and: [elem second = foregroundColor]) ifTrue: [			^ twoArgBlock value: elem third value: i.		].	].	^ false.! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:12' prior: 25318686!widthOf: char	"This method cannot use #formOf: because formOf: discriminates the color and causes unnecessary bitmap creation."	| newForm |	self hasCached: char ifTrue: [:form :index |		self access: char at: index.		^ form width.	].	newForm := self computeForm: char.	self at: char put: newForm.	^ newForm width.! !!EFontBDFFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:28' prior: 19953661!readCharactersInRangeFrom: start to: stop totalNums: upToNum storeInto: chars	| array form code |	1 to: upToNum do: [:i |		array := self readOneCharacter.		code := array at: 2.		code > stop ifTrue: [^ self].		(code between: start and: stop) ifTrue: [			form := array at: 1.			form ifNotNil: [				chars add: array.			].		].	].! !!EFontBDFFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:21' prior: 19954085!readFrom: start to: end	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx width blt lastAscii pointSize ret lastValue |	form := encoding := bbx := nil.	self initialize.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	(properties includesKey: 'POINT_SIZE' asSymbol) ifTrue: [		pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.	] ifFalse: [		pointSize := (ascent + descent) * 72 // 96.	].				maxWidth := 0.	minAscii := 16r200000.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	self readCharactersInRangeFrom: start to: end totalNums: charsNum storeInto: chars.	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum := chars size. "undefined encodings make this different"	chars do: [:array |		encoding := array at: 2.		bbx := array at: 3..		width := bbx at: 1.		maxWidth := maxWidth max: width.		minAscii := minAscii min: encoding.		maxAscii := maxAscii max: encoding.		strikeWidth := strikeWidth + width.	].	glyphs := Form extent: strikeWidth@height.	blt := BitBlt toForm: glyphs.	"xTable := XTableForUnicodeFont new ranges: (Array with: (Array with: start with: end))."	xTable := SparseLargeTable new: end + 3 chunkSize: 32 arrayClass: Array base: start + 1 defaultValue: -1.	lastAscii := start.		1 to: charsNum do: [:i |		form := (chars at: i) first.		encoding := (chars at: i) second.		bbx := (chars at: i) third.		"lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)]."		lastValue := xTable at: lastAscii + 1 + 1.		xTable at: encoding + 1 put: lastValue.		blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))				extent: (bbx at: 1)@(bbx at: 2))			from: 0@0 in: form.		xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).		lastAscii := encoding.	].	xTable zapDefaultOnlyEntries.	ret _ Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!LanguageEditor methodsFor: 'gui methods' stamp: 'sd 2/4/2008 21:21' prior: 22862070!codeSelectedTranslationAsMimeString	| keys code tmpStream s2 gzs cont |	keys := selectedTranslations				collect: [:key | self translations at: key].	code := String				streamContents: [:aStream | self translator fileOutOn: aStream keys: keys].	tmpStream := MultiByteBinaryOrTextStream on: ''.	tmpStream converter: UTF8TextConverter new.	translator fileOutHeaderOn: tmpStream.	tmpStream nextPutAll: code.	s2 := RWBinaryOrTextStream on: ''.	gzs := GZipWriteStream on: s2.	tmpStream reset.	gzs nextPutAll: (tmpStream binary contentsOfEntireFile asString) contents.	gzs close.	s2 reset.	cont := String streamContents: [:strm |		strm nextPutAll: '"Gzip+Base64 encoded translation for;'; cr.		strm nextPutAll: '#('.		keys do: [:each | strm  nextPutAll: '''', each, ''' '.].		strm nextPutAll: ')"'; cr; cr.		strm nextPutAll: 'NaturalLanguageTranslator loadForLocaleIsoString: '.		strm nextPut: $'.		strm nextPutAll: translator localeID isoString.		strm nextPut: $'.		strm nextPutAll: ' fromGzippedMimeLiteral: '.		strm nextPut: $'.		strm nextPutAll: (Base64MimeConverter mimeEncode: s2) contents.		strm nextPutAll: '''.'.		strm cr.	].		(StringHolder new contents: cont)		openLabel: 'exported codes in Gzip+Base64 encoding'! !!LanguageEditor methodsFor: 'gui methods' stamp: 'sd 2/4/2008 21:21' prior: 22863845!filterTranslations: aString | filter |filter := aString ifNil:[''].""	translationsFilter := filter.self update: #translations.! !!LanguageEditor methodsFor: 'initialization' stamp: 'sd 2/4/2008 21:21' prior: 22874799!initializeNewerKeys	newerKeys := Set new.! !!LanguageEditor methodsFor: 'gui methods' stamp: 'sd 2/4/2008 21:21' prior: 22870557!selectNewerKeys	| translations index |	self deselectAllTranslation.	translations := self translations.	newerKeys do: [:k |		index := translations indexOf: k ifAbsent: [0].		index > 0 ifTrue: [			self selectedTranslationsAt: index put: true		].	].! !!LanguageEditor methodsFor: 'accessing' stamp: 'sd 2/4/2008 21:21' prior: 22858708!translation: aStringOrText 	"change the translation for the selected phrase"	| phrase |	self selectedTranslation isZero		ifTrue: [^ self].	phrase := self translations at: self selectedTranslation.	translator		phrase: phrase		translation: aStringOrText asString.	newerKeys add: phrase.	^ true! !!TranslatedReceiverFinder methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:21' prior: 33022405!senders	| m o |	m := SystemNavigation default allCallsOn: #translated.	m := m collect: [:e |		e classIsMeta ifTrue: [			(Smalltalk at: e classSymbol) class decompile: e methodSymbol.		] ifFalse: [			(Smalltalk at: e classSymbol) decompile: e methodSymbol.		]	].	o := SortedCollection new.	m do: [:e | self searchMethodNode: e addTo: o].	^ o.! !!TTCFontReader class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31985517!encodingTag: aNumber"	TTCFontReader encodingTag: 6"	EncodingTag := aNumber.! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31976778!decodeCmapFmtTable: entry	| cmapFmt length cmap firstCode entryCount segCount segments offset code |	cmapFmt := entry nextUShort.	length := entry nextUShort.	entry skip: 2. "skip version"	cmapFmt = 0 ifTrue: "byte encoded table"		[length := length - 6. 		"should be always 256"		length <= 0 ifTrue: [^ nil].	"but sometimes, this table is empty"		cmap := Array new: length.		entry nextBytes: length into: cmap startingAt: entry offset.		^ cmap].	cmapFmt = 4 ifTrue: "segment mapping to deltavalues"		[segCount := entry nextUShort // 2.		entry skip: 6. "skip searchRange, entrySelector, rangeShift"		segments := Array new: segCount.		segments := (1 to: segCount) collect: [:e | Array new: 4].		1 to: segCount do: [:i | (segments at: i) at: 2 put: entry nextUShort]. "endCount"		entry skip: 2. "skip reservedPad"		1 to: segCount do: [:i | (segments at: i) at: 1 put: entry nextUShort]. "startCount"		1 to: segCount do: [:i | (segments at: i) at: 3 put: entry nextShort]. "idDelta"		offset := entry offset.		1 to: segCount do: [:i | (segments at: i) at: 4 put: entry nextUShort]. "idRangeOffset"		cmap := Array new: 65536 withAll: 0.		segments withIndexDo:			[:seg :si |			seg first to: seg second do:				[:i |					seg last > 0 ifTrue:						["offset to glypthIdArray - this is really C-magic!!"						entry offset: i - seg first - 1 * 2 + seg last + si + si + offset.						code := entry nextUShort.						code > 0 ifTrue: [code := code + seg third]]					ifFalse:						["simple offset"						code := i + seg third].					cmap at: i + 1 put: (code \\ 16r10000)]].		^ cmap].	cmapFmt = 6 ifTrue: "trimmed table"		[firstCode := entry nextUShort.		entryCount := entry nextUShort.		cmap := Array new: entryCount + firstCode withAll: 0.		entryCount timesRepeat:			[cmap at: (firstCode := firstCode + 1) put: entry nextUShort].		^ cmap].	^ nil! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31978718!getTableDirEntry: tagString from: fontData offset: offset	"Find the table named tagString in fontData and return a table directory entry for it."	| nTables pos currentTag tag |	nTables := fontData shortAt: 5 + offset bigEndian: true.	tag := ByteArray new: 4.	1 to: 4 do:[:i| tag byteAt: i put: (tagString at: i) asInteger].	tag := tag longAt: 1 bigEndian: true.	pos := 13 + offset.	1 to: nTables do:[:i|		currentTag := fontData longAt: pos bigEndian: true.		currentTag = tag ifTrue:[^TTFontTableDirEntry on: fontData at: pos].		pos := pos+16].	^nil! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31979356!parseTTCHeaderFrom: fontData	| pos nTables |	nTables := fontData longAt: 9 bigEndian: true.	fonts := Array new: nTables.	pos := 13.	1 to: nTables do: [:i |		fonts at: i put: (fontData longAt: pos bigEndian: true).		pos := pos + 4.	].	^ fonts! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31979688!processCharMap: assoc	"Process the given character map"	| glyph cmap encode0 encode1 char value null |	cmap := assoc value.	null := (glyphs at: (cmap at: Character space asUnicode + 1) + 1) copy.	null contours: #().	encode0 := Array new: 256 withAll: glyphs first.	encode1 := Array new: 65536 withAll: glyphs first.	0 to: 255 do: [:i |		char := Character value: i.		glyph := glyphs at: (cmap at: char asUnicode + 1) + 1.		encode0 at: i+1 put: glyph.	].	Character separators do: [:c |		encode0 at: (c asciiValue + 1) put: null.	].	0 to: 65536 - 1 do: [:i |		value := cmap at: i+1.		value = 65535 ifFalse: [ "???"			encode1 at: i+1 put: (glyphs at: value+1).		]	].	^ {encode0. encode1}.! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31980475!processCharacterMappingTable: entry	"Read the font's character to glyph index mapping table.	If an appropriate mapping can be found then return an association	with the format identifier and the contents of the table"	| copy initialOffset nSubTables pID sID offset cmap assoc |	initialOffset := entry offset.	entry skip: 2. "Skip table version"	nSubTables := entry nextUShort.	1 to: nSubTables do:[:i|		pID := entry nextUShort.		sID := entry nextUShort.		offset := entry nextULong.		"Check if this is either a Macintosh encoded table		or a Windows encoded table"		(pID = 1 or:[pID = 3]) ifTrue:[			"Go to the beginning of the table"			copy := entry copy.			copy offset: initialOffset + offset.			cmap := self decodeCmapFmtTable: copy.			"(pID = 1 and: [cmap notNil])" "Prefer Macintosh encoding over everything else"				"ifTrue: [pID -> cmap]."			assoc := pID -> cmap. "Keep it in case we don't find a Mac encoded table"		].	].	^assoc! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31981507!readFrom: aStream	"Read the raw font byte data"	| fontData |	(aStream respondsTo: #binary) ifTrue:[aStream binary].	fontData := aStream contents asByteArray.	fonts := self parseTTCHeaderFrom: fontData.	^ ((Array with: fonts first) collect: [:offset |		fontDescription := TTCFontDescription new.		self readFrom: fontData fromOffset: offset at: EncodingTag.	]) at: 1.! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31981964!readFrom: fontData fromOffset: offset at: encodingTag	| headerEntry maxProfileEntry nameEntry indexLocEntry charMapEntry glyphEntry horzHeaderEntry horzMetricsEntry kerningEntry glyphOffset cmap numHMetrics indexToLocFormat fontDescription0 fontDescription1 array result |	"Search the tables required to build the font"	(headerEntry := self getTableDirEntry: 'head' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a header table'].	(maxProfileEntry := self getTableDirEntry: 'maxp' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a maximum profile table'].	(nameEntry := self getTableDirEntry: 'name' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a name table'].	(indexLocEntry := self getTableDirEntry: 'loca' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a relocation table'].	(charMapEntry := self getTableDirEntry: 'cmap' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a character map table'].	(glyphEntry := self getTableDirEntry: 'glyf' from: fontData  offset: offset) == nil ifTrue:[		^self error:'This font does not have a glyph table'].	(horzHeaderEntry := self getTableDirEntry: 'hhea' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a horizontal header table'].	(horzMetricsEntry := self getTableDirEntry: 'hmtx' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a horizontal metrics table'].	(kerningEntry := self getTableDirEntry: 'kern' from: fontData offset: offset) == nil ifTrue:[		Transcript cr; show:'This font does not have a kerning table';endEntry].	"Process the data"	indexToLocFormat := self processFontHeaderTable: headerEntry.	self processMaximumProfileTable: maxProfileEntry.	self processNamingTable: nameEntry.	glyphOffset := self processIndexToLocationTable: indexLocEntry format: indexToLocFormat.	cmap := self processCharacterMappingTable: charMapEntry.	(cmap == nil or:[cmap value == nil])		ifTrue:[^self error:'This font has no suitable character mappings'].	self processGlyphDataTable: glyphEntry offsets: glyphOffset.	numHMetrics := self processHorizontalHeaderTable: horzHeaderEntry.	self processHorizontalMetricsTable: horzMetricsEntry length: numHMetrics.	kerningEntry isNil 		ifTrue:[kernPairs := #()]		ifFalse:[self processKerningTable: kerningEntry].	array := self processCharMap: cmap.	fontDescription0 := fontDescription clone.	fontDescription1 := fontDescription clone.	fontDescription0 setGlyphs: (array at: 1) mapping: nil.	fontDescription1 setGlyphs: (array at: 2) mapping: nil.	"fontDescription setKernPairs: kernPairs."	result := OrderedCollection new.	(encodingTag = nil or: [encodingTag = 0]) ifTrue: [^ Array with: fontDescription1].	result add: fontDescription0.	encodingTag -1 timesRepeat: [result add: nil].	result add: fontDescription1.	^ result asArray.! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31985053!readTTFFrom: aStream	"Read the raw font byte data"	| fontData |	(aStream respondsTo: #binary) ifTrue:[aStream binary].	fontData := aStream contents asByteArray.	fontDescription := TTCFontDescription new.	^ self readFrom: fontData fromOffset: 0 at: EncodingTag.! !!ImmWin32 methodsFor: 'all' stamp: 'sd 2/4/2008 21:21' prior: 22083388!keyboardFocusForAMorph: aMorph	| left top pos |	aMorph ifNil: [^ self].	[		pos := aMorph preferredKeyboardPosition.		left := (pos x min: Display width max: 0) asInteger.		top := (pos y min: Display height max: 0) asInteger.		self setCompositionWindowPositionX: left y: top	] on: Error	do: [:ex |].! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31974305!addFromTTFile: fileName"	Execute the following only if you know what you are doing.	self addFromTTFile: 'C:\WINDOWS\Fonts\msgothic.TTC'"	| tt old |	(fileName asLowercase endsWith: 'ttf') ifTrue: [		tt := TTCFontReader readTTFFrom: (FileStream readOnlyFileNamed: fileName).	] ifFalse: [		tt := TTCFontReader readFrom: (FileStream readOnlyFileNamed: fileName).	].			old := TTCDescriptions detect: [:f | f first name = tt first name] ifNone: [nil].	old ifNotNil: [TTCDescriptions remove: old].	TTCDescriptions add: tt.	^ tt.! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31974935!clearDefault"	self clearDefault"	TTCDefault := nil.! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31975086!clearDescriptions"	self clearDescriptions"	TTCDescriptions := Set new.	TTCDefault ifNotNil: [TTCDescriptions add: TTCDefault].! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31975648!descriptionNamed: descriptionName at: index	| array |	(array :=  self descriptionNamed: descriptionName) ifNil: [^ nil].	^ array at: index.! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31976043!removeDescriptionNamed: descriptionName	| tt |	TTCDescriptions ifNil: [^ self].	[(tt := TTCDescriptions detect: [:f | ('Multi', f first name) = descriptionName] ifNone: [nil]) notNil] whileTrue:[		 TTCDescriptions remove: tt	].! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31976371!setDefault"	self setDefault"	TTCDefault := TTCFontReader readFrom: (FileStream readOnlyFileNamed: 'C:\WINDOWS\Fonts\msgothic.ttc').	self clearDescriptions.! !!TTCFontDescription methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31972842!at: aCharOrInteger	| char |	char := aCharOrInteger asCharacter.	^ glyphs at: (char charCode) + 1.! !!TTCFontDescription methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31973284!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	dp := DiskProxy global: #TTCFontDescription selector: #descriptionNamed:at:			args: {self name. ((TTCFontDescription descriptionNamed: self name) indexOf: self)}.	refStrm replace: self with: dp.	^ dp.! !!TTCFont class methodsFor: 'instance creation' stamp: 'sd 2/4/2008 21:20' prior: 31965119!familyName: n pointSize: s emphasis: code	"(TTCFont familyName: 'BitstreamVeraSans' pointSize: 12 emphasis: 0)"	| t ret index |	t := self registry at: n asSymbol ifAbsent: [#()].	t isEmpty ifTrue: [		t := (TextConstants at: #DefaultTextStyle) fontArray.		ret := t first.		ret pointSize >= s ifTrue: [^ ret emphasis: code].		index := 2.		[index <= t size and: [(t at: index) pointSize <= s]] whileTrue: [			ret := t at: index.			index := index + 1.		].		^ ret emphasis: code.	].	^ ((TextStyle named: n) addNewFontSize: s) emphasis: code.! !!TTCFont class methodsFor: 'instance creation' stamp: 'sd 2/4/2008 21:20' prior: 31965939!getExistings: fontArray	| result em |	result := OrderedCollection new.	result add: fontArray.	1 to: 3 do: [:i |		em := (fontArray collect: [:f | f emphasized: i]).		(em at: 1) ~= (fontArray at: 1) ifTrue: [			result add: em.		].	].	^ result asArray.! !!TTCFont class methodsFor: 'class initialization' stamp: 'sd 2/4/2008 21:20' prior: 31963756!initialize"	self initialize"	| tt |	Smalltalk addToShutDownList: TTCFont.	tt := TTFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].	(FileList respondsTo: #registerFileReader:) ifTrue: [		FileList registerFileReader: self	].! !!TTCFont class methodsFor: 'instance creation' stamp: 'sd 2/4/2008 21:20' prior: 31966675!newTextStyleFromTTFile: fileName	"Create a new TextStyle from specified file name.  On certain versions of Windows, you can evaluate following to get Arial font into the image.  On other platforms, wait and see someone implements the support code for FontPlugin then we can start relying on the generic font lookup mechanism.	TTCFontReader encodingTag: 0.	self newTextStyleFromTTFile: 'C:\WINDOWS\Fonts\symbol.TTF'.	"	| description |	description := TTFontDescription addFromTTFile: fileName.	^ self newTextStyleFromTT: description.! !!TTCFont class methodsFor: 'instance creation' stamp: 'sd 2/4/2008 21:20' prior: 31967295!newTextStyleFromTTStream: readStream""	| description |	description := TTFontDescription addFromTTStream: readStream.	^ self newTextStyleFromTT: description.! !!TTCFont class methodsFor: 'instance creation' stamp: 'sd 2/4/2008 21:20' prior: 31967538!reorganizeForNewFontArray: array name: styleName	| style existings regular altName |	(TextConstants includesKey: styleName) ifFalse: [		TextConstants at: styleName put: (TextStyle fontArray: array).		^ TextConstants at: styleName.	]. 	"There is a text style with the name I want to use.  See if it is a TTC font..."	style := TextConstants at: styleName.	style isTTCStyle ifFalse: [		altName := ((array at: 1) name, 'TT') asSymbol.		^ self reorganizeForNewFontArray: array name: altName.	].	existings := (self getExistings: style fontArray), (Array with: array).	regular := existings detect: [:e | (e at: 1) isRegular] ifNone: [existings at: 1].	regular do: [:r |		r addLined: r.	].	"The existing array may be different in size than the new one."	existings do: [:e |		(e at: 1) isRegular ifFalse: [			regular do: [ :r | | f |				f := e detect: [ :ea | ea pointSize = r pointSize ] ifNone: [ ].				f ifNotNil: [ r derivativeFont: f ].			].		].	].	style newFontArray: regular.	self register: regular at: styleName.	self recreateCache.		^ style.! !!TTCFont class methodsFor: 'other' stamp: 'sd 2/4/2008 21:20' prior: 31970515!repairBadSizes	"There was a bug that would cause the TTCFonts to generate incorrectly sized glyphs.	By looking at the dimensions of cached forms,	we can tell whether the incorrect height logic was used.	If it was, change the point size of the font and its derivatives.		Note that this is probably pointless to call after the new code has been loaded; it's here for documentation (it should be called from the CS preamble instead)."	"TTCFont repairBadSizes"	| description computedScale cached desiredScale newPointSize repaired |	repaired := OrderedCollection new.	TTCFont allInstancesDo: [ :font |		cached := (font cache copyFrom: $A asciiValue + 1 to: $z asciiValue + 1)			detect: [ :f | f notNil ] ifNone: [].		cached := cached ifNil: [  font formOf: $A ] ifNotNil: [ cached value ].		description := font ttcDescription.		desiredScale := cached height asFloat / (description ascender - description descender).		computedScale := font pixelSize asFloat / font ttcDescription unitsPerEm.		(((computedScale / desiredScale) - 1.0 * cached height) abs < 1.0) ifFalse: [			newPointSize := (font pointSize * desiredScale / computedScale) rounded.			font pointSize: newPointSize; flushCache.			repaired add: font.			font derivativeFonts do: [ :df | df ifNotNil: [				df pointSize: newPointSize; flushCache.				repaired add: df. ]].		].	].	repaired isEmpty ifFalse: [ repaired asArray inspect ].! !!TTCFont class methodsFor: 'other' stamp: 'sd 2/4/2008 21:20' prior: 31972303!scale: anObject	Scale := anObject.! !!TTCFont methodsFor: 'private' stamp: 'sd 2/4/2008 21:20' prior: 31960171!addLined: aTTCFont	| l |	l := LinedTTCFont fromTTCFont: aTTCFont emphasis: 4.	self derivativeFont: l at: l emphasis.	l := LinedTTCFont fromTTCFont: aTTCFont emphasis: 16.	self derivativeFont: l at: l emphasis.	l := LinedTTCFont fromTTCFont: aTTCFont emphasis: 20.	self derivativeFont: l at: l emphasis.! !!TTCFont methodsFor: 'private' stamp: 'sd 2/4/2008 21:20' prior: 31960700!computeForm: char	| ttGlyph scale |	scale := self pixelSize asFloat / (ttcDescription ascender - ttcDescription descender).	Scale ifNotNil: [scale := Scale * scale].	ttGlyph := ttcDescription at: (char isCharacter ifTrue: [char charCode] ifFalse: [char]).	^ ttGlyph asFormWithScale: scale ascender: ttcDescription ascender descender: ttcDescription descender fgColor: foregroundColor bgColor: Color transparent depth: self depth.! !!TTCFont methodsFor: 'objects from disk' stamp: 'sd 2/4/2008 21:20' prior: 31957625!convertToCurrentVersion: varDict refStream: smartRefStrm	"If we're reading in an old version with a pixelSize instance variable, convert it to a point size."	"Deal with the change from pixelSize to pointSize, assuming the current monitor dpi."	varDict at: 'pixelSize' ifPresent: [ :x | 		pointSize := (TextStyle pixelsToPoints: x) rounded.	].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31953896!derivativeFont: aTTCFont	| index |	index := self indexOfSubfamilyName: (aTTCFont subfamilyName).	index < 1 ifTrue: [		^ self "inform: 'unknown sub family name.  This font will be skipped'".	].	self derivativeFont: aTTCFont at: index.	self addLined: aTTCFont.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31954227!derivativeFont: aTTCFont at: index	| newDeriv |	aTTCFont ifNil: [derivatives := nil. ^ self].	derivatives ifNil: [derivatives := Array new: 32].	derivatives size < 32 ifTrue: [		newDeriv := Array new: 32.		newDeriv replaceFrom: 1 to: derivatives size with: derivatives.		derivatives := newDeriv.	].	derivatives at: index put: aTTCFont.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31955167!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| destPoint form glyphInfo destY |	destPoint := aPoint.	glyphInfo := Array new: 5.	startIndex to: stopIndex do: [:charIndex |		self glyphInfoOf: (aString at: charIndex) into: glyphInfo.		form := glyphInfo first.		((glyphInfo at:5) ~= aBitBlt lastFont) ifTrue: [			(glyphInfo at:5) installOn: aBitBlt.		].		destY := baselineY - (glyphInfo at:4). 		aBitBlt sourceForm: form.		aBitBlt destX: destPoint x.		aBitBlt destY: destY.		aBitBlt sourceOrigin: (glyphInfo at:2) @ 0.		aBitBlt width: glyphInfo third - glyphInfo second.		aBitBlt height: form height.		aBitBlt copyBits.		destPoint := destPoint + (((glyphInfo at:3) - (glyphInfo at:2)) + kernDelta @ 0).	].	^ destPoint.! !!TTCFont methodsFor: 'accessing' stamp: 'sd 2/4/2008 21:20' prior: 31950465!fallbackFont	^ fallbackFont		ifNil: [fallbackFont := FixedFaceFont new errorFont fontSize: self height]! !!TTCFont methodsFor: 'accessing' stamp: 'sd 2/4/2008 21:20' prior: 31950636!fallbackFont: aFontSetOrNil	fallbackFont := aFontSetOrNil.! !!TTCFont methodsFor: 'private' stamp: 'sd 2/4/2008 21:20' prior: 31961197!formOf: char	| f assoc code |	char charCode > 255		ifTrue: [^ self fallbackFont formOf: char].	code := char charCode.	assoc := self cache at: (code + 1).	assoc ifNotNil: [		(assoc key = foregroundColor) ifTrue: [			^ assoc value.		].	].	f := self computeForm: code.	self at: code put: f.	^ f.! !!TTCFont methodsFor: 'private' stamp: 'sd 2/4/2008 21:20' prior: 31961568!glyphInfoOf: aCharacter into: glyphInfoArray	"Answer the width of the argument as a character in the receiver."	| form |	(self hasGlyphOf: aCharacter) ifFalse: [		^ self fallbackFont glyphInfoOf: aCharacter into: glyphInfoArray.	].	form := self formOf: aCharacter.	glyphInfoArray at: 1 put: form;		at: 2 put: 0;		at: 3 put: form width;		at: 4 put: (self ascentOf: aCharacter);		at: 5 put: self.	^ glyphInfoArray.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31956145!initialize	foregroundColor := Color black.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31956385!installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor	foregroundColor := fgColor.	aDisplayContext installTTCFont: self foregroundColor: foregroundColor backgroundColor: bgColor! !!TTCFont methodsFor: 'objects from disk' stamp: 'sd 2/4/2008 21:20' prior: 31958113!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write areference to a known FontSet in the other system instead."	"a path to me"	dp := DiskProxy global: #TTCFont selector: #familyName:pointSize:emphasis:			args: {self familyName. self pointSize. self emphasis}.	refStrm replace: self with: dp.	^ dp.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31956653!recreateCache	cache := WeakArray new: 1.	ascent := nil.! !!TTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31952779!setupDefaultFallbackFont	| fonts f |	fonts := TextStyle default fontArray.	f := fonts first.	1 to: fonts size do: [:i |		self height > (fonts at: i) height ifTrue: [f := fonts at: i].	].	self fallbackFont: f.	self reset.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31956774!setupDefaultFallbackFontTo: aTextStyleOrNil"	TTCFont allInstances do: [:i | i setupDefaultFallbackFontTo: (TextStyle named: 'MultiMSMincho')]."	| fonts f |	aTextStyleOrNil ifNil: [		self fallbackFont: nil.		^ self.	].	fonts := aTextStyleOrNil fontArray.	(aTextStyleOrNil defaultFont familyName endsWith: self familyName) ifTrue: [fallbackFont := nil. ^ self].	f := fonts first.	1 to: fonts size do: [:i |		self height >= (fonts at: i) height ifTrue: [f := fonts at: i].	].	self fallbackFont: f.	self reset.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31957461!ttcDescription: aTTCDescription	ttcDescription := aTTCDescription.	self recreateCache.! !!TTCFont methodsFor: 'public' stamp: 'sd 2/4/2008 21:20' prior: 31959029!widthOf: aCharacter	"This method cannot use #formOf: because formOf: discriminates the color and causes unnecessary bitmap creation."	| f assoc |	aCharacter charCode > 255 ifTrue: [		fallbackFont ifNotNil: [^ fallbackFont widthOf: aCharacter].		^ 1	].	assoc := self cache at: (aCharacter charCode + 1).	assoc ifNotNil: [		^ assoc value width	].	f := self computeForm: aCharacter.	self at: aCharacter charCode put: f.	^ f width.! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'sd 2/4/2008 21:22' prior: 25288415!addCharToPresentation: char	presentation nextPut: char.	lastWidth := self widthOf: char inFont: font.	destX := destX + lastWidth.! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25296515!columnBreak	"Answer true. Set up values for the text line interval currently being 	composed."	line stop: lastIndex.	presentationLine stop: lastIndex - numOfComposition.	spaceX := destX.	line paddingWidth: rightMargin - spaceX.	presentationLine paddingWidth: rightMargin - spaceX.	^true! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25290083!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	"Set up margins"	leftMargin := lineRectangle left.	leftSide ifTrue: [leftMargin := leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	destX := spaceX := leftMargin.	firstDestX := destX.	rightMargin := lineRectangle right.	rightSide ifTrue: [rightMargin := rightMargin - textStyle rightIndent].	lastIndex := startIndex.	"scanning sets last index"	destY := lineRectangle top.	lineHeight := baseline := 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font"	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	line := (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	presentationLine := (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	numOfComposition := 0.	spaceCount := 0.	self handleIndentation.	leftMargin := destX.	line leftMargin: leftMargin.	presentationLine leftMargin: leftMargin.	presentation := TextStream on: (Text fromString: (WideString new: text size)).	done := false.	[done]		whileFalse: 			[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [presentationLine lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading.						^ line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25292022!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	destX := spaceX := leftMargin := aParagraph leftMarginForCompositionForLine: lineIndex.	destY := 0.	rightMargin := aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex := startIndex.	"scanning sets last index"	lineHeight := textStyle lineGrid.  "may be increased by setFont:..."	baseline := textStyle baseline.	baselineY := destY + baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	line := TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	presentationLine := TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	numOfComposition := 0.	presentation := TextStream on: (Text fromString: (WideString new: text size)).	spaceCount := 0.	done := false.	[done]		whileFalse: 			[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [presentationLine lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading.						^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25296898!cr	"Answer true. Set up values for the text line interval currently being 	composed."	line stop: lastIndex.	presentationLine stop: lastIndex - numOfComposition.	spaceX := destX.	line paddingWidth: rightMargin - spaceX.	presentationLine paddingWidth: rightMargin - spaceX.	^true! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25293734!crossedX	"There is a word that has fallen across the right edge of the composition 	rectangle. This signals the need for wrapping which is done to the last 	space that was encountered, as recorded by the space stop condition."	(breakAtSpace) ifTrue: [		spaceCount >= 1 ifTrue:			["The common case. First back off to the space at which we wrap."			line stop: breakableIndex.			presentationLine stop: breakableIndex - numOfComposition.			lineHeight := lineHeightAtBreak.			baseline := baselineAtBreak.			spaceCount := spaceCount - 1.			breakableIndex := breakableIndex - 1.			"Check to see if any spaces preceding the one at which we wrap.				Double space after punctuation, most likely."			[(spaceCount > 1 and: [(text at: breakableIndex) = Space])]				whileTrue:					[spaceCount := spaceCount - 1.					"Account for backing over a run which might						change width of space."					font := text fontAt: breakableIndex withStyle: textStyle.					breakableIndex := breakableIndex - 1.					spaceX := spaceX - (font widthOf: Space)].			line paddingWidth: rightMargin - spaceX.			presentationLine paddingWidth: rightMargin - spaceX.			presentationLine internalSpaces: spaceCount.			line internalSpaces: spaceCount]		ifFalse:			["Neither internal nor trailing spaces -- almost never happens."			lastIndex := lastIndex - 1.			[destX <= rightMargin]				whileFalse:					[destX := destX - (font widthOf: (text at: lastIndex)).					lastIndex := lastIndex - 1].			spaceX := destX.			line paddingWidth: rightMargin - destX.			presentationLine paddingWidth: rightMargin - destX.			presentationLine stop: (lastIndex max: line first).			line stop: (lastIndex max: line first)].		^true	].	(breakableIndex isNil or: [breakableIndex < line first]) ifTrue: [		"Any breakable point in this line.  Just wrap last character."		breakableIndex := lastIndex - 1.		lineHeightAtBreak := lineHeight.		baselineAtBreak := baseline.	].	"It wasn't a space, but anyway this is where we break the line."	line stop: breakableIndex.	presentationLine stop: breakableIndex.	lineHeight := lineHeightAtBreak.	baseline := baselineAtBreak.	^ true.! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25297272!endOfRun	"Answer true if scanning has reached the end of the paragraph. 	Otherwise step conditions (mostly install potential new font) and answer 	false."	| runLength |	lastIndex = text size	ifTrue:	[line stop: lastIndex.			presentationLine stop: lastIndex - numOfComposition.			spaceX := destX.			line paddingWidth: rightMargin - destX.			presentationLine paddingWidth: rightMargin - destX.			^true]	ifFalse:	[			"(text at: lastIndex) charCode = 32 ifTrue: [destX := destX + spaceWidth]."			runLength := (text runLengthFor: (lastIndex := lastIndex + 1)).			runStopIndex := lastIndex + (runLength - 1).			self setStopConditions.			^false]! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25298012!placeEmbeddedObject: anchoredMorph	| descent |	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	(super placeEmbeddedObject: anchoredMorph) ifFalse: ["It doesn't fit"		"But if it's the first character then leave it here"		lastIndex < line first ifFalse:[			line stop: lastIndex-1.			^ false]].	descent := lineHeight - baseline.	lineHeight := lineHeight max: anchoredMorph height.	baseline := lineHeight - descent.	line stop: lastIndex.	presentationLine stop: lastIndex - numOfComposition.	^ true! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'sd 2/4/2008 21:22' prior: 25289128!registerBreakableIndex	"Record left x and character index of the line-wrappable point. 	Used for wrap-around. Answer whether the character has crossed the 	right edge of the composition rectangle of the paragraph."	(text at: lastIndex) = Character space ifTrue: [		breakAtSpace := true.		spaceX := destX.		spaceCount := spaceCount + 1.		lineHeightAtBreak := lineHeight.		baselineAtBreak := baseline.		breakableIndex := lastIndex.		destX > rightMargin ifTrue: 	[^self crossedX].	] ifFalse: [		breakAtSpace := false.		lineHeightAtBreak := lineHeight.		baselineAtBreak := baseline.		breakableIndex := lastIndex - 1.	].	^ false.! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'sd 2/4/2008 21:22' prior: 25289858!removeLastCharFromPresentation	presentation ifNotNil: [		presentation position: presentation position - 1.	].	destX := destX - lastWidth.! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25295958!setActualFont: aFont	"Keep track of max height and ascent for auto lineheight"	| descent |	super setActualFont: aFont.	"'   ', lastIndex printString, '   ' displayAt: (lastIndex * 15)@0."	lineHeight == nil		ifTrue: [descent := font descent.				baseline := font ascent.				lineHeight := baseline + descent]		ifFalse: [descent := lineHeight - baseline max: font descent.				baseline := baseline max: font ascent.				lineHeight := lineHeight max: baseline + descent]! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25298679!setFont	super setFont.	breakAtSpace := false.	wantsColumnBreaks == true ifTrue: [		stopConditions := stopConditions copy.		stopConditions at: TextComposer characterForColumnBreak asciiValue + 1 put: #columnBreak.	].! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25299173!tab	"Advance destination x according to tab settings in the paragraph's 	textStyle. Answer whether the character has crossed the right edge of 	the composition rectangle of the paragraph."	destX := textStyle				nextTabXFrom: destX leftMargin: leftMargin rightMargin: rightMargin.	destX > rightMargin ifTrue:	[^self crossedX].	lastIndex := lastIndex + 1.	^false! !!MultiCanvasCharacterScanner methodsFor: 'accessing' stamp: 'sd 2/4/2008 21:22' prior: 25247342!canvas: aCanvas	"set the canvas to draw on"	canvas ifNotNil: [ self inform: 'initializing twice!!' ].	canvas := aCanvas! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25248960!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	lastIndex:= lastIndex + 1.	^false! !!MultiCanvasCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25247551!displayLine: textLine  offset: offset  leftInRun: leftInRun	|  nowLeftInRun done startLoc startIndex stopCondition |	"largely copied from DisplayScanner's routine"	line := textLine.	foregroundColor ifNil: [ foregroundColor := Color black ].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	rightMargin := line rightMargin + offset x.	lineY := line top + offset y.	lastIndex := textLine first.	leftInRun <= 0		ifTrue: [self setStopConditions.  "also sets the font"				nowLeftInRun := text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun := leftInRun].	runX := destX := leftMargin.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	done := false.	[done] whileFalse: [		"remember where this portion of the line starts"		startLoc := destX@destY.		startIndex := lastIndex.		"find the end of this portion of the line"		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex						in: text string rightX: rightMargin stopConditions: stopConditions						kern: kern "displaying: false".		"display that portion of the line"		canvas drawString: text string			from: startIndex to: lastIndex			at: startLoc			font: font			color: foregroundColor.		"handle the stop condition"		done := self perform: stopCondition	].	^runStopIndex - lastIndex! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25249710!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	lastIndex = line last ifTrue: [^true].	runX := destX.	runLength := text runLengthFor: (lastIndex := lastIndex + 1).	runStopIndex := lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25250226!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	destX := destX + spaceWidth + (line justifiedPadFor: spaceCount).	lastIndex := lastIndex + 1.	^ false! !!MultiCanvasCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25251574!setFont	foregroundColor ifNil: [foregroundColor := Color black].	super setFont.	baselineY := lineY + line baseline.	destY := baselineY - font ascent.! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25250988!tab	destX := (alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastIndex := lastIndex + 1.	^ false! !!MultiCanvasCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25251810!textColor: color	foregroundColor := color! !!MultiNewParagraph methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 25312448!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| visibleRectangle offset leftInRun line |	visibleRectangle := aCanvas clipRect.	offset := somePosition - positionWhenComposed.	leftInRun := 0.	(self lineIndexForPoint: visibleRectangle topLeft)		to: (self lineIndexForPoint: visibleRectangle bottomRight)		do: [:i | line := lines at: i.			self displaySelectionInLine: line on: aCanvas.			line first <= line last ifTrue:				[leftInRun := displayScanner displayLine: line								offset: offset leftInRun: leftInRun]].! !!MultiNewParagraph methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 25313126!displayOnTest: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| visibleRectangle offset leftInRun line |	(presentationText isNil or: [presentationLines isNil]) ifTrue: [		^ self displayOn: aCanvas using: displayScanner at: somePosition.	].	visibleRectangle := aCanvas clipRect.	offset := somePosition - positionWhenComposed.	leftInRun := 0.	(self lineIndexForPoint: visibleRectangle topLeft)		to: (self lineIndexForPoint: visibleRectangle bottomRight)		do: [:i | line := presentationLines at: i.			self displaySelectionInLine: line on: aCanvas.			line first <= line last ifTrue:				[leftInRun := displayScanner displayLine: line								offset: offset leftInRun: leftInRun]].! !!MultiNewParagraph methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 25313958!multiComposeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines	atY: startingY	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| newResult composer presentationInfo |	composer := MultiTextComposer new.	presentationLines := nil.	presentationText := nil.	newResult := composer		multiComposeLinesFrom: start 		to: stop 		delta: delta 		into: lineColl 		priorLines: priorLines		atY: startingY		textStyle: textStyle 		text: text 		container: container		wantsColumnBreaks: wantsColumnBreaks == true.	lines := newResult first asArray.	maxRightX := newResult second.	presentationInfo := composer getPresentationInfo.	presentationLines := presentationInfo first asArray.	presentationText := presentationInfo second.	"maxRightX printString displayAt: 0@0."	^maxRightX! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31156787!createExternalFontFileForLatin2: fileName"	StrikeFontSet createExternalFontFileForLatin2: 'latin2.out'."	| file array f installDirectory |	file := FileStream newFileNamed: fileName.	installDirectory := Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory := installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array := Array				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b10.bdf' name: 'LatinTwo9' ranges: EFontBDFFontReaderForRanges rangesForLatin2)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'LatinTwo10' ranges: EFontBDFFontReaderForRanges rangesForLatin2)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'LatinTwo12' ranges: EFontBDFFontReaderForRanges rangesForLatin2)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b16.bdf' name: 'LatingTwo14' ranges: EFontBDFFontReaderForRanges rangesForLatin2)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'LatinTwo20' ranges: EFontBDFFontReaderForRanges rangesForLatin2).	TextConstants at: #forceFontWriting put: true.	f := ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31158159!createExternalFontFileForUnicodeJapanese: fileName"	StrikeFontSet createExternalFontFileForUnicodeJapanese: 'uJapaneseFont.out'."	| file array f installDirectory |	file := FileStream newFileNamed: fileName.	installDirectory := Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory := installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array := Array				with: (StrikeFont newForJapaneseFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'Japanese10' overrideWith: 'shnmk12.bdf')				with: ((StrikeFont newForJapaneseFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'Japanese12' overrideWith: 'shnmk14.bdf') "fixAscent: 14 andDescent: 1 head: 1")				with: ((StrikeFont newForJapaneseFromEFontBDFFile: 'b16.bdf' name: 'Japanese14' overrideWith: 'shnmk16.bdf') "fixAscent: 16 andDescent: 4 head: 4")				with: (StrikeFont newForJapaneseFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'Japanese18' overrideWith: 'kanji24.bdf').	TextConstants at: #forceFontWriting put: true.	f := ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31159421!createExternalFontFileForUnicodeKorean: fileName"	Smalltalk garbageCollect.	StrikeFontSet createExternalFontFileForUnicodeKorean: 'uKoreanFont.out'."	| file array f installDirectory |	file := FileStream newFileNamed: fileName.	installDirectory := Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory := installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array := Array				with: (StrikeFont newForKoreanFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'Japanese10' overrideWith: 'shnmk12.bdf')				with: ((StrikeFont newForKoreanFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'Japanese12' overrideWith: 'shnmk14.bdf') "fixAscent: 14 andDescent: 1 head: 1")				with: ((StrikeFont newForKoreanFromEFontBDFFile: installDirectory , 'b16.bdf' name: 'Japanese14' overrideWith: 'hanglg16.bdf') fixAscent: 16 andDescent: 4 head: 4)				with: (StrikeFont newForKoreanFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'Japanese18' overrideWith: 'hanglm24.bdf').	TextConstants at: #forceFontWriting put: true.	f := ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31160716!decodedFromRemoteCanvas: aString	| array |	array := aString findTokens: #($ ).	^ self familyName: (array at: 1) size: (array at: 2) asNumber emphasized: (array at: 3) asNumber.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31160986!duplicateArrayElementsForLeadingCharShift"	self duplicateArrayElementsForLeadingCharShift"	| array font |	self allInstances do: [:s |		s emphasis = 0 ifTrue: [			array := s fontArray.			2 to: (4 min: array size) do: [:i |				font := array at: i.				s addNewFont: font at: ((i - 1) << 2) + 1.			].		] ifFalse: [			s reset		].	].! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31161416!familyName: aName size: aSize	"Answer a font (or the default font if the name is unknown) in the specified size."	| collection |	collection :=  self allInstances select: [:inst | (inst name beginsWith: aName) and: [inst emphasis = 0]].	collection isEmpty ifTrue: [		(aName = 'DefaultMultiStyle') ifTrue: [			collection := (TextConstants at: #DefaultMultiStyle) fontArray.		] ifFalse: [			^ TextStyle defaultFont		]	].	collection := collection asSortedCollection: [:a :b | a pointSize <= b pointSize].	collection do: [:s | (s pointSize >= aSize) ifTrue: [^ s]].	^ TextStyle defaultFont.! !!StrikeFontSet class methodsFor: 'fileIn/Out' stamp: 'sd 2/4/2008 21:20' prior: 31166392!installExternalFontFileName: fileName inDir: dir encoding: encoding encodingName: aString textStyleName: styleName	| array arrayFour oldStyle arrayOfFS fs fonts newFonts |	array := (ReferenceStream on: (dir readOnlyFileNamed: fileName)) next.	arrayFour := Array new: 4 withAll: array last.	arrayFour replaceFrom: 1 to: array size with: array startingAt: 1.	TextConstants at: aString asSymbol put: arrayFour.	oldStyle := TextConstants at: styleName asSymbol.	arrayOfFS := oldStyle fontArray.	arrayOfFS := (1 to: 4) collect: [:i |		fs := arrayOfFS at: i.		fonts := fs fontArray.		encoding + 1 > fonts size ifTrue: [			newFonts := Array new: encoding + 1.			newFonts replaceFrom: 1 to: fonts size with: fonts startingAt: 1.			newFonts at: encoding + 1 put: (arrayFour at: i).			fs initializeWithFontArray: newFonts.		] ifFalse: [			fonts at: encoding + 1 put: (arrayFour at: i).		].		fs.	].	TextConstants at: styleName asSymbol put: (TextStyle fontArray: arrayOfFS).	oldStyle becomeForward: (TextConstants at: styleName asSymbol).! !!StrikeFontSet class methodsFor: 'fileIn/Out' stamp: 'sd 2/4/2008 21:20' prior: 31167519!installExternalFontOn: aStream encoding: encoding encodingName: aString textStyleName: styleName	| array fonts encodingIndex textStyle |	array := aStream		untilEndWithFork: [(ReferenceStream on: aStream) next]		displayingProgress: 'Font reading...'. 		TextConstants at: aString asSymbol put: array.	textStyle := TextConstants at: styleName asSymbol.	encodingIndex := encoding + 1.	textStyle fontArray do: [:fs |		fonts := fs fontArray.		encodingIndex > fonts size			ifTrue: [fonts :=  (Array new: encodingIndex)				replaceFrom: 1 to: fonts size with: fonts startingAt: 1].		fonts at: encodingIndex put: (self findMaximumLessThan: fs fontArray first in: array).		fs initializeWithFontArray: fonts.	].! !!StrikeFontSet class methodsFor: 'fileIn/Out' stamp: 'sd 2/4/2008 21:20' prior: 31168628!installNewFontAtIndex: newIndex fromOld: oldIndex	| fontArray newArray |	self allInstances do: [:set |		fontArray := set fontArray.		newIndex + 1 > fontArray size ifTrue: [			newArray := Array new: newIndex + 1.			newArray replaceFrom: 1 to: fontArray size with: fontArray startingAt: 1.			newArray at: newIndex + 1 put: (fontArray at: oldIndex + 1).			set initializeWithFontArray: newArray.		] ifFalse: [			fontArray at: newIndex + 1 put: (fontArray at: oldIndex + 1).		].	]."StrikeFontSet installNewFontAtIndex: UnicodeSimplifiedChinese leadingChar fromOld: UnicodeJapanese leadingCharStrikeFontSet installNewFontAtIndex: UnicodeKorean leadingChar fromOld: UnicodeJapanese leadingChar"! !!StrikeFontSet class methodsFor: 'fileIn/Out' stamp: 'sd 2/4/2008 21:20' prior: 31169412!removeFontsForEncoding: leadingChar encodingName: encodingSymbol	| insts fonts newFonts index |	leadingChar = 0 ifTrue: [^ self error: 'you cannot delete the intrinsic fonts'].	insts := self allInstances.	insts do: [:inst |		fonts := inst fontArray.		fonts size >= (leadingChar + 1) ifTrue: [			leadingChar + 1 = fonts size ifTrue: [				newFonts := fonts copyFrom: 1 to: fonts size - 1.				index := newFonts indexOf: nil.				index > 0 ifTrue: [newFonts := newFonts copyFrom: 1 to: index - 1].				inst initializeWithFontArray: newFonts.			] ifFalse: [				fonts at: leadingChar + 1 put: nil.			].		].	].	TextConstants removeKey: encodingSymbol asSymbol ifAbsent: [].! !!StrikeFontSet methodsFor: 'private' stamp: 'sd 2/4/2008 21:13' prior: 31155143!addNewFont: aFont at: encodingIndex	| newArray |	encodingIndex > fontArray size ifTrue: [		newArray := Array new: encodingIndex.		newArray replaceFrom: 1 to: fontArray size with: fontArray startingAt: 1.	] ifFalse: [		newArray := fontArray.	].	newArray at: encodingIndex put: aFont.	self initializeWithFontArray: newArray.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31135158!bonk: glyphForm with: bonkForm at: j	"Bonking means to run through the glyphs clearing out black pixels	between characters to prevent them from straying into an adjacent	character as a result of, eg, bolding or italicizing"	"Uses the bonkForm to erase at every character boundary in glyphs."	| bb offset font x |	font := (fontArray at: j).	offset := bonkForm offset x.	bb := BitBlt toForm: glyphForm.	bb sourceForm: bonkForm; sourceRect: bonkForm boundingBox;		combinationRule: Form erase; destY: 0.	x := font xTable.	(x isMemberOf: SparseLargeTable) ifTrue: [		x base to: x size-1 do: [:i | bb destX: (x at: i) + offset; copyBits].	] ifFalse: [		1 to: x size-1 do: [:i | bb destX: (x at: i) + offset; copyBits].	].! !!StrikeFontSet methodsFor: 'character shapes' stamp: 'sd 2/4/2008 21:20' prior: 31144264!characterFormAt: character 	| encoding ascii xTable leftX rightX |	encoding := character leadingChar + 1.	ascii := character charCode.	(ascii < (fontArray at: encoding) minAscii or: [ascii > (fontArray at: encoding) maxAscii])		ifTrue: [ascii := (fontArray at: encoding) maxAscii].	xTable := (fontArray at: encoding) xTable.	leftX := xTable at: ascii + 1.	rightX := xTable at: ascii + 2.	^ (fontArray at: encoding) glyphs copy: (leftX @ 0 corner: rightX @ self height).! !!StrikeFontSet methodsFor: 'character shapes' stamp: 'sd 2/4/2008 21:20' prior: 31144819!characterFormAt: character put: characterForm 	| ascii leftX rightX widthDif newGlyphs encoding xTable glyphs |	encoding := character leadingChar + 1.	ascii := character charCode.	ascii < (fontArray at: encoding) minAscii ifTrue: [		^ self error: 'Cant store characters below min ascii'	].	ascii > (fontArray at: encoding) maxAscii ifTrue: [		^ self error: 'No change made'	].	xTable := (fontArray at: encoding) xTable.	leftX := xTable at: ascii + 1.	rightX := xTable at: ascii + 2.	glyphs := (fontArray at: encoding) glyphs.	widthDif := characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue: [		newGlyphs := Form extent: glyphs width + widthDif @ glyphs height.		newGlyphs copy: (0 @ 0 corner: leftX @ glyphs height) from: 0 @ 0			in: glyphs rule: Form over.		newGlyphs				copy: (rightX + widthDif @ 0 corner: newGlyphs width @ glyphs height)				from: rightX @ 0 in: glyphs rule: Form over.		glyphs := newGlyphs.		"adjust further entries on xTable"		xTable := xTable copy.		ascii + 2 to: xTable size do: [:i |			xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 extent: characterForm extent) from: 0 @ 0 in: characterForm rule: Form over.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'sd 2/4/2008 21:20' prior: 31146080!characters: anInterval in: sourceString displayAt: aPoint clippedBy: clippingRectangle rule: ruleInteger fillColor: aForm kernDelta: kernDelta on: aBitBlt	"Simple, slow, primitive method for displaying a line of characters.	No wrap-around is provided."	| ascii encoding destPoint leftX rightX sourceRect xTable noFont f |	destPoint := aPoint.	anInterval do: 		[:i |		encoding := (sourceString at: i) leadingChar + 1.		noFont := false.		[f := fontArray at: encoding]			on: Exception do: [:ex | noFont := true. f := fontArray at: 1].		f ifNil: [noFont := true. f := fontArray at: 1].		ascii := noFont ifTrue: [$?] ifFalse: [(sourceString at: i) charCode].		(ascii < f minAscii			or: [ascii > f maxAscii])			ifTrue: [ascii := f maxAscii].		xTable := f xTable.		leftX := xTable at: ascii + 1.		rightX := xTable at: ascii + 2.		sourceRect := leftX@0 extent: (rightX-leftX) @ self height.		aBitBlt copyFrom: sourceRect in: f glyphs to: destPoint.		destPoint := destPoint + ((rightX-leftX+kernDelta)@0).		"destPoint printString displayAt: 0@(i*20)."	].	^ destPoint.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31135970!copy	| s a |	s := self class new.	s name: self name.	s emphasis: self emphasis.	s reset.	a := Array new: fontArray size.	1 to: a size do: [:i |		a at: i put: (fontArray at: i) copy.	].	s fontArray: a.	^ s.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'sd 2/4/2008 21:20' prior: 31149299!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	"Draw the given string from startIndex to stopIndex 	at aPoint on the (already prepared) BitBlt."		"Assume this is a wide string"	| isMulti |	isMulti := true.	"Look for an excuse to use the fast primitive" 	(aString isKindOf: ByteString) 		ifTrue:[ isMulti := false]		ifFalse:[ (aString isKindOf: Text) 			ifTrue:[ (aString string isKindOf: ByteString) 				ifTrue:[ isMulti := false ] 	]].	isMulti ifTrue:[^ self displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY].	^ aBitBlt displayString: aString 			from: startIndex 			to: stopIndex 			at: aPoint 			strikeFont: self			kern: kernDelta! !!StrikeFontSet methodsFor: 'displaying' stamp: 'sd 2/4/2008 21:20' prior: 31150161!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta from: fromFont baselineY: baselineY	| destPoint leftX rightX glyphInfo g tag char destY |	destPoint := aPoint.	rIndex := startIndex.	tag := (aString at: rIndex) leadingChar.	glyphInfo := Array new: 5.	[rIndex <= stopIndex] whileTrue: [		char := aString at: rIndex.		((fromFont hasGlyphOf: char) or: [char leadingChar ~= tag]) ifTrue: [^ Array with: rIndex with: destPoint].		self glyphInfoOf: char into: glyphInfo.		g := glyphInfo first.		leftX := glyphInfo second.		rightX := glyphInfo third.		(glyphInfo fifth ~= aBitBlt lastFont) ifTrue: [			glyphInfo fifth installOn: aBitBlt.		].		aBitBlt sourceForm: g.		destY := baselineY - glyphInfo fourth. 		aBitBlt destX: destPoint x.		aBitBlt destY: destY.		aBitBlt sourceOrigin: leftX @ 0.		aBitBlt width: rightX - leftX.		aBitBlt height: self height.		aBitBlt copyBits.		destPoint := destPoint + (rightX - leftX + kernDelta @ 0).		rIndex := rIndex + 1.	].	^ Array with: rIndex with: destPoint.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'sd 2/4/2008 21:20' prior: 31148083!displayStringR2L: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	| destPoint font |	destPoint := aPoint.	startIndex to: stopIndex do: [:charIndex | 		| encoding ascii xTable leftX rightX | 		encoding := (aString at: charIndex) leadingChar + 1.		ascii := (aString at: charIndex) charCode.		font := fontArray at: encoding.		((ascii between: font minAscii and: font maxAscii) not) ifTrue: [			ascii := font maxAscii].		xTable := font xTable.		leftX := xTable at: ascii + 1.		rightX := xTable at: ascii + 2.		aBitBlt sourceForm: font glyphs.		aBitBlt destX: destPoint x - (rightX - leftX).		aBitBlt destY: destPoint y.		aBitBlt sourceOrigin: leftX @ 0.		aBitBlt width: rightX - leftX.		aBitBlt height: self height.		aBitBlt copyBits.		destPoint := destPoint - (rightX - leftX + kernDelta @ 0).	].! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31137219!emphasis: code 	"Set the integer code for synthetic bold, itallic, underline, and strike-out, 	where bold=1, italic=2, underlined=4, and struck out=8."	emphasis := code.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31137475!emphasized: code 	"Answer a copy of the receiver with emphasis set to include code."	| derivative addedEmphasis base safeCode |	code = 0 ifTrue: [^ self].	(derivativeFonts == nil or: [derivativeFonts size = 0]) ifTrue: [^ self].	derivative := derivativeFonts at: (safeCode := code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis := 1 bitShift: safeCode highBit - 1.	base := self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative := (base copy name: base name , 'B') makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative := (base copy name: base name , 'I') makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative := (base copy name: base name , 'U') makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative := (base copy name: base name , 'N') makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative := (base copy name: base name , 'X') makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31139270!fontArray: anArray	fontArray := anArray.! !!StrikeFontSet methodsFor: 'private' stamp: 'sd 2/4/2008 21:14' prior: 31155546!glyphInfoOf: aCharacter into: glyphInfoArray	| index f code leftX |	index := aCharacter leadingChar + 1.	fontArray size < index ifTrue: [^ self questionGlyphInfoInto: glyphInfoArray].	(f := fontArray at: index) ifNil: [^ self questionGlyphInfoInto: glyphInfoArray].	code := aCharacter charCode.	((code between: f minAscii and: f maxAscii) not) ifTrue: [		^ self questionGlyphInfoInto: glyphInfoArray.	].	leftX := f xTable at: code + 1.	leftX < 0 ifTrue: [		^ self questionGlyphInfoInto: glyphInfoArray.	].	glyphInfoArray at: 1 put: f glyphs;		at: 2 put: leftX;		at: 3 put: (f xTable at: code + 2);		at: 4 put: (f ascentOf: aCharacter);		at: 5 put: self.	^ glyphInfoArray.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31141153!lineGrid	| f |	f := fontArray first.	^ f ascent + f descent.! !!StrikeFontSet methodsFor: 'emphasis' stamp: 'sd 2/4/2008 21:14' prior: 31151819!makeBoldGlyphs	"Make a bold set of glyphs with same widths by ORing 1 bit to the right		(requires at least 1 pixel of intercharacter space)"	| g bonkForm font |	1 to: fontArray size do: [:i |		font := fontArray at: i.		font ifNotNil: [			g := font glyphs deepCopy.			bonkForm := (Form extent: 1@16) fillBlack offset: -1@0.			self bonk: g with: bonkForm at: i.			g copyBits: g boundingBox from: g at: (1@0)				clippingBox: g boundingBox rule: Form under fillColor: nil.			(fontArray at: i) setGlyphs: g.		].	].! !!StrikeFontSet methodsFor: 'emphasis' stamp: 'sd 2/4/2008 21:18' prior: 31152414!makeItalicGlyphs	"Make an italic set of glyphs with same widths by skewing left and right		(may require more intercharacter space)"	| g bonkForm bc font |	1 to: fontArray size do: [:j |		font := (fontArray at: j).		font ifNotNil: [			g := font glyphs deepCopy.			"BonkForm will have bits where slanted characters overlap their neighbors."			bonkForm := Form extent: (self height//4+2) @ self height.			bc := font descent//4 + 1.  "Bonker x-coord corresponding to char boundary."			bonkForm fill: (0 @ 0 corner: (bc+1) @ font ascent) fillColor: Color black.			4 to: font ascent-1 by: 4 do:				[:y | 		"Slide ascenders right..."				g copy: (1@0 extent: g width @ (font ascent - y))					from: 0@0 in: g rule: Form over.				bonkForm copy: (1@0 extent: bonkForm width @ (font ascent - y))					from: 0@0 in: bonkForm rule: Form over].			bonkForm fill: (0 @ 0 corner: (bc+1) @ font ascent) fillColor: Color white.			bonkForm fill: (bc @ font ascent corner: bonkForm extent) fillColor: Color black.			font ascent to: font height-1 by: 4 do:				[:y | 		"Slide descenders left..."				g copy: (0@y extent: g width @ g height)					from: 1@y in: g rule: Form over.				bonkForm copy: (0@0 extent: bonkForm width @ bonkForm height)					from: 1@0 in: bonkForm rule: Form over].			bonkForm fill: (bc @ font ascent corner: bonkForm extent) fillColor: Color white.			"Now use bonkForm to erase at every character boundary in glyphs."			bonkForm offset: (0-bc) @ 0.			font bonk: g with: bonkForm.			font setGlyphs: g		].	].! !!StrikeFontSet methodsFor: 'emphasis' stamp: 'sd 2/4/2008 21:18' prior: 31154020!makeStruckOutGlyphs	"Make a struck-out set of glyphs with same widths"	| g font |	1 to: fontArray size do: [:i |		font := (fontArray at: i).		font ifNotNil: [			g := font glyphs deepCopy.			g fillBlack: (0 @ (font ascent - (font ascent//3)) extent: g width @ 1).			font setGlyphs: g		].	].! !!StrikeFontSet methodsFor: 'emphasis' stamp: 'sd 2/4/2008 21:18' prior: 31154392!makeUnderlinedGlyphs	"Make an underlined set of glyphs with same widths"	| g font |	1 to: fontArray size do: [:i |		font := (fontArray at: i).		font ifNotNil: [			g := font glyphs deepCopy.			g fillBlack: (0 @ (font ascent+1) extent: g width @ 1).			font setGlyphs: g		].	].! !!StrikeFontSet methodsFor: 'accessing' stamp: 'sd 2/4/2008 21:20' prior: 31134192!maxAsciiFor: encoding	| f |	f := (fontArray at: encoding+1).	f ifNotNil: [^ f maxAscii].	^ 0.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31141636!name: aString	name := aString! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31141750!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	dp := DiskProxy global: #StrikeFontSet selector: #familyName:size:emphasized:			args: (Array with: self familyName with: self pointSize					with: self emphasis).	refStrm replace: self with: dp.	^ dp.! !!StrikeFontSet methodsFor: 'private' stamp: 'sd 2/4/2008 21:14' prior: 31156305!questionGlyphInfoInto: glyphInfoArray	| f ascii |	f := fontArray at: 1.	ascii := $? asciiValue.	glyphInfoArray at: 1 put: f glyphs;		at: 2 put: (f xTable at: ascii + 1);		at: 3 put: (f xTable at: ascii + 2);		at: 4 put: (self ascentOf: $?);		at: 5 put: self.	^ glyphInfoArray.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31142726!reset	"Reset the cache of derivative emphasized fonts"	derivativeFonts := Array new: 32.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31143519!widthOfString: aString from: startIndex to: stopIndex	"Measure the length of the given string between start and stop index"	| resultX |	resultX := 0.	startIndex to: stopIndex do:[:i | 		resultX := resultX + (self widthOf: (aString at: i))].	^ resultX.! !!X11Encoding class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:21' prior: 50975709!encoding	| enc |	enc := self getEncoding.	enc ifNil: [ ^ nil ].	^ enc asLowercase.! !!LinedTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:11' prior: 23081381!computeForm: char	| ttGlyph scale |	char = Character tab ifTrue: [^ super computeForm: char].	"char = $U ifTrue: [self doOnlyOnce: [self halt]]."	scale := self pixelSize asFloat / (ttcDescription ascender - ttcDescription descender).	ttGlyph := ttcDescription at: char.	^ ttGlyph asFormWithScale: scale ascender: ttcDescription ascender descender: ttcDescription descender fgColor: foregroundColor bgColor: Color transparent depth: self depth replaceColor: false lineGlyph: lineGlyph lingGlyphWidth: contourWidth emphasis: emphasis! !!LinedTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:11' prior: 23082104!emphasis: code	emphasis := code.! !!LinedTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:11' prior: 23082219!lineGlyph: aGlyph	lineGlyph := aGlyph.	contourWidth := aGlyph calculateWidth.! !"Multilingual"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.332.mcz') load.ScriptLoader new updateFrom7067.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 2/14/2008 21:18'!script93	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.150.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.115.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.22.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/14/2008 21:45'!updateFrom7069	"self new updateFrom7069"		"unloading OB"		(MCWorkingCopy forPackage: (MCPackage new name: 'OmniBrowser')) unload.	(MCWorkingCopy forPackage: (MCPackage new name: 'OB-Standard')) unload.	SystemBrowser removeObsolete.	SystemOrganization removeCategoriesMatching: 'OmniBrowser*'.	SystemOrganization removeCategoriesMatching: 'OB-Standard*'.		World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	self flushCaches.				! !"ScriptLoader"!PluggableButtonMorph removeSelector: #isOn!OBTextMorph removeSelector: #installEditorToReplace:!Smalltalk removeClassNamed: #OBTextMorph!Object removeSelector: #asAnnouncement!OBService removeSelector: #wantsButton!OBService removeSelector: #useLineAfter!OBService removeSelector: #trigger!OBService removeSelector: #labelWithKeystroke!OBService removeSelector: #label:!OBService removeSelector: #label!OBService removeSelector: #keystroke:!OBService removeSelector: #keystroke!OBService removeSelector: #isEnabledFor:!OBService removeSelector: #isEnabled!OBService removeSelector: #initialize!OBService removeSelector: #icon:!OBService removeSelector: #icon!OBService removeSelector: #executeFor:!OBService removeSelector: #execute!OBService removeSelector: #description!OBService removeSelector: #condition:!OBService removeSelector: #condition!OBService removeSelector: #condExecuteFor:!OBService removeSelector: #buttonMorph!OBService removeSelector: #buttonLabelMorph!OBService removeSelector: #buttonLabel:!OBService removeSelector: #buttonLabel!OBService removeSelector: #announcer:!OBService removeSelector: #announcer!OBService removeSelector: #addServiceFor:toMenu:!OBService removeSelector: #action:!OBService removeSelector: #action!OBService class removeSelector: #new!OBService class removeSelector: #action:condition:!OBService class removeSelector: #action:!Smalltalk removeClassNamed: #OBService!OBRequestor removeSelector: #select:!OBRequestor removeSelector: #requestNode!OBRequestor removeSelector: #node:!OBRequestor removeSelector: #doesNotUnderstand:!OBRequestor removeSelector: #browser:!OBRequestor removeSelector: #announce:!OBRequestor class removeSelector: #for:!Smalltalk removeClassNamed: #OBRequestor!OBVarButtonPanel removeSelector: #subscribe!OBVarButtonPanel removeSelector: #selectionChanged:!OBVarButtonPanel removeSelector: #morphHeight!OBVarButtonPanel removeSelector: #morph!Smalltalk removeClassNamed: #OBVarButtonPanel!OBPanel removeSelector: #subscribe!OBPanel removeSelector: #isNavigation!OBPanel removeSelector: #browser:!OBPanel removeSelector: #browser!OBPanel removeSelector: #announcer!OBPanel class removeSelector: #inBrowser:!OBFixedButtonPanel removeSelector: #subscribe!OBFixedButtonPanel removeSelector: #selectionChanged:!OBFixedButtonPanel removeSelector: #push:!OBFixedButtonPanel removeSelector: #morphHeight!OBFixedButtonPanel removeSelector: #morphForModel:!OBFixedButtonPanel removeSelector: #morph!OBFixedButtonPanel removeSelector: #isSelected:!OBFixedButtonPanel removeSelector: #isEnabled:!OBFixedButtonPanel removeSelector: #initialize!OBFixedButtonPanel removeSelector: #createMorph!OBFixedButtonPanel removeSelector: #buttonModels!OBFixedButtonPanel removeSelector: #addButtonWithLabel:!OBFixedButtonPanel class removeSelector: #new!Smalltalk removeClassNamed: #OBFixedButtonPanel!OBDefinitionPanel removeSelector: #yellowButtonMenu!OBDefinitionPanel removeSelector: #withDefinitionDo:ifNil:!OBDefinitionPanel removeSelector: #text!OBDefinitionPanel removeSelector: #subscribe!OBDefinitionPanel removeSelector: #shiftedYellowButtonMenu!OBDefinitionPanel removeSelector: #selectionChanged:!OBDefinitionPanel removeSelector: #selection!OBDefinitionPanel removeSelector: #selectedClass!OBDefinitionPanel removeSelector: #refresh:!OBDefinitionPanel removeSelector: #perform:orSendTo:!OBDefinitionPanel removeSelector: #morphHeight!OBDefinitionPanel removeSelector: #morph!OBDefinitionPanel removeSelector: #menu:shifted:!OBDefinitionPanel removeSelector: #getDefinition!OBDefinitionPanel removeSelector: #doItReceiver!OBDefinitionPanel removeSelector: #doItContext!OBDefinitionPanel removeSelector: #definitionChanged:!OBDefinitionPanel removeSelector: #definition:!OBDefinitionPanel removeSelector: #accept:notifying:!OBDefinitionPanel removeSelector: #aboutToChange:!Smalltalk removeClassNamed: #OBDefinitionPanel!OBColumnPanel removeSelector: #subscribe!OBColumnPanel removeSelector: #sizing!OBColumnPanel removeSelector: #setMinPanes:maxPanes:!OBColumnPanel removeSelector: #setMetaNode:node:!OBColumnPanel removeSelector: #selectionPath!OBColumnPanel removeSelector: #selectionChanged:!OBColumnPanel removeSelector: #selected:!OBColumnPanel removeSelector: #selectNode:!OBColumnPanel removeSelector: #root!OBColumnPanel removeSelector: #reclaimPanes!OBColumnPanel removeSelector: #pushColumn:!OBColumnPanel removeSelector: #popColumn!OBColumnPanel removeSelector: #parentNodeForColumn:!OBColumnPanel removeSelector: #panes!OBColumnPanel removeSelector: #okToReclaimPane!OBColumnPanel removeSelector: #nodeDeleted:!OBColumnPanel removeSelector: #morphHeight!OBColumnPanel removeSelector: #morph!OBColumnPanel removeSelector: #minPanes!OBColumnPanel removeSelector: #maxPanes!OBColumnPanel removeSelector: #labelString!OBColumnPanel removeSelector: #jumpToRoot!OBColumnPanel removeSelector: #jumpTo:!OBColumnPanel removeSelector: #isNavigation!OBColumnPanel removeSelector: #hopTo:!OBColumnPanel removeSelector: #hasSelection!OBColumnPanel removeSelector: #emptyColumn!OBColumnPanel removeSelector: #defaultBackgroundColor!OBColumnPanel removeSelector: #currentOrRootNode!OBColumnPanel removeSelector: #currentNode!OBColumnPanel removeSelector: #currentColumn!OBColumnPanel removeSelector: #columns:!OBColumnPanel removeSelector: #columns!OBColumnPanel removeSelector: #columnBefore:ifAbsent:!OBColumnPanel removeSelector: #columnBefore:!OBColumnPanel removeSelector: #columnAfter:!OBColumnPanel removeSelector: #clearAfter:!OBColumnPanel removeSelector: #buildScroller!OBColumnPanel class removeSelector: #new!OBColumnPanel class removeSelector: #minPanes:maxPanes:!Smalltalk removeClassNamed: #OBColumnPanel!Smalltalk removeClassNamed: #OBPanel!OBNode removeSelector: #wantsDroppedNode:!OBNode removeSelector: #title!OBNode removeSelector: #textSelection!OBNode removeSelector: #text:!OBNode removeSelector: #text!OBNode removeSelector: #signalSelection!OBNode removeSelector: #signalDeletion!OBNode removeSelector: #signalChildrenChanged!OBNode removeSelector: #signalChanged!OBNode removeSelector: #referenceForMethod:ofClass:!OBNode removeSelector: #name!OBNode removeSelector: #metaNode:!OBNode removeSelector: #metaNode!OBNode removeSelector: #isDescendantOf:!OBNode removeSelector: #isAncestorOf:!OBNode removeSelector: #hash!OBNode removeSelector: #dropSelector!OBNode removeSelector: #displayString!OBNode removeSelector: #displayName!OBNode removeSelector: #demandSelection!OBNode removeSelector: #definition!OBNode removeSelector: #correspondsWith:!OBNode removeSelector: #asDraggableMorph!OBNode removeSelector: #announce:!OBNode removeSelector: #ancestrySelector!OBNode removeSelector: #actions!OBNode removeSelector: #action:withMenuLabel:withButtonLabel:withKeystroke:withIcon:!OBNode removeSelector: #action:withLabel:withKeystroke:withIcon:!OBNode removeSelector: #action:withLabel:withKeystroke:!OBNode removeSelector: #action:withLabel:withIcon:!OBNode removeSelector: #action:withLabel:!OBNode removeSelector: #action:buttonLabel:menuLabel:!OBNode removeSelector: #acceptDroppedNode:!OBNode removeSelector: #accept:notifying:!OBNode removeSelector: #=!OBNode class removeSelector: #fromAssociation:!OBNode class removeSelector: #actionsForParent:!OBCollectionNode removeSelector: #setCollection:!OBCollectionNode removeSelector: #name!OBCollectionNode removeSelector: #children!OBCollectionNode class removeSelector: #on:!Smalltalk removeClassNamed: #OBCollectionNode!Smalltalk removeClassNamed: #OBNode!OBMorphicPanelLayout removeSelector: #setPanels:!OBMorphicPanelLayout removeSelector: #navigationPanel!OBMorphicPanelLayout removeSelector: #columnProportion!OBMorphicPanelLayout removeSelector: #addOtherMorphsTo:!OBMorphicPanelLayout removeSelector: #addNavMorphTo:!OBMorphicPanelLayout removeSelector: #addMorphsTo:!OBMorphicPanelLayout class removeSelector: #for:!Smalltalk removeClassNamed: #OBMorphicPanelLayout!OBMetaNode removeSelector: #shortPrintOn:!OBMetaNode removeSelector: #printOn:!OBMetaNode removeSelector: #nodesForParent:!OBMetaNode removeSelector: #name:!OBMetaNode removeSelector: #name!OBMetaNode removeSelector: #metaNode!OBMetaNode removeSelector: #initialize!OBMetaNode removeSelector: #hasChildren!OBMetaNode removeSelector: #filterClass:!OBMetaNode removeSelector: #filter!OBMetaNode removeSelector: #edges!OBMetaNode removeSelector: #displaySelector:!OBMetaNode removeSelector: #displaySelector!OBMetaNode removeSelector: #columnInPanel:node:!OBMetaNode removeSelector: #columnClass:!OBMetaNode removeSelector: #children!OBMetaNode removeSelector: #childAt:put:!OBMetaNode removeSelector: #childAt:labeled:put:!OBMetaNode removeSelector: #addActor:!OBMetaNode removeSelector: #actionsForParent:!OBMetaNode removeSelector: #actionsForNode:!OBMetaNode removeSelector: #actionSetsForParent:!OBMetaNode removeSelector: #actionSetsForNode:!OBMetaNode class removeSelector: #new!OBMetaNode class removeSelector: #named:!Smalltalk removeClassNamed: #OBMetaNode!OBMetaEdge removeSelector: #setLabel:selector:metaNode:!OBMetaEdge removeSelector: #selector!OBMetaEdge removeSelector: #printOn:!OBMetaEdge removeSelector: #nodesForParent:!OBMetaEdge removeSelector: #metaNode!OBMetaEdge removeSelector: #label!OBMetaEdge class removeSelector: #selector:metaNode:!OBMetaEdge class removeSelector: #label:selector:metaNode:!Smalltalk removeClassNamed: #OBMetaEdge!OBModalFilter removeSelector: #wantsButton!OBModalFilter removeSelector: #selection:!OBModalFilter removeSelector: #selection!OBModalFilter removeSelector: #selectedEdge!OBModalFilter removeSelector: #selectAncestorOf:withParent:!OBModalFilter removeSelector: #nodesForParent:!OBModalFilter removeSelector: #list!OBModalFilter removeSelector: #incrementSelection!OBModalFilter removeSelector: #buttonMorph!Smalltalk removeClassNamed: #OBModalFilter!OBFilter removeSelector: #wantsButton!OBFilter removeSelector: #setMetaNode:!OBFilter removeSelector: #selectAncestorOf:withParent:!OBFilter removeSelector: #nodesForParent:!OBFilter removeSelector: #monitor:!OBFilter removeSelector: #metaNode!OBFilter removeSelector: #children!OBFilter class removeSelector: #forMetaNode:!Smalltalk removeClassNamed: #OBFilter!OBDefinition removeSelector: #textSelection!OBDefinition removeSelector: #text:!OBDefinition removeSelector: #text!OBDefinition removeSelector: #signalChange!OBDefinition removeSelector: #selection!OBDefinition removeSelector: #doItReceiver!OBDefinition removeSelector: #doItContext!OBDefinition removeSelector: #accept:notifying:!Smalltalk removeClassNamed: #OBDefinition!OBColumn removeSelector: #wantsDroppedMorph:event:inMorph:!OBColumn removeSelector: #wantsButton!OBColumn removeSelector: #subscribe!OBColumn removeSelector: #simplePane!OBColumn removeSelector: #signalSelectionChanged!OBColumn removeSelector: #shouldBeLast!OBColumn removeSelector: #setPanel:metaNode:node:!OBColumn removeSelector: #setPanel:!OBColumn removeSelector: #servicesForKeystroke:!OBColumn removeSelector: #selectionChanged:!OBColumn removeSelector: #selection:!OBColumn removeSelector: #selection!OBColumn removeSelector: #selectedNode!OBColumn removeSelector: #selectSilently:!OBColumn removeSelector: #selectAncestorOf:!OBColumn removeSelector: #select:!OBColumn removeSelector: #requestor!OBColumn removeSelector: #refreshAndSignal:!OBColumn removeSelector: #refresh:!OBColumn removeSelector: #refresh!OBColumn removeSelector: #printOn:!OBColumn removeSelector: #parent:!OBColumn removeSelector: #parent!OBColumn removeSelector: #paneWithHeader!OBColumn removeSelector: #okToChange!OBColumn removeSelector: #nodeForItem:inMorph:!OBColumn removeSelector: #nodeForDroppedMorph:event:inMorph:!OBColumn removeSelector: #nodeDeleted:!OBColumn removeSelector: #nodeChanged:!OBColumn removeSelector: #nextMetaNode!OBColumn removeSelector: #next!OBColumn removeSelector: #morph!OBColumn removeSelector: #metaNode!OBColumn removeSelector: #menu:!OBColumn removeSelector: #listSize!OBColumn removeSelector: #listMorph!OBColumn removeSelector: #listChanged!OBColumn removeSelector: #listAt:!OBColumn removeSelector: #list!OBColumn removeSelector: #keystroke:from:!OBColumn removeSelector: #isEmpty!OBColumn removeSelector: #includesNode:!OBColumn removeSelector: #hasSelection!OBColumn removeSelector: #getChildren!OBColumn removeSelector: #filter:!OBColumn removeSelector: #filter!OBColumn removeSelector: #dropEnabled!OBColumn removeSelector: #dragTransferTypeForMorph:!OBColumn removeSelector: #dragTransferType!OBColumn removeSelector: #dragPassengerFor:inMorph:!OBColumn removeSelector: #dragEnabled!OBColumn removeSelector: #descriptor!OBColumn removeSelector: #createNext!OBColumn removeSelector: #columnWithHeader!OBColumn removeSelector: #clearSelection!OBColumn removeSelector: #clear!OBColumn removeSelector: #childrenChanged:!OBColumn removeSelector: #buttonHeight!OBColumn removeSelector: #browser!OBColumn removeSelector: #basicNext!OBColumn removeSelector: #announcer!OBColumn removeSelector: #addServicesToMenu:!OBColumn removeSelector: #addActionsToMenu:!OBColumn removeSelector: #actionsForSelectedNode!OBColumn removeSelector: #actionsForParentNode!OBColumn removeSelector: #actionsForKeystroke:!OBColumn removeSelector: #actionSetsForSelectedNode!OBColumn removeSelector: #actionSetsForParentNode!OBColumn removeSelector: #acceptDroppingMorph:event:inMorph:!OBColumn class removeSelector: #inPanel:metaNode:node:!OBColumn class removeSelector: #inPanel:!Smalltalk removeClassNamed: #OBColumn!OBButtonModel removeSelector: #selectionChanged!OBButtonModel removeSelector: #push!OBButtonModel removeSelector: #morph!OBButtonModel removeSelector: #labelMorph!OBButtonModel removeSelector: #label:!OBButtonModel removeSelector: #label!OBButtonModel removeSelector: #isSelected!OBButtonModel removeSelector: #isEnabled!OBButtonModel removeSelector: #bar:!OBButtonModel class removeSelector: #withLabel:inBar:!OBButtonModel class removeSelector: #onColor!OBButtonModel class removeSelector: #offColor!Smalltalk removeClassNamed: #OBButtonModel!OBBrowser removeSelector: #transcribe!OBBrowser removeSelector: #subscribe!OBBrowser removeSelector: #signalRefresh!OBBrowser removeSelector: #setMetaNode:node:!OBBrowser removeSelector: #selectionPath!OBBrowser removeSelector: #root!OBBrowser removeSelector: #requestor!OBBrowser removeSelector: #relabel:!OBBrowser removeSelector: #panels!OBBrowser removeSelector: #openInMorphic!OBBrowser removeSelector: #open!OBBrowser removeSelector: #okToChange!OBBrowser removeSelector: #navigationPanel!OBBrowser removeSelector: #morphicPanelLayout!OBBrowser removeSelector: #morph!OBBrowser removeSelector: #labelString!OBBrowser removeSelector: #jumpToRoot!OBBrowser removeSelector: #jumpTo:!OBBrowser removeSelector: #initialize!OBBrowser removeSelector: #dontTranscribe!OBBrowser removeSelector: #defaultLabel!OBBrowser removeSelector: #defaultBackgroundColor!OBBrowser removeSelector: #currentOrRootNode!OBBrowser removeSelector: #currentNode!OBBrowser removeSelector: #announcer!OBBrowser removeSelector: #addPanel:!OBBrowser class removeSelector: #titleForRoot:!OBBrowser class removeSelector: #title!OBBrowser class removeSelector: #selection:!OBBrowser class removeSelector: #root:selection:!OBBrowser class removeSelector: #root:!OBBrowser class removeSelector: #panels!OBBrowser class removeSelector: #paneCount!OBBrowser class removeSelector: #optionalButtons!OBBrowser class removeSelector: #optionalButtonPanel!OBBrowser class removeSelector: #openRoot:selection:!OBBrowser class removeSelector: #open!OBBrowser class removeSelector: #new!OBBrowser class removeSelector: #navigationPanel!OBBrowser class removeSelector: #minPanes!OBBrowser class removeSelector: #metaNode:root:selection:panels:!OBBrowser class removeSelector: #metaNode:root:selection:!OBBrowser class removeSelector: #metaNode:node:!OBBrowser class removeSelector: #maxPanes!OBBrowser class removeSelector: #definitionPanel!OBBrowser class removeSelector: #defaultRootNode!OBBrowser class removeSelector: #defaultMetaNode!Smalltalk removeClassNamed: #OBBrowser!OBAnnouncer removeSelector: #unsubscribe:!OBAnnouncer removeSelector: #observe:send:to:!OBAnnouncer removeSelector: #observe:do:!OBAnnouncer removeSelector: #initialize!OBAnnouncer removeSelector: #announce:!OBAnnouncer class removeSelector: #new!OBAnnouncer class removeSelector: #current!Smalltalk removeClassNamed: #OBAnnouncer!OBServiceScan removeSelector: #services!OBServiceScan removeSelector: #initialize!OBServiceScan removeSelector: #addService:!Smalltalk removeClassNamed: #OBServiceScan!OBSelectionChanged removeSelector: #node:!OBSelectionChanged removeSelector: #node!OBSelectionChanged removeSelector: #column:!OBSelectionChanged removeSelector: #column!OBSelectionChanged class removeSelector: #node:!OBSelectionChanged class removeSelector: #column:!Smalltalk removeClassNamed: #OBSelectionChanged!OBSelectingNode removeSelector: #node:!OBSelectingNode removeSelector: #node!OBSelectingNode class removeSelector: #node:!Smalltalk removeClassNamed: #OBSelectingNode!Smalltalk removeClassNamed: #OBRefreshRequired!OBNodeDeleted removeSelector: #node:!OBNodeDeleted removeSelector: #node!OBNodeDeleted class removeSelector: #node:!Smalltalk removeClassNamed: #OBNodeDeleted!OBNodeCreated removeSelector: #node:!OBNodeCreated removeSelector: #node!OBNodeCreated class removeSelector: #node:!Smalltalk removeClassNamed: #OBNodeCreated!OBNodeChanged removeSelector: #node:!OBNodeChanged removeSelector: #node!OBNodeChanged class removeSelector: #node:!Smalltalk removeClassNamed: #OBNodeChanged!OBDefinitionChanged removeSelector: #node:!OBDefinitionChanged removeSelector: #node!OBDefinitionChanged removeSelector: #definition:!OBDefinitionChanged removeSelector: #definition!OBDefinitionChanged class removeSelector: #node:definition:!OBDefinitionChanged class removeSelector: #definition:!Smalltalk removeClassNamed: #OBDefinitionChanged!OBChildrenChanged removeSelector: #node:!OBChildrenChanged removeSelector: #node!OBChildrenChanged class removeSelector: #node:!Smalltalk removeClassNamed: #OBChildrenChanged!OBAboutToChange removeSelector: #veto!OBAboutToChange removeSelector: #isVetoed!Smalltalk removeClassNamed: #OBAboutToChange!Smalltalk removeClassNamed: #OBAnnouncement!OBNodeActor removeSelector: #nodeClass:!OBNodeActor removeSelector: #actionsForParent:!OBNodeActor removeSelector: #actionsForNode:!OBNodeActor class removeSelector: #onNodeClass:!Smalltalk removeClassNamed: #OBNodeActor!OBActor removeSelector: #newIcon!OBActor removeSelector: #findIcon!OBActor removeSelector: #deleteIcon!OBActor removeSelector: #actionsForParent:!OBActor removeSelector: #actionsForNode:!OBActor removeSelector: #actionWithLabel:selector:!Smalltalk removeClassNamed: #OBActor!OBScrollBar removeSelector: #wantsSteps!OBScrollBar removeSelector: #waitForDelay1:delay2:!OBScrollBar removeSelector: #upArrow8Bit!OBScrollBar removeSelector: #totalSliderArea!OBScrollBar removeSelector: #thumbColor!OBScrollBar removeSelector: #stepTime!OBScrollBar removeSelector: #step!OBScrollBar removeSelector: #sliderThickness!OBScrollBar removeSelector: #sliderShadowColor!OBScrollBar removeSelector: #sliderExtent!OBScrollBar removeSelector: #sliderColor:!OBScrollBar removeSelector: #setValue:!OBScrollBar removeSelector: #setNextDirectionFromEvent:!OBScrollBar removeSelector: #scrollUpInit!OBScrollBar removeSelector: #scrollUp:!OBScrollBar removeSelector: #scrollUp!OBScrollBar removeSelector: #scrollPageInit:!OBScrollBar removeSelector: #scrollDownInit!OBScrollBar removeSelector: #scrollDown:!OBScrollBar removeSelector: #scrollDown!OBScrollBar removeSelector: #scrollDelta:pageDelta:!OBScrollBar removeSelector: #scrollDelta!OBScrollBar removeSelector: #scrollBarAction:!OBScrollBar removeSelector: #scrollBarAction!OBScrollBar removeSelector: #roundedScrollbarLook!OBScrollBar removeSelector: #resetTimer!OBScrollBar removeSelector: #pagingArea!OBScrollBar removeSelector: #mouseDownInSlider:!OBScrollBar removeSelector: #menuButtonMouseDown:!OBScrollBar removeSelector: #interval:!OBScrollBar removeSelector: #initializeUpButton!OBScrollBar removeSelector: #initializeSlider!OBScrollBar removeSelector: #initializePagingArea!OBScrollBar removeSelector: #initializeEmbedded:!OBScrollBar removeSelector: #initializeDownButton!OBScrollBar removeSelector: #initialize!OBScrollBar removeSelector: #finishedScrolling!OBScrollBar removeSelector: #extent:!OBScrollBar removeSelector: #expandSlider!OBScrollBar removeSelector: #doScrollUp!OBScrollBar removeSelector: #doScrollDown!OBScrollBar removeSelector: #doScrollByPage!OBScrollBar removeSelector: #cachedImageAt:ifAbsentPut:!OBScrollBar removeSelector: #buttonExtent!OBScrollBar removeSelector: #adoptPaneColor:!OBScrollBar class removeSelector: #initialize!OBScrollBar class removeSelector: #alwaysShowFlatScrollbarForAlternativeLook!Smalltalk removeClassNamed: #OBScrollBar!LazyListMorph removeSelector: #rectForRow:!MenuIcons class removeSelector: #tryIcons:!OBPluggableTextMorph removeSelector: #setText:!OBPluggableTextMorph removeSelector: #keyStroke:!Smalltalk removeClassNamed: #OBPluggableTextMorph!Behavior removeSelector: #asAnnouncement!OBRadioButtonBar removeSelector: #withSelectedButtonDo:!OBRadioButtonBar removeSelector: #withButtonAt:do:!OBRadioButtonBar removeSelector: #updateSelection!OBRadioButtonBar removeSelector: #updateMorphs!OBRadioButtonBar removeSelector: #updateList!OBRadioButtonBar removeSelector: #updateButtons!OBRadioButtonBar removeSelector: #update:!OBRadioButtonBar removeSelector: #push:!OBRadioButtonBar removeSelector: #on:list:selected:changeSelected:!OBRadioButtonBar removeSelector: #noteNewOwner:!OBRadioButtonBar removeSelector: #model:!OBRadioButtonBar removeSelector: #list!OBRadioButtonBar removeSelector: #isSelected:!OBRadioButtonBar removeSelector: #isEnabled:!OBRadioButtonBar removeSelector: #initGeometry!OBRadioButtonBar removeSelector: #getSelectionIndex!OBRadioButtonBar removeSelector: #adoptPaneColor:!OBRadioButtonBar class removeSelector: #on:list:selected:changeSelected:!Smalltalk removeClassNamed: #OBRadioButtonBar!OBPaneScroller removeSelector: #updateSizing!OBPaneScroller removeSelector: #updatePanes!OBPaneScroller removeSelector: #update:!OBPaneScroller removeSelector: #totalScrollRange!OBPaneScroller removeSelector: #totalPaneWidth!OBPaneScroller removeSelector: #stepTime!OBPaneScroller removeSelector: #step!OBPaneScroller removeSelector: #sizing!OBPaneScroller removeSelector: #showScrollBar!OBPaneScroller removeSelector: #setScrollDeltas!OBPaneScroller removeSelector: #separatorWidth!OBPaneScroller removeSelector: #separator!OBPaneScroller removeSelector: #scrollToRight!OBPaneScroller removeSelector: #scrollDeltaWidth!OBPaneScroller removeSelector: #scrollBarValue:!OBPaneScroller removeSelector: #scrollBarIsVisible!OBPaneScroller removeSelector: #scrollBarHeight!OBPaneScroller removeSelector: #resizeScrollBar!OBPaneScroller removeSelector: #reclaimPanes!OBPaneScroller removeSelector: #pushPane:!OBPaneScroller removeSelector: #popPanes:!OBPaneScroller removeSelector: #panes!OBPaneScroller removeSelector: #paneWidthsToFit:!OBPaneScroller removeSelector: #paneHeight!OBPaneScroller removeSelector: #paneCount!OBPaneScroller removeSelector: #model:!OBPaneScroller removeSelector: #model!OBPaneScroller removeSelector: #leftoverScrollRange!OBPaneScroller removeSelector: #layoutWidgets!OBPaneScroller removeSelector: #layoutPanes!OBPaneScroller removeSelector: #isScrollable!OBPaneScroller removeSelector: #innerBounds!OBPaneScroller removeSelector: #initializeTransform!OBPaneScroller removeSelector: #initializeScrollbar!OBPaneScroller removeSelector: #initialize!OBPaneScroller removeSelector: #hideScrollBar!OBPaneScroller removeSelector: #hideOrShowScrollBar!OBPaneScroller removeSelector: #doLayout!OBPaneScroller removeSelector: #computeMorphWidths!OBPaneScroller removeSelector: #clearPanes!OBPaneScroller removeSelector: #bounds:!OBPaneScroller removeSelector: #basicUpdateSizing!OBPaneScroller removeSelector: #basicUpdatePanes!OBPaneScroller removeSelector: #adjustPaneHeight!OBPaneScroller class removeSelector: #withModel:!Smalltalk removeClassNamed: #OBPaneScroller!OBPane removeSelector: #update:!OBPane removeSelector: #setColumn:filter:!OBPane removeSelector: #removeButton!OBPane removeSelector: #noteNewOwner:!OBPane removeSelector: #model:!OBPane removeSelector: #initGeometry!OBPane removeSelector: #hasButton!OBPane removeSelector: #defaultButtonHeight!OBPane removeSelector: #buttonHeight!OBPane removeSelector: #bounds:!OBPane removeSelector: #adjustList!OBPane removeSelector: #adjustButton!OBPane removeSelector: #addButton:!OBPane class removeSelector: #forColumn:withFilter:!OBPane class removeSelector: #forColumn:!Smalltalk removeClassNamed: #OBPane!OBTextMorphEditor removeSelector: #sendersOfIt!OBTextMorphEditor removeSelector: #send:toModelWith:orDo:!OBTextMorphEditor removeSelector: #referencesToIt!OBTextMorphEditor removeSelector: #implementorsOfIt!OBTextMorphEditor removeSelector: #browseIt!Smalltalk removeClassNamed: #OBTextMorphEditor!PluggableListMorph removeSelector: #getListObtrusively!PluggableListMorph removeSelector: #getListDelicately!OBTextRequest removeSelector: #template:!OBTextRequest removeSelector: #template!OBTextRequest removeSelector: #requestText!OBTextRequest removeSelector: #prompt:!OBTextRequest removeSelector: #prompt!OBTextRequest removeSelector: #defaultAction!OBTextRequest class removeSelector: #prompt:template:!OBTextRequest class removeSelector: #prompt:!Smalltalk removeClassNamed: #OBTextRequest!OBInteractionRequest removeSelector: #isBrowseRequest!OBConfirmationRequest removeSelector: #setPrompt:confirm:cancel:!OBConfirmationRequest removeSelector: #ok!OBConfirmationRequest removeSelector: #defaultAction!OBConfirmationRequest removeSelector: #cancel!OBConfirmationRequest class removeSelector: #prompt:confirm:cancel:!OBConfirmationRequest class removeSelector: #prompt:confirm:!OBConfirmationRequest class removeSelector: #prompt:!OBConfirmationRequest class removeSelector: #newPrompt:confirm:cancel:!Smalltalk removeClassNamed: #OBConfirmationRequest!OBChoiceRequest removeSelector: #values!OBChoiceRequest removeSelector: #setPrompt:labels:values:lines:!OBChoiceRequest removeSelector: #prompt!OBChoiceRequest removeSelector: #lines!OBChoiceRequest removeSelector: #labels!OBChoiceRequest removeSelector: #defaultAction!OBChoiceRequest class removeSelector: #prompt:labels:values:lines:!OBChoiceRequest class removeSelector: #prompt:labels:values:!OBChoiceRequest class removeSelector: #labels:lines:!OBChoiceRequest class removeSelector: #labels:!Smalltalk removeClassNamed: #OBChoiceRequest!OBBrowseRequest removeSelector: #isBrowseRequest!OBBrowseRequest removeSelector: #defaultAction!OBBrowseRequest removeSelector: #browser:!OBBrowseRequest removeSelector: #browser!OBBrowseRequest class removeSelector: #signal:!Smalltalk removeClassNamed: #OBBrowseRequest!Smalltalk removeClassNamed: #OBInteractionRequest!Smalltalk removeClassNamed: #OBDispatcherRequest!Smalltalk removeClassNamed: #OBAnnouncerRequest!OBAction removeSelector: #wantsButton!OBAction removeSelector: #trigger!OBAction removeSelector: #perform:orSendTo:!OBAction removeSelector: #labelWithKeystroke!OBAction removeSelector: #label:!OBAction removeSelector: #label!OBAction removeSelector: #keystroke:!OBAction removeSelector: #keystroke!OBAction removeSelector: #icon:!OBAction removeSelector: #icon!OBAction removeSelector: #buttonMorph!OBAction removeSelector: #buttonLabelMorph!OBAction removeSelector: #buttonLabel:!OBAction removeSelector: #buttonLabel!OBAction removeSelector: #announcer:!OBAction removeSelector: #announcer!OBAction removeSelector: #addItemToMenu:!OBAction class removeSelector: #label:receiver:selector:arguments:keystroke:icon:!OBAction class removeSelector: #label:receiver:selector:arguments:keystroke:!OBAction class removeSelector: #label:receiver:selector:arguments:icon:!OBAction class removeSelector: #label:receiver:selector:arguments:!OBAction class removeSelector: #label:buttonLabel:receiver:selector:arguments:keystroke:icon:!OBAction class removeSelector: #label:buttonLabel:receiver:selector:arguments:!Smalltalk removeClassNamed: #OBAction!MessageSend removeSelector: #valueWithPossibleArgs:!SystemOrganizer removeSelector: #isClassOrganizer!OBSystemBrowserAdaptor removeSelector: #targetClass!OBSystemBrowserAdaptor removeSelector: #setClass:selector:!OBSystemBrowserAdaptor removeSelector: #selector!OBSystemBrowserAdaptor removeSelector: #openEditString:!OBSystemBrowserAdaptor removeSelector: #labelString!OBSystemBrowserAdaptor class removeSelector: #unregister!OBSystemBrowserAdaptor class removeSelector: #register!OBSystemBrowserAdaptor class removeSelector: #openBrowserView:label:!OBSystemBrowserAdaptor class removeSelector: #openBrowser!OBSystemBrowserAdaptor class removeSelector: #open!OBSystemBrowserAdaptor class removeSelector: #initialize!OBSystemBrowserAdaptor class removeSelector: #fullOnClass:selector:!Smalltalk removeClassNamed: #OBSystemBrowserAdaptor!OBMethodVersion removeSelector: #theClassName!OBMethodVersion removeSelector: #theClass!OBMethodVersion removeSelector: #stamp!OBMethodVersion removeSelector: #source!OBMethodVersion removeSelector: #setSources:pointer:!OBMethodVersion removeSelector: #setSelector!OBMethodVersion removeSelector: #selector!OBMethodVersion removeSelector: #previous!OBMethodVersion removeSelector: #pointer!OBMethodVersion removeSelector: #parseSource!OBMethodVersion removeSelector: #parseChunk:!OBMethodVersion removeSelector: #latest!OBMethodVersion removeSelector: #hash!OBMethodVersion removeSelector: #fileIn!OBMethodVersion removeSelector: #classSymbol!OBMethodVersion removeSelector: #category!OBMethodVersion removeSelector: #=!OBMethodVersion class removeSelector: #versionsOfMethod:!OBMethodVersion class removeSelector: #scan:from:!OBMethodVersion class removeSelector: #fromSources:andPointer:!Smalltalk removeClassNamed: #OBMethodVersion!OBClassReference removeSelector: #theNonMetaName:!OBClassReference removeSelector: #theNonMetaName!OBClassReference removeSelector: #theNonMetaClass!OBClassReference removeSelector: #theClass!OBClassReference removeSelector: #setName:!OBClassReference removeSelector: #referenceToMethod:!OBClassReference removeSelector: #printOn:!OBClassReference removeSelector: #name!OBClassReference removeSelector: #isMeta!OBClassReference removeSelector: #hash!OBClassReference removeSelector: #beNonMeta!OBClassReference removeSelector: #beMeta!OBClassReference removeSelector: #=!OBClassReference removeSelector: #<=!OBClassReference class removeSelector: #to:!OBClassReference class removeSelector: #named:!OBClassReference class removeSelector: #metaNamed:!Smalltalk removeClassNamed: #OBClassReference!OBCategoryServant removeSelector: #svcCreateCategory!OBCategoryServant removeSelector: #services!OBCategoryServant removeSelector: #createCategory:!OBCategoryServant removeSelector: #categoryTemplateFor:!Smalltalk removeClassNamed: #OBCategoryServant!ClassTrait removeSelector: #asNode!ClassTrait removeSelector: #asClassSideNode!MethodReference removeSelector: #asNode!Class removeSelector: #asNode!Class removeSelector: #asClassSideNode!Metaclass removeSelector: #asNode!Metaclass removeSelector: #asClassSideNode!Trait removeSelector: #asNode!Trait removeSelector: #asClassSideNode!TCommentDescription removeSelector: #asCommentNode!ClassOrganizer removeSelector: #isClassOrganizer!OBSourceFilesRequest removeSelector: #isBrowseRequest!OBSourceFilesRequest removeSelector: #defaultAction!Smalltalk removeClassNamed: #OBSourceFilesRequest!Smalltalk removeClassNamed: #OBVersionBrowser!Smalltalk removeClassNamed: #OBVariablesBrowser!Smalltalk removeClassNamed: #OBSystemBrowser!Smalltalk removeClassNamed: #OBSendersBrowser!Smalltalk removeClassNamed: #OBReferencesBrowser!Smalltalk removeClassNamed: #OBImplementorsBrowser!Smalltalk removeClassNamed: #OBListBrowser!Smalltalk removeClassNamed: #OBInheritanceBrowser!Smalltalk removeClassNamed: #OBHierarchyBrowser!Smalltalk removeClassNamed: #OBCodeBrowser!Smalltalk removeClassNamed: #OBOrganizationDefinition!Smalltalk removeClassNamed: #OBMethodDefinition!Smalltalk removeClassNamed: #OBClassDefinition!Smalltalk removeClassNamed: #OBInstanceVariableNode!Smalltalk removeClassNamed: #OBClassVariableNode!Smalltalk removeClassNamed: #OBVariableNode!Smalltalk removeClassNamed: #OBSelectorNode!Smalltalk removeClassNamed: #OBMethodVersionNode!Smalltalk removeClassNamed: #OBMessageNode!Smalltalk removeClassNamed: #OBClassRefNode!Smalltalk removeClassNamed: #OBMethodNode!Smalltalk removeClassNamed: #OBAllMethodCategoryNode!Smalltalk removeClassNamed: #OBMethodCategoryNode!Smalltalk removeClassNamed: #OBMetaclassNode!Smalltalk removeClassNamed: #OBEnvironmentNode!Smalltalk removeClassNamed: #OBClassNode!Smalltalk removeClassNamed: #OBClassCommentNode!Smalltalk removeClassNamed: #OBClassCategoryNode!Smalltalk removeClassNamed: #OBClassAwareNode!Smalltalk removeClassNamed: #OBCodeNode!Smalltalk removeClassNamed: #OBImplementorsViewActor!Smalltalk removeClassNamed: #OBClassActor!Smalltalk removeClassNamed: #OBCategoryActor!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.335.mcz') load.ScriptLoader new updateFrom7069.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 2/14/2008 22:04' prior: 33818317!script93	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.150.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.116.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.22.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.102.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/14/2008 22:04'!updateFrom7070	"self new updateFrom7070"	self script93.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	self flushCaches.	Preferences enable: #serverMode.		! !"ScriptLoader"!!Preferences class methodsFor: 'standard queries' stamp: 'al 7/31/2007 16:17'!serverMode	^ self		valueOfFlag: #serverMode		ifAbsent: [false]! !!WorldState methodsFor: 'update cycle' stamp: 'al 7/31/2007 16:12' prior: 50954331!interCyclePause: milliSecs	"delay enough that the previous cycle plus the amount of delay will equal milliSecs.  If the cycle is already expensive, then no delay occurs.  However, if the system is idly waiting for interaction from the user, the method will delay for a proportionally long time and cause the overall CPU usage of Squeak to be low.	If the preference #serverMode is enabled, always do a complete delay of 50ms, independant of my argument. This prevents the freezing problem described in Mantis #6581"	| currentTime wait |	Preferences serverMode		ifFalse: [			(lastCycleTime notNil and: [CanSurrenderToOS ~~ false]) ifTrue: [ 				currentTime := Time millisecondClockValue.				wait := lastCycleTime + milliSecs - currentTime.				(wait > 0 and: [ wait <= milliSecs ] ) ifTrue: [					(Delay forMilliseconds: wait) wait ] ] ]		ifTrue: [ (Delay forMilliseconds: 50) wait ].	lastCycleTime := Time millisecondClockValue.	CanSurrenderToOS := true.! !"Morphic"!"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.336.mcz') load.ScriptLoader new updateFrom7070.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 2/14/2008 22:12'!script94	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.151.mczKernelTests-sd.51.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.116.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.22.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.102.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/14/2008 22:12'!updateFrom7071	"self new updateFrom7071"	self script94.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	self flushCaches.	Preferences enable: #serverMode.		! !"ScriptLoader"!!Process methodsFor: 'changing process state' stamp: 'ar 10/5/2007 18:01' prior: 28009754!terminate 	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."	| ctxt unwindBlock inSema |	self isActiveProcess ifTrue: [		ctxt := thisContext.		[	ctxt := ctxt findNextUnwindContextUpTo: nil.			ctxt isNil		] whileFalse: [			unwindBlock := ctxt tempAt: 1.			unwindBlock ifNotNil: [				ctxt tempAt: 1 put: nil.				thisContext terminateTo: ctxt.				unwindBlock value].		].		thisContext terminateTo: nil.		myList := nil.		self primitiveSuspend.	] ifFalse: [		"Since the receiver is not the active process, drop its priority to rock-bottom so that		it doesn't accidentally preempt the process that is trying to terminate it."		priority := 10.		myList ifNotNil: [			myList remove: self ifAbsent: [].			"Figure out if the receiver was terminated while waiting on a Semaphore"			inSema := myList class == Semaphore.			myList := nil].		suspendedContext ifNotNil: [			"Figure out if we are terminating the process while waiting in Semaphore>>critical:			In this case, pop the suspendedContext so that we leave the ensure: block inside			Semaphore>>critical: without signaling the semaphore."			(inSema == true and:[				suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue:[					suspendedContext := suspendedContext home.			].			ctxt := self popTo: suspendedContext bottomContext.			ctxt == suspendedContext bottomContext ifFalse: [				self debug: ctxt title: 'Unwind error during termination']].	].! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 17:59' prior: 29701676!critical: mutuallyExcludedBlock				"Evaluate mutuallyExcludedBlock only if the receiver is not currently in	the process of running the critical: message. If the receiver is, evaluate	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue caught |	caught := false.	[		caught := true.		self wait.		blockValue := mutuallyExcludedBlock value	] ensure: [caught ifTrue: [self signal]].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 18:33'!critical: mutuallyExcludedBlock ifCurtailed: terminationBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	^self critical:[[mutuallyExcludedBlock value] ifCurtailed: terminationBlock]! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 17:59' prior: 29702118!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr |	hasError := false.	self critical:[		blockValue := [mutuallyExcludedBlock value] ifError:[:msg :rcvr|			hasError := true.			errMsg := msg.			errRcvr := rcvr		].	].	hasError ifTrue:[ ^errorBlock value: errMsg value: errRcvr].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 18:34'!critical: mutuallyExcludedBlock ifLocked: alternativeBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	excessSignals == 0 ifTrue:[		"If we come here, then the semaphore was locked when the test executed. 		Evaluate the alternative block and answer its result."		^alternativeBlock value 	].	^self critical: mutuallyExcludedBlock! !!SemaphoreTest methodsFor: 'testing' stamp: 'ar 10/5/2007 18:09'!testSemaAfterCriticalWait	"self run: #testSemaAfterCriticalWait"	"This tests whether a semaphore that has just left the wait in Semaphore>>critical:	leaves it with signaling the associated semaphore."	| s p |	s := Semaphore new.	p := [s critical:[]] forkAt: Processor activePriority-1.	"wait until p entered the critical section"	[p suspendingList == s] whileFalse:[(Delay forMilliseconds: 10) wait].	"Now that p entered it, signal the semaphore. p now 'owns' the semaphore	but since we are running at higher priority than p it will not get to do	anything."	s signal.	p terminate.	self assert:[(s instVarNamed: #excessSignals) = 1]! !!SemaphoreTest methodsFor: 'testing' stamp: 'ar 10/5/2007 18:06'!testSemaInCriticalWait	"self run: #testSemaInCriticalWait"	"This tests whether a semaphore that has entered the wait in Semaphore>>critical:	leaves it without signaling the associated semaphore."	| s p |	s := Semaphore new.	p := [s critical:[]] fork.	Processor yield.	self assert:[p suspendingList == s].	p terminate.	self assert:[(s instVarNamed: #excessSignals) = 0]! !"Kernel"!"KernelTests"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.337.mcz') load.ScriptLoader new updateFrom7071.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 2/14/2008 22:20'!script95	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.152.mczKernelTests-sd.51.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.116.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.22.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.103.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/14/2008 22:21'!updateFrom7072	"self new updateFrom7072"	self script95.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	self flushCaches.			! !"ScriptLoader"!!Semaphore methodsFor: 'communication' stamp: 'ar 8/30/2007 16:15' prior: 29699960!waitTimeoutMSecs: anInteger	"Wait on this semaphore for up to the given number of milliseconds, then timeout. It is up to the sender to determine the difference between the expected event and a timeout."	| d |	d := Delay timeoutSemaphore: self afterMSecs: (anInteger max: 0).	[self wait] ensure:[d unschedule].! !!SystemDictionary class methodsFor: 'initialization' stamp: 'ar 10/5/2007 18:16' prior: 31725227!initialize	"SystemDictionary initialize"	| oldList |	oldList _ StartUpList.	StartUpList _ OrderedCollection new.	"These get processed from the top down..."	#(		Delay		DisplayScreen		Cursor		InputSensor		ProcessorScheduler  "Starts low space watcher and bkground."		FileDirectory  "Enables file stack dump and opens sources."		ShortIntegerArray		ShortRunArray		CrLfFileStream	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].	oldList ifNotNil: [oldList do: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToStartUpList: theClass]]].	#(		ImageSegment		PasteUpMorph		ControlManager	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].			oldList _ ShutDownList.	ShutDownList _ OrderedCollection new.	"These get processed from the bottom up..."	#(		Delay		DisplayScreen		InputSensor		Form		ControlManager		PasteUpMorph		StrikeFont		Color		FileDirectory		SoundPlayer		HttpUrl		Password		PWS		MailDB		ImageSegment	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToShutDownList: cls].	].	oldList ifNotNil: [oldList reverseDo: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToShutDownList: theClass]]].! !!Delay commentStamp: 'stephaneducasse 10/1/2005 21:07' prior: 19691973!I am the main way that a process may pause for some amount of time.  The simplest usage is like this:	(Delay forSeconds: 5) wait.An instance of Delay responds to the message 'wait' by suspending the caller's process for a certain amount of time. The duration of the pause is specified when the Delay is created with the message forMilliseconds: or forSeconds:. A Delay can be used again when the current wait has finished. For example, a clock process might repeatedly wait on a one-second Delay.The maximum delay is (SmallInteger maxVal // 2) milliseconds, or about six days. A delay in progress when an image snapshot is saved is resumed when the snapshot is re-started. Delays work across millisecond clock roll-overs.For a more complex example, see  #testDelayOf:for:rect: .A word of advice:This is THE highest priority code which is run in Squeak, in other words it is time-critical. The speed of this code is critical for accurate responses, it is critical for network services, it affects every last part of the system.In short: Don't fix it if it ain't broken!! This code isn't supposed to be beautiful, it's supposed to be fast!! The reason for duplicating code is to make it fast. The reason for not using ifNil:[]ifNotNil:[] is that the compiler may not inline those. Since the effect of changes are VERY hard to predict it is best to leave things as they are for now unless there is an actual need to change anything!!Delay class methodsFor: 'timer process' stamp: 'ar 8/24/2007 12:36'!handleTimerEvent	"Handle a timer event; which can be either:		- a schedule request (ScheduledDelay notNil)		- an unschedule request (FinishedDelay notNil)		- a timer signal (not explicitly specified)	We check for timer expiry every time we get a signal."	| nowTick nextTick |	"Wait until there is work to do."	TimingSemaphore wait.	"Process any schedule requests"	ScheduledDelay ifNotNil:[		"Schedule the given delay"		self scheduleDelay: ScheduledDelay.		ScheduledDelay := nil.	].	"Process any unschedule requests"	FinishedDelay ifNotNil:[		self unscheduleDelay: FinishedDelay.		FinishedDelay := nil.	].	"Check for clock wrap-around."	nowTick := Time millisecondClockValue.	nowTick < ActiveDelayStartTime ifTrue: [		"clock wrapped"		self saveResumptionTimes.		self restoreResumptionTimes.	].	ActiveDelayStartTime := nowTick.	"Signal any expired delays"	[ActiveDelay notNil and:[nowTick >= ActiveDelay resumptionTime]] whileTrue:[		ActiveDelay signalWaitingProcess.		SuspendedDelays isEmpty 			ifTrue: [ActiveDelay := nil] 			ifFalse:[ActiveDelay := SuspendedDelays removeFirst].	].	"And signal when the next request is due. We sleep at most 1sec here	as a soft busy-loop so that we don't accidentally miss signals."	nextTick := nowTick + 1000.	ActiveDelay ifNotNil:[nextTick := nextTick min: ActiveDelay resumptionTime].	nextTick := nextTick min: SmallInteger maxVal.	"Since we have processed all outstanding requests, reset the timing semaphore so	that only new work will wake us up again. Do this RIGHT BEFORE setting the next	wakeup call from the VM because it is only signaled once so we mustn't miss it."	TimingSemaphore initSignals.	Delay primSignal: TimingSemaphore atMilliseconds: nextTick.	"This last test is necessary for the obscure case that the msecs clock rolls over	after nowTick has been computed (unlikely but not impossible). In this case we'd	wait for MillisecondClockMask msecs (roughly six days) or until another delay gets	scheduled (which may not be any time soon). In any case, since handling the	condition is easy, let's just deal with it"	Time millisecondClockValue < nowTick ifTrue:[TimingSemaphore signal]. "retry"! !!Delay class methodsFor: 'class initialization' stamp: 'ar 7/11/2007 18:16'!initialize	"Delay initialize"	self startTimerEventLoop.! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/11/2007 09:04'!runTimerEventLoop	"Run the timer event loop."	[		[RunTimerEventLoop] whileTrue: [self handleTimerEvent]	] on: Error do:[:ex|		"Clear out the process so it does't get killed"		TimerEventLoop := nil.		"Launch the old-style interrupt watcher"		self startTimerInterruptWatcher.		"And pass the exception on"		ex pass.	].! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 22:32'!scheduleDelay: aDelay	"Private. Schedule this Delay."	aDelay beingWaitedOn: true.	ActiveDelay ifNil:[		ActiveDelay := aDelay	] ifNotNil:[		aDelay resumptionTime < ActiveDelay resumptionTime ifTrue:[			SuspendedDelays add: ActiveDelay.			ActiveDelay := aDelay.		] ifFalse: [SuspendedDelays add: aDelay].	].! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/11/2007 10:18'!startTimerEventLoop	"Start the timer event loop"	"Delay startTimerEventLoop"	self stopTimerEventLoop.	self stopTimerInterruptWatcher.	AccessProtect := Semaphore forMutualExclusion.	ActiveDelayStartTime := Time millisecondClockValue.	SuspendedDelays := 		Heap withAll: (SuspendedDelays ifNil:[#()])			sortBlock: [:d1 :d2 | d1 resumptionTime <= d2 resumptionTime].	TimingSemaphore := Semaphore new.	RunTimerEventLoop := true.	TimerEventLoop := [self runTimerEventLoop] newProcess.	TimerEventLoop priority: Processor timingPriority.	TimerEventLoop resume.	TimingSemaphore signal. "get going"! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 22:32' prior: 19703732!startTimerInterruptWatcher	"Reset the class variables that keep track of active Delays and re-start the timer interrupt watcher process. Any currently scheduled delays are forgotten."	"Delay startTimerInterruptWatcher"	| p |	self stopTimerEventLoop.	self stopTimerInterruptWatcher.	TimingSemaphore := Semaphore new.	AccessProtect := Semaphore forMutualExclusion.	SuspendedDelays := 		SortedCollection sortBlock: 			[:d1 :d2 | d1 resumptionTime <= d2 resumptionTime].	ActiveDelay := nil.	p := [self timerInterruptWatcher] newProcess.	p priority: Processor timingPriority.	p resume.! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 21:26'!stopTimerEventLoop	"Stop the timer event loop"	RunTimerEventLoop := false.	TimingSemaphore signal.	TimerEventLoop := nil.! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 21:32'!stopTimerInterruptWatcher	"Reset the class variables that keep track of active Delays and re-start the timer interrupt watcher process. Any currently scheduled delays are forgotten."	"Delay startTimerInterruptWatcher"	self primSignal: nil atMilliseconds: 0.	TimingSemaphore ifNotNil:[TimingSemaphore terminateProcess].! !!Delay class methodsFor: 'timer process' stamp: 'ar 8/30/2007 19:59'!unscheduleDelay: aDelay	"Private. Unschedule this Delay."	aDelay beingWaitedOn ifFalse:[^self].	ActiveDelay == aDelay ifTrue: [		SuspendedDelays isEmpty ifTrue:[			ActiveDelay := nil.		] ifFalse: [			ActiveDelay := SuspendedDelays removeFirst.		]	] ifFalse:[		SuspendedDelays remove: aDelay ifAbsent: [].	].	aDelay beingWaitedOn: false.! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:24' prior: 19694398!activate	"Private!! Make the receiver the Delay to be awoken when the next timer interrupt occurs. This method should only be called from a block protected by the AccessProtect semaphore."	TimerEventLoop ifNotNil:[^nil].	ActiveDelay := self.	ActiveDelayStartTime := Time millisecondClockValue.	ActiveDelayStartTime > resumptionTime ifTrue:[		ActiveDelay signalWaitingProcess.		SuspendedDelays isEmpty ifTrue:[			ActiveDelay := nil.			ActiveDelayStartTime := nil.		] ifFalse:[SuspendedDelays removeFirst activate].	] ifFalse:[		TimingSemaphore initSignals.		Delay primSignal: TimingSemaphore atMilliseconds: resumptionTime.	].! !!Delay methodsFor: 'public' stamp: 'ar 7/10/2007 21:49'!beingWaitedOn	"Answer whether this delay is currently scheduled, e.g., being waited on"	^beingWaitedOn! !!Delay methodsFor: 'public' stamp: 'ar 7/10/2007 21:49'!beingWaitedOn: aBool	"Indicate whether this delay is currently scheduled, e.g., being waited on"	beingWaitedOn := aBool! !!Delay methodsFor: 'public' stamp: 'ar 7/10/2007 20:56'!delayDuration	^delayDuration! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:55' prior: 19695927!schedule	"Private!! Schedule this Delay, but return immediately rather than waiting. The receiver's semaphore will be signalled when its delay duration has elapsed."	beingWaitedOn ifTrue: [self error: 'This Delay has already been scheduled.'].	TimerEventLoop ifNotNil:[^self scheduleEvent].	AccessProtect critical: [		beingWaitedOn := true.		resumptionTime := Time millisecondClockValue + delayDuration.		ActiveDelay == nil			ifTrue: [self activate]			ifFalse: [				resumptionTime < ActiveDelay resumptionTime					ifTrue: [						SuspendedDelays add: ActiveDelay.						self activate]					ifFalse: [SuspendedDelays add: self]]].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 22:33'!scheduleEvent	"Schedule this delay"	resumptionTime := Time millisecondClockValue + delayDuration.	AccessProtect critical:[		ScheduledDelay := self.		TimingSemaphore signal.	].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:55' prior: 19693580!unschedule	"Unschedule this Delay. Do nothing if it wasn't scheduled."	| done |	TimerEventLoop ifNotNil:[^self unscheduleEvent].	AccessProtect critical: [		done := false.		[done] whileFalse:			[SuspendedDelays remove: self ifAbsent: [done := true]].		ActiveDelay == self ifTrue: [			SuspendedDelays isEmpty				ifTrue: [					ActiveDelay := nil.					ActiveDelayStartTime := nil]				ifFalse: [					SuspendedDelays removeFirst activate]]].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:56'!unscheduleEvent	AccessProtect critical:[		FinishedDelay := self.		TimingSemaphore signal.	].! !!Delay methodsFor: 'delaying' stamp: 'ar 8/30/2007 19:32' prior: 19694039!wait	"Schedule this Delay, then wait on its semaphore. The current process will be suspended for the amount of time specified when this Delay was created."	self schedule.	[delaySemaphore wait] ifCurtailed:[self unschedule].! !"Kernel"!"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.338.mcz') load.ScriptLoader new updateFrom7072.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 2/17/2008 21:19'!script96	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.152.mczKernelTests-sd.51.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.116.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.22.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.104.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/17/2008 21:19'!updateFrom7073	"self new updateFrom7073"	self script96.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	self flushCaches.			! !"ScriptLoader"!!SystemDictionary class methodsFor: 'initialization' stamp: 'mu 2/11/2008 10:54' prior: 33867991!initialize	"SystemDictionary initialize"	| oldList |	oldList _ StartUpList.	StartUpList _ OrderedCollection new.	"These get processed from the top down..."	#(		Delay		DisplayScreen		Cursor		InputSensor		ProcessorScheduler  "Starts low space watcher and bkground."		LanguageEnvironment		FileDirectory  "Enables file stack dump and opens sources."		NaturalLanguageTranslator		ShortIntegerArray		ShortRunArray		CrLfFileStream	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].	oldList ifNotNil: [oldList do: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToStartUpList: theClass]]].	#(		ImageSegment		PasteUpMorph		ControlManager	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].			oldList _ ShutDownList.	ShutDownList _ OrderedCollection new.	"These get processed from the bottom up..."	#(		Delay		DisplayScreen		InputSensor		Form		ControlManager		PasteUpMorph		StrikeFont		Color		FileDirectory		SoundPlayer		HttpUrl		Password		PWS		MailDB		ImageSegment	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToShutDownList: cls].	].	oldList ifNotNil: [oldList reverseDo: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToShutDownList: theClass]]].! !"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.339.mcz') load.ScriptLoader new updateFrom7073.!----End fileIn of a stream----!'From Squeak3.9.1a of ''14 Feb 2008'' [latest update: #7074] on 1 March 2008 at 6:13:05 pm'!"Change Set:		7075-FixingRefToImageBrowserDate:			1 March 2008Author:			stephane ducasseThere was a ref to OB in the registered commands of the world menu."!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."TheWorldMenu unregisterOpenCommand: 'Image Browser'.SystemVersion newVersion: 'Squeak3.9.1'.!----End fileIn of a stream----!----SNAPSHOT----an Array(2 March 2008 6:56:27 pm) Squeak3.9.1-final-7075.image priorSource: 105817!----SNAPSHOT----an Array(2 March 2008 6:57:31 pm) Squeak3.9.1-final-7075.image priorSource: 329967!----QUIT/NOSAVE----an Array(2 March 2008 6:57:35 pm) Squeak3.9.1-final-7075.image priorSource: 330068!