'From Squeak 1.31 of Feb 4, 1998 on 23 March 1998 at 11:06:46 pm'!"Change Set:		Finalization-FixedFieldsDate:			23 March 1998Author:			Andreas RaabThis change set contains the necessary adjustments to keep fixed fields (i.e. inst vars) in weak classes non-weak. As a side effect none of the weak classes can now be compact."!!Behavior methodsFor: 'private' stamp: 'ar 3/23/98 22:55'!becomeCompact	| cct index |	self isWeak ifTrue:[^self halt:'You must not make a weak class compact'].	cct _ Smalltalk compactClassesArray.	(self indexIfCompact > 0 or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	index _ cct indexOf: nil		ifAbsent: [^ self halt: 'compact class table is full'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format _ format + (index bitShift: 11).	"Make up new instances and become old ones into them"	self updateInstancesFrom: self.	"Purge any old instances"	Smalltalk garbageCollect.! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'ar 3/23/98 22:46'!startObj	"Start tracing the object 'child' and answer the next action. The object may be anywhere in the middle of being swept itself. See comment in markAndTrace for explanation of tracer state variables."	| oop header lastFieldOffset |	oop _ child.	oop < youngStart ifTrue: [		"old object; skip it"		 field _ oop.		^ Upward	].	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [		"unmarked; mark and trace"		"<-- Finalization support: Do not trace the object's indexed fields if it's a weak class -->"		(self isWeak: oop) ifTrue:[			"Set lastFieldOffset before the weak fields in the receiver"			lastFieldOffset := (self nonWeakFieldsOf: oop) << 2.		] ifFalse:[			"Do it the usual way"			lastFieldOffset _ self lastPointerOf: oop.		].		header _ header bitAnd: AllButTypeMask.		header _ (header bitOr: MarkBit) bitOr: HeaderTypeGC.		self longAt: oop put: header.		field _ oop + lastFieldOffset.		^ StartField	"trace its fields and class"	] ifFalse: [		"already marked; skip it"		field _ oop.		^ Upward	].!]style[(8 428 336 278)f1b,f1,f1cred;,f1! !!ObjectMemory methodsFor: 'finalization' stamp: 'ar 3/23/98 22:39'!finalizeReference: oop	"During sweep phase we have encountered a weak reference. Check if	its object has gone away (or is about to) and if so, signal a semaphore."	| weakOop oopGone chunk firstField lastField |	"Do *not* inline this in sweepPhase - it is quite an unlikely case to run into a weak reference"	self inline: false.	firstField := BaseHeaderSize + ((self nonWeakFieldsOf: oop) << 2).	lastField := self lastPointerOf: oop.	firstField to: lastField by: 4 do:[:i|		weakOop := self longAt: oop+i.		((weakOop == nilObj) or:[(self isIntegerObject: weakOop)]) ifFalse:[			"Check if the object is being collected.			If the weak reference points 				* backward: check if the weakOops chunk is free				* forward: check if the weakOoop has been marked by GC"			weakOop < oop 				ifTrue:[	chunk _ self chunkFromOop: weakOop.						oopGone _ ((self longAt: chunk) bitAnd: TypeMask) = HeaderTypeFree]				ifFalse:[oopGone _ ((self baseHeader: weakOop) bitAnd: MarkBit) = 0].			oopGone ifTrue:[					"Store nil in the pointer and signal the interpreter"					self longAt: oop+i put: nilObj.					self signalFinalization: oop].		].	].! !!DynamicInterpreter methodsFor: 'object format' stamp: 'ar 3/23/98 22:52'!nonWeakFieldsOf: oop	"Return the number of non-weak fields in oop (i.e. the number of fixed fields).	Note: The following is copied from fixedFieldsOf:format:length: since we do know	the format of the oop (e.g. format = 4) and thus don't need the length."	| class classFormat |	self inline: false. "No need to inline - we won't call this often"	(self isWeak: oop) ifFalse:[self error:'Called fixedFieldsOfWeak: with a non-weak oop'].	"fmt = 3 or 4: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!Interpreter methodsFor: 'object format' stamp: 'ar 3/23/98 22:52'!nonWeakFieldsOf: oop	"Return the number of non-weak fields in oop (i.e. the number of fixed fields).	Note: The following is copied from fixedFieldsOf:format:length: since we do know	the format of the oop (e.g. format = 4) and thus don't need the length."	| class classFormat |	self inline: false. "No need to inline - we won't call this often"	(self isWeak: oop) ifFalse:[self error:'Called fixedFieldsOfWeak: with a non-weak oop'].	"fmt = 3 or 4: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !