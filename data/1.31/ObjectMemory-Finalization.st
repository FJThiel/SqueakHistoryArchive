'From Squeak 1.31 of Feb 4, 1998 on 21 March 1998 at 11:17:12 pm'!"Change Set:		ObjectMemory-FinalizationDate:			21 March 1998Author:			Andreas RaabThis change set contains the finalization framework in ObjectMemory.Two methods are not included in this change set:	* ObjectMemory>>isWeak: oop		Which has to return if a given oop contains only weak references.		This method is in the Interpreter-WeakClasses change set.	* Interpreter|DynamicInterpreter>>signalFinalization: weakRefOop		Saying the interpreter that an object in weakRefOop has been destroyed. The interpreter should signal any associated semaphore or record the information for later use. The interpreter must keep care of the fact that this method is called during GC		This method is in the Interpreter-Finalization change set."!!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'ar 3/21/98 23:07'!startObj	"Start tracing the object 'child' and answer the next action. The object may be anywhere in the middle of being swept itself. See comment in markAndTrace for explanation of tracer state variables."	| oop header lastFieldOffset |	oop _ child.	oop < youngStart ifTrue: [		"old object; skip it"		 field _ oop.		^ Upward	].	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [		"unmarked; mark and trace"		"<-- Finalization support: Do not trace the object if it's a weak class -->"		(self isWeak: oop) ifTrue:[			"Mark the object but do not trash header information"		
	self longAt: oop put: (header bitOr: MarkBit).			field := oop.			^Upward].		header _ header bitAnd: AllButTypeMask.		header _ (header bitOr: MarkBit) bitOr: HeaderTypeGC.		self longAt: oop put: header.		lastFieldOffset _ self lastPointerOf: oop.		field _ oop + lastFieldOffset.		^ StartField	"trace its fields and class"	] ifFalse: [		"already marked; skip it"		field _ oop.		^ Upward	].!]style[(8 428 247 323)f1b,f1,f1cred;,f1! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'ar 3/21/98 23:08'!sweepPhase	"Sweep memory from youngStart through the end of memory. Free all inaccessible objects and coalesce adjacent free chunks. Clear the mark bits of accessible objects. Compute the starting point for the first pass of incremental compaction (compStart). Return the number of surviving objects."	"Details: Each time a non-free object is encountered, decrement the number of available forward table entries. If all entries are spoken for (i.e., entriesAvailable reaches zero), set compStart to the last free chunk before that object or, if there is no free chunk before the given object, the first free chunk after it. Thus, at the end of the sweep phase, compStart through compEnd spans the highest collection of non-free objects that can be accomodated by the forwarding table. This information is used by the first pass of incremental compaction to ensure that space is initially freed at the end of memory. Note that there should always be at least one free chunk--the one at the end of the heap."	| entriesAvailable survivors freeChunk firstFree oop oopHeader oopHeaderType hdrBytes oopSize freeChunkSize |	self inline: false.	entriesAvailable _ self fwdTableInit.	survivors _ 0.	freeChunk _ nil.	firstFree _ nil.  "will be updated later"	oop _ self oopFromChunk: youngStart.	[oop < endOfMemory] whileTrue: [		"get oop's header, header type, size, and header size"		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeShort) ifTrue: [			oopSize _ oopHeader bitAnd: 16rFC.			hdrBytes _ 0.		] ifFalse: [			(oopHeaderType = HeaderTypeClass) ifTrue: [				oopSize _ oopHeader bitAnd: 16rFC.				hdrBytes _ 4.			] ifFalse: [				(oopHeaderType = HeaderTypeSizeAndClass) ifTrue: [					oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask.					hdrBytes _ 8.				] ifFalse: [  "free chunk"					oopSize _ oopHeader bitAnd: FreeSizeMask.					hdrBytes _ 0.				].			].		].		(oopHeader bitAnd: MarkBit) = 0 ifTrue: [			"object is not marked; free it"			"<-- Finalization support: We need to mark each oop chunk as free -->"			self longAt: oop - hdrBytes put: HeaderTypeFree.			freeChunk ~= nil ifTrue: [				"enlarge current free chunk to include this oop"				freeChunkSize _ freeChunkSize + oopSize + hdrBytes.			] ifFalse: [				"start a new free chunk"				freeChunk _ oop - hdrBytes.  "chunk may start 4 or 8 bytes before oop"				freeChunkSize _ oopSize + (oop - freeChunk).  "adjust size for possible extra header bytes"				firstFree = nil ifTrue: [ firstFree _ freeChunk ].			].		] ifFalse: [			"object is marked; clear its mark bit and possibly adjust the compaction start"			self longAt: oop put: (oopHeader bitAnd: AllButMarkBit).			"<-- Finalization support: Check if we're running about a weak class -->"			(self isWeak: oop) ifTrue:[				self finalizeReference: oop.			].			entriesAvailable > 0 ifTrue: [				entriesAvailable _ entriesAvailable - 1.			] ifFalse: [				"start compaction at the last free chunk before this object"				firstFree _ freeChunk.			].			freeChunk ~= nil ifTrue: [				"record the size of the last free chunk"				self longAt: freeChunk					    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).			].			freeChunk _ nil.			survivors _ survivors + 1.		].		oop _ self oopFromChunk: (oop + oopSize).  "get next oop"	].	freeChunk ~= nil ifTrue: [		"record size of final free chunk"		self longAt: freeChunk			    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).	].	oop = endOfMemory		ifFalse: [ self error: 'sweep failed to find exact end of memory' ].	firstFree = nil		ifTrue: [ self error: 'expected to find at least one free object' ]		ifFalse: [ compStart _ firstFree ].	^ survivors!]style[(10 2027 126 574 147 894)f1b,f1,f1cred;,f1,f1cred;,f1! !!ObjectMemory methodsFor: 'finalization' stamp: 'ar 3/21/98 23:14'!aFinalizationComment	"This finalization scheme assumes to have weak classes in which the fields are not traced during the mark phase of a GC. This means, if an object is referenced only by any instances of weak classes it can be collected. In turn, we need to find out if an object referenced by a weak class is actually being collected because we have to invalidate the weak object pointer and to signal that the object has gone.	How do we know that an object referenced by a weak class is being collected? Well,  this is based on two observations. First, objects will not change their relative locations in memory, meaning that if object A is created BEFORE object B it will always have a physical memory address which is LESS than B. Secondly, GC always works from a given starting address (youngStart during incremental GC; startOfMemory during fullGC) up to end of memory. If we can somehow garantuee that the weak reference is created after the object it points to we can easily implement the following simple scheme:	1) Mark phase		Do not trace the fields of any instances of weak classes.	2) Sweep phase:		a) Explicitly mark all free objects.		b) 	If a weak reference is encountered check the the object it points to. 			If the object is marked as free than we know that this weak reference's object is gone.			Signal that it is gone.	There is, however, one small problem with this approach. We cannot always garantuee that WeakReferences point backwards such as in the following piece of code:		| o1 o2 w1 w2 |		o1 _ Object new.		w1 _ WeakReference on: o1.		o2 _ Object new.		w2 _ WeakReference on: o2.		o1 become: o2.The become: operation makes w1 point to o2 and because o2 has been created AFTER w1 the object reference in w1 points forward. Why might this be a problem? Well, if the GC would start after the weak reference AND free the object then the weak reference would simply point to an invalid memory location (since we've not been checking the weak reference during sweep phase).	Fortunately, this can not happen in the current ObjectMemory implementation. Why? Well, the only GC not starting at the beginning of the memory is incremental GC. Incremental GC however is only executed in so-called youngSpace. If both, the weak reference AND the object it points to reside in youngSpace then we can still check the weak reference. If however, the weak reference is not in youngSpace but the object is, then the object is itself a root in young space and will be marked by the GC even if it is only referenced by the WeakReference.	In the end, we just need a little adjustment in step 2b) of the above procedure which looks as follows:		If the weak reference points 			* backwards: check if the object header is marked free			* forwards: check if the object has been marked in markPhase.	Note that a number of finalizations will only be executed during a fullGC. This happens if either the WeakReference or the object reside outside youngSpace. So, if you must garantuee that some object has been finalized you definitely need to do a fullGC.ar 3/20/98 17:20"	self error:'Comment only'.! !!ObjectMemory methodsFor: 'finalization' stamp: 'ar 3/21/98 23:15'!finalizeReference: oop	"During sweep phase we have encountered a weak reference. Check if	its object has gone away (or is about to) and if so, signal a semaphore."	| weakOop oopGone chunk lastField |	"Do *not* inline this in sweepPhase - it is quite an unlikely case to run into a weak reference"	self inline: false.	lastField := self lastPointerOf: oop.	BaseHeaderSize to: lastField by: 4 do:[:i|		weakOop := self longAt: oop+i.		((weakOop == nilObj) or:[(self isIntegerObject: weakOop)]) ifFalse:[			"Check if the object is being collected.			If the weak reference points 				* backward: check if the weakOops chunk is free				* forward: check if the weakOoop has been marked by GC"			weakOop < oop 				ifTrue:[	chunk _ self chunkFromOop: weakOop.						oopGone _ ((self longAt: chunk) bitAnd: TypeMask) = HeaderTypeFree]				ifFalse:[oopGone _ ((self baseHeader: weakOop) bitAnd: MarkBit) = 0].			oopGone ifTrue:[					"Store nil in the pointer and signal the interpreter"					self longAt: oop+i put: nilObj.					self signalFinalization: oop].		].	].! !