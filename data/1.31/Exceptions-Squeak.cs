'From Squeak 1.31 of Feb 4, 1998 on 8 April 1998 at 11:26:19 pm'!"Change Set:		Exceptions-SqueakDate:			8 April 1998Author:			Andreas Raab (ar) raab@isg.cs.uni-magdeburg.deThis change set contains numerous modifications of methods raising errors. Rather than opening a debugger, an exception is raised which can be handled accordingly.""First make sure that the image handles broken sender chains correctly"TerminationHandler crashVM ifFalse:[self error:'Build a new VM first'].!!Object methodsFor: 'error handling' stamp: 'ar 4/2/98 00:34'!caseError	"Report an error from an in-line or explicit case statement."	Error		signal: 'Case not found, and no otherwise clause'		with: #caseError! !!Object methodsFor: 'error handling' stamp: 'ar 3/31/98 19:30'!doesNotUnderstand: aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message (typically sent from the machine when a message is sent to the receiver and no method is defined for that selector)."	"Unless the receiver has an error handler defined for the active process, report to the user that the receiver does not understand the argument, aMessage, as a message."	"Testing: (3 activeProcess)"	"Check if somebody wants to handle doesNotUnderstand: before defining accessors"	MessageNotUnderstood new isNested ifTrue:[		MessageNotUnderstood receiver: self message: aMessage.		^aMessage sentTo: self.	].	"Put the following into a MessageNotUnderstood handler to avoid recursion"	[(Preferences autoAccessors and: [self tryToDefineVariableAccess: aMessage])		ifTrue: [^ aMessage sentTo: self].	]	on: MessageNotUnderstood		do:[:ex| ex return].	"Now really raise the exception"	MessageNotUnderstood receiver: self message: aMessage.	^aMessage sentTo: self.! !!Object methodsFor: 'error handling' stamp: 'ar 4/5/98 17:42'!error: aString 	"Signal an error condition"	^Error 		signal: aString		with: nil		from: self! !!Object methodsFor: 'error handling' stamp: 'ar 3/31/98 19:31'!halt	"This is the typical message to use for inserting breakpoints during 	debugging. It behaves like halt:, but does not call on halt: in order to 	avoid putting this message on the stack. Halt is especially useful when 	the breakpoint message is an arbitrary one."	ResumableError 		signal:'Halt encountered' 		with: #halt.	"nil halt."! !!Object methodsFor: 'error handling' stamp: 'ar 3/31/98 19:45'!halt: aString 	"This is the typical message to use for inserting breakpoints during 	debugging. It creates and schedules a Notifier with the argument, 	aString, as the label."	ResumableError 		signal: aString 		with: #halt.	"nil halt: 'Test of halt:.'."! !!Object methodsFor: 'error handling' stamp: 'ar 4/8/98 00:03'!notify: aString 	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed.	Use Warning - this can be caught by exception handling. 4/8/98 ar"	Warning 		signal: aString		with: nil		from: self	"nil notify: 'confirmation message'"! !!Object methodsFor: 'error handling' stamp: 'ar 4/5/98 17:43'!primitiveFailed	"Announce that a primitive has failed and there is no appropriate 	Smalltalk code to run."	Error 		signal:'a primitive has failed' 		with: #primitiveFailed		from: self! !!Object methodsFor: 'error handling' stamp: 'ar 4/5/98 17:43'!shouldNotImplement	"Announce that, although the receiver inherits this message, it should 	not implement it."	Error 		signal: 'This message is not appropriate for this object' 		with: #shouldNotImplement		from: self! !!Object methodsFor: 'error handling' stamp: 'ar 4/5/98 17:43'!subclassResponsibility	"This message sets up a framework for the behavior of the class' 	subclasses. Announce that the subclass should have implemented this 	message."	Error		signal: 'My subclass should have overridden one of my messages.'		with: #subclassResponsibility		from: self! !!Object methodsFor: 'error handling' stamp: 'ar 4/7/98 23:58'!warn: aString 	"Signal an warning condition"	^Warning 		signal: aString		with: nil		from: self! !!Object methodsFor: 'user interface' stamp: 'ar 4/8/98 00:02'!inform: aString	"Display a message for the user to read and then dismiss.  6/9/96 sw"	"Use notification -- if the image runs headless this can be caught. 4/8/98 ar"	Notification		signal: aString		with: nil		from: self! !!Object methodsFor: 'private' stamp: 'ar 4/5/98 17:43'!errorImproperStore	"Create an error notification that an improper store was attempted."	Error		signal: 'Improper store into indexable object'		with: #errorImproperStore		from: self! !!Object methodsFor: 'private' stamp: 'ar 4/5/98 17:43'!errorNonIntegerIndex	"Create an error notification that an improper object was used as an index."	Error		signal: 'only integers should be used as indices'		with: #errorNonIntegerIndex		from: self! !!Object methodsFor: 'private' stamp: 'ar 4/5/98 17:43'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	Error		signal: 'subscript is out of bounds: ' , index printString		with: #errorSubscriptBounds		from: self! !!Object methodsFor: 'private' stamp: 'ar 3/31/98 19:42'!mustBeBoolean	"Catches attempts to test truth of non-Booleans.  This message is sent from the	interpreter."	ResumableError		signal:'NonBoolean receiver--proceed for truth'		with: #mustBeBoolean.	^true! !!Object methodsFor: 'private' stamp: 'ar 4/5/98 20:27'!primitiveError: aString 	"This method is called when the error handling results in a recursion in calling	on error: or halt or halt:."	| context |	(String streamContents:		[:s |		s nextPutAll: '**System Error Handling Failed** '.		s cr; nextPutAll: aString.		context _ thisContext sender sender.		50 timesRepeat: 			[context == nil ifFalse: [s cr; print: (context _ context sender)]].		s cr; nextPutAll: '**Type any character to restart.**'])		displayAt: 0@0.	[Sensor keyboardPressed] whileFalse.	Sensor keyboard.	ScheduledControllers searchForActiveController! !!BlockContext methodsFor: 'evaluating' stamp: 'ar 4/5/98 17:44'!ifError: aBlock	"Evaluate the block represented by the receiver. If an error occurs aBlock is evaluated with the error message and the receiver as parameters. The receiver should not contain an explicit return statement as this would leave an obsolete error handler hanging around."	"Changed to handle otherwise unhandled exceptions only - ar 4/5/98 17:31"	^self 		on: UnhandledException		do:[:ex| ex return: (aBlock value: ex messageText value: ex signaler)].! !!BlockContext methodsFor: 'evaluating' stamp: 'ar 4/5/98 17:44'!value: arg1 ifError: aBlock	"Evaluate the block represented by the receiver. If an error occurs aBlock is evaluated with the error message and the receiver as parameters. The receiver should not contain an explicit return statement as this would leave an obsolete error handler hanging around."	"Changed to handle otherwise unhandled exceptions only - ar 4/5/98 17:31"	^[self value: arg1] 		on: UnhandledException 		do:[:ex| ex return: (aBlock value: ex messageText value: ex signaler)].! !!BlockContext methodsFor: 'system simulation' stamp: 'ar 4/2/98 03:30'!return: value to: sendr 	"Simulate the return of value to sendr."	| ctx |	ctx := self.	[ctx == nil or:[ctx == sendr]] whileFalse:[ctx := ctx sender].	ctx == nil ifTrue:[		^self send: #cannotReturn: to: self with: (Array with: value) super: false].	 ^super return: value to: sendr.! !!Collection methodsFor: 'private' stamp: 'ar 4/5/98 17:41'!errorEmptyCollection	Error		signal: 'this collection is empty'		with: #errorEmptyCollection		from: self! !!Float methodsFor: 'arithmetic' stamp: 'ar 3/31/98 16:55'!/ aNumber 	"Primitive. Answer the result of dividing receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 50>	aNumber = 0		ifTrue: [^ZeroDivide dividend: self]		ifFalse: [^ (aNumber adaptFloat: self) / aNumber adaptToFloat]! !!Object class methodsFor: 'exception-filters' stamp: 'ar 4/7/98 22:47'!caseError	^Error tagged: #caseError! !!Object class methodsFor: 'exception-filters' stamp: 'ar 4/7/98 22:52'!haltError	^ResumableError tagged: #halt! !!Object class methodsFor: 'exception-filters' stamp: 'ar 4/7/98 22:46'!improperStoreError	^Error tagged: #errorImproperStore! !!Object class methodsFor: 'exception-filters' stamp: 'ar 4/7/98 22:52'!mustBeBooleanError	^ResumableError tagged: #mustBeBoolean! !!Object class methodsFor: 'exception-filters' stamp: 'ar 4/7/98 22:47'!nonIntegerIndexError	^Error tagged: #errorNonIntegerIndex! !!Object class methodsFor: 'exception-filters' stamp: 'ar 4/7/98 22:48'!primitiveFailedError	^Error tagged: #primitiveFailed! !!Object class methodsFor: 'exception-filters' stamp: 'ar 4/7/98 22:48'!shouldNotImplementError	^Error tagged: #shouldNotImplement! !!Object class methodsFor: 'exception-filters' stamp: 'ar 4/7/98 22:48'!subclassResponsibilityError	^Error tagged: #subclassResponsibility! !!Object class methodsFor: 'exception-filters' stamp: 'ar 4/7/98 22:48'!subscriptBoundsError	^Error tagged: #errorSubscriptBounds! !!BlockContext class methodsFor: 'exception-filters' stamp: 'ar 4/7/98 23:32'!cannotReturnError	^Error tagged: #cannotReturn! !!Collection class reorganize!('instance creation' fromBraceStack: with: with:with: with:with:with: with:with:with:with:)('private' initialize)('exception-filters' emptyCollectionErrorFilter)!!Collection class methodsFor: 'exception-filters' stamp: 'ar 4/7/98 22:45'!emptyCollectionErrorFilter	^Error tagged: #errorEmptyCollection! !!SmallInteger methodsFor: 'arithmetic' stamp: 'ar 3/31/98 16:55'!/ aNumber 	"Primitive. This primitive (for /) divides the receiver by the argument	and returns the result if the division is exact. Fail if the result is not a	whole integer. Fail if the argument is 0 or is not a SmallInteger. Optional.	No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 10>	aNumber = 0 ifTrue: [^ZeroDivide dividend: self].	(aNumber isMemberOf: SmallInteger)		ifTrue: [^(Fraction numerator: self denominator: aNumber) reduced]		ifFalse: [^super / aNumber]! !