'From Squeak 1.31 of Feb 4, 1998 on 22 March 1998 at 12:22:05 am'!"Change Set:		WeakCollectionsDate:			21 March 1998Author:			Andreas RaabThis change set contains a number of collection classes:	* WeakArray: an array holding only weakly on its elements	* WeakKeyDictionary: a dictionary with weak keys	* WeakValueDictionary: a dictionary with weak values	* WeakRegistry: a registry for the finalization of objects.This change set requires the following change sets	* ObjectMemory-Finalization	* Interpreter-Finalization	* Interpreter-WeakClassesafter which you have to generate a new interpreter and then (while already using the new interpreter) the change set	* Behavior-WeakClassesbefore you even can think of using the weak collections.""Make sure that we really have the appropriate interpreter installed"| tempClass tempObject tempValue |Transcript cr; show:'Checking for Behavior-WeakChanges...'.(Behavior canUnderstand: #isWeak) ifFalse:[	self inform:'You have not installed the Behavior-WeakClasses change set which is required for this change set.'.	self halt.].Transcript show:'ok.'."Now try to instanciate a weak subclass. If the interpreter is NOT the right versionthan it will fill the slots with zero instead of nil."Transcript cr; show:'Creating a sample weak subclass...'.tempClass _	Object 		weakSubclass: #AWeakObjectForTemporaryTestingDuringInstallation		instanceVariableNames: ''		classVariableNames: '' 		poolDictionaries: ''		category: 'Kernel-Objects'.Transcript show:'ok'.Transcript cr; show:'Checking the VM for the right class format...'.tempObject _ tempClass new: 1.tempValue _ tempObject at: 1."For some reason the following doesn't work at the moment"(tempValue == nil) & false ifTrue:[	Transcript show:'ok'.	Transcript cr; show:'Checking for weak object support in the VM...'.	tempObject at: 1 put: Object new.	Smalltalk garbageCollect.	tempValue _ tempObject at: 1.].tempObject _ nil.tempClass removeFromSystem.tempClass _ nil.Smalltalk garbageCollect.tempValue == nil ifFalse:[	Transcript show:'failed'.	"Something went wrong"	tempValue == 0 ifTrue:[		self inform:'Your virtual machine does NOT support the format for weak classes.You must build a new virtual machine first.'.		self halt.	] ifFalse:[		self inform:'Your virtual machine does NOT support weak classes.You must install the ObjectMemory-Finalization change setand build a new virtual machine first'.		self halt.	].].Transcript show:'ok'.SystemOrganization addCategory: 'Collections-Weak' before: 'Collections-Support' asSymbol.!Array weakSubclass: #WeakArray	instanceVariableNames: ''	classVariableNames: 'FinalizationDependents FinalizationLock FinalizationProcess FinalizationSemaphore '	poolDictionaries: ''	category: 'Collections-Weak'!Association subclass: #WeakKeyAssociation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!Dictionary subclass: #WeakKeyDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!Collection subclass: #WeakRegistry	instanceVariableNames: 'valueDictionary accessLock '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!Association subclass: #WeakValueAssociation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!Dictionary subclass: #WeakValueDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 16:26'!actAsExecutor	"Prepare the receiver to act as executor for any resources associated with it"	self breakDependents! !!Object methodsFor: 'finalization' stamp: 'ar 3/20/98 22:19'!executor	"Return an object which can act as executor for finalization of the receiver"	^self shallowCopy actAsExecutor! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 16:27'!finalize	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO garantuee that the resource associated with the receiver hasn't been free'd before so take care that you don't run into trouble - this all may happen with interrupt priority."! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 18:38'!retryWithGC: execBlock until: testBlock	"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try."	| blockValue |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!WeakArray commentStamp: 'ar 3/22/98 00:22' prior: 0!WeakArray is an array which holds only weakly on its elements. This means whenever an object is only referenced by instances of WeakArray it will be garbage collected.If you want to know how this works, have a look at ObjectMemory aFinalizationComment.!]style[(220 33 2)f1,f1LObjectMemory aFinalizationComment;,f1!!WeakArray class methodsFor: 'class initialization' stamp: 'ar 3/21/98 22:27'!initialize	"WeakArray initialize"	FinalizationProcess notNil ifTrue:[FinalizationProcess terminate].	"Do we need to initialize specialObjectsArray?"	Smalltalk specialObjectsArray size < 42 		ifTrue:[Smalltalk recreateSpecialObjectsArray].	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.	FinalizationDependents isNil ifTrue:[		FinalizationDependents := WeakArray new: 100.	].	FinalizationLock := Semaphore forMutualExclusion.	FinalizationProcess := [self finalizationProcess] newProcess.	FinalizationProcess priority: Processor userInterruptPriority.	FinalizationProcess resume.! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 3/21/98 15:15'!addWeakDependent: anObject	| finished index weakDependent |	FinalizationLock critical:[		finished := false.		index := 0.		[index := index + 1.		finished not and:[index <= FinalizationDependents size]] whileTrue:[			weakDependent := FinalizationDependents at: index.			weakDependent isNil ifTrue:[				FinalizationDependents at: index put: anObject.				finished := true.			].		].		finished ifFalse:[			"Grow linearly"			FinalizationDependents := FinalizationDependents, (WeakArray new: 100).			FinalizationDependents at: index put: anObject.		].	].! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 3/21/98 15:18'!removeWeakDependent: anObject	FinalizationLock critical:[		1 to: FinalizationDependents size do:[:i|			((FinalizationDependents at: i) == anObject) ifTrue:[				FinalizationDependents at: i put: nil.			].		].	].! !!WeakArray class methodsFor: 'private' stamp: 'ar 3/21/98 15:09'!finalizationProcess	[true] whileTrue:[		FinalizationSemaphore wait.		FinalizationLock critical:[			FinalizationDependents do:[:weakDependent|				weakDependent isNil 					ifFalse:[weakDependent finalizeValues].			].		].	].! !!WeakKeyAssociation commentStamp: 'ar 3/22/98 00:22' prior: 0!I am an association holding only weakly on my key.!!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:54'!key	^key isNil		ifTrue:[nil]		ifFalse:[key at: 1]! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:45'!key: aKey	key := WeakArray with: aKey! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:44'!key: aKey value: anObject	key := WeakArray with: key.	value := anObject.! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:45'!< aLookupKey 	"Refer to the comment in Magnitude|<."	^self key < aLookupKey key! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!= aLookupKey	self species = aLookupKey species		ifTrue: [^self key = aLookupKey key]		ifFalse: [^false]! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!hash	"Hash is reimplemented because = is implemented."	^self key hash! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^self key hashMappedBy: map! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:47'!identityHashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^ self key identityHashMappedBy: map! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:53'!printOn: aStream	self key printOn: aStream.	aStream nextPutAll: '->'.	self value printOn: aStream! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:53'!storeOn: aStream	aStream 		nextPut: $(;		nextPutAll: self class name;		nextPutAll:' key: '.	self key storeOn: aStream.	aStream nextPutAll: ' value: '.	self value storeOn: aStream.	aStream nextPut: $)! !!WeakKeyDictionary commentStamp: 'ar 3/22/98 00:22' prior: 0!I am a dictionary holding only weakly on my keys. This is a bit dangerous since at any time my keys can go away. Clients are responsible to register my instances by WeakArray such that the appropriate actions can be taken upon loss of any keys.See WeakRegistry for an example of use.!]style[(250 12 24)f1,f1LWeakRegistry Definition;,f1!!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:02'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	key isNil ifTrue:[^anObject].	index _ self findElementOrNil: key.	element _ array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakKeyAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!WeakKeyDictionary methodsFor: 'adding' stamp: 'ar 3/21/98 16:00'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ar 3/21/98 16:15'!finalizeValues	"default action is to re-hash the receiver and to remove nil-keys"	self rehash.	self removeKey: nil ifAbsent:[].! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ar 3/22/98 00:21'!rehash	"Overriden to copy the size also - we may have lost any number of elements"	| newSelf |	newSelf := self species new: self size.	self associationsDo:[:each| newSelf noCheckAdd: each].	array := newSelf array.	tally := newSelf size.! !!WeakRegistry commentStamp: 'ar 3/22/98 00:22' prior: 0!I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.See also:	Object executor	Object actAsExecutor	Object finalize!]style[(261 15 2 20 2 15 1)f1,f1LObject executor;,f1,f1LObject actAsExecutor;,f1,f1LObject finalize;,f1!!WeakRegistry methodsFor: 'initialize' stamp: 'ar 3/21/98 16:08'!initialize: n	valueDictionary := WeakKeyDictionary new: n.	accessLock := Semaphore forMutualExclusion.! !!WeakRegistry methodsFor: 'accessing' stamp: 'ar 3/21/98 16:33'!size	^self protected:[		valueDictionary size	].! !!WeakRegistry methodsFor: 'accessing' stamp: 'ar 3/20/98 19:31'!species	^Set! !!WeakRegistry methodsFor: 'adding' stamp: 'ar 3/21/98 16:33'!add: anObject	"Add anObject to the receiver. Store the object as well as the associated executor."	| executor |	executor := anObject executor.	self protected:[		valueDictionary at: anObject put: executor.	].	^anObject! !!WeakRegistry methodsFor: 'removing' stamp: 'ar 3/21/98 21:12'!remove: oldObject ifAbsent: exceptionBlock	"Remove oldObject as one of the receiver's elements."	| removedObject |	oldObject isNil ifTrue:[^oldObject].	self protected:[		removedObject := valueDictionary removeKey: oldObject ifAbsent:[nil].	].	^removedObject isNil		ifTrue:[exceptionBlock value]		ifFalse:[removedObject].! !!WeakRegistry methodsFor: 'enumerating' stamp: 'ar 3/21/98 18:36'!do: aBlock	^self protected:[		valueDictionary keysDo: aBlock.	].! !!WeakRegistry methodsFor: 'finalization' stamp: 'ar 3/22/98 00:19'!finalizeValues	"Some of our elements may have gone away. Look for those and activate the associated executors."	| finiObjects |	finiObjects := nil.	"First collect the objects."	self protected:[		valueDictionary associationsDo:[:assoc|			assoc key isNil ifTrue:[				finiObjects isNil 					ifTrue:[finiObjects := OrderedCollection with: assoc value]					ifFalse:[finiObjects add: assoc value]]		].		finiObjects isNil ifFalse:[valueDictionary finalizeValues].	].	"Then do the finalization"	finiObjects isNil ifTrue:[^self].	finiObjects do:[:each| each finalize].! !!WeakRegistry methodsFor: 'private' stamp: 'ar 3/21/98 16:35'!protected: aBlock	"Execute aBlock protected by the accessLock"	^accessLock isNil		ifTrue:[aBlock value]		ifFalse:[accessLock critical: aBlock]! !!WeakRegistry commentStamp: 'ar 3/22/98 00:22' prior: 0!I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.See also:	Object executor	Object actAsExecutor	Object finalize!]style[(261 15 2 20 2 15 1)f1,f1LObject executor;,f1,f1LObject actAsExecutor;,f1,f1LObject finalize;,f1!!WeakRegistry class methodsFor: 'instance creation' stamp: 'ar 3/21/98 15:32'!new	^self new: 5! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'ar 3/21/98 15:33'!new: n	| registry |	registry := super new initialize: n.	WeakArray addWeakDependent: registry.	^registry! !!WeakValueAssociation commentStamp: 'ar 3/22/98 00:22' prior: 0!I am an association holding only weakly on my value.!!WeakValueAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:53'!key: aKey value: anObject 	"Store the arguments as the variables of the receiver."	key _ aKey.	value _ WeakArray with: anObject! !!WeakValueAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:55'!value	^value isNil		ifTrue:[nil]		ifFalse:[value at: 1]! !!WeakValueAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:54'!value: anObject 	"Store the argument, anObject, as the value of the receiver."	value _ WeakArray with: anObject! !!WeakValueAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:54'!printOn: aStream	self key printOn: aStream.	aStream nextPutAll: '->'.	self value printOn: aStream! !!WeakValueAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:54'!storeOn: aStream	aStream 		nextPut: $(;		nextPutAll: self class name;		nextPutAll:' key: '.	self key storeOn: aStream.	aStream nextPutAll: ' value: '.	self value storeOn: aStream.	aStream nextPut: $)! !!WeakValueDictionary commentStamp: 'ar 3/22/98 00:22' prior: 0!I am a dictionary holding only weakly on my values. Clients may expect to get a nil value for any object they request.!!WeakValueDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:01'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	index _ self findElementOrNil: key.	element _ array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakValueAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!WeakValueDictionary methodsFor: 'adding' stamp: 'ar 3/21/98 16:02'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !WeakArray initialize!