'From Squeak3.9alpha of 4 July 2005 [latest update: #7054] on 7 September 2006 at 11:22:45 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."Smalltalk condenseSources.SystemVersion current version: 'Squeak3.9gamma'; date: '23 July 2006'.self inform: 'The version number for this image hasnow been advanced to Squeak3.9gamma.'!----End fileIn of a stream----!"empty cs to bump cs number to 7056"!----End fileIn of a stream----!----SNAPSHOT----an Array(7 September 2006 11:23:23 pm) Squeak3.9b-7053.image priorSource: 0!----QUIT/NOSAVE----an Array(7 September 2006 11:23:29 pm) Squeak3.9b-7053.image priorSource: 670!----STARTUP----an Array(7 September 2006 11:23:48 pm) as Macintosh:Users:ducasse:Desktop:Squeak3.9b-7053:Squeak3.9b-7053.image!----SNAPSHOT----an Array(7 September 2006 11:28:13 pm) Squeak3.9b-7056.image priorSource: 670!----QUIT/NOSAVE----an Array(7 September 2006 11:28:23 pm) Squeak3.9b-7056.image priorSource: 993!----STARTUP----an Array(7 September 2006 11:28:50 pm) as Macintosh:Users:ducasse:Desktop:Squeak3.9g-7056:Squeak3.9b-7056.image!----SNAPSHOT----an Array(7 September 2006 11:28:55 pm) Squeak3.9g-7056.image priorSource: 993!----QUIT/NOSAVE----an Array(7 September 2006 11:29 pm) Squeak3.9g-7056.image priorSource: 1318!----STARTUP----an Array(7 September 2006 11:29:10 pm) as Macintosh:Users:ducasse:Desktop:Squeak3.9g-7056:Squeak3.9g-7056.image!----QUIT----an Array(7 September 2006 11:30 pm) Squeak3.9g-7056.image priorSource: 1318!----STARTUP----an Array(10 September 2006 8:06:33 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7057/Squeak3.9g-7056.image!!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/8/2006 20:59'!cleaningCS	"self new cleaningCS" 	 	ChangeSorter removeChangeSetsNamedSuchThat: [:each | true].	ChangeSet resetCurrentToNewUnnamedChangeSet ! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/8/2006 20:59' prior: 29494449!currentPackages	"ScriptLoader new currentPackages" 			| copies |	copies := MCWorkingCopy allManagers asSortedCollection:		[ :a :b | a package name <= b package name ].	^ copies select: [:each | '*Plus*' match: each package name ].! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 21:06'!script84	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.96.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 20:55'!script84Log	"adding way to reset current CS"! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/8/2006 20:53'!updateFrom7056	"self new updateFrom7056"			self script84.	"include changeset extension"	self cleaningCS.		self flushCaches.! !"ScriptLoader"!!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 9/8/2006 21:05'!resetCurrentToNewUnnamedChangeSet 	current := self new.  	self newChanges: current ! !"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.305.mcz') load.ScriptLoader new updateFrom7056.!----End fileIn of a stream----!----SNAPSHOT----an Array(10 September 2006 8:13:08 pm) Squeak3.9g-7056.image priorSource: 1641!----SNAPSHOT----an Array(10 September 2006 8:13:23 pm) Squeak3.9g-7057.image priorSource: 4851!----QUIT----an Array(10 September 2006 8:13:29 pm) Squeak3.9g-7057.image priorSource: 4948!----STARTUP----an Array(14 September 2006 9:30:35 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7057/Squeak3.9g-7057.image!!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/14/2006 20:33' prior: 29495067!generateCS: extensionAndNumber fromUpdate: updateNumber on: st		st nextPutAll:'"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: ''http://source.squeakfoundation.org/39a''                user: ''''                password: ''''.(repository loadVersionFromFileNamed:' .	st nextPut: $' ; nextPutAll: 'ScriptLoader', extensionAndNumber, '.mcz'') load.'; cr.	st nextPutAll: 'ScriptLoader new updateFrom', (updateNumber-1) asString; nextPutAll: '.' ; cr.	st nextPutAll: '!!'.	^ st contents! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/14/2006 20:33'!script85	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.97.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/14/2006 21:10'!updateFrom7057	"self new updateFrom7057"			self script85.	"fix windowColorRegistry"	ServicePreferences wipe.	ServiceRegistry rebuild.	WindowColorRegistry refresh.	self cleaningCS.		self flushCaches.! !"ScriptLoader"!!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:07' prior: 50891697!refresh	"This is a one-time only method for bootstraping the new registry. Here we will scan all classes for #windowColorSpecification methods and register those to the registry"	registry := nil.	((self systemNavigation allClassesImplementing: #windowColorSpecification)		collect: [:aClass | aClass theNonMetaClass windowColorSpecification])		do: [:spec | self registerColorSpecification: spec toClassNamed: spec classSymbol ].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11' prior: 50892769!registry	^registry ifNil: [registry := Dictionary new].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11'!unregisterColorSpecificationForClassNamed: aClassName		self registry removeKey: aClassName asSymbol ! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:12' prior: 27893618!setWindowColorFor: modelSymbol to: incomingColor	| aColor aPrefSymbol aColorSpec |	aColorSpec := WindowColorRegistry registeredWindowColorSpecFor: modelSymbol.	aColorSpec ifNil: [^self].	aColor := incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor or: [aColor = Color black]) 		ifTrue: [^ self].		aPrefSymbol :=  self windowColorPreferenceForClassNamed: aColorSpec classSymbol.	self 		addPreference: aPrefSymbol  		categories:  { #'window colors' }		default:  aColor 		balloonHelp: aColorSpec helpMessage translated		projectLocal: false		changeInformee: nil		changeSelector: nil		viewRegistry: (PreferenceViewRegistry registryOf: #windowColorPreferences)! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:13' prior: 27894402!windowColorFor: aModelClassName	| classToCheck prefSymbol |	self checkForWindowColors.	classToCheck := Smalltalk at: aModelClassName.	prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name.	[(classToCheck ~~ Object) and: [(self preferenceAt: prefSymbol) isNil]]		whileTrue: 				[classToCheck := classToCheck superclass.				prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name].	^self valueOfPreference: prefSymbol ifAbsent: [Color white].! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:14' prior: 27896694!windowSpecificationPanel	"Put up a panel for specifying window colors"	"Preferences windowSpecificationPanel"	| aPanel buttonRow aButton aRow aSwatch aColor aWindow aMiniWorld aStringMorph |	aPanel := AlignmentMorph newColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap;		layoutInset: 0.	aPanel addMorph: (buttonRow := AlignmentMorph newRow color: (aColor := Color tan lighter)).		buttonRow addTransparentSpacerOfSize: 2@0.	buttonRow addMorphBack: (SimpleButtonMorph new label: '?'; target: self; actionSelector: #windowColorHelp; setBalloonText: 'Click for an explanation of this panel'; color: Color veryVeryLightGray; yourself).	buttonRow addTransparentSpacerOfSize: 8@0.	#(	('Bright' 	installBrightWindowColors	yellow					'Use standard bright colors for all windows.')		('Pastel'		installPastelWindowColors	paleMagenta					'Use standard pastel colors for all windows.')		('White'	installUniformWindowColors		white					'Use white backgrounds for all standard windows.')) do:		[:quad |			aButton := (SimpleButtonMorph new target: self)				label: quad first;				actionSelector: quad second;				color: (Color colorFrom: quad third);				setBalloonText: quad fourth;				yourself.			buttonRow addMorphBack: aButton.			buttonRow addTransparentSpacerOfSize: 10@0].	self windowColorTable do:		[:colorSpec | 			aRow _ AlignmentMorph newRow color: aColor.			aSwatch _ ColorSwatch new				target: self;				getSelector: #windowColorFor:;				putSelector: #setWindowColorFor:to:;				argument: colorSpec classSymbol;				extent: (40 @ 20);				setBalloonText: 'Click here to change the standard color to be used for ', colorSpec wording, ' windows.';				yourself.			aRow addMorphFront: aSwatch.			aRow addTransparentSpacerOfSize: (12 @ 1).			aRow addMorphBack: (aStringMorph := StringMorph contents: colorSpec wording font: TextStyle defaultFont).			aStringMorph setBalloonText: colorSpec helpMessage.			aPanel addMorphBack: aRow].	 Smalltalk isMorphic                ifTrue:                        [aWindow := aPanel wrappedInWindowWithTitle: 'Window Colors'.					" don't allow the window to be picked up by clicking inside "					aPanel on: #mouseDown send: #yourself to: aPanel.					self currentWorld addMorphCentered: aWindow.					aWindow activateAndForceLabelToShow ]                ifFalse:                        [(aMiniWorld := MVCWiWPasteUpMorph newWorldForProject: nil)						addMorph: aPanel.                           aMiniWorld startSteppingSubmorphsOf: aPanel.                        MorphWorldView openOn: aMiniWorld                                label: 'Window Colors'                                extent: aMiniWorld fullBounds extent]! !"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.309.mcz') load.ScriptLoader new updateFrom7057.!----End fileIn of a stream----!----SNAPSHOT----an Array(14 September 2006 9:32:22 pm) Squeak3.9g-7058.image priorSource: 5045!----QUIT/NOSAVE----an Array(14 September 2006 9:32:27 pm) Squeak3.9g-7058.image priorSource: 13446!----STARTUP----an Array(22 September 2006 2:45:56 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7058 2/Squeak3.9g-7058.image!!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/18/2006 13:29'!updateFrom7058	"self new updateFrom7058"			(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . ! !"ScriptLoader"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.310.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7059] on 18 September 2006 at 1:43:17 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . !----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46' prior: 33568303!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !"ScriptLoader"!!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'wiz 8/13/2006 17:55'!testInitialChangeSet	"Run this to assure the initial changeset is named. Checks bug found in 3.9 7052."	"self new testInitialChangeSet"	"self run:  #testInitialChangeSet"	self deny: (ChangeSet current printString = 'a ChangeSet named <no name -- garbage?>') .	^true! !!ChangeSet class methodsFor: 'current changeset' stamp: 'wiz 9/19/2006 03:21' prior: 18299908!current	"return the current changeset	assure first that we have a named changeset. To cure mantis #4535. "	current isMoribund		ifTrue: [(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed'))] .	^ current! !!RequiredSelectors methodsFor: 'access to cache' stamp: 'dvf 9/18/2006 22:04' prior: 28614021!calculateForClass: aClass 	| rscc |	self clearOut: aClass.	rscc := RequiredSelectorsChangesCalculator onModificationOf: { aClass }				withTargets: { aClass }.	rscc doWork! !!ATestCase methodsFor: 'as yet unclassified' stamp: 'dvf 9/18/2006 21:28'!testRequirement  "  self debug: #testRequirement  "  | class |  class := Object            subclass: #AClassForTest            instanceVariableNames: ''            classVariableNames: ''            poolDictionaries: ''            category: self class category.  [   class compile: 'call                    ^ self isCalled'.   self assert: (class requiredSelectors includes: #isCalled).   class compile: 'isCalled                    ^ 1'.   "Fail here:"   self deny: (class requiredSelectors includes: #isCalled)]  ensure: [class removeFromSystem] ! !"System"!"Tests"!"Traits"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.311.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!!AClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 9/22/2006 14:49'!call                    ^ self isCalled! !!AClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 9/22/2006 14:49'!isCalled                    ^ 1! !Smalltalk removeClassNamed: #AClassForTest!testRequirement  "  self debug: #testRequirement!!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/18/2006 13:29' prior: 33570915!updateFrom7058	"self new updateFrom7058"			(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . ! !ScriptLoader removeSelector: #script86!"ScriptLoader"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.310.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7059] on 18 September 2006 at 1:43:17 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . !----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46' prior: 33573645!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !"ScriptLoader"!----QUIT/NOSAVE----an Array(22 September 2006 2:53:01 pm) Squeak3.9g-7058.image priorSource: 13446!----STARTUP----an Array(22 September 2006 2:53:09 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7058 2/Squeak3.9g-7058.image!!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/18/2006 13:29'!updateFrom7058	"self new updateFrom7058"			(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . ! !"ScriptLoader"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.310.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7059] on 18 September 2006 at 1:43:17 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . !----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46' prior: 33576725!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !"ScriptLoader"!!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'wiz 8/13/2006 17:55'!testInitialChangeSet	"Run this to assure the initial changeset is named. Checks bug found in 3.9 7052."	"self new testInitialChangeSet"	"self run:  #testInitialChangeSet"	self deny: (ChangeSet current printString = 'a ChangeSet named <no name -- garbage?>') .	^true! !!ChangeSet class methodsFor: 'current changeset' stamp: 'wiz 9/19/2006 03:21' prior: 18299908!current	"return the current changeset	assure first that we have a named changeset. To cure mantis #4535. "	current isMoribund		ifTrue: [(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed'))] .	^ current! !!RequiredSelectors methodsFor: 'access to cache' stamp: 'dvf 9/18/2006 22:04' prior: 28614021!calculateForClass: aClass 	| rscc |	self clearOut: aClass.	rscc := RequiredSelectorsChangesCalculator onModificationOf: { aClass }				withTargets: { aClass }.	rscc doWork! !!ATestCase methodsFor: 'as yet unclassified' stamp: 'dvf 9/18/2006 21:28'!testRequirement  "  self debug: #testRequirement  "  | class |  class := Object            subclass: #AClassForTest            instanceVariableNames: ''            classVariableNames: ''            poolDictionaries: ''            category: self class category.  [   class compile: 'call                    ^ self isCalled'.   self assert: (class requiredSelectors includes: #isCalled).   class compile: 'isCalled                    ^ 1'.   "Fail here:"   self deny: (class requiredSelectors includes: #isCalled)]  ensure: [class removeFromSystem] ! !"System"!"Tests"!"Traits"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.311.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!----SNAPSHOT----an Array(22 September 2006 2:56:15 pm) Squeak3.9g-7061.image priorSource: 13446!----SNAPSHOT----an Array(22 September 2006 2:56:23 pm) Squeak3.9g-7061.image priorSource: 27219!----QUIT/NOSAVE----an Array(22 September 2006 2:56:29 pm) Squeak3.9g-7061.image priorSource: 27317!----STARTUP----an Array(14 October 2006 10:29:19 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7061/Squeak3.9g-7061.image!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 13 October 2006 at 1:46:42 pm'!----End fileIn of a stream----!"Installed SUnit auto version 14".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '26bea8bf-733f-4715-b188-fa6d848984ad' autoVersion: '14' asVersion atSeconds: 3338274597 number: 3]!!SMLoader commentStamp: '<historical>' prior: 28830228!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:14' prior: 28832242!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := model isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(model directory directoryEntryFor: model lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'gui building' stamp: 'gk 9/25/2006 23:13' prior: 28845150!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:12' prior: 28850838!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((model categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 9/25/2006 23:13' prior: 28841017!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (model object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:41' prior: 28856889!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:25' prior: 28856648!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:12' prior: 28837324!loadUpdates	[Cursor wait showWhile: [		model loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 01:02' prior: 28857752!noteChanged	filters ifNil: [^self reOpen].	model ifNotNil: [		packagesList := nil.		selectedCategoryWrapper := nil.		self changed: #categoryWrapperList.		self changed: #packageWrapperList.		self changed: #packagesListIndex.	"update my selection"		self contentsChanged]! !!SMLoader methodsFor: 'initialization' stamp: 'gk 9/25/2006 23:12' prior: 28850564!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 28851422!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'private' stamp: 'gk 9/25/2006 23:12' prior: 28858069!packages	"We request the packages as sorted by name by default."	^model packagesByName asArray! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 28852607!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', model packages size printString, ')'! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/26/2006 00:40' prior: 28838431!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:40' prior: 28858774!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !"SMLoader"!"Installed SqueakMap2 loader auto version 10".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3' autoVersion: '10' asVersion atSeconds: 3338274602 number: 4]!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."SMSqueakMap default loadUpdates; upgradeOldPackages; purge.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87Log	"Name: KernelTests-lr.49Author: lrTime: 5 October 2006, 10:16:34 amUUID: 762d5c23-0364-4c26-ba13-129327ea7f39Ancestors: KernelTests-lr.48- merged code to fix unknown pragma selectors and binary selectors in pragmas- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmas- added some testsName: Compiler-lr.56Author: lrTime: 5 October 2006, 10:14:04 amUUID: f429f722-c39f-4acf-9d8c-c8a38320eaa8Ancestors: Compiler-lr.55- merged code to fix unknown pragma selectors- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmasMorphic fix duplicateChange Set:		ToggleBreakFix39Date:			26 September 2006Author:			tim@rowledge.orgPutative fix for Mantis http://bugs.impara.de/view.php?id=5123Fix Squeakmap"! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/13/2006 19:19'!updateFrom7061	"self new updateFrom7061"	self script87.	self flushCaches.	! !"ScriptLoader"!!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:48' prior: 26575366!addPragma: aPragma	self properties addPragma: aPragma! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47' prior: 26575484!pragmaLiteral	"Read a pragma literal."	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])		ifTrue: [ ^ self advance ].	(here == $# and: [ tokenType == #word ])		ifTrue: [ ^ self advance ].	(here == #- and: [ tokenType == #number ])		ifTrue: [ ^ (self advance; advance) negated ].	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])		ifTrue: [ ^ Compiler evaluate: self advance ].	^ self expected: 'Literal constant'! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 10:04' prior: 26576048!pragmaPrimitives	| pragmas primitives |	self properties pragmas isEmpty		ifTrue: [ ^ 0 ].	pragmas := Pragma allNamed: #primitive from: self class to: Parser.	primitives := self properties pragmas select: [ :prim |		pragmas anySatisfy: [ :prag | 			prag selector = prim keyword ] ].	primitives isEmpty 		ifTrue: [ ^ 0 ].	primitives size = 1 		ifFalse: [ ^ self notify: 'Ambigous primitives' ].	^ primitives first message sendTo: self! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47' prior: 26576424!pragmaSequence	"Parse a sequence of method pragmas."		[ true ] whileTrue: [		(self matchToken: #<)			ifFalse: [ ^ self ].		self pragmaStatement.		(self matchToken: #>)			ifFalse: [ ^ self expected: '>' ] ]! !!Parser methodsFor: 'pragmas' stamp: 'lr 8/19/2006 20:39' prior: 26576701!pragmaStatement	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."		| selector arguments words index keyword |	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])		ifFalse: [  ^ self expected: 'pragma declaration' ].	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "	(here = #apicall: or: [ here = #cdecl: ])		ifTrue: [ ^ self externalFunctionDeclaration ].	selector := String new.	arguments := OrderedCollection new.	words := OrderedCollection new.	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [		index := self startOfNextToken + requestorOffset.		selector := selector , self advance.		words add: (index to: self endOfLastToken + requestorOffset).		(selector last = $: or: [ selector first isLetter not ])			ifTrue: [ arguments add: self pragmaLiteral ] ].	selector numArgs ~= arguments size		ifTrue: [ ^ self expected: 'pragma argument' ].	(Symbol hasInterned: selector 		ifTrue: [ :value | keyword := value]) 		ifFalse: [ 			keyword := self 				correctSelector: selector wordIntervals: words				exprInterval: (words first first to: words last last)				ifAbort: [ ^ self fail ] ].	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).	^ true! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:50' prior: 26580110!primitive: anIntegerOrString	"Create indexed primitive."		<primitive>	^ anIntegerOrString isInteger		ifTrue: [ anIntegerOrString ]		ifFalse: [ 			anIntegerOrString isString				ifTrue: [ self primitive: anIntegerOrString module: nil ]				ifFalse: [ self expected: 'Indexed primitive' ] ]! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:51' prior: 26580460!primitive: aNameString module: aModuleStringOrNil	"Create named primitive."		<primitive>	(aNameString isString and: [ aModuleStringOrNil isNil or: [ aModuleStringOrNil isString ] ])		ifFalse: [ ^ self expected: 'Named primitive' ].	self allocateLiteral: (Array 		with: (aModuleStringOrNil isNil 			ifFalse: [ aModuleStringOrNil asSymbol ])		with: aNameString asSymbol		with: 0 with: 0).	^ 117! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47' prior: 26577682!properties	^ properties ifNil: [ properties := MethodProperties new ]! !!BreakpointManager class methodsFor: 'install-uninstall' stamp: 'tpr 9/26/2006 16:14' prior: 17771108!installInClass: aClass selector: aSymbol 	"Install a new method containing a breakpoint.	The receiver will remember this for unstalling it later"	| breakMethod |	breakMethod _ self compilePrototype: aSymbol in: aClass.	breakMethod isNil		ifTrue: [^ nil].	self installed at: breakMethod put: aClass >> aSymbol. "old method"	aClass class basicAddSelector: aSymbol withMethod: breakMethod.! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 8/19/2006 20:44'!testCompileBinary	self assertPragma: ' = 1' givesKeyword: #= arguments: #( 1 ).	self assertPragma: ' , 3' givesKeyword: #, arguments: #( 3 ).	self assertPragma: ' > 4' givesKeyword: #> arguments: #( 4 ).	self assertPragma: ' < 5' givesKeyword: #< arguments: #( 5 ).	self assertPragma: ' == 1' givesKeyword: #== arguments: #( 1 ).	self assertPragma: ' <> 3' givesKeyword: #<> arguments: #( 3 ).	self assertPragma: ' >< 4' givesKeyword: #>< arguments: #( 4 ).	self assertPragma: ' ** 5' givesKeyword: #** arguments: #( 5 )! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 10:15' prior: 24466852!testCompileInvalid	"Invalid pragmas should properly raise an error."	self should: [ self compile: '<>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<#123>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo bar>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo 1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar zork>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar 1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: bar:>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: #bar: zork:>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<<1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<=2>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 = >' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 =2 >' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: String>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: Pragma>' selector: #zork ] raise: SyntaxErrorNotification! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 09:49' prior: 24469260!testCompileValue	self assertPragma: 'foo: true' givesKeyword: #foo: arguments: #( true ).	self assertPragma: 'foo: false' givesKeyword: #foo: arguments: #( false ).	self assertPragma: 'foo: nil' givesKeyword: #foo: arguments: #( nil )! !!SMLoader commentStamp: '<historical>' prior: 33582520!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!SMLoader methodsFor: 'actions' stamp: 'gk 5/5/2006 02:05' prior: 33582749!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := squeakMap isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(squeakMap directory directoryEntryFor: squeakMap lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'gui building' stamp: 'gk 5/5/2006 02:05' prior: 33583415!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [squeakMap cache directoryForPackage: item]				ifFalse: [squeakMap cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/12/2004 01:16' prior: 33583905!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((squeakMap categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/13/2004 15:49' prior: 33584511!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (squeakMap object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'private' stamp: 'gk 7/11/2004 04:07' prior: 33585646!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe ifFalse: [self reOpen].		self noteChanged]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 7/11/2004 03:58' prior: 33586541!installedReleaseOfMe	"Return the release of the installed package loader."	^squeakMap installedReleaseOf: (squeakMap packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/10/2004 18:51' prior: 33586817!loadUpdates	[Cursor wait showWhile: [		squeakMap loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 7/13/2004 17:07' prior: 33587103!noteChanged	packagesList := nil.	selectedCategoryWrapper := nil.	filters ifNil: [^self reOpen].	self changed: #categoryWrapperList.	self changed: #packageWrapperList.	self changed: #packagesListIndex.	"update my selection"	self contentsChanged! !!SMLoader methodsFor: 'initialization' stamp: 'gk 5/5/2006 02:05' prior: 33587467!on: aSqueakMap 	"Initialize instance."	squeakMap := aSqueakMap.	squeakMap synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/13/2004 17:10' prior: 33587747!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (squeakMap object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'private' stamp: 'gk 11/18/2003 02:24' prior: 33588552!packages	"We request the packages as sorted by name by default."	^squeakMap packagesByName asArray! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/13/2004 17:10' prior: 33588729!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', squeakMap packages size printString, ')'! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/13/2004 15:25' prior: 33588995!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := squeakMap installedPackages.	old := squeakMap oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := squeakMap upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				squeakMap upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe ifFalse: [self reOpen].				self noteChanged]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'gk 5/5/2006 02:05' prior: 33590719!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := squeakMap installedPackages.	old := squeakMap oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := squeakMap upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					squeakMap upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [squeakMap upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe ifFalse: [self reOpen].				self noteChanged]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!Morph methodsFor: 'halos and balloon help' stamp: 'zz 9/28/2006 18:53' prior: 24733634!balloonHelpTextForHandle: aHandle 	"Answer a string providing balloon help for the	given halo handle"	| itsSelector |	itsSelector := aHandle eventHandler firstMouseSelector.	itsSelector == #doRecolor:with:		ifTrue: [^ Preferences propertySheetFromHalo				ifTrue: ['Open a property sheet.']				ifFalse: ['Change color']].	itsSelector == #mouseDownInDimissHandle:with:		ifTrue: [^ Preferences preserveTrash				ifTrue: ['Move to trash']				ifFalse: ['Remove from screen']].	#(#(#addFullHandles 'More halo handles') #(#addSimpleHandles 'Fewer halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#dismiss 'Remove') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMakeSibling:with: 'Make a sibling') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#editButtonsScript 'See the script for this button') #(#editDrawing 'Repaint') #(#doDupOrMakeSibling:with: 'Duplicate (press shift to make a sibling)') #(#doMakeSiblingOrDup:with: 'Make a sibling (press shift to make simple duplicate)') #(#makeNascentScript 'Make a scratch script') #(#makeNewDrawingWithin 'Paint new object') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#openViewerForArgument 'Open a Viewer for me. Press shift for a snapshot.') #(#openViewerForTarget:with: 'Open a Viewer for me. Press shift for a snapshot.') #(#paintBackground 'Paint background') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#presentViewMenu 'Present the Viewing menu') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#tearOffTile 'Make a tile representing this object') #(#tearOffTileForTarget:with: 'Make a tile representing this object') #(#trackCenterOfRotation:with: 'Set center of rotation') )		do: [:pair | itsSelector == pair first				ifTrue: [^ pair last]].	^ 'unknown halo handle'translated! !"Compiler"!"KernelTests"!"Morphic"!"SMLoader"!"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.316.mcz') load.ScriptLoader new updateFrom7061.!----End fileIn of a stream----!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 13 October 2006 at 1:46:42 pm'!----End fileIn of a stream----!----SNAPSHOT----an Array(14 October 2006 10:37 am) Squeak3.9-RC2-7063.image priorSource: 27317!----SNAPSHOT----an Array(14 October 2006 10:38:53 am) Squeak3.9-RC2-7063.image priorSource: 61467!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7061] on 5 October 2006 at 12:48:11 pm'!----End fileIn of a stream----!----SNAPSHOT----an Array(14 October 2006 10:40:44 am) Squeak3.9-RC2-7063.image priorSource: 61564!----QUIT/NOSAVE----an Array(14 October 2006 10:41:14 am) Squeak3.9-RC2-7063.image priorSource: 61797!----STARTUP----an Array(14 October 2006 10:41:44 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7063/Squeak3.9-RC2-7063.image!----QUIT/NOSAVE----an Array(14 October 2006 10:41:52 am) Squeak3.9-RC2-7063.image priorSource: 61797!----STARTUP----an Array(14 October 2006 10:58:15 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7063/Squeak3.9-RC2-7063.image!----QUIT/NOSAVE----an Array(14 October 2006 11:03:12 am) Squeak3.9-RC2-7063.image priorSource: 61797!----STARTUP----an Array(14 October 2006 11:03:23 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7063/Squeak3.9-RC2-7063.image!installingDefaultRepositoriesToPackages	"self new installingDefaultRepositoriesToPackages!!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:07' prior: 29509092!installRepository: aString for: packageName	(MCWorkingCopy allManagers select: [:each | each package name = packageName])		first repositoryGroup		addRepository: (MCHttpRepository new location: aString ; user: 'squeak' ; password: 'squeak')		! !installingDefaultRepositoriesToPackages	"self new installingDefaultRepositoriesToPackages!!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:08' prior: 29508560!installInBoxAnd39	"self new installInBoxAnd39"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/39a' ; user: ''; password: '');			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/inbox' ; user: '' ; password: '')].		! !installInBoxAnd39	"self new installInBoxAnd39!installInBoxAnd39	"self new installInBoxAnd39"		MCWorkingCopy allManagers!!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:12' prior: 29503230!cleanOldRepositories	"self new cleanOldRepositories"	"does not work since the interface of the repository group is not made for removing a repository only based on name"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			removeRepository: (MCHttpRepository new location: 'http://kilana.unibe.ch:8888/Monticello');			removeRepository: (MCHttpRepository new location: 'http://modules.squeakfoundation.org/People/gk/')].	! !"ScriptLoader"!----SNAPSHOT----an Array(14 October 2006 11:15:30 am) Squeak3.9-RC2-7063.image priorSource: 61797!----QUIT/NOSAVE----an Array(14 October 2006 11:15:37 am) Squeak3.9-RC2-7063.image priorSource: 64335!----STARTUP----an Array(15 October 2006 11:15:59 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7064/Squeak3.9-RC2-7063.image!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/15/2006 11:11'!script88	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/15/2006 11:11'!updateFrom7063	"self new updateFrom7063"		self script88.	SMSqueakMap default noteInstalledPackageNamed: 'SqueakMap2 loader'autoVersion: '10'.	self flushCaches.	! !"ScriptLoader"!!SMLoader commentStamp: '<historical>' prior: 33602792!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:14' prior: 33603020!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := model isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(model directory directoryEntryFor: model lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'gui building' stamp: 'gk 9/25/2006 23:13' prior: 33603697!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:12' prior: 33604195!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((model categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 9/25/2006 23:13' prior: 33604805!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (model object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:41' prior: 33605944!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:25' prior: 33606822!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:12' prior: 33607078!loadUpdates	[Cursor wait showWhile: [		model loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 01:02' prior: 33607368!noteChanged	filters ifNil: [^self reOpen].	model ifNotNil: [		packagesList := nil.		selectedCategoryWrapper := nil.		self changed: #categoryWrapperList.		self changed: #packageWrapperList.		self changed: #packagesListIndex.	"update my selection"		self contentsChanged]! !!SMLoader methodsFor: 'initialization' stamp: 'gk 9/25/2006 23:12' prior: 33607705!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 33607993!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'private' stamp: 'gk 9/25/2006 23:12' prior: 33608803!packages	"We request the packages as sorted by name by default."	^model packagesByName asArray! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 33608984!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', model packages size printString, ')'! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/26/2006 00:40' prior: 33609254!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:40' prior: 33610978!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !"SMLoader"!"Installed SqueakMap2 loader auto version 10".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3' autoVersion: '10' asVersion atSeconds: 3338363798 number: 5]!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.318.mcz') load.ScriptLoader new updateFrom7063.!----End fileIn of a stream----!----SNAPSHOT----an Array(15 October 2006 11:23:41 am) Squeak3.9-RC2-7063.image priorSource: 64335!----QUIT/NOSAVE----an Array(15 October 2006 11:23:46 am) Squeak3.9-RC2-7063.image priorSource: 77325!----STARTUP----an Array(15 October 2006 11:24 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7064/Squeak3.9-RC2-7063.image!----SNAPSHOT----an Array(15 October 2006 11:24:06 am) Squeak3.9-RC2-7064.image priorSource: 77325!----QUIT/NOSAVE----an Array(15 October 2006 11:24:10 am) Squeak3.9-RC2-7064.image priorSource: 77689!----STARTUP----an Array(20 October 2006 9:37:38 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7064/Squeak3.9-RC2-7064.image!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/18/2006 11:37'!script89	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.114.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/18/2006 11:37'!updateFrom7064	"self new updateFrom7064"		self script89.	self flushCaches.	! !"ScriptLoader"!!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57' prior: 31820324!initialize	"Initialize a system window. Add label, stripes, etc., if desired"	super initialize.	allowReframeHandles _ true.	labelString ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	borderColor _ Color lightGray.	borderWidth _ 1.	self color: Color lightGray lighter lighter lighter.	self layoutPolicy: ProportionalLayout new.		self initializeLabelArea.					self addCornerGrips.	self extent: 300 @ 200.	mustNotClose _ false.	updatablePanes _ Array new.			Preferences menuAppearance3d		ifTrue: [			self				addDropShadow;				shadowColor: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.333);				shadowOffset: 1@1.		].					! !!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57' prior: 31822124!initializeLabelArea	"Initialize the label area (titlebar) for the window."	label _ StringMorph new contents: labelString;						 font: Preferences windowTitleFont emphasis: 0.			"Add collapse box so #labelHeight will work"			collapseBox _ self createCollapseBox.			stripes _ Array						with: (RectangleMorph newBounds: bounds)						with: (RectangleMorph newBounds: bounds).			"see extent:"			self addLabelArea.			self setLabelWidgetAllowance.			self addCloseBox.			self addMenuControl.			labelArea addMorphBack: (Morph new extent: self class borderWidth @ 0).			labelArea addMorphBack: label.			self wantsExpandBox				ifTrue: [self addExpandBox].			labelArea addMorphBack: collapseBox.			self setFramesForLabelArea.			Preferences clickOnLabelToEdit				ifTrue: [label						on: #mouseDown						send: #relabel						to: self].			Preferences noviceMode				ifTrue: [closeBox						ifNotNil: [closeBox setBalloonText: 'close window'].					menuBox						ifNotNil: [menuBox setBalloonText: 'window menu'].					collapseBox						ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].! !!Compiler methodsFor: 'public access' stamp: 'md 10/16/2006 09:53' prior: 19127422!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	| methodNode method value toLog itsSelectionString itsSelection |	class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	method selector ifNil: [method selector: #DoIt].	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ])		executeMethod: method.	logFlag ifTrue:		[toLog := ((requestor respondsTo: #selection)  and:			[(itsSelection := requestor selection) notNil] and:			[(itsSelectionString := itsSelection asString) isEmptyOrNil not] )			ifTrue: 				[itsSelectionString]			ifFalse:				[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext ].	^ value.! !"Compiler"!"Morphic"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.319.mcz') load.ScriptLoader new updateFrom7064.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/20/2006 21:30'!script90	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.149.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.114.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/20/2006 21:31'!updateFrom7065	"self new updateFrom7065"		self script90.	self flushCaches.	! !"ScriptLoader"!!ClassRenameFixTest methodsFor: 'Tests' stamp: 'cmm 8/7/2005 18:21' prior: 18689065!renameClassUsing: aBlock	| createdClass foundClasses |	originalName := self newUniqueClassName.	createdClass := Object 		subclass: originalName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'ClassRenameFix-GeneradClass'.	newClassName := self newUniqueClassName.	aBlock value: createdClass value: newClassName.	self assert: (Smalltalk classNamed: originalName) isNil.	self assert: (Smalltalk classNamed: newClassName) notNil.	foundClasses := Smalltalk organization listAtCategoryNamed: 'ClassRenameFix-GeneradClass'.	self assert: (foundClasses notEmpty).	self assert: (foundClasses includes: newClassName).	self assert: (createdClass name = newClassName).! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'cmm 8/7/2005 18:20' prior: 18688108!setUp	previousChangeSet := ChangeSet current.	testsChangeSet := ChangeSet new.	ChangeSet newChanges: testsChangeSet.	SystemChangeNotifier uniqueInstance		notify: self		ofSystemChangesOfItem: #class		change: #Renamed		using: #verifyRenameEvent:.	super setUp! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'cmm 8/7/2005 18:21' prior: 18688450!tearDown	self removeEverythingInSetFromSystem: testsChangeSet.	ChangeSet newChanges: previousChangeSet.	ChangeSorter removeChangeSet: testsChangeSet.	previousChangeSet := nil.	testsChangeSet := nil.	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self.	super tearDown.! !!SystemDictionary methodsFor: 'class and trait names' stamp: 'rw 10/7/2006 08:34' prior: 31627640!renameClass: aClass as: newName 	"Rename the class, aClass, to have the title newName."	"Original one I want to keep but needs to be fixed"		| oldref i oldName category |	oldName := aClass name.	category := aClass category.	SystemOrganization classify: newName under: aClass category.	SystemOrganization removeElement: aClass name.	oldref _ self associationAt: aClass name.	self removeKey: aClass name.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i _ list indexOf: aClass name ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemDictionary methodsFor: 'class names' stamp: 'rw 10/17/2006 23:07'!renameClass: aClass from: oldName 	"Rename the class, aClass, to have the title newName."	| oldref i newName category |	newName := aClass name.	category := SystemOrganization categoryOfElement: oldName.	SystemOrganization classify: newName under: category.	SystemOrganization removeElement: oldName.	oldref := self associationAt: oldName.	self removeKey: oldName.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i := list indexOf: oldName ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemChangeNotifierTest commentStamp: 'rw 4/3/2006 17:19' prior: 31614888!A SystemChangeNotifierTest is a test class that tests whether the triggering of changes indeed results in the intended changes to be sent to registered object. The basic mechanism for each test is fairly simple:	- register the receiver as the one to get the change notifier.	- manually trigger a change (so the system is not polluted just to see whether we get the needed event).	- the method #event: is invoked and remembers the change event.	- the change event is checked to see whether it was the intended one.Instance Variables	capturedEvent:		Remembers the captured event!!SystemChangeNotifierTest methodsFor: 'Running' stamp: 'rw 10/19/2006 17:21'!setUp	super setUp.	notifier := SystemChangeNotifier createInstance.! !!SystemChangeNotifierTest methodsFor: 'Private' stamp: 'rw 10/19/2006 17:23'!systemChangeNotifier	"The notifier to use. Do not use the one in the system so that the fake events triggered in the tests perturb clients of the system's change notifier (e.g. the changes file then shows fake entries)."	^notifier! !!SystemChangeNotifierTest methodsFor: 'Running' stamp: 'rw 10/19/2006 17:23' prior: 31617204!tearDown	super tearDown.	self capturedEvent: nil.	notifier releaseAll.	notifier := nil! !!SystemChangeNotifierTest methodsFor: 'Testing-system triggers' stamp: 'rw 10/19/2006 17:24' prior: 31619179!testClassRenamedEvent	"self run: #testClassRenamedEvent"	self systemChangeNotifier notify: self ofAllSystemChangesUsing: #event:.	self systemChangeNotifier 		classRenamed: self class		from: #OldFooClass		to: #NewFooClass		inCategory: #FooCat.	self		checkEventForClass: self class		category: #FooCat		change: #Renamed."	self assert: capturedEvent oldName = #OldFooClass.	self assert: capturedEvent newName = #NewFooClass"! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/17/2006 22:26' prior: 18241916!event: anEvent	"Hook for SystemChangeNotifier"	anEvent itemKind = SystemChangeNotifier classKind ifTrue: [		anEvent isRemoved 			ifTrue: [self noteRemovalOf: anEvent item].		anEvent isAdded 			ifTrue: [self addClass: anEvent item].		anEvent isModified 			ifTrue: [anEvent anyChanges ifTrue: [self changeClass: anEvent item from: anEvent oldItem]].		anEvent isCommented 			ifTrue: [self commentClass: anEvent item].		anEvent isRenamed 			ifTrue: [self renameClass: anEvent item from: anEvent oldName to: anEvent newName].		anEvent isReorganized			ifTrue: [self reorganizeClass: anEvent item].		anEvent isRecategorized			ifTrue: [self changeClass: anEvent item from: anEvent item].	].	anEvent itemKind = SystemChangeNotifier methodKind ifTrue: [		anEvent isAdded			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: nil].		anEvent isModified			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: anEvent oldItem].		anEvent isRemoved			ifTrue: [self removeSelector: anEvent itemSelector class: anEvent itemClass priorMethod: anEvent item lastMethodInfo: {anEvent item sourcePointer. anEvent itemProtocol}].		anEvent isRecategorized			ifTrue: [self reorganizeClass: anEvent itemClass].	].! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/19/2006 17:52'!renameClass: class from: oldName to: newName 	"Include indication that a class has been renamed."	| recorder oldMetaClassName newMetaClassName |	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet renameClass: class as: newName].	(recorder _ self changeRecorderFor: oldName)		noteChangeType: #rename;		noteNewName: newName asSymbol.			"store under new name (metaclass too)"	changeRecords at: newName put: recorder.	changeRecords removeKey: oldName.	self noteClassStructure: class.	newMetaClassName := newName, ' class'.	oldMetaClassName := oldName, ' class'.	recorder _ changeRecords at: oldMetaClassName ifAbsent: [^ nil].	changeRecords at: newMetaClassName put: recorder.	changeRecords removeKey: oldMetaClassName.	recorder noteNewName: newMetaClassName! !!Class methodsFor: 'class name' stamp: 'rw 10/7/2006 08:30' prior: 18519182!rename: aString 	"The new name of the receiver is the argument, aString."	| oldName newName |	(newName _ aString asSymbol) = (oldName _ self name)		ifTrue: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	name _ newName.	self environment renameClass: self from: oldName! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57' prior: 18691219!deleteClass	| cl |	cl := Smalltalk at: className ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57'!deleteRenamedClass	| cl |	cl := Smalltalk at: renamedName ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:05' prior: 18691426!setUp	className := #TUTU.	renamedName := #RenamedTUTU.	self deleteClass.	self deleteRenamedClass.	Object subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'KernelTests-Classes'! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:08' prior: 18691687!tearDown	self deleteClass.	self deleteRenamedClass! !!ClassTest methodsFor: 'testing' stamp: 'rw 10/17/2006 22:13' prior: 18692104!testRenaming	"self debug: #testRenaming"	"self run: #testRenaming"		| oldName newMetaclassName class |	oldName := className.	newMetaclassName := (renamedName, #' class') asSymbol.	class := Smalltalk at: oldName.	class class compile: 'dummyMeth'.	class rename: renamedName.	self assert: class name = renamedName.	self assert: (ChangeSet current changedClassNames includes: renamedName). 	self assert: (ChangeSet current changedClassNames includes: newMetaclassName).	! !ChangeSet removeSelector: #renameClass:as:!"Kernel"!"KernelTests"!"System"!"SystemChangeNotification-Tests"!"Tests"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.320.mcz') load.ScriptLoader new updateFrom7065.!----End fileIn of a stream----!----SNAPSHOT----an Array(20 October 2006 9:43:06 pm) Squeak3.9-RC3-7066.image priorSource: 77689!----QUIT/NOSAVE----an Array(20 October 2006 9:43:18 pm) Squeak3.9-RC3-7066.image priorSource: 95470!----STARTUP----an Array(7 November 2006 11:57:51 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC3-7066/Squeak3.9-RC3-7066.image!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 11/6/2006 20:38'!script91	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.150.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.115.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 11/7/2006 11:50'!updateFrom7066	"self new updateFrom7066"		self script91.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	SystemVersion newVersion: 'Squeak3.9'.	self flushCaches.	! !"ScriptLoader"!!Complex methodsFor: 'comparing' stamp: 'hmm 11/1/2006 23:29' prior: 19144324!= anObject	anObject isNumber ifFalse: [^false].	anObject isComplex		ifTrue: [^ (real = anObject real) & (imaginary = anObject imaginary)]		ifFalse: [^ anObject adaptToComplex: self andSend: #=]! !!Complex methodsFor: 'testing' stamp: 'hmm 11/1/2006 23:34'!isNumber	^ true! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:22'!testAddAction	"MVCToolBuilder does not implement #buildPluggableMenu:"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:22'!testAddTargetSelectorArgumentList	"MVCToolBuilder does not implement #buildPluggableMenu:"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:23'!testButtonFiresBlock	"MVC buttons only support action Symbols"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:23'!testButtonFiresMessage	"MVC buttons only support action Symbols, not MessageSends"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testButtonInitiallyDisabled	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testButtonInitiallyDisabledSelector	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testGetButtonColor	"MVC buttons do not have color"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testGetButtonEnabled	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:18'!testGetButtonSideEffectFree	"MVC button ask for their state on any change notification"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:19'!testGetInputFieldColor	"MVC input fields do not have color"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:20'!testGetPanelChildren	"MVC panels do not allow changing children"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetTextColor	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetWindowChildren	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetWindowLabel	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeExpandPath	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeExpandPathFirst	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeGetSelectionPath	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeRoots	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeWidgetID	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:25'!testWindowCloseAction	"This can only work if we're actually run in MVC"	World isNil ifTrue: [super testWindowCloseAction]! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36' prior: 17737741!addCornerGrips	self		addMorphBack: (TopLeftGripMorph new target: self; position: self position).	self		addMorphBack: (TopRightGripMorph new target: self; position: self position).	self		addMorphBack: (BottomLeftGripMorph new target: self;position: self position).	self		addMorphBack: (BottomRightGripMorph new target: self;position: self position)! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36' prior: 17738079!addPaneHSplitterBetween: topMorph and: bottomMorphs	| targetY minX maxX splitter |	targetY _ topMorph layoutFrame bottomFraction.	minX _ (bottomMorphs detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.	maxX _ (bottomMorphs detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.	splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.	splitter layoutFrame: (LayoutFrame		fractions: (minX @ targetY corner: maxX @ targetY)		offsets: (((topMorph layoutFrame leftOffset ifNil: [0]) @ 0 corner: (topMorph layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (topMorph layoutFrame bottomOffset ifNil: [0]))).	self addMorphBack: (splitter position: self position).! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:34' prior: 17738876!addPaneSplitters	| splitter remaining target targetX sameX minY maxY targetY sameY minX maxX |	self removePaneSplitters.	self removeCornerGrips.	remaining _ submorphs reject: [:each | each layoutFrame rightFraction = 1].	[remaining notEmpty] whileTrue:		[target _ remaining first.		targetX _ target layoutFrame rightFraction.		sameX _ submorphs select: [:each | each layoutFrame rightFraction = targetX].		minY _ (sameX detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.		maxY _ (sameX detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.		splitter layoutFrame: (LayoutFrame			fractions: (targetX @ minY corner: targetX @ maxY)			offsets: ((0 @ (target layoutFrame topOffset ifNil: [0]) corner: 4 @ (target layoutFrame bottomOffset ifNil: [0])) translateBy: (target layoutFrame rightOffset ifNil: [0]) @ 0)).		self addMorphBack: (splitter position: self position).		remaining _ remaining copyWithoutAll: sameX].	remaining _ submorphs copy reject: [:each | each layoutFrame bottomFraction = 1].	[remaining notEmpty]		whileTrue: [target _ remaining first.			targetY _ target layoutFrame bottomFraction.			sameY _ submorphs select: [:each | each layoutFrame bottomFraction = targetY].			minX _ (sameY detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.			maxX _ (sameY detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.			splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.			splitter layoutFrame: (LayoutFrame				fractions: (minX @ targetY corner: maxX @ targetY)				offsets: (((target layoutFrame leftOffset ifNil: [0]) @ 0 corner: (target layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (target layoutFrame bottomOffset ifNil: [0]))).			self addMorphBack: (splitter position: self position).			remaining _ remaining copyWithoutAll: sameY].	self linkSubmorphsToSplitters.	self splitters do: [:each | each comeToFront].! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:37' prior: 17740940!addPaneVSplitterBetween: leftMorph and: rightMorphs 	| targetX minY maxY splitter |	targetX _ leftMorph layoutFrame rightFraction.	minY _ (rightMorphs detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.	maxY _ (rightMorphs detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.	splitter layoutFrame: (LayoutFrame		fractions: (targetX @ minY corner: targetX @ maxY)		offsets: ((0 @ (leftMorph layoutFrame topOffset ifNil: [0]) corner: (4@ (leftMorph layoutFrame bottomOffset ifNil: [0]))) translateBy: (leftMorph layoutFrame rightOffset ifNil: [0]) @ 0)).	self addMorphBack: (splitter position: self position).! !"Kernel"!"Morphic"!"ToolBuilder-MVC"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.324.mcz') load.ScriptLoader new updateFrom7066.!----End fileIn of a stream----!----SNAPSHOT----an Array(7 November 2006 12:05:35 pm) Squeak3.9-final-7067.image priorSource: 95470!----QUIT/NOSAVE----an Array(7 November 2006 12:05:44 pm) Squeak3.9-final-7067.image priorSource: 105817!----STARTUP----an Array(2 March 2008 5:56:06 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-final-7067/Squeak3.9-final-7067.image!"Change Set:		advance391Date:			14 feb 2008Author:			S. DucasseAdvance the version to 3.9.1. Subsequent updates will lead to version 3.9.1"!"Postscript:Advance the version number to 3.9.1a ."SystemVersion newVersion: 'Squeak3.9.1a'.SystemVersion current date: '14 Feb 2008'.self inform: 'You may now save this Version 3.9.1 alpha image.Subsequent updates will lead to 3.9.1.'.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 2/4/2008 16:21'!VersionText^ 'Welcome to the finale version of 3.9 of 7 of November 2006You will find more recent versions at http://www.squeak.org/This image will be used to produce other distributions such as a developer image and a fun with Squeak image. We hope that you will really appreciate this version and that Squeak will help you making your projects reality.You can also participate to Squeak at different kinds of levels. This can be as simple as:		- asking questions in the beginner list (beginners@lists.squeakfoundation.org) 		or in the dev list (squeak-dev@lists.squeakfoundation.org)		- answering questions 		- finding and reporting bugs at:		http://bugs.impara.de	- fixing them, testing fixes and commenting them	- writing tests for uncovered parts		- helping for the website	- creating new cool products, frameworks, applications in squeak	- writing articles....	We wish you a lot of fun and we would like to thanks all the persons that participated to make this release a really good one.We know who you are!!	Stephane Ducasse and Marcus Denker	stephane.ducasse@free.fr and denker@iam.unibe.ch'! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 2/4/2008 16:21'!WelcomeText	^ 'Welcome to Squeak - an open Smalltalk system.What is this?Squeak is an open source implementation of Smalltalk with an expansive and rapidly developing world of objects included. Squeak includes a fully integrated development environment, networking, sound synthesis and sampling, speech synthesis, 2 & 3D graphics, arithmetic and data structure libraries.The SqueakMap tool (click on -> "SMLoader open" to start it) tool provides easy access to a large range of packages and projects.Even the tools to produce the its own virtual machine (VM) are available so that you can build your own - and most of the VM is written in Smalltalk. Not only is all the Smalltalk source code included and changeable at will, it is also completely open and free. The Squeak system image runs bit-identically across all platforms, and VMs are available for just about every computer and operating system available. To find out exactly which version of Squeak this is click on -> "SystemVersion current" Further DocumentationThe primary website for Squeak is 	http://www.squeak.organd a large amount of online information is linked to from there. There are several very active mailing lists that you might consider joining.The Squeak Swiki at Georgia Tech is currently the primary source of online documentation and community information regarding Squeak.  It contains a FAQ, tutorials, and much more.  Visit it at:	http://minnow.cc.gatech.edu/squeakSqueak depends on the involvement and contributions of people like you. Please take a look around the website, join the mail list, report bugs, offer suggestions and most of all have fun with it.The Squeak LicenseSqueak is distributed for use and modification subject to a liberal open source license.  See the main Squeak website for details.  Unless stated to the contrary, works submitted for incorporation into or for distribution with Squeak shall be presumed subject to the same license.Portions of Squeak are:Copyright (c) 1996 Apple Computer, Inc.Copyright (c) 1997-2001 Walt Disney Company, and/orCopyrighted works of many other contributors.All rights reserved.'! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 2/4/2008 16:09'!openWindow: contents label: aLabel	StringHolder new 		contents: contents ;		openLabel: aLabel! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 2/14/2008 20:12'!script92	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.150.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.115.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.22.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/14/2008 20:13'!updateFrom7067	"self new updateFrom7067"		self script92. "loading multilingual is sync"	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/14/2008 20:13'!updateFrom7068	"self new updateFrom7067"			"SystemWindow allInstances do: [:each | each delete]."	self script92.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	SystemVersion newVersion: 'Squeak3.9.1'.	self flushCaches.	! !"ScriptLoader"!!FontTest methodsFor: 'testing' stamp: 'sd 2/4/2008 21:10' prior: 21250151!testDisplay	"self debug: #testDisplay"	| text font bb destPoint width |	text := 'test' asText.	font := TextStyle default fontOfSize: 21.	text addAttribute: (TextFontReference toFont: font).	bb := (Form extent: 100 @ 30) getCanvas privatePort.	bb combinationRule: Form paint.	font installOn: bb foregroundColor: Color black backgroundColor: Color white.	destPoint := font displayString: text on: bb from: 1 to: 4 at: 0@0 kern: 1.	width := text inject: 0 into: [:max :char | max + (font widthOf: char)].	self assert: destPoint x = (width + 4).	"bb destForm asMorph openInHand."! !!FontTest methodsFor: 'testing' stamp: 'sd 2/4/2008 21:10' prior: 21250802!testFallback	"self debug: #testFallback"	| text font bb destPoint |	text := (Character value: 257) asString asText.	font := TextStyle default fontOfSize: 21.	text addAttribute: (TextFontReference toFont: font).	bb := (Form extent: 100 @ 30) getCanvas privatePort.	bb combinationRule: Form paint.	font installOn: bb foregroundColor: Color black backgroundColor: Color white.	destPoint := font displayString: text on: bb from: 1 to: 1 at: 0@0 kern: 1.	"bb destForm asMorph openInHand."	self assert: destPoint x = ((font widthOf: $?) + 1).! !!FontTest methodsFor: 'testing' stamp: 'sd 2/4/2008 21:11' prior: 21254867!testResetAfterEmphasized	"self debug: #testResetAfterEmphasized"	| normal derivative |	normal := TextStyle defaultFont.	derivative := normal emphasized: 3.	self assert: (normal derivativeFonts at: 3) == derivative.	normal reset.	self assert: normal derivativeFonts isEmpty! !!MultiTextComposer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 25319628!composeEachRectangleIn: rectangles	| myLine lastChar |	1 to: rectangles size do: [:i | 		currCharIndex <= theText size ifFalse: [^false].		myLine := scanner 			composeFrom: currCharIndex 			inRectangle: (rectangles at: i)							firstLine: isFirstLine 			leftSide: i=1 			rightSide: i=rectangles size.		lines addLast: myLine.		presentationLines addLast: scanner getPresentationLine.		presentation ifNil: [presentation := scanner getPresentation]			ifNotNil: [presentation := presentation, scanner getPresentation].		actualHeight := actualHeight max: myLine lineHeight.  "includes font changes"		currCharIndex := myLine last + 1.		lastChar := theText at: myLine last.		lastChar = Character cr ifTrue: [^#cr].		wantsColumnBreaks ifTrue: [			lastChar = TextComposer characterForColumnBreak ifTrue: [^#columnBreak].		].	].	^false! !!MultiTextComposer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 25320718!multiComposeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY textStyle: argTextStyle text: argText container: argContainer wantsColumnBreaks: argWantsColumnBreaks	wantsColumnBreaks := argWantsColumnBreaks.	lines := argLinesCollection.	presentationLines := argLinesCollection copy.	theTextStyle := argTextStyle.	theText := argText.	theContainer := argContainer.	deltaCharIndex := argDelta.	currCharIndex := startCharIndex := argStart.	stopCharIndex := argStop.	prevLines := argPriorLines.	currentY := argStartY.	defaultLineHeight := theTextStyle lineGrid.	maxRightX := theContainer left.	possibleSlide := stopCharIndex < theText size and: [theContainer isMemberOf: Rectangle].	nowSliding := false.	prevIndex := 1.	scanner := MultiCompositionScanner new text: theText textStyle: theTextStyle.	scanner wantsColumnBreaks: wantsColumnBreaks.	isFirstLine := true.	self composeAllLines.	isFirstLine ifTrue: ["No space in container or empty text"		self 			addNullLineWithIndex: startCharIndex			andRectangle: (theContainer topLeft extent: 0@defaultLineHeight)	] ifFalse: [		self fixupLastLineIfCR	].	^{lines asArray. maxRightX}! !!MultiCharacterBlockScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25265616!buildCharacterBlockIn: para	| lineIndex runLength lineStop done stopCondition |	"handle nullText"	(para numberOfLines = 0 or: [text size = 0])		ifTrue:	[^ CharacterBlock new stringIndex: 1  "like being off end of string"					text: para text					topLeft: (para leftMarginForDisplayForLine: 1 alignment: (alignment ifNil:[textStyle alignment]))								@ para compositionRectangle top					extent: 0 @ textStyle lineGrid].	"find the line"	lineIndex := para lineIndexOfTop: characterPoint y.	destY := para topAtLineIndex: lineIndex.	line := para lines at: lineIndex.	rightMargin := para rightMarginForDisplay.	(lineIndex = para numberOfLines and:		[(destY + line lineHeight) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					self characterPointSetX: rightMargin]			ifFalse:	[characterPoint y < (para compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint := (para compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[self characterPointSetX: rightMargin]].	destX := (leftMargin := para leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment])).	nextLeftMargin:= para leftMarginForDisplayForLine: lineIndex+1 alignment: (alignment ifNil:[textStyle alignment]).	lastIndex := line first.	self setStopConditions.		"also sets font"	runLength := (text runLengthFor: line first).	characterIndex == nil		ifTrue:	[lineStop := line last  "characterBlockAtPoint"]		ifFalse:	[lineStop := characterIndex  "characterBlockForIndex"].	(runStopIndex := lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex := lineStop].	lastCharacterExtent := 0 @ line lineHeight.	spaceCount := 0. done  := false.	self handleIndentation.	[done]	whileFalse:	[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.	"see setStopConditions for stopping conditions for character block 	operations."	self lastCharacterExtentSetX: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition) ifTrue:		[characterIndex == nil			ifTrue: ["characterBlockAtPoint"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + (font descentKern @ 0)						extent: lastCharacterExtent]			ifFalse: ["characterBlockForIndex"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + ((font descentKern) - kern @ 0)						extent: lastCharacterExtent]]]! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25252218!characterBlockAtPoint: aPoint in: aParagraph	"Answer a CharacterBlock for character in aParagraph at point aPoint. It 	is assumed that aPoint has been transformed into coordinates appropriate 	to the text's destination form rectangle and the composition rectangle."	self initializeFromParagraph: aParagraph clippedBy: aParagraph clippingRectangle.	characterPoint := aPoint.	^self buildCharacterBlockIn: aParagraph! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25255478!characterBlockForIndex: targetIndex in: aParagraph 	"Answer a CharacterBlock for character in aParagraph at targetIndex. The 	coordinates in the CharacterBlock will be appropriate to the intersection 	of the destination form rectangle and the composition rectangle."	self 		initializeFromParagraph: aParagraph 		clippedBy: aParagraph clippingRectangle.	characterIndex := targetIndex.	characterPoint := 		aParagraph rightMarginForDisplay @ 			(aParagraph topAtLineIndex: 				(aParagraph lineIndexOfCharacterIndex: characterIndex)).	^self buildCharacterBlockIn: aParagraph! !!MultiCharacterBlockScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25268248!characterPointSetX: xVal	characterPoint := xVal @ characterPoint y! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25258309!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY := destY +  line lineHeight.				baselineY := line lineHeight.				lastCharacter := nil.				characterPoint := (nextLeftMargin ifNil: [leftMargin]) @ destY.				lastIndex := lastIndex + 1.				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter := CR.		characterPoint := destX @ destY.		self lastCharacterExtentSetX: rightMargin - destX.		^true! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25259341!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| leadingTab currentX |	characterIndex == nil ifFalse: [		"If the last character of the last line is a space,		and it crosses the right margin, then locating		the character block after it is impossible without this hack."		characterIndex > text size ifTrue: [			lastIndex := characterIndex.			characterPoint := (nextLeftMargin ifNil: [leftMargin]) @ (destY + line lineHeight).			^true]].	characterPoint x <= (destX + (lastCharacterExtent x // 2))		ifTrue:	[lastCharacter := (text at: lastIndex).				characterPoint := destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter := (text at: line last).				characterPoint := destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex := lastIndex + 1.	lastCharacter := text at: lastIndex.	currentX := destX + lastCharacterExtent x + kern.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint := currentX @ destY.	lastCharacter = Space ifFalse: [^ true].	"Yukky if next character is space or tab."	alignment = Justified ifTrue:		[self lastCharacterExtentSetX:			(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1))).		^ true].	true ifTrue: [^ true].	"NOTE:  I find no value to the following code, and so have defeated it - DI"	"See tabForDisplay for illumination on the following awfulness."	leadingTab := true.	line first to: lastIndex - 1 do:		[:index | (text at: index) ~= Tab ifTrue: [leadingTab := false]].	(alignment ~= Justified or: [leadingTab])		ifTrue:	[self lastCharacterExtentSetX: (textStyle nextTabXFrom: currentX					leftMargin: leftMargin rightMargin: rightMargin) -						currentX]		ifFalse:	[self lastCharacterExtentSetX:  (((currentX + (textStyle tabWidth -						(line justifiedTabDeltaFor: spaceCount))) -							currentX) max: 0)].	^ true! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25261447!endOfRun	"Before arriving at the cursor location, the selection has encountered an 	end of run. Answer false if the selection continues, true otherwise. Set 	up indexes for building the appropriate CharacterBlock."	| runLength lineStop |	(((characterIndex ~~ nil and:		[runStopIndex < characterIndex and: [runStopIndex < text size]])			or:	[characterIndex == nil and: [lastIndex < line last]]) or: [				((lastIndex < line last)				and: [((text at: lastIndex) leadingChar ~= (text at: lastIndex+1) leadingChar)					and: [lastIndex ~= characterIndex]])])		ifTrue:	["We're really at the end of a real run."				runLength := (text runLengthFor: (lastIndex := lastIndex + 1)).				characterIndex ~~ nil					ifTrue:	[lineStop := characterIndex	"scanning for index"]					ifFalse:	[lineStop := line last			"scanning for point"].				(runStopIndex := lastIndex + (runLength - 1)) > lineStop					ifTrue: 	[runStopIndex := lineStop].				self setStopConditions.				^false].	lastCharacter := text at: lastIndex.	characterPoint := destX @ destY.	((lastCharacter = Space and: [alignment = Justified])		or: [lastCharacter = Tab and: [lastSpaceOrTabExtent notNil]])		ifTrue: [lastCharacterExtent := lastSpaceOrTabExtent].	characterIndex ~~ nil		ifTrue:	["If scanning for an index and we've stopped on that index,				then we back destX off by the width of the character stopped on				(it will be pointing at the right side of the character) and return"				runStopIndex = characterIndex					ifTrue:	[self characterPointSetX: destX - lastCharacterExtent x.							^true].				"Otherwise the requested index was greater than the length of the				string.  Return string size + 1 as index, indicate further that off the				string by setting character to nil and the extent to 0."				lastIndex :=  lastIndex + 1.				lastCharacter := nil.				self lastCharacterExtentSetX: 0.				^true].	"Scanning for a point and either off the end of the line or off the end of the string."	runStopIndex = text size		ifTrue:	["off end of string"				lastIndex :=  lastIndex + 1.				lastCharacter := nil.				self lastCharacterExtentSetX: 0.				^true].	"just off end of line without crossing x"	lastIndex := lastIndex + 1.	^true! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25256145!indentationLevel: anInteger	super indentationLevel: anInteger.	nextLeftMargin := leftMargin.	indentationLevel timesRepeat: [		nextLeftMargin := textStyle nextTabXFrom: nextLeftMargin					leftMargin: leftMargin					rightMargin: rightMargin]! !!MultiCharacterBlockScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25268399!lastCharacterExtentSetX: xVal	lastCharacterExtent := xVal @ lastCharacterExtent y! !!MultiCharacterBlockScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25268565!lastSpaceOrTabExtentSetX: xVal	lastSpaceOrTabExtent := xVal @ lastSpaceOrTabExtent y! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25263755!paddedSpace	"When the line is justified, the spaces will not be the same as the font's 	space character. A padding of extra space must be considered in trying 	to find which character the cursor is pointing at. Answer whether the 	scanning has crossed the cursor."	| pad |	pad := 0.	spaceCount := spaceCount + 1.	pad := line justifiedPadFor: spaceCount.	lastSpaceOrTabExtent := lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX:  spaceWidth + pad.	(destX + lastSpaceOrTabExtent x)  >= characterPoint x		ifTrue: [lastCharacterExtent := lastSpaceOrTabExtent copy.				^self crossedX].	lastIndex := lastIndex + 1.	destX := destX + lastSpaceOrTabExtent x.	^ false! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25256474!placeEmbeddedObject: anchoredMorph	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	specialWidth := anchoredMorph width.	^ true! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25256824!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| encoding f nextDestX maxAscii startEncoding char charValue |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		char := (sourceString at: lastIndex).		charValue := char charCode.		charValue > maxAscii ifTrue: [charValue := maxAscii].		(encoding = 0 and: [(stopConditions at: charValue + 1) ~~ nil]) ifTrue: [			^ stops at: charValue + 1		].		nextDestX := destX + (self widthOf: char inFont: font).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25264523!setFont	specialWidth := nil.	super setFont! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25264921!tab	| currentX |	currentX := (alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse:			[textStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastSpaceOrTabExtent := lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX: (currentX - destX max: 0).	currentX >= characterPoint x		ifTrue: 			[lastCharacterExtent := lastSpaceOrTabExtent copy.			^ self crossedX].	destX := currentX.	lastIndex := lastIndex + 1.	^false! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31993038!discardDefault"	self discardDefault"	| ttc |	ttc := TTCFontDescription default.	ttc ifNotNil: [		TextConstants removeKey: ttc name asSymbol ifAbsent: [].	].! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31993287!familyName: n pointSize: s	"(self familyName: 'MultiMSGothic' pointSize: 14) pointSize"	| t ret index |	t := self registry at: n asSymbol ifAbsent: [#()].	t isEmpty ifTrue: [		t := (TextConstants at: #DefaultTextStyle) fontArray.		ret := t first.		ret pointSize >= s ifTrue: [^ ret].		index := 2.		[index <= t size and: [(t at: index) pointSize <= s]] whileTrue: [			ret := t at: index.			index := index + 1.		].		^ ret.	].	^ (TextStyle named: n) addNewFontSize: s.! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31993849!initialize"	self initialize"	| tt |	tt := TTCFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31994211!newTextStyleFromTT: descriptionArray	| array f textStyle styleName arrayOfArray |	arrayOfArray := self pointSizes collect: [:pt |		descriptionArray collect: [:ttc |			ttc ifNil: [nil] ifNotNil: [				f := (ttc size > 256)					ifTrue: [MultiTTCFont new initialize]					ifFalse: [TTCFont new initialize].				f ttcDescription: ttc.				f pointSize: pt.			].		].	].	array := arrayOfArray collect: [:fonts |		self newFontArray: fonts.	].	styleName := (array at: 1) familyName asSymbol.	textStyle := TextStyle fontArray: array.	TextConstants at: styleName put: textStyle.	self register: array at: styleName.	^ TextConstants at: styleName.! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31994949!newTextStyleFromTTFile: fileName"	TTCFontReader encodingTag: JapaneseEnvironment leadingChar.	self newTextStyleFromTTFile: 'C:\WINDOWS\Fonts\msmincho.TTC'	TTCFontReader encodingTag: 0.	self newTextStyleFromTTFile: 'C:\WINDOWS\Fonts\symbol.ttf'"	| description |	description := TTCFontDescription addFromTTFile: fileName.	^ self newTextStyleFromTT: description.! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31995877!removeStyleName: aString	| style symName |	symName := aString asSymbol.	style := TextConstants removeKey: symName ifAbsent: [].	style ifNotNil: [self unregister: symName].	TTCFontDescription removeDescriptionNamed: aString asString.! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31996200!setDefault"	self setDefault"	| tt |	tt := TTCFontDescription default.	tt ifNil: [TTCFontDescription setDefault].	tt := TTCFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31986994!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| destPoint font form encoding glyphInfo char charCode destY |	destPoint := aPoint.	glyphInfo := Array new: 5.	startIndex to: stopIndex do: [:charIndex |		char := aString at: charIndex.		encoding := char leadingChar + 1.		charCode := char charCode.		font := fontArray at: encoding.		((charCode between: font minAscii and: font maxAscii) not) ifTrue: [			charCode := font maxAscii].		self glyphInfoOf: char into: glyphInfo.		form := glyphInfo first.		(glyphInfo fifth ~= aBitBlt lastFont) ifTrue: [			glyphInfo fifth installOn: aBitBlt.		].		destY := baselineY - glyphInfo fourth. 		aBitBlt sourceForm: form.		aBitBlt destX: destPoint x.		aBitBlt destY: destY.		aBitBlt sourceOrigin: 0 @ 0.		aBitBlt width: form width.		aBitBlt height: form height.		aBitBlt copyBits.		destPoint := destPoint + (form width + kernDelta @ 0).	].	^ destPoint.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31988043!displayStringR2L: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	| destPoint font form encoding char charCode glyphInfo |	destPoint := aPoint.	glyphInfo := Array new: 5.	startIndex to: stopIndex do: [:charIndex |		char := aString at: charIndex.		encoding := char leadingChar + 1.		charCode := char charCode.		font := fontArray at: encoding.		((charCode between: font minAscii and: font maxAscii) not) ifTrue: [			charCode := font maxAscii].		self glyphInfoOf: char into: glyphInfo.		form := glyphInfo first.			(glyphInfo size > 4 and: [glyphInfo fifth notNil and: [glyphInfo fifth ~= aBitBlt lastFont]]) ifTrue: [				glyphInfo fifth installOn: aBitBlt.			].		aBitBlt sourceForm: form.		aBitBlt destX: destPoint x - form width.		aBitBlt destY: destPoint y.		aBitBlt sourceOrigin: 0 @ 0.		aBitBlt width: form width.		aBitBlt height: form height.		aBitBlt copyBits.		destPoint := destPoint - (form width + kernDelta @ 0).	].! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31989713!glyphInfoOf: aCharacter into: glyphInfoArray	| index f code |	index := aCharacter leadingChar + 1.	fontArray size < index ifTrue: [^ self questionGlyphInfoInto: glyphInfoArray].	(f := fontArray at: index) ifNil: [^ self questionGlyphInfoInto: glyphInfoArray].	code := aCharacter charCode.	((code between: f minAscii and: f maxAscii) not) ifTrue: [		^ self questionGlyphInfoInto: glyphInfoArray.	].	f glyphInfoOf: aCharacter into: glyphInfoArray.	glyphInfoArray at: 5 put: self.	^ glyphInfoArray.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31990417!initializeWithFontArray: anArray	fontArray := anArray.	"name := anArray first name."! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31990730!installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor	foregroundColor := fgColor.	fontArray do: [:s | s ifNotNil: [s installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor]].! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31991249!maxAsciiFor: encoding	| f |	f := (fontArray at: encoding+1).	f ifNotNil: [^ f maxAscii].	^ 0.! !!TTCFontSet methodsFor: 'objects from disk' stamp: 'sd 2/4/2008 21:20' prior: 31992515!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write areference to a known FontSet in the other system instead."	"a path to me"	dp := DiskProxy global: #TTCFontSet selector: #familyName:pointSize:			args: {self familyName. self pointSize}.	refStrm replace: self with: dp.	^ dp.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31991678!questionGlyphInfoInto: glyphInfoArray	| f form |	f := fontArray at: 1.	form := f formOf: $?.	glyphInfoArray at: 1 put: form;		at: 2 put: 0;		at: 3 put: form width;		at: 4 put: self.	^ glyphInfoArray.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31992312!widthOf: aCharacter	| encoding |	encoding := aCharacter leadingChar.	^ (fontArray at: encoding + 1) widthOf: aCharacter.! !!CombinedChar class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 19030333!parseCompositionMappingFrom: stream"	self halt.	self parseCompositionMapping"	| line fieldEnd point fieldStart compositions toNumber diacritical result |	toNumber := [:quad | ('16r', quad) asNumber].	Compositions := IdentityDictionary new: 2048.	Decompositions := IdentityDictionary new: 2048.	Diacriticals := IdentitySet new: 2048.	[(line := stream upTo: Character cr) size > 0] whileTrue: [		fieldEnd := line indexOf: $; startingAt: 1.		point := ('16r', (line copyFrom: 1 to: fieldEnd - 1)) asNumber.		2 to: 6 do: [:i |			fieldStart := fieldEnd + 1.			fieldEnd := line indexOf: $; startingAt: fieldStart.		].		compositions := line copyFrom: fieldStart to: fieldEnd - 1.		(compositions size > 0 and: [compositions first ~= $<]) ifTrue: [			compositions := compositions substrings collect: toNumber.			compositions size > 1 ifTrue: [				diacritical := compositions first.				Diacriticals add: diacritical.				result := compositions second.				(Decompositions includesKey: point) ifTrue: [					self error: 'should not happen'.				] ifFalse: [					Decompositions at: point put: (Array with: diacritical with: result).				].				(Compositions includesKey: diacritical) ifTrue: [					(Compositions at: diacritical) at: result put: point.				] ifFalse: [					Compositions at: diacritical						put: (IdentityDictionary new at: result put: point; yourself).				].			].		].	].! !!CombinedChar methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 19029505!add: char	| dict elem |	codes ifNil: [codes := Array with: char. combined := char. ^ true].	dict := Compositions at: combined charCode ifAbsent: [^ false].	elem := dict at: combined charCode ifAbsent: [^ false].	codes := codes copyWith: char.	combined := elem.	^ true.! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25307960!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	lastIndex:= lastIndex + 1.	^false! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25305124!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos |	line := textLine.	morphicOffset := offset.	lineY := line top + offset y.	lineHeight := line lineHeight.	rightMargin := line rightMargin + offset x.	lastIndex := line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	destX := runX := leftMargin.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: line width left height: lineHeight; copyBits].	lastIndex := line first.	leftInRun <= 0		ifTrue: [nowLeftInRun := text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun := leftInRun].	baselineY := lineY + line baseline.	destY := baselineY - font ascent.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	done := false.	string := text string.	[done] whileFalse:[		startIndex := lastIndex.		lastPos := destX@destY.		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex to: lastIndex at: lastPos kern: kern baselineY: baselineY].		"see setStopConditions for stopping conditions for displaying."		done := self perform: stopCondition.		"lastIndex > runStopIndex ifTrue: [done := true]."	].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!MultiDisplayScanner methodsFor: 'MVC-compatibility' stamp: 'sd 2/4/2008 21:22' prior: 25299915!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun startIndex string lastPos |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	morphicOffset := 0@0.	leftInRun := 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges := false.	paragraph := aParagraph.	foregroundColor := paragraphColor := aParagraph foregroundColor.	backgroundColor := aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt := nil]		ifFalse: [fillBlt := bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin := aParagraph rightMarginForDisplay.	lineY := aParagraph topAtLineIndex: linesInterval first.	bitBlt destForm deferUpdatesIn: visibleRectangle while: [		linesInterval do: 			[:lineIndex | 			leftMargin := aParagraph leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment]).			destX := (runX := leftMargin).			line := aParagraph lines at: lineIndex.			lineHeight := line lineHeight.			fillBlt == nil ifFalse:				[fillBlt destX: visibleRectangle left destY: lineY					width: visibleRectangle width height: lineHeight; copyBits].			lastIndex := line first.			leftInRun <= 0				ifTrue: [self setStopConditions.  "also sets the font"						leftInRun := text runLengthFor: line first].			baselineY := lineY + line baseline.			destY := baselineY - font ascent.  "Should have happened in setFont"			runLength := leftInRun.			runStopIndex := lastIndex + (runLength - 1) min: line last.			leftInRun := leftInRun - (runStopIndex - lastIndex + 1).			spaceCount := 0.			done := false.			string := text string.			self handleIndentation.			[done] whileFalse:[				startIndex := lastIndex.				lastPos := destX@destY.				stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex							in: string rightX: rightMargin stopConditions: stopConditions							kern: kern.				lastIndex >= startIndex ifTrue:[					font displayString: string on: bitBlt 						from: startIndex to: lastIndex at: lastPos kern: kern baselineY: baselineY].				"see setStopConditions for stopping conditions for displaying."				done := self perform: stopCondition].			fillBlt == nil ifFalse:				[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].			lineY := lineY + lineHeight]]! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25308673!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	lastIndex = line last ifTrue: [^true].	runX := destX.	runLength := text runLengthFor: (lastIndex := lastIndex + 1).	runStopIndex := lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!MultiDisplayScanner methodsFor: 'MVC-compatibility' stamp: 'sd 2/4/2008 21:22' prior: 25302890!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	super initializeFromParagraph: aParagraph clippedBy: clippingRectangle.	bitBlt := BitBlt asGrafPort toForm: aParagraph destinationForm.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt combinationRule: Form paint.	bitBlt colorMap:		(Bitmap with: 0      "Assumes 1-bit deep fonts"				with: (bitBlt destForm pixelValueFor: aParagraph foregroundColor)).	bitBlt clipRect: clippingRectangle.! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25309180!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	spaceCount := spaceCount + 1.	destX := destX + spaceWidth + (line justifiedPadFor: spaceCount).	lastIndex := lastIndex + 1.	^ false! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25307163!placeEmbeddedObject: anchoredMorph	anchoredMorph relativeTextAnchorPosition ifNotNil:[		anchoredMorph position: 			anchoredMorph relativeTextAnchorPosition +			(anchoredMorph owner textBounds origin x @ 0)			- (0@morphicOffset y) + (0@lineY).		^true	].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph ifTrue: [		anchoredMorph position: ((destX - anchoredMorph width)@lineY) - morphicOffset	] ifFalse: [		destY := lineY.		baselineY := lineY + anchoredMorph height..		runX := destX.		anchoredMorph 			displayOn: bitBlt destForm 			at: destX - anchoredMorph width @ destY			clippingBox: bitBlt clipRect			rule: Form blend			fillColor: Color white 	].	^ true! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25309690!plainTab	| oldX |	oldX := destX.	super plainTab.	fillBlt == nil ifFalse:		[fillBlt destX: oldX destY: destY width: destX - oldX height: font height; copyBits]! !!MultiDisplayScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25310518!presentationText: t	text := t.! !!MultiDisplayScanner methodsFor: 'multilingual scanning' stamp: 'sd 2/4/2008 21:22' prior: 25303653!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| encoding f nextDestX maxAscii startEncoding char charValue |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		char := (sourceString at: lastIndex).		charValue := char charCode.		charValue > maxAscii ifTrue: [charValue := maxAscii].		(encoding = 0 and: [(stopConditions at: charValue + 1) ~~ nil]) ifTrue: [			^ stops at: charValue + 1		].		nextDestX := destX + (self widthOf: char inFont: font).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!MultiDisplayScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25310744!setFont 	foregroundColor := paragraphColor.	super setFont.  "Sets font and emphasis bits, and maybe foregroundColor"	font installOn: bitBlt foregroundColor: foregroundColor backgroundColor: Color transparent.	text ifNotNil:[		baselineY := lineY + line baseline.		destY := baselineY - font ascent].! !!MultiDisplayScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25311123!setPort: aBitBlt	"Install the BitBlt to use"	bitBlt := aBitBlt.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt sourceForm: nil. "Make sure font installation won't be confused"! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25309938!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	self setConditionArray: (alignment = Justified ifTrue: [#paddedSpace])."	alignment = Justified ifTrue: [		stopConditions == DefaultStopConditions 			ifTrue:[stopConditions := stopConditions copy].		stopConditions at: Space asciiValue + 1 put: #paddedSpace]"! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25310384!tab	self plainTab.	lastIndex := lastIndex + 1.	^ false! !!MultiDisplayScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25311435!text: t textStyle: ts foreground: foreColor background: backColor fillBlt: blt ignoreColorChanges: shadowMode	text := t.	textStyle := ts. 	foregroundColor := paragraphColor := foreColor.	(backgroundColor := backColor) isTransparent ifFalse:		[fillBlt := blt.		fillBlt fillColor: backgroundColor].	ignoreColorChanges := shadowMode! !!MultiDisplayScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25311842!textColor: textColor	ignoreColorChanges ifTrue: [^ self].	foregroundColor := textColor! !!XTableForFixedFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 50983724!maxAscii: anInteger	maxCode := anInteger.! !!XTableForFixedFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 50984175!width: anInteger	width := anInteger.! !!MultiCharacterScanner class methodsFor: 'class initialization' stamp: 'sd 2/4/2008 21:22' prior: 25286574!initialize"	MultiCharacterScanner initialize"	| a |	a := Array new: 258.	a at: 1 + 1 put: #embeddedObject.	a at: Tab asciiValue + 1 put: #tab.	a at: CR asciiValue + 1 put: #cr.	a at: EndOfRun put: #endOfRun.	a at: CrossedX put: #crossedX.	NilCondition := a copy.	DefaultStopConditions := a copy.	PaddedSpaceCondition := a copy.	PaddedSpaceCondition at: Space asciiValue + 1 put: #paddedSpace.		SpaceCondition := a copy.	SpaceCondition at: Space asciiValue + 1 put: #space.! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25283851!addEmphasis: code	"Set the bold-ital-under-strike emphasis."	emphasisCode := emphasisCode bitOr: code! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25284033!addKern: kernDelta	"Set the current kern amount."	kern := kern + kernDelta! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'sd 2/4/2008 21:22' prior: 25270454!basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable, indexed by map. 	If dextX would exceed rightX, then return stops at: 258. 	Advance destX by the width of the character. If stopIndex has been	reached, then return stops at: 257. Optional. 	See Object documentation whatIsAPrimitive."	| ascii nextDestX char |	<primitive: 103>	lastIndex := startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[char := (sourceString at: lastIndex).			ascii := char asciiValue + 1.			(stops at: ascii) == nil ifFalse: [^stops at: ascii].			"Note: The following is querying the font about the width			since the primitive may have failed due to a non-trivial			mapping of characters to glyphs or a non-existing xTable."			nextDestX := destX + (font widthOf: char).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			destX := nextDestX + kernDelta.			lastIndex := lastIndex + 1].	lastIndex := stopIndex.	^stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25280079!embeddedObject	| savedIndex |	savedIndex := lastIndex.	text attributesAt: lastIndex do:[:attr| 		attr anchoredMorph ifNotNil:[			"Following may look strange but logic gets reversed.			If the morph fits on this line we're not done (return false for true) 			and if the morph won't fit we're done (return true for false)"			(self placeEmbeddedObject: attr anchoredMorph) ifFalse:[^true]]].	lastIndex := savedIndex + 1. "for multiple(!!) embedded morphs"	^false! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25280996!indentationLevel: anInteger	"set the number of tabs to put at the beginning of each line"	indentationLevel := anInteger! !!MultiCharacterScanner methodsFor: 'initialize' stamp: 'sd 2/4/2008 21:22' prior: 25269221!initialize	destX := destY := leftMargin := 0.! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25284188!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	text := aParagraph text.	textStyle := aParagraph textStyle. ! !!MultiCharacterScanner methodsFor: 'initialize' stamp: 'sd 2/4/2008 21:22' prior: 25269347!initializeStringMeasurer	stopConditions := Array new: 258.	stopConditions at: CrossedX put: #crossedX.	stopConditions at: EndOfRun put: #endOfRun.! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25281418!measureString: aString inFont: aFont from: startIndex to: stopIndex	"WARNING: In order to use this method the receiver has to be set up using #initializeStringMeasurer"	destX := destY := lastIndex := 0.	baselineY := aFont ascent.	xTable := aFont xTable.	font := aFont.  " added Dec 03, 2004 ""	map := aFont characterToGlyphMap."	self scanCharactersFrom: startIndex to: stopIndex in: aString rightX: 999999 stopConditions: stopConditions kern: 0.	^destX! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25281953!placeEmbeddedObject: anchoredMorph	"Place the anchoredMorph or return false if it cannot be placed.	In any event, advance destX by its width."	| w |	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	destX := destX + (w := anchoredMorph width).	(destX > rightMargin and: [(leftMargin + w) <= rightMargin])		ifTrue: ["Won't fit, but would on next line"				^ false].	lastIndex := lastIndex + 1.	self setFont.  "Force recalculation of emphasis for next run"	^ true! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25282574!plainTab	"This is the basic method of adjusting destX for a tab."	destX := (alignment == Justified and: [self leadingTab not])		ifTrue:		"embedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin]! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25283026!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isByteString) ifTrue: [^ self basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isWideString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].		startEncoding :=  (sourceString at: startIndex) leadingChar.		selector := (EncodedCharSet charsetAt: startEncoding) scanSelector.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stopConditions with: kernDelta).	].		^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'sd 2/4/2008 21:22' prior: 25272234!scanJapaneseCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		"xTable := f xTable.		maxAscii := xTable size - 2."		spaceWidth := f widthOf: Space.	] ifFalse: [		(font isMemberOf: HostFont) ifTrue: [			f := font.			maxAscii := f maxAscii.			spaceWidth := f widthOf: Space.		] ifFalse: [			maxAscii := font maxAscii.		].	].	[lastIndex <= stopIndex] whileTrue: [		"self halt."		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		ascii := (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii := maxAscii].		(encoding = 0 and: [(stopConditions at: ascii + 1) ~~ nil]) ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: (EncodedCharSet charsetAt: encoding)) ifTrue: [			self registerBreakableIndex.		].		nextDestX := destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [firstDestX ~= destX ifTrue: [^ stops at: CrossedX]].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'sd 2/4/2008 21:22' prior: 25274038!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| charCode encoding f maxAscii startEncoding combining combined combiningIndex c |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := font widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.		spaceWidth := font widthOf: Space.	].	combining := nil.	[lastIndex <= stopIndex] whileTrue: [		charCode := (sourceString at: lastIndex) charCode.		c := (sourceString at: lastIndex).		combining ifNil: [			combining := CombinedChar new.			combining add: c.			combiningIndex := lastIndex.			lastIndex := lastIndex + 1.		] ifNotNil: [			(combining add: c) ifFalse: [				self addCharToPresentation: (combined := combining combined).				combining := CombinedChar new.				combining add: c.				charCode := combined charCode.				encoding := combined leadingChar.				encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1.					(encoding = 0 and: [(stopConditions at: charCode + 1) ~~ nil]) ifTrue: [						^ stops at: charCode + 1					] ifFalse: [						 ^ stops at: EndOfRun					].				].				charCode > maxAscii ifTrue: [charCode := maxAscii].				""				(encoding = 0 and: [(stopConditions at: charCode + 1) ~~ nil]) ifTrue: [					combining ifNotNil: [						self addCharToPresentation: (combining combined).					].					^ stops at: charCode + 1				].				(self isBreakableAt: lastIndex in: sourceString in: Latin1Environment) ifTrue: [					self registerBreakableIndex.				].						destX > rightX ifTrue: [					destX ~= firstDestX ifTrue: [						lastIndex := combiningIndex.						self removeLastCharFromPresentation.						^ stops at: CrossedX]].				combiningIndex := lastIndex.				lastIndex := lastIndex + 1.			] ifTrue: [				lastIndex := lastIndex + 1.				numOfComposition := numOfComposition + 1.			].		].	].	lastIndex := stopIndex.	combining ifNotNil: [		combined := combining combined.		self addCharToPresentation: combined.		"assuming that there is always enough space for at least one character".		destX := destX + (self widthOf: combined inFont: font).	].	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'sd 2/4/2008 21:22' prior: 25276712!scanMultiCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		ascii := (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii := maxAscii].		(encoding = 0 and: [ascii < stopConditions size and: [(stopConditions at: ascii + 1) ~~ nil]]) ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: Latin1Environment) ifTrue: [			self registerBreakableIndex.		].		nextDestX := destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [destX ~= firstDestX ifTrue: [^ stops at: CrossedX]].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'sd 2/4/2008 21:22' prior: 25278328!scanMultiCharactersR2LFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Note that 'rightX' really means 'endX' in R2L context.  Ie.  rightX is usually smaller than destX."	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		ascii := (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii := maxAscii].		(encoding = 0 and: [(stopConditions at: ascii + 1) ~~ nil]) ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: Latin1Environment) ifTrue: [			self registerBreakableIndex.		].		nextDestX := destX - (font widthOf: (sourceString at: lastIndex)).		nextDestX < rightX ifTrue: [^ stops at: CrossedX].		destX := nextDestX - kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25284395!setActualFont: aFont	"Set the basal font to an isolated font reference."	font := aFont! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25284563!setAlignment: style	alignment := style.	! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25284684!setConditionArray: aSymbol	aSymbol == #paddedSpace ifTrue: [^stopConditions := PaddedSpaceCondition "copy"].	"aSymbol == #space ifTrue: [^stopConditions := SpaceCondition copy]."	aSymbol == nil ifTrue: [^stopConditions := NilCondition "copy"].	self error: 'undefined stopcondition for space character'.! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25285070!setFont	| priorFont |	"Set the font and other emphasis."	priorFont := font.	text == nil ifFalse:[		emphasisCode := 0.		kern := 0.		indentationLevel := 0.		alignment := textStyle alignment.		font := nil.		(text attributesAt: lastIndex forStyle: textStyle)			do: [:att | att emphasizeScanner: self]].	font == nil ifTrue:		[self setFont: textStyle defaultFontIndex].	font := font emphasized: emphasisCode.	priorFont ifNotNil: [destX := destX + priorFont descentKern].	destX := destX - font descentKern.	"NOTE: next statement should be removed when clipping works"	leftMargin ifNotNil: [destX := destX max: leftMargin].	kern := kern - font baseKern.	"Install various parameters from the font."	spaceWidth := font widthOf: Space.	xTable := font xTable."	map := font characterToGlyphMap."	stopConditions := DefaultStopConditions.! !!MultiCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25286181!text: t textStyle: ts	text := t.	textStyle := ts! !!MultiCharacterScanner methodsFor: 'initialize' stamp: 'sd 2/4/2008 21:22' prior: 25269579!wantsColumnBreaks: aBoolean	wantsColumnBreaks := aBoolean! !!SparseXTable methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:12' prior: 30580940!tableFor: code	| div t table |	div := code // 65536.	t := xTables at: div ifAbsent: [table := Array new: 65536 withAll: 0. xTables at: div put: table. table].	^ t.! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:32' prior: 19956837!additionalRangesForJapanese	| basics |	basics := {		Array with: 16r5C with: 16rFF3C.		Array with: 16r3013 with: 16rFFFD.	}.	^ basics! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:32' prior: 19957073!additionalRangesForKorean	| basics |	basics := {		Array with: 16rA1 with: 16rFFE6C.		Array with: 16r3000 with: 16rFFFD.	}.	^ basics! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:33' prior: 19957308!override: chars with: otherFileName ranges: pairArray transcodingTable: table additionalRange: additionalRange	| other rangeStream currentRange newChars code form u newArray j |	other := BDFFontReader readOnlyFileNamed: otherFileName.	rangeStream := ReadStream on: pairArray.	currentRange := rangeStream next.	newChars := PluggableSet new.	newChars hashBlock: [:elem | (elem at: 2) hash].	newChars equalBlock: [:a :b | (a at: 2) = (b at: 2)].	other readChars do: [:array | 		code := array at: 2.		"code printStringHex printString displayAt: 0@0."		code > currentRange last ifTrue: [			[rangeStream atEnd not and: [currentRange := rangeStream next. currentRange last < code]] whileTrue.			rangeStream atEnd ifTrue: [				newChars addAll: chars.				^ newChars.			].		].		(code between: currentRange first and: currentRange last) ifTrue: [			form := array at: 1.			form ifNotNil: [				j := array at: 2.				u := table at: (((j // 256) - 33 * 94 + ((j \\ 256) - 33)) + 1).				u ~= -1 ifTrue: [					array at: 2 put: u.					newChars add: array.					additionalRange do: [:e |						e first = (array at: 2) ifTrue: [							newArray := array clone.							newArray at: 2 put: e second.							newChars add: newArray						].					]				].			].		].	].	self error: 'should not reach here'.! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:34' prior: 19959006!rangesForJapanese	| basics etc |	basics := {		Array with: 16r5C with: 16r5C.		Array with: 16rA2 with: 16rA3.		Array with: 16rA7 with: 16rA8.		Array with: 16rAC with: 16rAC.		Array with: 16rB0 with: 16rB1.		Array with: 16rB4 with: 16rB4.		Array with: 16rB6 with: 16rB6.		Array with: 16rD7 with: 16rD7.		Array with: 16rF7 with: 16rF7	}.	etc := {		Array with: 16r370 with: 16r3FF. "greek"		Array with: 16r400 with: 16r52F. "cyrillic"		Array with: 16r1D00 with: 16r1D7F. "phonetic"		Array with: 16r1E00 with: 16r1EFF. "latin extended additional"		Array with: 16r2000 with: 16r206F. "general punctuation"		Array with: 16r20A0 with: 16r20CF. "currency symbols"		Array with: 16r2100 with: 16r214F. "letterlike"		Array with: 16r2150 with: 16r218F. "number form"		Array with: 16r2190 with: 16r21FF. "arrows"		Array with: 16r2200 with: 16r22FF. "math operators"		Array with: 16r2300 with: 16r23FF. "misc tech"		Array with: 16r2460 with: 16r24FF. "enclosed alnum"		Array with: 16r2500 with: 16r257F. "box drawing"		Array with: 16r2580 with: 16r259F. "box elem"		Array with: 16r25A0 with: 16r25FF. "geometric shapes"		Array with: 16r2600 with: 16r26FF. "misc symbols"		Array with: 16r2700 with: 16r27BF. "dingbats"		Array with: 16r27C0 with: 16r27EF. "misc math A"		Array with: 16r27F0 with: 16r27FF. "supplimental arrow A"		Array with: 16r2900 with: 16r297F. "supplimental arrow B"		Array with: 16r2980 with: 16r29FF. "misc math B"		Array with: 16r2A00 with: 16r2AFF. "supplimental math op"		Array with: 16r2900 with: 16r297F. "supplimental arrow B"		Array with: 16r2E80 with: 16r2EFF. "cjk radicals suppliment"		Array with: 16r2F00 with: 16r2FDF. "kangxi radicals"		Array with: 16r3000 with: 16r303F. "cjk symbols"		Array with: 16r3040 with: 16r309F. "hiragana"		Array with: 16r30A0 with: 16r30FF. "katakana"		Array with: 16r3190 with: 16r319F. "kanbun"		Array with: 16r31F0 with: 16r31FF. "katakana extension"		Array with: 16r3200 with: 16r32FF. "enclosed CJK"		Array with: 16r3300 with: 16r33FF. "CJK compatibility"		Array with: 16r3400 with: 16r4DBF. "CJK unified extension A"		Array with: 16r4E00 with: 16r9FAF. "CJK ideograph"		Array with: 16rF900 with: 16rFAFF. "CJK compatiblity ideograph"		Array with: 16rFE30 with: 16rFE4F. "CJK compatiblity forms"		Array with: 16rFF00 with: 16rFFEF. "half and full"		Array with: 16rFFFF with: 16rFFFF. "sentinel"	}.	^ basics, etc.! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:34' prior: 19961521!rangesForKorean	| basics etc |	basics := {		Array with: 16rA1 with: 16rFF	}.	etc := {		Array with: 16r100 with: 16r17F. "extended latin"		Array with: 16r370 with: 16r3FF. "greek"		Array with: 16r400 with: 16r52F. "cyrillic"		Array with: 16r2000 with: 16r206F. "general punctuation"		Array with: 16r2100 with: 16r214F. "letterlike"		Array with: 16r2150 with: 16r218F. "number form"		Array with: 16r2190 with: 16r21FF. "arrows"		Array with: 16r2200 with: 16r22FF. "math operators"		Array with: 16r2300 with: 16r23FF. "misc tech"		Array with: 16r2460 with: 16r24FF. "enclosed alnum"		Array with: 16r2500 with: 16r257F. "box drawing"		Array with: 16r2580 with: 16r259F. "box elem"		Array with: 16r25A0 with: 16r25FF. "geometric shapes"		Array with: 16r2600 with: 16r26FF. "misc symbols"		Array with: 16r3000 with: 16r303F. "cjk symbols"		Array with: 16r3040 with: 16r309F. "hiragana"		Array with: 16r30A0 with: 16r30FF. "katakana"		Array with: 16r3190 with: 16r319F. "kanbun"		Array with: 16r31F0 with: 16r31FF. "katakana extension"		Array with: 16r3200 with: 16r32FF. "enclosed CJK"		Array with: 16r3300 with: 16r33FF. "CJK compatibility"		Array with: 16r4E00 with: 16r9FAF. "CJK ideograph"		Array with: 16rAC00 with: 16rD7AF. "Hangul Syllables"		Array with: 16rF900 with: 16rFAFF. "CJK compatiblity ideograph"		Array with: 16rFF00 with: 16rFFEF. "half and full"	}.	^ basics, etc.! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:35' prior: 19963337!readCharactersInRanges: ranges storeInto: chars	| array form code rangeStream currentRange |	rangeStream := ReadStream on: ranges.	currentRange := rangeStream next.	[true] whileTrue: [		array := self readOneCharacter.		array second ifNil: [^ self].		code := array at: 2.		code > currentRange last ifTrue: [			[rangeStream atEnd not and: [currentRange := rangeStream next. currentRange last < code]] whileTrue.			rangeStream atEnd ifTrue: [^ self].		].		(code between: currentRange first and: currentRange last) ifTrue: [			form := array at: 1.			form ifNotNil: [				chars add: array.			].		].	].! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:09' prior: 19964043!readRanges: ranges	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx width blt lastAscii pointSize ret lastValue start end |	form := encoding := bbx := nil.	self initialize.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	(properties includesKey: 'POINT_SIZE' asSymbol) ifTrue: [		pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.	] ifFalse: [		pointSize := (ascent + descent) * 72 // 96.	].	maxWidth := 0.	minAscii := 16r200000.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	self readCharactersInRanges: ranges storeInto: chars.	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum := chars size. "undefined encodings make this different"	chars do: [:array |		encoding := array at: 2.		bbx := array at: 3..		width := bbx at: 1.		maxWidth := maxWidth max: width.		minAscii := minAscii min: encoding.		maxAscii := maxAscii max: encoding.		strikeWidth := strikeWidth + width.	].	glyphs := Form extent: strikeWidth@height.	blt := BitBlt toForm: glyphs.	start := (ranges collect: [:r | r first]) min.	end := (ranges collect: [:r | r second]) max + 3.	xTable := SparseLargeTable new: end chunkSize: 64 arrayClass: Array base: start +1 defaultValue: -1.	lastAscii := start.	xTable at: lastAscii + 2 put: 0.	1 to: charsNum do: [:i |		form := (chars at: i) first.		encoding := (chars at: i) second.		bbx := (chars at: i) third.		"lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)]."		lastValue := xTable at: lastAscii + 1 + 1.		xTable at: encoding + 1 put: lastValue.		blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))				extent: (bbx at: 1)@(bbx at: 2))			from: 0@0 in: form.		xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).		lastAscii := encoding.	].	xTable at: xTable size put: (xTable at: xTable size - 1).	xTable zapDefaultOnlyEntries.	ret := Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:39' prior: 19966694!readRanges: ranges overrideWith: otherFileName otherRanges: otherRanges additionalOverrideRange: additionalRange	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx width blt lastAscii pointSize ret lastValue start end |	form := encoding := bbx := nil.	self initialize.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	(properties includesKey: 'POINT_SIZE' asSymbol) ifTrue: [		pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.	] ifFalse: [		pointSize := (ascent + descent) * 72 // 96.	].				maxWidth := 0.	minAscii := 16r200000.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	self readCharactersInRanges: ranges storeInto: chars.	chars := self override: chars with: otherFileName ranges: otherRanges transcodingTable: (UCSTable jisx0208Table) additionalRange: additionalRange.	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum := chars size. "undefined encodings make this different"		chars do: [:array |		encoding := array at: 2.		bbx := array at: 3..		width := bbx at: 1.		maxWidth := maxWidth max: width.		minAscii := minAscii min: encoding.		maxAscii := maxAscii max: encoding.		strikeWidth := strikeWidth + width.	].	glyphs := Form extent: strikeWidth@height.	blt := BitBlt toForm: glyphs.	start := ((ranges collect: [:r | r first]), (additionalRange collect: [:r2 | r2 first])) min.	end := ((ranges collect: [:r | r second]), (additionalRange collect: [:r2 | r2 second])) max + 3.	"xRange := Array with: (Array with: ((ranges collect: [:r | r first]), (additionalRange collect: [:r2 | r2 first])) min						with: (((ranges collect: [:r | r second]), (additionalRange collect: [:r2 | r2 second])) max + 2))."	"xTable := XTableForUnicodeFont new		ranges: xRange."	xTable := SparseLargeTable new: end chunkSize: 64 arrayClass: Array base: start defaultValue: -1.	lastAscii := start.	xTable at: lastAscii + 2 put: 0.	1 to: charsNum do: [:i |		form := (chars at: i) first.		encoding := (chars at: i) second.		bbx := (chars at: i) third.		"lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)]."		lastValue := xTable at: lastAscii + 1 + 1.		xTable at: encoding + 1 put: lastValue.		blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))				extent: (bbx at: 1)@(bbx at: 2))			from: 0@0 in: form.		xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).		lastAscii := encoding.	].	xTable at: xTable size put: (xTable at: xTable size - 1).	xTable zapDefaultOnlyEntries.	ret := Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!XTableForUnicodeFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 50984465!at: indexPlusOne	| index |	index := indexPlusOne.	ranges with: xTables do: [:range :xTable |		(range first <= index and: [index <= range last]) ifTrue: [			^ xTable at: index - range first + 1.		].	].	^ 0.! !!XTableForUnicodeFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 50985056!ranges: pairArray	xTables := Array new: 0.	pairArray do: [:range |		xTables := xTables copyWith: (Array new: range last - range first + 1 withAll: 0).	].	ranges := pairArray.! !!StrikeFontFixer class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31127894!initialize"	StrikeFontFixer initialize"	| d |	self initializeNoFontTable.	d := Array new: 256.	0 to: 127 do: [:i | d at: i+1 put: i].	16r80 to: 16r9F do: [:i | d at: i+1 put: nil].	d at: 16rA0+1 put: 16r20.	d at: 16rA1+1 put: 16rC1.	d at: 16rA2+1 put: 16rA2.	d at: 16rA3+1 put: 16rA3.	d at: 16rA4+1 put: 16rA9. "CURRENCY SIGN"	d at: 16rA5+1 put: 16rB4.	d at: 16rA6+1 put: 16r7C. "BROKEN BAR"	d at: 16rA7+1 put: 16rA4.	d at: 16rA8+1 put: 16r80. "DIAERESIS"	d at: 16rA9+1 put: 16rA9.	d at: 16rAA+1 put: 16rBB.	d at: 16rAB+1 put: 16rC7.	d at: 16rAC+1 put: 16rD1. "NOT SIGN"	d at: 16rAD+1 put: 16rD0.	d at: 16rAE+1 put: 16rA8.	d at: 16rAF+1 put: 16rD1. "MACRON"	d at: 16rB0+1 put: 16rA1.	d at: 16rB1+1 put: 16r2B. "PLUS-MINUS SIGN"	d at: 16rB2+1 put: 16rAB. "SUPERSCRIPT TWO"	d at: 16rB3+1 put: 16rAB. "SUPERSCRIPT THREE"	d at: 16rB4+1 put: 16rAB.	d at: 16rB5+1 put: 16r75. "MICRO SIGN"	d at: 16rB6+1 put: 16rA6.	d at: 16rB7+1 put: 16rA5.	d at: 16rB8+1 put: 16r82. "CEDILLA"	d at: 16rB9+1 put: 16rAB. "SUPERSCRIPT ONE"	d at: 16rBA+1 put: 16rBC.	d at: 16rBB+1 put: 16rC8.	d at: 16rBC+1 put: 16r4D. "VULGAR FRACTION ONE QUARTER"	d at: 16rBD+1 put: 16r4D. "VULGAR FRACTIOIN ONE HALF"	d at: 16rBE+1 put: 16r4D. "VALGAR FRACTION THREE QUARTERS"	d at: 16rBF+1 put: 16rC0.	d at: 16rC0+1 put: 16rCB.	d at: 16rC1+1 put: 16rCB. "CAPITAL A WITH ACUTE"	d at: 16rC2+1 put: 16rCB. "CAPITAL A WITH CIRCUMFLEX"	d at: 16rC3+1 put: 16rCC.	d at: 16rC4+1 put: 16r80.	d at: 16rC5+1 put: 16r81.	d at: 16rC6+1 put: 16rAE.	d at: 16rC7+1 put: 16r82.	d at: 16rC8+1 put: 16r83. "CAPITAL E WITH GRAVE"	d at: 16rC9+1 put: 16r83.	d at: 16rCA+1 put: 16r83. "CAPITAL E WITH CIRCUMFLEX"	d at: 16rCB+1 put: 16r83. "CAPITAL E WITH DIAERESIS"	d at: 16rCC+1 put: 16r49. "CAPITAL I WITH GRAVE"	d at: 16rCD+1 put: 16r49. "CAPITAL I WITH ACUTE"	d at: 16rCE+1 put: 16r49. "CAPITAL I WITH CIRCUMFLEX"	d at: 16rCF+1 put: 16r49. "CAPITAL I WITH DIAERESIS"	d at: 16rD0+1 put: 16r44. "CAPITAL ETH"	d at: 16rD1+1 put: 16r84.	d at: 16rD2+1 put: 16rCD. "CAPITAL O WITH GRAVE"	d at: 16rD3+1 put: 16rCD. "CAPITAL O WITH ACUTE"	d at: 16rD4+1 put: 16rCD. "CAPITAL O WITH CIRCUMFLEX"	d at: 16rD5+1 put: 16rCD.	d at: 16rD6+1 put: 16r85.	d at: 16rD7+1 put: 16r2B. "MULTIPLICATION SIGN"	d at: 16rD8+1 put: 16rBF.	d at: 16rD9+1 put: 16r86. "CAPITAL U WITH GRAVE"	d at: 16rDA+1 put: 16r86. "CAPITAL U WITH ACUTE"	d at: 16rDB+1 put: 16r86. "CAPITAL U WITH CIRCUMFLEX"	d at: 16rDC+1 put: 16r86. "CAPTIAL U WITH DIAERESIS"	d at: 16rDD+1 put: 16r59. "CAPITAL Y WITH ACUTE"	d at: 16rDE+1 put: 16r50. "CAPITAL THORN"	d at: 16rDF+1 put: 16rA7.	d at: 16rE0+1 put: 16r88.	d at: 16rE1+1 put: 16r87.	d at: 16rE2+1 put: 16r89.	d at: 16rE3+1 put: 16r8B.	d at: 16rE4+1 put: 16r8A.	d at: 16rE5+1 put: 16r8C.	d at: 16rE6+1 put: 16rBE.	d at: 16rE7+1 put: 16r8D.	d at: 16rE8+1 put: 16r8F.	d at: 16rE9+1 put: 16r8E.	d at: 16rEA+1 put: 16r90.	d at: 16rEB+1 put: 16r91.	d at: 16rEC+1 put: 16r93.	d at: 16rED+1 put: 16r92.	d at: 16rEE+1 put: 16r94.	d at: 16rEF+1 put: 16r95.	d at: 16rF0+1 put: 16r64. "SMALL ETH"	d at: 16rF1+1 put: 16r96.	d at: 16rF2+1 put: 16r98.	d at: 16rF3+1 put: 16r97.	d at: 16rF4+1 put: 16r99.	d at: 16rF5+1 put: 16r9B.	d at: 16rF6+1 put: 16r9A.	d at: 16rF7+1 put: 16r2D. "DIVISION SIGN"	d at: 16rF8+1 put: 16rBF.	d at: 16rF9+1 put: 16r9D.	d at: 16rFA+1 put: 16r9C.	d at: 16rFB+1 put: 16r9E.	d at: 16rFC+1 put: 16r9F.	d at: 16rFD+1 put: 16rD8. "SMALL Y WITH ACUTE"	d at: 16rFE+1 put: 16r70. "SMALL THORN"	d at: 16rFF+1 put: 16rD8.	MappingTable := d.! !!StrikeFontFixer class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31131578!initializeNoFontTable	| n |	n := #(	16rA4 "CURRENCY SIGN"	16rA6 "BROKEN BAR"	16rA8 "DIAERESIS"	16rAC "NOT SIGN"	16rAF "MACRON"	16rB1 "PLUS-MINUS SIGN"	16rB2 "SUPERSCRIPT TWO"	16rB3 "SUPERSCRIPT THREE"	16rB5 "MICRO SIGN"	16rB8 "CEDILLA"	16rB9 "SUPERSCRIPT ONE"	16rBC "VULGAR FRACTION ONE QUARTER"	16rBD "VULGAR FRACTIOIN ONE HALF"	16rBE "VALGAR FRACTION THREE QUARTERS"	16rC1 "CAPITAL A WITH ACUTE"	16rC2 "CAPITAL A WITH CIRCUMFLEX"	16rC8 "CAPITAL E WITH GRAVE"	16rCA "CAPITAL E WITH CIRCUMFLEX"	16rCB "CAPITAL E WITH DIAERESIS"	16rCC "CAPITAL I WITH GRAVE"	16rCD "CAPITAL I WITH ACUTE"	16rCE "CAPITAL I WITH CIRCUMFLEX"	16rCF "CAPITAL I WITH DIAERESIS"	16rD0 "CAPITAL ETH"	16rD2 "CAPITAL O WITH GRAVE"	16rD3 "CAPITAL O WITH ACUTE"	16rD4 "CAPITAL O WITH CIRCUMFLEX"	16rD7 "MULTIPLICATION SIGN"	16rD9 "CAPITAL U WITH GRAVE"	16rDA "CAPITAL U WITH ACUTE"	16rDB "CAPITAL U WITH CIRCUMFLEX"	16rDD "CAPITAL Y WITH ACUTE"	16rDE "CAPITAL THORN"	16rF0 "SMALL ETH"	16rF7 "DIVISION SIGN"	16rFD "SMALL Y WITH ACUTE"	16rFE "SMALL THORN"	).	NoFontTable := n.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:12' prior: 31125604!characterFormAt: aCharacter at: aPoint	| f |	f := charForms at: aCharacter asciiValue + 1.	(f magnifyBy: 3) displayAt: aPoint.	^ f.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:13' prior: 31125825!displayOn: aDisplayObject at: aPoint magnifyBy: aNumber	| form hStep vStep bb source nextPoint |	hStep := (strikeFont maxWidth * aNumber * 1.2) asInteger.	vStep := (strikeFont height * aNumber *  1.2) asInteger.		form := Form extent: (hStep * 16)@(vStep * 16).	bb := BitBlt toForm: form.	0 to: 15 do: [:i |		1 to: 16 do: [:j |			source := ((charForms at: (i * 16 + j)) magnifyBy: aNumber).			nextPoint := (hStep * (j - 1)@(vStep * i)).			bb copy: ((nextPoint+((hStep@vStep - source extent) // 2)) extent: source extent)				from: 0@0 in: source fillColor: Color black rule: Form over.		].	].	form displayOn: aDisplayObject at: aPoint.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:13' prior: 31126554!font: aStrikeFont	strikeFont := aStrikeFont.	self forms.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:13' prior: 31126895!initialize	charForms := Array new: 256.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:13' prior: 31127137!storeEditedGlyphsOn: aStream	| n |	NoFontTable do: [:i |		n := strikeFont name.		(n beginsWith: 'NewYork') ifTrue: [n := 'NewYork'].		aStream nextPutAll: '((StrikeFont familyName: ''', n, ''' size: ',			strikeFont height asString, ')'.		aStream nextPutAll: ' characterFormAt: '.		aStream nextPutAll: '(Character value: ', i asString, ')'.		aStream nextPutAll: ' put: '.		(strikeFont characterFormAt: (Character value: i)) storeOn: aStream base: 2.		aStream nextPutAll: ')!!'.		aStream nextPut: Character cr.		aStream nextPut: Character cr.	].! !!ImmX11 methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:21' prior: 22084117!keyboardFocusForAMorph: aMorph	| left bottom pos |	aMorph ifNil: [^ self].	[		pos := aMorph preferredKeyboardPosition.		left := (pos x min: Display width max: 0) asInteger.		bottom := (pos y min: Display height max: 0) asInteger			 + (aMorph paragraph				characterBlockForIndex: aMorph editor selectionInterval first) height.		self setCompositionWindowPositionX: left y: bottom	] on: Error	do: [:ex |].! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:11' prior: 25316581!access: char at: index	| wcache entry |	wcache := self cache.	entry := wcache at: index.	wcache replaceFrom: index to: wcache size - 1 with: wcache startingAt: index + 1.	wcache at: wcache size put: entry.! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:11' prior: 25316874!at: char put: form	| wcache |	wcache := self cache.	wcache replaceFrom: 1 to: wcache size - 1 with: wcache startingAt: 2.	wcache at: wcache size		put: (Array with: char asciiValue with: foregroundColor with: form).! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:12' prior: 25317356!formOf: char	| newForm |	self hasCached: char ifTrue: [:form :index |		self access: char at: index.		^ form.	].	newForm := self computeForm: char.	self at: char put: newForm.	^ newForm.! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:12' prior: 25317632!glyphInfoOf: char into: glyphInfoArray	| newForm |	self hasCached: char ifTrue: [:form :index |		self access: char at: index.		glyphInfoArray at: 1 put: form;			at: 2 put: 0;			at: 3 put: form width;			at: 4 put: (self ascentOf: char);			at: 5 put: self.		^ glyphInfoArray.	].	newForm := self computeForm: char.	self at: char put: newForm.	glyphInfoArray at: 1 put: newForm;		at: 2 put: 0;		at: 3 put: newForm width;		at: 4 put: (self ascentOf: char);		at: 5 put: self.	^ glyphInfoArray.! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:12' prior: 25318223!hasCached: char ifTrue: twoArgBlock	| value elem |	value := char asciiValue.	self cache size to: 1 by: -1 do: [:i |		elem := self cache at: i.		(elem first = value and: [elem second = foregroundColor]) ifTrue: [			^ twoArgBlock value: elem third value: i.		].	].	^ false.! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:12' prior: 25318686!widthOf: char	"This method cannot use #formOf: because formOf: discriminates the color and causes unnecessary bitmap creation."	| newForm |	self hasCached: char ifTrue: [:form :index |		self access: char at: index.		^ form width.	].	newForm := self computeForm: char.	self at: char put: newForm.	^ newForm width.! !!EFontBDFFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 20:28' prior: 19953661!readCharactersInRangeFrom: start to: stop totalNums: upToNum storeInto: chars	| array form code |	1 to: upToNum do: [:i |		array := self readOneCharacter.		code := array at: 2.		code > stop ifTrue: [^ self].		(code between: start and: stop) ifTrue: [			form := array at: 1.			form ifNotNil: [				chars add: array.			].		].	].! !!EFontBDFFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:21' prior: 19954085!readFrom: start to: end	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx width blt lastAscii pointSize ret lastValue |	form := encoding := bbx := nil.	self initialize.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	(properties includesKey: 'POINT_SIZE' asSymbol) ifTrue: [		pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.	] ifFalse: [		pointSize := (ascent + descent) * 72 // 96.	].				maxWidth := 0.	minAscii := 16r200000.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	self readCharactersInRangeFrom: start to: end totalNums: charsNum storeInto: chars.	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum := chars size. "undefined encodings make this different"	chars do: [:array |		encoding := array at: 2.		bbx := array at: 3..		width := bbx at: 1.		maxWidth := maxWidth max: width.		minAscii := minAscii min: encoding.		maxAscii := maxAscii max: encoding.		strikeWidth := strikeWidth + width.	].	glyphs := Form extent: strikeWidth@height.	blt := BitBlt toForm: glyphs.	"xTable := XTableForUnicodeFont new ranges: (Array with: (Array with: start with: end))."	xTable := SparseLargeTable new: end + 3 chunkSize: 32 arrayClass: Array base: start + 1 defaultValue: -1.	lastAscii := start.		1 to: charsNum do: [:i |		form := (chars at: i) first.		encoding := (chars at: i) second.		bbx := (chars at: i) third.		"lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)]."		lastValue := xTable at: lastAscii + 1 + 1.		xTable at: encoding + 1 put: lastValue.		blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))				extent: (bbx at: 1)@(bbx at: 2))			from: 0@0 in: form.		xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).		lastAscii := encoding.	].	xTable zapDefaultOnlyEntries.	ret _ Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!LanguageEditor methodsFor: 'gui methods' stamp: 'sd 2/4/2008 21:21' prior: 22862070!codeSelectedTranslationAsMimeString	| keys code tmpStream s2 gzs cont |	keys := selectedTranslations				collect: [:key | self translations at: key].	code := String				streamContents: [:aStream | self translator fileOutOn: aStream keys: keys].	tmpStream := MultiByteBinaryOrTextStream on: ''.	tmpStream converter: UTF8TextConverter new.	translator fileOutHeaderOn: tmpStream.	tmpStream nextPutAll: code.	s2 := RWBinaryOrTextStream on: ''.	gzs := GZipWriteStream on: s2.	tmpStream reset.	gzs nextPutAll: (tmpStream binary contentsOfEntireFile asString) contents.	gzs close.	s2 reset.	cont := String streamContents: [:strm |		strm nextPutAll: '"Gzip+Base64 encoded translation for;'; cr.		strm nextPutAll: '#('.		keys do: [:each | strm  nextPutAll: '''', each, ''' '.].		strm nextPutAll: ')"'; cr; cr.		strm nextPutAll: 'NaturalLanguageTranslator loadForLocaleIsoString: '.		strm nextPut: $'.		strm nextPutAll: translator localeID isoString.		strm nextPut: $'.		strm nextPutAll: ' fromGzippedMimeLiteral: '.		strm nextPut: $'.		strm nextPutAll: (Base64MimeConverter mimeEncode: s2) contents.		strm nextPutAll: '''.'.		strm cr.	].		(StringHolder new contents: cont)		openLabel: 'exported codes in Gzip+Base64 encoding'! !!LanguageEditor methodsFor: 'gui methods' stamp: 'sd 2/4/2008 21:21' prior: 22863845!filterTranslations: aString | filter |filter := aString ifNil:[''].""	translationsFilter := filter.self update: #translations.! !!LanguageEditor methodsFor: 'initialization' stamp: 'sd 2/4/2008 21:21' prior: 22874799!initializeNewerKeys	newerKeys := Set new.! !!LanguageEditor methodsFor: 'gui methods' stamp: 'sd 2/4/2008 21:21' prior: 22870557!selectNewerKeys	| translations index |	self deselectAllTranslation.	translations := self translations.	newerKeys do: [:k |		index := translations indexOf: k ifAbsent: [0].		index > 0 ifTrue: [			self selectedTranslationsAt: index put: true		].	].! !!LanguageEditor methodsFor: 'accessing' stamp: 'sd 2/4/2008 21:21' prior: 22858708!translation: aStringOrText 	"change the translation for the selected phrase"	| phrase |	self selectedTranslation isZero		ifTrue: [^ self].	phrase := self translations at: self selectedTranslation.	translator		phrase: phrase		translation: aStringOrText asString.	newerKeys add: phrase.	^ true! !!TranslatedReceiverFinder methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:21' prior: 33022405!senders	| m o |	m := SystemNavigation default allCallsOn: #translated.	m := m collect: [:e |		e classIsMeta ifTrue: [			(Smalltalk at: e classSymbol) class decompile: e methodSymbol.		] ifFalse: [			(Smalltalk at: e classSymbol) decompile: e methodSymbol.		]	].	o := SortedCollection new.	m do: [:e | self searchMethodNode: e addTo: o].	^ o.! !!TTCFontReader class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31985517!encodingTag: aNumber"	TTCFontReader encodingTag: 6"	EncodingTag := aNumber.! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31976778!decodeCmapFmtTable: entry	| cmapFmt length cmap firstCode entryCount segCount segments offset code |	cmapFmt := entry nextUShort.	length := entry nextUShort.	entry skip: 2. "skip version"	cmapFmt = 0 ifTrue: "byte encoded table"		[length := length - 6. 		"should be always 256"		length <= 0 ifTrue: [^ nil].	"but sometimes, this table is empty"		cmap := Array new: length.		entry nextBytes: length into: cmap startingAt: entry offset.		^ cmap].	cmapFmt = 4 ifTrue: "segment mapping to deltavalues"		[segCount := entry nextUShort // 2.		entry skip: 6. "skip searchRange, entrySelector, rangeShift"		segments := Array new: segCount.		segments := (1 to: segCount) collect: [:e | Array new: 4].		1 to: segCount do: [:i | (segments at: i) at: 2 put: entry nextUShort]. "endCount"		entry skip: 2. "skip reservedPad"		1 to: segCount do: [:i | (segments at: i) at: 1 put: entry nextUShort]. "startCount"		1 to: segCount do: [:i | (segments at: i) at: 3 put: entry nextShort]. "idDelta"		offset := entry offset.		1 to: segCount do: [:i | (segments at: i) at: 4 put: entry nextUShort]. "idRangeOffset"		cmap := Array new: 65536 withAll: 0.		segments withIndexDo:			[:seg :si |			seg first to: seg second do:				[:i |					seg last > 0 ifTrue:						["offset to glypthIdArray - this is really C-magic!!"						entry offset: i - seg first - 1 * 2 + seg last + si + si + offset.						code := entry nextUShort.						code > 0 ifTrue: [code := code + seg third]]					ifFalse:						["simple offset"						code := i + seg third].					cmap at: i + 1 put: (code \\ 16r10000)]].		^ cmap].	cmapFmt = 6 ifTrue: "trimmed table"		[firstCode := entry nextUShort.		entryCount := entry nextUShort.		cmap := Array new: entryCount + firstCode withAll: 0.		entryCount timesRepeat:			[cmap at: (firstCode := firstCode + 1) put: entry nextUShort].		^ cmap].	^ nil! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31978718!getTableDirEntry: tagString from: fontData offset: offset	"Find the table named tagString in fontData and return a table directory entry for it."	| nTables pos currentTag tag |	nTables := fontData shortAt: 5 + offset bigEndian: true.	tag := ByteArray new: 4.	1 to: 4 do:[:i| tag byteAt: i put: (tagString at: i) asInteger].	tag := tag longAt: 1 bigEndian: true.	pos := 13 + offset.	1 to: nTables do:[:i|		currentTag := fontData longAt: pos bigEndian: true.		currentTag = tag ifTrue:[^TTFontTableDirEntry on: fontData at: pos].		pos := pos+16].	^nil! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31979356!parseTTCHeaderFrom: fontData	| pos nTables |	nTables := fontData longAt: 9 bigEndian: true.	fonts := Array new: nTables.	pos := 13.	1 to: nTables do: [:i |		fonts at: i put: (fontData longAt: pos bigEndian: true).		pos := pos + 4.	].	^ fonts! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31979688!processCharMap: assoc	"Process the given character map"	| glyph cmap encode0 encode1 char value null |	cmap := assoc value.	null := (glyphs at: (cmap at: Character space asUnicode + 1) + 1) copy.	null contours: #().	encode0 := Array new: 256 withAll: glyphs first.	encode1 := Array new: 65536 withAll: glyphs first.	0 to: 255 do: [:i |		char := Character value: i.		glyph := glyphs at: (cmap at: char asUnicode + 1) + 1.		encode0 at: i+1 put: glyph.	].	Character separators do: [:c |		encode0 at: (c asciiValue + 1) put: null.	].	0 to: 65536 - 1 do: [:i |		value := cmap at: i+1.		value = 65535 ifFalse: [ "???"			encode1 at: i+1 put: (glyphs at: value+1).		]	].	^ {encode0. encode1}.! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31980475!processCharacterMappingTable: entry	"Read the font's character to glyph index mapping table.	If an appropriate mapping can be found then return an association	with the format identifier and the contents of the table"	| copy initialOffset nSubTables pID sID offset cmap assoc |	initialOffset := entry offset.	entry skip: 2. "Skip table version"	nSubTables := entry nextUShort.	1 to: nSubTables do:[:i|		pID := entry nextUShort.		sID := entry nextUShort.		offset := entry nextULong.		"Check if this is either a Macintosh encoded table		or a Windows encoded table"		(pID = 1 or:[pID = 3]) ifTrue:[			"Go to the beginning of the table"			copy := entry copy.			copy offset: initialOffset + offset.			cmap := self decodeCmapFmtTable: copy.			"(pID = 1 and: [cmap notNil])" "Prefer Macintosh encoding over everything else"				"ifTrue: [pID -> cmap]."			assoc := pID -> cmap. "Keep it in case we don't find a Mac encoded table"		].	].	^assoc! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31981507!readFrom: aStream	"Read the raw font byte data"	| fontData |	(aStream respondsTo: #binary) ifTrue:[aStream binary].	fontData := aStream contents asByteArray.	fonts := self parseTTCHeaderFrom: fontData.	^ ((Array with: fonts first) collect: [:offset |		fontDescription := TTCFontDescription new.		self readFrom: fontData fromOffset: offset at: EncodingTag.	]) at: 1.! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31981964!readFrom: fontData fromOffset: offset at: encodingTag	| headerEntry maxProfileEntry nameEntry indexLocEntry charMapEntry glyphEntry horzHeaderEntry horzMetricsEntry kerningEntry glyphOffset cmap numHMetrics indexToLocFormat fontDescription0 fontDescription1 array result |	"Search the tables required to build the font"	(headerEntry := self getTableDirEntry: 'head' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a header table'].	(maxProfileEntry := self getTableDirEntry: 'maxp' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a maximum profile table'].	(nameEntry := self getTableDirEntry: 'name' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a name table'].	(indexLocEntry := self getTableDirEntry: 'loca' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a relocation table'].	(charMapEntry := self getTableDirEntry: 'cmap' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a character map table'].	(glyphEntry := self getTableDirEntry: 'glyf' from: fontData  offset: offset) == nil ifTrue:[		^self error:'This font does not have a glyph table'].	(horzHeaderEntry := self getTableDirEntry: 'hhea' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a horizontal header table'].	(horzMetricsEntry := self getTableDirEntry: 'hmtx' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a horizontal metrics table'].	(kerningEntry := self getTableDirEntry: 'kern' from: fontData offset: offset) == nil ifTrue:[		Transcript cr; show:'This font does not have a kerning table';endEntry].	"Process the data"	indexToLocFormat := self processFontHeaderTable: headerEntry.	self processMaximumProfileTable: maxProfileEntry.	self processNamingTable: nameEntry.	glyphOffset := self processIndexToLocationTable: indexLocEntry format: indexToLocFormat.	cmap := self processCharacterMappingTable: charMapEntry.	(cmap == nil or:[cmap value == nil])		ifTrue:[^self error:'This font has no suitable character mappings'].	self processGlyphDataTable: glyphEntry offsets: glyphOffset.	numHMetrics := self processHorizontalHeaderTable: horzHeaderEntry.	self processHorizontalMetricsTable: horzMetricsEntry length: numHMetrics.	kerningEntry isNil 		ifTrue:[kernPairs := #()]		ifFalse:[self processKerningTable: kerningEntry].	array := self processCharMap: cmap.	fontDescription0 := fontDescription clone.	fontDescription1 := fontDescription clone.	fontDescription0 setGlyphs: (array at: 1) mapping: nil.	fontDescription1 setGlyphs: (array at: 2) mapping: nil.	"fontDescription setKernPairs: kernPairs."	result := OrderedCollection new.	(encodingTag = nil or: [encodingTag = 0]) ifTrue: [^ Array with: fontDescription1].	result add: fontDescription0.	encodingTag -1 timesRepeat: [result add: nil].	result add: fontDescription1.	^ result asArray.! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31985053!readTTFFrom: aStream	"Read the raw font byte data"	| fontData |	(aStream respondsTo: #binary) ifTrue:[aStream binary].	fontData := aStream contents asByteArray.	fontDescription := TTCFontDescription new.	^ self readFrom: fontData fromOffset: 0 at: EncodingTag.! !!ImmWin32 methodsFor: 'all' stamp: 'sd 2/4/2008 21:21' prior: 22083388!keyboardFocusForAMorph: aMorph	| left top pos |	aMorph ifNil: [^ self].	[		pos := aMorph preferredKeyboardPosition.		left := (pos x min: Display width max: 0) asInteger.		top := (pos y min: Display height max: 0) asInteger.		self setCompositionWindowPositionX: left y: top	] on: Error	do: [:ex |].! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31974305!addFromTTFile: fileName"	Execute the following only if you know what you are doing.	self addFromTTFile: 'C:\WINDOWS\Fonts\msgothic.TTC'"	| tt old |	(fileName asLowercase endsWith: 'ttf') ifTrue: [		tt := TTCFontReader readTTFFrom: (FileStream readOnlyFileNamed: fileName).	] ifFalse: [		tt := TTCFontReader readFrom: (FileStream readOnlyFileNamed: fileName).	].			old := TTCDescriptions detect: [:f | f first name = tt first name] ifNone: [nil].	old ifNotNil: [TTCDescriptions remove: old].	TTCDescriptions add: tt.	^ tt.! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31974935!clearDefault"	self clearDefault"	TTCDefault := nil.! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31975086!clearDescriptions"	self clearDescriptions"	TTCDescriptions := Set new.	TTCDefault ifNotNil: [TTCDescriptions add: TTCDefault].! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31975648!descriptionNamed: descriptionName at: index	| array |	(array :=  self descriptionNamed: descriptionName) ifNil: [^ nil].	^ array at: index.! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31976043!removeDescriptionNamed: descriptionName	| tt |	TTCDescriptions ifNil: [^ self].	[(tt := TTCDescriptions detect: [:f | ('Multi', f first name) = descriptionName] ifNone: [nil]) notNil] whileTrue:[		 TTCDescriptions remove: tt	].! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31976371!setDefault"	self setDefault"	TTCDefault := TTCFontReader readFrom: (FileStream readOnlyFileNamed: 'C:\WINDOWS\Fonts\msgothic.ttc').	self clearDescriptions.! !!TTCFontDescription methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31972842!at: aCharOrInteger	| char |	char := aCharOrInteger asCharacter.	^ glyphs at: (char charCode) + 1.! !!TTCFontDescription methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31973284!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	dp := DiskProxy global: #TTCFontDescription selector: #descriptionNamed:at:			args: {self name. ((TTCFontDescription descriptionNamed: self name) indexOf: self)}.	refStrm replace: self with: dp.	^ dp.! !!TTCFont class methodsFor: 'instance creation' stamp: 'sd 2/4/2008 21:20' prior: 31965119!familyName: n pointSize: s emphasis: code	"(TTCFont familyName: 'BitstreamVeraSans' pointSize: 12 emphasis: 0)"	| t ret index |	t := self registry at: n asSymbol ifAbsent: [#()].	t isEmpty ifTrue: [		t := (TextConstants at: #DefaultTextStyle) fontArray.		ret := t first.		ret pointSize >= s ifTrue: [^ ret emphasis: code].		index := 2.		[index <= t size and: [(t at: index) pointSize <= s]] whileTrue: [			ret := t at: index.			index := index + 1.		].		^ ret emphasis: code.	].	^ ((TextStyle named: n) addNewFontSize: s) emphasis: code.! !!TTCFont class methodsFor: 'instance creation' stamp: 'sd 2/4/2008 21:20' prior: 31965939!getExistings: fontArray	| result em |	result := OrderedCollection new.	result add: fontArray.	1 to: 3 do: [:i |		em := (fontArray collect: [:f | f emphasized: i]).		(em at: 1) ~= (fontArray at: 1) ifTrue: [			result add: em.		].	].	^ result asArray.! !!TTCFont class methodsFor: 'class initialization' stamp: 'sd 2/4/2008 21:20' prior: 31963756!initialize"	self initialize"	| tt |	Smalltalk addToShutDownList: TTCFont.	tt := TTFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].	(FileList respondsTo: #registerFileReader:) ifTrue: [		FileList registerFileReader: self	].! !!TTCFont class methodsFor: 'instance creation' stamp: 'sd 2/4/2008 21:20' prior: 31966675!newTextStyleFromTTFile: fileName	"Create a new TextStyle from specified file name.  On certain versions of Windows, you can evaluate following to get Arial font into the image.  On other platforms, wait and see someone implements the support code for FontPlugin then we can start relying on the generic font lookup mechanism.	TTCFontReader encodingTag: 0.	self newTextStyleFromTTFile: 'C:\WINDOWS\Fonts\symbol.TTF'.	"	| description |	description := TTFontDescription addFromTTFile: fileName.	^ self newTextStyleFromTT: description.! !!TTCFont class methodsFor: 'instance creation' stamp: 'sd 2/4/2008 21:20' prior: 31967295!newTextStyleFromTTStream: readStream""	| description |	description := TTFontDescription addFromTTStream: readStream.	^ self newTextStyleFromTT: description.! !!TTCFont class methodsFor: 'instance creation' stamp: 'sd 2/4/2008 21:20' prior: 31967538!reorganizeForNewFontArray: array name: styleName	| style existings regular altName |	(TextConstants includesKey: styleName) ifFalse: [		TextConstants at: styleName put: (TextStyle fontArray: array).		^ TextConstants at: styleName.	]. 	"There is a text style with the name I want to use.  See if it is a TTC font..."	style := TextConstants at: styleName.	style isTTCStyle ifFalse: [		altName := ((array at: 1) name, 'TT') asSymbol.		^ self reorganizeForNewFontArray: array name: altName.	].	existings := (self getExistings: style fontArray), (Array with: array).	regular := existings detect: [:e | (e at: 1) isRegular] ifNone: [existings at: 1].	regular do: [:r |		r addLined: r.	].	"The existing array may be different in size than the new one."	existings do: [:e |		(e at: 1) isRegular ifFalse: [			regular do: [ :r | | f |				f := e detect: [ :ea | ea pointSize = r pointSize ] ifNone: [ ].				f ifNotNil: [ r derivativeFont: f ].			].		].	].	style newFontArray: regular.	self register: regular at: styleName.	self recreateCache.		^ style.! !!TTCFont class methodsFor: 'other' stamp: 'sd 2/4/2008 21:20' prior: 31970515!repairBadSizes	"There was a bug that would cause the TTCFonts to generate incorrectly sized glyphs.	By looking at the dimensions of cached forms,	we can tell whether the incorrect height logic was used.	If it was, change the point size of the font and its derivatives.		Note that this is probably pointless to call after the new code has been loaded; it's here for documentation (it should be called from the CS preamble instead)."	"TTCFont repairBadSizes"	| description computedScale cached desiredScale newPointSize repaired |	repaired := OrderedCollection new.	TTCFont allInstancesDo: [ :font |		cached := (font cache copyFrom: $A asciiValue + 1 to: $z asciiValue + 1)			detect: [ :f | f notNil ] ifNone: [].		cached := cached ifNil: [  font formOf: $A ] ifNotNil: [ cached value ].		description := font ttcDescription.		desiredScale := cached height asFloat / (description ascender - description descender).		computedScale := font pixelSize asFloat / font ttcDescription unitsPerEm.		(((computedScale / desiredScale) - 1.0 * cached height) abs < 1.0) ifFalse: [			newPointSize := (font pointSize * desiredScale / computedScale) rounded.			font pointSize: newPointSize; flushCache.			repaired add: font.			font derivativeFonts do: [ :df | df ifNotNil: [				df pointSize: newPointSize; flushCache.				repaired add: df. ]].		].	].	repaired isEmpty ifFalse: [ repaired asArray inspect ].! !!TTCFont class methodsFor: 'other' stamp: 'sd 2/4/2008 21:20' prior: 31972303!scale: anObject	Scale := anObject.! !!TTCFont methodsFor: 'private' stamp: 'sd 2/4/2008 21:20' prior: 31960171!addLined: aTTCFont	| l |	l := LinedTTCFont fromTTCFont: aTTCFont emphasis: 4.	self derivativeFont: l at: l emphasis.	l := LinedTTCFont fromTTCFont: aTTCFont emphasis: 16.	self derivativeFont: l at: l emphasis.	l := LinedTTCFont fromTTCFont: aTTCFont emphasis: 20.	self derivativeFont: l at: l emphasis.! !!TTCFont methodsFor: 'private' stamp: 'sd 2/4/2008 21:20' prior: 31960700!computeForm: char	| ttGlyph scale |	scale := self pixelSize asFloat / (ttcDescription ascender - ttcDescription descender).	Scale ifNotNil: [scale := Scale * scale].	ttGlyph := ttcDescription at: (char isCharacter ifTrue: [char charCode] ifFalse: [char]).	^ ttGlyph asFormWithScale: scale ascender: ttcDescription ascender descender: ttcDescription descender fgColor: foregroundColor bgColor: Color transparent depth: self depth.! !!TTCFont methodsFor: 'objects from disk' stamp: 'sd 2/4/2008 21:20' prior: 31957625!convertToCurrentVersion: varDict refStream: smartRefStrm	"If we're reading in an old version with a pixelSize instance variable, convert it to a point size."	"Deal with the change from pixelSize to pointSize, assuming the current monitor dpi."	varDict at: 'pixelSize' ifPresent: [ :x | 		pointSize := (TextStyle pixelsToPoints: x) rounded.	].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31953896!derivativeFont: aTTCFont	| index |	index := self indexOfSubfamilyName: (aTTCFont subfamilyName).	index < 1 ifTrue: [		^ self "inform: 'unknown sub family name.  This font will be skipped'".	].	self derivativeFont: aTTCFont at: index.	self addLined: aTTCFont.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31954227!derivativeFont: aTTCFont at: index	| newDeriv |	aTTCFont ifNil: [derivatives := nil. ^ self].	derivatives ifNil: [derivatives := Array new: 32].	derivatives size < 32 ifTrue: [		newDeriv := Array new: 32.		newDeriv replaceFrom: 1 to: derivatives size with: derivatives.		derivatives := newDeriv.	].	derivatives at: index put: aTTCFont.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31955167!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| destPoint form glyphInfo destY |	destPoint := aPoint.	glyphInfo := Array new: 5.	startIndex to: stopIndex do: [:charIndex |		self glyphInfoOf: (aString at: charIndex) into: glyphInfo.		form := glyphInfo first.		((glyphInfo at:5) ~= aBitBlt lastFont) ifTrue: [			(glyphInfo at:5) installOn: aBitBlt.		].		destY := baselineY - (glyphInfo at:4). 		aBitBlt sourceForm: form.		aBitBlt destX: destPoint x.		aBitBlt destY: destY.		aBitBlt sourceOrigin: (glyphInfo at:2) @ 0.		aBitBlt width: glyphInfo third - glyphInfo second.		aBitBlt height: form height.		aBitBlt copyBits.		destPoint := destPoint + (((glyphInfo at:3) - (glyphInfo at:2)) + kernDelta @ 0).	].	^ destPoint.! !!TTCFont methodsFor: 'accessing' stamp: 'sd 2/4/2008 21:20' prior: 31950465!fallbackFont	^ fallbackFont		ifNil: [fallbackFont := FixedFaceFont new errorFont fontSize: self height]! !!TTCFont methodsFor: 'accessing' stamp: 'sd 2/4/2008 21:20' prior: 31950636!fallbackFont: aFontSetOrNil	fallbackFont := aFontSetOrNil.! !!TTCFont methodsFor: 'private' stamp: 'sd 2/4/2008 21:20' prior: 31961197!formOf: char	| f assoc code |	char charCode > 255		ifTrue: [^ self fallbackFont formOf: char].	code := char charCode.	assoc := self cache at: (code + 1).	assoc ifNotNil: [		(assoc key = foregroundColor) ifTrue: [			^ assoc value.		].	].	f := self computeForm: code.	self at: code put: f.	^ f.! !!TTCFont methodsFor: 'private' stamp: 'sd 2/4/2008 21:20' prior: 31961568!glyphInfoOf: aCharacter into: glyphInfoArray	"Answer the width of the argument as a character in the receiver."	| form |	(self hasGlyphOf: aCharacter) ifFalse: [		^ self fallbackFont glyphInfoOf: aCharacter into: glyphInfoArray.	].	form := self formOf: aCharacter.	glyphInfoArray at: 1 put: form;		at: 2 put: 0;		at: 3 put: form width;		at: 4 put: (self ascentOf: aCharacter);		at: 5 put: self.	^ glyphInfoArray.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31956145!initialize	foregroundColor := Color black.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31956385!installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor	foregroundColor := fgColor.	aDisplayContext installTTCFont: self foregroundColor: foregroundColor backgroundColor: bgColor! !!TTCFont methodsFor: 'objects from disk' stamp: 'sd 2/4/2008 21:20' prior: 31958113!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write areference to a known FontSet in the other system instead."	"a path to me"	dp := DiskProxy global: #TTCFont selector: #familyName:pointSize:emphasis:			args: {self familyName. self pointSize. self emphasis}.	refStrm replace: self with: dp.	^ dp.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31956653!recreateCache	cache := WeakArray new: 1.	ascent := nil.! !!TTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31952779!setupDefaultFallbackFont	| fonts f |	fonts := TextStyle default fontArray.	f := fonts first.	1 to: fonts size do: [:i |		self height > (fonts at: i) height ifTrue: [f := fonts at: i].	].	self fallbackFont: f.	self reset.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31956774!setupDefaultFallbackFontTo: aTextStyleOrNil"	TTCFont allInstances do: [:i | i setupDefaultFallbackFontTo: (TextStyle named: 'MultiMSMincho')]."	| fonts f |	aTextStyleOrNil ifNil: [		self fallbackFont: nil.		^ self.	].	fonts := aTextStyleOrNil fontArray.	(aTextStyleOrNil defaultFont familyName endsWith: self familyName) ifTrue: [fallbackFont := nil. ^ self].	f := fonts first.	1 to: fonts size do: [:i |		self height >= (fonts at: i) height ifTrue: [f := fonts at: i].	].	self fallbackFont: f.	self reset.! !!TTCFont methodsFor: 'friend' stamp: 'sd 2/4/2008 21:20' prior: 31957461!ttcDescription: aTTCDescription	ttcDescription := aTTCDescription.	self recreateCache.! !!TTCFont methodsFor: 'public' stamp: 'sd 2/4/2008 21:20' prior: 31959029!widthOf: aCharacter	"This method cannot use #formOf: because formOf: discriminates the color and causes unnecessary bitmap creation."	| f assoc |	aCharacter charCode > 255 ifTrue: [		fallbackFont ifNotNil: [^ fallbackFont widthOf: aCharacter].		^ 1	].	assoc := self cache at: (aCharacter charCode + 1).	assoc ifNotNil: [		^ assoc value width	].	f := self computeForm: aCharacter.	self at: aCharacter charCode put: f.	^ f width.! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'sd 2/4/2008 21:22' prior: 25288415!addCharToPresentation: char	presentation nextPut: char.	lastWidth := self widthOf: char inFont: font.	destX := destX + lastWidth.! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25296515!columnBreak	"Answer true. Set up values for the text line interval currently being 	composed."	line stop: lastIndex.	presentationLine stop: lastIndex - numOfComposition.	spaceX := destX.	line paddingWidth: rightMargin - spaceX.	presentationLine paddingWidth: rightMargin - spaceX.	^true! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25290083!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	"Set up margins"	leftMargin := lineRectangle left.	leftSide ifTrue: [leftMargin := leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	destX := spaceX := leftMargin.	firstDestX := destX.	rightMargin := lineRectangle right.	rightSide ifTrue: [rightMargin := rightMargin - textStyle rightIndent].	lastIndex := startIndex.	"scanning sets last index"	destY := lineRectangle top.	lineHeight := baseline := 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font"	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	line := (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	presentationLine := (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	numOfComposition := 0.	spaceCount := 0.	self handleIndentation.	leftMargin := destX.	line leftMargin: leftMargin.	presentationLine leftMargin: leftMargin.	presentation := TextStream on: (Text fromString: (WideString new: text size)).	done := false.	[done]		whileFalse: 			[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [presentationLine lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading.						^ line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25292022!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	destX := spaceX := leftMargin := aParagraph leftMarginForCompositionForLine: lineIndex.	destY := 0.	rightMargin := aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex := startIndex.	"scanning sets last index"	lineHeight := textStyle lineGrid.  "may be increased by setFont:..."	baseline := textStyle baseline.	baselineY := destY + baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	line := TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	presentationLine := TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	numOfComposition := 0.	presentation := TextStream on: (Text fromString: (WideString new: text size)).	spaceCount := 0.	done := false.	[done]		whileFalse: 			[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [presentationLine lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading.						^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25296898!cr	"Answer true. Set up values for the text line interval currently being 	composed."	line stop: lastIndex.	presentationLine stop: lastIndex - numOfComposition.	spaceX := destX.	line paddingWidth: rightMargin - spaceX.	presentationLine paddingWidth: rightMargin - spaceX.	^true! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25293734!crossedX	"There is a word that has fallen across the right edge of the composition 	rectangle. This signals the need for wrapping which is done to the last 	space that was encountered, as recorded by the space stop condition."	(breakAtSpace) ifTrue: [		spaceCount >= 1 ifTrue:			["The common case. First back off to the space at which we wrap."			line stop: breakableIndex.			presentationLine stop: breakableIndex - numOfComposition.			lineHeight := lineHeightAtBreak.			baseline := baselineAtBreak.			spaceCount := spaceCount - 1.			breakableIndex := breakableIndex - 1.			"Check to see if any spaces preceding the one at which we wrap.				Double space after punctuation, most likely."			[(spaceCount > 1 and: [(text at: breakableIndex) = Space])]				whileTrue:					[spaceCount := spaceCount - 1.					"Account for backing over a run which might						change width of space."					font := text fontAt: breakableIndex withStyle: textStyle.					breakableIndex := breakableIndex - 1.					spaceX := spaceX - (font widthOf: Space)].			line paddingWidth: rightMargin - spaceX.			presentationLine paddingWidth: rightMargin - spaceX.			presentationLine internalSpaces: spaceCount.			line internalSpaces: spaceCount]		ifFalse:			["Neither internal nor trailing spaces -- almost never happens."			lastIndex := lastIndex - 1.			[destX <= rightMargin]				whileFalse:					[destX := destX - (font widthOf: (text at: lastIndex)).					lastIndex := lastIndex - 1].			spaceX := destX.			line paddingWidth: rightMargin - destX.			presentationLine paddingWidth: rightMargin - destX.			presentationLine stop: (lastIndex max: line first).			line stop: (lastIndex max: line first)].		^true	].	(breakableIndex isNil or: [breakableIndex < line first]) ifTrue: [		"Any breakable point in this line.  Just wrap last character."		breakableIndex := lastIndex - 1.		lineHeightAtBreak := lineHeight.		baselineAtBreak := baseline.	].	"It wasn't a space, but anyway this is where we break the line."	line stop: breakableIndex.	presentationLine stop: breakableIndex.	lineHeight := lineHeightAtBreak.	baseline := baselineAtBreak.	^ true.! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25297272!endOfRun	"Answer true if scanning has reached the end of the paragraph. 	Otherwise step conditions (mostly install potential new font) and answer 	false."	| runLength |	lastIndex = text size	ifTrue:	[line stop: lastIndex.			presentationLine stop: lastIndex - numOfComposition.			spaceX := destX.			line paddingWidth: rightMargin - destX.			presentationLine paddingWidth: rightMargin - destX.			^true]	ifFalse:	[			"(text at: lastIndex) charCode = 32 ifTrue: [destX := destX + spaceWidth]."			runLength := (text runLengthFor: (lastIndex := lastIndex + 1)).			runStopIndex := lastIndex + (runLength - 1).			self setStopConditions.			^false]! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25298012!placeEmbeddedObject: anchoredMorph	| descent |	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	(super placeEmbeddedObject: anchoredMorph) ifFalse: ["It doesn't fit"		"But if it's the first character then leave it here"		lastIndex < line first ifFalse:[			line stop: lastIndex-1.			^ false]].	descent := lineHeight - baseline.	lineHeight := lineHeight max: anchoredMorph height.	baseline := lineHeight - descent.	line stop: lastIndex.	presentationLine stop: lastIndex - numOfComposition.	^ true! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'sd 2/4/2008 21:22' prior: 25289128!registerBreakableIndex	"Record left x and character index of the line-wrappable point. 	Used for wrap-around. Answer whether the character has crossed the 	right edge of the composition rectangle of the paragraph."	(text at: lastIndex) = Character space ifTrue: [		breakAtSpace := true.		spaceX := destX.		spaceCount := spaceCount + 1.		lineHeightAtBreak := lineHeight.		baselineAtBreak := baseline.		breakableIndex := lastIndex.		destX > rightMargin ifTrue: 	[^self crossedX].	] ifFalse: [		breakAtSpace := false.		lineHeightAtBreak := lineHeight.		baselineAtBreak := baseline.		breakableIndex := lastIndex - 1.	].	^ false.! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'sd 2/4/2008 21:22' prior: 25289858!removeLastCharFromPresentation	presentation ifNotNil: [		presentation position: presentation position - 1.	].	destX := destX - lastWidth.! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25295958!setActualFont: aFont	"Keep track of max height and ascent for auto lineheight"	| descent |	super setActualFont: aFont.	"'   ', lastIndex printString, '   ' displayAt: (lastIndex * 15)@0."	lineHeight == nil		ifTrue: [descent := font descent.				baseline := font ascent.				lineHeight := baseline + descent]		ifFalse: [descent := lineHeight - baseline max: font descent.				baseline := baseline max: font ascent.				lineHeight := lineHeight max: baseline + descent]! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25298679!setFont	super setFont.	breakAtSpace := false.	wantsColumnBreaks == true ifTrue: [		stopConditions := stopConditions copy.		stopConditions at: TextComposer characterForColumnBreak asciiValue + 1 put: #columnBreak.	].! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25299173!tab	"Advance destination x according to tab settings in the paragraph's 	textStyle. Answer whether the character has crossed the right edge of 	the composition rectangle of the paragraph."	destX := textStyle				nextTabXFrom: destX leftMargin: leftMargin rightMargin: rightMargin.	destX > rightMargin ifTrue:	[^self crossedX].	lastIndex := lastIndex + 1.	^false! !!MultiCanvasCharacterScanner methodsFor: 'accessing' stamp: 'sd 2/4/2008 21:22' prior: 25247342!canvas: aCanvas	"set the canvas to draw on"	canvas ifNotNil: [ self inform: 'initializing twice!!' ].	canvas := aCanvas! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25248960!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	lastIndex:= lastIndex + 1.	^false! !!MultiCanvasCharacterScanner methodsFor: 'scanning' stamp: 'sd 2/4/2008 21:22' prior: 25247551!displayLine: textLine  offset: offset  leftInRun: leftInRun	|  nowLeftInRun done startLoc startIndex stopCondition |	"largely copied from DisplayScanner's routine"	line := textLine.	foregroundColor ifNil: [ foregroundColor := Color black ].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	rightMargin := line rightMargin + offset x.	lineY := line top + offset y.	lastIndex := textLine first.	leftInRun <= 0		ifTrue: [self setStopConditions.  "also sets the font"				nowLeftInRun := text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun := leftInRun].	runX := destX := leftMargin.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	done := false.	[done] whileFalse: [		"remember where this portion of the line starts"		startLoc := destX@destY.		startIndex := lastIndex.		"find the end of this portion of the line"		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex						in: text string rightX: rightMargin stopConditions: stopConditions						kern: kern "displaying: false".		"display that portion of the line"		canvas drawString: text string			from: startIndex to: lastIndex			at: startLoc			font: font			color: foregroundColor.		"handle the stop condition"		done := self perform: stopCondition	].	^runStopIndex - lastIndex! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25249710!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	lastIndex = line last ifTrue: [^true].	runX := destX.	runLength := text runLengthFor: (lastIndex := lastIndex + 1).	runStopIndex := lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25250226!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	destX := destX + spaceWidth + (line justifiedPadFor: spaceCount).	lastIndex := lastIndex + 1.	^ false! !!MultiCanvasCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25251574!setFont	foregroundColor ifNil: [foregroundColor := Color black].	super setFont.	baselineY := lineY + line baseline.	destY := baselineY - font ascent.! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'sd 2/4/2008 21:22' prior: 25250988!tab	destX := (alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastIndex := lastIndex + 1.	^ false! !!MultiCanvasCharacterScanner methodsFor: 'private' stamp: 'sd 2/4/2008 21:22' prior: 25251810!textColor: color	foregroundColor := color! !!MultiNewParagraph methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 25312448!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| visibleRectangle offset leftInRun line |	visibleRectangle := aCanvas clipRect.	offset := somePosition - positionWhenComposed.	leftInRun := 0.	(self lineIndexForPoint: visibleRectangle topLeft)		to: (self lineIndexForPoint: visibleRectangle bottomRight)		do: [:i | line := lines at: i.			self displaySelectionInLine: line on: aCanvas.			line first <= line last ifTrue:				[leftInRun := displayScanner displayLine: line								offset: offset leftInRun: leftInRun]].! !!MultiNewParagraph methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 25313126!displayOnTest: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| visibleRectangle offset leftInRun line |	(presentationText isNil or: [presentationLines isNil]) ifTrue: [		^ self displayOn: aCanvas using: displayScanner at: somePosition.	].	visibleRectangle := aCanvas clipRect.	offset := somePosition - positionWhenComposed.	leftInRun := 0.	(self lineIndexForPoint: visibleRectangle topLeft)		to: (self lineIndexForPoint: visibleRectangle bottomRight)		do: [:i | line := presentationLines at: i.			self displaySelectionInLine: line on: aCanvas.			line first <= line last ifTrue:				[leftInRun := displayScanner displayLine: line								offset: offset leftInRun: leftInRun]].! !!MultiNewParagraph methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:22' prior: 25313958!multiComposeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines	atY: startingY	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| newResult composer presentationInfo |	composer := MultiTextComposer new.	presentationLines := nil.	presentationText := nil.	newResult := composer		multiComposeLinesFrom: start 		to: stop 		delta: delta 		into: lineColl 		priorLines: priorLines		atY: startingY		textStyle: textStyle 		text: text 		container: container		wantsColumnBreaks: wantsColumnBreaks == true.	lines := newResult first asArray.	maxRightX := newResult second.	presentationInfo := composer getPresentationInfo.	presentationLines := presentationInfo first asArray.	presentationText := presentationInfo second.	"maxRightX printString displayAt: 0@0."	^maxRightX! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31156787!createExternalFontFileForLatin2: fileName"	StrikeFontSet createExternalFontFileForLatin2: 'latin2.out'."	| file array f installDirectory |	file := FileStream newFileNamed: fileName.	installDirectory := Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory := installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array := Array				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b10.bdf' name: 'LatinTwo9' ranges: EFontBDFFontReaderForRanges rangesForLatin2)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'LatinTwo10' ranges: EFontBDFFontReaderForRanges rangesForLatin2)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'LatinTwo12' ranges: EFontBDFFontReaderForRanges rangesForLatin2)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b16.bdf' name: 'LatingTwo14' ranges: EFontBDFFontReaderForRanges rangesForLatin2)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'LatinTwo20' ranges: EFontBDFFontReaderForRanges rangesForLatin2).	TextConstants at: #forceFontWriting put: true.	f := ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31158159!createExternalFontFileForUnicodeJapanese: fileName"	StrikeFontSet createExternalFontFileForUnicodeJapanese: 'uJapaneseFont.out'."	| file array f installDirectory |	file := FileStream newFileNamed: fileName.	installDirectory := Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory := installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array := Array				with: (StrikeFont newForJapaneseFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'Japanese10' overrideWith: 'shnmk12.bdf')				with: ((StrikeFont newForJapaneseFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'Japanese12' overrideWith: 'shnmk14.bdf') "fixAscent: 14 andDescent: 1 head: 1")				with: ((StrikeFont newForJapaneseFromEFontBDFFile: 'b16.bdf' name: 'Japanese14' overrideWith: 'shnmk16.bdf') "fixAscent: 16 andDescent: 4 head: 4")				with: (StrikeFont newForJapaneseFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'Japanese18' overrideWith: 'kanji24.bdf').	TextConstants at: #forceFontWriting put: true.	f := ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31159421!createExternalFontFileForUnicodeKorean: fileName"	Smalltalk garbageCollect.	StrikeFontSet createExternalFontFileForUnicodeKorean: 'uKoreanFont.out'."	| file array f installDirectory |	file := FileStream newFileNamed: fileName.	installDirectory := Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory := installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array := Array				with: (StrikeFont newForKoreanFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'Japanese10' overrideWith: 'shnmk12.bdf')				with: ((StrikeFont newForKoreanFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'Japanese12' overrideWith: 'shnmk14.bdf') "fixAscent: 14 andDescent: 1 head: 1")				with: ((StrikeFont newForKoreanFromEFontBDFFile: installDirectory , 'b16.bdf' name: 'Japanese14' overrideWith: 'hanglg16.bdf') fixAscent: 16 andDescent: 4 head: 4)				with: (StrikeFont newForKoreanFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'Japanese18' overrideWith: 'hanglm24.bdf').	TextConstants at: #forceFontWriting put: true.	f := ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31160716!decodedFromRemoteCanvas: aString	| array |	array := aString findTokens: #($ ).	^ self familyName: (array at: 1) size: (array at: 2) asNumber emphasized: (array at: 3) asNumber.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31160986!duplicateArrayElementsForLeadingCharShift"	self duplicateArrayElementsForLeadingCharShift"	| array font |	self allInstances do: [:s |		s emphasis = 0 ifTrue: [			array := s fontArray.			2 to: (4 min: array size) do: [:i |				font := array at: i.				s addNewFont: font at: ((i - 1) << 2) + 1.			].		] ifFalse: [			s reset		].	].! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31161416!familyName: aName size: aSize	"Answer a font (or the default font if the name is unknown) in the specified size."	| collection |	collection :=  self allInstances select: [:inst | (inst name beginsWith: aName) and: [inst emphasis = 0]].	collection isEmpty ifTrue: [		(aName = 'DefaultMultiStyle') ifTrue: [			collection := (TextConstants at: #DefaultMultiStyle) fontArray.		] ifFalse: [			^ TextStyle defaultFont		]	].	collection := collection asSortedCollection: [:a :b | a pointSize <= b pointSize].	collection do: [:s | (s pointSize >= aSize) ifTrue: [^ s]].	^ TextStyle defaultFont.! !!StrikeFontSet class methodsFor: 'fileIn/Out' stamp: 'sd 2/4/2008 21:20' prior: 31166392!installExternalFontFileName: fileName inDir: dir encoding: encoding encodingName: aString textStyleName: styleName	| array arrayFour oldStyle arrayOfFS fs fonts newFonts |	array := (ReferenceStream on: (dir readOnlyFileNamed: fileName)) next.	arrayFour := Array new: 4 withAll: array last.	arrayFour replaceFrom: 1 to: array size with: array startingAt: 1.	TextConstants at: aString asSymbol put: arrayFour.	oldStyle := TextConstants at: styleName asSymbol.	arrayOfFS := oldStyle fontArray.	arrayOfFS := (1 to: 4) collect: [:i |		fs := arrayOfFS at: i.		fonts := fs fontArray.		encoding + 1 > fonts size ifTrue: [			newFonts := Array new: encoding + 1.			newFonts replaceFrom: 1 to: fonts size with: fonts startingAt: 1.			newFonts at: encoding + 1 put: (arrayFour at: i).			fs initializeWithFontArray: newFonts.		] ifFalse: [			fonts at: encoding + 1 put: (arrayFour at: i).		].		fs.	].	TextConstants at: styleName asSymbol put: (TextStyle fontArray: arrayOfFS).	oldStyle becomeForward: (TextConstants at: styleName asSymbol).! !!StrikeFontSet class methodsFor: 'fileIn/Out' stamp: 'sd 2/4/2008 21:20' prior: 31167519!installExternalFontOn: aStream encoding: encoding encodingName: aString textStyleName: styleName	| array fonts encodingIndex textStyle |	array := aStream		untilEndWithFork: [(ReferenceStream on: aStream) next]		displayingProgress: 'Font reading...'. 		TextConstants at: aString asSymbol put: array.	textStyle := TextConstants at: styleName asSymbol.	encodingIndex := encoding + 1.	textStyle fontArray do: [:fs |		fonts := fs fontArray.		encodingIndex > fonts size			ifTrue: [fonts :=  (Array new: encodingIndex)				replaceFrom: 1 to: fonts size with: fonts startingAt: 1].		fonts at: encodingIndex put: (self findMaximumLessThan: fs fontArray first in: array).		fs initializeWithFontArray: fonts.	].! !!StrikeFontSet class methodsFor: 'fileIn/Out' stamp: 'sd 2/4/2008 21:20' prior: 31168628!installNewFontAtIndex: newIndex fromOld: oldIndex	| fontArray newArray |	self allInstances do: [:set |		fontArray := set fontArray.		newIndex + 1 > fontArray size ifTrue: [			newArray := Array new: newIndex + 1.			newArray replaceFrom: 1 to: fontArray size with: fontArray startingAt: 1.			newArray at: newIndex + 1 put: (fontArray at: oldIndex + 1).			set initializeWithFontArray: newArray.		] ifFalse: [			fontArray at: newIndex + 1 put: (fontArray at: oldIndex + 1).		].	]."StrikeFontSet installNewFontAtIndex: UnicodeSimplifiedChinese leadingChar fromOld: UnicodeJapanese leadingCharStrikeFontSet installNewFontAtIndex: UnicodeKorean leadingChar fromOld: UnicodeJapanese leadingChar"! !!StrikeFontSet class methodsFor: 'fileIn/Out' stamp: 'sd 2/4/2008 21:20' prior: 31169412!removeFontsForEncoding: leadingChar encodingName: encodingSymbol	| insts fonts newFonts index |	leadingChar = 0 ifTrue: [^ self error: 'you cannot delete the intrinsic fonts'].	insts := self allInstances.	insts do: [:inst |		fonts := inst fontArray.		fonts size >= (leadingChar + 1) ifTrue: [			leadingChar + 1 = fonts size ifTrue: [				newFonts := fonts copyFrom: 1 to: fonts size - 1.				index := newFonts indexOf: nil.				index > 0 ifTrue: [newFonts := newFonts copyFrom: 1 to: index - 1].				inst initializeWithFontArray: newFonts.			] ifFalse: [				fonts at: leadingChar + 1 put: nil.			].		].	].	TextConstants removeKey: encodingSymbol asSymbol ifAbsent: [].! !!StrikeFontSet methodsFor: 'private' stamp: 'sd 2/4/2008 21:13' prior: 31155143!addNewFont: aFont at: encodingIndex	| newArray |	encodingIndex > fontArray size ifTrue: [		newArray := Array new: encodingIndex.		newArray replaceFrom: 1 to: fontArray size with: fontArray startingAt: 1.	] ifFalse: [		newArray := fontArray.	].	newArray at: encodingIndex put: aFont.	self initializeWithFontArray: newArray.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31135158!bonk: glyphForm with: bonkForm at: j	"Bonking means to run through the glyphs clearing out black pixels	between characters to prevent them from straying into an adjacent	character as a result of, eg, bolding or italicizing"	"Uses the bonkForm to erase at every character boundary in glyphs."	| bb offset font x |	font := (fontArray at: j).	offset := bonkForm offset x.	bb := BitBlt toForm: glyphForm.	bb sourceForm: bonkForm; sourceRect: bonkForm boundingBox;		combinationRule: Form erase; destY: 0.	x := font xTable.	(x isMemberOf: SparseLargeTable) ifTrue: [		x base to: x size-1 do: [:i | bb destX: (x at: i) + offset; copyBits].	] ifFalse: [		1 to: x size-1 do: [:i | bb destX: (x at: i) + offset; copyBits].	].! !!StrikeFontSet methodsFor: 'character shapes' stamp: 'sd 2/4/2008 21:20' prior: 31144264!characterFormAt: character 	| encoding ascii xTable leftX rightX |	encoding := character leadingChar + 1.	ascii := character charCode.	(ascii < (fontArray at: encoding) minAscii or: [ascii > (fontArray at: encoding) maxAscii])		ifTrue: [ascii := (fontArray at: encoding) maxAscii].	xTable := (fontArray at: encoding) xTable.	leftX := xTable at: ascii + 1.	rightX := xTable at: ascii + 2.	^ (fontArray at: encoding) glyphs copy: (leftX @ 0 corner: rightX @ self height).! !!StrikeFontSet methodsFor: 'character shapes' stamp: 'sd 2/4/2008 21:20' prior: 31144819!characterFormAt: character put: characterForm 	| ascii leftX rightX widthDif newGlyphs encoding xTable glyphs |	encoding := character leadingChar + 1.	ascii := character charCode.	ascii < (fontArray at: encoding) minAscii ifTrue: [		^ self error: 'Cant store characters below min ascii'	].	ascii > (fontArray at: encoding) maxAscii ifTrue: [		^ self error: 'No change made'	].	xTable := (fontArray at: encoding) xTable.	leftX := xTable at: ascii + 1.	rightX := xTable at: ascii + 2.	glyphs := (fontArray at: encoding) glyphs.	widthDif := characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue: [		newGlyphs := Form extent: glyphs width + widthDif @ glyphs height.		newGlyphs copy: (0 @ 0 corner: leftX @ glyphs height) from: 0 @ 0			in: glyphs rule: Form over.		newGlyphs				copy: (rightX + widthDif @ 0 corner: newGlyphs width @ glyphs height)				from: rightX @ 0 in: glyphs rule: Form over.		glyphs := newGlyphs.		"adjust further entries on xTable"		xTable := xTable copy.		ascii + 2 to: xTable size do: [:i |			xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 extent: characterForm extent) from: 0 @ 0 in: characterForm rule: Form over.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'sd 2/4/2008 21:20' prior: 31146080!characters: anInterval in: sourceString displayAt: aPoint clippedBy: clippingRectangle rule: ruleInteger fillColor: aForm kernDelta: kernDelta on: aBitBlt	"Simple, slow, primitive method for displaying a line of characters.	No wrap-around is provided."	| ascii encoding destPoint leftX rightX sourceRect xTable noFont f |	destPoint := aPoint.	anInterval do: 		[:i |		encoding := (sourceString at: i) leadingChar + 1.		noFont := false.		[f := fontArray at: encoding]			on: Exception do: [:ex | noFont := true. f := fontArray at: 1].		f ifNil: [noFont := true. f := fontArray at: 1].		ascii := noFont ifTrue: [$?] ifFalse: [(sourceString at: i) charCode].		(ascii < f minAscii			or: [ascii > f maxAscii])			ifTrue: [ascii := f maxAscii].		xTable := f xTable.		leftX := xTable at: ascii + 1.		rightX := xTable at: ascii + 2.		sourceRect := leftX@0 extent: (rightX-leftX) @ self height.		aBitBlt copyFrom: sourceRect in: f glyphs to: destPoint.		destPoint := destPoint + ((rightX-leftX+kernDelta)@0).		"destPoint printString displayAt: 0@(i*20)."	].	^ destPoint.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31135970!copy	| s a |	s := self class new.	s name: self name.	s emphasis: self emphasis.	s reset.	a := Array new: fontArray size.	1 to: a size do: [:i |		a at: i put: (fontArray at: i) copy.	].	s fontArray: a.	^ s.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'sd 2/4/2008 21:20' prior: 31149299!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	"Draw the given string from startIndex to stopIndex 	at aPoint on the (already prepared) BitBlt."		"Assume this is a wide string"	| isMulti |	isMulti := true.	"Look for an excuse to use the fast primitive" 	(aString isKindOf: ByteString) 		ifTrue:[ isMulti := false]		ifFalse:[ (aString isKindOf: Text) 			ifTrue:[ (aString string isKindOf: ByteString) 				ifTrue:[ isMulti := false ] 	]].	isMulti ifTrue:[^ self displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY].	^ aBitBlt displayString: aString 			from: startIndex 			to: stopIndex 			at: aPoint 			strikeFont: self			kern: kernDelta! !!StrikeFontSet methodsFor: 'displaying' stamp: 'sd 2/4/2008 21:20' prior: 31150161!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta from: fromFont baselineY: baselineY	| destPoint leftX rightX glyphInfo g tag char destY |	destPoint := aPoint.	rIndex := startIndex.	tag := (aString at: rIndex) leadingChar.	glyphInfo := Array new: 5.	[rIndex <= stopIndex] whileTrue: [		char := aString at: rIndex.		((fromFont hasGlyphOf: char) or: [char leadingChar ~= tag]) ifTrue: [^ Array with: rIndex with: destPoint].		self glyphInfoOf: char into: glyphInfo.		g := glyphInfo first.		leftX := glyphInfo second.		rightX := glyphInfo third.		(glyphInfo fifth ~= aBitBlt lastFont) ifTrue: [			glyphInfo fifth installOn: aBitBlt.		].		aBitBlt sourceForm: g.		destY := baselineY - glyphInfo fourth. 		aBitBlt destX: destPoint x.		aBitBlt destY: destY.		aBitBlt sourceOrigin: leftX @ 0.		aBitBlt width: rightX - leftX.		aBitBlt height: self height.		aBitBlt copyBits.		destPoint := destPoint + (rightX - leftX + kernDelta @ 0).		rIndex := rIndex + 1.	].	^ Array with: rIndex with: destPoint.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'sd 2/4/2008 21:20' prior: 31148083!displayStringR2L: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	| destPoint font |	destPoint := aPoint.	startIndex to: stopIndex do: [:charIndex | 		| encoding ascii xTable leftX rightX | 		encoding := (aString at: charIndex) leadingChar + 1.		ascii := (aString at: charIndex) charCode.		font := fontArray at: encoding.		((ascii between: font minAscii and: font maxAscii) not) ifTrue: [			ascii := font maxAscii].		xTable := font xTable.		leftX := xTable at: ascii + 1.		rightX := xTable at: ascii + 2.		aBitBlt sourceForm: font glyphs.		aBitBlt destX: destPoint x - (rightX - leftX).		aBitBlt destY: destPoint y.		aBitBlt sourceOrigin: leftX @ 0.		aBitBlt width: rightX - leftX.		aBitBlt height: self height.		aBitBlt copyBits.		destPoint := destPoint - (rightX - leftX + kernDelta @ 0).	].! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31137219!emphasis: code 	"Set the integer code for synthetic bold, itallic, underline, and strike-out, 	where bold=1, italic=2, underlined=4, and struck out=8."	emphasis := code.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31137475!emphasized: code 	"Answer a copy of the receiver with emphasis set to include code."	| derivative addedEmphasis base safeCode |	code = 0 ifTrue: [^ self].	(derivativeFonts == nil or: [derivativeFonts size = 0]) ifTrue: [^ self].	derivative := derivativeFonts at: (safeCode := code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis := 1 bitShift: safeCode highBit - 1.	base := self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative := (base copy name: base name , 'B') makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative := (base copy name: base name , 'I') makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative := (base copy name: base name , 'U') makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative := (base copy name: base name , 'N') makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative := (base copy name: base name , 'X') makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31139270!fontArray: anArray	fontArray := anArray.! !!StrikeFontSet methodsFor: 'private' stamp: 'sd 2/4/2008 21:14' prior: 31155546!glyphInfoOf: aCharacter into: glyphInfoArray	| index f code leftX |	index := aCharacter leadingChar + 1.	fontArray size < index ifTrue: [^ self questionGlyphInfoInto: glyphInfoArray].	(f := fontArray at: index) ifNil: [^ self questionGlyphInfoInto: glyphInfoArray].	code := aCharacter charCode.	((code between: f minAscii and: f maxAscii) not) ifTrue: [		^ self questionGlyphInfoInto: glyphInfoArray.	].	leftX := f xTable at: code + 1.	leftX < 0 ifTrue: [		^ self questionGlyphInfoInto: glyphInfoArray.	].	glyphInfoArray at: 1 put: f glyphs;		at: 2 put: leftX;		at: 3 put: (f xTable at: code + 2);		at: 4 put: (f ascentOf: aCharacter);		at: 5 put: self.	^ glyphInfoArray.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31141153!lineGrid	| f |	f := fontArray first.	^ f ascent + f descent.! !!StrikeFontSet methodsFor: 'emphasis' stamp: 'sd 2/4/2008 21:14' prior: 31151819!makeBoldGlyphs	"Make a bold set of glyphs with same widths by ORing 1 bit to the right		(requires at least 1 pixel of intercharacter space)"	| g bonkForm font |	1 to: fontArray size do: [:i |		font := fontArray at: i.		font ifNotNil: [			g := font glyphs deepCopy.			bonkForm := (Form extent: 1@16) fillBlack offset: -1@0.			self bonk: g with: bonkForm at: i.			g copyBits: g boundingBox from: g at: (1@0)				clippingBox: g boundingBox rule: Form under fillColor: nil.			(fontArray at: i) setGlyphs: g.		].	].! !!StrikeFontSet methodsFor: 'emphasis' stamp: 'sd 2/4/2008 21:18' prior: 31152414!makeItalicGlyphs	"Make an italic set of glyphs with same widths by skewing left and right		(may require more intercharacter space)"	| g bonkForm bc font |	1 to: fontArray size do: [:j |		font := (fontArray at: j).		font ifNotNil: [			g := font glyphs deepCopy.			"BonkForm will have bits where slanted characters overlap their neighbors."			bonkForm := Form extent: (self height//4+2) @ self height.			bc := font descent//4 + 1.  "Bonker x-coord corresponding to char boundary."			bonkForm fill: (0 @ 0 corner: (bc+1) @ font ascent) fillColor: Color black.			4 to: font ascent-1 by: 4 do:				[:y | 		"Slide ascenders right..."				g copy: (1@0 extent: g width @ (font ascent - y))					from: 0@0 in: g rule: Form over.				bonkForm copy: (1@0 extent: bonkForm width @ (font ascent - y))					from: 0@0 in: bonkForm rule: Form over].			bonkForm fill: (0 @ 0 corner: (bc+1) @ font ascent) fillColor: Color white.			bonkForm fill: (bc @ font ascent corner: bonkForm extent) fillColor: Color black.			font ascent to: font height-1 by: 4 do:				[:y | 		"Slide descenders left..."				g copy: (0@y extent: g width @ g height)					from: 1@y in: g rule: Form over.				bonkForm copy: (0@0 extent: bonkForm width @ bonkForm height)					from: 1@0 in: bonkForm rule: Form over].			bonkForm fill: (bc @ font ascent corner: bonkForm extent) fillColor: Color white.			"Now use bonkForm to erase at every character boundary in glyphs."			bonkForm offset: (0-bc) @ 0.			font bonk: g with: bonkForm.			font setGlyphs: g		].	].! !!StrikeFontSet methodsFor: 'emphasis' stamp: 'sd 2/4/2008 21:18' prior: 31154020!makeStruckOutGlyphs	"Make a struck-out set of glyphs with same widths"	| g font |	1 to: fontArray size do: [:i |		font := (fontArray at: i).		font ifNotNil: [			g := font glyphs deepCopy.			g fillBlack: (0 @ (font ascent - (font ascent//3)) extent: g width @ 1).			font setGlyphs: g		].	].! !!StrikeFontSet methodsFor: 'emphasis' stamp: 'sd 2/4/2008 21:18' prior: 31154392!makeUnderlinedGlyphs	"Make an underlined set of glyphs with same widths"	| g font |	1 to: fontArray size do: [:i |		font := (fontArray at: i).		font ifNotNil: [			g := font glyphs deepCopy.			g fillBlack: (0 @ (font ascent+1) extent: g width @ 1).			font setGlyphs: g		].	].! !!StrikeFontSet methodsFor: 'accessing' stamp: 'sd 2/4/2008 21:20' prior: 31134192!maxAsciiFor: encoding	| f |	f := (fontArray at: encoding+1).	f ifNotNil: [^ f maxAscii].	^ 0.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31141636!name: aString	name := aString! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31141750!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	dp := DiskProxy global: #StrikeFontSet selector: #familyName:size:emphasized:			args: (Array with: self familyName with: self pointSize					with: self emphasis).	refStrm replace: self with: dp.	^ dp.! !!StrikeFontSet methodsFor: 'private' stamp: 'sd 2/4/2008 21:14' prior: 31156305!questionGlyphInfoInto: glyphInfoArray	| f ascii |	f := fontArray at: 1.	ascii := $? asciiValue.	glyphInfoArray at: 1 put: f glyphs;		at: 2 put: (f xTable at: ascii + 1);		at: 3 put: (f xTable at: ascii + 2);		at: 4 put: (self ascentOf: $?);		at: 5 put: self.	^ glyphInfoArray.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31142726!reset	"Reset the cache of derivative emphasized fonts"	derivativeFonts := Array new: 32.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:20' prior: 31143519!widthOfString: aString from: startIndex to: stopIndex	"Measure the length of the given string between start and stop index"	| resultX |	resultX := 0.	startIndex to: stopIndex do:[:i | 		resultX := resultX + (self widthOf: (aString at: i))].	^ resultX.! !!X11Encoding class methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:21' prior: 50975709!encoding	| enc |	enc := self getEncoding.	enc ifNil: [ ^ nil ].	^ enc asLowercase.! !!LinedTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:11' prior: 23081381!computeForm: char	| ttGlyph scale |	char = Character tab ifTrue: [^ super computeForm: char].	"char = $U ifTrue: [self doOnlyOnce: [self halt]]."	scale := self pixelSize asFloat / (ttcDescription ascender - ttcDescription descender).	ttGlyph := ttcDescription at: char.	^ ttGlyph asFormWithScale: scale ascender: ttcDescription ascender descender: ttcDescription descender fgColor: foregroundColor bgColor: Color transparent depth: self depth replaceColor: false lineGlyph: lineGlyph lingGlyphWidth: contourWidth emphasis: emphasis! !!LinedTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:11' prior: 23082104!emphasis: code	emphasis := code.! !!LinedTTCFont methodsFor: 'as yet unclassified' stamp: 'sd 2/4/2008 21:11' prior: 23082219!lineGlyph: aGlyph	lineGlyph := aGlyph.	contourWidth := aGlyph calculateWidth.! !"Multilingual"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.332.mcz') load.ScriptLoader new updateFrom7067.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 2/14/2008 21:18'!script93	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.150.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.115.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.22.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/14/2008 21:45'!updateFrom7069	"self new updateFrom7069"		"unloading OB"		(MCWorkingCopy forPackage: (MCPackage new name: 'OmniBrowser')) unload.	(MCWorkingCopy forPackage: (MCPackage new name: 'OB-Standard')) unload.	SystemBrowser removeObsolete.	SystemOrganization removeCategoriesMatching: 'OmniBrowser*'.	SystemOrganization removeCategoriesMatching: 'OB-Standard*'.		World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	self flushCaches.				! !"ScriptLoader"!PluggableButtonMorph removeSelector: #isOn!OBTextMorph removeSelector: #installEditorToReplace:!Smalltalk removeClassNamed: #OBTextMorph!Object removeSelector: #asAnnouncement!OBService removeSelector: #wantsButton!OBService removeSelector: #useLineAfter!OBService removeSelector: #trigger!OBService removeSelector: #labelWithKeystroke!OBService removeSelector: #label:!OBService removeSelector: #label!OBService removeSelector: #keystroke:!OBService removeSelector: #keystroke!OBService removeSelector: #isEnabledFor:!OBService removeSelector: #isEnabled!OBService removeSelector: #initialize!OBService removeSelector: #icon:!OBService removeSelector: #icon!OBService removeSelector: #executeFor:!OBService removeSelector: #execute!OBService removeSelector: #description!OBService removeSelector: #condition:!OBService removeSelector: #condition!OBService removeSelector: #condExecuteFor:!OBService removeSelector: #buttonMorph!OBService removeSelector: #buttonLabelMorph!OBService removeSelector: #buttonLabel:!OBService removeSelector: #buttonLabel!OBService removeSelector: #announcer:!OBService removeSelector: #announcer!OBService removeSelector: #addServiceFor:toMenu:!OBService removeSelector: #action:!OBService removeSelector: #action!OBService class removeSelector: #new!OBService class removeSelector: #action:condition:!OBService class removeSelector: #action:!Smalltalk removeClassNamed: #OBService!OBRequestor removeSelector: #select:!OBRequestor removeSelector: #requestNode!OBRequestor removeSelector: #node:!OBRequestor removeSelector: #doesNotUnderstand:!OBRequestor removeSelector: #browser:!OBRequestor removeSelector: #announce:!OBRequestor class removeSelector: #for:!Smalltalk removeClassNamed: #OBRequestor!OBVarButtonPanel removeSelector: #subscribe!OBVarButtonPanel removeSelector: #selectionChanged:!OBVarButtonPanel removeSelector: #morphHeight!OBVarButtonPanel removeSelector: #morph!Smalltalk removeClassNamed: #OBVarButtonPanel!OBPanel removeSelector: #subscribe!OBPanel removeSelector: #isNavigation!OBPanel removeSelector: #browser:!OBPanel removeSelector: #browser!OBPanel removeSelector: #announcer!OBPanel class removeSelector: #inBrowser:!OBFixedButtonPanel removeSelector: #subscribe!OBFixedButtonPanel removeSelector: #selectionChanged:!OBFixedButtonPanel removeSelector: #push:!OBFixedButtonPanel removeSelector: #morphHeight!OBFixedButtonPanel removeSelector: #morphForModel:!OBFixedButtonPanel removeSelector: #morph!OBFixedButtonPanel removeSelector: #isSelected:!OBFixedButtonPanel removeSelector: #isEnabled:!OBFixedButtonPanel removeSelector: #initialize!OBFixedButtonPanel removeSelector: #createMorph!OBFixedButtonPanel removeSelector: #buttonModels!OBFixedButtonPanel removeSelector: #addButtonWithLabel:!OBFixedButtonPanel class removeSelector: #new!Smalltalk removeClassNamed: #OBFixedButtonPanel!OBDefinitionPanel removeSelector: #yellowButtonMenu!OBDefinitionPanel removeSelector: #withDefinitionDo:ifNil:!OBDefinitionPanel removeSelector: #text!OBDefinitionPanel removeSelector: #subscribe!OBDefinitionPanel removeSelector: #shiftedYellowButtonMenu!OBDefinitionPanel removeSelector: #selectionChanged:!OBDefinitionPanel removeSelector: #selection!OBDefinitionPanel removeSelector: #selectedClass!OBDefinitionPanel removeSelector: #refresh:!OBDefinitionPanel removeSelector: #perform:orSendTo:!OBDefinitionPanel removeSelector: #morphHeight!OBDefinitionPanel removeSelector: #morph!OBDefinitionPanel removeSelector: #menu:shifted:!OBDefinitionPanel removeSelector: #getDefinition!OBDefinitionPanel removeSelector: #doItReceiver!OBDefinitionPanel removeSelector: #doItContext!OBDefinitionPanel removeSelector: #definitionChanged:!OBDefinitionPanel removeSelector: #definition:!OBDefinitionPanel removeSelector: #accept:notifying:!OBDefinitionPanel removeSelector: #aboutToChange:!Smalltalk removeClassNamed: #OBDefinitionPanel!OBColumnPanel removeSelector: #subscribe!OBColumnPanel removeSelector: #sizing!OBColumnPanel removeSelector: #setMinPanes:maxPanes:!OBColumnPanel removeSelector: #setMetaNode:node:!OBColumnPanel removeSelector: #selectionPath!OBColumnPanel removeSelector: #selectionChanged:!OBColumnPanel removeSelector: #selected:!OBColumnPanel removeSelector: #selectNode:!OBColumnPanel removeSelector: #root!OBColumnPanel removeSelector: #reclaimPanes!OBColumnPanel removeSelector: #pushColumn:!OBColumnPanel removeSelector: #popColumn!OBColumnPanel removeSelector: #parentNodeForColumn:!OBColumnPanel removeSelector: #panes!OBColumnPanel removeSelector: #okToReclaimPane!OBColumnPanel removeSelector: #nodeDeleted:!OBColumnPanel removeSelector: #morphHeight!OBColumnPanel removeSelector: #morph!OBColumnPanel removeSelector: #minPanes!OBColumnPanel removeSelector: #maxPanes!OBColumnPanel removeSelector: #labelString!OBColumnPanel removeSelector: #jumpToRoot!OBColumnPanel removeSelector: #jumpTo:!OBColumnPanel removeSelector: #isNavigation!OBColumnPanel removeSelector: #hopTo:!OBColumnPanel removeSelector: #hasSelection!OBColumnPanel removeSelector: #emptyColumn!OBColumnPanel removeSelector: #defaultBackgroundColor!OBColumnPanel removeSelector: #currentOrRootNode!OBColumnPanel removeSelector: #currentNode!OBColumnPanel removeSelector: #currentColumn!OBColumnPanel removeSelector: #columns:!OBColumnPanel removeSelector: #columns!OBColumnPanel removeSelector: #columnBefore:ifAbsent:!OBColumnPanel removeSelector: #columnBefore:!OBColumnPanel removeSelector: #columnAfter:!OBColumnPanel removeSelector: #clearAfter:!OBColumnPanel removeSelector: #buildScroller!OBColumnPanel class removeSelector: #new!OBColumnPanel class removeSelector: #minPanes:maxPanes:!Smalltalk removeClassNamed: #OBColumnPanel!Smalltalk removeClassNamed: #OBPanel!OBNode removeSelector: #wantsDroppedNode:!OBNode removeSelector: #title!OBNode removeSelector: #textSelection!OBNode removeSelector: #text:!OBNode removeSelector: #text!OBNode removeSelector: #signalSelection!OBNode removeSelector: #signalDeletion!OBNode removeSelector: #signalChildrenChanged!OBNode removeSelector: #signalChanged!OBNode removeSelector: #referenceForMethod:ofClass:!OBNode removeSelector: #name!OBNode removeSelector: #metaNode:!OBNode removeSelector: #metaNode!OBNode removeSelector: #isDescendantOf:!OBNode removeSelector: #isAncestorOf:!OBNode removeSelector: #hash!OBNode removeSelector: #dropSelector!OBNode removeSelector: #displayString!OBNode removeSelector: #displayName!OBNode removeSelector: #demandSelection!OBNode removeSelector: #definition!OBNode removeSelector: #correspondsWith:!OBNode removeSelector: #asDraggableMorph!OBNode removeSelector: #announce:!OBNode removeSelector: #ancestrySelector!OBNode removeSelector: #actions!OBNode removeSelector: #action:withMenuLabel:withButtonLabel:withKeystroke:withIcon:!OBNode removeSelector: #action:withLabel:withKeystroke:withIcon:!OBNode removeSelector: #action:withLabel:withKeystroke:!OBNode removeSelector: #action:withLabel:withIcon:!OBNode removeSelector: #action:withLabel:!OBNode removeSelector: #action:buttonLabel:menuLabel:!OBNode removeSelector: #acceptDroppedNode:!OBNode removeSelector: #accept:notifying:!OBNode removeSelector: #=!OBNode class removeSelector: #fromAssociation:!OBNode class removeSelector: #actionsForParent:!OBCollectionNode removeSelector: #setCollection:!OBCollectionNode removeSelector: #name!OBCollectionNode removeSelector: #children!OBCollectionNode class removeSelector: #on:!Smalltalk removeClassNamed: #OBCollectionNode!Smalltalk removeClassNamed: #OBNode!OBMorphicPanelLayout removeSelector: #setPanels:!OBMorphicPanelLayout removeSelector: #navigationPanel!OBMorphicPanelLayout removeSelector: #columnProportion!OBMorphicPanelLayout removeSelector: #addOtherMorphsTo:!OBMorphicPanelLayout removeSelector: #addNavMorphTo:!OBMorphicPanelLayout removeSelector: #addMorphsTo:!OBMorphicPanelLayout class removeSelector: #for:!Smalltalk removeClassNamed: #OBMorphicPanelLayout!OBMetaNode removeSelector: #shortPrintOn:!OBMetaNode removeSelector: #printOn:!OBMetaNode removeSelector: #nodesForParent:!OBMetaNode removeSelector: #name:!OBMetaNode removeSelector: #name!OBMetaNode removeSelector: #metaNode!OBMetaNode removeSelector: #initialize!OBMetaNode removeSelector: #hasChildren!OBMetaNode removeSelector: #filterClass:!OBMetaNode removeSelector: #filter!OBMetaNode removeSelector: #edges!OBMetaNode removeSelector: #displaySelector:!OBMetaNode removeSelector: #displaySelector!OBMetaNode removeSelector: #columnInPanel:node:!OBMetaNode removeSelector: #columnClass:!OBMetaNode removeSelector: #children!OBMetaNode removeSelector: #childAt:put:!OBMetaNode removeSelector: #childAt:labeled:put:!OBMetaNode removeSelector: #addActor:!OBMetaNode removeSelector: #actionsForParent:!OBMetaNode removeSelector: #actionsForNode:!OBMetaNode removeSelector: #actionSetsForParent:!OBMetaNode removeSelector: #actionSetsForNode:!OBMetaNode class removeSelector: #new!OBMetaNode class removeSelector: #named:!Smalltalk removeClassNamed: #OBMetaNode!OBMetaEdge removeSelector: #setLabel:selector:metaNode:!OBMetaEdge removeSelector: #selector!OBMetaEdge removeSelector: #printOn:!OBMetaEdge removeSelector: #nodesForParent:!OBMetaEdge removeSelector: #metaNode!OBMetaEdge removeSelector: #label!OBMetaEdge class removeSelector: #selector:metaNode:!OBMetaEdge class removeSelector: #label:selector:metaNode:!Smalltalk removeClassNamed: #OBMetaEdge!OBModalFilter removeSelector: #wantsButton!OBModalFilter removeSelector: #selection:!OBModalFilter removeSelector: #selection!OBModalFilter removeSelector: #selectedEdge!OBModalFilter removeSelector: #selectAncestorOf:withParent:!OBModalFilter removeSelector: #nodesForParent:!OBModalFilter removeSelector: #list!OBModalFilter removeSelector: #incrementSelection!OBModalFilter removeSelector: #buttonMorph!Smalltalk removeClassNamed: #OBModalFilter!OBFilter removeSelector: #wantsButton!OBFilter removeSelector: #setMetaNode:!OBFilter removeSelector: #selectAncestorOf:withParent:!OBFilter removeSelector: #nodesForParent:!OBFilter removeSelector: #monitor:!OBFilter removeSelector: #metaNode!OBFilter removeSelector: #children!OBFilter class removeSelector: #forMetaNode:!Smalltalk removeClassNamed: #OBFilter!OBDefinition removeSelector: #textSelection!OBDefinition removeSelector: #text:!OBDefinition removeSelector: #text!OBDefinition removeSelector: #signalChange!OBDefinition removeSelector: #selection!OBDefinition removeSelector: #doItReceiver!OBDefinition removeSelector: #doItContext!OBDefinition removeSelector: #accept:notifying:!Smalltalk removeClassNamed: #OBDefinition!OBColumn removeSelector: #wantsDroppedMorph:event:inMorph:!OBColumn removeSelector: #wantsButton!OBColumn removeSelector: #subscribe!OBColumn removeSelector: #simplePane!OBColumn removeSelector: #signalSelectionChanged!OBColumn removeSelector: #shouldBeLast!OBColumn removeSelector: #setPanel:metaNode:node:!OBColumn removeSelector: #setPanel:!OBColumn removeSelector: #servicesForKeystroke:!OBColumn removeSelector: #selectionChanged:!OBColumn removeSelector: #selection:!OBColumn removeSelector: #selection!OBColumn removeSelector: #selectedNode!OBColumn removeSelector: #selectSilently:!OBColumn removeSelector: #selectAncestorOf:!OBColumn removeSelector: #select:!OBColumn removeSelector: #requestor!OBColumn removeSelector: #refreshAndSignal:!OBColumn removeSelector: #refresh:!OBColumn removeSelector: #refresh!OBColumn removeSelector: #printOn:!OBColumn removeSelector: #parent:!OBColumn removeSelector: #parent!OBColumn removeSelector: #paneWithHeader!OBColumn removeSelector: #okToChange!OBColumn removeSelector: #nodeForItem:inMorph:!OBColumn removeSelector: #nodeForDroppedMorph:event:inMorph:!OBColumn removeSelector: #nodeDeleted:!OBColumn removeSelector: #nodeChanged:!OBColumn removeSelector: #nextMetaNode!OBColumn removeSelector: #next!OBColumn removeSelector: #morph!OBColumn removeSelector: #metaNode!OBColumn removeSelector: #menu:!OBColumn removeSelector: #listSize!OBColumn removeSelector: #listMorph!OBColumn removeSelector: #listChanged!OBColumn removeSelector: #listAt:!OBColumn removeSelector: #list!OBColumn removeSelector: #keystroke:from:!OBColumn removeSelector: #isEmpty!OBColumn removeSelector: #includesNode:!OBColumn removeSelector: #hasSelection!OBColumn removeSelector: #getChildren!OBColumn removeSelector: #filter:!OBColumn removeSelector: #filter!OBColumn removeSelector: #dropEnabled!OBColumn removeSelector: #dragTransferTypeForMorph:!OBColumn removeSelector: #dragTransferType!OBColumn removeSelector: #dragPassengerFor:inMorph:!OBColumn removeSelector: #dragEnabled!OBColumn removeSelector: #descriptor!OBColumn removeSelector: #createNext!OBColumn removeSelector: #columnWithHeader!OBColumn removeSelector: #clearSelection!OBColumn removeSelector: #clear!OBColumn removeSelector: #childrenChanged:!OBColumn removeSelector: #buttonHeight!OBColumn removeSelector: #browser!OBColumn removeSelector: #basicNext!OBColumn removeSelector: #announcer!OBColumn removeSelector: #addServicesToMenu:!OBColumn removeSelector: #addActionsToMenu:!OBColumn removeSelector: #actionsForSelectedNode!OBColumn removeSelector: #actionsForParentNode!OBColumn removeSelector: #actionsForKeystroke:!OBColumn removeSelector: #actionSetsForSelectedNode!OBColumn removeSelector: #actionSetsForParentNode!OBColumn removeSelector: #acceptDroppingMorph:event:inMorph:!OBColumn class removeSelector: #inPanel:metaNode:node:!OBColumn class removeSelector: #inPanel:!Smalltalk removeClassNamed: #OBColumn!OBButtonModel removeSelector: #selectionChanged!OBButtonModel removeSelector: #push!OBButtonModel removeSelector: #morph!OBButtonModel removeSelector: #labelMorph!OBButtonModel removeSelector: #label:!OBButtonModel removeSelector: #label!OBButtonModel removeSelector: #isSelected!OBButtonModel removeSelector: #isEnabled!OBButtonModel removeSelector: #bar:!OBButtonModel class removeSelector: #withLabel:inBar:!OBButtonModel class removeSelector: #onColor!OBButtonModel class removeSelector: #offColor!Smalltalk removeClassNamed: #OBButtonModel!OBBrowser removeSelector: #transcribe!OBBrowser removeSelector: #subscribe!OBBrowser removeSelector: #signalRefresh!OBBrowser removeSelector: #setMetaNode:node:!OBBrowser removeSelector: #selectionPath!OBBrowser removeSelector: #root!OBBrowser removeSelector: #requestor!OBBrowser removeSelector: #relabel:!OBBrowser removeSelector: #panels!OBBrowser removeSelector: #openInMorphic!OBBrowser removeSelector: #open!OBBrowser removeSelector: #okToChange!OBBrowser removeSelector: #navigationPanel!OBBrowser removeSelector: #morphicPanelLayout!OBBrowser removeSelector: #morph!OBBrowser removeSelector: #labelString!OBBrowser removeSelector: #jumpToRoot!OBBrowser removeSelector: #jumpTo:!OBBrowser removeSelector: #initialize!OBBrowser removeSelector: #dontTranscribe!OBBrowser removeSelector: #defaultLabel!OBBrowser removeSelector: #defaultBackgroundColor!OBBrowser removeSelector: #currentOrRootNode!OBBrowser removeSelector: #currentNode!OBBrowser removeSelector: #announcer!OBBrowser removeSelector: #addPanel:!OBBrowser class removeSelector: #titleForRoot:!OBBrowser class removeSelector: #title!OBBrowser class removeSelector: #selection:!OBBrowser class removeSelector: #root:selection:!OBBrowser class removeSelector: #root:!OBBrowser class removeSelector: #panels!OBBrowser class removeSelector: #paneCount!OBBrowser class removeSelector: #optionalButtons!OBBrowser class removeSelector: #optionalButtonPanel!OBBrowser class removeSelector: #openRoot:selection:!OBBrowser class removeSelector: #open!OBBrowser class removeSelector: #new!OBBrowser class removeSelector: #navigationPanel!OBBrowser class removeSelector: #minPanes!OBBrowser class removeSelector: #metaNode:root:selection:panels:!OBBrowser class removeSelector: #metaNode:root:selection:!OBBrowser class removeSelector: #metaNode:node:!OBBrowser class removeSelector: #maxPanes!OBBrowser class removeSelector: #definitionPanel!OBBrowser class removeSelector: #defaultRootNode!OBBrowser class removeSelector: #defaultMetaNode!Smalltalk removeClassNamed: #OBBrowser!OBAnnouncer removeSelector: #unsubscribe:!OBAnnouncer removeSelector: #observe:send:to:!OBAnnouncer removeSelector: #observe:do:!OBAnnouncer removeSelector: #initialize!OBAnnouncer removeSelector: #announce:!OBAnnouncer class removeSelector: #new!OBAnnouncer class removeSelector: #current!Smalltalk removeClassNamed: #OBAnnouncer!OBServiceScan removeSelector: #services!OBServiceScan removeSelector: #initialize!OBServiceScan removeSelector: #addService:!Smalltalk removeClassNamed: #OBServiceScan!OBSelectionChanged removeSelector: #node:!OBSelectionChanged removeSelector: #node!OBSelectionChanged removeSelector: #column:!OBSelectionChanged removeSelector: #column!OBSelectionChanged class removeSelector: #node:!OBSelectionChanged class removeSelector: #column:!Smalltalk removeClassNamed: #OBSelectionChanged!OBSelectingNode removeSelector: #node:!OBSelectingNode removeSelector: #node!OBSelectingNode class removeSelector: #node:!Smalltalk removeClassNamed: #OBSelectingNode!Smalltalk removeClassNamed: #OBRefreshRequired!OBNodeDeleted removeSelector: #node:!OBNodeDeleted removeSelector: #node!OBNodeDeleted class removeSelector: #node:!Smalltalk removeClassNamed: #OBNodeDeleted!OBNodeCreated removeSelector: #node:!OBNodeCreated removeSelector: #node!OBNodeCreated class removeSelector: #node:!Smalltalk removeClassNamed: #OBNodeCreated!OBNodeChanged removeSelector: #node:!OBNodeChanged removeSelector: #node!OBNodeChanged class removeSelector: #node:!Smalltalk removeClassNamed: #OBNodeChanged!OBDefinitionChanged removeSelector: #node:!OBDefinitionChanged removeSelector: #node!OBDefinitionChanged removeSelector: #definition:!OBDefinitionChanged removeSelector: #definition!OBDefinitionChanged class removeSelector: #node:definition:!OBDefinitionChanged class removeSelector: #definition:!Smalltalk removeClassNamed: #OBDefinitionChanged!OBChildrenChanged removeSelector: #node:!OBChildrenChanged removeSelector: #node!OBChildrenChanged class removeSelector: #node:!Smalltalk removeClassNamed: #OBChildrenChanged!OBAboutToChange removeSelector: #veto!OBAboutToChange removeSelector: #isVetoed!Smalltalk removeClassNamed: #OBAboutToChange!Smalltalk removeClassNamed: #OBAnnouncement!OBNodeActor removeSelector: #nodeClass:!OBNodeActor removeSelector: #actionsForParent:!OBNodeActor removeSelector: #actionsForNode:!OBNodeActor class removeSelector: #onNodeClass:!Smalltalk removeClassNamed: #OBNodeActor!OBActor removeSelector: #newIcon!OBActor removeSelector: #findIcon!OBActor removeSelector: #deleteIcon!OBActor removeSelector: #actionsForParent:!OBActor removeSelector: #actionsForNode:!OBActor removeSelector: #actionWithLabel:selector:!Smalltalk removeClassNamed: #OBActor!OBScrollBar removeSelector: #wantsSteps!OBScrollBar removeSelector: #waitForDelay1:delay2:!OBScrollBar removeSelector: #upArrow8Bit!OBScrollBar removeSelector: #totalSliderArea!OBScrollBar removeSelector: #thumbColor!OBScrollBar removeSelector: #stepTime!OBScrollBar removeSelector: #step!OBScrollBar removeSelector: #sliderThickness!OBScrollBar removeSelector: #sliderShadowColor!OBScrollBar removeSelector: #sliderExtent!OBScrollBar removeSelector: #sliderColor:!OBScrollBar removeSelector: #setValue:!OBScrollBar removeSelector: #setNextDirectionFromEvent:!OBScrollBar removeSelector: #scrollUpInit!OBScrollBar removeSelector: #scrollUp:!OBScrollBar removeSelector: #scrollUp!OBScrollBar removeSelector: #scrollPageInit:!OBScrollBar removeSelector: #scrollDownInit!OBScrollBar removeSelector: #scrollDown:!OBScrollBar removeSelector: #scrollDown!OBScrollBar removeSelector: #scrollDelta:pageDelta:!OBScrollBar removeSelector: #scrollDelta!OBScrollBar removeSelector: #scrollBarAction:!OBScrollBar removeSelector: #scrollBarAction!OBScrollBar removeSelector: #roundedScrollbarLook!OBScrollBar removeSelector: #resetTimer!OBScrollBar removeSelector: #pagingArea!OBScrollBar removeSelector: #mouseDownInSlider:!OBScrollBar removeSelector: #menuButtonMouseDown:!OBScrollBar removeSelector: #interval:!OBScrollBar removeSelector: #initializeUpButton!OBScrollBar removeSelector: #initializeSlider!OBScrollBar removeSelector: #initializePagingArea!OBScrollBar removeSelector: #initializeEmbedded:!OBScrollBar removeSelector: #initializeDownButton!OBScrollBar removeSelector: #initialize!OBScrollBar removeSelector: #finishedScrolling!OBScrollBar removeSelector: #extent:!OBScrollBar removeSelector: #expandSlider!OBScrollBar removeSelector: #doScrollUp!OBScrollBar removeSelector: #doScrollDown!OBScrollBar removeSelector: #doScrollByPage!OBScrollBar removeSelector: #cachedImageAt:ifAbsentPut:!OBScrollBar removeSelector: #buttonExtent!OBScrollBar removeSelector: #adoptPaneColor:!OBScrollBar class removeSelector: #initialize!OBScrollBar class removeSelector: #alwaysShowFlatScrollbarForAlternativeLook!Smalltalk removeClassNamed: #OBScrollBar!LazyListMorph removeSelector: #rectForRow:!MenuIcons class removeSelector: #tryIcons:!OBPluggableTextMorph removeSelector: #setText:!OBPluggableTextMorph removeSelector: #keyStroke:!Smalltalk removeClassNamed: #OBPluggableTextMorph!Behavior removeSelector: #asAnnouncement!OBRadioButtonBar removeSelector: #withSelectedButtonDo:!OBRadioButtonBar removeSelector: #withButtonAt:do:!OBRadioButtonBar removeSelector: #updateSelection!OBRadioButtonBar removeSelector: #updateMorphs!OBRadioButtonBar removeSelector: #updateList!OBRadioButtonBar removeSelector: #updateButtons!OBRadioButtonBar removeSelector: #update:!OBRadioButtonBar removeSelector: #push:!OBRadioButtonBar removeSelector: #on:list:selected:changeSelected:!OBRadioButtonBar removeSelector: #noteNewOwner:!OBRadioButtonBar removeSelector: #model:!OBRadioButtonBar removeSelector: #list!OBRadioButtonBar removeSelector: #isSelected:!OBRadioButtonBar removeSelector: #isEnabled:!OBRadioButtonBar removeSelector: #initGeometry!OBRadioButtonBar removeSelector: #getSelectionIndex!OBRadioButtonBar removeSelector: #adoptPaneColor:!OBRadioButtonBar class removeSelector: #on:list:selected:changeSelected:!Smalltalk removeClassNamed: #OBRadioButtonBar!OBPaneScroller removeSelector: #updateSizing!OBPaneScroller removeSelector: #updatePanes!OBPaneScroller removeSelector: #update:!OBPaneScroller removeSelector: #totalScrollRange!OBPaneScroller removeSelector: #totalPaneWidth!OBPaneScroller removeSelector: #stepTime!OBPaneScroller removeSelector: #step!OBPaneScroller removeSelector: #sizing!OBPaneScroller removeSelector: #showScrollBar!OBPaneScroller removeSelector: #setScrollDeltas!OBPaneScroller removeSelector: #separatorWidth!OBPaneScroller removeSelector: #separator!OBPaneScroller removeSelector: #scrollToRight!OBPaneScroller removeSelector: #scrollDeltaWidth!OBPaneScroller removeSelector: #scrollBarValue:!OBPaneScroller removeSelector: #scrollBarIsVisible!OBPaneScroller removeSelector: #scrollBarHeight!OBPaneScroller removeSelector: #resizeScrollBar!OBPaneScroller removeSelector: #reclaimPanes!OBPaneScroller removeSelector: #pushPane:!OBPaneScroller removeSelector: #popPanes:!OBPaneScroller removeSelector: #panes!OBPaneScroller removeSelector: #paneWidthsToFit:!OBPaneScroller removeSelector: #paneHeight!OBPaneScroller removeSelector: #paneCount!OBPaneScroller removeSelector: #model:!OBPaneScroller removeSelector: #model!OBPaneScroller removeSelector: #leftoverScrollRange!OBPaneScroller removeSelector: #layoutWidgets!OBPaneScroller removeSelector: #layoutPanes!OBPaneScroller removeSelector: #isScrollable!OBPaneScroller removeSelector: #innerBounds!OBPaneScroller removeSelector: #initializeTransform!OBPaneScroller removeSelector: #initializeScrollbar!OBPaneScroller removeSelector: #initialize!OBPaneScroller removeSelector: #hideScrollBar!OBPaneScroller removeSelector: #hideOrShowScrollBar!OBPaneScroller removeSelector: #doLayout!OBPaneScroller removeSelector: #computeMorphWidths!OBPaneScroller removeSelector: #clearPanes!OBPaneScroller removeSelector: #bounds:!OBPaneScroller removeSelector: #basicUpdateSizing!OBPaneScroller removeSelector: #basicUpdatePanes!OBPaneScroller removeSelector: #adjustPaneHeight!OBPaneScroller class removeSelector: #withModel:!Smalltalk removeClassNamed: #OBPaneScroller!OBPane removeSelector: #update:!OBPane removeSelector: #setColumn:filter:!OBPane removeSelector: #removeButton!OBPane removeSelector: #noteNewOwner:!OBPane removeSelector: #model:!OBPane removeSelector: #initGeometry!OBPane removeSelector: #hasButton!OBPane removeSelector: #defaultButtonHeight!OBPane removeSelector: #buttonHeight!OBPane removeSelector: #bounds:!OBPane removeSelector: #adjustList!OBPane removeSelector: #adjustButton!OBPane removeSelector: #addButton:!OBPane class removeSelector: #forColumn:withFilter:!OBPane class removeSelector: #forColumn:!Smalltalk removeClassNamed: #OBPane!OBTextMorphEditor removeSelector: #sendersOfIt!OBTextMorphEditor removeSelector: #send:toModelWith:orDo:!OBTextMorphEditor removeSelector: #referencesToIt!OBTextMorphEditor removeSelector: #implementorsOfIt!OBTextMorphEditor removeSelector: #browseIt!Smalltalk removeClassNamed: #OBTextMorphEditor!PluggableListMorph removeSelector: #getListObtrusively!PluggableListMorph removeSelector: #getListDelicately!OBTextRequest removeSelector: #template:!OBTextRequest removeSelector: #template!OBTextRequest removeSelector: #requestText!OBTextRequest removeSelector: #prompt:!OBTextRequest removeSelector: #prompt!OBTextRequest removeSelector: #defaultAction!OBTextRequest class removeSelector: #prompt:template:!OBTextRequest class removeSelector: #prompt:!Smalltalk removeClassNamed: #OBTextRequest!OBInteractionRequest removeSelector: #isBrowseRequest!OBConfirmationRequest removeSelector: #setPrompt:confirm:cancel:!OBConfirmationRequest removeSelector: #ok!OBConfirmationRequest removeSelector: #defaultAction!OBConfirmationRequest removeSelector: #cancel!OBConfirmationRequest class removeSelector: #prompt:confirm:cancel:!OBConfirmationRequest class removeSelector: #prompt:confirm:!OBConfirmationRequest class removeSelector: #prompt:!OBConfirmationRequest class removeSelector: #newPrompt:confirm:cancel:!Smalltalk removeClassNamed: #OBConfirmationRequest!OBChoiceRequest removeSelector: #values!OBChoiceRequest removeSelector: #setPrompt:labels:values:lines:!OBChoiceRequest removeSelector: #prompt!OBChoiceRequest removeSelector: #lines!OBChoiceRequest removeSelector: #labels!OBChoiceRequest removeSelector: #defaultAction!OBChoiceRequest class removeSelector: #prompt:labels:values:lines:!OBChoiceRequest class removeSelector: #prompt:labels:values:!OBChoiceRequest class removeSelector: #labels:lines:!OBChoiceRequest class removeSelector: #labels:!Smalltalk removeClassNamed: #OBChoiceRequest!OBBrowseRequest removeSelector: #isBrowseRequest!OBBrowseRequest removeSelector: #defaultAction!OBBrowseRequest removeSelector: #browser:!OBBrowseRequest removeSelector: #browser!OBBrowseRequest class removeSelector: #signal:!Smalltalk removeClassNamed: #OBBrowseRequest!Smalltalk removeClassNamed: #OBInteractionRequest!Smalltalk removeClassNamed: #OBDispatcherRequest!Smalltalk removeClassNamed: #OBAnnouncerRequest!OBAction removeSelector: #wantsButton!OBAction removeSelector: #trigger!OBAction removeSelector: #perform:orSendTo:!OBAction removeSelector: #labelWithKeystroke!OBAction removeSelector: #label:!OBAction removeSelector: #label!OBAction removeSelector: #keystroke:!OBAction removeSelector: #keystroke!OBAction removeSelector: #icon:!OBAction removeSelector: #icon!OBAction removeSelector: #buttonMorph!OBAction removeSelector: #buttonLabelMorph!OBAction removeSelector: #buttonLabel:!OBAction removeSelector: #buttonLabel!OBAction removeSelector: #announcer:!OBAction removeSelector: #announcer!OBAction removeSelector: #addItemToMenu:!OBAction class removeSelector: #label:receiver:selector:arguments:keystroke:icon:!OBAction class removeSelector: #label:receiver:selector:arguments:keystroke:!OBAction class removeSelector: #label:receiver:selector:arguments:icon:!OBAction class removeSelector: #label:receiver:selector:arguments:!OBAction class removeSelector: #label:buttonLabel:receiver:selector:arguments:keystroke:icon:!OBAction class removeSelector: #label:buttonLabel:receiver:selector:arguments:!Smalltalk removeClassNamed: #OBAction!MessageSend removeSelector: #valueWithPossibleArgs:!SystemOrganizer removeSelector: #isClassOrganizer!OBSystemBrowserAdaptor removeSelector: #targetClass!OBSystemBrowserAdaptor removeSelector: #setClass:selector:!OBSystemBrowserAdaptor removeSelector: #selector!OBSystemBrowserAdaptor removeSelector: #openEditString:!OBSystemBrowserAdaptor removeSelector: #labelString!OBSystemBrowserAdaptor class removeSelector: #unregister!OBSystemBrowserAdaptor class removeSelector: #register!OBSystemBrowserAdaptor class removeSelector: #openBrowserView:label:!OBSystemBrowserAdaptor class removeSelector: #openBrowser!OBSystemBrowserAdaptor class removeSelector: #open!OBSystemBrowserAdaptor class removeSelector: #initialize!OBSystemBrowserAdaptor class removeSelector: #fullOnClass:selector:!Smalltalk removeClassNamed: #OBSystemBrowserAdaptor!OBMethodVersion removeSelector: #theClassName!OBMethodVersion removeSelector: #theClass!OBMethodVersion removeSelector: #stamp!OBMethodVersion removeSelector: #source!OBMethodVersion removeSelector: #setSources:pointer:!OBMethodVersion removeSelector: #setSelector!OBMethodVersion removeSelector: #selector!OBMethodVersion removeSelector: #previous!OBMethodVersion removeSelector: #pointer!OBMethodVersion removeSelector: #parseSource!OBMethodVersion removeSelector: #parseChunk:!OBMethodVersion removeSelector: #latest!OBMethodVersion removeSelector: #hash!OBMethodVersion removeSelector: #fileIn!OBMethodVersion removeSelector: #classSymbol!OBMethodVersion removeSelector: #category!OBMethodVersion removeSelector: #=!OBMethodVersion class removeSelector: #versionsOfMethod:!OBMethodVersion class removeSelector: #scan:from:!OBMethodVersion class removeSelector: #fromSources:andPointer:!Smalltalk removeClassNamed: #OBMethodVersion!OBClassReference removeSelector: #theNonMetaName:!OBClassReference removeSelector: #theNonMetaName!OBClassReference removeSelector: #theNonMetaClass!OBClassReference removeSelector: #theClass!OBClassReference removeSelector: #setName:!OBClassReference removeSelector: #referenceToMethod:!OBClassReference removeSelector: #printOn:!OBClassReference removeSelector: #name!OBClassReference removeSelector: #isMeta!OBClassReference removeSelector: #hash!OBClassReference removeSelector: #beNonMeta!OBClassReference removeSelector: #beMeta!OBClassReference removeSelector: #=!OBClassReference removeSelector: #<=!OBClassReference class removeSelector: #to:!OBClassReference class removeSelector: #named:!OBClassReference class removeSelector: #metaNamed:!Smalltalk removeClassNamed: #OBClassReference!OBCategoryServant removeSelector: #svcCreateCategory!OBCategoryServant removeSelector: #services!OBCategoryServant removeSelector: #createCategory:!OBCategoryServant removeSelector: #categoryTemplateFor:!Smalltalk removeClassNamed: #OBCategoryServant!ClassTrait removeSelector: #asNode!ClassTrait removeSelector: #asClassSideNode!MethodReference removeSelector: #asNode!Class removeSelector: #asNode!Class removeSelector: #asClassSideNode!Metaclass removeSelector: #asNode!Metaclass removeSelector: #asClassSideNode!Trait removeSelector: #asNode!Trait removeSelector: #asClassSideNode!TCommentDescription removeSelector: #asCommentNode!ClassOrganizer removeSelector: #isClassOrganizer!OBSourceFilesRequest removeSelector: #isBrowseRequest!OBSourceFilesRequest removeSelector: #defaultAction!Smalltalk removeClassNamed: #OBSourceFilesRequest!Smalltalk removeClassNamed: #OBVersionBrowser!Smalltalk removeClassNamed: #OBVariablesBrowser!Smalltalk removeClassNamed: #OBSystemBrowser!Smalltalk removeClassNamed: #OBSendersBrowser!Smalltalk removeClassNamed: #OBReferencesBrowser!Smalltalk removeClassNamed: #OBImplementorsBrowser!Smalltalk removeClassNamed: #OBListBrowser!Smalltalk removeClassNamed: #OBInheritanceBrowser!Smalltalk removeClassNamed: #OBHierarchyBrowser!Smalltalk removeClassNamed: #OBCodeBrowser!Smalltalk removeClassNamed: #OBOrganizationDefinition!Smalltalk removeClassNamed: #OBMethodDefinition!Smalltalk removeClassNamed: #OBClassDefinition!Smalltalk removeClassNamed: #OBInstanceVariableNode!Smalltalk removeClassNamed: #OBClassVariableNode!Smalltalk removeClassNamed: #OBVariableNode!Smalltalk removeClassNamed: #OBSelectorNode!Smalltalk removeClassNamed: #OBMethodVersionNode!Smalltalk removeClassNamed: #OBMessageNode!Smalltalk removeClassNamed: #OBClassRefNode!Smalltalk removeClassNamed: #OBMethodNode!Smalltalk removeClassNamed: #OBAllMethodCategoryNode!Smalltalk removeClassNamed: #OBMethodCategoryNode!Smalltalk removeClassNamed: #OBMetaclassNode!Smalltalk removeClassNamed: #OBEnvironmentNode!Smalltalk removeClassNamed: #OBClassNode!Smalltalk removeClassNamed: #OBClassCommentNode!Smalltalk removeClassNamed: #OBClassCategoryNode!Smalltalk removeClassNamed: #OBClassAwareNode!Smalltalk removeClassNamed: #OBCodeNode!Smalltalk removeClassNamed: #OBImplementorsViewActor!Smalltalk removeClassNamed: #OBClassActor!Smalltalk removeClassNamed: #OBCategoryActor!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.335.mcz') load.ScriptLoader new updateFrom7069.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 2/14/2008 22:04' prior: 33818317!script93	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.150.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.116.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.22.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.102.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/14/2008 22:04'!updateFrom7070	"self new updateFrom7070"	self script93.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	self flushCaches.	Preferences enable: #serverMode.		! !"ScriptLoader"!!Preferences class methodsFor: 'standard queries' stamp: 'al 7/31/2007 16:17'!serverMode	^ self		valueOfFlag: #serverMode		ifAbsent: [false]! !!WorldState methodsFor: 'update cycle' stamp: 'al 7/31/2007 16:12' prior: 50954331!interCyclePause: milliSecs	"delay enough that the previous cycle plus the amount of delay will equal milliSecs.  If the cycle is already expensive, then no delay occurs.  However, if the system is idly waiting for interaction from the user, the method will delay for a proportionally long time and cause the overall CPU usage of Squeak to be low.	If the preference #serverMode is enabled, always do a complete delay of 50ms, independant of my argument. This prevents the freezing problem described in Mantis #6581"	| currentTime wait |	Preferences serverMode		ifFalse: [			(lastCycleTime notNil and: [CanSurrenderToOS ~~ false]) ifTrue: [ 				currentTime := Time millisecondClockValue.				wait := lastCycleTime + milliSecs - currentTime.				(wait > 0 and: [ wait <= milliSecs ] ) ifTrue: [					(Delay forMilliseconds: wait) wait ] ] ]		ifTrue: [ (Delay forMilliseconds: 50) wait ].	lastCycleTime := Time millisecondClockValue.	CanSurrenderToOS := true.! !"Morphic"!"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.336.mcz') load.ScriptLoader new updateFrom7070.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 2/14/2008 22:12'!script94	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.151.mczKernelTests-sd.51.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.116.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.22.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.102.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/14/2008 22:12'!updateFrom7071	"self new updateFrom7071"	self script94.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	self flushCaches.	Preferences enable: #serverMode.		! !"ScriptLoader"!!Process methodsFor: 'changing process state' stamp: 'ar 10/5/2007 18:01' prior: 28009754!terminate 	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."	| ctxt unwindBlock inSema |	self isActiveProcess ifTrue: [		ctxt := thisContext.		[	ctxt := ctxt findNextUnwindContextUpTo: nil.			ctxt isNil		] whileFalse: [			unwindBlock := ctxt tempAt: 1.			unwindBlock ifNotNil: [				ctxt tempAt: 1 put: nil.				thisContext terminateTo: ctxt.				unwindBlock value].		].		thisContext terminateTo: nil.		myList := nil.		self primitiveSuspend.	] ifFalse: [		"Since the receiver is not the active process, drop its priority to rock-bottom so that		it doesn't accidentally preempt the process that is trying to terminate it."		priority := 10.		myList ifNotNil: [			myList remove: self ifAbsent: [].			"Figure out if the receiver was terminated while waiting on a Semaphore"			inSema := myList class == Semaphore.			myList := nil].		suspendedContext ifNotNil: [			"Figure out if we are terminating the process while waiting in Semaphore>>critical:			In this case, pop the suspendedContext so that we leave the ensure: block inside			Semaphore>>critical: without signaling the semaphore."			(inSema == true and:[				suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue:[					suspendedContext := suspendedContext home.			].			ctxt := self popTo: suspendedContext bottomContext.			ctxt == suspendedContext bottomContext ifFalse: [				self debug: ctxt title: 'Unwind error during termination']].	].! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 17:59' prior: 29701676!critical: mutuallyExcludedBlock				"Evaluate mutuallyExcludedBlock only if the receiver is not currently in	the process of running the critical: message. If the receiver is, evaluate	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue caught |	caught := false.	[		caught := true.		self wait.		blockValue := mutuallyExcludedBlock value	] ensure: [caught ifTrue: [self signal]].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 18:33'!critical: mutuallyExcludedBlock ifCurtailed: terminationBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	^self critical:[[mutuallyExcludedBlock value] ifCurtailed: terminationBlock]! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 17:59' prior: 29702118!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr |	hasError := false.	self critical:[		blockValue := [mutuallyExcludedBlock value] ifError:[:msg :rcvr|			hasError := true.			errMsg := msg.			errRcvr := rcvr		].	].	hasError ifTrue:[ ^errorBlock value: errMsg value: errRcvr].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 18:34'!critical: mutuallyExcludedBlock ifLocked: alternativeBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	excessSignals == 0 ifTrue:[		"If we come here, then the semaphore was locked when the test executed. 		Evaluate the alternative block and answer its result."		^alternativeBlock value 	].	^self critical: mutuallyExcludedBlock! !!SemaphoreTest methodsFor: 'testing' stamp: 'ar 10/5/2007 18:09'!testSemaAfterCriticalWait	"self run: #testSemaAfterCriticalWait"	"This tests whether a semaphore that has just left the wait in Semaphore>>critical:	leaves it with signaling the associated semaphore."	| s p |	s := Semaphore new.	p := [s critical:[]] forkAt: Processor activePriority-1.	"wait until p entered the critical section"	[p suspendingList == s] whileFalse:[(Delay forMilliseconds: 10) wait].	"Now that p entered it, signal the semaphore. p now 'owns' the semaphore	but since we are running at higher priority than p it will not get to do	anything."	s signal.	p terminate.	self assert:[(s instVarNamed: #excessSignals) = 1]! !!SemaphoreTest methodsFor: 'testing' stamp: 'ar 10/5/2007 18:06'!testSemaInCriticalWait	"self run: #testSemaInCriticalWait"	"This tests whether a semaphore that has entered the wait in Semaphore>>critical:	leaves it without signaling the associated semaphore."	| s p |	s := Semaphore new.	p := [s critical:[]] fork.	Processor yield.	self assert:[p suspendingList == s].	p terminate.	self assert:[(s instVarNamed: #excessSignals) = 0]! !"Kernel"!"KernelTests"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.337.mcz') load.ScriptLoader new updateFrom7071.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 2/14/2008 22:20'!script95	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.152.mczKernelTests-sd.51.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.116.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.22.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.103.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/14/2008 22:21'!updateFrom7072	"self new updateFrom7072"	self script95.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	self flushCaches.			! !"ScriptLoader"!!Semaphore methodsFor: 'communication' stamp: 'ar 8/30/2007 16:15' prior: 29699960!waitTimeoutMSecs: anInteger	"Wait on this semaphore for up to the given number of milliseconds, then timeout. It is up to the sender to determine the difference between the expected event and a timeout."	| d |	d := Delay timeoutSemaphore: self afterMSecs: (anInteger max: 0).	[self wait] ensure:[d unschedule].! !!SystemDictionary class methodsFor: 'initialization' stamp: 'ar 10/5/2007 18:16' prior: 31725227!initialize	"SystemDictionary initialize"	| oldList |	oldList _ StartUpList.	StartUpList _ OrderedCollection new.	"These get processed from the top down..."	#(		Delay		DisplayScreen		Cursor		InputSensor		ProcessorScheduler  "Starts low space watcher and bkground."		FileDirectory  "Enables file stack dump and opens sources."		ShortIntegerArray		ShortRunArray		CrLfFileStream	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].	oldList ifNotNil: [oldList do: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToStartUpList: theClass]]].	#(		ImageSegment		PasteUpMorph		ControlManager	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].			oldList _ ShutDownList.	ShutDownList _ OrderedCollection new.	"These get processed from the bottom up..."	#(		Delay		DisplayScreen		InputSensor		Form		ControlManager		PasteUpMorph		StrikeFont		Color		FileDirectory		SoundPlayer		HttpUrl		Password		PWS		MailDB		ImageSegment	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToShutDownList: cls].	].	oldList ifNotNil: [oldList reverseDo: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToShutDownList: theClass]]].! !!Delay commentStamp: 'stephaneducasse 10/1/2005 21:07' prior: 19691973!I am the main way that a process may pause for some amount of time.  The simplest usage is like this:	(Delay forSeconds: 5) wait.An instance of Delay responds to the message 'wait' by suspending the caller's process for a certain amount of time. The duration of the pause is specified when the Delay is created with the message forMilliseconds: or forSeconds:. A Delay can be used again when the current wait has finished. For example, a clock process might repeatedly wait on a one-second Delay.The maximum delay is (SmallInteger maxVal // 2) milliseconds, or about six days. A delay in progress when an image snapshot is saved is resumed when the snapshot is re-started. Delays work across millisecond clock roll-overs.For a more complex example, see  #testDelayOf:for:rect: .A word of advice:This is THE highest priority code which is run in Squeak, in other words it is time-critical. The speed of this code is critical for accurate responses, it is critical for network services, it affects every last part of the system.In short: Don't fix it if it ain't broken!! This code isn't supposed to be beautiful, it's supposed to be fast!! The reason for duplicating code is to make it fast. The reason for not using ifNil:[]ifNotNil:[] is that the compiler may not inline those. Since the effect of changes are VERY hard to predict it is best to leave things as they are for now unless there is an actual need to change anything!!Delay class methodsFor: 'timer process' stamp: 'ar 8/24/2007 12:36'!handleTimerEvent	"Handle a timer event; which can be either:		- a schedule request (ScheduledDelay notNil)		- an unschedule request (FinishedDelay notNil)		- a timer signal (not explicitly specified)	We check for timer expiry every time we get a signal."	| nowTick nextTick |	"Wait until there is work to do."	TimingSemaphore wait.	"Process any schedule requests"	ScheduledDelay ifNotNil:[		"Schedule the given delay"		self scheduleDelay: ScheduledDelay.		ScheduledDelay := nil.	].	"Process any unschedule requests"	FinishedDelay ifNotNil:[		self unscheduleDelay: FinishedDelay.		FinishedDelay := nil.	].	"Check for clock wrap-around."	nowTick := Time millisecondClockValue.	nowTick < ActiveDelayStartTime ifTrue: [		"clock wrapped"		self saveResumptionTimes.		self restoreResumptionTimes.	].	ActiveDelayStartTime := nowTick.	"Signal any expired delays"	[ActiveDelay notNil and:[nowTick >= ActiveDelay resumptionTime]] whileTrue:[		ActiveDelay signalWaitingProcess.		SuspendedDelays isEmpty 			ifTrue: [ActiveDelay := nil] 			ifFalse:[ActiveDelay := SuspendedDelays removeFirst].	].	"And signal when the next request is due. We sleep at most 1sec here	as a soft busy-loop so that we don't accidentally miss signals."	nextTick := nowTick + 1000.	ActiveDelay ifNotNil:[nextTick := nextTick min: ActiveDelay resumptionTime].	nextTick := nextTick min: SmallInteger maxVal.	"Since we have processed all outstanding requests, reset the timing semaphore so	that only new work will wake us up again. Do this RIGHT BEFORE setting the next	wakeup call from the VM because it is only signaled once so we mustn't miss it."	TimingSemaphore initSignals.	Delay primSignal: TimingSemaphore atMilliseconds: nextTick.	"This last test is necessary for the obscure case that the msecs clock rolls over	after nowTick has been computed (unlikely but not impossible). In this case we'd	wait for MillisecondClockMask msecs (roughly six days) or until another delay gets	scheduled (which may not be any time soon). In any case, since handling the	condition is easy, let's just deal with it"	Time millisecondClockValue < nowTick ifTrue:[TimingSemaphore signal]. "retry"! !!Delay class methodsFor: 'class initialization' stamp: 'ar 7/11/2007 18:16'!initialize	"Delay initialize"	self startTimerEventLoop.! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/11/2007 09:04'!runTimerEventLoop	"Run the timer event loop."	[		[RunTimerEventLoop] whileTrue: [self handleTimerEvent]	] on: Error do:[:ex|		"Clear out the process so it does't get killed"		TimerEventLoop := nil.		"Launch the old-style interrupt watcher"		self startTimerInterruptWatcher.		"And pass the exception on"		ex pass.	].! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 22:32'!scheduleDelay: aDelay	"Private. Schedule this Delay."	aDelay beingWaitedOn: true.	ActiveDelay ifNil:[		ActiveDelay := aDelay	] ifNotNil:[		aDelay resumptionTime < ActiveDelay resumptionTime ifTrue:[			SuspendedDelays add: ActiveDelay.			ActiveDelay := aDelay.		] ifFalse: [SuspendedDelays add: aDelay].	].! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/11/2007 10:18'!startTimerEventLoop	"Start the timer event loop"	"Delay startTimerEventLoop"	self stopTimerEventLoop.	self stopTimerInterruptWatcher.	AccessProtect := Semaphore forMutualExclusion.	ActiveDelayStartTime := Time millisecondClockValue.	SuspendedDelays := 		Heap withAll: (SuspendedDelays ifNil:[#()])			sortBlock: [:d1 :d2 | d1 resumptionTime <= d2 resumptionTime].	TimingSemaphore := Semaphore new.	RunTimerEventLoop := true.	TimerEventLoop := [self runTimerEventLoop] newProcess.	TimerEventLoop priority: Processor timingPriority.	TimerEventLoop resume.	TimingSemaphore signal. "get going"! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 22:32' prior: 19703732!startTimerInterruptWatcher	"Reset the class variables that keep track of active Delays and re-start the timer interrupt watcher process. Any currently scheduled delays are forgotten."	"Delay startTimerInterruptWatcher"	| p |	self stopTimerEventLoop.	self stopTimerInterruptWatcher.	TimingSemaphore := Semaphore new.	AccessProtect := Semaphore forMutualExclusion.	SuspendedDelays := 		SortedCollection sortBlock: 			[:d1 :d2 | d1 resumptionTime <= d2 resumptionTime].	ActiveDelay := nil.	p := [self timerInterruptWatcher] newProcess.	p priority: Processor timingPriority.	p resume.! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 21:26'!stopTimerEventLoop	"Stop the timer event loop"	RunTimerEventLoop := false.	TimingSemaphore signal.	TimerEventLoop := nil.! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 21:32'!stopTimerInterruptWatcher	"Reset the class variables that keep track of active Delays and re-start the timer interrupt watcher process. Any currently scheduled delays are forgotten."	"Delay startTimerInterruptWatcher"	self primSignal: nil atMilliseconds: 0.	TimingSemaphore ifNotNil:[TimingSemaphore terminateProcess].! !!Delay class methodsFor: 'timer process' stamp: 'ar 8/30/2007 19:59'!unscheduleDelay: aDelay	"Private. Unschedule this Delay."	aDelay beingWaitedOn ifFalse:[^self].	ActiveDelay == aDelay ifTrue: [		SuspendedDelays isEmpty ifTrue:[			ActiveDelay := nil.		] ifFalse: [			ActiveDelay := SuspendedDelays removeFirst.		]	] ifFalse:[		SuspendedDelays remove: aDelay ifAbsent: [].	].	aDelay beingWaitedOn: false.! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:24' prior: 19694398!activate	"Private!! Make the receiver the Delay to be awoken when the next timer interrupt occurs. This method should only be called from a block protected by the AccessProtect semaphore."	TimerEventLoop ifNotNil:[^nil].	ActiveDelay := self.	ActiveDelayStartTime := Time millisecondClockValue.	ActiveDelayStartTime > resumptionTime ifTrue:[		ActiveDelay signalWaitingProcess.		SuspendedDelays isEmpty ifTrue:[			ActiveDelay := nil.			ActiveDelayStartTime := nil.		] ifFalse:[SuspendedDelays removeFirst activate].	] ifFalse:[		TimingSemaphore initSignals.		Delay primSignal: TimingSemaphore atMilliseconds: resumptionTime.	].! !!Delay methodsFor: 'public' stamp: 'ar 7/10/2007 21:49'!beingWaitedOn	"Answer whether this delay is currently scheduled, e.g., being waited on"	^beingWaitedOn! !!Delay methodsFor: 'public' stamp: 'ar 7/10/2007 21:49'!beingWaitedOn: aBool	"Indicate whether this delay is currently scheduled, e.g., being waited on"	beingWaitedOn := aBool! !!Delay methodsFor: 'public' stamp: 'ar 7/10/2007 20:56'!delayDuration	^delayDuration! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:55' prior: 19695927!schedule	"Private!! Schedule this Delay, but return immediately rather than waiting. The receiver's semaphore will be signalled when its delay duration has elapsed."	beingWaitedOn ifTrue: [self error: 'This Delay has already been scheduled.'].	TimerEventLoop ifNotNil:[^self scheduleEvent].	AccessProtect critical: [		beingWaitedOn := true.		resumptionTime := Time millisecondClockValue + delayDuration.		ActiveDelay == nil			ifTrue: [self activate]			ifFalse: [				resumptionTime < ActiveDelay resumptionTime					ifTrue: [						SuspendedDelays add: ActiveDelay.						self activate]					ifFalse: [SuspendedDelays add: self]]].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 22:33'!scheduleEvent	"Schedule this delay"	resumptionTime := Time millisecondClockValue + delayDuration.	AccessProtect critical:[		ScheduledDelay := self.		TimingSemaphore signal.	].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:55' prior: 19693580!unschedule	"Unschedule this Delay. Do nothing if it wasn't scheduled."	| done |	TimerEventLoop ifNotNil:[^self unscheduleEvent].	AccessProtect critical: [		done := false.		[done] whileFalse:			[SuspendedDelays remove: self ifAbsent: [done := true]].		ActiveDelay == self ifTrue: [			SuspendedDelays isEmpty				ifTrue: [					ActiveDelay := nil.					ActiveDelayStartTime := nil]				ifFalse: [					SuspendedDelays removeFirst activate]]].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:56'!unscheduleEvent	AccessProtect critical:[		FinishedDelay := self.		TimingSemaphore signal.	].! !!Delay methodsFor: 'delaying' stamp: 'ar 8/30/2007 19:32' prior: 19694039!wait	"Schedule this Delay, then wait on its semaphore. The current process will be suspended for the amount of time specified when this Delay was created."	self schedule.	[delaySemaphore wait] ifCurtailed:[self unschedule].! !"Kernel"!"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.338.mcz') load.ScriptLoader new updateFrom7072.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 2/17/2008 21:19'!script96	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.152.mczKernelTests-sd.51.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.116.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.22.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.104.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 2/17/2008 21:19'!updateFrom7073	"self new updateFrom7073"	self script96.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	self flushCaches.			! !"ScriptLoader"!!SystemDictionary class methodsFor: 'initialization' stamp: 'mu 2/11/2008 10:54' prior: 33867991!initialize	"SystemDictionary initialize"	| oldList |	oldList _ StartUpList.	StartUpList _ OrderedCollection new.	"These get processed from the top down..."	#(		Delay		DisplayScreen		Cursor		InputSensor		ProcessorScheduler  "Starts low space watcher and bkground."		LanguageEnvironment		FileDirectory  "Enables file stack dump and opens sources."		NaturalLanguageTranslator		ShortIntegerArray		ShortRunArray		CrLfFileStream	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].	oldList ifNotNil: [oldList do: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToStartUpList: theClass]]].	#(		ImageSegment		PasteUpMorph		ControlManager	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].			oldList _ ShutDownList.	ShutDownList _ OrderedCollection new.	"These get processed from the bottom up..."	#(		Delay		DisplayScreen		InputSensor		Form		ControlManager		PasteUpMorph		StrikeFont		Color		FileDirectory		SoundPlayer		HttpUrl		Password		PWS		MailDB		ImageSegment	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToShutDownList: cls].	].	oldList ifNotNil: [oldList reverseDo: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToShutDownList: theClass]]].! !"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.339.mcz') load.ScriptLoader new updateFrom7073.!----End fileIn of a stream----!'From Squeak3.9.1a of ''14 Feb 2008'' [latest update: #7074] on 1 March 2008 at 6:13:05 pm'!"Change Set:		7075-FixingRefToImageBrowserDate:			1 March 2008Author:			stephane ducasseThere was a ref to OB in the registered commands of the world menu."!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."TheWorldMenu unregisterOpenCommand: 'Image Browser'.SystemVersion newVersion: 'Squeak3.9.1'.!----End fileIn of a stream----!----SNAPSHOT----an Array(2 March 2008 6:56:27 pm) Squeak3.9.1-final-7075.image priorSource: 105817!----SNAPSHOT----an Array(2 March 2008 6:57:31 pm) Squeak3.9.1-final-7075.image priorSource: 329967!----QUIT/NOSAVE----an Array(2 March 2008 6:57:35 pm) Squeak3.9.1-final-7075.image priorSource: 330068!----STARTUP----an Array(25 February 2009 4:35:59 pm) as /Volumes/Zion/bob/wip/LPF/Squeak3.9.1-lpf/Squeak3.9.1-final-7075.image!'From Squeak3.10.2bc-beta of 16 December 2008 [latest update: #7179] on 16 February 2009 at 6:06:39 pm'!!TranscriptStream methodsFor: 'stream extensions' stamp: 'kph 2/16/2009 17:41' prior: 32961406!endEntry	"Display all the characters since the last endEntry, and reset the stream"	self semaphore critical:[		self changed: #appendEntry.		self logEntry.		self reset.	].! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'kph 2/16/2009 18:01'!logEntry	Preferences logTranscriptToFile ifTrue: [		(StandardFileStream fileNamed: 'transcript.log') setToEnd; nextPutAll: self contents; cr.	]! !Preferences addPreference: #logTranscriptToFile categories: #(logging) default: false balloonHelp:'Log transcript to a file'.!----End fileIn of a stream----!"self halt." (HTTPSocket httpGet: 'ftp.squeak.org/3.11/bob/TranscriptToFile.cs') readStream fileIn.!"self halt." Preferences setPreference: #logTranscriptToFile toValue: true.!SystemOrganization addCategory: #'Installer-Core'!Object subclass: #Installer	instanceVariableNames: 'answers packages messagesToSuppress isBootstrap'	classVariableNames: 'IsSetToTrapErrors Remembered SkipLoadingTests InstallerBindings ValidationBlock'	poolDictionaries: ''	category: 'Installer-Core'!!Installer commentStamp: 'kph 2/24/2009 06:32' prior: 0!Documentation now available at http://installer.pbwiki.com/Installer isBootstrap - flag to load source.st rather than using Monticello!!Installer class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!actionMatch: theLine reportOn: report ifNoMatch: aBlock	| line |		line := theLine withBlanksCondensed.	self allSubclassesDo: [:class |		(class canReportLine: line)		ifTrue: [ ^ class new action: theLine reportOn: report ]].	^ aBlock value! !!Installer class methodsFor: 'action report' stamp: 'kph 2/24/2009 07:54'!bootstrapTheRestOfInstaller	(Installer url: 'www.squeaksource.com/Installer/Installer-Scripts')  			bootstrap;			logCR: 'installer bootstrap - loaded'.! !!Installer class methodsFor: 'mantis' stamp: 'kph 2/15/2009 05:21'!bug: n fix: filename	Transcript cr; show: 'Code script in Mantis:', n asString, ' should read Installer mantis bug: ',n asString, ' fix: ', filename printString,'.'.		^ self mantis bug: n fix: filename! !!Installer class methodsFor: 'monticello' stamp: 'mtf 5/20/2008 22:10'!cache	^ self monticello cache! !!Installer class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!canReportLine: line	^ false! !!Installer class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:20'!cancelSkipLoadingTests	"sets a flag to un-ignore loading of the testing portion of scripts embedded in pages"		SkipLoadingTests := false. ! !!Installer class methodsFor: 'debug' stamp: 'kph 5/9/2007 23:05'!debug	IsSetToTrapErrors := false! !!Installer class methodsFor: 'launcher support' stamp: 'kph 2/23/2009 01:55'!do: webPageName	| rs |	rs := webPageName readStream.	[ rs atEnd ] whileFalse: [ self install: (rs upTo: $;) ].! !!Installer class methodsFor: 'custom names' stamp: 'kph 5/28/2007 05:11'!doesNotUnderstand: aMessage	^ self remembered at: aMessage selector ifAbsent: [ super doesNotUnderstand: aMessage ]! !!Installer class methodsFor: 'file' stamp: 'mtf 10/23/2008 15:49'!file	^ InstallerFile new! !!Installer class methodsFor: 'file' stamp: 'mtf 10/23/2008 16:08'!file: fileName 	^ InstallerFile new file: fileName; yourself! !!Installer class methodsFor: 'url' stamp: 'kph 2/11/2009 20:12'!fromUrl: aUrl	"try and pick an Installer appropriate for the Url"		| mci |		mci := Installer mc fromUrl: aUrl.		mci packages ifEmpty: [ ^ Installer url: aUrl ].		^ mci! !!Installer class methodsFor: 'repositories' stamp: 'kph 6/2/2008 20:21'!goran	^ self monticello http: 'squeak.krampe.se'; project: ''! !!Installer class methodsFor: 'repositories' stamp: 'kph 5/10/2007 01:29'!impara	^ self monticello http: 'source.impara.de'! !!Installer class methodsFor: 'action report' stamp: 'kph 2/23/2009 05:27'!install: scriptName	^ (self scripts install: scriptName) ifNil:[ self web install: scriptName ]! !!Installer class methodsFor: 'file' stamp: 'mtf 10/23/2008 16:08'!installFile: fileName 	^ (self file: fileName) install.! !!Installer class methodsFor: 'url' stamp: 'stephane.ducasse 9/30/2008 18:24'!installSilentlyUrl: urlString	^ SystemChangeNotifier uniqueInstance doSilently: [ self url url: urlString; install ].! !!Installer class methodsFor: 'url' stamp: 'stephane.ducasse 9/30/2008 18:24'!installUrl: urlString	^ self url url: urlString; install.! !!Installer class methodsFor: 'repositories' stamp: 'kph 12/18/2008 02:06'!keith 	^ self monticello ftp: 'squeak.warwick.st' directory: 'mc' user: 'squeak' password: 'viewpoints'! !!Installer class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 20:29'!label	^ ''! !!Installer class methodsFor: 'launcher support' stamp: 'kph 2/27/2007 18:57'!launchFrom: launcher	^self launchWith: launcher getParameters! !!Installer class methodsFor: 'launcher support' stamp: 'kph 5/24/2007 19:59'!launchHelp^'path=/dir/*.txt          Specify a search path for the item to installp=/dir1/*.txt;<url2>/    Multiple items delimited by ;                         The page name is typically appended to the path string, or                         if a "*" is present, it will be replaced by the page name.					in,i,install=<page>      Page appended to the path to begin the install processurl,u=<url>              Install using an explicit url from which to obtain a script or filefile=<url>                Install using a local file+debug                   Do not trap errorsview=<page>              Print the script that would have been installed.For more options use Script eval="Installer ... " '! !!Installer class methodsFor: 'launcher support' stamp: 'kph 1/11/2008 07:58'!launchWith: params 	params at: 'P' ifPresent: [ :v | params at: 'PATH' put: v ]. 	params at: 'I' ifPresent: [ :v | params at: 'INSTALL' put: v ]. 	params at: 'IN' ifPresent: [ :v | params at: 'INSTALL' put: v ]. 	params at: 'U' ifPresent: [ :v | params at: 'URL' put: v ].	params at: 'PATH' ifPresent: [ :v | 		self webSearchPathFrom: v.	].	params at: 'USER' ifPresent: [ :v | 		Utilities setAuthorInitials: v	].	params at: 'VERSION' ifPresent: [ :v | 		SystemVersion current version: v	].	params at: 'VIEW' ifPresent: [ :v |		self view: v	].	IsSetToTrapErrors := true.	params at: 'DEBUG' ifPresent: [ :v | IsSetToTrapErrors := (v == true) not ]. 	params at: 'URL' ifPresent: [ :v | 		 self installUrl: v	].	params at: 'FILE' ifPresent: [ :v | 		 self installFile: v	].  	params at: 'INSTALL' ifPresent: [ :v | 		  self do: v	].	params at: 'DO' ifPresent: [ :v | 		  self do: v	]. 	 ^true	! !!Installer class methodsFor: 'logging' stamp: 'kph 2/24/2009 07:29'!log: aString	Transcript show: aString; cr.! !!Installer class methodsFor: 'repositories' stamp: 'kph 4/24/2008 16:56'!lukas	^ self monticello http: 'source.lukas-renggli.ch'! !!Installer class methodsFor: 'mantis' stamp: 'kph 3/14/2007 21:07'!mantis	^ self mantis: 'http://bugs.squeak.org/'! !!Installer class methodsFor: 'mantis' stamp: 'mtf 10/8/2008 12:00'!mantis: host	^ InstallerMantis host: host! !!Installer class methodsFor: 'monticello' stamp: 'kph 5/10/2007 00:49'!mc	^ self monticello! !!Installer class methodsFor: 'monticello' stamp: 'kph 5/10/2007 00:49'!monticello	^ InstallerMonticello new! !!Installer class methodsFor: 'debug' stamp: 'kph 5/9/2007 23:05'!noDebug	IsSetToTrapErrors := true! !!Installer class methodsFor: 'during' stamp: 'kph 5/21/2008 09:05'!noProgressDuring: block 	[ block value: self ] on: ProgressInitiationException do: [ :note | note resume ]! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:24'!path: aString	"convenience abbreviation"		self webSearchPathFrom: aString! !!Installer class methodsFor: 'custom names' stamp: 'kph 5/28/2007 00:54'!remembered	^	Remembered ifNil: [ Remembered := IdentityDictionary new ]! !!Installer class methodsFor: 'instanciation' stamp: 'kph 12/1/2008 20:12'!repositories	^ self class organization listAtCategoryNamed: 'repositories'.! !!Installer class methodsFor: 'monticello' stamp: 'stephane.ducasse 9/30/2008 18:24'!repository: host  	^self monticello http: host ! !!Installer class methodsFor: 'sake' stamp: 'mtf 10/8/2008 12:00'!sake	^ self sake: InstallerSake sake! !!Installer class methodsFor: 'sake' stamp: 'kph 1/28/2008 10:42'!sake: aSakePackagesClass	^ InstallerSake new sake: aSakePackagesClass! !!Installer class methodsFor: 'repositories' stamp: 'kph 8/18/2008 03:15'!saltypickle	^ self monticello http: 'squeak.saltypickle.com'! !!Installer class methodsFor: 'internal scripts' stamp: 'kph 2/23/2009 02:03'!scripts	^ InstallerScripts new! !!Installer class methodsFor: 'sake' stamp: 'mtf 10/8/2008 12:00'!setSakeToUse: aClass	InstallerSake sake: aClass! !!Installer class methodsFor: 'documentation' stamp: 'kph 5/10/2007 01:21'!sf	^ self squeakfoundation ! !!Installer class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:21'!skipLoadingTests	"sets a flag to ignore loading of the testing portion of scripts embedded in pages"		SkipLoadingTests := true. ! !!Installer class methodsFor: 'during' stamp: 'kph 5/21/2008 08:53'!skipLoadingTestsDuring: block	| oldValue |	oldValue := SkipLoadingTests.	SkipLoadingTests := true.		[ block value: self ] ensure:[ SkipLoadingTests := oldValue ].! !!Installer class methodsFor: 'squeakmap' stamp: 'kph 5/10/2007 01:19'!sm	^ self squeakmap! !!Installer class methodsFor: 'repositories' stamp: 'kph 12/15/2007 11:08'!sophie	^ self monticello http: 'source.sophieproject.org'	! !!Installer class methodsFor: 'repositories' stamp: 'kph 5/10/2007 01:21'!squeakfoundation	^ self monticello http: 'source.squeakfoundation.org'! !!Installer class methodsFor: 'squeakmap' stamp: 'stephane.ducasse 9/30/2008 18:26'!squeakmap	^ InstallerSqueakMap new sm: true; yourself! !!Installer class methodsFor: 'repositories' stamp: 'kph 5/10/2007 01:19'!squeaksource	^ self monticello http: 'www.squeaksource.com'! !!Installer class methodsFor: 'repositories' stamp: 'kph 5/10/2007 01:19'!ss	^ self squeaksource ! !!Installer class methodsFor: 'universe' stamp: 'mtf 10/14/2008 10:10'!universe	^ InstallerUniverse default! !!Installer class methodsFor: 'instanciation' stamp: 'kph 2/23/2009 05:29'!upgrade	Installer ss project: 'Installer'; 		installQuietly: 'Installer-Core';		installQuietly: 'Installer-Scripts'.			^ self! !!Installer class methodsFor: 'url' stamp: 'kph 12/9/2008 03:10'!url	^ InstallerUrl new url: ''! !!Installer class methodsFor: 'url' stamp: 'stephane.ducasse 9/30/2008 18:26'!url: urlString	^self url url: urlString; yourself! !!Installer class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:28'!validationBlock	^ ValidationBlock! !!Installer class methodsFor: 'accessing' stamp: 'kph 5/25/2007 01:34'!validationBlock: aBlock	ValidationBlock := aBlock! !!Installer class methodsFor: 'instanciation' stamp: 'stephane.ducasse 9/30/2008 18:26'!view: webPageNameOrUrl	| theReport |	theReport := String streamContents: [ :report | 	(webPageNameOrUrl beginsWith: 'http://') ifTrue: [ 		self actionMatch: ('Installer installUrl: ', (webPageNameOrUrl printString),'.')  				reportOn: report ifNoMatch: []	]	ifFalse: [		self actionMatch: ('Installer install: ', (webPageNameOrUrl printString),'.')  				reportOn: report ifNoMatch: []	]].	Workspace new contents: (theReport contents); openLabel: webPageNameOrUrl.	^theReport contents! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:26'!web 	^ InstallerWeb! !!Installer class methodsFor: 'web' stamp: 'kph 2/23/2009 01:56'!webInstall: webPageName	^ self web install: webPageName! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:22'!webSearchPath	"a search path item, has the following format. prefix*suffix"	^ self web searchPath! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:22'!webSearchPathFrom: string	| reader wsp path |	reader := string readStream.	wsp := self webSearchPath.	[ reader atEnd ] whileFalse: [ 		path := reader upTo: $;.		(wsp includes: wsp) ifFalse: [ wsp addFirst: path ]].	 ! !!Installer class methodsFor: 'websqueakmap' stamp: 'stephane.ducasse 9/30/2008 18:28'!websqueakmap	^ InstallerWebSqueakMap new wsm: 'http://map.squeak.org'; yourself! !!Installer class methodsFor: 'websqueakmap' stamp: 'stephane.ducasse 9/30/2008 18:28'!websqueakmap: host	^ InstallerWebSqueakMap new wsm: host; yourself! !!Installer class methodsFor: 'repositories' stamp: 'kph 5/10/2007 01:30'!wiresong	^ self monticello http: 'source.wiresong.ca'! !!Installer class methodsFor: 'websqueakmap' stamp: 'kph 5/10/2007 01:19'!wsm	^ self websqueakmap! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 18:45'!addPackage: anObject	self packages add: anObject! !!Installer methodsFor: 'auto answering' stamp: 'sd 3/6/2008 18:46'!answer: aString with: anAnswer	^self answers add: ( Array with: aString with: anAnswer )! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:46'!answers	^ answers ifNil: [ answers := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:46'!answers: anObject	answers := anObject! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!availablePackages		^ self basicAvailablePackages! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicAvailablePackages! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicBrowse! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicInstall! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicVersions! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicView! !!Installer methodsFor: 'script bindings' stamp: 'kph 5/8/2007 19:52'!bindingOf: aString 		InstallerBindings isNil ifTrue: [ InstallerBindings := Dictionary new].	(InstallerBindings includesKey: aString)		ifFalse: [InstallerBindings at: aString put: nil].	^ InstallerBindings associationAt: aString.! !!Installer methodsFor: 'public interface' stamp: 'kph 2/24/2009 06:32'!bootstrap	isBootstrap := true.	self install.! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!browse	self logErrorDuring: [self basicBrowse]! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 18:45'!browse: packageNameCollectionOrDetectBlock	self package: packageNameCollectionOrDetectBlock.	self browse! !!Installer methodsFor: 'mantis' stamp: 'kph 12/19/2007 12:03'!browse: aFileName from: stream		| mcThing ext browseSelector |		 	self log: ' browsing...'. 		mcThing := self classMCReader ifNotNil: [ self mcThing: aFileName from: stream ].				mcThing 			ifNotNil: [ (mcThing respondsTo: #snapshot) 						ifTrue: [ mcThing browse ]				        	ifFalse: [ (MCSnapshotBrowser forSnapshot: mcThing) showLabelled: 'Browsing ', aFileName ]			]			ifNil: [ 						ext := aFileName copyAfterLast: $..				browseSelector := ('browse', ext asUppercase, ':from:') asSymbol.					(self respondsTo: browseSelector)					ifTrue: [ self perform: browseSelector with: aFileName with: stream ]					ifFalse: [ self browseDefault: aFileName from: stream ].			]! !!Installer methodsFor: 'mantis' stamp: 'kph 12/19/2007 13:49'!browseCS: aFileName from: stream 		| list |		list := self classChangeList new			scanFile: stream from: 1 to: stream size.		 	self classChangeList open: list name: aFileName		multiSelect: true.! !!Installer methodsFor: 'mantis' stamp: 'kph 12/19/2007 12:05'!browseDefault: aFileName from: stream	self view: aFileName from: stream! !!Installer methodsFor: 'mantis' stamp: 'sd 3/6/2008 19:08'!browseGZ: aFileName from: stream 	"FileIn the contents of a gzipped stream"	| zipped unzipped |	zipped := self classGZipReadStream on: stream.	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	ChangeList browseStream: unzipped	! !!Installer methodsFor: 'utils' stamp: 'kph 5/24/2007 19:16'!changeSetNamed: aName	(ChangeSet respondsTo: #named:)		ifTrue: [ ^ChangeSet named: aName ].			^ ChangeSorter changeSetNamed: aName.! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classChangeList	^Smalltalk at: #ChangeList  ifAbsent: [ self error: 'ChangeList not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classChangeSet	^Smalltalk at: #ChangeSet  ifAbsent: [ self error: 'ChangeSet not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classChangeSorter	^Smalltalk at: #ChangeSorter ifAbsent: [ self error: 'ChangeSorter not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classGZipReadStream	^Smalltalk at: #GZipReadStream  ifAbsent: [ self error: 'Compression not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classMCReader	^Smalltalk at: #MCReader ifAbsent: [ nil ]	! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classMczInstaller	^Smalltalk at: #MczInstaller ifAbsent: [ nil ]	! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classMultiByteBinaryOrTextStream	^Smalltalk at: #MultiByteBinaryOrTextStream  ifAbsent: [ self error: 'MultiByteBinaryOrTextStream not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classSARInstaller	^Smalltalk at: #SARInstaller  ifAbsent: [ self error: 'SARInstaller not present' ]! !!Installer methodsFor: 'utils' stamp: 'mtf 7/23/2008 12:00'!ditchOldChangeSetFor: aFileName 	| changeSetName | 	changeSetName := (self validChangeSetName: aFileName) sansPeriodSuffix.	(self changeSetNamed: changeSetName)		ifNotNilDo: [:changeSet |				(self logCR:'Removing old change set ', changeSetName) cr.				self  removeChangeSet: changeSet ].! !!Installer methodsFor: 'public interface' stamp: 'kph 2/24/2009 08:01'!initialize	isBootstrap := false.! !!Installer methodsFor: 'public interface' stamp: 'kph 2/24/2009 07:57'!inizialize	isBootstrap := false.! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!install	self logErrorDuring: [self basicInstall]! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 18:45'!install: packageNameCollectionOrDetectBlock	self addPackage: packageNameCollectionOrDetectBlock.	self install! !!Installer methodsFor: 'mantis' stamp: 'kph 2/24/2009 08:09'!install: aFileName from: stream| ext installSelector mcThing |	 	self log: ' installing...'. 	self withAnswersDo:	[				mcThing := self classMCReader ifNotNil: [ self mcThing: aFileName from: stream ].				mcThing 			ifNotNil: [ (mcThing respondsTo: #install) 						ifTrue: [ mcThing install ]				        	ifFalse: [ (mcThing respondsTo: #load) ifTrue: [ mcThing load ] ]			]			ifNil: [ 						ext := (aFileName copyAfterLast: $/) in: [ :path | path isEmpty ifTrue: [ aFileName ] ifFalse: [ path ] ].				ext :=  ext copyAfterLast: $..				ext = '' ifTrue: [ ext := 'st' ].				installSelector := ('install', ext asUppercase, ':from:') asSymbol.					isBootstrap ifTrue: [ 				[					SystemChangeNotifier uniqueInstance doSilently: [self install: aFileName from: stream using: installSelector ]] 						on: Warning do: [ :ex | ex resume: true ].				] ifFalse: [					self install: aFileName from: stream using: installSelector. 				]			]	]. 	self log: ' done.'! !!Installer methodsFor: 'mantis' stamp: 'kph 2/24/2009 08:07'!install: aFileName from: stream using: installSelector		(self respondsTo: installSelector)			ifTrue: [ self perform: installSelector with: aFileName with: stream ]			ifFalse: [ self installDefault: aFileName from: stream ].! !!Installer methodsFor: 'mantis' stamp: 'kph 5/9/2007 18:14'!installCS: aFileName from: stream 	self ditchOldChangeSetFor: aFileName.	self newChangeSetFromStream: stream named: (self validChangeSetName: aFileName).! !!Installer methodsFor: 'mantis' stamp: 'ar 2/14/2009 22:56'!installDefault: aFileName from: stream	"Check for UTF-8 input before filing it in"	| pos bom |	pos := stream position.	bom := stream next: 3.	(bom size = 3		and:[(bom at: 1) asInteger = 16rEF]		and:[(bom at: 2) asInteger = 16rBB]		and:[(bom at: 3) asInteger = 16rBF]) 			ifTrue:[(RWBinaryOrTextStream on: stream upToEnd utf8ToSqueak) fileIn]			ifFalse:[stream position: pos; fileIn]! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:42'!installGZ: aFileName from: stream 	"FileIn the contents of a gzipped stream"	| zipped unzipped |	 	zipped := self classGZipReadStream on: stream.	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	self  newChangeSetFromStream: unzipped named:aFileName.	! !!Installer methodsFor: 'mantis' stamp: 'kph 2/24/2009 07:10'!installMCZ: aFileName from: stream 	| source pkg wc |		pkg := aFileName copyUpToLast: $-.		wc := Smalltalk at: #MCWorkingCopy ifAbsent: [ nil ].wc ifNotNil: [ 	(wc allManagers select:  [:each | each packageName = pkg ]) do: [ :ea | ea unregister ] ].		self classMczInstaller ifNotNilDo: [ :reader | ^ reader install: aFileName stream: stream].  	source :=  ((ZipArchive new readFrom:stream) memberNamed: 'snapshot/source.st') contents.	[		SystemChangeNotifier uniqueInstance doSilently: [ 			source  readStream fileInAnnouncing: 'Booting ' , aFileName. 		]	] on: Warning do: [ :ex | ex resume: true ].! !!Installer methodsFor: 'mantis' stamp: 'kph 2/24/2009 08:05'!installMCZBasic: aFileName from: stream 	| source |	 	self classMczInstaller ifNotNilDo: [ :reader | ^ reader install: aFileName stream: stream].  	source :=  ((ZipArchive new readFrom:stream) memberNamed: 'snapshot/source.st') contents.	[		SystemChangeNotifier uniqueInstance doSilently: [ 			source  readStream fileInAnnouncing: 'Booting ' , aFileName. 		]	] on: Warning do: [ :ex | ex resume: true ].! !!Installer methodsFor: 'mantis' stamp: 'kph 5/9/2007 18:07'!installMCcs: aFileName from: stream 	| reader |		reader := MCCsReader on: stream.! !!Installer methodsFor: 'public interface' stamp: 'kph 5/16/2008 00:44'!installQuietly   	[ self install ] on: Warning do: [ :ex | ex resume: true ].! !!Installer methodsFor: 'public interface' stamp: 'kph 5/16/2008 00:45'!installQuietly: packageNameCollectionOrDetectBlock	self package: packageNameCollectionOrDetectBlock. 	self installQuietly.! !!Installer methodsFor: 'mantis' stamp: 'kph 5/25/2007 01:09'!installSAR: aFileName from: stream  | newCS |	self classSARInstaller withCurrentChangeSetNamed: aFileName		do: [:cs | newCS := cs. self classSARInstaller new fileInFrom: stream].	newCS isEmpty ifTrue: [ self removeChangeSet: newCS ]! !!Installer methodsFor: 'public interface' stamp: 'kph 6/2/2008 12:17'!installSilently	SystemChangeNotifier uniqueInstance doSilently: [ self install ]	! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!isSkipLoadingTestsSet	^SkipLoadingTests ifNil: [ false ]! !!Installer methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:37'!label	^ self class label! !!Installer methodsFor: 'logging' stamp: 'sd 3/6/2008 20:23'!log: text	^Transcript show: text.! !!Installer methodsFor: 'logging' stamp: 'mtf 10/15/2008 08:08'!logCR: text	self validate.	^ Transcript show: text; cr! !!Installer methodsFor: 'logging' stamp: 'kph 9/1/2008 21:39'!logErrorDuring: block	(IsSetToTrapErrors = true) ifFalse: [ ^ block value ].	block on: Error 		do: [ :e |			self halt. 			self logCR: '****', e class name, ': ', (e messageText ifNil: [ '']). 					(e isKindOf: MessageNotUnderstood) 				ifTrue: [ e pass ]				ifFalse: [ e isResumable ifTrue:[ e resume: true ]]]! !!Installer methodsFor: 'searching' stamp: 'kph 1/4/2007 23:59'!match: aMatch	^self packagesMatching: aMatch! !!Installer methodsFor: 'mantis' stamp: 'kph 2/24/2009 06:36'!mcThing: aFileName from: stream			"dont use monticello for .cs or for .st use monticello for .mcs"	| reader |		isBootstrap ifTrue: [ ^ nil ].		reader := self classMCReader readerClassForFileNamed: aFileName.	reader name = 'MCStReader' ifTrue: [ ^ nil ].	reader ifNil: [ ^ nil ].	(reader respondsTo: #on:fileName:) 		ifTrue: [ reader := reader on: stream fileName: aFileName.					^ reader version  ]		ifFalse: [ reader := reader on: stream. 				    ^ reader snapshot  ].! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!messagesToSuppress	^ messagesToSuppress ifNil: [ messagesToSuppress := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!messagesToSuppress: anObject	messagesToSuppress := anObject! !!Installer methodsFor: 'mantis' stamp: 'kb 12/18/2006 13:01'!newChangeSetFromStream: aStream named: aName 	"This code is based upon ChangeSet-c-#newChangesFromStream:named: which is in 3.9,	implemented here for previous versions. The second branch is for 3.8, where ChangeSets	are loaded by ChangeSorter. "	| oldChanges newName newSet newStream |	(self classChangeSet respondsTo: #newChangesFromStream:named:) 		ifTrue: [ ^self classChangeSet newChangesFromStream: aStream named:aName ].	(self classChangeSorter respondsTo: #newChangesFromStream:named:)		ifTrue: [ ^self classChangeSorter newChangesFromStream: aStream named: aName ].	oldChanges := ChangeSet current. 	"so a Bumper update can find it"	newName := aName sansPeriodSuffix.	newSet := self classChangeSet basicNewNamed: newName.	[newSet		ifNotNil: [(aStream respondsTo: #converter:)				ifTrue: [newStream := aStream]				ifFalse: [newStream := self classMultiByteBinaryOrTextStream with: aStream contentsOfEntireFile.					newStream reset].			self classChangeSet newChanges: newSet.			newStream setConverterForCode.			newStream fileInAnnouncing: 'Loading ' , newName , '...'.			Transcript cr; show: 'File ' , aName , ' successfully filed in to change set ' , newName].	aStream close]		ensure: [self classChangeSet newChanges: oldChanges].	 	^ newSet! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 18:48'!open! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!package	^ self packages isEmpty ifTrue: [ nil ] ifFalse: [ self packages last ]! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!package: anObject	self addPackage: anObject.! !!Installer methodsFor: 'squeakmap' stamp: 'mtf 10/15/2008 10:14'!packageAndVersionFrom: pkg	| p |	p := ReadStream on: pkg .	^Array with: (p upTo: $() with: (p upTo: $)).! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!packages	 	^ packages ifNil: [ packages := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!packages: aCollection 	packages := aCollection! !!Installer methodsFor: 'searching' stamp: 'mtf 10/8/2008 12:00'!packagesMatching: aMatch	^'search type not supported'! !!Installer methodsFor: 'printing' stamp: 'damiencassou 2/20/2009 20:30'!printConfigurationOn: stream	! !!Installer methodsFor: 'printing' stamp: 'damiencassou 2/20/2009 20:30'!printOn: s	s		nextPutAll: '(Installer ';		nextPutAll: self label;		nextPut: $).	"lf project ifNotNil: [ s nextPutAll: ' project:'; nextPutAll: '''', self project, ''''.						self package ifNotNil: [ s nextPutAll: '; '] ]."	self package ifNotNil: [ s nextPutAll: ' package:'; nextPutAll: '''', self package asString, '''' ].	self printConfigurationOn: s.	s nextPut: $..! !!Installer methodsFor: 'custom names' stamp: 'kph 5/28/2007 03:42'!rememberAs: symbol	self class remembered at: symbol asSymbol put: self! !!Installer methodsFor: 'utils' stamp: 'kph 5/25/2007 01:15'!removeChangeSet: cs	(self classChangeSet respondsTo: #removeChangeSet:)		ifTrue: [ ^ChangeSet removeChangeSet: cs ].			^ self classChangeSorter removeChangeSet: cs .! !!Installer methodsFor: 'action report' stamp: 'sd 3/6/2008 18:45'!reportFor: theLine page: thePage on: report  		[ thePage atEnd ] whileFalse: [ 		| line |		line := thePage nextLine.		Installer actionMatch: line reportOn: report ifNoMatch: [ report nextPutAll: line; cr. ]].! !!Installer methodsFor: 'action report' stamp: 'sd 3/6/2008 18:45'!reportSection: line on: report		report isEmpty ifFalse: [ report cr ].	report nextPutAll: '">>>> ' ; nextPutAll: (line copyWithout: $"); nextPut: $"; cr.	! !!Installer methodsFor: 'searching' stamp: 'damiencassou 2/20/2009 19:29'!search: aMatch	^'search type not supported'! !!Installer methodsFor: 'auto answering' stamp: 'kph 2/5/2008 15:48'!suppress: aMessage	messagesToSuppress add: aMessage! !!Installer methodsFor: 'url' stamp: 'sd 3/6/2008 20:20'!validChangeSetName: aFileName	" dots in the url confuses the changeset loader. I replace them with dashes"	 	(aFileName beginsWith:'http:') ifTrue: [ | asUrl |		asUrl := Url absoluteFromText: aFileName.		^String streamContents: [:stream |			stream nextPutAll: (asUrl authority copyReplaceAll: '.' with: '-').			asUrl path allButLastDo: [:each |				stream					nextPutAll: '/';					nextPutAll: (each copyReplaceAll: '.' with: '-') ].			stream				nextPutAll: '/';				nextPutAll: asUrl path last ] ].	^aFileName! !!Installer methodsFor: 'logging' stamp: 'kph 5/25/2007 01:36'!validate	ValidationBlock value = false ifTrue: [ self error: 'Validation failed' ].! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!versions		^ self basicVersions! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!view	self logErrorDuring: [self basicView]! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 19:06'!view: packageNameCollectionOrDetectBlock	self package: packageNameCollectionOrDetectBlock.	self view! !!Installer methodsFor: 'mantis' stamp: 'kph 5/10/2007 00:21'!view: aFileName from: stream		self log: ' viewing...'. 		Workspace new contents: (stream contents); openLabel: aFileName. 	 				 ! !!Installer methodsFor: 'auto answering' stamp: 'kph 10/21/2006 06:52'!withAnswersDo: aBlock	(aBlock respondsTo: #valueSuppressingMessages:supplyingAnswers: )		ifTrue: [aBlock valueSuppressingMessages: self messagesToSuppress supplyingAnswers: self answers.]		ifFalse: [ aBlock value ]! !Installer subclass: #InstallerCruft	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerCruft commentStamp: 'mtf 10/1/2008 22:24' prior: 0!I am a copy of Installer as of Installer-Core-kph.232. I am being split up.I  am called InstallerCruft because I stand-in for Sake{MC,SM,Mantis,Web,etc}Installer!!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classProjectLauncher	^Smalltalk at: #ProjectLauncher ifAbsent: [ self error: 'ProjectLauncher not present' ]! !!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classSakePackages	^Smalltalk at: #SakePackages  ifAbsent: [ self error: 'Sake Packages code not present' ]! !!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classes	^ Smalltalk! !!InstallerCruft class methodsFor: 'documentation' stamp: 'kph 7/25/2007 13:25'!history"7 Jan 2007  !!Installer fixBug: <aBugNo>aBugNo can now be a number or a string, beginning with a number. This allows the mantis bug report summary to be used verbatim.It also provides more infomarion for Installer to support self documentation.!!Install fix if not already installed Installer ensureFix: <aBugNoOrString> Installer ensureFixes: #(1 2 3 4)Installer now keeps a list of fix <aBugNoOrString> that have been installed up to this point.#ensureFix: will only install the fix if it has not already been loaded.note that only the bugNumber not the description is significant in the check.8 Jan 2007!!Installer view: <webPageNameOrUrl>Provided that web page based scripts follow some simple rules, installer can collate the scripts from web pages into a single workspace where you can manually 'doit' portions as you wish.The report generation is not very clever, it only matches on: 'Installer install:' ,  'Installer installUrl:', and 'Installer mantis fixBug:' note these lines must be properly completed with an ending $. (period).also invoked by commandline option VIEW=<webPageNameOrUrl>10 Jan 2007!!Now matches simpler htmlCheck for an html page, now matches'<!!DOCTYPE HTML' and <html> the allows use of pbwiki's raw=bare option which returns iframe embeddable html without the usual headers.8 May 2007Modified bug:fix:date: so that the fixesApplied history does not contain unnecessary duplicate entries.Fixed changeset naming for mantis bugs.25 July 2007Added Universes  Support"! !!InstallerCruft class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:38'!label	^ 'cruft'! !!InstallerCruft class methodsFor: 'documentation' stamp: 'kph 5/24/2007 18:54'!mczInstall: urlOrFile	^ self new mczInstall: urlOrFile! !!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:20'!smalltalkImage	^ SmalltalkImage current! !!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:20'!sourceFiles	^ SourceFiles! !!InstallerCruft class methodsFor: 'unload' stamp: 'stephane.ducasse 9/30/2008 18:30'!unload: categoryMatchesString 	^ self error: 'deprecated, use Installer mc unload: ''pkgname''.'! !!InstallerCruft methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classMCMczReader	^Smalltalk at: #MCMczReader ifAbsent: [ nil ]	! !!InstallerCruft methodsFor: 'mantis' stamp: 'edc 4/4/2007 07:56'!createRBforBug: aBugNo 	| aStream  fileList selFile aFileName |	self setBug: aBugNo.fileList := self maFiles keys asOrderedCollection.fileList  addLast: 'none'.ReleaseBuilderFor3dot10 clear.[selFile := UIManager default chooseFrom: fileList title: 'Choose what files load '.selFile = fileList size ifFalse:[aFileName := fileList at: selFile.	self logCR: 'obtaining ', aFileName, '...'.	aStream := self maStreamForFile: aFileName .	ReleaseBuilderFor3dot10 current packagesInfluenced: aStream named: aFileName.		self installCS: aFileName from: aStream].selFile = fileList size]whileFalse.		ReleaseBuilderFor3dot10 current newUpdateFor: aBugNo			! !!InstallerCruft methodsFor: 'mantis' stamp: 'sd 3/6/2008 19:10'!evaluate: stream	stream fileIn.! !!InstallerCruft methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!info	self sm ifTrue: [ ^ self smInfo  ].	self wsm ifNotNil: [ ^ self wsmInfo  ].! !!InstallerCruft methodsFor: 'monticello' stamp: 'kph 5/24/2007 18:56'!mczInstall: urlOrFile	self log: ('Loading ', urlOrFile, ' ...').	(urlOrFile beginsWith: 'http:')		ifTrue: [  MczInstaller installStream: (HTTPSocket httpGet: urlOrFile) ]		ifFalse: [ MczInstaller installFileNamed: urlOrFile ].			self logCR: ' Loaded'.	! !!InstallerCruft methodsFor: 'mantis' stamp: 'kph 12/21/2006 01:28'!skipTests! !!InstallerCruft methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:06'!user	^ user ifNil: [ '' ]! !!InstallerCruft methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:06'!user: anObject	user := anObject! !!InstallerCruft methodsFor: 'utils' stamp: 'kph 5/9/2007 21:49'!viewUrl	^Workspace new contents: (self urlGet contents); openLabel: self urlToDownload.! !Installer subclass: #InstallerFile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerFile class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:39'!label	^ 'file'! !!InstallerFile methodsFor: 'basic interface' stamp: 'kph 7/28/2007 23:48'!basicBrowse		self browse: self file from:  (FileDirectory readOnlyFileNamed: self file).	! !!InstallerFile methodsFor: 'basic interface' stamp: 'kph 7/28/2007 23:48'!basicInstall		self install: self file from: (FileDirectory default readOnlyFileNamed: self file)	! !!InstallerFile methodsFor: 'basic interface' stamp: 'kph 7/28/2007 23:48'!basicView		self view: self file from:  (FileDirectory readOnlyFileNamed: self file).	! !!InstallerFile methodsFor: 'accessing' stamp: 'mtf 10/23/2008 15:51'!file	^ self package! !!InstallerFile methodsFor: 'accessing' stamp: 'mtf 10/23/2008 15:51'!file: f	self package: f! !Installer subclass: #InstallerInternetBased	instanceVariableNames: 'url pageDataStream markers'	classVariableNames: 'Entities'	poolDictionaries: ''	category: 'Installer-Core'!!InstallerInternetBased class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:20'!entities	^ Entities ifNil: [ Entities := 				"enough entities to be going on with"  				Dictionary new.				Entities at: 'lt' put: '<';				at: 'gt' put: '>';				at: 'amp' put: '&';				at: 'star' put: '*';				at: 'quot' put: '"';				at: 'nbsp' put: ' '; 			yourself] ! !!InstallerInternetBased methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classHTTPSocket	^Smalltalk at: #HTTPSocket ifAbsent: [ self error: 'Network package not present' ]! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:07'!extractFromHtml: html option: allOrLast	|  start stop test in |	start := self markersBegin.	stop :=  self markersEnd.	test := self markersTest.			 	in := ReadWriteStream with: String new.			[ html upToAll: start; atEnd ] 		whileFalse: [			| chunk |			(allOrLast == #last) ifTrue: [ in resetToStart ]. 			chunk := html upToAll: stop.			self isSkipLoadingTestsSet ifTrue: [ chunk := chunk readStream upToAll: test ].			in nextPutAll: chunk. 		 ].	^self removeHtmlMarkupFrom: in reset	 ! !!InstallerInternetBased methodsFor: 'url' stamp: 'kph 10/11/2008 17:02'!hasPage	^ pageDataStream notNil and: [ pageDataStream size > 0 ]			! !!InstallerInternetBased methodsFor: 'utils' stamp: 'sd 3/6/2008 20:15'!httpGet: aUrl	| page |	page := self classHTTPSocket httpGet: aUrl accept: 'application/octet-stream'.   	(page respondsTo: #reset)  ifFalse: [ self error: 'unable to contact web site' ].	^ page	! !!InstallerInternetBased methodsFor: 'url' stamp: 'sd 3/6/2008 20:18'!isHtmlStream: page	"matches  '<!!DOCTYPE HTML', and <html>' "		| first |		first := (page next: 14) asUppercase.	^ (first = '<!!DOCTYPE HTML') | (first beginsWith: '<HTML>')	! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:07'!markers	^ markers ifNil: [ '<code st>..."test ...</code st>' ]! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:07'!markers: anObject	markers := anObject! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:08'!markersBegin		 	 	 ^ self markers copyUpTo: $.! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:08'!markersEnd	"return the third marker or the second if there are only two"		| str  a | 	str := self markers readStream.	a := str upToAll: '...'; upToAll: '...'.	str atEnd  ifTrue: [ ^a ] ifFalse: [ ^str upToEnd ]	! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:08'!markersTest		 	 	^ self markers readStream upToAll: '...'; upToAll: '...'! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:08'!removeHtmlMarkupFrom: in 	| out |	out := ReadWriteStream on: (String new: 100).	[ in atEnd ] whileFalse: [ 		out nextPutAll: (in upTo: $<).		(((in upTo: $>) asLowercase beginsWith: 'br') and: [ (in peek = Character cr) ]) ifTrue: [ in next ].		].		^self replaceEntitiesIn: out reset.! !!InstallerInternetBased methodsFor: 'url' stamp: 'sd 3/6/2008 20:19'!replaceEntitiesIn: in	| out |	out := ReadWriteStream on: (String new: 100).	[ in atEnd ] whileFalse: [ 		out nextPutAll: ((in upTo: $&) replaceAll: Character lf with: Character cr).		in atEnd ifFalse: [ out nextPutAll: (self class entities at: (in upTo: $;) ifAbsent: '?') ].		].	^out reset! !!InstallerInternetBased methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:06'!url	^url! !!InstallerInternetBased methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:06'!url: aUrl 	url := aUrl! !!InstallerInternetBased methodsFor: 'url' stamp: 'sd 3/6/2008 20:19'!urlGet	^ self urlGet: self urlToDownload! !!InstallerInternetBased methodsFor: 'url' stamp: 'kph 12/9/2008 03:17'!urlGet: aUrl	| page |	page := HTTPSocket httpGet: aUrl accept: 'application/octet-stream'.  	(page respondsTo: #reset)  ifFalse: [ ^ nil ].	(self isHtmlStream: page) ifTrue: [ page := self extractFromHtml: page option: nil ].	^ page reset	! !!InstallerInternetBased methodsFor: 'url' stamp: 'kph 10/11/2008 17:02'!wasPbwikiSpeedWarning				^ self hasPage and: [pageDataStream contents includesSubString: 'Please slow down a bit' ]  ! !InstallerInternetBased subclass: #InstallerUrl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerUrl class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!canReportLine: line	^ ((line beginsWith: 'Installer installUrl:') and: 		[ | ext |		 ext :=  (line readStream upToAll: '''.') copyAfterLast: $..		 (#( 'cs' 'st' 'mcz' 'sar') includes: ext) not ])! !!InstallerUrl class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:39'!label	^ 'url'! !!InstallerUrl methodsFor: 'action report' stamp: 'kph 1/8/2007 11:19'!action: line reportOn: report  	url :=  line readStream upTo: $' ; upTo: $'.  		self reportSection: line on: report.	(pageDataStream := self urlGet: self urlToDownload) 		ifNil: [ self error: 'unable to contact host' ].	 		self reportFor: line page: pageDataStream on: report ! !!InstallerUrl methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:19'!basicBrowse 	"(Installer debug url: 'http://installer.pbwiki.com/f/Installer.st') browse.".		self browse: self urlToDownload from: self urlThing.		! !!InstallerUrl methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:19'!basicInstall  	 	self install: self urlToDownload from: self urlThing.	^ pageDataStream ! !!InstallerUrl methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:19'!basicView 	 "(Installer debug url: 'http://installer.pbwiki.com/f/Installer.st') view.".		self view: self urlToDownload from: self urlThing.		! !!InstallerUrl methodsFor: 'accessing' stamp: 'kph 2/24/2009 07:07'!bootstrap"(Installer url: 'http://www.squeaksource.com/Sake/Sake-Core-kph.47.mcz') bootstrap."| pkg splitPos repo getFileName fileName |isBootstrap := true.splitPos := url lastIndexOf: $/. pkg := url copyFrom: splitPos + 1 to: url size.repo := url copyFrom: 1 to: splitPos.getFileName := [ :pkgName | pkgName , ((HTTPSocket httpGet: repo) upToAll: pkgName; upTo: $") ]. fileName := getFileName value: pkg.url := repo,fileName.self install! !!InstallerUrl methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:44'!label	^ 'url:''', url, ''''! !!InstallerUrl methodsFor: 'url' stamp: 'mtf 10/15/2008 08:40'!urlThing 	| retry delay |		self logCR: 'retrieving ', self urlToDownload , ' ...'.		delay := 0.	[ retry := false. pageDataStream := self urlGet: self urlToDownload ] 		doWhileTrue: [  				self wasPbwikiSpeedWarning ifTrue: [retry := true. delay := delay + 5.				self logCR: 'PBWiki speed warning. Retrying in ', delay printString, ' seconds'.				(Delay forSeconds: delay) wait ].														retry ].			pageDataStream ifNil: [ self error: 'unable to contact host' ].	 	^ pageDataStream	! !!InstallerUrl methodsFor: 'url' stamp: 'kph 1/4/2007 23:49'!urlToDownload	^ (self url, (self package ifNil: [ '' ])) asUrl asString.	 ! !InstallerInternetBased subclass: #InstallerWebBased	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!InstallerWebBased subclass: #InstallerMantis	instanceVariableNames: 'ma bug desc date array data status'	classVariableNames: 'Fixes Status'	poolDictionaries: ''	category: 'Installer-Core'!!InstallerMantis commentStamp: 'test 1/14/2009 00:11' prior: 0!Search feature is based upon a custom mantis query ceveloped and maintained by Ken Causey <ken@kencausey.com>Installer mantis bugsAll select: [ :ea | ea status = 'testing' ].!!InstallerMantis class methodsFor: 'instance creation' stamp: 'test 1/12/2009 00:00'!initialize	Status := Dictionary new		at: '10' put: 'new';		at: '20' put: 'feedback';		at: '30' put: 'acknowledged';		at: '40' put: 'confirmed';		at: '50' put: 'assigned';		at: '60' put: 'pending';		at: '70' put: 'testing';		at: '80' put: 'resolved';		at: '90' put: 'closed';		yourself ! !!InstallerMantis class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!canReportLine: line	^ line beginsWith: 'Installer mantis fixBug:'! !!InstallerMantis class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:21'!fixesApplied	^ Fixes ifNil: [ Fixes := OrderedCollection new ].! !!InstallerMantis class methodsFor: 'instance creation' stamp: 'stephane.ducasse 9/30/2008 18:24'!host: host	^self new	ma: host; 			markers: '&quot;fix begin&quot;...&quot;fix test&quot;...&quot;fix end&quot;'; 			yourself.! !!InstallerMantis class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:40'!label	^ 'mantis'! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:42'!= other	^ array = other array! !!InstallerMantis methodsFor: 'action report' stamp: 'sd 3/6/2008 18:44'!action: line reportOn: report		| param mantis |	mantis := Installer mantis.	param :=  line readStream upTo: $: ; upTo: $..		mantis setBug: ((param readStream upTo: $'; atEnd)		 ifTrue: [  param ]		 ifFalse: [ param readStream upTo: $'; upTo: $' ]).		self reportSection: line on: report.	report nextPutAll: (mantis replaceEntitiesIn: mantis markersBegin readStream).	self reportFor: line page: mantis maScript on: report.	report nextPutAll: (mantis replaceEntitiesIn: mantis markersEnd readStream); cr.	! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:40'!array	^ array! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:25'!browseFile: aFileName	^ self browse: aFileName from: (self maThing: aFileName date: nil)! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:45'!bug		^ bug ifNil: [ 				date := ((self dataAtName: 'Updated') replaceAll: $  with: $T) asDateAndTime. 		desc := (self dataAtName: 'Summary').		bug := (self dataAtName: 'Id'). 		self statusInit. 	]! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/17/2008 10:53'!bug: aBugNo	self setBug: aBugNo.	^ self report! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:26'!bug: aBugNo browse: aFileName	 self setBug: aBugNo.	^ self browseFile: aFileName! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/18/2006 04:11'!bug: aBugNo fix: aFileName	^ self bug: aBugNo fix: aFileName date: nil! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/9/2008 22:46'!bug: aBugNo fix: aFileName date: aDate 	| |	self setBug: aBugNo.	self ditchOldChangeSetFor: aFileName.	self install: aFileName from: (self maThing: aFileName date: aDate).			^ date! !!InstallerMantis methodsFor: 'public interface' stamp: 'sd 3/6/2008 19:09'!bug: aBugNo retrieve: aFileName	 self setBug: aBugNo.	^ (self maStreamForFile: aFileName) contents! !!InstallerMantis methodsFor: 'public interface' stamp: 'sd 3/6/2008 19:09'!bug: aBugNo view: aFileName	"Installer mantis bug: 6089 browse: 'TTFSpeedUp-dgd.1.cs'"		 self setBug: aBugNo.	^ self view: aFileName from: (self maThing: aFileName date: nil)! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:35'!bugFiles: aBugNo 	"provide a list of files associated with the bug in id order"	"	Installer mantis bugFiles: 6660.	"	self setBug: aBugNo; files! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:37'!bugFilesView: aBugNo 	"provide a list of files associated with the bug in id order"	"	Installer mantis bugFiles: 6660.	"	self setBug: aBugNo; viewFiles! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:37'!bugScript: aBugNo	^ (self setBug: aBugNo) script		! !!InstallerMantis methodsFor: 'action report' stamp: 'test 1/13/2009 23:39'!bugsAll	^ array ifNil: [				array := ( self bugsSqueak ,  (self dataGetFrom: '/installer_export.php') ) asSet asSortedCollection: [ :a :b | a date > b date ]			]."Installer mantis bugsAll"	! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/13/2009 23:00'!bugsClosed	^ array ifNil: [ array := self dataGetFrom: '/installer_export.php?closed' ]! !!InstallerMantis methodsFor: 'search' stamp: 'kph 2/15/2009 15:08'!bugsRelease: version	^self bugsAll select: [ :ea | (ea status = 'resolved') and: [ ea fixedIn = version ]]! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/13/2009 22:59'!bugsSqueak	^ array ifNil: [ array := self dataGetFrom: '/installer_export.php?project=Squeak' ]	"Installer mantis bugsSqueak.Installer mantis bugsAll.Installer mantis bugsClosed."! !!InstallerMantis methodsFor: 'search' stamp: 'kph 2/15/2009 15:14'!bugsTesting: version	^self bugsAll select: [ :ea | ea status = 'testing' and: [ ea fixedIn = version ]]! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/11/2009 23:15'!category	^ self dataAtName: 'Category'	 "s bugs collect: [ :ea | ea category ]"! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/11/2009 23:28'!dataAtName: key		^ array at: (self dataNames indexOf: key)! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/13/2009 22:51'!dataAtName: key put: v		^ array at: (self dataNames indexOf: key) put: v! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/12/2009 00:15'!dataClosed	^ array ifNil: [ array := self dataGetFrom: '/installer_export.php?closed' ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 2/22/2009 13:42'!dataGetFrom: aPath	| rs line first col row out |			rs := HTTPSocket httpGet: ma, aPath.		rs isString ifTrue: [ ^ ProtocolClientError signal: 'notFound' ].		first := true.		out := OrderedCollection new.		[ rs atEnd ] whileFalse: [ 				line := rs nextLine readStream.		col := 1.		row := Array new: 9.		[ (line atEnd or: [ col > 9 ]) ] whileFalse: [ row at: col put: (line upTo: $|). col := col + 1 ].			rs next.		[ out add: (self class new in: self row: row) ] ifError: []			 ].			^ out"self reset.self getBugsList "! !!InstallerMantis methodsFor: 'public interface' stamp: 'test 1/11/2009 23:29'!dataNames	^ #(Id Project Category Assigned Updated Status Severity FixedIn Summary)! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 12/17/2008 11:58'!date 	^ date ! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 12/11/2008 14:41'!date: anObject	date := anObject ifNotNilDo: [ :d | d asDate ]! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 1/8/2007 07:22'!desc	 	^ desc! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 1/8/2007 07:22'!desc: anObject	desc := anObject! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:47'!ensureFix	| fixesAppliedNumbers |		fixesAppliedNumbers := self fixesApplied collect: [ :fixDesc | fixDesc asInteger ].	(fixesAppliedNumbers includes: bug) ifFalse: [ self fixBug ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:48'!ensureFix: aBugNo	^self ensureFix: aBugNo date: nil! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:47'!ensureFix: aBugNo date: aDate	self setBug: aBugNo.	self date: aDate..		self ensureFix.! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:45'!ensureFixes: aBugNos	aBugNos do: [ :bugNo | self ensureFix: bugNo ].! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:34'!files 	"provide a list of files associated with the bug in id order"	"	Installer mantis bugFiles: 6660.	"	^ (self maFiles associations asSortedCollection: [ :a :b | a value asInteger < b value asInteger ]) 				collect: [ :a | a key ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/14/2008 18:06'!fixBug 	self install: self maUrl from: self maScript.	self maCheckDateAgainst: date.			self fixesAppliedNumbers in: [ :fixed |		(fixed isEmpty or: [ (fixed includes: bug asInteger) not]) 		ifTrue: [ self fixesApplied add: (bug asString, desc) ]].		! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:48'!fixBug: aBugNo 	^ self fixBug: aBugNo date: nil.	! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:44'!fixBug: aBugNo date: aDate	self setBug: aBugNo. 	self date: aDate.	self fixBug.	! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/14/2009 01:12'!fixedIn	^ self dataAtName: 'FixedIn'! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 10/16/2008 00:04'!fixesApplied	^ Fixes ifNil: [ Fixes := OrderedCollection new ].! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/9/2008 22:48'!fixesAppliedNumbers	^ self fixesApplied collect: [ :fixDesc | fixDesc asInteger ]. ! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 12/10/2008 14:21'!getView	"Installer mantis viewBug: 5639."	| page text | 		page := self maPage. 	text := String streamContents: [ :str |						#('Bug ID' 'Category' 'Severity' 'Reproducibility' 'Date Submitted' 			'Date Updated' 'Reporter' 'View Status' 'Handler' 			'Priority' 'Resolution' 'Status' 'Product Version' 'Summary' 'Description' 'Additional Information' ) 				do: [ :field |						| f |						f := self maRead: page field: field.			str nextPutAll: f key; nextPutAll: ': '; nextPutAll: f value; cr.		].		str nextPutAll: 'Notes: '; cr.		(self maReadNotes: page) do: [ :note | str nextPutAll: note; cr; cr ].				str nextPutAll: 'Files: '; nextPutAll: self maFiles keys asArray printString.	]. 	^ text	! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:41'!hash	^ array hash! !!InstallerMantis methodsFor: 'public interface' stamp: 'test 1/11/2009 23:56'!in: parent row: dataRow	self ma: parent ma.	self markers: parent markers.	self setArray: dataRow.! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 1/4/2007 06:43'!justFixBug: aBugNo	^self class skipLoadingTests: true during: [ self fixBug: aBugNo date: nil ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 1/4/2007 06:43'!justFixBug: aBugNo date: d	^self class skipLoadingTests: true during: [ self fixBug: aBugNo date: d ]! !!InstallerMantis methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!ma	^ ma! !!InstallerMantis methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!ma: aUrl	ma := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!InstallerMantis methodsFor: 'utils' stamp: 'sd 3/6/2008 20:16'!maCheckDateAgainst: okDate	(okDate notNil and: [date < okDate asDate ]) 		ifTrue: [ self notify: 'bug ', self bug asString, ' updated on ', date printString ]. ! !!InstallerMantis methodsFor: 'mantis' stamp: 'stephane.ducasse 9/30/2008 18:37'!maFiles 	| file files bugPage id  |  	files := Dictionary new. 	bugPage := self maPage.	 [ 		id := bugPage upToAll: 'href="file_download.php?file_id='; upTo: $&.  		file := bugPage upToAll: 'amp;type=bug"' ; upTo: $<. 		((file size > 1) and: [file first = $>]) ifTrue: [ files at: file copyWithoutFirst put: id ]. 		id notEmpty ] whileTrue.	^files ! !!InstallerMantis methodsFor: 'mantis' stamp: 'stephane.ducasse 9/30/2008 18:37'!maPage  	"  self mantis bug: 5251."	| page |	page :=  self httpGet: self maUrl. 	date := ((self maRead: page field: 'Date Updated') value copyUpTo: $ ).	date isEmpty ifTrue: [ ^self error: bug, ' not found' ].	date := date asDate. 	^page reset! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 12/17/2008 13:55'!maRead: page field: fieldKey	 | value | 	value := page upToAll: ('!!-- ', fieldKey, ' -->'); upToAll: '<td'; upTo: $>; upToAll: '</td>'.		page upTo: $<.		page peek = $t ifTrue: [ value := page upToAll: 'td'; upTo: $>; upToAll: '</td>' ].	  	^Association key: fieldKey value: (self removeHtmlMarkupFrom: value withBlanksTrimmed readStream) contents! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 12/17/2008 13:51'!maReadNotes: page 	 |  notes note  | 	notes := OrderedCollection new.	[ page upToAll: 'tr class="bugnote"'; upTo: $>.	  page atEnd ]			whileFalse: [ 		note := (self removeHtmlMarkupFrom: (page upToAll: '</tr>') readStream) contents.		note := note withBlanksCondensed.		note replaceAll: Character lf with: Character cr.		notes add: note  	].		^notes! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 1/8/2007 10:01'!maScript 	^self extractFromHtml: self maPage option: #last! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:48'!maStreamForFile: aFileName	| fileId  | 	fileId :=  self maFiles at: aFileName ifAbsent: [ self error: aFileName, ' not found' ]. 	^ self httpGet: (self ma, 'file_download.php?file_id=' , fileId , '&type=bug').	 ! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 5/9/2007 22:31'!maThing: aFileName date: aDate 	self logCR: 'obtaining ', aFileName, '...'.	pageDataStream := self maStreamForFile: aFileName.	self maCheckDateAgainst: aDate.	^ pageDataStream	! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:54'!maUrl 	^ url := self ma, 'view.php?id=', bug asString ! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 12/18/2006 04:08'!maUrlFor: maBugNo 	^ url := self ma, 'view.php?id=', maBugNo asString  ! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 12/9/2008 23:42'!printOn: stream	super printOn: stream.		(array ifNil: [ ^ self ]) printOn: stream.! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/14/2009 01:06'!project	^ self dataAtName: 'Project'! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/17/2008 14:03'!report	"Installer mantis viewBug: 5639."	| page text | 		page := self maPage. 	text := String streamContents: [ :str |						#('Bug ID' 'Category' 'Severity' 'Reproducibility' 'Date Submitted' 			'Date Updated' 'Reporter' 'View Status' 'Handler' 			'Priority' 'Resolution' 'Status' 'Product Version' 'Summary' 'Description' 'Additional Information' ) 				do: [ :field |						| f |						f := self maRead: page field: field.			str nextPutAll: f key; nextPutAll: ': '; nextPutAll: f value; cr.		].		str nextPutAll: 'Notes: '; cr.		(self maReadNotes: page) do: [ :note | str nextPutAll: note; cr; cr ].				str nextPutAll: 'Files: '; nextPutAll: self maFiles keys asArray printString.	]. 	^ text	! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:27'!script 	^ self maScript contents.	 		! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/11/2008 15:30'!selectCategoryCollections	^ self select: [ :ea | ea category = 'Collections' ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'test 1/11/2009 23:57'!setArray: dataRow	(array := dataRow) ifNotNil: [ self bug ].! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 12/9/2008 20:25'!setBug: stringOrNumber	| newBug |		(newBug := stringOrNumber asInteger) = bug ifTrue: [ ^ self ].		self logCR: 'Installer accessing bug: ' , stringOrNumber asString. 	bug := newBug.	 	stringOrNumber = bug ifTrue: [ desc := ''. ^ self ].	desc := stringOrNumber withoutLeadingDigits  ! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/11/2009 23:48'!status 	^ status! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:45'!statusInit	status ifNil: [ status := Status at: (self dataAtName: 'Status').		self dataAtName:'Status' put: status.	].	! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/11/2009 23:15'!summary	^ self dataAtName: 'Summary'! !!InstallerMantis methodsFor: 'action report' stamp: 'kph 2/13/2009 05:50'!validChangeSetName: aFileName	| csn prefix |	csn := super validChangeSetName: aFileName.		prefix := 'M' , self bug asString.		^ (csn beginsWith: prefix) 		ifTrue: [ csn ]		ifFalse: [ prefix, '-', (csn replaceAll: prefix with: '') ].			! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:32'!view		^ Workspace new contents: self report; openLabel: ('Mantis ', bug printString).! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:22'!viewBug: aBugNo	self setBug: aBugNo; view! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:23'!viewFile: aFileName	"Installer mantis bug: 6089 browse: 'TTFSpeedUp-dgd.1.cs'"		^ self view: aFileName from: (self maThing: aFileName date: nil)! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:36'!viewFiles		^ self files do: [ :ea | self viewFile: ea ].! !InstallerWebBased subclass: #InstallerWeb	instanceVariableNames: ''	classVariableNames: 'WebSearchPath'	poolDictionaries: ''	category: 'Installer-Core'!!InstallerWeb class methodsFor: 'instanciation' stamp: 'kph 2/23/2009 04:10'!initialize		WebSearchPath := nil! !!InstallerWeb class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!canReportLine: line	^ ((line beginsWith: 'Installer install:') | (line beginsWith: 'Installer do:'))! !!InstallerWeb class methodsFor: 'compatability' stamp: 'stephane.ducasse 9/30/2008 18:22'!install: webPageName"This keeps the syntax Installer web install: working"	^ self new install: webPageName! !!InstallerWeb class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:40'!label	^ 'web'! !!InstallerWeb class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:22'!searchPath	"a search path item, has the following format. prefix*suffix"	^ WebSearchPath ifNil: [ WebSearchPath := OrderedCollection new ].! !!InstallerWeb methodsFor: 'action report' stamp: 'kph 10/11/2008 16:48'!action: line reportOn: report		self package: (line readStream upTo: $' ; upTo: $').	self reportSection: line on: report.	 	url := self urlToDownload.		self reportFor: line page: pageDataStream on: report ! !!InstallerWeb methodsFor: 'basic interface' stamp: 'kph 10/11/2008 16:49'!basicBrowse  	 self thing size > 0 		ifTrue: [ self browse: url from: pageDataStream ]		ifFalse: [ self logCR: 'NO DATA ',url,' was empty' ].	 ! !!InstallerWeb methodsFor: 'basic interface' stamp: 'kph 10/11/2008 16:49'!basicInstall  	 self thing size > 0 		ifTrue: [ self install: url from: pageDataStream ]		ifFalse: [ url ifNil: [ ^ self logCR: self package, ' not found on webSearchPath' ].				  self logCR: '...',url,' was empty' ].	 ! !!InstallerWeb methodsFor: 'basic interface' stamp: 'kph 10/11/2008 16:49'!basicView  	 self thing size > 0 		ifTrue: [ self view: url from: pageDataStream ]		ifFalse: [ self logCR: 'NO DATA ',url,' was empty' ].	 ! !!InstallerWeb methodsFor: 'web install' stamp: 'mtf 10/15/2008 09:04'!thing	self logCR: 'searching for web package ''', self package, ''''. 	url := self urlToDownload.	url ifNil: [ self logCR: 'page ', self package, ' not found on path' ]		ifNotNil: [ self logCR: 'found ',  url, ' ...'.   ].	^ pageDataStream! !!InstallerWeb methodsFor: 'web install' stamp: 'mtf 10/15/2008 08:39'!urlToDownload	"while we look for a url which returns what we are looking for, we  get the data anyway"		| delay retry |	delay := 0.	self class webSearchPath do: [ :pathSpec | | potentialUrl readPathSpec  |		readPathSpec := pathSpec value readStream.		potentialUrl := (readPathSpec upTo: $*), self package, (readPathSpec upToEnd ifNil: [ '' ]).		[ retry := false. pageDataStream := self urlGet: potentialUrl ] doWhileTrue: [ 				self wasPbwikiSpeedWarning				ifTrue: [ retry := true. delay := delay + 5. 					self logCR: 'PBWiki speed warning. Retrying in ', delay printString, ' seconds'.					(Delay forSeconds: delay) wait]				ifFalse: [ self hasPage ifTrue: [ pageDataStream reset. ^ potentialUrl ] ].			retry ]].	^nil! !InstallerWebBased subclass: #InstallerWebSqueakMap	instanceVariableNames: 'wsm'	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerWebSqueakMap class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:40'!label	^ 'websqueammap'! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'squeak 3/31/2008 22:21'!basicAvailablePackages	| html id name pkgs | 	pkgs := Dictionary new.	html := self httpGet: (self wsm, 'packagesbyname').		[ id := html upToAll: '/package/'; upToAll: '">'.	name := html upTo: $<.	(id notEmpty and: [ name notEmpty ])] 		whileTrue: [ pkgs at: name put: id ].	^ pkgs		! !!InstallerWebSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:41'!basicInstall		| it |	it := self wsmThing.	self install: it from: it asUrl retrieveContents contentStream.	! !!InstallerWebSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:42'!basicVersions	| pkgAndVersion packageId packageName packageVersion versions |	pkgAndVersion := self packageAndVersionFrom: self package .	packageName := pkgAndVersion first.	packageVersion := pkgAndVersion last.	packageVersion isEmpty ifTrue: [ packageVersion := #latest ].	packageId := self availablePackages at: packageName.	versions := (self wsmReleasesFor: packageId) keys.	versions remove: #latest.	^ versions collect: [ :version | self copy package: (packageName,'(', version ,')'); yourself ]. ! !!InstallerWebSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:42'!basicView		| it |	it := self wsmThing.	self view: it from: (self httpGet: it).	! !!InstallerWebSqueakMap methodsFor: 'searching' stamp: 'mtf 10/8/2008 12:00'!packagesMatching: aMatch	^ (self availablePackages		select: [ :p | ( aMatch) match: p ]) 		collect: [ :p | self copy package: p ; yourself ]! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:40'!wsm		^ wsm! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:41'!wsm: aUrl 	wsm := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:41'!wsmDownloadUrl 	| pkgAndVersion packageId packageName packageVersion releaseAutoVersion 	downloadPage |	pkgAndVersion := self packageAndVersionFrom: self package.	packageName := pkgAndVersion first.	packageVersion := pkgAndVersion last.	packageVersion isEmpty ifTrue: [ packageVersion := #latest ].	packageId := self availablePackages at: packageName.	releaseAutoVersion := (self wsmReleasesFor: packageId) at: packageVersion.					 	downloadPage := self httpGet: (self wsm,'packagebyname/', packageName,'/autoversion/', releaseAutoVersion,'/downloadurl') asUrl asString.				 		 	^ downloadPage contents	! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:42'!wsmReleasesFor: packageId	| html autoVersion version releases |	releases := Dictionary new.	html := self httpGet: (self wsm, '/package/', packageId ).	[releases at: #latest put: autoVersion.	autoVersion := html upToAll: '/autoversion/'; upTo: $".	version := html upTo: $-; upTo: $<.	(autoVersion notEmpty and: [version notEmpty ])] 		whileTrue: [ releases at: version put: autoVersion ].	^ releases	! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:42'!wsmThing	| downloadUrl |	self logCR: 'finding ', self package, ' from websqueakmap(', self wsm, ') ...'.	downloadUrl := self wsmDownloadUrl.	self logCR: 'found at ', downloadUrl asString, ' ...'.	^ downloadUrl	! !Installer subclass: #InstallerMonticello	instanceVariableNames: 'mc root project'	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerMonticello class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:41'!label	^ 'monticello'! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicAvailablePackages	^ self mc allFileNames! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'kph 12/5/2008 02:46'!basicBrowse	 "Installer ss project: 'Installer'; browse: 'Installer-Core'."	| it |	it := self mcThing.		(it class includesSelector: #browse) ifTrue: [ ^ it browse ].		(it instVarNamed: 'versions') do: #browse.! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'kph 10/23/2008 23:09'!basicInstall	 	self withAnswersDo: [ self mcThing load ].	self logCR: 'loaded'.! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:18'!basicVersions	^ (self availablePackages select: [ :p | ( self package,'-*.mcz' ) match: p ]) collect: [ :p | self copy package: p  ; yourself ]. ! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'kph 12/5/2008 02:56'!basicView	 "Installer ss project: 'Installer'; view: 'Installer-Core'. "	| it |		packages isEmptyOrNil ifTrue: [ self mc morphicOpen: nil ].		it := self mcThing. 	(it respondsTo: #open) ifTrue: [ ^ it open ].	"in case an old mc doesnt have #open"		(it instVarNamed: 'versions') do: #open.! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'mtf 5/20/2008 17:38'!cache		mc := self classMCCacheRepository default.	root := mc directory localName ! !!InstallerMonticello methodsFor: 'class references' stamp: 'mtf 5/20/2008 16:43'!classMCCacheRepository	^Smalltalk at: #MCCacheRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 01:01'!classMCDirectoryRepository	^Smalltalk at: #MCDirectoryRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:56'!classMCFtpRepository	^Smalltalk at: #MCFtpRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:59'!classMCGOODSRepository	^Smalltalk at: #MCGOODSRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:56'!classMCHttpRepository	^Smalltalk at: #MCHttpRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:59'!classMCMagmaRepository	^Smalltalk at: #MCMagmaRepository ifAbsent: [ self error: 'Magma not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'mtf 10/25/2008 14:04'!classMCRepositoryGroup	^Smalltalk at: #MCRepositoryGroup ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:56'!classMCSmtpRepository	^Smalltalk at: #MCSmtpRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'stephane.ducasse 9/30/2008 18:34'!classMCVersionLoader	^Smalltalk at: #MCVersionLoader  ifAbsent: [ self error: 'Monticello not present' ]! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 12/19/2007 00:30'!directory: dir	| directory |	directory := dir isString 		ifTrue: [  FileDirectory on: (FileDirectory default fullNameFor: dir) ]		ifFalse: [ dir ].			mc := self classMCDirectoryRepository new directory: directory; yourself. 	root := dir	 ! !!InstallerMonticello methodsFor: 'accessing' stamp: 'kph 12/2/2008 07:43'!fromUrl: aUrl	| url  path |		url := aUrl asUrl.	self http: url authority.		path := url path.		path size = 2 ifTrue: [ 		self project: path first.		path removeFirst. 	].			path size = 1 ifTrue: [ self package: path first ].! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 12/18/2008 02:06'!ftp: host directory: dir user: name password: secret	"Installer mc ftp: 'mc.gjallar.se' directory: '' user: 'gjallar' password: secret."		mc := self classMCFtpRepository host: host directory: dir user: name password: secret.	root :=  dir.	 ! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 5/10/2007 00:58'!goods: host port: aport		mc := (self classMCGOODSRepository new) host: host port: aport; yourself ! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 12/15/2007 11:37'!http: aUrl  		self http: aUrl user: 'squeak' password: 'squeak'		 ! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 5/10/2007 03:45'!http: aUrl user: name password: secret		mc := self classMCHttpRepository location: aUrl user: name password: secret.	root := mc locationWithTrailingSlash	 ! !!InstallerMonticello methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:42'!label	^ 'repository:''', mc description, ''''! !!InstallerMonticello methodsFor: 'accessing' stamp: 'kph 12/2/2008 07:42'!latest 	| newPackage |	newPackage := self package copyUpToLast: $-.	self packages removeLast.	self package: newPackage	"Installer mc fromUrl: 'http://www.squeaksource.com/Installer/Installer-Core-kph.100.mcz'."! !!InstallerMonticello methodsFor: 'accessing' stamp: 'kph 12/2/2008 07:40'!latestFromUsers: list	| newPackage |	newPackage := self package copyUpToLast: $-.	self packages removeLast.	self package: (list collect: [ :ea | newPackage, '-', ea ])! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 5/10/2007 00:58'!magma: host port: aport		mc := (self classMCMagmaRepository new) host: host port: aport; yourself ! !!InstallerMonticello methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!mc	^ mc! !!InstallerMonticello methodsFor: 'accessing' stamp: 'kph 12/8/2008 03:24'!mc: aRepo	mc := aRepo! !!InstallerMonticello methodsFor: 'monticello' stamp: 'kph 5/24/2007 19:49'!mcDetectFileBlock	self package isString ifTrue: [  ^ [ :aFile | aFile beginsWith: self package ] ].	(self package isKindOf: Array) 			ifTrue: [  ^  [ :aFile | (self package detect: [ :item | aFile beginsWith: item ] ifNone: [ false ]) ~= false ] ].	self package isBlock ifTrue: [ ^ self package ].   ! !!InstallerMonticello methodsFor: 'monticello' stamp: 'stephane.ducasse 9/30/2008 18:39'!mcSortFileBlock	^ [:a :b |         	[(a findBetweenSubStrs: #($.)) allButLast last asInteger > (b findBetweenSubStrs: #($.)) allButLast last asInteger] 				on: Error do: [:ex | false]].! !!InstallerMonticello methodsFor: 'monticello' stamp: 'kph 12/8/2008 03:36'!mcThing	| loader files fileToLoad  version  count |	loader := self classMCVersionLoader new.		1 to: self packages size do: [ :n |		self logCR: 'finding ', self package asString, '...'.		"several attempts to read files - repository readableFileNames sometimes fails"		count := 0. fileToLoad := nil.			[count := count + 1.		 (fileToLoad = nil) and:[ count < 5 ] ] 			whileTrue: [							files := mc readableFileNames asSortedCollection: self mcSortFileBlock.							fileToLoad := files detect: self mcDetectFileBlock ifNone: [ nil ].		].		fileToLoad ifNil: [ Warning signal: 'Package: ', self package ,' not found in repository: ', mc description. ^ nil ].		version := mc versionFromFileNamed: fileToLoad.		(version isKindOf: MCConfiguration) 			ifTrue: [ ^ version ]			ifFalse:[				MCRepositoryGroup default addRepository: self normalizedRepository.				version workingCopy repositoryGroup addRepository: self normalizedRepository.				loader addVersion: version].		self log: ' found ', version fileName, '...'.		packages removeFirst.	].	^ loader! !!InstallerMonticello methodsFor: 'monticello' stamp: 'test 1/15/2009 15:10'!mcUrl	^ self mc description 	! !!InstallerMonticello methodsFor: 'monticello' stamp: 'mtf 10/25/2008 14:04'!normalizedRepository"Find an existing instance of the active repository so that we use whatever name and password the user usually uses. If not found, answer a copy"	self classMCRepositoryGroup default repositoriesDo: [:ea |		mc = ea ifTrue: [^ ea]].	^ mc copy! !!InstallerMonticello methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!open	self mc morphicOpen: nil! !!InstallerMonticello methodsFor: 'searching' stamp: 'mtf 10/8/2008 12:00'!packagesMatching: aMatch	^ (self availablePackages		select: [:p | ( aMatch , '.mcz' ) match: p])		collect: [:p | self copy package: p ; yourself]! !!InstallerMonticello methodsFor: 'Installer-Core' stamp: 'kph 2/21/2009 18:41'!printConfigurationOn: stream	self project ifNil: [ ^ self ].		stream 		nextPutAll: ' project:''';		nextPutAll: self project;		nextPut: $'! !!InstallerMonticello methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:04'!project	^ project! !!InstallerMonticello methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:04'!project: name	project := name.	packages := nil.		(mc respondsTo: #location:) ifTrue:[ mc := mc copy location: root , name ].	(mc respondsTo: #directory:) ifTrue: [ mc := mc copy directory: root ,'/', name ].			^self copy.! !!InstallerMonticello methodsFor: 'public interface' stamp: 'kph 12/8/2008 01:02'!unload 	(MCWorkingCopy allManagers select: [ :wc | self package match: (wc package name) ])		 do: [ :wc |  			 	self logCR: 'Unloading ', wc package asString. 				wc unload.].	self unloadCleanUp! !!InstallerMonticello methodsFor: 'public interface' stamp: 'kph 12/8/2008 01:02'!unload: match 	self addPackage: match.	self unload.! !!InstallerMonticello methodsFor: 'public interface' stamp: 'kph 10/23/2008 20:57'!unloadCleanUp 	SystemOrganization removeEmptyCategories.	"Until Mantis 5718 is addressed" 	Smalltalk at: #PackagePaneBrowser ifPresent: [ :ppbClass | ppbClass allInstancesDo: [ :ppb | ppb updatePackages ]  ]. 	Smalltalk at: #Browser ifPresent: [ :bClass | bClass allInstancesDo: [ :b | b updateSystemCategories ] ].	MCFileBasedRepository freeSomeSpace.	SmalltalkImage current fixObsoleteReferences.! !Installer subclass: #InstallerSake	instanceVariableNames: 'sake'	classVariableNames: 'Sake'	poolDictionaries: ''	category: 'Installer-Core'!!InstallerSake class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classPackages	^Smalltalk at: #Packages  ifAbsent: [ self error: 'Sake Packages code not present' ]! !!InstallerSake class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:42'!label	^ 'sake'! !!InstallerSake class methodsFor: 'accessing' stamp: 'kph 6/30/2008 16:49'!sake	^ Sake ifNil: [ self classPackages current ]! !!InstallerSake class methodsFor: 'accessing' stamp: 'mtf 10/8/2008 12:00'!sake: aClass	Sake := aClass! !!InstallerSake methodsFor: 'basic interface' stamp: 'kph 4/23/2008 22:44'!basicInstall 	self withAnswersDo: [ (self packages collect: [ :packageName | sake named: packageName ]) asTask run ].	! !!InstallerSake methodsFor: 'websqueakmap' stamp: 'kph 1/28/2008 11:27'!sake 	^ sake  ! !!InstallerSake methodsFor: 'websqueakmap' stamp: 'kph 1/28/2008 10:41'!sake: aSakePackagesClass	sake := aSakePackagesClass! !Installer subclass: #InstallerSqueakMap	instanceVariableNames: 'sm'	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerSqueakMap class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:42'!label	^ 'squeakmap'! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:43'!basicAvailablePackages		^self classSMSqueakMap default packagesByName! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'kph 5/10/2007 00:29'!basicBrowse	self smThing explore! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:42'!basicInstall 	self log: ' installing '. 	self withAnswersDo: [ self smThing install ].	self log: ' done'.! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:43'!basicVersions 	^ (self smReleasesForPackage: self package) 			collect: [ :v | self copy package: (v package name,'(',v version,')'); yourself. ]  ! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'kph 5/10/2007 00:25'!basicView	self smThing explore! !!InstallerSqueakMap methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classSMLoader	^Smalltalk at: #SMLoader  ifAbsent: [ self error: 'SqueakMap Loader not present' ]! !!InstallerSqueakMap methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classSMSqueakMap	^Smalltalk at: #SMSqueakMap  ifAbsent: [ self error: 'SqueakMap not present' ]! !!InstallerSqueakMap methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!open	self classSMLoader open! !!InstallerSqueakMap methodsFor: 'searching' stamp: 'mtf 10/8/2008 12:00'!packagesMatching: aMatch	^ (self availablePackages		select: [ :p | aMatch match: p name ]) 		collect: [ :p | self copy package: p name; yourself ]! !!InstallerSqueakMap methodsFor: 'searching' stamp: 'damiencassou 2/20/2009 19:30'!search: aMatch  	| results |	results := Set new.	self availablePackages do: [ :pkg |		({ 'name:',pkg name.		   'summary:', pkg summary.		   'description:', pkg description.		   'author:', pkg author. } anySatisfy: [ :field | aMatch match: field ])		 ifTrue: [ results add: (self copy package: pkg name) ]. 	].	^results! !!InstallerSqueakMap methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:05'!sm	^ sm ifNil: [ false ]! !!InstallerSqueakMap methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:05'!sm: anObject	sm := anObject! !!InstallerSqueakMap methodsFor: 'squeakmap' stamp: 'kph 4/24/2008 23:03'!smPackageAndVersion	| p |	p := ReadStream on: self package .	^Array with: (p upTo: $() with: (p upTo: $)).! !!InstallerSqueakMap methodsFor: 'squeakmap' stamp: 'sd 3/6/2008 20:43'!smReleasesForPackage: name 	^(self classSMSqueakMap default packageWithName: name) releases! !!InstallerSqueakMap methodsFor: 'squeakmap' stamp: 'sd 3/6/2008 20:43'!smThing 	| pkgAndVersion releases release |	pkgAndVersion := self packageAndVersionFrom: self package.	self logCR: 'retrieving ', self package, ' from SqueakMap...'.	releases := self smReleasesForPackage: pkgAndVersion first.	release := pkgAndVersion last isEmpty 				ifTrue: [ releases last ]				ifFalse:[ releases detect: [ :rel | rel version = pkgAndVersion last ] ]. 	^ release			! !!InstallerSqueakMap methodsFor: 'squeakmap' stamp: 'stephane.ducasse 9/30/2008 18:41'!update"Updates the local map for SqueakMap, upgrading SqueakMap to the latest version if necessary.When SqueakMap is old and needs to be upgraded, it does four things that mostly make sense in the interactive world SM was built for, but are totally evil here in the world of automatic scripting:1. It asks the user if she wants to upgrade, in the form of a pop-up (see SMSqueakMap >> #checkVersion:).2. It terminates its own process.3. It creates a new UI process.(see the last line of the SqueakMap upgrade file-in: ''Project spawnNewProcessAndTerminateOld: true'', from http://map.squeak.org/accountbyid/9bdedc18-1525-44a6-9b79-db5d4a87f6f8/files/SqueakMap8.st4. It opens a SqueakMap windowWe work around these three problems seperately:1. We use #answer:with: and #withAnswersDo: to automatically answer ''Yes'' when asked if we want to upgrade2. We don't want this process to be terminated, so we run the update in a forked process and wait for it to finish, using #fork, #ensure:, and a Semaphore3. We keep track of the UI process before updating, and if it changes, we terminate the new UI process and reinstall the old one using Project >> #resumeProcess:4. We don't bother with the newly opened window. The other three problems are much worse.We do all this in a new process, since it is not unlikely that this method is executing in the UI process"	| oldUIProcess newUIProcess doneSema |	self answer: 'You need to upgrade the SqueakMap package' with: true.	oldUIProcess := Project uiProcess.	doneSema := Semaphore new.	[[self withAnswersDo: [self classSMSqueakMap default loadUpdates]] 		ensure: [newUIProcess := Project uiProcess.		(oldUIProcess ~~ newUIProcess				and: [oldUIProcess notNil]					and: [oldUIProcess isTerminated not])					 ifTrue: [							newUIProcess ifNotNil: [newUIProcess terminate].							oldUIProcess suspend.							Project resumeProcess: oldUIProcess.].	doneSema signal]] fork.	doneSema wait! !Installer subclass: #InstallerUniverse	instanceVariableNames: 'universe'	classVariableNames: 'LastUniUpdate'	poolDictionaries: ''	category: 'Installer-Core'!!InstallerUniverse class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classUGlobalInstaller	^Smalltalk at: #UGlobalInstaller  ifAbsent: [ self error: 'Universes code not present' ]! !!InstallerUniverse class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classUUniverse	^Smalltalk at: #UUniverse  ifAbsent: [ self error: 'Universes code not present' ]! !!InstallerUniverse class methodsFor: 'instance creation' stamp: 'mtf 10/14/2008 10:09'!default	^ self universe: (self classUGlobalInstaller universe: self classUUniverse systemUniverse)! !!InstallerUniverse class methodsFor: 'as yet unclassified' stamp: 'damiencassou 2/20/2009 19:42'!label	^ 'universe'! !!InstallerUniverse class methodsFor: 'instance creation' stamp: 'mtf 10/14/2008 10:10'!universe: u	^ self new universe: u! !!InstallerUniverse methodsFor: 'basic interface' stamp: 'sd 3/6/2008 19:05'!basicInstall	| pkgAndVersion pkg version potentials |	self packages do: [ :packageName |			pkgAndVersion := self packageAndVersionFrom: packageName.		pkg := pkgAndVersion first.		version := pkgAndVersion last.			potentials := universe packageVersionsForPackage: pkg.			pkg := version isEmpty 			ifTrue: [ potentials last ]			ifFalse: [ 				version := self classUVersion readFrom: version readStream.  				potentials detect:[ :p | p version = version] ifNone: [ ^ self error: 'version not found']			].			universe planToInstallPackage: pkg.	].	self uniDoInstall! !!InstallerUniverse methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classUVersion	^Smalltalk at: #UVersion  ifAbsent: [ self error: 'Universes code not present' ]! !!InstallerUniverse methodsFor: 'universes' stamp: 'kph 7/25/2007 13:46'!uniDoInstall	self withAnswersDo: [ self universe doInstall ] ! !!InstallerUniverse methodsFor: 'universes' stamp: 'kph 7/25/2007 12:52'!universe	^ universe! !!InstallerUniverse methodsFor: 'universes' stamp: 'squeak 7/26/2007 18:12'!universe: u	universe := u.	self update.! !!InstallerUniverse methodsFor: 'public interface' stamp: 'stephane.ducasse 9/30/2008 18:41'!update	(LastUniUpdate isNil or:[ (DateAndTime now - LastUniUpdate) > 600 seconds  ])		ifTrue: [universe requestPackageList.				LastUniUpdate := DateAndTime now]! !Installer subclass: #InstallerUpdateStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Core'!!InstallerUpdateStream class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:43'!label	^ 'updatestream'! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/6/2008 20:40'!changesetNamesFromUpdates: startNumber through: stopNumber	"Answer the concatenation of summary strings for updates numbered in the given range"	"self new changesetNamesFromUpdates: 7059 through: 7061"		^ String streamContents: [:aStream |		((ChangeSet changeSetsNamedSuchThat:			[:aName | aName first isDigit and:						[aName initialIntegerOrNil >= startNumber] and:						[aName initialIntegerOrNil <= stopNumber]]) asSortedCollection:				[:a :b | a name < b name]) do:					[:aChangeSet | aStream cr; nextPutAll: aChangeSet summaryString]]! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/8/2008 21:15'!loadUpdatesFromDisk		| updateDirectory updateNumbers |	updateDirectory := self updateDirectoryOrNil.	updateDirectory ifNil: [^ self].	updateNumbers := updateDirectory fileNames						collect: [:fn | fn initialIntegerOrNil]						thenSelect: [:fn | fn notNil].		self loadUpdatesFromDiskToUpdateNumber: updateNumbers max		stopIfGap: false			! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/9/2008 11:30'!loadUpdatesFromDiskToUpdateNumber: lastUpdateNumber stopIfGap: stopIfGapFlag 	"To use this mechanism, be sure all updates you want to have considered 	are in a folder named 'updates' which resides in the same directory as  	your image. Having done that, simply evaluate:  	 	Installer new loadUpdatesFromDiskToUpdateNumber: 100020 stopIfGap: false  	 	and all numbered updates <= lastUpdateNumber not yet in the image will 	be loaded in numerical order."		"apparently does not use the updatelist too bad!! and to rewrite - sd 7 March 2008"	| previousHighest currentUpdateNumber done fileNames aMessage updateDirectory loaded |	updateDirectory := self updateDirectoryOrNil.	updateDirectory ifNil: [^ self].	previousHighest := SystemVersion current highestUpdate.	currentUpdateNumber := previousHighest.	done := false.	loaded := 0.	[done]		whileFalse: [currentUpdateNumber := currentUpdateNumber + 1.			currentUpdateNumber > lastUpdateNumber				ifTrue: [done := true]				ifFalse: [fileNames := updateDirectory fileNamesMatching: currentUpdateNumber printString , '*'.					fileNames size > 1						ifTrue: [^ self inform: 'ambiguity -- two files both start with ' , currentUpdateNumber printString , '(at this point it is probably best to remedythe situation on disk, then try again.)'].					fileNames size == 0						ifTrue: [Transcript cr; show: 'gap in updates from disk for update number '; print: currentUpdateNumber; show: ' found...'.							done := stopIfGapFlag]						ifFalse: [ChangeSet								newChangesFromStream: (updateDirectory readOnlyFileNamed: fileNames first)								named: fileNames first.							SystemVersion current registerUpdate: currentUpdateNumber.							loaded := loaded + 1]]].	aMessage := loaded = 0				ifTrue: ['No new updates found.']				ifFalse: [loaded printString , ' update(s) loaded.'].	self inform: aMessage , 'Highest numbered update is now ' , (currentUpdateNumber - 1) printString , '.'! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/3/2008 10:37'!parseUpdateListContents: listContentString	"Parse the contents of an updates.list into {{releaseTag. {fileNames*}}*}, and return it."	| sections releaseTag strm line fileNames |	sections := OrderedCollection new.	fileNames := OrderedCollection new: 1000.	releaseTag := nil.	strm := ReadStream on: listContentString.	[strm atEnd] whileFalse:		[line := strm upTo: Character cr.		line size > 0 ifTrue:			[line first = $#				ifTrue: [releaseTag ifNotNil: [sections addLast: {releaseTag. fileNames asArray}].						releaseTag := line allButFirst.						fileNames resetTo: 1]				ifFalse: [line first = $* ifFalse: [fileNames addLast: line]]]].	releaseTag ifNotNil: [sections addLast: {releaseTag. fileNames asArray}].	^ sections asArray! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/8/2008 21:13'!updateDirectoryOrNil	^ (FileDirectory default directoryNames includes: 'updates')		ifTrue: [FileDirectory default directoryNamed: 'updates']		ifFalse: [self inform: 'Error: cannot find "updates" folder'.				nil]! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/3/2008 10:52'!writeList: listContents toStream: strm	"Write a parsed updates.list out as text.	This is the inverse of parseUpdateListContents:"	| fileNames releaseTag |	strm reset.	listContents do:		[:pair | 		releaseTag := pair first.  		fileNames := pair last.		strm nextPut: $#; nextPutAll: releaseTag; cr.		fileNames do: [:fileName | strm nextPutAll: fileName; cr]].	strm close! !InstallerMantis initialize!InstallerWeb initialize!----End fileIn of a ReadStream 'SystemOrganization addCategory: #''Installer-Core''!!Object subclass: #Installer	instanceVariableNames: ''answers packages messagesToSuppress isBootstrap''	classVariableNames: ''IsSetToTrapErrors Remembered SkipLoadingTests InstallerBindings ValidationBlock''	poolDictionaries: ''''	category: ''Installer-Core''!!!!Installer commentStamp: ''kph 2/24/2009 06:32'' prior: 0!!Documentation now available at http://installer.pbwiki.com/Installer isBootstrap - flag to load source.st rather than using Monticello!!!!Installer class methodsFor: ''action report'' stamp: ''mtf 10/8/2008 12:00''!!actionMatch: theLine reportOn: report ifNoMatch: aBlock	| line |		line := theLine withBlanksCondensed.	self allSubclassesDo: [:class |		(class canReportLine: line)		ifTrue: [ ^ class new action: theLine reportOn: report ]].	^ aBlock value!! !!!!Installer class methodsFor: ''action report'' stamp: ''kph 2/24/2009 07:54''!!bootstrapTheRestOfInstaller	(Installer url: ''www.squeaksource.com/Installer/Installer-Scripts'')  			bootstrap;			logCR: ''installer bootstrap - loaded''.!! !!!!Installer class methodsFor: ''mantis'' stamp: ''kph 2/15/2009 05:21''!!bug: n fix: filename	Transcript cr; show: ''Code script in Mantis:'', n asString, '' should read Installer mantis bug: '',n asString, '' fix: '', filename printString,''.''.		^ self mantis bug: n fix: filename!! !!!!Installer class methodsFor: ''monticello'' stamp: ''mtf 5/20/2008 22:10''!!cache	^ self monticello cache!! !!!!Installer class methodsFor: ''action report'' stamp: ''mtf 10/8/2008 12:00''!!canReportLine: line	^ false!! !!!!Installer class methodsFor: ''accessing'' stamp: ''stephane.ducasse 9/30/2008 18:20''!!cancelSkipLoadingTests	"sets a flag to un-ignore loading of the testing portion of scripts embedded in pages"		SkipLoadingTests := false. !! !!!!Installer class methodsFor: ''debug'' stamp: ''kph 5/9/2007 23:05''!!debug	IsSetToTrapErrors := false!! !!!!Installer class methodsFor: ''launcher support'' stamp: ''kph 2/23/2009 01:55''!!do: webPageName	| rs |	rs := webPageName readStream.	[ rs atEnd ] whileFalse: [ self install: (rs upTo: $;) ].!! !!!!Installer class methodsFor: ''custom names'' stamp: ''kph 5/28/2007 05:11''!!doesNotUnderstand: aMessage	^ self remembered at: aMessage selector ifAbsent: [ super doesNotUnderstand: aMessage ]!! !!!!Installer class methodsFor: ''file'' stamp: ''mtf 10/23/2008 15:49''!!file	^ InstallerFile new!! !!!!Installer class methodsFor: ''file'' stamp: ''mtf 10/23/2008 16:08''!!file: fileName 	^ InstallerFile new file: fileName; yourself!! !!!!Installer class methodsFor: ''url'' stamp: ''kph 2/11/2009 20:12''!!fromUrl: aUrl	"try and pick an Installer appropriate for the Url"		| mci |		mci := Installer mc fromUrl: aUrl.		mci packages ifEmpty: [ ^ Installer url: aUrl ].		^ mci!! !!!!Installer class methodsFor: ''repositories'' stamp: ''kph 6/2/2008 20:21''!!goran	^ self monticello http: ''squeak.krampe.se''; project: ''''!! !!!!Installer class methodsFor: ''repositories'' stamp: ''kph 5/10/2007 01:29''!!impara	^ self monticello http: ''source.impara.de''!! !!!!Installer class methodsFor: ''action report'' stamp: ''kph 2/23/2009 05:27''!!install: scriptName	^ (self scripts install: scriptName) ifNil:[ self web install: scriptName ]!! !!!!Installer class methodsFor: ''file'' stamp: ''mtf 10/23/2008 16:08''!!installFile: fileName 	^ (self file: fileName) install.!! !!!!Installer class methodsFor: ''url'' stamp: ''stephane.ducasse 9/30/2008 18:24''!!installSilentlyUrl: urlString	^ SystemChangeNotifier uniqueInstance doSilently: [ self url url: urlString; install ].!! !!!!Installer class methodsFor: ''url'' stamp: ''stephane.ducasse 9/30/2008 18:24''!!installUrl: urlString	^ self url url: urlString; install.!! !!!!Installer class methodsFor: ''repositories'' stamp: ''kph 12/18/2008 02:06''!!keith 	^ self monticello ftp: ''squeak.warwick.st'' directory: ''mc'' user: ''squeak'' password: ''viewpoints''!! !!!!Installer class methodsFor: ''accessing'' stamp: ''damiencassou 2/20/2009 20:29''!!label	^ ''''!! !!!!Installer class methodsFor: ''launcher support'' stamp: ''kph 2/27/2007 18:57''!!launchFrom: launcher	^self launchWith: launcher getParameters!! !!!!Installer class methodsFor: ''launcher support'' stamp: ''kph 5/24/2007 19:59''!!launchHelp^''path=/dir/*.txt          Specify a search path for the item to installp=/dir1/*.txt;<url2>/    Multiple items delimited by ;                         The page name is typically appended to the path string, or                         if a "*" is present, it will be replaced by the page name.					in,i,install=<page>      Page appended to the path to begin the install processurl,u=<url>              Install using an explicit url from which to obtain a script or filefile=<url>                Install using a local file+debug                   Do not trap errorsview=<page>              Print the script that would have been installed.For more options use Script eval="Installer ... " ''!! !!!!Installer class methodsFor: ''launcher support'' stamp: ''kph 1/11/2008 07:58''!!launchWith: params 	params at: ''P'' ifPresent: [ :v | params at: ''PATH'' put: v ]. 	params at: ''I'' ifPresent: [ :v | params at: ''INSTALL'' put: v ]. 	params at: ''IN'' ifPresent: [ :v | params at: ''INSTALL'' put: v ]. 	params at: ''U'' ifPresent: [ :v | params at: ''URL'' put: v ].	params at: ''PATH'' ifPresent: [ :v | 		self webSearchPathFrom: v.	].	params at: ''USER'' ifPresent: [ :v | 		Utilities setAuthorInitials: v	].	params at: ''VERSION'' ifPresent: [ :v | 		SystemVersion current version: v	].	params at: ''VIEW'' ifPresent: [ :v |		self view: v	].	IsSetToTrapErrors := true.	params at: ''DEBUG'' ifPresent: [ :v | IsSetToTrapErrors := (v == true) not ]. 	params at: ''URL'' ifPresent: [ :v | 		 self installUrl: v	].	params at: ''FILE'' ifPresent: [ :v | 		 self installFile: v	].  	params at: ''INSTALL'' ifPresent: [ :v | 		  self do: v	].	params at: ''DO'' ifPresent: [ :v | 		  self do: v	]. 	 ^true	!! !!!!Installer class methodsFor: ''logging'' stamp: ''kph 2/24/2009 07:29''!!log: aString	Transcript show: aString; cr.!! !!!!Installer class methodsFor: ''repositories'' stamp: ''kph 4/24/2008 16:56''!!lukas	^ self monticello http: ''source.lukas-renggli.ch''!! !!!!Installer class methodsFor: ''mantis'' stamp: ''kph 3/14/2007 21:07''!!mantis	^ self mantis: ''http://bugs.squeak.org/''!! !!!!Installer class methodsFor: ''mantis'' stamp: ''mtf 10/8/2008 12:00''!!mantis: host	^ InstallerMantis host: host!! !!!!Installer class methodsFor: ''monticello'' stamp: ''kph 5/10/2007 00:49''!!mc	^ self monticello!! !!!!Installer class methodsFor: ''monticello'' stamp: ''kph 5/10/2007 00:49''!!monticello	^ InstallerMonticello new!! !!!!Installer class methodsFor: ''debug'' stamp: ''kph 5/9/2007 23:05''!!noDebug	IsSetToTrapErrors := true!! !!!!Installer class methodsFor: ''during'' stamp: ''kph 5/21/2008 09:05''!!noProgressDuring: block 	[ block value: self ] on: ProgressInitiationException do: [ :note | note resume ]!! !!!!Installer class methodsFor: ''web'' stamp: ''stephane.ducasse 9/30/2008 18:24''!!path: aString	"convenience abbreviation"		self webSearchPathFrom: aString!! !!!!Installer class methodsFor: ''custom names'' stamp: ''kph 5/28/2007 00:54''!!remembered	^	Remembered ifNil: [ Remembered := IdentityDictionary new ]!! !!!!Installer class methodsFor: ''instanciation'' stamp: ''kph 12/1/2008 20:12''!!repositories	^ self class organization listAtCategoryNamed: ''repositories''.!! !!!!Installer class methodsFor: ''monticello'' stamp: ''stephane.ducasse 9/30/2008 18:24''!!repository: host  	^self monticello http: host !! !!!!Installer class methodsFor: ''sake'' stamp: ''mtf 10/8/2008 12:00''!!sake	^ self sake: InstallerSake sake!! !!!!Installer class methodsFor: ''sake'' stamp: ''kph 1/28/2008 10:42''!!sake: aSakePackagesClass	^ InstallerSake new sake: aSakePackagesClass!! !!!!Installer class methodsFor: ''repositories'' stamp: ''kph 8/18/2008 03:15''!!saltypickle	^ self monticello http: ''squeak.saltypickle.com''!! !!!!Installer class methodsFor: ''internal scripts'' stamp: ''kph 2/23/2009 02:03''!!scripts	^ InstallerScripts new!! !!!!Installer class methodsFor: ''sake'' stamp: ''mtf 10/8/2008 12:00''!!setSakeToUse: aClass	InstallerSake sake: aClass!! !!!!Installer class methodsFor: ''documentation'' stamp: ''kph 5/10/2007 01:21''!!sf	^ self squeakfoundation !! !!!!Installer class methodsFor: ''accessing'' stamp: ''stephane.ducasse 9/30/2008 18:21''!!skipLoadingTests	"sets a flag to ignore loading of the testing portion of scripts embedded in pages"		SkipLoadingTests := true. !! !!!!Installer class methodsFor: ''during'' stamp: ''kph 5/21/2008 08:53''!!skipLoadingTestsDuring: block	| oldValue |	oldValue := SkipLoadingTests.	SkipLoadingTests := true.		[ block value: self ] ensure:[ SkipLoadingTests := oldValue ].!! !!!!Installer class methodsFor: ''squeakmap'' stamp: ''kph 5/10/2007 01:19''!!sm	^ self squeakmap!! !!!!Installer class methodsFor: ''repositories'' stamp: ''kph 12/15/2007 11:08''!!sophie	^ self monticello http: ''source.sophieproject.org''	!! !!!!Installer class methodsFor: ''repositories'' stamp: ''kph 5/10/2007 01:21''!!squeakfoundation	^ self monticello http: ''source.squeakfoundation.org''!! !!!!Installer class methodsFor: ''squeakmap'' stamp: ''stephane.ducasse 9/30/2008 18:26''!!squeakmap	^ InstallerSqueakMap new sm: true; yourself!! !!!!Installer class methodsFor: ''repositories'' stamp: ''kph 5/10/2007 01:19''!!squeaksource	^ self monticello http: ''www.squeaksource.com''!! !!!!Installer class methodsFor: ''repositories'' stamp: ''kph 5/10/2007 01:19''!!ss	^ self squeaksource !! !!!!Installer class methodsFor: ''universe'' stamp: ''mtf 10/14/2008 10:10''!!universe	^ InstallerUniverse default!! !!!!Installer class methodsFor: ''instanciation'' stamp: ''kph 2/23/2009 05:29''!!upgrade	Installer ss project: ''Installer''; 		installQuietly: ''Installer-Core'';		installQuietly: ''Installer-Scripts''.			^ self!! !!!!Installer class methodsFor: ''url'' stamp: ''kph 12/9/2008 03:10''!!url	^ InstallerUrl new url: ''''!! !!!!Installer class methodsFor: ''url'' stamp: ''stephane.ducasse 9/30/2008 18:26''!!url: urlString	^self url url: urlString; yourself!! !!!!Installer class methodsFor: ''accessing'' stamp: ''stephane.ducasse 9/30/2008 18:28''!!validationBlock	^ ValidationBlock!! !!!!Installer class methodsFor: ''accessing'' stamp: ''kph 5/25/2007 01:34''!!validationBlock: aBlock	ValidationBlock := aBlock!! !!!!Installer class methodsFor: ''instanciation'' stamp: ''stephane.ducasse 9/30/2008 18:26''!!view: webPageNameOrUrl	| theReport |	theReport := String streamContents: [ :report | 	(webPageNameOrUrl beginsWith: ''http://'') ifTrue: [ 		self actionMatch: (''Installer installUrl: '', (webPageNameOrUrl printString),''.'')  				reportOn: report ifNoMatch: []	]	ifFalse: [		self actionMatch: (''Installer install: '', (webPageNameOrUrl printString),''.'')  				reportOn: report ifNoMatch: []	]].	Workspace new contents: (theReport contents); openLabel: webPageNameOrUrl.	^theReport contents!! !!!!Installer class methodsFor: ''web'' stamp: ''stephane.ducasse 9/30/2008 18:26''!!web 	^ InstallerWeb!! !!!!Installer class methodsFor: ''web'' stamp: ''kph 2/23/2009 01:56''!!webInstall: webPageName	^ self web install: webPageName!! !!!!Installer class methodsFor: ''web'' stamp: ''stephane.ducasse 9/30/2008 18:22''!!webSearchPath	"a search path item, has the following format. prefix*suffix"	^ self web searchPath!! !!!!Installer class methodsFor: ''web'' stamp: ''stephane.ducasse 9/30/2008 18:22''!!webSearchPathFrom: string	| reader wsp path |	reader := string readStream.	wsp := self webSearchPath.	[ reader atEnd ] whileFalse: [ 		path := reader upTo: $;.		(wsp includes: wsp) ifFalse: [ wsp addFirst: path ]].	 !! !!!!Installer class methodsFor: ''websqueakmap'' stamp: ''stephane.ducasse 9/30/2008 18:28''!!websqueakmap	^ InstallerWebSqueakMap new wsm: ''http://map.squeak.org''; yourself!! !!!!Installer class methodsFor: ''websqueakmap'' stamp: ''stephane.ducasse 9/30/2008 18:28''!!websqueakmap: host	^ InstallerWebSqueakMap new wsm: host; yourself!! !!!!Installer class methodsFor: ''repositories'' stamp: ''kph 5/10/2007 01:30''!!wiresong	^ self monticello http: ''source.wiresong.ca''!! !!!!Installer class methodsFor: ''websqueakmap'' stamp: ''kph 5/10/2007 01:19''!!wsm	^ self websqueakmap!! !!!!Installer methodsFor: ''public interface'' stamp: ''sd 3/6/2008 18:45''!!addPackage: anObject	self packages add: anObject!! !!!!Installer methodsFor: ''auto answering'' stamp: ''sd 3/6/2008 18:46''!!answer: aString with: anAnswer	^self answers add: ( Array with: aString with: anAnswer )!! !!!!Installer methodsFor: ''accessing'' stamp: ''sd 3/6/2008 18:46''!!answers	^ answers ifNil: [ answers := OrderedCollection new ]!! !!!!Installer methodsFor: ''accessing'' stamp: ''sd 3/6/2008 18:46''!!answers: anObject	answers := anObject!! !!!!Installer methodsFor: ''public interface'' stamp: ''mtf 10/8/2008 12:00''!!availablePackages		^ self basicAvailablePackages!! !!!!Installer methodsFor: ''basic interface'' stamp: ''mtf 10/8/2008 12:00''!!basicAvailablePackages!! !!!!Installer methodsFor: ''basic interface'' stamp: ''mtf 10/8/2008 12:00''!!basicBrowse!! !!!!Installer methodsFor: ''basic interface'' stamp: ''mtf 10/8/2008 12:00''!!basicInstall!! !!!!Installer methodsFor: ''basic interface'' stamp: ''mtf 10/8/2008 12:00''!!basicVersions!! !!!!Installer methodsFor: ''basic interface'' stamp: ''mtf 10/8/2008 12:00''!!basicView!! !!!!Installer methodsFor: ''script bindings'' stamp: ''kph 5/8/2007 19:52''!!bindingOf: aString 		InstallerBindings isNil ifTrue: [ InstallerBindings := Dictionary new].	(InstallerBindings includesKey: aString)		ifFalse: [InstallerBindings at: aString put: nil].	^ InstallerBindings associationAt: aString.!! !!!!Installer methodsFor: ''public interface'' stamp: ''kph 2/24/2009 06:32''!!bootstrap	isBootstrap := true.	self install.!! !!!!Installer methodsFor: ''public interface'' stamp: ''mtf 10/8/2008 12:00''!!browse	self logErrorDuring: [self basicBrowse]!! !!!!Installer methodsFor: ''public interface'' stamp: ''sd 3/6/2008 18:45''!!browse: packageNameCollectionOrDetectBlock	self package: packageNameCollectionOrDetectBlock.	self browse!! !!!!Installer methodsFor: ''mantis'' stamp: ''kph 12/19/2007 12:03''!!browse: aFileName from: stream		| mcThing ext browseSelector |		 	self log: '' browsing...''. 		mcThing := self classMCReader ifNotNil: [ self mcThing: aFileName from: stream ].				mcThing 			ifNotNil: [ (mcThing respondsTo: #snapshot) 						ifTrue: [ mcThing browse ]				        	ifFalse: [ (MCSnapshotBrowser forSnapshot: mcThing) showLabelled: ''Browsing '', aFileName ]			]			ifNil: [ 						ext := aFileName copyAfterLast: $..				browseSelector := (''browse'', ext asUppercase, '':from:'') asSymbol.					(self respondsTo: browseSelector)					ifTrue: [ self perform: browseSelector with: aFileName with: stream ]					ifFalse: [ self browseDefault: aFileName from: stream ].			]!! !!!!Installer methodsFor: ''mantis'' stamp: ''kph 12/19/2007 13:49''!!browseCS: aFileName from: stream 		| list |		list := self classChangeList new			scanFile: stream from: 1 to: stream size.		 	self classChangeList open: list name: aFileName		multiSelect: true.!! !!!!Installer methodsFor: ''mantis'' stamp: ''kph 12/19/2007 12:05''!!browseDefault: aFileName from: stream	self view: aFileName from: stream!! !!!!Installer methodsFor: ''mantis'' stamp: ''sd 3/6/2008 19:08''!!browseGZ: aFileName from: stream 	"FileIn the contents of a gzipped stream"	| zipped unzipped |	zipped := self classGZipReadStream on: stream.	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	ChangeList browseStream: unzipped	!! !!!!Installer methodsFor: ''utils'' stamp: ''kph 5/24/2007 19:16''!!changeSetNamed: aName	(ChangeSet respondsTo: #named:)		ifTrue: [ ^ChangeSet named: aName ].			^ ChangeSorter changeSetNamed: aName.!! !!!!Installer methodsFor: ''class references'' stamp: ''sd 3/6/2008 20:16''!!classChangeList	^Smalltalk at: #ChangeList  ifAbsent: [ self error: ''ChangeList not present'' ]!! !!!!Installer methodsFor: ''class references'' stamp: ''sd 3/6/2008 20:16''!!classChangeSet	^Smalltalk at: #ChangeSet  ifAbsent: [ self error: ''ChangeSet not present'' ]!! !!!!Installer methodsFor: ''class references'' stamp: ''sd 3/6/2008 20:16''!!classChangeSorter	^Smalltalk at: #ChangeSorter ifAbsent: [ self error: ''ChangeSorter not present'' ]!! !!!!Installer methodsFor: ''class references'' stamp: ''sd 3/6/2008 20:16''!!classGZipReadStream	^Smalltalk at: #GZipReadStream  ifAbsent: [ self error: ''Compression not present'' ]!! !!!!Installer methodsFor: ''class references'' stamp: ''sd 3/6/2008 20:16''!!classMCReader	^Smalltalk at: #MCReader ifAbsent: [ nil ]	!! !!!!Installer methodsFor: ''class references'' stamp: ''sd 3/6/2008 20:16''!!classMczInstaller	^Smalltalk at: #MczInstaller ifAbsent: [ nil ]	!! !!!!Installer methodsFor: ''class references'' stamp: ''sd 3/6/2008 20:17''!!classMultiByteBinaryOrTextStream	^Smalltalk at: #MultiByteBinaryOrTextStream  ifAbsent: [ self error: ''MultiByteBinaryOrTextStream not present'' ]!! !!!!Installer methodsFor: ''class references'' stamp: ''sd 3/6/2008 20:17''!!classSARInstaller	^Smalltalk at: #SARInstaller  ifAbsent: [ self error: ''SARInstaller not present'' ]!! !!!!Installer methodsFor: ''utils'' stamp: ''mtf 7/23/2008 12:00''!!ditchOldChangeSetFor: aFileName 	| changeSetName | 	changeSetName := (self validChangeSetName: aFileName) sansPeriodSuffix.	(self changeSetNamed: changeSetName)		ifNotNilDo: [:changeSet |				(self logCR:''Removing old change set '', changeSetName) cr.				self  removeChangeSet: changeSet ].!! !!!!Installer methodsFor: ''public interface'' stamp: ''kph 2/24/2009 08:01''!!initialize	isBootstrap := false.!! !!!!Installer methodsFor: ''public interface'' stamp: ''kph 2/24/2009 07:57''!!inizialize	isBootstrap := false.!! !!!!Installer methodsFor: ''public interface'' stamp: ''mtf 10/8/2008 12:00''!!install	self logErrorDuring: [self basicInstall]!! !!!!Installer methodsFor: ''public interface'' stamp: ''sd 3/6/2008 18:45''!!install: packageNameCollectionOrDetectBlock	self addPackage: packageNameCollectionOrDetectBlock.	self install!! !!!!Installer methodsFor: ''mantis'' stamp: ''kph 2/24/2009 08:09''!!install: aFileName from: stream| ext installSelector mcThing |	 	self log: '' installing...''. 	self withAnswersDo:	[				mcThing := self classMCReader ifNotNil: [ self mcThing: aFileName from: stream ].				mcThing 			ifNotNil: [ (mcThing respondsTo: #install) 						ifTrue: [ mcThing install ]				        	ifFalse: [ (mcThing respondsTo: #load) ifTrue: [ mcThing load ] ]			]			ifNil: [ 						ext := (aFileName copyAfterLast: $/) in: [ :path | path isEmpty ifTrue: [ aFileName ] ifFalse: [ path ] ].				ext :=  ext copyAfterLast: $..				ext = '''' ifTrue: [ ext := ''st'' ].				installSelector := (''install'', ext asUppercase, '':from:'') asSymbol.					isBootstrap ifTrue: [ 				[					SystemChangeNotifier uniqueInstance doSilently: [self install: aFileName from: stream using: installSelector ]] 						on: Warning do: [ :ex | ex resume: true ].				] ifFalse: [					self install: aFileName from: stream using: installSelector. 				]			]	]. 	self log: '' done.''!! !!!!Installer methodsFor: ''mantis'' stamp: ''kph 2/24/2009 08:07''!!install: aFileName from: stream using: installSelector		(self respondsTo: installSelector)			ifTrue: [ self perform: installSelector with: aFileName with: stream ]			ifFalse: [ self installDefault: aFileName from: stream ].!! !!!!Installer methodsFor: ''mantis'' stamp: ''kph 5/9/2007 18:14''!!installCS: aFileName from: stream 	self ditchOldChangeSetFor: aFileName.	self newChangeSetFromStream: stream named: (self validChangeSetName: aFileName).!! !!!!Installer methodsFor: ''mantis'' stamp: ''ar 2/14/2009 22:56''!!installDefault: aFileName from: stream	"Check for UTF-8 input before filing it in"	| pos bom |	pos := stream position.	bom := stream next: 3.	(bom size = 3		and:[(bom at: 1) asInteger = 16rEF]		and:[(bom at: 2) asInteger = 16rBB]		and:[(bom at: 3) asInteger = 16rBF]) 			ifTrue:[(RWBinaryOrTextStream on: stream upToEnd utf8ToSqueak) fileIn]			ifFalse:[stream position: pos; fileIn]!! !!!!Installer methodsFor: ''mantis'' stamp: ''kph 1/8/2007 06:42''!!installGZ: aFileName from: stream 	"FileIn the contents of a gzipped stream"	| zipped unzipped |	 	zipped := self classGZipReadStream on: stream.	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	self  newChangeSetFromStream: unzipped named:aFileName.	!! !!!!Installer methodsFor: ''mantis'' stamp: ''kph 2/24/2009 07:10''!!installMCZ: aFileName from: stream 	| source pkg wc |		pkg := aFileName copyUpToLast: $-.		wc := Smalltalk at: #MCWorkingCopy ifAbsent: [ nil ].wc ifNotNil: [ 	(wc allManagers select:  [:each | each packageName = pkg ]) do: [ :ea | ea unregister ] ].		self classMczInstaller ifNotNilDo: [ :reader | ^ reader install: aFileName stream: stream].  	source :=  ((ZipArchive new readFrom:stream) memberNamed: ''snapshot/source.st'') contents.	[		SystemChangeNotifier uniqueInstance doSilently: [ 			source  readStream fileInAnnouncing: ''Booting '' , aFileName. 		]	] on: Warning do: [ :ex | ex resume: true ].!! !!!!Installer methodsFor: ''mantis'' stamp: ''kph 2/24/2009 08:05''!!installMCZBasic: aFileName from: stream 	| source |	 	self classMczInstaller ifNotNilDo: [ :reader | ^ reader install: aFileName stream: stream].  	source :=  ((ZipArchive new readFrom:stream) memberNamed: ''snapshot/source.st'') contents.	[		SystemChangeNotifier uniqueInstance doSilently: [ 			source  readStream fileInAnnouncing: ''Booting '' , aFileName. 		]	] on: Warning do: [ :ex | ex resume: true ].!! !!!!Installer methodsFor: ''mantis'' stamp: ''kph 5/9/2007 18:07''!!installMCcs: aFileName from: stream 	| reader |		reader := MCCsReader on: stream.!! !!!!Installer methodsFor: ''public interface'' stamp: ''kph 5/16/2008 00:44''!!installQuietly   	[ self install ] on: Warning do: [ :ex | ex resume: true ].!! !!!!Installer methodsFor: ''public interface'' stamp: ''kph 5/16/2008 00:45''!!installQuietly: packageNameCollectionOrDetectBlock	self package: packageNameCollectionOrDetectBlock. 	self installQuietly.!! !!!!Installer methodsFor: ''mantis'' stamp: ''kph 5/25/2007 01:09''!!installSAR: aFileName from: stream  | newCS |	self classSARInstaller withCurrentChangeSetNamed: aFileName		do: [:cs | newCS := cs. self classSARInstaller new fileInFrom: stream].	newCS isEmpty ifTrue: [ self removeChangeSet: newCS ]!! !!!!Installer methodsFor: ''public interface'' stamp: ''kph 6/2/2008 12:17''!!installSilently	SystemChangeNotifier uniqueInstance doSilently: [ self install ]	!! !!!!Installer methodsFor: ''accessing'' stamp: ''sd 3/6/2008 18:47''!!isSkipLoadingTestsSet	^SkipLoadingTests ifNil: [ false ]!! !!!!Installer methodsFor: ''accessing'' stamp: ''damiencassou 2/20/2009 19:37''!!label	^ self class label!! !!!!Installer methodsFor: ''logging'' stamp: ''sd 3/6/2008 20:23''!!log: text	^Transcript show: text.!! !!!!Installer methodsFor: ''logging'' stamp: ''mtf 10/15/2008 08:08''!!logCR: text	self validate.	^ Transcript show: text; cr!! !!!!Installer methodsFor: ''logging'' stamp: ''kph 9/1/2008 21:39''!!logErrorDuring: block	(IsSetToTrapErrors = true) ifFalse: [ ^ block value ].	block on: Error 		do: [ :e |			self halt. 			self logCR: ''****'', e class name, '': '', (e messageText ifNil: [ '''']). 					(e isKindOf: MessageNotUnderstood) 				ifTrue: [ e pass ]				ifFalse: [ e isResumable ifTrue:[ e resume: true ]]]!! !!!!Installer methodsFor: ''searching'' stamp: ''kph 1/4/2007 23:59''!!match: aMatch	^self packagesMatching: aMatch!! !!!!Installer methodsFor: ''mantis'' stamp: ''kph 2/24/2009 06:36''!!mcThing: aFileName from: stream			"dont use monticello for .cs or for .st use monticello for .mcs"	| reader |		isBootstrap ifTrue: [ ^ nil ].		reader := self classMCReader readerClassForFileNamed: aFileName.	reader name = ''MCStReader'' ifTrue: [ ^ nil ].	reader ifNil: [ ^ nil ].	(reader respondsTo: #on:fileName:) 		ifTrue: [ reader := reader on: stream fileName: aFileName.					^ reader version  ]		ifFalse: [ reader := reader on: stream. 				    ^ reader snapshot  ].!! !!!!Installer methodsFor: ''accessing'' stamp: ''sd 3/6/2008 18:47''!!messagesToSuppress	^ messagesToSuppress ifNil: [ messagesToSuppress := OrderedCollection new ]!! !!!!Installer methodsFor: ''accessing'' stamp: ''sd 3/6/2008 18:48''!!messagesToSuppress: anObject	messagesToSuppress := anObject!! !!!!Installer methodsFor: ''mantis'' stamp: ''kb 12/18/2006 13:01''!!newChangeSetFromStream: aStream named: aName 	"This code is based upon ChangeSet-c-#newChangesFromStream:named: which is in 3.9,	implemented here for previous versions. The second branch is for 3.8, where ChangeSets	are loaded by ChangeSorter. "	| oldChanges newName newSet newStream |	(self classChangeSet respondsTo: #newChangesFromStream:named:) 		ifTrue: [ ^self classChangeSet newChangesFromStream: aStream named:aName ].	(self classChangeSorter respondsTo: #newChangesFromStream:named:)		ifTrue: [ ^self classChangeSorter newChangesFromStream: aStream named: aName ].	oldChanges := ChangeSet current. 	"so a Bumper update can find it"	newName := aName sansPeriodSuffix.	newSet := self classChangeSet basicNewNamed: newName.	[newSet		ifNotNil: [(aStream respondsTo: #converter:)				ifTrue: [newStream := aStream]				ifFalse: [newStream := self classMultiByteBinaryOrTextStream with: aStream contentsOfEntireFile.					newStream reset].			self classChangeSet newChanges: newSet.			newStream setConverterForCode.			newStream fileInAnnouncing: ''Loading '' , newName , ''...''.			Transcript cr; show: ''File '' , aName , '' successfully filed in to change set '' , newName].	aStream close]		ensure: [self classChangeSet newChanges: oldChanges].	 	^ newSet!! !!!!Installer methodsFor: ''public interface'' stamp: ''sd 3/6/2008 18:48''!!open!! !!!!Installer methodsFor: ''accessing'' stamp: ''sd 3/6/2008 18:48''!!package	^ self packages isEmpty ifTrue: [ nil ] ifFalse: [ self packages last ]!! !!!!Installer methodsFor: ''accessing'' stamp: ''sd 3/6/2008 18:48''!!package: anObject	self addPackage: anObject.!! !!!!Installer methodsFor: ''squeakmap'' stamp: ''mtf 10/15/2008 10:14''!!packageAndVersionFrom: pkg	| p |	p := ReadStream on: pkg .	^Array with: (p upTo: $() with: (p upTo: $)).!! !!!!Installer methodsFor: ''accessing'' stamp: ''sd 3/6/2008 18:48''!!packages	 	^ packages ifNil: [ packages := OrderedCollection new ]!! !!!!Installer methodsFor: ''accessing'' stamp: ''sd 3/6/2008 18:48''!!packages: aCollection 	packages := aCollection!! !!!!Installer methodsFor: ''searching'' stamp: ''mtf 10/8/2008 12:00''!!packagesMatching: aMatch	^''search type not supported''!! !!!!Installer methodsFor: ''printing'' stamp: ''damiencassou 2/20/2009 20:30''!!printConfigurationOn: stream	!! !!!!Installer methodsFor: ''printing'' stamp: ''damiencassou 2/20/2009 20:30''!!printOn: s	s		nextPutAll: ''(Installer '';		nextPutAll: self label;		nextPut: $).	"lf project ifNotNil: [ s nextPutAll: '' project:''; nextPutAll: '''''''', self project, ''''''''.						self package ifNotNil: [ s nextPutAll: ''; ''] ]."	self package ifNotNil: [ s nextPutAll: '' package:''; nextPutAll: '''''''', self package asString, '''''''' ].	self printConfigurationOn: s.	s nextPut: $..!! !!!!Installer methodsFor: ''custom names'' stamp: ''kph 5/28/2007 03:42''!!rememberAs: symbol	self class remembered at: symbol asSymbol put: self!! !!!!Installer methodsFor: ''utils'' stamp: ''kph 5/25/2007 01:15''!!removeChangeSet: cs	(self classChangeSet respondsTo: #removeChangeSet:)		ifTrue: [ ^ChangeSet removeChangeSet: cs ].			^ self classChangeSorter removeChangeSet: cs .!! !!!!Installer methodsFor: ''action report'' stamp: ''sd 3/6/2008 18:45''!!reportFor: theLine page: thePage on: report  		[ thePage atEnd ] whileFalse: [ 		| line |		line := thePage nextLine.		Installer actionMatch: line reportOn: report ifNoMatch: [ report nextPutAll: line; cr. ]].!! !!!!Installer methodsFor: ''action report'' stamp: ''sd 3/6/2008 18:45''!!reportSection: line on: report		report isEmpty ifFalse: [ report cr ].	report nextPutAll: ''">>>> '' ; nextPutAll: (line copyWithout: $"); nextPut: $"; cr.	!! !!!!Installer methodsFor: ''searching'' stamp: ''damiencassou 2/20/2009 19:29''!!search: aMatch	^''search type not supported''!! !!!!Installer methodsFor: ''auto answering'' stamp: ''kph 2/5/2008 15:48''!!suppress: aMessage	messagesToSuppress add: aMessage!! !!!!Installer methodsFor: ''url'' stamp: ''sd 3/6/2008 20:20''!!validChangeSetName: aFileName	" dots in the url confuses the changeset loader. I replace them with dashes"	 	(aFileName beginsWith:''http:'') ifTrue: [ | asUrl |		asUrl := Url absoluteFromText: aFileName.		^String streamContents: [:stream |			stream nextPutAll: (asUrl authority copyReplaceAll: ''.'' with: ''-'').			asUrl path allButLastDo: [:each |				stream					nextPutAll: ''/'';					nextPutAll: (each copyReplaceAll: ''.'' with: ''-'') ].			stream				nextPutAll: ''/'';				nextPutAll: asUrl path last ] ].	^aFileName!! !!!!Installer methodsFor: ''logging'' stamp: ''kph 5/25/2007 01:36''!!validate	ValidationBlock value = false ifTrue: [ self error: ''Validation failed'' ].!! !!!!Installer methodsFor: ''public interface'' stamp: ''mtf 10/8/2008 12:00''!!versions		^ self basicVersions!! !!!!Installer methodsFor: ''public interface'' stamp: ''mtf 10/8/2008 12:00''!!view	self logErrorDuring: [self basicView]!! !!!!Installer methodsFor: ''public interface'' stamp: ''sd 3/6/2008 19:06''!!view: packageNameCollectionOrDetectBlock	self package: packageNameCollectionOrDetectBlock.	self view!! !!!!Installer methodsFor: ''mantis'' stamp: ''kph 5/10/2007 00:21''!!view: aFileName from: stream		self log: '' viewing...''. 		Workspace new contents: (stream contents); openLabel: aFileName. 	 				 !! !!!!Installer methodsFor: ''auto answering'' stamp: ''kph 10/21/2006 06:52''!!withAnswersDo: aBlock	(aBlock respondsTo: #valueSuppressingMessages:supplyingAnswers: )		ifTrue: [aBlock valueSuppressingMessages: self messagesToSuppress supplyingAnswers: self answers.]		ifFalse: [ aBlock value ]!! !!Installer subclass: #InstallerCruft	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Installer-Core''!!!!InstallerCruft commentStamp: ''mtf 10/1/2008 22:24'' prior: 0!!I am a copy of Installer as of Installer-Core-kph.232. I am being split up.I  am called InstallerCruft because I stand-in for Sake{MC,SM,Mantis,Web,etc}Installer!!!!InstallerCruft class methodsFor: ''accessing system'' stamp: ''stephane.ducasse 9/30/2008 18:16''!!classProjectLauncher	^Smalltalk at: #ProjectLauncher ifAbsent: [ self error: ''ProjectLauncher not present'' ]!! !!!!InstallerCruft class methodsFor: ''accessing system'' stamp: ''stephane.ducasse 9/30/2008 18:16''!!classSakePackages	^Smalltalk at: #SakePackages  ifAbsent: [ self error: ''Sake Packages code not present'' ]!! !!!!InstallerCruft class methodsFor: ''accessing system'' stamp: ''stephane.ducasse 9/30/2008 18:16''!!classes	^ Smalltalk!! !!!!InstallerCruft class methodsFor: ''documentation'' stamp: ''kph 7/25/2007 13:25''!!history"7 Jan 2007  !!!!Installer fixBug: <aBugNo>aBugNo can now be a number or a string, beginning with a number. This allows the mantis bug report summary to be used verbatim.It also provides more infomarion for Installer to support self documentation.!!!!Install fix if not already installed Installer ensureFix: <aBugNoOrString> Installer ensureFixes: #(1 2 3 4)Installer now keeps a list of fix <aBugNoOrString> that have been installed up to this point.#ensureFix: will only install the fix if it has not already been loaded.note that only the bugNumber not the description is significant in the check.8 Jan 2007!!!!Installer view: <webPageNameOrUrl>Provided that web page based scripts follow some simple rules, installer can collate the scripts from web pages into a single workspace where you can manually ''doit'' portions as you wish.The report generation is not very clever, it only matches on: ''Installer install:'' ,  ''Installer installUrl:'', and ''Installer mantis fixBug:'' note these lines must be properly completed with an ending $. (period).also invoked by commandline option VIEW=<webPageNameOrUrl>10 Jan 2007!!!!Now matches simpler htmlCheck for an html page, now matches''<!!!!DOCTYPE HTML'' and <html> the allows use of pbwiki''s raw=bare option which returns iframe embeddable html without the usual headers.8 May 2007Modified bug:fix:date: so that the fixesApplied history does not contain unnecessary duplicate entries.Fixed changeset naming for mantis bugs.25 July 2007Added Universes  Support"!! !!!!InstallerCruft class methodsFor: ''accessing'' stamp: ''damiencassou 2/20/2009 19:38''!!label	^ ''cruft''!! !!!!InstallerCruft class methodsFor: ''documentation'' stamp: ''kph 5/24/2007 18:54''!!mczInstall: urlOrFile	^ self new mczInstall: urlOrFile!! !!!!InstallerCruft class methodsFor: ''accessing system'' stamp: ''stephane.ducasse 9/30/2008 18:20''!!smalltalkImage	^ SmalltalkImage current!! !!!!InstallerCruft class methodsFor: ''accessing system'' stamp: ''stephane.ducasse 9/30/2008 18:20''!!sourceFiles	^ SourceFiles!! !!!!InstallerCruft class methodsFor: ''unload'' stamp: ''stephane.ducasse 9/30/2008 18:30''!!unload: categoryMatchesString 	^ self error: ''deprecated, use Installer mc unload: ''''pkgname''''.''!! !!!!InstallerCruft methodsFor: ''class references'' stamp: ''sd 3/6/2008 20:16''!!classMCMczReader	^Smalltalk at: #MCMczReader ifAbsent: [ nil ]	!! !!!!InstallerCruft methodsFor: ''mantis'' stamp: ''edc 4/4/2007 07:56''!!createRBforBug: aBugNo 	| aStream  fileList selFile aFileName |	self setBug: aBugNo.fileList := self maFiles keys asOrderedCollection.fileList  addLast: ''none''.ReleaseBuilderFor3dot10 clear.[selFile := UIManager default chooseFrom: fileList title: ''Choose what files load ''.selFile = fileList size ifFalse:[aFileName := fileList at: selFile.	self logCR: ''obtaining '', aFileName, ''...''.	aStream := self maStreamForFile: aFileName .	ReleaseBuilderFor3dot10 current packagesInfluenced: aStream named: aFileName.		self installCS: aFileName from: aStream].selFile = fileList size]whileFalse.		ReleaseBuilderFor3dot10 current newUpdateFor: aBugNo			!! !!!!InstallerCruft methodsFor: ''mantis'' stamp: ''sd 3/6/2008 19:10''!!evaluate: stream	stream fileIn.!! !!!!InstallerCruft methodsFor: ''accessing'' stamp: ''sd 3/6/2008 18:47''!!info	self sm ifTrue: [ ^ self smInfo  ].	self wsm ifNotNil: [ ^ self wsmInfo  ].!! !!!!InstallerCruft methodsFor: ''monticello'' stamp: ''kph 5/24/2007 18:56''!!mczInstall: urlOrFile	self log: (''Loading '', urlOrFile, '' ...'').	(urlOrFile beginsWith: ''http:'')		ifTrue: [  MczInstaller installStream: (HTTPSocket httpGet: urlOrFile) ]		ifFalse: [ MczInstaller installFileNamed: urlOrFile ].			self logCR: '' Loaded''.	!! !!!!InstallerCruft methodsFor: ''mantis'' stamp: ''kph 12/21/2006 01:28''!!skipTests!! !!!!InstallerCruft methodsFor: ''accessing'' stamp: ''sd 3/6/2008 19:06''!!user	^ user ifNil: [ '''' ]!! !!!!InstallerCruft methodsFor: ''accessing'' stamp: ''sd 3/6/2008 19:06''!!user: anObject	user := anObject!! !!!!InstallerCruft methodsFor: ''utils'' stamp: ''kph 5/9/2007 21:49''!!viewUrl	^Workspace new contents: (self urlGet contents); openLabel: self urlToDownload.!! !!Installer subclass: #InstallerFile	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Installer-Core''!!!!InstallerFile class methodsFor: ''accessing'' stamp: ''damiencassou 2/20/2009 19:39''!!label	^ ''file''!! !!!!InstallerFile methodsFor: ''basic interface'' stamp: ''kph 7/28/2007 23:48''!!basicBrowse		self browse: self file from:  (FileDirectory readOnlyFileNamed: self file).	!! !!!!InstallerFile methodsFor: ''basic interface'' stamp: ''kph 7/28/2007 23:48''!!basicInstall		self install: self file from: (FileDirectory default readOnlyFileNamed: self file)	!! !!!!InstallerFile methodsFor: ''basic interface'' stamp: ''kph 7/28/2007 23:48''!!basicView		self view: self file from:  (FileDirectory readOnlyFileNamed: self file).	!! !!!!InstallerFile methodsFor: ''accessing'' stamp: ''mtf 10/23/2008 15:51''!!file	^ self package!! !!!!InstallerFile methodsFor: ''accessing'' stamp: ''mtf 10/23/2008 15:51''!!file: f	self package: f!! !!Installer subclass: #InstallerInternetBased	instanceVariableNames: ''url pageDataStream markers''	classVariableNames: ''Entities''	poolDictionaries: ''''	category: ''Installer-Core''!!!!InstallerInternetBased class methodsFor: ''accessing'' stamp: ''stephane.ducasse 9/30/2008 18:20''!!entities	^ Entities ifNil: [ Entities := 				"enough entities to be going on with"  				Dictionary new.				Entities at: ''lt'' put: ''<'';				at: ''gt'' put: ''>'';				at: ''amp'' put: ''&'';				at: ''star'' put: ''*'';				at: ''quot'' put: ''"'';				at: ''nbsp'' put: '' ''; 			yourself] !! !!!!InstallerInternetBased methodsFor: ''class references'' stamp: ''sd 3/6/2008 20:16''!!classHTTPSocket	^Smalltalk at: #HTTPSocket ifAbsent: [ self error: ''Network package not present'' ]!! !!!!InstallerInternetBased methodsFor: ''as yet unclassified'' stamp: ''kph 12/9/2008 03:07''!!extractFromHtml: html option: allOrLast	|  start stop test in |	start := self markersBegin.	stop :=  self markersEnd.	test := self markersTest.			 	in := ReadWriteStream with: String new.			[ html upToAll: start; atEnd ] 		whileFalse: [			| chunk |			(allOrLast == #last) ifTrue: [ in resetToStart ]. 			chunk := html upToAll: stop.			self isSkipLoadingTestsSet ifTrue: [ chunk := chunk readStream upToAll: test ].			in nextPutAll: chunk. 		 ].	^self removeHtmlMarkupFrom: in reset	 !! !!!!InstallerInternetBased methodsFor: ''url'' stamp: ''kph 10/11/2008 17:02''!!hasPage	^ pageDataStream notNil and: [ pageDataStream size > 0 ]			!! !!!!InstallerInternetBased methodsFor: ''utils'' stamp: ''sd 3/6/2008 20:15''!!httpGet: aUrl	| page |	page := self classHTTPSocket httpGet: aUrl accept: ''application/octet-stream''.   	(page respondsTo: #reset)  ifFalse: [ self error: ''unable to contact web site'' ].	^ page	!! !!!!InstallerInternetBased methodsFor: ''url'' stamp: ''sd 3/6/2008 20:18''!!isHtmlStream: page	"matches  ''<!!!!DOCTYPE HTML'', and <html>'' "		| first |		first := (page next: 14) asUppercase.	^ (first = ''<!!!!DOCTYPE HTML'') | (first beginsWith: ''<HTML>'')	!! !!!!InstallerInternetBased methodsFor: ''as yet unclassified'' stamp: ''kph 12/9/2008 03:07''!!markers	^ markers ifNil: [ ''<code st>..."test ...</code st>'' ]!! !!!!InstallerInternetBased methodsFor: ''as yet unclassified'' stamp: ''kph 12/9/2008 03:07''!!markers: anObject	markers := anObject!! !!!!InstallerInternetBased methodsFor: ''as yet unclassified'' stamp: ''kph 12/9/2008 03:08''!!markersBegin		 	 	 ^ self markers copyUpTo: $.!! !!!!InstallerInternetBased methodsFor: ''as yet unclassified'' stamp: ''kph 12/9/2008 03:08''!!markersEnd	"return the third marker or the second if there are only two"		| str  a | 	str := self markers readStream.	a := str upToAll: ''...''; upToAll: ''...''.	str atEnd  ifTrue: [ ^a ] ifFalse: [ ^str upToEnd ]	!! !!!!InstallerInternetBased methodsFor: ''as yet unclassified'' stamp: ''kph 12/9/2008 03:08''!!markersTest		 	 	^ self markers readStream upToAll: ''...''; upToAll: ''...''!! !!!!InstallerInternetBased methodsFor: ''as yet unclassified'' stamp: ''kph 12/9/2008 03:08''!!removeHtmlMarkupFrom: in 	| out |	out := ReadWriteStream on: (String new: 100).	[ in atEnd ] whileFalse: [ 		out nextPutAll: (in upTo: $<).		(((in upTo: $>) asLowercase beginsWith: ''br'') and: [ (in peek = Character cr) ]) ifTrue: [ in next ].		].		^self replaceEntitiesIn: out reset.!! !!!!InstallerInternetBased methodsFor: ''url'' stamp: ''sd 3/6/2008 20:19''!!replaceEntitiesIn: in	| out |	out := ReadWriteStream on: (String new: 100).	[ in atEnd ] whileFalse: [ 		out nextPutAll: ((in upTo: $&) replaceAll: Character lf with: Character cr).		in atEnd ifFalse: [ out nextPutAll: (self class entities at: (in upTo: $;) ifAbsent: ''?'') ].		].	^out reset!! !!!!InstallerInternetBased methodsFor: ''accessing'' stamp: ''sd 3/6/2008 19:06''!!url	^url!! !!!!InstallerInternetBased methodsFor: ''accessing'' stamp: ''sd 3/6/2008 19:06''!!url: aUrl 	url := aUrl!! !!!!InstallerInternetBased methodsFor: ''url'' stamp: ''sd 3/6/2008 20:19''!!urlGet	^ self urlGet: self urlToDownload!! !!!!InstallerInternetBased methodsFor: ''url'' stamp: ''kph 12/9/2008 03:17''!!urlGet: aUrl	| page |	page := HTTPSocket httpGet: aUrl accept: ''application/octet-stream''.  	(page respondsTo: #reset)  ifFalse: [ ^ nil ].	(self isHtmlStream: page) ifTrue: [ page := self extractFromHtml: page option: nil ].	^ page reset	!! !!!!InstallerInternetBased methodsFor: ''url'' stamp: ''kph 10/11/2008 17:02''!!wasPbwikiSpeedWarning				^ self hasPage and: [pageDataStream contents includesSubString: ''Please slow down a bit'' ]  !! !!InstallerInternetBased subclass: #InstallerUrl	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Installer-Core''!!!!InstallerUrl class methodsFor: ''action report'' stamp: ''mtf 10/8/2008 12:00''!!canReportLine: line	^ ((line beginsWith: ''Installer installUrl:'') and: 		[ | ext |		 ext :=  (line readStream upToAll: ''''''.'') copyAfterLast: $..		 (#( ''cs'' ''st'' ''mcz'' ''sar'') includes: ext) not ])!! !!!!InstallerUrl class methodsFor: ''accessing'' stamp: ''damiencassou 2/20/2009 19:39''!!label	^ ''url''!! !!!!InstallerUrl methodsFor: ''action report'' stamp: ''kph 1/8/2007 11:19''!!action: line reportOn: report  	url :=  line readStream upTo: $'' ; upTo: $''.  		self reportSection: line on: report.	(pageDataStream := self urlGet: self urlToDownload) 		ifNil: [ self error: ''unable to contact host'' ].	 		self reportFor: line page: pageDataStream on: report !! !!!!InstallerUrl methodsFor: ''basic interface'' stamp: ''sd 3/6/2008 20:19''!!basicBrowse 	"(Installer debug url: ''http://installer.pbwiki.com/f/Installer.st'') browse.".		self browse: self urlToDownload from: self urlThing.		!! !!!!InstallerUrl methodsFor: ''basic interface'' stamp: ''sd 3/6/2008 20:19''!!basicInstall  	 	self install: self urlToDownload from: self urlThing.	^ pageDataStream !! !!!!InstallerUrl methodsFor: ''basic interface'' stamp: ''sd 3/6/2008 20:19''!!basicView 	 "(Installer debug url: ''http://installer.pbwiki.com/f/Installer.st'') view.".		self view: self urlToDownload from: self urlThing.		!! !!!!InstallerUrl methodsFor: ''accessing'' stamp: ''kph 2/24/2009 07:07''!!bootstrap"(Installer url: ''http://www.squeaksource.com/Sake/Sake-Core-kph.47.mcz'') bootstrap."| pkg splitPos repo getFileName fileName |isBootstrap := true.splitPos := url lastIndexOf: $/. pkg := url copyFrom: splitPos + 1 to: url size.repo := url copyFrom: 1 to: splitPos.getFileName := [ :pkgName | pkgName , ((HTTPSocket httpGet: repo) upToAll: pkgName; upTo: $") ]. fileName := getFileName value: pkg.url := repo,fileName.self install!! !!!!InstallerUrl methodsFor: ''accessing'' stamp: ''damiencassou 2/20/2009 19:44''!!label	^ ''url:'''''', url, ''''''''!! !!!!InstallerUrl methodsFor: ''url'' stamp: ''mtf 10/15/2008 08:40''!!urlThing 	| retry delay |		self logCR: ''retrieving '', self urlToDownload , '' ...''.		delay := 0.	[ retry := false. pageDataStream := self urlGet: self urlToDownload ] 		doWhileTrue: [  				self wasPbwikiSpeedWarning ifTrue: [retry := true. delay := delay + 5.				self logCR: ''PBWiki speed warning. Retrying in '', delay printString, '' seconds''.				(Delay forSeconds: delay) wait ].														retry ].			pageDataStream ifNil: [ self error: ''unable to contact host'' ].	 	^ pageDataStream	!! !!!!InstallerUrl methodsFor: ''url'' stamp: ''kph 1/4/2007 23:49''!!urlToDownload	^ (self url, (self package ifNil: [ '''' ])) asUrl asString.	 !! !!InstallerInternetBased subclass: #InstallerWebBased	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Installer-Core''!!InstallerWebBased subclass: #InstallerMantis	instanceVariableNames: ''ma bug desc date array data status''	classVariableNames: ''Fixes Status''	poolDictionaries: ''''	category: ''Installer-Core''!!!!InstallerMantis commentStamp: ''test 1/14/2009 00:11'' prior: 0!!Search feature is based upon a custom mantis query ceveloped and maintained by Ken Causey <ken@kencausey.com>Installer mantis bugsAll select: [ :ea | ea status = ''testing'' ].!!!!InstallerMantis class methodsFor: ''instance creation'' stamp: ''test 1/12/2009 00:00''!!initialize	Status := Dictionary new		at: ''10'' put: ''new'';		at: ''20'' put: ''feedback'';		at: ''30'' put: ''acknowledged'';		at: ''40'' put: ''confirmed'';		at: ''50'' put: ''assigned'';		at: ''60'' put: ''pending'';		at: ''70'' put: ''testing'';		at: ''80'' put: ''resolved'';		at: ''90'' put: ''closed'';		yourself !! !!!!InstallerMantis class methodsFor: ''action report'' stamp: ''mtf 10/8/2008 12:00''!!canReportLine: line	^ line beginsWith: ''Installer mantis fixBug:''!! !!!!InstallerMantis class methodsFor: ''accessing'' stamp: ''stephane.ducasse 9/30/2008 18:21''!!fixesApplied	^ Fixes ifNil: [ Fixes := OrderedCollection new ].!! !!!!InstallerMantis class methodsFor: ''instance creation'' stamp: ''stephane.ducasse 9/30/2008 18:24''!!host: host	^self new	ma: host; 			markers: ''&quot;fix begin&quot;...&quot;fix test&quot;...&quot;fix end&quot;''; 			yourself.!! !!!!InstallerMantis class methodsFor: ''accessing'' stamp: ''damiencassou 2/20/2009 19:40''!!label	^ ''mantis''!! !!!!InstallerMantis methodsFor: ''accessing'' stamp: ''test 1/13/2009 23:42''!!= other	^ array = other array!! !!!!InstallerMantis methodsFor: ''action report'' stamp: ''sd 3/6/2008 18:44''!!action: line reportOn: report		| param mantis |	mantis := Installer mantis.	param :=  line readStream upTo: $: ; upTo: $..		mantis setBug: ((param readStream upTo: $''; atEnd)		 ifTrue: [  param ]		 ifFalse: [ param readStream upTo: $''; upTo: $'' ]).		self reportSection: line on: report.	report nextPutAll: (mantis replaceEntitiesIn: mantis markersBegin readStream).	self reportFor: line page: mantis maScript on: report.	report nextPutAll: (mantis replaceEntitiesIn: mantis markersEnd readStream); cr.	!! !!!!InstallerMantis methodsFor: ''accessing'' stamp: ''test 1/13/2009 23:40''!!array	^ array!! !!!!InstallerMantis methodsFor: ''public interface'' stamp: ''kph 12/10/2008 14:25''!!browseFile: aFileName	^ self browse: aFileName from: (self maThing: aFileName date: nil)!! !!!!InstallerMantis methodsFor: ''accessing'' stamp: ''test 1/13/2009 23:45''!!bug		^ bug ifNil: [ 				date := ((self dataAtName: ''Updated'') replaceAll: $  with: $T) asDateAndTime. 		desc := (self dataAtName: ''Summary'').		bug := (self dataAtName: ''Id''). 		self statusInit. 	]!! !!!!InstallerMantis methodsFor: ''public interface'' stamp: ''kph 12/17/2008 10:53''!!bug: aBugNo	self setBug: aBugNo.	^ self report!! !!!!InstallerMantis methodsFor: ''public interface'' stamp: ''kph 12/10/2008 14:26''!!bug: aBugNo browse: aFileName	 self setBug: aBugNo.	^ self browseFile: aFileName!! !!!!InstallerMantis methodsFor: ''public interface'' stamp: ''kph 12/18/2006 04:11''!!bug: aBugNo fix: aFileName	^ self bug: aBugNo fix: aFileName date: nil!! !!!!InstallerMantis methodsFor: ''public interface'' stamp: ''kph 12/9/2008 22:46''!!bug: aBugNo fix: aFileName date: aDate 	| |	self setBug: aBugNo.	self ditchOldChangeSetFor: aFileName.	self install: aFileName from: (self maThing: aFileName date: aDate).			^ date!! !!!!InstallerMantis methodsFor: ''public interface'' stamp: ''sd 3/6/2008 19:09''!!bug: aBugNo retrieve: aFileName	 self setBug: aBugNo.	^ (self maStreamForFile: aFileName) contents!! !!!!InstallerMantis methodsFor: ''public interface'' stamp: ''sd 3/6/2008 19:09''!!bug: aBugNo view: aFileName	"Installer mantis bug: 6089 browse: ''TTFSpeedUp-dgd.1.cs''"		 self setBug: aBugNo.	^ self view: aFileName from: (self maThing: aFileName date: nil)!! !!!!InstallerMantis methodsFor: ''public interface'' stamp: ''kph 12/10/2008 14:35''!!bugFiles: aBugNo 	"provide a list of files associated with the bug in id order"	"	Installer mantis bugFiles: 6660.	"	self setBug: aBugNo; files!! !!!!InstallerMantis methodsFor: ''public interface'' stamp: ''kph 12/10/2008 14:37''!!bugFilesView: aBugNo 	"provide a list of files associated with the bug in id order"	"	Installer mantis bugFiles: 6660.	"	self setBug: aBugNo; viewFiles!! !!!!InstallerMantis methodsFor: ''public interface'' stamp: ''kph 12/10/2008 14:37''!!bugScript: aBugNo	^ (self setBug: aBugNo) script		!! !!!!InstallerMantis methodsFor: ''action report'' stamp: ''test 1/13/2009 23:39''!!bugsAll	^ array ifNil: [				array := ( self bugsSqueak ,  (self dataGetFrom: ''/installer_export.php'') ) asSet asSortedCollection: [ :a :b | a date > b date ]			]."Installer mantis bugsAll"	!! !!!!InstallerMantis methodsFor: ''search'' stamp: ''test 1/13/2009 23:00''!!bugsClosed	^ array ifNil: [ array := self dataGetFrom: ''/installer_export.php?closed'' ]!! !!!!InstallerMantis methodsFor: ''search...etc...----!SystemOrganization addCategory: #'Installer-Formats'!Model subclass: #SARInstaller	instanceVariableNames: 'zip directory fileName installed'	classVariableNames: ''	poolDictionaries: ''	category: 'Installer-Formats'!!SARInstaller commentStamp: 'nk 7/5/2003 21:12' prior: 28710797!I am an object that handles the loading of SAR (Squeak ARchive) files.A SAR file is a Zip file that follows certain simple conventions:* it may have a member named "install/preamble".This member, if present, will be filed in as Smalltalk source code at the beginning of installation.Typically, the code in the preamble will make whatever installation preparations are necessary,and will then call methods in the "client services" method category to extract or install other zip members.* It may have a member named "install/postscript".This member, if present, will be filed in as Smalltalk source code at the end of installation.Typically, the code in the postscript will set up the operating environment,and will perhaps put objects in flaps, open projects or README files, or launch samples.Within the code in the preamble and postscript, "self" is set to the instance of the SARInstaller.If neither an "install/preamble" nor an "install/postscript" file is present,all the members will be installed after prompting the user,based on a best guess of the member file types that is based on member filename extensions.This is new behavior.!!SARInstaller class methodsFor: 'class initialization' stamp: 'nk 7/5/2003 22:22' prior: 28734616!initialize	"SARInstaller initialize"	(FileList respondsTo: #registerFileReader:)		ifTrue: [ FileList registerFileReader: self ]! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'pk 10/17/2006 09:42' prior: 28731326!basicNewChangeSet: newName	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs basicNewChangeSet: newName ].	(self changeSetNamed: newName) ifNotNil: [ self inform: 'Sorry that name is already used'. ^nil ].	^ChangeSet basicNewNamed: newName.! !!SARInstaller class methodsFor: 'SqueakMap' stamp: 'nk 7/21/2003 17:21' prior: 28737660!cardForSqueakMap: aSqueakMap	"Answer the current card or a new card."	(aSqueakMap cardWithId: self squeakMapPackageID)		ifNotNilDo: [ :card |			(card installedVersion = self squeakMapPackageVersion) ifTrue: [ ^card ]		].	^self newCardForSqueakMap: aSqueakMap! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'pk 10/17/2006 09:42' prior: 28731671!changeSetNamed: newName	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs changeSetNamed: newName ].	^ChangeSet allInstances detect: [ :cs | cs name = newName ] ifNone: [ nil ].! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'nk 7/5/2003 22:49' prior: 28731950!currentChangeSet	"Answer the current change set, in a way that should work in 3.5 as well"	"SARInstaller currentChangeSet"	^[ ChangeSet current ]		on: MessageNotUnderstood		do: [ :ex | ex return: Smalltalk changes ]! !!SARInstaller class methodsFor: 'instance creation' stamp: 'nk 10/27/2002 10:29' prior: 28735801!directory: dir fileName: fn	^(self new) directory: dir; fileName: fn; yourself.! !!SARInstaller class methodsFor: 'package format support' stamp: 'ar 9/27/2005 20:11' prior: 28735973!ensurePackageWithId: anIdString	self squeakMapDo: [ :sm | | card newCS |		self withCurrentChangeSetNamed: 'updates' do: [ :cs |			newCS := cs.			card := sm cardWithId: anIdString.			(card isNil or: [ card isInstalled not or: [ card isOld ]])				ifTrue: [ sm installPackageWithId: anIdString ]		].		newCS isEmpty ifTrue: [ ChangeSet removeChangeSet: newCS ]	].! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'yo 8/17/2004 10:04' prior: 28732261!fileIntoChangeSetNamed: aString fromStream: stream 	"We let the user confirm filing into an existing ChangeSet	or specify another ChangeSet name if	the name derived from the filename already exists.	Duplicated from SMSimpleInstaller.	Should be a class-side method."	^self withCurrentChangeSetNamed: aString		do: [ :cs | | newName |			newName := cs name.			stream setConverterForCode.			stream 				fileInAnnouncing: 'Loading ' , newName , ' into change set ''' , newName, ''''.			stream close]! !!SARInstaller class methodsFor: 'class initialization' stamp: 'nk 11/13/2002 07:33' prior: 28734375!fileReaderServicesForFile: fullName suffix: suffix 	^(suffix = 'sar') | (suffix = '*') 		ifTrue: [Array with: self serviceFileInSAR]		ifFalse: [#()]! !!SARInstaller class methodsFor: 'class initialization' stamp: 'nk 7/5/2003 21:05' prior: 28734834!installSAR: relativeOrFullName	FileDirectory splitName: (FileDirectory default fullNameFor: relativeOrFullName)		to: [ :dir :fileName | (self directory: (FileDirectory on: dir) fileName: fileName) fileIn ]! !!SARInstaller class methodsFor: 'package format support' stamp: 'nk 7/25/2003 14:05' prior: 28736433!loadDVS	"Load the DVS support from SqueakMap"	self ensurePackageWithId: '100d59d0-bf81-4e74-a4fe-5a2fd0c6b4ec'! !!SARInstaller class methodsFor: 'package format support' stamp: 'nk 9/9/2003 12:08' prior: 28736636!loadMonticello	"Load Monticello support (MCInstaller and Monticello) from SqueakMap"	self ensurePackageWithId: 'af9d090d-2896-4a4e-82d0-c61cf2fdf40e'.	self ensurePackageWithId: '66236497-7026-45f5-bcf6-ad00ba7a8a4e'.! !!SARInstaller class methodsFor: 'package format support' stamp: 'nk 7/25/2003 14:39' prior: 28736947!loadMonticelloCVS	"Load MonticelloCVS support from SqueakMap"	self ensurePackageWithId: '2be9f7e2-1de2-4eb6-89bd-ec9b60593a93'.! !!SARInstaller class methodsFor: 'SqueakMap' stamp: 'nk 7/21/2003 17:17' prior: 28738005!newCardForSqueakMap: aSqueakMap	"Answer a new card."	^(aSqueakMap newCardWithId: self squeakMapPackageID)	created: 3236292323	updated:3236292323	name: 'SARInstaller for 3.6'	currentVersion:'16'	summary: 'Lets you load SAR (Squeak ARchive) files from SqueakMap and the File List. For 3.6 and later images.'	description:'Support for installing SAR (Squeak ARchive) packages from SqueakMap and the File List.For 3.6 and later images.SMSARInstaller will use this if it''s present to load SAR packages.Use SARBuilder for making these packages easily.'	url: 'http://bike-nomad.com/squeak/'	downloadUrl:'http://bike-nomad.com/squeak/SARInstallerFor36-nk.16.cs.gz'	author: 'Ned Konz <ned@bike-nomad.com>'	maintainer:'Ned Konz <ned@bike-nomad.com>'	registrator:'Ned Konz <ned@bike-nomad.com>'	password:240495131608326995113451940367316491071470713347	categories: #('6ba57b6e-946a-4009-beaa-0ac93c08c5d1' '94277ca9-4d8f-4f0e-a0cb-57f4b48f1c8a' 'a71a6233-c7a5-4146-b5e3-30f28e4d3f6b' '8209da9b-8d6e-40dd-b23a-eb7e05d4677b' );	modulePath: ''	moduleVersion:''	moduleTag:''	versionComment:'v16: same as v16 of SARInstaller for 3.4 but doesn''t include any classes other than SARInstaller.To be loaded into 3.6 images only. Will de-register the 3.4 version if it''s registered.Added a default (DWIM) mode in which SAR files that are missing both a preamble and postscript have all their members loaded in a default manner.Changed the behavior of #extractMemberWithoutPath: to use the same directory as the SAR itself.Added #extractMemberWithoutPath:inDirectory:Moved several change set methods to the class side.Made change set methods work with 3.5 or 3.6a/bNow supports the following file types:Projects (with or without construction of a ViewMorph)Genie gesture dictionariesChange setsDVS packagesMonticello packagesGraphics files (loaded as SketchMorphs)Text files (loaded as text editor windows)Morph(s) in filesNow keeps track of installed members.'! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'nk 7/5/2003 22:51' prior: 28732854!newChanges: aChangeSet	"Change the current change set, in a way that should work in 3.5 as well"	"SARInstaller newChanges: SARInstaller currentChangeSet"	^[ ChangeSet newChanges: aChangeSet ]		on: MessageNotUnderstood		do: [ :ex | ex return: (Smalltalk newChanges: aChangeSet) ]! !!SARInstaller class methodsFor: 'class initialization' stamp: 'nk 11/13/2002 07:35' prior: 28735131!serviceFileInSAR	"Answer a service for opening a changelist browser on a file"	^ SimpleServiceEntry 		provider: self 		label: 'install SAR'		selector: #installSAR:		description: 'install this Squeak ARchive into the image.'		buttonLabel: 'install'! !!SARInstaller class methodsFor: 'class initialization' stamp: 'nk 11/21/2002 09:46' prior: 28735476!services	^Array with: self serviceFileInSAR! !!SARInstaller class methodsFor: 'package format support' stamp: 'nk 7/25/2003 08:27' prior: 28737169!squeakMapDo: aBlock	"If SqueakMap is installed, evaluate aBlock with the default map.	Otherwise, offer to install SqueakMap and continue."	Smalltalk at: #SMSqueakMap ifPresent: [ :smClass | ^aBlock value: smClass default ].	(self confirm: 'SqueakMap is not installed in this image.Would you like to load it from the network?')		ifTrue: [ TheWorldMenu loadSqueakMap.			^self squeakMapDo: aBlock ].	^nil! !!SARInstaller class methodsFor: 'SqueakMap' stamp: 'nk 7/21/2003 17:16' prior: 28740073!squeakMapPackageID	^'75c970ab-dca7-48ee-af42-5a013912c880'! !!SARInstaller class methodsFor: 'SqueakMap' stamp: 'nk 7/21/2003 17:18' prior: 28740210!squeakMapPackageVersion	^'16'! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'rbb 3/1/2005 11:11' prior: 28733227!withCurrentChangeSetNamed: aString do: aOneArgumentBlock 	"Evaluate the one-argument block aOneArgumentBlock while the named change set is active.	We let the user confirm operating on an existing ChangeSet 	or specify another ChangeSet name if 	the name derived from the filename already exists. 	Duplicated from SMSimpleInstaller. 	Returns change set."	| changeSet newName oldChanges |	newName := aString.	changeSet := self changeSetNamed: newName.	changeSet ifNotNil: 			[newName := UIManager default 						request: 'ChangeSet already present, just confirm to overwrite or enter a new name:'						initialAnswer: newName.			newName isEmpty ifTrue: [self error: 'Cancelled by user'].			changeSet := self changeSetNamed: newName].	changeSet ifNil: [changeSet := self basicNewChangeSet: newName].	changeSet 		ifNil: [self error: 'User did not specify a valid ChangeSet name'].	oldChanges := self currentChangeSet.		[ self newChanges: changeSet.	aOneArgumentBlock value: changeSet] 			ensure: [ self newChanges: oldChanges].	^changeSet! !!SARInstaller methodsFor: 'accessing' stamp: 'nk 10/25/2002 12:16' prior: 28712031!directory	^directory! !!SARInstaller methodsFor: 'accessing' stamp: 'nk 10/25/2002 12:16' prior: 28712125!directory: anObject	directory := anObject! !!SARInstaller methodsFor: 'private' stamp: 'nk 10/13/2003 12:56' prior: 28730333!errorNoSuchMember: aMemberName	(self confirm: 'No member named ', aMemberName, '. Do you want to stop loading?')		== true ifTrue: [ self error: 'aborted' ].! !!SARInstaller methodsFor: 'client services' stamp: 'nk 7/5/2003 22:25' prior: 28713602!extractMember: aMemberOrName	"Extract aMemberOrName to a file using its filename"	(self zip extractMember: aMemberOrName)		ifNil: [ self errorNoSuchMember: aMemberOrName ]		ifNotNil: [ self installed: aMemberOrName ].! !!SARInstaller methodsFor: 'client services' stamp: 'nk 7/5/2003 22:25' prior: 28713900!extractMember: aMemberOrName toFileNamed: aFileName	"Extract aMemberOrName to a specified filename"	(self zip extractMember: aMemberOrName toFileNamed: aFileName)		ifNil: [ self errorNoSuchMember: aMemberOrName ]		ifNotNil: [ self installed: aMemberOrName ].! !!SARInstaller methodsFor: 'client services' stamp: 'nk 7/5/2003 22:40' prior: 28714239!extractMemberWithoutPath: aMemberOrName	"Extract aMemberOrName to its own filename, but ignore any directory paths, using my directory instead."	self extractMemberWithoutPath: aMemberOrName inDirectory: self directory.! !!SARInstaller methodsFor: 'client services' stamp: 'nk 7/5/2003 22:40' prior: 28714537!extractMemberWithoutPath: aMemberOrName inDirectory: aDirectory	"Extract aMemberOrName to its own filename, but ignore any directory paths, using aDirectory instead"	| member |	member := self memberNamed: aMemberOrName.	member ifNil: [ ^self errorNoSuchMember: aMemberOrName ].	self zip extractMemberWithoutPath: member inDirectory: aDirectory.	self installed: member.! !!SARInstaller methodsFor: 'fileIn' stamp: 'ar 9/27/2005 20:10' prior: 28728231!fileIn	"File in to a change set named like my file"	| stream newCS |	stream := directory readOnlyFileNamed: fileName.	self class withCurrentChangeSetNamed: fileName		do: [:cs | newCS := cs. self fileInFrom: stream].	newCS isEmpty ifTrue: [ ChangeSet removeChangeSet: newCS ]! !!SARInstaller methodsFor: 'fileIn' stamp: 'yo 8/17/2004 00:33' prior: 28728580!fileInFrom: stream	"The zip has been saved already by the download.	Read the zip into my instvar, then file in the correct members"	| preamble postscript |	[		stream position: 0.		zip := ZipArchive new readFrom: stream.		preamble := zip memberNamed: 'install/preamble'.		preamble ifNotNil: [			preamble contentStream text setConverterForCode fileInFor: self announcing: 'Preamble'.			self class currentChangeSet preambleString: preamble contents.		].		postscript := zip memberNamed: 'install/postscript'.		postscript ifNotNil: [			postscript contentStream text setConverterForCode fileInFor: self announcing: 'Postscript'.			self class currentChangeSet postscriptString: postscript contents.		].		preamble isNil & postscript isNil ifTrue: [			(self confirm: 'No install/preamble or install/postscript member were found.	Install all the members automatically?') ifTrue: [ self installAllMembers ]		].	] ensure: [ stream close ].! !!SARInstaller methodsFor: 'client services' stamp: 'nk 2/13/2004 12:12' prior: 28714988!fileInGenieDictionaryNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as Genie gesture dictionaries.	Answers a dictionary."	| member object crDictionary stream |	crDictionary := Smalltalk at: #CRDictionary ifAbsent: [ ^self error: 'Genie not installed' ].	"don't know how to recursively load"	member := self memberNamed: memberName.	member ifNil: [ ^self errorNoSuchMember: memberName ].	stream := ReferenceStream on: member contentStream.	[ object := stream next ]		on: Error do: 		[:ex |  stream close.		self inform: 'Error on loading: ' , ex description. ^ nil ].	stream close.	(object notNil and: [object name isEmptyOrNil])		ifTrue: [object := crDictionary name: object storedName].	self installed: member.	^ object! !!SARInstaller methodsFor: 'private' stamp: 'ar 9/27/2005 20:10' prior: 28730561!fileInMCVersion: member withBootstrap: mcBootstrap	"This will use the MCBootstrapLoader to load a (non-compressed) Monticello file (.mc or .mcv)"	| newCS |	self class withCurrentChangeSetNamed: member localFileName		do: [ :cs | 			newCS := cs.			mcBootstrap loadStream: member contentStream ascii ].	newCS isEmpty ifTrue: [ ChangeSet removeChangeSet: newCS ].	World doOneCycle.	self installed: member.! !!SARInstaller methodsFor: 'client services' stamp: 'yo 8/17/2004 10:01' prior: 28715852!fileInMemberNamed: csName	"This is to be used from preamble/postscript code to file in zip members as ChangeSets."	| cs |	cs := self memberNamed: csName.	cs ifNil: [ ^self errorNoSuchMember: csName ].	self class fileIntoChangeSetNamed: csName fromStream: cs contentStream text setConverterForCode.	self installed: cs.! !!SARInstaller methodsFor: 'client services' stamp: 'ar 9/27/2005 20:10' prior: 28716253!fileInMonticelloPackageNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as Monticello packages (.mc)."	| member file mcPackagePanel mcRevisionInfo mcSnapshot mcFilePackageManager mcPackage info snapshot newCS mcBootstrap |	mcPackagePanel := Smalltalk at: #MCPackagePanel ifAbsent: [ ].	mcRevisionInfo := Smalltalk at: #MCRevisionInfo ifAbsent: [ ].	mcSnapshot := Smalltalk at: #MCSnapshot ifAbsent: [ ].	mcFilePackageManager := Smalltalk at: #MCFilePackageManager ifAbsent: [ ].	mcPackage := Smalltalk at: #MCPackage ifAbsent: [ ].	member := self memberNamed: memberName.	member ifNil: [ ^self errorNoSuchMember: memberName ].	"We are missing MCInstaller, Monticello and/or MonticelloCVS.	If the bootstrap is present, use it. Otherwise interact with the user."	({ mcPackagePanel. mcRevisionInfo. mcSnapshot. mcFilePackageManager. mcPackage } includes: nil)		ifTrue: [			mcBootstrap := self getMCBootstrapLoaderClass.			mcBootstrap ifNotNil: [ ^self fileInMCVersion: member withBootstrap: mcBootstrap ].			(self confirm: ('Monticello support is not installed, but must be to load member named ', memberName, '.Load it from SqueakMap?'))				ifTrue: [ self class loadMonticello; loadMonticelloCVS.					^self fileInMonticelloPackageNamed: memberName ]				ifFalse: [ ^false ] ].	member extractToFileNamed: member localFileName inDirectory: self directory.	file := (Smalltalk at: #MCFile)				name: member localFileName				directory: self directory.	self class withCurrentChangeSetNamed: file name do: [ :cs |		newCS := cs.		file readStreamDo: [ :stream |			info := mcRevisionInfo readFrom: stream nextChunk.			snapshot := mcSnapshot fromStream: stream ].			snapshot install.			(mcFilePackageManager forPackage:				(mcPackage named: info packageName))					file: file		].	newCS isEmpty ifTrue: [ ChangeSet removeChangeSet: newCS ].	mcPackagePanel allSubInstancesDo: [ :ea | ea refresh ].	World doOneCycle.	self installed: member.! !!SARInstaller methodsFor: 'client services' stamp: 'ar 9/27/2005 20:10' prior: 28718345!fileInMonticelloVersionNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as Monticello version (.mcv) files."	| member newCS mcMcvReader |	mcMcvReader := Smalltalk at: #MCMcvReader ifAbsent: [].	member := self memberNamed: memberName.	member ifNil: [^self errorNoSuchMember: memberName].	"If we don't have Monticello, offer to get it."	mcMcvReader ifNil:  [		(self confirm: 'Monticello is not installed, but must be to load member named ', memberName , '.Load it from SqueakMap?') 			ifTrue:  [ self class loadMonticello.						^self fileInMonticelloVersionNamed: memberName]					ifFalse: [^false]].	self class withCurrentChangeSetNamed: member localFileName		do: 			[:cs | 			newCS := cs.			(mcMcvReader versionFromStream: member contentStream ascii) load ].	newCS isEmpty ifTrue: [ChangeSet removeChangeSet: newCS].	World doOneCycle.	self installed: member! !!SARInstaller methodsFor: 'client services' stamp: 'ar 9/27/2005 20:10' prior: 28719347!fileInMonticelloZipVersionNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as Monticello version (.mcz) files."	| member mczInstaller newCS mcMczReader |	mcMczReader := Smalltalk at: #MCMczReader ifAbsent: [].	mczInstaller := Smalltalk at: #MczInstaller ifAbsent: [].	member := self memberNamed: memberName.	member ifNil: [^self errorNoSuchMember: memberName].	"If we don't have Monticello, but have the bootstrap, use it silently."	mcMczReader ifNil:  [		mczInstaller ifNotNil: [ ^mczInstaller installStream: member contentStream ].		(self confirm: 'Monticello is not installed, but must be to load member named ', memberName , '.Load it from SqueakMap?') 			ifTrue:  [ self class loadMonticello.						^self fileInMonticelloZipVersionNamed: memberName]					ifFalse: [^false]].	self class withCurrentChangeSetNamed: member localFileName		do: 			[:cs | 			newCS := cs.			(mcMczReader versionFromStream: member contentStream) load ].	newCS isEmpty ifTrue: [ChangeSet removeChangeSet: newCS].	World doOneCycle.	self installed: member! !!SARInstaller methodsFor: 'client services' stamp: 'nk 7/5/2003 22:27' prior: 28720524!fileInMorphsNamed: memberName addToWorld: aBoolean	"This will load the Morph (or Morphs) from the given member.	Answers a Morph, or a list of Morphs, or nil if no such member or error.	If aBoolean is true, also adds them and their models to the World."	| member morphOrList |	member := self memberNamed: memberName.	member ifNil: [ ^self errorNoSuchMember: memberName ].	self installed: member.	morphOrList := member contentStream fileInObjectAndCode.	morphOrList ifNil: [ ^nil ].	aBoolean ifTrue: [ ActiveWorld addMorphsAndModel: morphOrList ].	^morphOrList! !!SARInstaller methodsFor: 'client services' stamp: 'yo 8/17/2004 10:05' prior: 28721173!fileInPackageNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as DVS packages."	| member current new baseName imagePackageLoader packageInfo streamPackageLoader packageManager |	member := self zip memberNamed: memberName.	member ifNil: [ ^self errorNoSuchMember: memberName ].	imagePackageLoader := Smalltalk at: #ImagePackageLoader ifAbsent: [].	streamPackageLoader := Smalltalk at: #StreamPackageLoader ifAbsent: [].	packageInfo := Smalltalk at: #PackageInfo ifAbsent: [].	packageManager := Smalltalk at: #FilePackageManager ifAbsent: [].	"If DVS isn't present, do a simple file-in"	(packageInfo isNil or: [imagePackageLoader isNil or: [streamPackageLoader isNil]])		ifTrue: [ ^ self fileInMemberNamed: memberName ].	baseName := memberName copyReplaceAll: '.st' with: '' asTokens: false.	(packageManager allManagers anySatisfy: [ :pm | pm packageName = baseName ])		ifTrue: [			current := imagePackageLoader new package: (packageInfo named: baseName).			new := streamPackageLoader new stream: member contentStream ascii.			(new changesFromBase: current) fileIn ]		ifFalse: [ self class fileIntoChangeSetNamed: baseName fromStream: member contentStream ascii setConverterForCode. ].	packageManager registerPackage: baseName.	self installed: member.! !!SARInstaller methodsFor: 'client services' stamp: 'nk 7/27/2003 09:49' prior: 28722562!fileInProjectNamed: projectOrMemberName createView: aBoolean 	"This is to be used from preamble/postscript code to file in SAR members 	as Projects. 	Answers the loaded project, or nil. 	Does not enter the loaded project. 	If aBoolean is true, also creates a ProjectViewMorph 	(possibly in a window, depending on your Preferences)."	| member project triple memberName |	member := self memberNamed: projectOrMemberName.	member		ifNotNil: [ memberName := member fileName ]		ifNil: [ 	member := self memberNamed: (memberName := self memberNameForProjectNamed: projectOrMemberName) ].	member ifNil: [ ^self errorNoSuchMember: projectOrMemberName ].	triple := Project parseProjectFileName: memberName unescapePercents.	project := nil.	[[ProjectLoading		openName: triple first		stream: member contentStream		fromDirectory: nil		withProjectView: nil]		on: ProjectViewOpenNotification		do: [:ex | ex resume: aBoolean]]		on: ProjectEntryNotification		do: [:ex | 			project := ex projectToEnter.			ex resume].	self installed: member.	^ project! !!SARInstaller methodsFor: 'client services' stamp: 'nk 9/26/2003 17:17' prior: 28723693!fileInTrueTypeFontNamed: memberOrName	| member description |	member := self memberNamed: memberOrName.	member ifNil: [^self errorNoSuchMember: memberOrName].	description := TTFontDescription addFromTTStream: member contentStream.	TTCFont newTextStyleFromTT: description.	World doOneCycle.	self installed: member! !!SARInstaller methodsFor: 'fileIn' stamp: 'nk 7/27/2003 14:02' prior: 28729602!fileIntoChangeSetNamed: aString fromStream: stream	"Not recommended for new code"	^self class fileIntoChangeSetNamed: aString fromStream: stream! !!SARInstaller methodsFor: 'accessing' stamp: 'nk 10/25/2002 12:16' prior: 28712240!fileName	^fileName! !!SARInstaller methodsFor: 'accessing' stamp: 'nk 10/25/2002 12:16' prior: 28712332!fileName: anObject	fileName := anObject! !!SARInstaller methodsFor: 'client services' stamp: 'nk 9/9/2003 11:56' prior: 28724090!getMCBootstrapLoaderClass	^Smalltalk at: #MCBootstrapLoader		ifAbsent: 			[(self memberNamed: 'MCBootstrapLoader.st') 				ifNotNilDo: [:m | self fileInMemberNamed: m.					Smalltalk at: #MCBootstrapLoader ifAbsent: []]]! !!SARInstaller methodsFor: 'client services' stamp: 'nk 10/14/2003 15:40' prior: 28724392!importImage: memberOrName	| member form |	member := self memberNamed: memberOrName.	member ifNil: [ ^self errorNoSuchMember: memberOrName ].	form := ImageReadWriter formFromStream: member contentStream binary.	form ifNil: [ ^self ].	Imports default importImage: form named: (FileDirectory localNameFor: member fileName) sansPeriodSuffix.	self installed: member.! !!SARInstaller methodsFor: 'initialization' stamp: 'nk 7/5/2003 22:24' prior: 28730215!initialize	installed := OrderedCollection new.! !!SARInstaller methodsFor: 'fileIn' stamp: 'nk 10/12/2003 20:41' prior: 28729818!installAllMembers	"Try to install all the members, in order, based on their filenames and/or contents."	| uninstalled |	uninstalled := OrderedCollection new.	zip members do: [ :member | self installMember: member ].	uninstalled := self uninstalledMembers.	uninstalled isEmpty ifTrue: [ ^self ].	uninstalled inspect.! !!SARInstaller methodsFor: 'client services' stamp: 'tak 1/24/2005 19:12' prior: 28724837!installMember: memberOrName	| memberName extension isGraphic stream member |	member := self memberNamed: memberOrName.	member ifNil: [ ^false ].	memberName := member fileName.	extension := (FileDirectory extensionFor: memberName) asLowercase.	Smalltalk at: #CRDictionary ifPresent: [ :crDictionary |		(extension = crDictionary fileNameSuffix) ifTrue: [  self fileInGenieDictionaryNamed: memberName. ^true ] ].	extension caseOf: {		[ Project projectExtension ] -> [ self fileInProjectNamed: memberName createView: true ].		[ FileStream st ] -> [ self fileInPackageNamed: memberName ].		[ FileStream cs ] -> [  self fileInMemberNamed: memberName  ]."		[ FileStream multiSt ] -> [  self fileInMemberNamedAsUTF8: memberName  ].		[ FileStream multiCs ] -> [  self fileInMemberNamedAsUTF8: memberName  ]."		[ 'mc' ] -> [ self fileInMonticelloPackageNamed: memberName ].		[ 'mcv' ] -> [ self fileInMonticelloVersionNamed: memberName ].		[ 'mcz' ] -> [ self fileInMonticelloZipVersionNamed: memberName ].		[ 'morph' ] -> [ self fileInMorphsNamed: member addToWorld: true ].		[ 'ttf' ] -> [ self fileInTrueTypeFontNamed: memberName ].		[ 'translation' ] -> [  self fileInMemberNamed: memberName  ].	} otherwise: [		('t*xt' match: extension) ifTrue: [ self openTextFile: memberName ]			ifFalse: [ stream := member contentStream.		isGraphic := ImageReadWriter understandsImageFormat: stream.		stream reset.		isGraphic			ifTrue: [ self openGraphicsFile: member ]			ifFalse: [ "now what?" ^false ]]	].	^true! !!SARInstaller methodsFor: 'private' stamp: 'nk 7/10/2003 16:55' prior: 28731044!installed: aMemberOrName	self installedMembers add: (self zip member: aMemberOrName)! !!SARInstaller methodsFor: 'accessing' stamp: 'nk 7/5/2003 23:01' prior: 28712443!installedMemberNames	"Answer the names of the zip members that have been installed already."	^self installedMembers collect: [ :ea | ea fileName ]! !!SARInstaller methodsFor: 'accessing' stamp: 'nk 7/10/2003 16:53' prior: 28712663!installedMembers	"Answer the zip members that have been installed already."	^installed ifNil: [ installed := OrderedCollection new ]! !!SARInstaller methodsFor: 'client services' stamp: 'nk 7/5/2003 10:02' prior: 28726434!memberNameForProjectNamed: projectName	"Answer my member name for the given project, or nil.	Ignores version numbers and suffixes, and also unescapes percents in filenames."	^self zip memberNames detect: [ :memberName | | triple |		triple := Project parseProjectFileName: memberName unescapePercents.		triple first asLowercase = projectName asLowercase	] ifNone: [ nil ].! !!SARInstaller methodsFor: 'client services' stamp: 'nk 10/14/2003 18:58' prior: 28726890!memberNamed: aString	^(zip member: aString)		ifNil: [ | matching |			matching := zip membersMatching: aString.			matching isEmpty ifFalse: [ matching last ]].! !!SARInstaller methodsFor: 'accessing' stamp: 'nk 7/5/2003 21:57' prior: 28712867!memberNames	^self zip memberNames! !!SARInstaller methodsFor: 'client services' stamp: 'nk 10/27/2002 10:34' prior: 28727130!membersMatching: aString	^self zip membersMatching: aString! !!SARInstaller methodsFor: 'client services' stamp: 'nk 6/12/2004 10:03' prior: 28727268!openGraphicsFile: memberOrName	| member morph |	member := self memberNamed: memberOrName.	member ifNil: [ ^self errorNoSuchMember: memberOrName ].	morph := (World drawingClass fromStream: member contentStream binary).	morph ifNotNil: [ morph openInWorld ].	self installed: member.! !!SARInstaller methodsFor: 'client services' stamp: 'nk 7/5/2003 22:28' prior: 28727629!openTextFile: memberOrName	"Open a text window on the given member"	| member |	member := self memberNamed: memberOrName.	member ifNil: [ ^self errorNoSuchMember: memberOrName ].	StringHolder new		acceptContents: member contents;		openLabel: member fileName.	self installed: member.! !!SARInstaller methodsFor: 'client services' stamp: 'nk 10/27/2002 10:36' prior: 28727996!prependedDataSize	^self zip prependedDataSize! !!SARInstaller methodsFor: 'accessing' stamp: 'nk 7/5/2003 23:00' prior: 28712972!uninstalledMemberNames	"Answer the names of the zip members that have not yet been installed."	^self uninstalledMembers collect: [ :ea | ea fileName ]! !!SARInstaller methodsFor: 'accessing' stamp: 'nk 7/10/2003 16:55' prior: 28713196!uninstalledMembers	"Answer the zip members that haven't been installed or extracted yet."	^zip members copyWithoutAll: self installedMembers! !!SARInstaller methodsFor: 'accessing' stamp: 'nk 10/25/2002 12:16' prior: 28713411!zip	^zip! !!SARInstaller methodsFor: 'accessing' stamp: 'nk 10/25/2002 12:16' prior: 28713493!zip: anObject	^zip := anObject! !!SARInstaller methodsFor: 'client services' stamp: 'nk 10/27/2002 10:35' prior: 28728121!zipFileComment	^self zip zipFileComment! !!SARInstaller class methodsFor: 'class initialization' stamp: 'nk 7/5/2003 22:22' prior: 28735609!unload	(FileList respondsTo: #unregisterFileReader:)		ifTrue: [ FileList unregisterFileReader: self ]! !Object subclass: #MczInstaller	instanceVariableNames: 'stream fileName zip'	classVariableNames: 'Versions'	poolDictionaries: ''	category: 'Installer-Formats'!!MczInstaller class methodsFor: 'services' stamp: 'avi 3/7/2004 14:51' prior: 24002600!initialize	self clearVersionInfo.	self registerForFileList.! !!MczInstaller class methodsFor: 'versionInfo' stamp: 'avi 1/19/2004 13:13' prior: 24003389!clearVersionInfo	Versions := Dictionary new! !!MczInstaller class methodsFor: 'services' stamp: 'cwp 8/7/2003 18:49' prior: 24002287!extension	^ 'mcz'! !!MczInstaller class methodsFor: 'services' stamp: 'nk 6/8/2004 17:29' prior: 24002381!fileReaderServicesForFile: fileName suffix: suffix	^({ self extension. '*' } includes: suffix)		ifTrue: [ self services ]		ifFalse: [#()].! !!MczInstaller class methodsFor: 'installing' stamp: 'kph 2/24/2009 07:11'!install: fileName stream: aStream	(self on: aStream) fileName: fileName; install! !!MczInstaller class methodsFor: 'installing' stamp: 'kph 2/24/2009 07:03' prior: 24001864!installFileNamed: aFileName	self install: aFileName stream: (FileStream readOnlyFileNamed: aFileName)! !!MczInstaller class methodsFor: 'installing' stamp: 'kph 2/24/2009 07:05' prior: 24002033!installStream: aStream	self deprecated: 'use install: aFileName stream: aStream'. 	(self on: aStream) install! !!MczInstaller class methodsFor: 'services' stamp: 'cwp 8/7/2003 18:54' prior: 24002738!loadVersionFile: fileName	self installFileNamed: fileName! !!MczInstaller class methodsFor: 'instance creation' stamp: 'cwp 8/7/2003 17:56' prior: 24002170!on: aStream	^ self new stream: aStream! !!MczInstaller class methodsFor: 'services' stamp: 'avi 3/7/2004 14:49' prior: 24002874!registerForFileList	Smalltalk at: #MCReader ifAbsent: [FileList registerFileReader: self]! !!MczInstaller class methodsFor: 'services' stamp: 'cwp 8/7/2003 18:53' prior: 24003041!serviceLoadVersion	^ SimpleServiceEntry		provider: self		label: 'load'		selector: #loadVersionFile:		description: 'load a package version'! !!MczInstaller class methodsFor: 'services' stamp: 'ab 8/8/2003 18:01' prior: 24003260!services	^ Array with: self serviceLoadVersion! !!MczInstaller class methodsFor: 'versionInfo' stamp: 'cwp 8/11/2003 23:49' prior: 24003513!storeVersionInfo: aVersion	Versions 		at: aVersion package name		put: aVersion info asDictionary! !!MczInstaller class methodsFor: 'versionInfo' stamp: 'avi 3/7/2004 14:51' prior: 24003692!unloadMonticello	"self unloadMonticello"	Utilities breakDependents.		Smalltalk at: #MCWorkingCopy ifPresent:		[:wc | 		wc allInstances do:			[:ea | 			Versions at: ea package name put: ea currentVersionInfo asDictionary.			ea breakDependents.			Smalltalk at: #SystemChangeNotifier ifPresent: [:scn | scn uniqueInstance noMoreNotificationsFor: ea]]	displayingProgress: 'Saving version info...'].		"keep things simple and don't unload any class extensions"	(ChangeSet superclassOrder: ((PackageInfo named: 'Monticello') classes)) reverseDo:		[:ea | 		ea removeFromSystem].		self registerForFileList.! !!MczInstaller class methodsFor: 'versionInfo' stamp: 'avi 2/17/2004 02:49' prior: 24004388!versionInfo	^ Versions! !!MczInstaller methodsFor: 'utilities' stamp: 'avi 1/20/2004 11:13' prior: 23999324!associate: tokens	| result |	result := Dictionary new.	tokens pairsDo: [:key :value | 					value isString ifFalse: [value := value collect: [:ea | self associate: ea]].					value = 'nil' ifTrue: [value := ''].					result at: key put: value].	^ result! !!MczInstaller methodsFor: 'utilities' stamp: 'avi 2/17/2004 02:53' prior: 23999651!checkDependencies	| dependencies unmet |	dependencies := (zip membersMatching: 'dependencies/*') 			collect: [:member | self extractInfoFrom: (self parseMember: member)].	unmet := dependencies reject: [:dep |		self versions: Versions anySatisfy: (dep at: #id)].	^ unmet isEmpty or: [		self confirm: (String streamContents: [:s|			s nextPutAll: 'The following dependencies seem to be missing:'; cr.			unmet do: [:each | s nextPutAll: (each at: #name); cr].			s nextPutAll: 'Do you still want to install this package?'])]! !!MczInstaller methodsFor: 'utilities' stamp: 'avi 2/17/2004 03:26' prior: 24000251!extractInfoFrom: dict	dict at: #id put: (UUID fromString: (dict at: #id)).	dict at: #date ifPresent: [:d | d isEmpty ifFalse: [dict at: #date put: (Date fromString: d)]].	dict at: #time ifPresent: [:t | t isEmpty ifFalse: [dict at: #time put: (Time readFrom: t readStream)]].	dict at: #ancestors ifPresent: [:a | dict at: #ancestors put: (a collect: [:ea | self extractInfoFrom: ea])].	^ dict! !!MczInstaller methodsFor: 'accessing' stamp: 'cwp 8/13/2003 01:58' prior: 23998061!extractPackageName	^ (self parseMember: 'package') at: #name.	! !!MczInstaller methodsFor: 'accessing' stamp: 'cwp 8/13/2003 02:17' prior: 23998198!extractVersionInfo	^ self extractInfoFrom: (self parseMember: 'version')! !!MczInstaller methodsFor: 'accessing' stamp: 'kph 2/24/2009 07:01'!fileName: aFileName	fileName := aFileName! !!MczInstaller methodsFor: 'installation' stamp: 'kph 2/24/2009 07:14' prior: 23998711!install	| sources |		self unregisterPackage.		zip := ZipArchive new.	zip readFrom: stream.	self checkDependencies ifFalse: [^false].	self recordVersionInfo.	sources := (zip membersMatching: 'snapshot/*') 				asSortedCollection: [:a :b | a fileName < b fileName].	sources do: [:src | self installMember: src].! !!MczInstaller methodsFor: 'installation' stamp: 'kph 2/24/2009 07:02' prior: 23999074!installMember: member	 | str |	self useNewChangeSetDuring:		[str := member contentStream text.		str setConverterForCode.		str fileInAnnouncing: 'booting ', (fileName ifNil: [ member fileName ])]! !!MczInstaller methodsFor: 'installation' stamp: 'kph 2/24/2009 07:12'!packageName		^ fileName copyUpToLast: $-.! !!MczInstaller methodsFor: 'utilities' stamp: 'cwp 8/13/2003 01:58' prior: 24000721!parseMember: fileName	| tokens |	tokens := (self scanner scanTokens: (zip contentsOf: fileName)) first.	^ self associate: tokens! !!MczInstaller methodsFor: 'accessing' stamp: 'cwp 8/7/2003 19:18' prior: 23998343!recordVersionInfo	Versions 		at: self extractPackageName 		put: self extractVersionInfo! !!MczInstaller methodsFor: 'accessing' stamp: 'cwp 8/13/2003 02:04' prior: 23998506!scanner	^ Scanner new! !!MczInstaller methodsFor: 'accessing' stamp: 'avi 2/17/2004 02:55' prior: 23998601!stream: aStream	stream := aStream! !!MczInstaller methodsFor: 'installation' stamp: 'kph 2/24/2009 07:14'!unregisterPackage		| pkg |	pkg := self packageName.		((Smalltalk at: #MCWorkingCopy ifAbsent: [ ^ nil ])		allManagers select:  [:each | each packageName = pkg ] ) do: [ :ea | ea unregister ].! !!MczInstaller methodsFor: 'utilities' stamp: 'bf 2/9/2004 13:56' prior: 24000922!useNewChangeSetDuring: aBlock	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := ChangeSet new name: (ChangeSet uniqueNameLike: self extractPackageName).	changeHolder newChanges: newChanges.	[aBlock value] ensure: [changeHolder newChanges: oldChanges].! !!MczInstaller methodsFor: 'utilities' stamp: 'bf 2/9/2004 15:00' prior: 24001475!versions: aVersionList anySatisfy: aDependencyID	^ aVersionList anySatisfy: [:version | 			aDependencyID = (version at: #id)				or: [self versions: (version at: #ancestors) anySatisfy: aDependencyID]]! !SARInstaller initialize!MczInstaller initialize!----End fileIn of a ReadStream 'SystemOrganization addCategory: #''Installer-Formats''!!Model subclass: #SARInstaller	instanceVariableNames: ''zip directory fileName installed''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Installer-Formats''!!!!SARInstaller commentStamp: ''nk 7/5/2003 21:12'' prior: 0!!I am an object that handles the loading of SAR (Squeak ARchive) files.A SAR file is a Zip file that follows certain simple conventions:* it may have a member named "install/preamble".This member, if present, will be filed in as Smalltalk source code at the beginning of installation.Typically, the code in the preamble will make whatever installation preparations are necessary,and will then call methods in the "client services" method category to extract or install other zip members.* It may have a member named "install/postscript".This member, if present, will be filed in as Smalltalk source code at the end of installation.Typically, the code in the postscript will set up the operating environment,and will perhaps put objects in flaps, open projects or README files, or launch samples.Within the code in the preamble and postscript, "self" is set to the instance of the SARInstaller.If neither an "install/preamble" nor an "install/postscript" file is present,all the members will be installed after prompting the user,based on a best guess of the member file types that is based on member filename extensions.This is new behavior.!!!!SARInstaller class methodsFor: ''class initialization'' stamp: ''nk 7/5/2003 22:22''!!initialize	"SARInstaller initialize"	(FileList respondsTo: #registerFileReader:)		ifTrue: [ FileList registerFileReader: self ]!! !!!!SARInstaller class methodsFor: ''change set utilities'' stamp: ''pk 10/17/2006 09:42''!!basicNewChangeSet: newName	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs basicNewChangeSet: newName ].	(self changeSetNamed: newName) ifNotNil: [ self inform: ''Sorry that name is already used''. ^nil ].	^ChangeSet basicNewNamed: newName.!! !!!!SARInstaller class methodsFor: ''SqueakMap'' stamp: ''nk 7/21/2003 17:21''!!cardForSqueakMap: aSqueakMap	"Answer the current card or a new card."	(aSqueakMap cardWithId: self squeakMapPackageID)		ifNotNilDo: [ :card |			(card installedVersion = self squeakMapPackageVersion) ifTrue: [ ^card ]		].	^self newCardForSqueakMap: aSqueakMap!! !!!!SARInstaller class methodsFor: ''change set utilities'' stamp: ''pk 10/17/2006 09:42''!!changeSetNamed: newName	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs changeSetNamed: newName ].	^ChangeSet allInstances detect: [ :cs | cs name = newName ] ifNone: [ nil ].!! !!!!SARInstaller class methodsFor: ''change set utilities'' stamp: ''nk 7/5/2003 22:49''!!currentChangeSet	"Answer the current change set, in a way that should work in 3.5 as well"	"SARInstaller currentChangeSet"	^[ ChangeSet current ]		on: MessageNotUnderstood		do: [ :ex | ex return: Smalltalk changes ]!! !!!!SARInstaller class methodsFor: ''instance creation'' stamp: ''nk 10/27/2002 10:29''!!directory: dir fileName: fn	^(self new) directory: dir; fileName: fn; yourself.!! !!!!SARInstaller class methodsFor: ''package format support'' stamp: ''ar 9/27/2005 20:11''!!ensurePackageWithId: anIdString	self squeakMapDo: [ :sm | | card newCS |		self withCurrentChangeSetNamed: ''updates'' do: [ :cs |			newCS := cs.			card := sm cardWithId: anIdString.			(card isNil or: [ card isInstalled not or: [ card isOld ]])				ifTrue: [ sm installPackageWithId: anIdString ]		].		newCS isEmpty ifTrue: [ ChangeSet removeChangeSet: newCS ]	].!! !!!!SARInstaller class methodsFor: ''change set utilities'' stamp: ''yo 8/17/2004 10:04''!!fileIntoChangeSetNamed: aString fromStream: stream 	"We let the user confirm filing into an existing ChangeSet	or specify another ChangeSet name if	the name derived from the filename already exists.	Duplicated from SMSimpleInstaller.	Should be a class-side method."	^self withCurrentChangeSetNamed: aString		do: [ :cs | | newName |			newName := cs name.			stream setConverterForCode.			stream 				fileInAnnouncing: ''Loading '' , newName , '' into change set '''''' , newName, ''''''''.			stream close]!! !!!!SARInstaller class methodsFor: ''class initialization'' stamp: ''nk 11/13/2002 07:33''!!fileReaderServicesForFile: fullName suffix: suffix 	^(suffix = ''sar'') | (suffix = ''*'') 		ifTrue: [Array with: self serviceFileInSAR]		ifFalse: [#()]!! !!!!SARInstaller class methodsFor: ''class initialization'' stamp: ''nk 7/5/2003 21:05''!!installSAR: relativeOrFullName	FileDirectory splitName: (FileDirectory default fullNameFor: relativeOrFullName)		to: [ :dir :fileName | (self directory: (FileDirectory on: dir) fileName: fileName) fileIn ]!! !!!!SARInstaller class methodsFor: ''package format support'' stamp: ''nk 7/25/2003 14:05''!!loadDVS	"Load the DVS support from SqueakMap"	self ensurePackageWithId: ''100d59d0-bf81-4e74-a4fe-5a2fd0c6b4ec''!! !!!!SARInstaller class methodsFor: ''package format support'' stamp: ''nk 9/9/2003 12:08''!!loadMonticello	"Load Monticello support (MCInstaller and Monticello) from SqueakMap"	self ensurePackageWithId: ''af9d090d-2896-4a4e-82d0-c61cf2fdf40e''.	self ensurePackageWithId: ''66236497-7026-45f5-bcf6-ad00ba7a8a4e''.!! !!!!SARInstaller class methodsFor: ''package format support'' stamp: ''nk 7/25/2003 14:39''!!loadMonticelloCVS	"Load MonticelloCVS support from SqueakMap"	self ensurePackageWithId: ''2be9f7e2-1de2-4eb6-89bd-ec9b60593a93''.!! !!!!SARInstaller class methodsFor: ''SqueakMap'' stamp: ''nk 7/21/2003 17:17''!!newCardForSqueakMap: aSqueakMap	"Answer a new card."	^(aSqueakMap newCardWithId: self squeakMapPackageID)	created: 3236292323	updated:3236292323	name: ''SARInstaller for 3.6''	currentVersion:''16''	summary: ''Lets you load SAR (Squeak ARchive) files from SqueakMap and the File List. For 3.6 and later images.''	description:''Support for installing SAR (Squeak ARchive) packages from SqueakMap and the File List.For 3.6 and later images.SMSARInstaller will use this if it''''s present to load SAR packages.Use SARBuilder for making these packages easily.''	url: ''http://bike-nomad.com/squeak/''	downloadUrl:''http://bike-nomad.com/squeak/SARInstallerFor36-nk.16.cs.gz''	author: ''Ned Konz <ned@bike-nomad.com>''	maintainer:''Ned Konz <ned@bike-nomad.com>''	registrator:''Ned Konz <ned@bike-nomad.com>''	password:240495131608326995113451940367316491071470713347	categories: #(''6ba57b6e-946a-4009-beaa-0ac93c08c5d1'' ''94277ca9-4d8f-4f0e-a0cb-57f4b48f1c8a'' ''a71a6233-c7a5-4146-b5e3-30f28e4d3f6b'' ''8209da9b-8d6e-40dd-b23a-eb7e05d4677b'' );	modulePath: ''''	moduleVersion:''''	moduleTag:''''	versionComment:''v16: same as v16 of SARInstaller for 3.4 but doesn''''t include any classes other than SARInstaller.To be loaded into 3.6 images only. Will de-register the 3.4 version if it''''s registered.Added a default (DWIM) mode in which SAR files that are missing both a preamble and postscript have all their members loaded in a default manner.Changed the behavior of #extractMemberWithoutPath: to use the same directory as the SAR itself.Added #extractMemberWithoutPath:inDirectory:Moved several change set methods to the class side.Made change set methods work with 3.5 or 3.6a/bNow supports the following file types:Projects (with or without construction of a ViewMorph)Genie gesture dictionariesChange setsDVS packagesMonticello packagesGraphics files (loaded as SketchMorphs)Text files (loaded as text editor windows)Morph(s) in filesNow keeps track of installed members.''!! !!!!SARInstaller class methodsFor: ''change set utilities'' stamp: ''nk 7/5/2003 22:51''!!newChanges: aChangeSet	"Change the current change set, in a way that should work in 3.5 as well"	"SARInstaller newChanges: SARInstaller currentChangeSet"	^[ ChangeSet newChanges: aChangeSet ]		on: MessageNotUnderstood		do: [ :ex | ex return: (Smalltalk newChanges: aChangeSet) ]!! !!!!SARInstaller class methodsFor: ''class initialization'' stamp: ''nk 11/13/2002 07:35''!!serviceFileInSAR	"Answer a service for opening a changelist browser on a file"	^ SimpleServiceEntry 		provider: self 		label: ''install SAR''		selector: #installSAR:		description: ''install this Squeak ARchive into the image.''		buttonLabel: ''install''!! !!!!SARInstaller class methodsFor: ''class initialization'' stamp: ''nk 11/21/2002 09:46''!!services	^Array with: self serviceFileInSAR!! !!!!SARInstaller class methodsFor: ''package format support'' stamp: ''nk 7/25/2003 08:27''!!squeakMapDo: aBlock	"If SqueakMap is installed, evaluate aBlock with the default map.	Otherwise, offer to install SqueakMap and continue."	Smalltalk at: #SMSqueakMap ifPresent: [ :smClass | ^aBlock value: smClass default ].	(self confirm: ''SqueakMap is not installed in this image.Would you like to load it from the network?'')		ifTrue: [ TheWorldMenu loadSqueakMap.			^self squeakMapDo: aBlock ].	^nil!! !!!!SARInstaller class methodsFor: ''SqueakMap'' stamp: ''nk 7/21/2003 17:16''!!squeakMapPackageID	^''75c970ab-dca7-48ee-af42-5a013912c880''!! !!!!SARInstaller class methodsFor: ''SqueakMap'' stamp: ''nk 7/21/2003 17:18''!!squeakMapPackageVersion	^''16''!! !!!!SARInstaller class methodsFor: ''change set utilities'' stamp: ''rbb 3/1/2005 11:11''!!withCurrentChangeSetNamed: aString do: aOneArgumentBlock 	"Evaluate the one-argument block aOneArgumentBlock while the named change set is active.	We let the user confirm operating on an existing ChangeSet 	or specify another ChangeSet name if 	the name derived from the filename already exists. 	Duplicated from SMSimpleInstaller. 	Returns change set."	| changeSet newName oldChanges |	newName := aString.	changeSet := self changeSetNamed: newName.	changeSet ifNotNil: 			[newName := UIManager default 						request: ''ChangeSet already present, just confirm to overwrite or enter a new name:''						initialAnswer: newName.			newName isEmpty ifTrue: [self error: ''Cancelled by user''].			changeSet := self changeSetNamed: newName].	changeSet ifNil: [changeSet := self basicNewChangeSet: newName].	changeSet 		ifNil: [self error: ''User did not specify a valid ChangeSet name''].	oldChanges := self currentChangeSet.		[ self newChanges: changeSet.	aOneArgumentBlock value: changeSet] 			ensure: [ self newChanges: oldChanges].	^changeSet!! !!!!SARInstaller methodsFor: ''accessing'' stamp: ''nk 10/25/2002 12:16''!!directory	^directory!! !!!!SARInstaller methodsFor: ''accessing'' stamp: ''nk 10/25/2002 12:16''!!directory: anObject	directory := anObject!! !!!!SARInstaller methodsFor: ''private'' stamp: ''nk 10/13/2003 12:56''!!errorNoSuchMember: aMemberName	(self confirm: ''No member named '', aMemberName, ''. Do you want to stop loading?'')		== true ifTrue: [ self error: ''aborted'' ].!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 7/5/2003 22:25''!!extractMember: aMemberOrName	"Extract aMemberOrName to a file using its filename"	(self zip extractMember: aMemberOrName)		ifNil: [ self errorNoSuchMember: aMemberOrName ]		ifNotNil: [ self installed: aMemberOrName ].!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 7/5/2003 22:25''!!extractMember: aMemberOrName toFileNamed: aFileName	"Extract aMemberOrName to a specified filename"	(self zip extractMember: aMemberOrName toFileNamed: aFileName)		ifNil: [ self errorNoSuchMember: aMemberOrName ]		ifNotNil: [ self installed: aMemberOrName ].!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 7/5/2003 22:40''!!extractMemberWithoutPath: aMemberOrName	"Extract aMemberOrName to its own filename, but ignore any directory paths, using my directory instead."	self extractMemberWithoutPath: aMemberOrName inDirectory: self directory.!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 7/5/2003 22:40''!!extractMemberWithoutPath: aMemberOrName inDirectory: aDirectory	"Extract aMemberOrName to its own filename, but ignore any directory paths, using aDirectory instead"	| member |	member := self memberNamed: aMemberOrName.	member ifNil: [ ^self errorNoSuchMember: aMemberOrName ].	self zip extractMemberWithoutPath: member inDirectory: aDirectory.	self installed: member.!! !!!!SARInstaller methodsFor: ''fileIn'' stamp: ''ar 9/27/2005 20:10''!!fileIn	"File in to a change set named like my file"	| stream newCS |	stream := directory readOnlyFileNamed: fileName.	self class withCurrentChangeSetNamed: fileName		do: [:cs | newCS := cs. self fileInFrom: stream].	newCS isEmpty ifTrue: [ ChangeSet removeChangeSet: newCS ]!! !!!!SARInstaller methodsFor: ''fileIn'' stamp: ''yo 8/17/2004 00:33''!!fileInFrom: stream	"The zip has been saved already by the download.	Read the zip into my instvar, then file in the correct members"	| preamble postscript |	[		stream position: 0.		zip := ZipArchive new readFrom: stream.		preamble := zip memberNamed: ''install/preamble''.		preamble ifNotNil: [			preamble contentStream text setConverterForCode fileInFor: self announcing: ''Preamble''.			self class currentChangeSet preambleString: preamble contents.		].		postscript := zip memberNamed: ''install/postscript''.		postscript ifNotNil: [			postscript contentStream text setConverterForCode fileInFor: self announcing: ''Postscript''.			self class currentChangeSet postscriptString: postscript contents.		].		preamble isNil & postscript isNil ifTrue: [			(self confirm: ''No install/preamble or install/postscript member were found.	Install all the members automatically?'') ifTrue: [ self installAllMembers ]		].	] ensure: [ stream close ].!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 2/13/2004 12:12''!!fileInGenieDictionaryNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as Genie gesture dictionaries.	Answers a dictionary."	| member object crDictionary stream |	crDictionary := Smalltalk at: #CRDictionary ifAbsent: [ ^self error: ''Genie not installed'' ].	"don''t know how to recursively load"	member := self memberNamed: memberName.	member ifNil: [ ^self errorNoSuchMember: memberName ].	stream := ReferenceStream on: member contentStream.	[ object := stream next ]		on: Error do: 		[:ex |  stream close.		self inform: ''Error on loading: '' , ex description. ^ nil ].	stream close.	(object notNil and: [object name isEmptyOrNil])		ifTrue: [object := crDictionary name: object storedName].	self installed: member.	^ object!! !!!!SARInstaller methodsFor: ''private'' stamp: ''ar 9/27/2005 20:10''!!fileInMCVersion: member withBootstrap: mcBootstrap	"This will use the MCBootstrapLoader to load a (non-compressed) Monticello file (.mc or .mcv)"	| newCS |	self class withCurrentChangeSetNamed: member localFileName		do: [ :cs | 			newCS := cs.			mcBootstrap loadStream: member contentStream ascii ].	newCS isEmpty ifTrue: [ ChangeSet removeChangeSet: newCS ].	World doOneCycle.	self installed: member.!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''yo 8/17/2004 10:01''!!fileInMemberNamed: csName	"This is to be used from preamble/postscript code to file in zip members as ChangeSets."	| cs |	cs := self memberNamed: csName.	cs ifNil: [ ^self errorNoSuchMember: csName ].	self class fileIntoChangeSetNamed: csName fromStream: cs contentStream text setConverterForCode.	self installed: cs.!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''ar 9/27/2005 20:10''!!fileInMonticelloPackageNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as Monticello packages (.mc)."	| member file mcPackagePanel mcRevisionInfo mcSnapshot mcFilePackageManager mcPackage info snapshot newCS mcBootstrap |	mcPackagePanel := Smalltalk at: #MCPackagePanel ifAbsent: [ ].	mcRevisionInfo := Smalltalk at: #MCRevisionInfo ifAbsent: [ ].	mcSnapshot := Smalltalk at: #MCSnapshot ifAbsent: [ ].	mcFilePackageManager := Smalltalk at: #MCFilePackageManager ifAbsent: [ ].	mcPackage := Smalltalk at: #MCPackage ifAbsent: [ ].	member := self memberNamed: memberName.	member ifNil: [ ^self errorNoSuchMember: memberName ].	"We are missing MCInstaller, Monticello and/or MonticelloCVS.	If the bootstrap is present, use it. Otherwise interact with the user."	({ mcPackagePanel. mcRevisionInfo. mcSnapshot. mcFilePackageManager. mcPackage } includes: nil)		ifTrue: [			mcBootstrap := self getMCBootstrapLoaderClass.			mcBootstrap ifNotNil: [ ^self fileInMCVersion: member withBootstrap: mcBootstrap ].			(self confirm: (''Monticello support is not installed, but must be to load member named '', memberName, ''.Load it from SqueakMap?''))				ifTrue: [ self class loadMonticello; loadMonticelloCVS.					^self fileInMonticelloPackageNamed: memberName ]				ifFalse: [ ^false ] ].	member extractToFileNamed: member localFileName inDirectory: self directory.	file := (Smalltalk at: #MCFile)				name: member localFileName				directory: self directory.	self class withCurrentChangeSetNamed: file name do: [ :cs |		newCS := cs.		file readStreamDo: [ :stream |			info := mcRevisionInfo readFrom: stream nextChunk.			snapshot := mcSnapshot fromStream: stream ].			snapshot install.			(mcFilePackageManager forPackage:				(mcPackage named: info packageName))					file: file		].	newCS isEmpty ifTrue: [ ChangeSet removeChangeSet: newCS ].	mcPackagePanel allSubInstancesDo: [ :ea | ea refresh ].	World doOneCycle.	self installed: member.!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''ar 9/27/2005 20:10''!!fileInMonticelloVersionNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as Monticello version (.mcv) files."	| member newCS mcMcvReader |	mcMcvReader := Smalltalk at: #MCMcvReader ifAbsent: [].	member := self memberNamed: memberName.	member ifNil: [^self errorNoSuchMember: memberName].	"If we don''t have Monticello, offer to get it."	mcMcvReader ifNil:  [		(self confirm: ''Monticello is not installed, but must be to load member named '', memberName , ''.Load it from SqueakMap?'') 			ifTrue:  [ self class loadMonticello.						^self fileInMonticelloVersionNamed: memberName]					ifFalse: [^false]].	self class withCurrentChangeSetNamed: member localFileName		do: 			[:cs | 			newCS := cs.			(mcMcvReader versionFromStream: member contentStream ascii) load ].	newCS isEmpty ifTrue: [ChangeSet removeChangeSet: newCS].	World doOneCycle.	self installed: member!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''ar 9/27/2005 20:10''!!fileInMonticelloZipVersionNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as Monticello version (.mcz) files."	| member mczInstaller newCS mcMczReader |	mcMczReader := Smalltalk at: #MCMczReader ifAbsent: [].	mczInstaller := Smalltalk at: #MczInstaller ifAbsent: [].	member := self memberNamed: memberName.	member ifNil: [^self errorNoSuchMember: memberName].	"If we don''t have Monticello, but have the bootstrap, use it silently."	mcMczReader ifNil:  [		mczInstaller ifNotNil: [ ^mczInstaller installStream: member contentStream ].		(self confirm: ''Monticello is not installed, but must be to load member named '', memberName , ''.Load it from SqueakMap?'') 			ifTrue:  [ self class loadMonticello.						^self fileInMonticelloZipVersionNamed: memberName]					ifFalse: [^false]].	self class withCurrentChangeSetNamed: member localFileName		do: 			[:cs | 			newCS := cs.			(mcMczReader versionFromStream: member contentStream) load ].	newCS isEmpty ifTrue: [ChangeSet removeChangeSet: newCS].	World doOneCycle.	self installed: member!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 7/5/2003 22:27''!!fileInMorphsNamed: memberName addToWorld: aBoolean	"This will load the Morph (or Morphs) from the given member.	Answers a Morph, or a list of Morphs, or nil if no such member or error.	If aBoolean is true, also adds them and their models to the World."	| member morphOrList |	member := self memberNamed: memberName.	member ifNil: [ ^self errorNoSuchMember: memberName ].	self installed: member.	morphOrList := member contentStream fileInObjectAndCode.	morphOrList ifNil: [ ^nil ].	aBoolean ifTrue: [ ActiveWorld addMorphsAndModel: morphOrList ].	^morphOrList!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''yo 8/17/2004 10:05''!!fileInPackageNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as DVS packages."	| member current new baseName imagePackageLoader packageInfo streamPackageLoader packageManager |	member := self zip memberNamed: memberName.	member ifNil: [ ^self errorNoSuchMember: memberName ].	imagePackageLoader := Smalltalk at: #ImagePackageLoader ifAbsent: [].	streamPackageLoader := Smalltalk at: #StreamPackageLoader ifAbsent: [].	packageInfo := Smalltalk at: #PackageInfo ifAbsent: [].	packageManager := Smalltalk at: #FilePackageManager ifAbsent: [].	"If DVS isn''t present, do a simple file-in"	(packageInfo isNil or: [imagePackageLoader isNil or: [streamPackageLoader isNil]])		ifTrue: [ ^ self fileInMemberNamed: memberName ].	baseName := memberName copyReplaceAll: ''.st'' with: '''' asTokens: false.	(packageManager allManagers anySatisfy: [ :pm | pm packageName = baseName ])		ifTrue: [			current := imagePackageLoader new package: (packageInfo named: baseName).			new := streamPackageLoader new stream: member contentStream ascii.			(new changesFromBase: current) fileIn ]		ifFalse: [ self class fileIntoChangeSetNamed: baseName fromStream: member contentStream ascii setConverterForCode. ].	packageManager registerPackage: baseName.	self installed: member.!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 7/27/2003 09:49''!!fileInProjectNamed: projectOrMemberName createView: aBoolean 	"This is to be used from preamble/postscript code to file in SAR members 	as Projects. 	Answers the loaded project, or nil. 	Does not enter the loaded project. 	If aBoolean is true, also creates a ProjectViewMorph 	(possibly in a window, depending on your Preferences)."	| member project triple memberName |	member := self memberNamed: projectOrMemberName.	member		ifNotNil: [ memberName := member fileName ]		ifNil: [ 	member := self memberNamed: (memberName := self memberNameForProjectNamed: projectOrMemberName) ].	member ifNil: [ ^self errorNoSuchMember: projectOrMemberName ].	triple := Project parseProjectFileName: memberName unescapePercents.	project := nil.	[[ProjectLoading		openName: triple first		stream: member contentStream		fromDirectory: nil		withProjectView: nil]		on: ProjectViewOpenNotification		do: [:ex | ex resume: aBoolean]]		on: ProjectEntryNotification		do: [:ex | 			project := ex projectToEnter.			ex resume].	self installed: member.	^ project!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 9/26/2003 17:17''!!fileInTrueTypeFontNamed: memberOrName	| member description |	member := self memberNamed: memberOrName.	member ifNil: [^self errorNoSuchMember: memberOrName].	description := TTFontDescription addFromTTStream: member contentStream.	TTCFont newTextStyleFromTT: description.	World doOneCycle.	self installed: member!! !!!!SARInstaller methodsFor: ''fileIn'' stamp: ''nk 7/27/2003 14:02''!!fileIntoChangeSetNamed: aString fromStream: stream	"Not recommended for new code"	^self class fileIntoChangeSetNamed: aString fromStream: stream!! !!!!SARInstaller methodsFor: ''accessing'' stamp: ''nk 10/25/2002 12:16''!!fileName	^fileName!! !!!!SARInstaller methodsFor: ''accessing'' stamp: ''nk 10/25/2002 12:16''!!fileName: anObject	fileName := anObject!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 9/9/2003 11:56''!!getMCBootstrapLoaderClass	^Smalltalk at: #MCBootstrapLoader		ifAbsent: 			[(self memberNamed: ''MCBootstrapLoader.st'') 				ifNotNilDo: [:m | self fileInMemberNamed: m.					Smalltalk at: #MCBootstrapLoader ifAbsent: []]]!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 10/14/2003 15:40''!!importImage: memberOrName	| member form |	member := self memberNamed: memberOrName.	member ifNil: [ ^self errorNoSuchMember: memberOrName ].	form := ImageReadWriter formFromStream: member contentStream binary.	form ifNil: [ ^self ].	Imports default importImage: form named: (FileDirectory localNameFor: member fileName) sansPeriodSuffix.	self installed: member.!! !!!!SARInstaller methodsFor: ''initialization'' stamp: ''nk 7/5/2003 22:24''!!initialize	installed := OrderedCollection new.!! !!!!SARInstaller methodsFor: ''fileIn'' stamp: ''nk 10/12/2003 20:41''!!installAllMembers	"Try to install all the members, in order, based on their filenames and/or contents."	| uninstalled |	uninstalled := OrderedCollection new.	zip members do: [ :member | self installMember: member ].	uninstalled := self uninstalledMembers.	uninstalled isEmpty ifTrue: [ ^self ].	uninstalled inspect.!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''tak 1/24/2005 19:12''!!installMember: memberOrName	| memberName extension isGraphic stream member |	member := self memberNamed: memberOrName.	member ifNil: [ ^false ].	memberName := member fileName.	extension := (FileDirectory extensionFor: memberName) asLowercase.	Smalltalk at: #CRDictionary ifPresent: [ :crDictionary |		(extension = crDictionary fileNameSuffix) ifTrue: [  self fileInGenieDictionaryNamed: memberName. ^true ] ].	extension caseOf: {		[ Project projectExtension ] -> [ self fileInProjectNamed: memberName createView: true ].		[ FileStream st ] -> [ self fileInPackageNamed: memberName ].		[ FileStream cs ] -> [  self fileInMemberNamed: memberName  ]."		[ FileStream multiSt ] -> [  self fileInMemberNamedAsUTF8: memberName  ].		[ FileStream multiCs ] -> [  self fileInMemberNamedAsUTF8: memberName  ]."		[ ''mc'' ] -> [ self fileInMonticelloPackageNamed: memberName ].		[ ''mcv'' ] -> [ self fileInMonticelloVersionNamed: memberName ].		[ ''mcz'' ] -> [ self fileInMonticelloZipVersionNamed: memberName ].		[ ''morph'' ] -> [ self fileInMorphsNamed: member addToWorld: true ].		[ ''ttf'' ] -> [ self fileInTrueTypeFontNamed: memberName ].		[ ''translation'' ] -> [  self fileInMemberNamed: memberName  ].	} otherwise: [		(''t*xt'' match: extension) ifTrue: [ self openTextFile: memberName ]			ifFalse: [ stream := member contentStream.		isGraphic := ImageReadWriter understandsImageFormat: stream.		stream reset.		isGraphic			ifTrue: [ self openGraphicsFile: member ]			ifFalse: [ "now what?" ^false ]]	].	^true!! !!!!SARInstaller methodsFor: ''private'' stamp: ''nk 7/10/2003 16:55''!!installed: aMemberOrName	self installedMembers add: (self zip member: aMemberOrName)!! !!!!SARInstaller methodsFor: ''accessing'' stamp: ''nk 7/5/2003 23:01''!!installedMemberNames	"Answer the names of the zip members that have been installed already."	^self installedMembers collect: [ :ea | ea fileName ]!! !!!!SARInstaller methodsFor: ''accessing'' stamp: ''nk 7/10/2003 16:53''!!installedMembers	"Answer the zip members that have been installed already."	^installed ifNil: [ installed := OrderedCollection new ]!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 7/5/2003 10:02''!!memberNameForProjectNamed: projectName	"Answer my member name for the given project, or nil.	Ignores version numbers and suffixes, and also unescapes percents in filenames."	^self zip memberNames detect: [ :memberName | | triple |		triple := Project parseProjectFileName: memberName unescapePercents.		triple first asLowercase = projectName asLowercase	] ifNone: [ nil ].!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 10/14/2003 18:58''!!memberNamed: aString	^(zip member: aString)		ifNil: [ | matching |			matching := zip membersMatching: aString.			matching isEmpty ifFalse: [ matching last ]].!! !!!!SARInstaller methodsFor: ''accessing'' stamp: ''nk 7/5/2003 21:57''!!memberNames	^self zip memberNames!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 10/27/2002 10:34''!!membersMatching: aString	^self zip membersMatching: aString!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 6/12/2004 10:03''!!openGraphicsFile: memberOrName	| member morph |	member := self memberNamed: memberOrName.	member ifNil: [ ^self errorNoSuchMember: memberOrName ].	morph := (World drawingClass fromStream: member contentStream binary).	morph ifNotNil: [ morph openInWorld ].	self installed: member.!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 7/5/2003 22:28''!!openTextFile: memberOrName	"Open a text window on the given member"	| member |	member := self memberNamed: memberOrName.	member ifNil: [ ^self errorNoSuchMember: memberOrName ].	StringHolder new		acceptContents: member contents;		openLabel: member fileName.	self installed: member.!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 10/27/2002 10:36''!!prependedDataSize	^self zip prependedDataSize!! !!!!SARInstaller methodsFor: ''accessing'' stamp: ''nk 7/5/2003 23:00''!!uninstalledMemberNames	"Answer the names of the zip members that have not yet been installed."	^self uninstalledMembers collect: [ :ea | ea fileName ]!! !!!!SARInstaller methodsFor: ''accessing'' stamp: ''nk 7/10/2003 16:55''!!uninstalledMembers	"Answer the zip members that haven''t been installed or extracted yet."	^zip members copyWithoutAll: self installedMembers!! !!!!SARInstaller methodsFor: ''accessing'' stamp: ''nk 10/25/2002 12:16''!!zip	^zip!! !!!!SARInstaller methodsFor: ''accessing'' stamp: ''nk 10/25/2002 12:16''!!zip: anObject	^zip := anObject!! !!!!SARInstaller methodsFor: ''client services'' stamp: ''nk 10/27/2002 10:35''!!zipFileComment	^self zip zipFileComment!! !!!!SARInstaller class methodsFor: ''class initialization'' stamp: ''nk 7/5/2003 22:22''!!unload	(FileList respondsTo: #unregisterFileReader:)		ifTrue: [ FileList unregisterFileReader: self ]!! !!Object subclass: #MczInstaller	instanceVariableNames: ''stream fileName zip''	classVariableNames: ''Versions''	poolDictionaries: ''''	category: ''Installer-Formats''!!!!MczInstaller class methodsFor: ''services'' stamp: ''avi 3/7/2004 14:51''!!initialize	self clearVersionInfo.	self registerForFileList.!! !!!!MczInstaller class methodsFor: ''versionInfo'' stamp: ''avi 1/19/2004 13:13''!!clearVersionInfo	Versions := Dictionary new!! !!!!MczInstaller class methodsFor: ''services'' stamp: ''cwp 8/7/2003 18:49''!!extension	^ ''mcz''!! !!!!MczInstaller class methodsFor: ''services'' stamp: ''nk 6/8/2004 17:29''!!fileReaderServicesForFile: fileName suffix: suffix	^({ self extension. ''*'' } includes: suffix)		ifTrue: [ self services ]		ifFalse: [#()].!! !!!!MczInstaller class methodsFor: ''installing'' stamp: ''kph 2/24/2009 07:11''!!install: fileName stream: aStream	(self on: aStream) fileName: fileName; install!! !!!!MczInstaller class methodsFor: ''installing'' stamp: ''kph 2/24/2009 07:03''!!installFileNamed: aFileName	self install: aFileName stream: (FileStream readOnlyFileNamed: aFileName)!! !!!!MczInstaller class methodsFor: ''installing'' stamp: ''kph 2/24/2009 07:05''!!installStream: aStream	self deprecated: ''use install: aFileName stream: aStream''. 	(self on: aStream) install!! !!!!MczInstaller class methodsFor: ''services'' stamp: ''cwp 8/7/2003 18:54''!!loadVersionFile: fileName	self installFileNamed: fileName!! !!!!MczInstaller class methodsFor: ''instance creation'' stamp: ''cwp 8/7/2003 17:56''!!on: aStream	^ self new stream: aStream!! !!!!MczInstaller class methodsFor: ''services'' stamp: ''avi 3/7/2004 14:49''!!registerForFileList	Smalltalk at: #MCReader ifAbsent: [FileList registerFileReader: self]!! !!!!MczInstaller class methodsFor: ''services'' stamp: ''cwp 8/7/2003 18:53''!!serviceLoadVersion	^ SimpleServiceEntry		provider: self		label: ''load''		selector: #loadVersionFile:		description: ''load a package version''!! !!!!MczInstaller class methodsFor: ''services'' stamp: ''ab 8/8/2003 18:01''!!services	^ Array with: self serviceLoadVersion!! !!!!MczInstaller class methodsFor: ''versionInfo'' stamp: ''cwp 8/11/2003 23:49''!!storeVersionInfo: aVersion	Versions 		at: aVersion package name		put: aVersion info asDictionary!! !!!!MczInstaller class methodsFor: ''versionInfo'' stamp: ''avi 3/7/2004 14:51''!!unloadMonticello	"self unloadMonticello"	Utilities breakDependents.		Smalltalk at: #MCWorkingCopy ifPresent:		[:wc | 		wc allInstances do:			[:ea | 			Versions at: ea package name put: ea currentVersionInfo asDictionary.			ea breakDependents.			Smalltalk at: #SystemChangeNotifier ifPresent: [:scn | scn uniqueInstance noMoreNotificationsFor: ea]]	displayingProgress: ''Saving version info...''].		"keep things simple and don''t unload any class extensions"	(ChangeSet superclassOrder: ((PackageInfo named: ''Monticello'') classes)) reverseDo:		[:ea | 		ea removeFromSystem].		self registerForFileList.!! !!!!MczInstaller class methodsFor: ''versionInfo'' stamp: ''avi 2/17/2004 02:49''!!versionInfo	^ Versions!! !!!!MczInstaller methodsFor: ''utilities'' stamp: ''avi 1/20/2004 11:13''!!associate: tokens	| result |	result := Dictionary new.	tokens pairsDo: [:key :value | 					value isString ifFalse: [value := value collect: [:ea | self associate: ea]].					value = ''nil'' ifTrue: [value := ''''].					result at: key put: value].	^ result!! !!!!MczInstaller methodsFor: ''utilities'' stamp: ''avi 2/17/2004 02:53''!!checkDependencies	| dependencies unmet |	dependencies := (zip membersMatching: ''dependencies/*'') 			collect: [:member | self extractInfoFrom: (self parseMember: member)].	unmet := dependencies reject: [:dep |		self versions: Versions anySatisfy: (dep at: #id)].	^ unmet isEmpty or: [		self confirm: (String streamContents: [:s|			s nextPutAll: ''The following dependencies seem to be missing:''; cr.			unmet do: [:each | s nextPutAll: (each at: #name); cr].			s nextPutAll: ''Do you still want to install this package?''])]!! !!!!MczInstaller methodsFor: ''utilities'' stamp: ''avi 2/17/2004 03:26''!!extractInfoFrom: dict	dict at: #id put: (UUID fromString: (dict at: #id)).	dict at: #date ifPresent: [:d | d isEmpty ifFalse: [dict at: #date put: (Date fromString: d)]].	dict at: #time ifPresent: [:t | t isEmpty ifFalse: [dict at: #time put: (Time readFrom: t readStream)]].	dict at: #ancestors ifPresent: [:a | dict at: #ancestors put: (a collect: [:ea | self extractInfoFrom: ea])].	^ dict!! !!!!MczInstaller methodsFor: ''accessing'' stamp: ''cwp 8/13/2003 01:58''!!extractPackageName	^ (self parseMember: ''package'') at: #name.	!! !!!!MczInstaller methodsFor: ''accessing'' stamp: ''cwp 8/13/2003 02:17''!!extractVersionInfo	^ self extractInfoFrom: (self parseMember: ''version'')!! !!!!MczInstaller methodsFor: ''accessing'' stamp: ''kph 2/24/2009 07:01''!!fileName: aFileName	fileName := aFileName!! !!!!MczInstaller methodsFor: ''installation'' stamp: ''kph 2/24/2009 07:14''!!install	| sources |		self unregisterPackage.		zip := ZipArchive new.	zip readFrom: stream.	self checkDependencies ifFalse: [^false].	self recordVersionInfo.	sources := (zip membersMatching: ''snapshot/*'') 				asSortedCollection: [:a :b | a fileName < b fileName].	sources do: [:src | self installMember: src].!! !!!!MczInstaller methodsFor: ''installation'' stamp: ''kph 2/24/2009 07:02''!!installMember: member	 | str |	self useNewChangeSetDuring:		[str := member contentStream text.		str setConverterForCode.		str fileInAnnouncing: ''booting '', (fileName ifNil: [ member fileName ])]!! !!!!MczInstaller methodsFor: ''installation'' stamp: ''kph 2/24/2009 07:12''!!packageName		^ fileName copyUpToLast: $-.!! !!!!MczInstaller methodsFor: ''utilities'' stamp: ''cwp 8/13/2003 01:58''!!parseMember: fileName	| tokens |	tokens := (self scanner scanTokens: (zip contentsOf: fileName)) first.	^ self associate: tokens!! !!!!MczInstaller methodsFor: ''accessing'' stamp: ''cwp 8/7/2003 19:18''!!recordVersionInfo	Versions 		at: self extractPackageName 		put: self extractVersionInfo!! !!!!MczInstaller methodsFor: ''accessing'' stamp: ''cwp 8/13/2003 02:04''!!scanner	^ Scanner new!! !!!!MczInstaller methodsFor: ''accessing'' stamp: ''avi 2/17/2004 02:55''!!stream: aStream	stream := aStream!! !!!!MczInstaller methodsFor: ''installation'' stamp: ''kph 2/24/2009 07:14''!!unregisterPackage		| pkg |	pkg := self packageName.		((Smalltalk at: #MCWorkingCopy ifAbsent: [ ^ nil ])		allManagers select:  [:each | each packageName = pkg ] ) do: [ :ea | ea unregister ].!! !!!!MczInstaller methodsFor: ''utilities'' stamp: ''bf 2/9/2004 13:56''!!useNewChangeSetDuring: aBlock	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := ChangeSet new name: (ChangeSet uniqueNameLike: self extractPackageName).	changeHolder newChanges: newChanges.	[aBlock value] ensure: [changeHolder newChanges: oldChanges].!! !!!!MczInstaller methodsFor: ''utilities'' stamp: ''bf 2/9/2004 15:00''!!versions: aVersionList anySatisfy: aDependencyID	^ aVersionList anySatisfy: [:version | 			aDependencyID = (version at: #id)				or: [self versions: (version at: #ancestors) anySatisfy: aDependencyID]]!! !!SARInstaller initialize!!MczInstaller initialize!!'----!"This script bootstraps Installer, and InstallerScripts into Squeak 3.7, 3.8.1(and 3.8), 3.9, and 3.10If used as the first squeak argument, subsequent arguments are processed by Launcher. This allows a desired result to be obtained in one hit, given a virgin imagee.g.squeak Squeak3.8.1-6747-basic.image http://ftp.squeak.org/3.11/bob/LPF.st"| list wc repo getFileName getSource fileName |Transcript open.list := #('Installer-Core' 'Installer-Formats').wc := Smalltalk at: #MCWorkingCopy ifAbsent: [ nil ].wc ifNotNil: [ 	(wc allManagers select:  [:each | list includes: each packageName ]) do: [ :ea | ea unregister ] ]."uninstall previous version"list do: [ :ea | SystemOrganization removeSystemCategory: ea asSymbol ].repo := 'http://www.squeaksource.com/Installer/'.getFileName := [ :pkgName | pkgName , ((HTTPSocket httpGet: repo) upToAll: pkgName; upTo: $") ].getSource :=  [ :url | ((ZipArchive new readFrom: (HTTPSocket httpGet: url)) 			memberNamed: 'snapshot/source.st') contents ].list do: [ :pkg | 	fileName := getFileName value: pkg.				(getSource value: (repo,fileName)) readStream fileInAnnouncing: 'Booting ' , fileName.].!!InstallerScripts commentStamp: 'kph 2/23/2009 02:27' prior: 0!(self new addPackage: 'Example') options collect: [ :ea  | ea value asLegalSelector asSymbol ]  #(#scriptExampleSqueak310forKPH #scriptExampleSqueak310 #scriptExampleSqueak310)!!InstallerScripts class methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:21'!basicInstall	| selector |		self options do: [ :ea | 		selector := ea value asLegalSelector asSymbol.		(self respondsTo: selector) ifTrue: [ ^ self perform: selector ]	].	^ nil! !!InstallerScripts class methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:26'!options	^ { 		['script', self package, Smalltalk version, 'for' ,  Utilities authorInitialsPerSe asUppercase].	['script', self package, Smalltalk version].	['script', self package, SystemVersion current majorMinorVersion].		}! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 03:19'!basicInstall	| selector |		self options do: [ :ea | 		selector := ea value asLegalSelector asSymbol.		(self respondsTo: selector) ifTrue: [ self perform: selector. ^ true ]	].	^ nil! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:50'!options	^ { 		['script', self package, Smalltalk version, 'for' ,  Utilities authorInitialsPerSe asUppercase].	['script', self package, Smalltalk version].	['script', self package, SystemVersion current majorMinorVersion].	['script', self package, self product ].	['script', self package ].		}! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:53'!product	| vers |	vers := Smalltalk version.		1 to: vers size do: [ :n | (vers at: n) isDigit ifTrue: [ ^ Smalltalk version first: n-1 ] ]	"self new product"! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 04:08'!scriptLPFInstaller install: 'LevelPlayingField-Preamble'.Installer install: 'LevelPlayingField'.Installer install: 'LevelPlayingField-Postscript'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:28'!scriptLPFPreamble! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:41'!scriptLevelPlayingField	Transcript cr; show: 'Your image version is not explicitly supported by LPF yet. Contact maintainers for details'.	Installer install:'LevelPlayingField-Monticello15'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:56'!scriptLevelPlayingFieldCroquetInstaller mantis fixBug: '7087 Enable MC File in for Croquet'.Installer mantis fixBug: '7088 Parser cannot parse the selector of a method with an underscore assignment'.Installer install:'LevelPlayingField-Monticello15'.Installer ss project: 'mc'; install: 'TweakMC'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 03:01'!scriptLevelPlayingFieldLauncherLaunch Installer mantis fixBug: '6086 Improved Line End Convention Specification'.  Installer squeaksource project:'Installer';        install:  'Installer-Launcher'.  Installer mantis fixBug: '5851 Refactor SmalltalkImage saveAs'.  Transcript cr; cr; show:'You now have a level playing field.'. Transcript cr; cr; show:'Launcher now processing additional commandline parameters...'. (Smalltalk at: #Launcher) new 		actionSelector: #launchFrom: ; 		image: SmalltalkImage current; 		commandLineClass: Launcher; 		beFirstTime; 		begin; 		yourself.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 06:58'!scriptLevelPlayingFieldMonticello15(Installer url: 'http://www.squeaksource.com/mc/PackageInfo-Base') bootstrap.(Installer url: 'http://www.squeaksource.com/mc/Monticello.impl-kph.637.mcz') bootstrap.((SequenceableCollection organization categoryOfElement: #do:displayingProgress:) beginsWith: '*')ifTrue: [SequenceableCollection organization classify: #do:displayingProgress: under: #enumerating].Installer ss project:'mc';installQuietly: 'Monticello.impl-kph.637';installQuietly: 'PackageInfo-Base'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 03:45'!scriptLevelPlayingFieldMonticello15PharoInstaller installSilentlyUrl: 'http://installer.pbwiki.com/f/PackageInfo-Base-kph.67.st'.Installer installSilentlyUrl: 'http://installer.pbwiki.com/f/Monticello.impl-kph.635.st'.Installer ss project:'mc';installQuietly: 'Monticello.impl-kph.635';installQuietly: 'PackageInfo-Base'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:56'!scriptLevelPlayingFieldPharoInstaller install:'LevelPlayingField-Monticello15'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/24/2009 06:46'!scriptLevelPlayingFieldPostscriptInstaller upgrade.Smalltalk organization removeSystemCategory: 'Monticello-Tests'.(MCPackage named: 'Monticello') workingCopy unregister.(MCPackage named: 'PackageInfo') workingCopy unregister.(MCPackage named: 'MonticelloConfigurations') workingCopy unregister.SystemOrganization removeEmptyCategories.MCMethodDefinition freeSomeSpace.MCFileBasedRepository freeSomeSpace.DataStream initialize.Installer install:'LevelPlayingField-UpdateSqueakMap'. Installer install:'LevelPlayingField-LauncherLaunch'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:58'!scriptLevelPlayingFieldPreambleTranscript show: 'Preamble found:'.Installer mantis ensureFix: 7131.Installer mantis ensureFix: 7205.Installer mantis ensureFix: 7218.Installer mantis ensureFix: 7166.Installer mantis ensureFix: 7291.Installer mantis ensureFix: 6426.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:58'!scriptLevelPlayingFieldPreamblePharoTranscript show: 'All fixes are already in Pharo 10236'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:54'!scriptLevelPlayingFieldSophie	^ self scriptLevelPlayingFieldSqueak38! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:37'!scriptLevelPlayingFieldSqueak310"lets not be beta any more"SystemVersion current version: 'Squeak3.10'."fix the millisecond clock"Installer mantis ensureFix: 474.Installer mantis ensureFix: 6805.Installer install:'LevelPlayingField-Monticello15'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:38'!scriptLevelPlayingFieldSqueak3101Installer install:'LevelPlayingField-Monticello15'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:43'!scriptLevelPlayingFieldSqueak3102	^ self scriptLevelPlayingFieldSqueak3101! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:32'!scriptLevelPlayingFieldSqueak37Installer debug mantis fixBug: '6476 Enable MC File in if before 3.9'."add ifNil:ifNotNil"Installer installUrl: 'http://installer.pbwiki.com/f/For37.cs'.Installer install:'LevelPlayingField-Monticello15'.Installer squeaksource project: 'Glorp37Compat'; install: 'Glorp3.7Compatibility'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:33'!scriptLevelPlayingFieldSqueak38Installer debug mantis fixBug: '6476 Enable MC File in if before 3.9'.Installer install:'LevelPlayingField-Monticello15'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:36'!scriptLevelPlayingFieldSqueak39Installer install:'LevelPlayingField-Monticello15'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/24/2009 18:47'!scriptLevelPlayingFieldUpdateSqueakMap 	(Smalltalk classNamed: #SMSqueakMap) ifNil: [ ^ self ].	self logCR: 'Postscript: Squeakmap Update '.	Installer wsm addPackage: 'SqueakMap2 base'; bootstrap; install.	Installer wsm addPackage: 'SqueakMap2 loader'; bootstrap; install.	Installer wsm addPackage: 'SqueakMap2 base'; install.  	Installer wsm addPackage: 'SqueakMap2 loader'; install.  ! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 02:54'!scriptLevelPlayingFieldetoys	^ self scriptLevelPlayingFieldSqueak38! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 03:06'!scriptLogging Installer mantis ensureFix: '7219 Improve Streams Usage Readability'. Installer ss project: 'Logging';      install: 'ProcessSpecific';      install: 'Logging'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 03:08'!scriptMonticello16Beta"Monticello 1.6 will be all about truly atomic loading, thanks to SystemEditor. The atomic loader comes with every copy of Monticello 1.5, but is disabled by default. So this script just loads up MC 1.5, SystemEditor, and enables the atomic loader.Note that this is beta level software, but I think it mostly worksThere is no support for Traits yet, or for Tweak fields, so you won't be able to load Traits or Nile or parts of Omnibrowser with this enabled.To use the stable loader, disable the preference monticello > useMonticelloAtomicLoader"Installer ss project: 'SystemEditor';install: 'SystemEditor-Core';install: 'SystemEditor-Squeak'.Preferences setPreference: #useMonticelloAtomicLoader toValue: true.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 03:09'!scriptOmniBrowserInstaller mantis fixBug: 7132.Installer wiresong project: 'ob';install: 'OmniBrowser-mtf.413';install: 'OB-Standard';install: 'OB-Morphic';install: 'OB-SUnitIntegration';install: 'OB-Enhancements'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 03:02'!scriptPackagesInstaller mantis ensureFix: '7219 Streams Readability'.Installer mantis ensureFix: '7166 Speedup allSelectors add allSelectorsBelow'.Installer mantis ensureFix: '7272 BlockContext equality testing missing'.Installer squeaksource project: 'Sake'; install: 'Sake-Core'.Installer squeaksource project: 'Packages';install: 'Sake-Packages';install: 'Packages-Library'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 03:03'!scriptPackagesPharoInstaller mantis ensureFix: '7272 BlockContext equality testing missing'.Installer squeaksource project: 'Sake'; install: 'Sake-Core'.Installer squeaksource project: 'Packages';install: 'Sake-Packages';install: 'Packages-Library'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 03:06'!scriptUniversesInstaller ss project: 'XMLSupport'; install: 'XML-Parser'.Installer ss project: 'universes'; install: 'Universes'.! !!InstallerScripts methodsFor: 'as yet unclassified' stamp: 'kph 2/23/2009 03:13'!scriptUnloadTraits"Phase 1: Disable traits activity and stub out the instance variables that will be removed in Phase 2"SystemChangeNotifier uniqueInstancenoMoreNotificationsFor: ProvidedSelectors current;noMoreNotificationsFor: RequiredSelectors current;noMoreNotificationsFor: LocalSends current.Installer installUrl: 'http://installer.pbwiki.org/f/UnloadTraits-StubOutAcessors.cs'."Phase 2: Recompile the image with classes in the old format, ie, without the traitsComposition and localSends instance variables"[ClassDescription subclass: #MetaclassinstanceVariableNames: 'thisClass'classVariableNames: ' 'poolDictionaries: ' 'category: 'Kernel-Classes'.ClassDescription subclass: #ClassinstanceVariableNames: 'subclasses name classPool sharedPools environment category'classVariableNames: ' 'poolDictionaries: ' 'category: 'Kernel-Classes'.] on: Warning do: [:warning | warning resume]."Phase 3: Remove all traits and all references to the Traits classes from the image, including methods that refer to traits functionality""Kill all traits" "variables are nil-ed out to prevent obsolete refs later"Smalltalk allTraits do: [:trait | trait removeFromSystem. trait := nil]."Recompile all methods that were part of a trait"SystemNavigation default allBehaviorsDo: [:class | class selectorsAndMethodsDo: [:sel :method | class ~~ method methodClass ifTrue: [class recompile: sel]. method := nil]. class := nil]."Remove references to traits from various places in the code"Installer installUrl: 'http://installer.pbwiki.org/f/UnloadTraits-ClearRefs.cs'."Phase 4: Unload the Traits package and install the Traits compatability stubs for Monticello"Installer unload: 'Traits'.Installer installUrl: 'http://installer.pbwiki.org/f/TraitsStubs.cs'.! !----End fileIn of a stream----!Installer bootstrapTheRestOfInstaller.!'From Croquet1.0beta of 11 April 2006 [latest update: #2] on 21 July 2008 at 8:46 pm'!!SyntaxError methodsFor: 'other' stamp: 'mtf 7/21/2008 20:44' prior: 31434855!contents: aString notifying: aController	"Compile the code in aString and proceed. Do not notify anybody of errors, because nobody would have been notified of errors if this syntax error had not arisen"	doitFlag		ifTrue: [Compiler new evaluate: aString]		ifFalse: [class compile: aString classified: category].	aController hasUnacceptedEdits: false.	self proceed! !----End fileIn of a stream----!Installer mantis bug: 7131 fix: 'SyntaxErrorUsesNonInteractiveParser-M7131.1.cs'.!----End fileIn of a stream----!'From etoys3.0 of 24 February 2008 [latest update: #2159] on 4 October 2008 at 9:56:38 pm'!"Change Set:		MethodReference-categoryDate:			4 October 2008Author:			Matthew FulmerI add the instance variable 'category' to MethodReference. This allows Monticello snapshotting to be about 25% faster"!Object subclass: #MethodReference	instanceVariableNames: 'classSymbol classIsMeta methodSymbol stringVersion category '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!MethodReference methodsFor: 'queries' stamp: 'mtf 10/4/2008 01:18' prior: 24484369!category	^ category ifNil: [category := self actualClass organization categoryOfElement: methodSymbol]! !!MethodReference methodsFor: 'setting' stamp: 'mtf 10/4/2008 00:52'!category: aSymbol	category := aSymbol! !Object subclass: #MethodReference	instanceVariableNames: 'classSymbol classIsMeta methodSymbol stringVersion category'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!----End fileIn of a stream----!Installer mantis bug: 7205 fix: 'MethodReference-category-M7205.2.cs'.!----End fileIn of a stream----!'From Croquet1.0beta of 11 April 2006 [latest update: #2] on 19 January 2009 at 3:18:03 pm'!!Categorizer methodsFor: 'accessing' stamp: 'mtf 1/19/2009 15:00' prior: 18081202!categories: anArray	"Reorder my categories to be in order of the argument, anArray. If the 	resulting organization does not include all elements, then give an error."	| newCategories newStops newElements catName list runningTotal | 		anArray size < 2 ifTrue: [ ^ self ].		newCategories := Array new: anArray size.	newStops := Array new: anArray size.	newElements := Array new: 0.	runningTotal := 0.	1 to: anArray size do:		[:i |		catName := (anArray at: i) asSymbol.		list := self listAtCategoryNamed: catName.				newElements := newElements, list.				newCategories at: i put: catName.				newStops at: i put: (runningTotal := runningTotal + list size)].	elementArray do:		[:element | "check to be sure all elements are included"		(newElements includes: element)			ifFalse: [^self error: 'New categories must match old ones']].	"Everything is good, now update my three arrays."	categoryArray := newCategories.	categoryStops := newStops.	elementArray := newElements! !----End fileIn of a stream----!Installer mantis bug: 7218 fix: 'EmptyCategoryList-M7218.2.cs'.!----End fileIn of a stream----!'From Pharo0.1 of 16 May 2008 [latest update: #10074] on 28 September 2008 at 6:26:08 pm'!!Behavior methodsFor: 'accessing method dictionary' stamp: 'kph 8/27/2008 22:31' prior: 17328318!allSelectors	"Answer all selectors understood by instances of the receiver"	^ self allSelectorsBelow: nil! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'dc 9/28/2008 15:54'!allSelectorsBelow: topClass 	| coll |	coll := IdentitySet new.	self withAllSuperclassesDo: 			[:aClass | 			aClass = topClass				ifTrue: [^ coll ]				ifFalse: [aClass selectorsDo: [ :sel | coll add: sel ]]].	^ coll	! !!BehaviorTest methodsFor: 'tests' stamp: 'dc 9/28/2008 16:46'!testAllSelectors	self assert: ProtoObject allSelectors = ProtoObject selectors.	self assert: Object allSelectors = (Object selectors union: ProtoObject selectors).	self assert: (Object allSelectorsBelow: ProtoObject) = (Object selectors).! !----End fileIn of a stream----!Installer mantis bug: 7166 fix: 'Speedup-AllSelectors-M7166.1.cs'.!----End fileIn of a stream----!'From Pharo0.1 of 16 May 2008 [Latest update: #10234] on 17 February 2009 at 10:32:42 am'!!HTTPSocket class methodsFor: 'get the page' stamp: 'damiencassou 2/17/2009 10:27' prior: 21679198!httpGet: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| document |	document := self httpGetDocument: url  args: args  accept: mimeType request: requestString.	(document isString) ifTrue: [		"strings indicate errors"		^ document ].	^ (RWBinaryOrTextStream with: document content) reset! !!HTTPSocket class methodsFor: 'get the page' stamp: 'damiencassou 2/17/2009 09:55' prior: 21679868!httpGet: url args: args user: user passwd: passwd	| authorization result |	authorization := (Base64MimeConverter mimeEncode: (user , ':' , passwd) readStream) contents.	result := self 		httpGet: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , String crlf.	result isString ifFalse: [^result].	authorization := self digestFor: result method: 'GET' url: url user: user password: passwd.	authorization ifNil: [^result].	^self 		httpGet: url args: args accept: '*/*' 		request: 'Authorization: Digest ' , authorization , String crlf.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'damiencassou 2/17/2009 10:11' prior: 21691993!httpPost: url args: args user: user passwd: passwd	| authorization result |	authorization := (Base64MimeConverter mimeEncode: (user , ':' , passwd) readStream) contents.	result := self 		httpPostDocument: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , String crlf.	result isString ifFalse: [^result].	authorization := self digestFor: result method: 'POST' url: url user: user password: passwd.	authorization ifNil: [^result].	^self 		httpPostDocument: url args: args accept: '*/*' 		request: 'Authorization: Digest ' , authorization , String crlf.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'damiencassou 2/17/2009 10:14' prior: 21692352!httpPut: contents to: url user: user passwd: passwd	"Upload the contents of the stream to a file on the server"	| bare serverName specifiedServer port page serverAddr authorization s list header firstData length aStream command digest |	Socket initializeNetwork. 	"parse url"	bare := (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName := bare copyUpTo: $/.	specifiedServer := serverName.	(serverName includes: $:) ifFalse: [ port := self defaultPort ] ifTrue: [		port := (serverName copyFrom: (serverName indexOf: $:) + 1 				to: serverName size) asNumber.		serverName := serverName copyUpTo: $:.	].	page := bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page := '/'].	(self shouldUseProxy: serverName) ifTrue: [ 		page := 'http://', serverName, ':', port printString, page.		"put back together"		serverName := self httpProxyServer.		port := self httpProxyPort].  	"make the request"		serverAddr := NetNameResolver addressForName: serverName timeout: 20.	serverAddr ifNil: [		^ 'Could not resolve the server named: ', serverName].	authorization := ' Basic ', (Base64MimeConverter mimeEncode: (user , ':' , passwd) readStream) contents.[	s := HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: url; cr.	command := 		'PUT ', page, ' HTTP/1.0', String crlf, 		self userAgentString, String crlf,		'Host: ', specifiedServer, String crlf, 		'ACCEPT: */*', String crlf,		HTTPProxyCredentials,		'Authorization: ' , authorization , String crlf , 		'Content-length: ', contents size printString, String crlf , String crlf , 		contents.	s sendCommand: command.	"get the header of the reply"	list := s getResponseUpTo: String crlf, String crlf ignoring: String cr.	"list = header, CrLf, CrLf, beginningOfData"	header := list at: 1.	"Transcript show: page; cr; show: argsStream contents; cr; show: header; cr."	firstData := list at: 3.	"dig out some headers"	s header: header.(authorization beginsWith: 'Digest ') notand: [(digest := self digestFrom: s method: 'PUT' url: url user: user password: passwd) notNil]]	whileTrue: [authorization :=  'Digest ', digest].	length := s getHeader: 'content-length'.	length ifNotNil: [ length := length asNumber ].	aStream := s getRestOfBuffer: firstData totalLength: length.	s destroy.	"Always OK to destroy!!"	^ header, aStream contents! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'damiencassou 2/17/2009 10:09' prior: 21673255!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index connectToHost connectToPort type newUrl |	Socket initializeNetwork.	bare := (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare := bare copyUpTo: $#.  "remove fragment, if specified"	serverName := bare copyUpTo: $/.	page := bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index := serverName indexOf: $:.			port := (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName := serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port := self defaultPort ].	page size = 0 ifTrue: [page := '/'].	"add arguments"	args ifNotNil: [page := page, (self argString: args) ].	(self shouldUseProxy: serverName)		ifFalse: [ 			connectToHost := serverName.			connectToPort := port ]		ifTrue:  [			page := 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost := self httpProxyServer.			connectToPort := self httpProxyPort].		serverAddr := NetNameResolver addressForName: connectToHost timeout: 20.	serverAddr ifNil: [		^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [	sock := HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	"Transcript cr;show: url; cr.	Transcript show: page; cr."	sock sendCommand: 'GET ', page, ' HTTP/1.0', String crlf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, String crlf] ifNil: ['']),		'ACCEPT: text/html', String crlf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		self userAgentString, String crlf,		'Host: ', serverName, ':', port printString, String crlf.	"blank line automatically added"	list := sock getResponseUpTo: String crlf, String crlf ignoring: String cr.	"list = header, CrLf, CrLf, beginningOfData"	header := list at: 1.	"Transcript show: page; cr; show: header; cr."	firstData := list at: 3.	header isEmpty 		ifTrue: [aStream := 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length := sock getHeader: 'content-length'.			length ifNotNil: [ length := length asNumber ].			type := sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl := sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					newUrl := self expandUrl: newUrl ip: serverAddr port: connectToPort.					^self httpGetDocument: newUrl args: args  accept: mimeType request: requestString] ].			aStream := sock getRestOfBuffer: firstData totalLength: length.			"a 400-series error"			sock responseCode first = $4 ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifTrue: [ ^aStream ].	].{'HTTPSocket class>>httpGetDocument:args:accept:request:'. aStream. url} inspect.	^'some other bad thing happened!!'! !!HTTPSocket class methodsFor: 'digest' stamp: 'damiencassou 2/17/2009 09:53'!digestFor: serverText method: method url: url user: user password: password	"RFC2069"	| sock |	sock := HTTPSocket new. "header decoder is on instance side"	sock header: (serverText readStream upToAll: String crlf, String crlf).	^self digestFrom: sock method: method url: url user: user password: password! !!HTTPSocket class methodsFor: 'digest' stamp: 'damiencassou 2/17/2009 09:54'!digestFrom: sock method: method url: url user: user password: password	"RFC2069"	| auth fields realm nonce uri a1 a2 response |	sock responseCode = '401' ifFalse: [^nil].	auth := sock getHeader: 'www-authenticate'.	(auth asLowercase beginsWith: 'digest') ifFalse: [^nil].	fields := (((auth allButFirst: 6) findTokens: ', 	') collect: [:ea |		(ea copyUpTo: $=) asLowercase -> (ea copyAfter: $=) withoutQuoting]) as: Dictionary.	realm := fields at: 'realm'.	nonce := fields at: 'nonce'.	uri := url readStream upToAll: '://'; skipTo: $/; skip: -1; upTo: $#.	a1 := self md5Hash: user, ':', realm, ':', password.	a2 := self md5Hash: method, ':', uri.	a1 ifNil: [^nil "no MD5 support"].	response := self md5Hash: a1, ':', nonce, ':', a2.	^String streamContents: [:digest |		digest			nextPutAll: 'username="', user, '"';			nextPutAll: ', realm="', realm, '"';			nextPutAll: ', nonce="', nonce, '"';			nextPutAll: ', uri="', uri, '"';			nextPutAll: ', response="', response, '"'.		fields at: 'opaque' ifPresent: [:opaque |			digest nextPutAll: ', opaque="', opaque, '"'].	]! !!HTTPSocket class methodsFor: 'digest' stamp: 'damiencassou 2/17/2009 10:15'!md5Hash: aString	"Answer hash of aString as lowercase 32 digit hex String.	There are several providers of MD5 hash ..."	"(self md5Hash: 'user:realm:passwd') =  '007e68e539ed680c24f6d9a370f3bcb1'"	| hash |	hash := Smalltalk at: #CMD5Hasher ifPresent: [:cls |		cls hashMessage: aString].	hash ifNil: [		hash := Smalltalk at: #TCryptoRandom ifPresent: [:cls |			(cls basicNew md5HashMessage: aString) asInteger]].	hash ifNotNil: [		hash := hash hex asLowercase.		(hash beginsWith: '16r') ifTrue: [hash := hash allButFirst: 3].		hash := hash padded: #left to: 32 with: $0].	^hash! !----End fileIn of a stream----!Installer mantis bug: 7291 fix: 'MergingMonticello15OverridesOnHTTPSocket-M7291.1.cs'.!----End fileIn of a stream----!'From Squeak3.9 of 7 November 2006 [latest update: #7067] on 19 April 2007 at 10:50:31 am'!!ProtoObject methodsFor: 'testing' stamp: 'vb 4/15/2007 10:54' prior: 28319300!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock valueWithPossibleArgs: {self}! !!ProtoObject methodsFor: 'testing' stamp: 'vb 4/15/2007 10:55' prior: 28319669!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock valueWithPossibleArgs: {self}! !!MessageNode methodsFor: 'code generation' stamp: 'vb 4/16/2007 11:40' prior: 24235522!emitIfNil: stack on: strm value: forValue	"Emits both ifNil: and ifNotNil: code."	"vb: The comment seems out of date; #ifNotNil: is expanded to #ifNil:ifNotNil: in 3.9 so this method only handles the ifNil: case."	| theNode theSize ifNotNilSelector |	theNode := arguments first.	theSize := sizes at: 1.	ifNotNilSelector := #ifNotNil:.	receiver emitForValue: stack on: strm.	forValue ifTrue: [strm nextPut: Dup. stack push: 1].	strm nextPut: LdNil. stack push: 1.	equalNode emit: stack args: 1 on: strm.	self 		emitBranchOn: (selector key == ifNotNilSelector)		dist: theSize 		pop: stack 		on: strm.	pc := strm position.	forValue 		ifTrue: 			[strm nextPut: Pop. stack pop: 1.			theNode emitForEvaluatedValue: stack on: strm]			ifFalse: [theNode emitForEvaluatedEffect: stack on: strm].! !!MessageNode methodsFor: 'macro transformations' stamp: 'vb 4/16/2007 11:42' prior: 24248754!transformIfNil: encoder	"vb: Removed the original transformBoolean: which amounds to a test we perform in each of the branches below."	(MacroSelectors at: special) = #ifNotNil:	ifTrue:		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder maxArgs: 1) ifFalse: [^ false].			"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.			Slightly better code and more consistent with decompilation."		self noteSpecialSelector: #ifNil:ifNotNil:.		selector := SelectorNode new key: (MacroSelectors at: special) code: #macro.		arguments := {BlockNode withJust: NodeNil. arguments first}.		(self transform: encoder) ifFalse: [self error: 'compiler logic error'].		^ true]	ifFalse:		[^ self checkBlock: arguments first as: 'ifNil arg' from: encoder]! !!MessageNode methodsFor: 'macro transformations' stamp: 'vb 4/16/2007 11:44' prior: 24249545!transformIfNilIfNotNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we transform the receiver to		(var := receiver)	which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	This does not allow the block variable to shadow an existing temp, but it's no different from how to:do: is done."	| ifNotNilArg blockVar |	ifNotNilArg := arguments at: 2.	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder)		and: [self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1])			ifFalse: [^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[blockVar := ifNotNilArg firstArgument.		receiver := AssignmentNode new variable: blockVar value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new		receiver: receiver		selector: #==		arguments: (Array with: NodeNil)		precedence: 2		from: encoder.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'vb 4/16/2007 11:44' prior: 24250061!transformIfNotNilIfNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we transform the receiver to		(var := receiver)	which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	This does not allow the block variable to shadow an existing temp, but it's no different from how to:do: is done."	| ifNotNilArg blockVar |	ifNotNilArg := arguments at: 1.	((self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1)		and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder])			ifFalse: [^false].			ifNotNilArg numberOfArguments = 1 ifTrue:		[blockVar := ifNotNilArg firstArgument.		receiver := AssignmentNode new variable: blockVar value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new		receiver: receiver		selector: #==		arguments: (Array with: NodeNil)		precedence: 2		from: encoder.	arguments swap: 1 with: 2.	^true! !!MessageNode methodsFor: 'private' stamp: 'vb 4/16/2007 11:39'!checkBlock: node as: nodeName from: encoder maxArgs: maxArgs	"vb: #canBeSpecialArgument for blocks hardcodes 0 arguments as the requirement for special blocks. We work around that here by further checking the number of arguments for blocks.."	node canBeSpecialArgument ifTrue: 		[^node isMemberOf: BlockNode].	(node isKindOf: BlockNode)		ifTrue:			[node numberOfArguments <= maxArgs				ifTrue: [^true]				ifFalse: [^encoder notify: '<- ', nodeName , ' of ' ,					(MacroSelectors at: special) , ' has too many arguments']]		ifFalse:			[^encoder notify: '<- ', nodeName , ' of ' ,					(MacroSelectors at: special) , ' must be a block or variable']! !!MessageNode methodsFor: 'private' stamp: 'vb 4/15/2007 09:10' prior: 24263906!checkBlock: node as: nodeName from: encoder	^self checkBlock: node as: nodeName from: encoder maxArgs: 0! !----End fileIn of a stream----!'From Squeak3.9 of 7 November 2006 [latest update: #7067] on 19 April 2007 at 10:50:35 am'!TestCase subclass: #IfNotNilTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'VB-IfNotNil-Tests'!!IfNotNilTests methodsFor: 'tests' stamp: 'vb 4/16/2007 11:43'!testIfNilIfNotNil0Arg	self assert: (5 ifNil: [#foo] ifNotNil: [#bar]) = #bar.	self assert: (nil ifNil: [#foo] ifNotNil: [#bar]) = #foo! !!IfNotNilTests methodsFor: 'tests' stamp: 'vb 4/16/2007 11:43'!testIfNilIfNotNil0ArgAsVar	| block1 block2 |	block1 := [#foo].	block2 := [#bar].	self assert: (5 ifNil: block1 ifNotNil: block2) = #bar.	self assert: (nil ifNil: block1 ifNotNil: block2) = #foo! !!IfNotNilTests methodsFor: 'tests' stamp: 'vb 4/15/2007 12:25'!testIfNilIfNotNil1Arg	self assert: (5 ifNil: [#foo] ifNotNil: [:a | a printString]) = '5'.	self assert: (nil ifNil: [#foo] ifNotNil: [:a | a printString]) = #foo! !!IfNotNilTests methodsFor: 'tests' stamp: 'vb 4/16/2007 11:33'!testIfNilIfNotNil1ArgAsVar	| block1 block2 |	block1 := [#foo].	block2 := [:a | a printString].	self assert: (5 ifNil: block1 ifNotNil: block2) = '5'.	self assert: (nil ifNil: block1 ifNotNil: block2) = #foo! !!IfNotNilTests methodsFor: 'tests' stamp: 'vb 4/15/2007 12:14'!testIfNotNil0Arg	self assert: (5 ifNotNil: [#foo]) = #foo.	self assert: (nil ifNotNil: [#foo]) = nil! !!IfNotNilTests methodsFor: 'tests' stamp: 'vb 4/16/2007 11:30'!testIfNotNil0ArgAsVar	| block |	block := [#foo].	self assert: (5 ifNotNil: block) = #foo.	self assert: (nil ifNotNil: block) = nil! !!IfNotNilTests methodsFor: 'tests' stamp: 'vb 4/15/2007 12:15'!testIfNotNil1Arg	self assert: (5 ifNotNil: [:a | a printString]) = '5'.	self assert: (nil ifNotNil: [:a | a printString]) = nil! !!IfNotNilTests methodsFor: 'tests' stamp: 'vb 4/16/2007 11:31'!testIfNotNil1ArgAsVar	| block |	block := [:a | a printString].	self assert: (5 ifNotNil: block) = '5'.	self assert: (nil ifNotNil: block) = nil! !!IfNotNilTests methodsFor: 'tests' stamp: 'vb 4/16/2007 11:35'!testIfNotNilIfNil0Arg	self assert: (5 ifNotNil: [#foo] ifNil: [#bar]) = #foo.	self assert: (nil ifNotNil: [#foo] ifNil: [#bar]) = #bar! !!IfNotNilTests methodsFor: 'tests' stamp: 'vb 4/16/2007 11:36'!testIfNotNilIfNil0ArgAsVar	| block1 block2 |	block1 := [#foo].	block2 := [#bar].	self assert: (5 ifNotNil: block2 ifNil: block1) = #bar.	self assert: (nil ifNotNil: block2 ifNil: block1) = #foo! !!IfNotNilTests methodsFor: 'tests' stamp: 'vb 4/16/2007 11:35'!testIfNotNilIfNil1Arg	self assert: (5 ifNotNil: [:a | a printString] ifNil: [#foo]) = '5'.	self assert: (nil ifNotNil: [:a | a printString] ifNil: [#foo]) = #foo! !!IfNotNilTests methodsFor: 'tests' stamp: 'vb 4/16/2007 11:36'!testIfNotNilIfNil1ArgAsVar	| block1 block2 |	block1 := [#foo].	block2 := [:a | a printString].	self assert: (5 ifNotNil: block2 ifNil: block1) = '5'.	self assert: (nil ifNotNil: block2 ifNil: block1) = #foo! !----End fileIn of a stream----!Installer mantis bug: 6426 fix: 'M6426-MonadicIfNotNil-mtf.2.cs'. "Vassili's fix""fix test"Installer mantis bug: 6426 fix: 'MonadicIfNotNilTests.1.cs'. "Vassilli's tests"!----End fileIn of a stream----!!ReadStream methodsFor: '*packageinfo-base' stamp: 'ab 5/24/2003 14:28' prior: 28419427!untilEnd: aBlock displayingProgress: aString	aString		displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:			[:bar |			[self atEnd] whileFalse:				[bar value: self position.				aBlock value]].! !!Collection methodsFor: '*packageinfo-base' stamp: 'ab 9/30/2002 19:26' prior: 18856447!gather: aBlock	^ Array streamContents:		[:stream |		self do: [:ea | stream nextPutAll: (aBlock value: ea)]]! !!PackageInfo commentStamp: 'kph 12/7/2008 03:10' prior: 26250789!Subclass this class to create new specialised packages, and make sure that #isResponsibleForName: is correctly defined.We have a number of useful default package types defined. If you use the appropriate suffix for the package name you add, then it will select the correct PacakgeInfo subclass.Package types for selective platform specific code exporting are available as an addon package. I.e. you can have a single package, and have a Seaside.vw Seaside.squeak etc providing different exports of the same codebase.External Files Support================The default implementation of the two methods below considers all files and directories (with their contents) matching the package name to be part of the package.#externalFiles#externalFilesMatchese.g. package name 'Release'.files matching would include:Release.textRelease/Introduction.textRelease/Tutorial/ch1.textExternal Files Support - Monticello========================================*Only file based repositories (i.e. .mcz files) are supported at presentSince your external files will change far less than your code, it is recommended that youuse a separate package to manage files in order to save space and time.Files are included in the .mcz (which is a standard zip archive)as files/* according to the pattern files/<uuid>/<path>/<to>/<file>*note: the uuid will change with every snapshot, it is unique to that file in that snapshot*note: in changes browsers the file is considered to be changed if the fileSize has changed.Snapshotting a package with files uses a temporary directory in package-cache/filesThe #flushCachedVersions menu item deletes this directory.OSProcess!!PackageInfoImpl commentStamp: 'kph 6/1/2008 11:35' prior: 0!Packages named MyPackage.implIncludes Categories Except those included in PackageInfoTests:!!PackageInfoImpl class methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 14:25'!isResponsibleForName: aString^ aString endsWith: '.impl'! !!PackageInfoImpl class methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 13:04'!testCategoryMatches^ PackageInfoTests testCategoryMatches! !!PackageInfoImpl methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 13:04'!includesSystemCategory: categoryName 	^ (super includesSystemCategory: categoryName) and: [  (self isCategory: categoryName matchingAny: self class testCategoryMatches) not ]  ! !!PackageInfoImpl methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 12:56'!isYourClassExtension: categoryName	^ (super isYourClassExtension: categoryName) and: [ (self isCategory: categoryName matchingAny: self class testCategoryMatches) not  ]! !!PackageInfoImpl methodsFor: 'as yet unclassified' stamp: 'kph 6/5/2008 22:44'!methodCategoryPrefix	^ methodCategoryPrefix ifNil: [methodCategoryPrefix := '*', self systemCategoryPrefix asLowercase]! !!PackageInfoImpl methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 14:16'!systemCategoryPrefix	^ self packageName copyUpToLast: $.! !!PackageInfoImpl methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 03:52'!testsPackageName	^ self systemCategoryPrefix , '.test'! !!PackageInfoKernel commentStamp: 'kph 6/1/2008 12:18' prior: 0!Packages named MyPackage.kernelEnables the definition of a package being a subset of any other packagecontent is marked by the pragma <kernel>!!PackageInfoKernel class methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 11:50'!isResponsibleForName: aString^ aString endsWith: '.kernel'! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 14:51'!chosenMethodsForClass: aClass	^ aClass isKernelClass 		ifFalse: [ self methodsForClass: aClass pragma: #kernel ]		ifTrue: [ (self allMethodsForClass: aClass) difference: ( self methodsForClass: aClass pragma: #excludeFromKernel) ]! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 14:46'!classes ^ self loadedClasses select: [ :ea | (self chosenMethodsForClass: ea) notEmpty ]! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 14:44'!coreMethodsForClass: aClass 	^ (self chosenMethodsForClass: aClass)		difference: (self foreignExtensionMethodsForClass: aClass)  	   ! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 14:45'!extensionMethodsForClass: aClass 	^ (super extensionMethodsForClass: aClass) intersection: (self chosenMethodsForClass: aClass)! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 12:14'!kernelMethodsForClass: aClass	^ (Pragma allNamed: #kernel in: aClass) collect: [ :pragma | self referenceForMethod: pragma selector ofClass: aClass ]	 	 ! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 6/5/2008 22:44'!methodCategoryPrefix	^ methodCategoryPrefix ifNil: [methodCategoryPrefix := '*', self systemCategoryPrefix asLowercase]! !!PackageInfoKernel methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 14:01'!systemCategoryPrefix	^ self packageName copyUpToLast: $.! !!PackageInfoTests class methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 15:31'!isResponsibleForName: aString^ aString endsWith: '.test'! !!PackageInfoTests class methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 13:03'!testCategoryMatches^ #('*-Tests-*' '*-Tests') ! !!PackageInfoTests methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 12:47'!includesSystemCategory: categoryName	^ (super includesSystemCategory: categoryName) and: [ self isCategory: categoryName matchingAny: self class testCategoryMatches  ]! !!PackageInfoTests methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 12:56'!isYourClassExtension: categoryName	^ (super isYourClassExtension: categoryName) and: [ self isCategory: categoryName matchingAny: self class testCategoryMatches  ]! !!PackageInfoTests methodsFor: 'as yet unclassified' stamp: 'kph 6/5/2008 22:44'!methodCategoryPrefix	^ methodCategoryPrefix ifNil: [methodCategoryPrefix := '*', self systemCategoryPrefix asLowercase]! !!PackageInfoTests methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 14:07'!systemCategoryPrefix	^ self packageName copyUpToLast: $.! !!PackageInfoTests methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 03:35'!testsPackageName	^ nil! !!PackageInfo class methodsFor: 'packages access' stamp: 'kph 10/26/2008 00:43' prior: 26263260!allPackages	^ self organizer packages! !!PackageInfo class methodsFor: 'class selection' stamp: 'kph 9/3/2008 20:14'!classResponsibleForName: aString 	PackageInfo allSubclassesDo: [ :class |		(class isResponsibleForName: aString) ifTrue: [ ^ class ].		].	^ PackageInfo! !!PackageInfo class methodsFor: 'class selection' stamp: 'kph 5/15/2008 18:48'!isResponsibleForName: aString^ false! !!PackageInfo class methodsFor: 'packages access' stamp: 'kph 8/3/2008 05:01' prior: 26263392!named: aString	^ PackageOrganizer default packageNamed: aString ifAbsent: [(self newForName: aString) register]! !!PackageInfo class methodsFor: 'private' stamp: 'kph 5/15/2008 18:31'!newForName: aString	^ (self classResponsibleForName: aString) basicNew 		packageName: aString; 		initialize; 		yourself! !!PackageInfo class methodsFor: 'packages access' stamp: 'kph 10/26/2008 00:42'!organizer	^PackageOrganizer default! !!PackageInfo class methodsFor: 'packages access' stamp: 'avi 11/11/2003 17:19' prior: 26263594!registerPackageName: aString	^ PackageOrganizer default registerPackageNamed: aString! !!PackageInfo class methodsFor: 'as yet unclassified' stamp: 'ab 11/14/2002 15:05'!registerPackage: aString	"for compatibility with old fileOuts"	^ Smalltalk at: #FilePackageManager ifPresent: [:p | p registerPackage: aString]! !!PackageInfo methodsFor: 'modifying' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26255281!addCoreMethod: aMethodReference	| category |	category := self baseCategoryOfMethod: aMethodReference.	aMethodReference actualClass organization		classify: aMethodReference methodSymbol		under: category		suppressIfDefault: false! !!PackageInfo methodsFor: 'modifying' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26255597!addExtensionMethod: aMethodReference	| category |	category := self baseCategoryOfMethod: aMethodReference.	aMethodReference actualClass organization		classify: aMethodReference methodSymbol		under: self methodCategoryPrefix, '-', category! !!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/11/2003 15:16' prior: 26255913!addMethod: aMethodReference	(self includesClass: aMethodReference class)		ifTrue: [self addCoreMethod: aMethodReference]		ifFalse: [self addExtensionMethod: aMethodReference]! !!PackageInfo methodsFor: 'testing' stamp: 'kph 2/7/2009 16:40'!allMethodsForAuthor: anAuthorInitials	"Browse uncommented methods whose initials (in the time-stamp, as logged to disk) match the given initials.  Present them in chronological order.  CAUTION: It will take several minutes for this to complete."	"Time millisecondsToRun: [SystemNavigation default browseUncommentedMethodsWithInitials: 'jm']"	| initials timeStamp methodReferences cm classes targetInitials |	methodReferences := OrderedCollection new.	classes		do: [:aClass | aClass selectors do: [:sel |			cm := aClass compiledMethodAt: sel.			timeStamp := Utilities timeStampForMethod: cm.			timeStamp isEmpty ifFalse:				[initials := timeStamp substrings first.				initials first isDigit ifFalse:					[(initials = targetInitials)						ifTrue:							[methodReferences add: (MethodReference new								setStandardClass: aClass 								methodSymbol: sel)]]]]].	ToolSet		browseMessageSet: methodReferences 		name: 'Uncommented methods with initials ', targetInitials		autoSelect: nil		 ! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/2/2008 23:30'!allMethodsForClass: aClass	^ aClass localSelectors collect: [ :sel | self referenceForMethod: sel ofClass: aClass ]		 ! !!PackageInfo methodsFor: 'enumerating' stamp: 'bf 5/4/2005 16:23'!allOverridenMethodsDo: aBlock	"search classes and meta classes"	^ ProtoObject withAllSubclassesDo: [:class | 		self overriddenMethodsInClass: class do: aBlock]! !!PackageInfo methodsFor: 'listing' stamp: 'bf 5/4/2005 16:33'!allOverridenMethods	"search classes and meta classes"	^ Array streamContents: [:stream |		self allOverridenMethodsDo: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'listing' stamp: 'kph 2/7/2009 17:17'!authors	"	(PackageInfo named: 'Monticello.impl') authors	"	| timeStamp aClass authors |		authors := Set new.		self classesDo: [:c | aClass := c ] methodsDo: [ :m | 				timeStamp := m timeStamp.			timeStamp isEmpty ifFalse:				[ authors add: timeStamp substrings first ].	].		^ authors! !!PackageInfo methodsFor: 'modifying' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26256173!baseCategoryOfMethod: aMethodReference	| oldCat oldPrefix tokens | 	oldCat := aMethodReference category.	({ 'as yet unclassified'. 'all' } includes: oldCat) ifTrue: [ oldCat := '' ].	tokens := oldCat findTokens: '*-' keep: '*'.	"Strip off any old prefixes"	((tokens at: 1 ifAbsent: [ '' ]) = '*') ifTrue: [		[ ((tokens at: 1 ifAbsent: [ '' ]) = '*') ]			whileTrue: [ tokens removeFirst ].		oldPrefix := tokens removeFirst asLowercase.		[ (tokens at: 1 ifAbsent: [ '' ]) asLowercase = oldPrefix ]			whileTrue: [ tokens removeFirst ].	].	tokens isEmpty ifTrue: [^ 'as yet unclassified'].	^ String streamContents:		[ :s |		tokens			do: [ :tok | s nextPutAll: tok ]			separatedBy: [ s nextPut: $- ]]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 21:37'!behaviorsNamed: aSymbol do: aBlock"Enumerates all behaviors with the given name"	| class traitClass |	class := Smalltalk at: aSymbol ifAbsent: [^ self].	class isBehavior ifTrue: [aBlock value: class. aBlock value: class class. ^ self].	traitClass := Smalltalk at: #Trait ifAbsent: [^ self].	(class isKindOf: traitClass) ifTrue: [aBlock value: class. ^ self].! !!PackageInfo methodsFor: 'modifying' stamp: 'kph 2/7/2009 17:15'!browseMethodsForAuthorInitials: authorInitials	| mr |	ToolSet		browseMessageSet: (mr := self methodsForAuthorInitials: authorInitials)		name: (self packageName, ' methods with initials ', authorInitials, '(', mr size asString ,')')		autoSelect: nil	! !!PackageInfo methodsFor: 'naming' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26257560!categoryName	|category|	category := self class category.	^ (category endsWith: '-Info')		ifTrue: [category copyUpToLast: $-]		ifFalse: [category]! !!PackageInfo methodsFor: 'testing' stamp: 'pmm 1/6/2007 18:09' prior: 26258585!category: categoryName matches: prefix	| prefixSize catSize |	categoryName ifNil: [ ^false ].	catSize := categoryName size.	prefixSize := prefix size.	catSize < prefixSize ifTrue: [ ^false ].	(categoryName findString: prefix startingAt: 1 caseSensitive: false) = 1		ifFalse: [ ^false ].	^(categoryName at: prefix size + 1 ifAbsent: [ ^true ]) = $-! !!PackageInfo methodsFor: 'testing' stamp: 'mtf 6/9/2008 20:50'!changeRecordForOverriddenMethod: aMethodReference	| position prevPos prevFileIndex thePreamble tokens sourceFilesCopy stamp method file methodCategory |	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [thePreamble := file nextChunk].		"thePreamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(thePreamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: thePreamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !!PackageInfo methodsFor: 'listing' stamp: 'al 12/14/2005 18:06' prior: 26253357!classesAndMetaClasses	| baseClasses |	baseClasses := self classes.	^baseClasses , (baseClasses collect: [:c | c classSide])! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/15/2008 20:55'!classesAsDefinitions	^ self classes collect: [ :c | c asClassDefinition ]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 23:18'!classesDo: classBlock methodsDo: methodBlock displayingProgress: aString"Enumerates all non-meta classes and all methods in the package, and displays a progress bar"	| classes methods i |	(1 to: 2) do: [:ignored | ] displayingProgress: 'Collecting...'.	classes := OrderedCollection new.	methods := OrderedCollection new.	self		classesDo: [:class | classes add: class]		methodsDo: [:method | methods add: method].	aString displayProgressAt: Sensor cursorPoint		from: 1 to: classes size + methods size		during: [:bar | i := 0.			classes do: [:class | bar value: (i := i + 1). classBlock value: class].			methods do: [:method | bar value: (i := i + 1). methodBlock value: method]]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 20:45'!classesDo: classBlock methodsDo: methodBlock"Enumerates all non-meta classes and all methods in the package"	self		includedClassesDo: [:class |			class isMeta ifFalse: [classBlock value: class].			self methodsInIncludedClass: class do: methodBlock]		excludedClassesDo: [:class |			self methodsInExcludedClass: class do: methodBlock]! !!PackageInfo methodsFor: 'listing' stamp: 'kph 6/2/2008 14:55' prior: 26253087!classes 	^ self loadedClasses! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:18' prior: 26258788!coreCategoriesForClass: aClass	^ aClass organization categories select: [:cat | (self isForeignClassExtension: cat) not]! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 14:32' prior: 26258979!coreMethodsForClass: aClass	^ (self allMethodsForClass: aClass)		difference: (self foreignExtensionMethodsForClass: aClass)  ! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/15/2007 02:28' prior: 26253553!coreMethods	^ self classesAndMetaClasses gather: [:class |  self coreMethodsForClass: class]! !!PackageInfo methodsFor: 'testing' stamp: 'mtf 10/3/2008 17:58'!extensionCategoriesForClass: aClass do: aBlock	^ aClass organization categories		do: [:cat | (self isYourClassExtension: cat) ifTrue: [aBlock value]]! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:20' prior: 26259266!extensionCategoriesForClass: aClass	^ aClass organization categories select: [:cat | self isYourClassExtension: cat]! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/10/2007 05:38' prior: 26253713!extensionClasses		"The classes that have extensions from this package"		^ self externalBehaviors reject: [:classOrTrait | (self extensionCategoriesForClass: classOrTrait) isEmpty]	 ! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/10/2004 18:28' prior: 26259452!extensionMethodsForClass: aClass	^ (self extensionCategoriesForClass: aClass)		gather: [:cat | self methodsInCategory: cat ofClass: aClass ]! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 10/18/2002 23:22' prior: 26259752!extensionMethodsFromClasses: classes	^classes		gather: [:class | self extensionMethodsForClass: class]! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/10/2007 05:39' prior: 26253906!extensionMethods	"The methods from this package which are extending other classes"		^ self externalBehaviors gather: [:classOrTrait | self extensionMethodsForClass: classOrTrait]! !!PackageInfo methodsFor: 'modifying' stamp: 'al 3/1/2006 21:42' prior: 26256958!externalBehaviors	^self externalClasses , self externalTraits! !!PackageInfo methodsFor: 'dependencies' stamp: 'ab 11/18/2002 01:16' prior: 26251160!externalCallers	^ self 		externalRefsSelect: [:literal | literal isKindOf: Symbol] 		thenCollect: [:l | l].! !!PackageInfo methodsFor: 'dependencies' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26251356!externalClasses	| myClasses |	myClasses := self classesAndMetaClasses.	^ Array streamContents:		[:s |		ProtoObject withAllSubclassesDo:			[:class |			(myClasses includes: class) ifFalse: [s nextPut: class]]]! !!PackageInfo methodsFor: 'naming' stamp: 'kph 12/8/2008 18:58'!externalFilesExclude	^ #( '*.image' '*.changes' '*.sources' 'prefs' 'sm' 'package-cache' )! !!PackageInfo methodsFor: 'naming' stamp: 'kph 12/5/2008 23:53'!externalFilesMatches	^ self systemCategoryPrefix in: [ :prefix | 	 	{ prefix. (prefix , '.*'). (prefix , '-*'). } ]! !!PackageInfo methodsFor: 'naming' stamp: 'kph 12/7/2008 01:24'!externalFiles		| matches entries |		matches := self externalFilesMatches.		entries := (FileDirectory default entriesAsFDs) select: [ :aFD | matches anySatisfy: [ :match | match match: aFD localName ] ].	entries addAll: (entries gather: [ :aFD | aFD allEntriesAsFDs ]).	^ entries ! !!PackageInfo methodsFor: 'naming' stamp: 'ab 10/16/2002 21:22' prior: 26257779!externalName	^ self packageName! !!PackageInfo methodsFor: 'dependencies' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26251656!externalRefsSelect: selBlock thenCollect: colBlock	| pkgMethods dependents refs extMethods otherClasses otherMethods classNames |	classNames := self classes collect: [:c | c name].	extMethods := self extensionMethods collect: [:mr | mr methodSymbol].	otherClasses := self externalClasses difference: self externalSubclasses.	otherMethods :=  otherClasses gather: [:c | c selectors].	pkgMethods := self methods asSet collect: [:mr | mr methodSymbol].	pkgMethods removeAllFoundIn: otherMethods.	dependents := Set new.	otherClasses do: [:c |		c selectorsAndMethodsDo:			[:sel :compiled |			(extMethods includes: sel) ifFalse: 				[refs := compiled literals select: selBlock thenCollect: colBlock.				refs do: [:ea |					((classNames includes: ea) or: [pkgMethods includes: ea])							ifTrue: [dependents add: (self referenceForMethod: sel ofClass: c) -> ea]]]]].	^ dependents! !!PackageInfo methodsFor: 'dependencies' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26252633!externalSubclasses	| pkgClasses subClasses |	pkgClasses := self classes.	subClasses := Set new.	pkgClasses do: [:c | subClasses addAll: (c allSubclasses)].	^ subClasses difference: pkgClasses! !!PackageInfo methodsFor: 'modifying' stamp: 'al 3/1/2006 22:08' prior: 26257090!externalTraits	| behaviors |		^ Array streamContents: [:s |		behaviors := self classesAndMetaClasses.		Smalltalk allTraits do: [:trait |			(behaviors includes: trait) ifFalse: [s nextPut: trait].			(behaviors includes: trait classSide) ifFalse: [s nextPut: trait classSide]]].			! !!PackageInfo methodsFor: 'dependencies' stamp: 'ab 11/18/2002 01:15' prior: 26252905!externalUsers	^ self 		externalRefsSelect: [:literal | literal isVariableBinding] 		thenCollect: [:l | l key]! !!PackageInfo methodsFor: 'listing' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26254099!foreignClasses	| s |	s := IdentitySet new.	self foreignSystemCategories		do: [:c | (SystemOrganization listAtCategoryNamed: c)				do: [:cl | 					| cls | 					cls := Smalltalk at: cl. 					s add: cls;					  add: cls class]].	^ s! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:22' prior: 26259926!foreignExtensionCategoriesForClass: aClass	^ aClass organization categories select: [:cat | self isForeignClassExtension: cat]! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:23' prior: 26260123!foreignExtensionMethodsForClass: aClass	^ (self foreignExtensionCategoriesForClass: aClass)		gather: [:cat | (aClass organization listAtCategoryNamed: cat)						  collect: [:sel | self referenceForMethod: sel ofClass: aClass]]! !!PackageInfo methodsFor: 'listing' stamp: 'ab 12/3/2002 14:34' prior: 26254406!foreignSystemCategories	^ SystemOrganization categories		reject: [:cat | self includesSystemCategory: cat] ! !!PackageInfo methodsFor: 'comparing' stamp: 'avi 10/11/2003 14:20' prior: 26250904!hash	^ packageName hash! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 14:55'!ignoreSystemCategory: categoryName	^ false! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 20:22'!includedClassesDo: includedBlock excludedClassesDo: excludedBlock"Enumerates behaviors, dividing them into included and excluded"	self		includedSystemCategoriesDo: [:cat |			(SystemOrganization listAtCategoryNamed: cat) do: [:name |				self behaviorsNamed: name do: includedBlock]]		excludedSystemCategoriesDo: [:cat |			(SystemOrganization listAtCategoryNamed: cat) do: [:name |				self behaviorsNamed: name do: excludedBlock]]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 21:37'!includedSystemCategoriesDo: includedBlock excludedSystemCategoriesDo: excludedBlock"Enumerate all system categories, dividing them into included and excluded"	SystemOrganization categories do: [:ea | (self includesSystemCategory: ea)		ifTrue: [includedBlock value: ea]		ifFalse: [excludedBlock value: ea]]! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/14/2004 13:34'!includesChangeRecord: aChangeRecord	^ aChangeRecord methodClass notNil and:		[self			includesMethodCategory: aChangeRecord category			ofClass: aChangeRecord methodClass]! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 7/23/2003 14:08' prior: 26260422!includesClassNamed: aClassName	^ self includesSystemCategory: ((SystemOrganization categoryOfElement: aClassName) ifNil: [^false])! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:23' prior: 26260623!includesClass: aClass	^ self includesSystemCategory: aClass theNonMetaClass category! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 7/23/2003 14:06' prior: 26260778!includesMethodCategory: categoryName ofClassNamed: aClass	^ (self isYourClassExtension: categoryName)		or: [(self includesClassNamed: aClass)				and: [(self isForeignClassExtension: categoryName) not]]! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 9/17/2002 00:18' prior: 26261052!includesMethodCategory: categoryName ofClass: aClass	^ (self isYourClassExtension: categoryName)		or: [(self includesClass: aClass)				and: [(self isForeignClassExtension: categoryName) not]]! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/14/2002 18:06' prior: 26261316!includesMethodReference: aMethodRef	^ self includesMethod: aMethodRef methodSymbol ofClass: aMethodRef actualClass! !!PackageInfo methodsFor: 'testing' stamp: 'ab 12/5/2002 00:16' prior: 26261500!includesMethod: aSymbol ofClass: aClass	aClass ifNil: [^ false].	^ self		includesMethodCategory: ((aClass organization categoryOfElement: aSymbol)										ifNil: [' '])		ofClass: aClass! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 14:56' prior: 26261761!includesSystemCategory: categoryName	^ (categoryName notNil and: [ self isCategory: categoryName prefixed: self systemCategoryPrefix ]) and: [ (self ignoreSystemCategory: categoryName) not ]! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 13:09'!initialize	methodCategoryPrefix := nil! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 12:40'!isCategory: categoryName matchingAny: matches 		^ matches anySatisfy: [ :match |  match match: categoryName ]! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 12:38'!isCategory: categoryName prefixed: prefix	| prefixSize catSize | 	catSize := categoryName size.	prefixSize := prefix size.	catSize < prefixSize ifTrue: [ ^false ].	(categoryName findString: prefix startingAt: 1 caseSensitive: false) = 1		ifFalse: [ ^false ].	^(categoryName at: prefix size + 1 ifAbsent: [ ^true ]) = $-! !!PackageInfo methodsFor: 'testing' stamp: 'kph 8/7/2007 16:36' prior: 26261933!isForeignClassExtension: categoryNamecategoryName isEmpty ifTrue: [ ^ false ].	^ categoryName first = $* and: [(self isYourClassExtension: categoryName) not]! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/10/2004 18:27'!isOverrideCategory: aString	^ aString endsWith: '-override'! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/10/2004 18:27' prior: 26262121!isOverrideMethod: aMethodReference	^ self isOverrideCategory: aMethodReference category! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/14/2004 13:35'!isOverrideOfYourMethod: aMethodReference	^ (self isYourClassExtension: aMethodReference category) not and:		[(self changeRecordForOverriddenMethod: aMethodReference) notNil]! !!PackageInfo methodsFor: 'testing' stamp: 'kph 6/1/2008 12:37' prior: 26262276!isYourClassExtension: categoryName	^ categoryName notNil and: [self isCategory: categoryName prefixed: self methodCategoryPrefix]! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/14/2007 16:57'!loadedClassesAsDefinitions	^ self loadedClasses collect: [ :c | c asClassDefinition ]! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/14/2007 16:57'!loadedClasses	^(self systemCategories gather:		[:cat |		(SystemOrganization listAtCategoryNamed: cat)			collect: [:className | Smalltalk at: className]])				sortBy: [:a :b | a className <= b className]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 20:58'!methodCategoriesInClass: aClasscoreDo: coreBlockextensionDo: extensionBlockoverrideDo: overrideBlock"Enumerates all interesting categories in aClass. Core categories go to coreBlock. My extension categories and override categories go to extensionBlock. Foreign override categories go to overrideBlock. Foreign extension categories are ignored"	aClass organization categories do: [:cat |		(self isYourClassExtension: cat) ifTrue: [extensionBlock value: cat]			ifFalse: [(self isOverrideCategory: cat) ifTrue: [overrideBlock value: cat]				ifFalse: [(self isForeignClassExtension: cat) ifFalse: [coreBlock value: cat]]]]! !!PackageInfo methodsFor: 'naming' stamp: 'kph 6/5/2008 22:43' prior: 26257891!methodCategoryPrefix	^ methodCategoryPrefix ifNil: [methodCategoryPrefix := '*', self packageName asLowercase]! !!PackageInfo methodsFor: 'modifying' stamp: 'kph 2/7/2009 17:15'!methodsForAuthorInitials: authorInitials	"	(PackageInfo named: 'Monticello.impl') methodsForAuthorInitials: 'test'.  	"	| initials timeStamp methodReferences aClass |		methodReferences := OrderedCollection new.		self classesDo: [:c | aClass := c ] methodsDo: [ :m | 					timeStamp := m timeStamp.			timeStamp isEmpty ifFalse:				[initials := timeStamp substrings first.				(initials = authorInitials)						ifTrue:							[ methodReferences add: m]]].		^ methodReferences	! !!PackageInfo methodsFor: 'as yet unclassified' stamp: 'kph 6/1/2008 14:30'!methodsForClass: aClass pragma: pragma 	^ (Pragma allNamed: pragma in: aClass) collect: [ :each | self referenceForMethod: each selector ofClass: aClass ]! !!PackageInfo methodsFor: 'enumerating' stamp: 'kph 6/2/2008 23:43'!methodsInCategory: aString ofClass: aClass do: aBlock	((aClass organization listAtCategoryNamed: aString) ifNil: [^self])		select: [ :sel | aClass includesLocalSelector: sel ]		thenDo: [:sel | aBlock value: (self referenceForMethod: sel ofClass: aClass)]			 ! !!PackageInfo methodsFor: 'testing' stamp: 'bf 5/4/2005 16:41'!methodsInCategory: aString ofClass: aClass 	^Array streamContents: [:stream |		self methodsInCategory: aString ofClass: aClass 			do: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/4/2008 00:54'!methodsInClass: aClass category: aCategory do: aBlock"Enumerate the methods in the given class and category"	(aClass organization listAtCategoryNamed: aCategory) do: [:selector |		aBlock value: ((self referenceForMethod: selector ofClass: aClass) category: aCategory)]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 21:37'!methodsInExcludedClass: aClass do: aBlock"Enumerate my methods in excluded class aClass"	self methodCategoriesInClass: aClass		coreDo: 		[:cat | "nothing"]		extensionDo:	[:cat | self methodsInClass: aClass category: cat do: aBlock]		overrideDo:	[:cat | self overriddenMethodsInClass: aClass category: cat do: aBlock]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 21:37'!methodsInIncludedClass: aClass do: aBlock"Enumerate my methods in included class aClass"	self methodCategoriesInClass: aClass		coreDo: 		[:cat | self methodsInClass: aClass category: cat do: aBlock]		extensionDo:	[:cat | self methodsInClass: aClass category: cat do: aBlock]		overrideDo:	[:cat | self overriddenMethodsInClass: aClass category: cat do: aBlock]! !!PackageInfo methodsFor: 'listing' stamp: 'kph 5/15/2007 02:29' prior: 26254584!methods	^ (self extensionMethods, self coreMethods) 		select: [:method | method isValid and: [(#(DoIt DoItIn:) includes: method methodSymbol) not]]! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/17/2005 12:55'!name^ self packageName! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 10/18/2002 23:22' prior: 26262486!outsideClasses	^ProtoObject withAllSubclasses difference: self classesAndMetaClasses! !!PackageInfo methodsFor: 'enumerating' stamp: 'bf 5/4/2005 17:39'!overriddenMethodsDo: aBlock	^ self allOverridenMethodsDo: [:ea |		(self isOverrideOfYourMethod: ea)			ifTrue: [aBlock value: ea]]! !!PackageInfo methodsFor: 'single-pass' stamp: 'mtf 10/3/2008 21:46'!overriddenMethodsInClass: aClass category: aCategory do: aBlock"Enumerate the methods in the given class and category"	self methodsInClass: aClass category: aCategory do: [:methodRef |		(self changeRecordForOverriddenMethod: methodRef)			ifNotNilDo: [:changeRecord | aBlock value: changeRecord]]! !!PackageInfo methodsFor: 'enumerating' stamp: 'bf 5/4/2005 16:27'!overriddenMethodsInClass: aClass do: aBlock	^ self overrideCategoriesForClass: aClass do: [:cat |		self methodsInCategory: cat ofClass: aClass do: aBlock]! !!PackageInfo methodsFor: 'listing' stamp: 'bf 5/4/2005 16:43'!overriddenMethodsInClass: aClass	^Array streamContents: [:stream |		self overriddenMethodsInClass: aClass			do: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'listing' stamp: 'bf 5/4/2005 17:40'!overriddenMethods	^ Array streamContents: [:stream |		self overriddenMethodsDo: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'enumerating' stamp: 'bf 5/4/2005 16:25'!overrideCategoriesForClass: aClass do: aBlock	^ aClass organization categories do: [:cat |		(self isOverrideCategory: cat) ifTrue: [aBlock value: cat]]! !!PackageInfo methodsFor: 'testing' stamp: 'bf 5/4/2005 16:44'!overrideCategoriesForClass: aClass	^Array streamContents: [:stream |		self overrideCategoriesForClass: aClass			do: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'listing' stamp: 'nk 5/1/2004 08:40' prior: 26254818!overrideMethods	^ self extensionMethods select: [:ea | self isOverrideMethod: ea]! !!PackageInfo methodsFor: 'naming' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26258082!packageName	^ packageName ifNil: [packageName := self categoryName]! !!PackageInfo methodsFor: 'naming' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26258230!packageName: aString	packageName := aString! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 02:56'!postscriptDefault	^ StringHolder new contents:  '"below, add code to be run after the loading of this package"'  ! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 02:56'!postscriptOfRemovalDefault	^ StringHolder new contents:'"below, add code to clean up after the unloading of this package"' ! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 02:56'!preambleDefault		^ StringHolder new contents: '"below, add code to be run before the loading of this package"' ! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 02:56'!preambleOfRemovalDefault	^ StringHolder new contents: '"below, add code to prepare for the unloading of this package"'! !!PackageInfo methodsFor: 'listing' stamp: 'kph 8/3/2008 04:25'!printOn: str	super printOn: str.	str nextPut: $(; nextPutAll: self packageName; nextPut: $)! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 2/23/2009 00:07'!propertyAt: key ifAbsentPut: valBlock	properties ifNil:[ ^ self propertyAt: key put: valBlock value ].		^ properties at: key ifAbsent: [ self propertyAt: key put: valBlock value ]! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 02:41'!propertyAt: key put: value	properties ifNil:[ properties := IdentityDictionary new ].		^ properties at: key put: value! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 03:17'!propertyAt: key	properties ifNil:[ ^ nil ].		^ properties at: key ifAbsent: [ nil ]! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 2/17/2009 12:01'!propertyDefaultAt: key	 | defaultSelector value |		 	defaultSelector := (key, 'Default') asSymbol.		value :=  (self respondsTo: defaultSelector) ifTrue: [ self perform: defaultSelector ] ifFalse: [ ^ nil ].				 ! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'kph 8/3/2008 03:20'!propertyOrDefaultAt: key	 | defaultSelector value |		(self propertyAt: key) ifNotNilDo: [ :v | ^ v ].	 	defaultSelector := (key, 'Default') asSymbol.		value :=  (self respondsTo: defaultSelector) ifTrue: [ self perform: defaultSelector ] ifFalse: [ ^ nil ].		^ self propertyAt: key put: value				 ! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:25' prior: 26262641!referenceForMethod: aSymbol ofClass: aClass	^ MethodReference new setStandardClass: aClass methodSymbol: aSymbol! !!PackageInfo methodsFor: 'registering' stamp: 'avi 11/12/2003 23:12' prior: 26258459!register	PackageOrganizer default registerPackage: self! !!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/11/2003 15:14' prior: 26257449!removeMethod: aMethodReference! !!PackageInfo methodsFor: 'listing' stamp: 'ab 11/14/2002 18:39' prior: 26254970!selectors	^ self methods collect: [:ea | ea methodSymbol]! !!PackageInfo methodsFor: 'listing' stamp: 'ab 11/11/2002 21:51' prior: 26255098!systemCategories	^ SystemOrganization categories select: [:cat | self includesSystemCategory: cat]! !!PackageInfo methodsFor: 'naming' stamp: 'ab 10/28/2002 10:38' prior: 26258343!systemCategoryPrefix	^ self packageName! !!PackageInfo methodsFor: 'modifying' stamp: 'kph 12/8/2008 02:46'!testsPackageName	^ self packageName, 'Tests'! !!PackageInfo methodsFor: 'comparing' stamp: 'avi 10/11/2003 00:09' prior: 26251001!= other	^ other species = self species and: [other packageName = self packageName]! !!PackageInfo class methodsFor: 'packages access' stamp: 'kph 10/26/2008 00:47'!unload	self organizer unregisterPackageInfoClass: self  ! !!PackageList class methodsFor: 'as yet unclassified' stamp: 'avi 10/10/2003 22:38'!open	^ self new openInWorld! !!PackageList methodsFor: 'actions' stamp: 'mtf 6/9/2008 20:53'!addPackage	| packageName |	packageName := FillInTheBlank request: 'Package name:'.	packageName isEmpty ifFalse:		[selectedPackage := self packageOrganizer registerPackageNamed: packageName.		self changed: #packageSelection]! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/10/2003 22:37'!buildList	^ PluggableListMorph		on: self		list: #packageList		selected: #packageSelection		changeSelected: #packageSelection:		menu: #packageMenu:! !!PackageList methodsFor: 'morphic' stamp: 'mtf 6/9/2008 20:54'!buildWindow	| window |	window := SystemWindow labelled: self label.	window model: self.	window addMorph: self buildList fullFrame: (LayoutFrame fractions: (0@0 corner: 1@1)).	^ window! !!PackageList methodsFor: 'morphic' stamp: 'avi 2/18/2004 00:28'!defaultBackgroundColor 	^ Color white! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 00:28'!defaultExtent	^ 200@200! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/10/2003 22:36'!label	^ 'Packages'! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 00:24'!openInWorld	self packageOrganizer addDependent: self.	self buildWindow openInWorldExtent: self defaultExtent! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 13:09'!packageContextMenu: aMenu	aMenu		addLine;		add: 'remove package' action: #removePackage;		addServices: PackageServices allServices for: selectedPackage extraLines: #()! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 00:10'!packageList	^ self packages collect: [:ea | ea packageName]! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 00:24'!packageMenu: aMenu	aMenu		defaultTarget: self;		add: 'add package' action: #addPackage.	selectedPackage ifNotNil: [self packageContextMenu: aMenu].	^ aMenu! !!PackageList methodsFor: 'actions' stamp: 'avi 10/11/2003 00:17'!packageOrganizer	^ PackageOrganizer default! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/10/2003 22:41'!packageSelection	^ self packages indexOf: selectedPackage! !!PackageList methodsFor: 'morphic' stamp: 'mtf 6/9/2008 20:54'!packageSelection: aNumber	selectedPackage := self packages at: aNumber ifAbsent: [].	self changed: #packageSelection! !!PackageList methodsFor: 'as yet unclassified' stamp: 'mtf 6/9/2008 20:55'!packages	^ packages ifNil: [packages := self packageOrganizer packageInfos asSortedCollection:									[:a :b | a packageName <= b packageName]]! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 00:15'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!PackageList methodsFor: 'actions' stamp: 'avi 10/11/2003 00:24'!removePackage	self packageOrganizer unregisterPackage: selectedPackage! !!PackageList methodsFor: 'actions' stamp: 'mtf 6/9/2008 20:55'!update: aSymbol	aSymbol = #packages ifTrue:		[packages := nil.		self changed: #packageList; changed: #packageSelection]! !!PackageList class methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 14:43'!initialize	TheWorldMenu registerOpenCommand: {'Package List'. {self. #open}}! !!PackageOrganizer commentStamp: 'kph 12/7/2008 01:38' prior: 0!PacakgeOrganizer default explore!!PackageOrganizer class methodsFor: 'clean up' stamp: 'kph 10/25/2008 23:58'!cleanUp	self default packages copy keysAndValuesDo: [ :k :v | v class isObsolete ifTrue: [ self default packages removeKey: k ] ].	self default packageInfos do: [ :pi | 		| resp |				resp := PackageInfo classResponsibleForName: pi packageName.			(((resp = PackageInfo) not and: [ pi class ~= resp ]) or: [ pi class isObsolete ])		ifTrue: [ 			PackageOrganizer default unregisterPackageNamed: pi packageName.		].		].! !!PackageOrganizer class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26266237!default	^ default ifNil: [default := self new]! !!PackageOrganizer class methodsFor: 'as yet unclassified' stamp: 'mtf 6/3/2008 10:07'!forcefullyClearCache	"Clear out the cache dangerously. Forgets any preambles that have been defined"	default := nil! !!PackageOrganizer class methodsFor: 'as yet unclassified' stamp: 'avi 10/13/2003 15:25' prior: 26266378!new	^ self basicNew initialize! !!PackageOrganizer methodsFor: 'initializing' stamp: 'kph 10/25/2008 02:15'!clearCacheButPreservePreambles	"Remove every PI from the cache which does not have either a preamble or postscript"	| keep |	keep := self packageInfos select: [:package | (((package hasPreamble			or: [package hasPostscript])			or: [package hasPreambleOfRemoval])			or: [package hasPostscriptOfRemoval]) ].			packages := Dictionary new.		keep do: [ :p | self registerPackage: p ]! !!PackageOrganizer methodsFor: 'searching' stamp: 'kph 12/8/2008 05:46'!includesPackageNamed: aString	^ (packages at: aString ifAbsent: [ nil ]) notNil! !!PackageOrganizer methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26264131!initialize	packages := Dictionary new! !!PackageOrganizer methodsFor: 'private' stamp: 'stephane.ducasse 9/4/2008 12:51'!mostSpecificPackageIn: aCollection ifNone: aBlock	aCollection isEmpty		ifTrue: [ ^ aBlock value ].	^ (aCollection asArray		sort: [ :a :b | a packageName size > b packageName size ])		first! !!PackageOrganizer methodsFor: 'searching' stamp: 'stephane.ducasse 9/4/2008 12:51'!mostSpecificPackageOfClass: aClass ifNone: aBlock		^ self 		mostSpecificPackageIn: (self packages select: [ :each | each includesClass: aClass ])		ifNone: aBlock! !!PackageOrganizer methodsFor: 'searching' stamp: 'stephane.ducasse 9/4/2008 12:50'!mostSpecificPackageOfClass: aClass	^ self mostSpecificPackageOfClass: aClass ifNone: [self noPackageFound]! !!PackageOrganizer methodsFor: 'searching' stamp: 'stephane.ducasse 9/4/2008 12:52'!mostSpecificPackageOfMethod: aMethodReference ifNone: aBlock	^ self  		mostSpecificPackageIn: (self packages select: [ :each | each includesMethodReference: aMethodReference ])		ifNone: aBlock! !!PackageOrganizer methodsFor: 'searching' stamp: 'stephane.ducasse 9/4/2008 12:50'!mostSpecificPackageOfMethod: aMethodReference	^ self mostSpecificPackageOfMethod: aMethodReference ifNone: [self noPackageFound]! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 10/11/2003 14:21' prior: 26265037!noPackageFound	self error: 'No package found'! !!PackageOrganizer methodsFor: 'accessing' stamp: 'kph 5/30/2008 20:44'!packageInfos	^ packages values! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 11/12/2003 23:08' prior: 26265161!packageNamed: aString ifAbsent: errorBlock	^ packages at: aString ifAbsent: errorBlock! !!PackageOrganizer methodsFor: 'accessing' stamp: 'avi 11/12/2003 23:01' prior: 26263905!packageNames	^ packages keys! !!PackageOrganizer methodsFor: 'searching' stamp: 'kph 5/30/2008 20:47' prior: 26265487!packageOfClass: aClass ifNone: errorBlock	^ self packageInfos detect: [:ea | ea includesClass: aClass] ifNone: errorBlock! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 10/11/2003 14:21' prior: 26265326!packageOfClass: aClass	^ self packageOfClass: aClass ifNone: [self noPackageFound]! !!PackageOrganizer methodsFor: 'searching' stamp: 'kph 5/30/2008 20:47'!packageOfMethodCategory: categoryName ofClass: aClass ifNone: errorBlock	^ self packageInfos detect: [:ea | ea includesMethodCategory: categoryName ofClassNamed: aClass] ifNone: errorBlock		! !!PackageOrganizer methodsFor: 'searching' stamp: 'nk 6/24/2004 16:02'!packageOfMethodCategory: categoryName ofClass: aClass	^self packageOfMethodCategory: categoryName ofClass: aClass ifNone: [ self noPackageFound ]! !!PackageOrganizer methodsFor: 'searching' stamp: 'kph 5/30/2008 20:47' prior: 26265866!packageOfMethod: aMethodReference ifNone: errorBlock	^ self packageInfos detect: [:ea | ea includesMethodReference: aMethodReference] ifNone: errorBlock! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 10/11/2003 14:21' prior: 26265683!packageOfMethod: aMethodReference	^ self packageOfMethod: aMethodReference ifNone: [self noPackageFound]! !!PackageOrganizer methodsFor: 'searching' stamp: 'kph 5/30/2008 20:47'!packageOfSystemCategory: aSystemCategory ifNone: errorBlock	^ self packageInfos detect: [:ea | ea includesSystemCategory: aSystemCategory] ifNone: errorBlock! !!PackageOrganizer methodsFor: 'searching' stamp: 'nk 6/24/2004 15:55'!packageOfSystemCategory: aSystemCategory	^ self packageOfSystemCategory: aSystemCategory ifNone: [ self noPackageFound ]! !!PackageOrganizer methodsFor: 'accessing' stamp: 'kph 9/2/2008 04:53' prior: 26264012!packages	^ packages! !!PackageOrganizer methodsFor: 'registering' stamp: 'avi 11/12/2003 21:08' prior: 26264468!registerPackageNamed: aString	^ self registerPackage: (PackageInfo named: aString)! !!PackageOrganizer methodsFor: 'registering' stamp: 'avi 11/12/2003 23:01' prior: 26264250!registerPackage: aPackageInfo	packages at: aPackageInfo packageName put: aPackageInfo.	self changed: #packages; changed: #packageNames.! !!PackageOrganizer methodsFor: 'registering' stamp: 'kph 10/26/2008 00:46'!unregisterPackageInfoClass: aClass	self packages copy keysAndValuesDo: [ :k :v | v class = aClass ifTrue: [ self packages removeKey: k ] ]! !!PackageOrganizer methodsFor: 'registering' stamp: 'kph 5/31/2008 01:19' prior: 26264854!unregisterPackageNamed: packageName	packages removeKey: packageName ifAbsent: [].		self changed: #packages; changed: #packageNames. ! !!PackageOrganizer methodsFor: 'registering' stamp: 'avi 11/12/2003 23:08' prior: 26264631!unregisterPackage: aPackageInfo	packages removeKey: aPackageInfo packageName ifAbsent: [].		self changed: #packages; changed: #packageNames.! !!PackageServices class methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 13:01' prior: 26280604!allServices	^ ServiceClasses gather: [:ea | ea services]! !!PackageServices class methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 12:59' prior: 26280894!register: aClass	ServiceClasses add: aClass! !!PackageServices class methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 12:59' prior: 26281031!unregister: aClass	ServiceClasses remove: aClass! !!PackageServices methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 14:06' prior: 26280389!seeClassSide! !!PackageServices class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:40' prior: 26280764!initialize	ServiceClasses := Set new! !!Class methodsFor: '*packageinfo-base' stamp: 'kph 6/1/2008 14:18'!isKernelClass^ false ! !!Class methodsFor: '*packageinfo-base' stamp: 'kph 6/1/2008 14:48'!isSqueakOnlyClass^ false ! !!FileDirectory methodsFor: '*packageinfo-base' stamp: 'kph 12/6/2008 02:45'!allEntriesAsFDs	^ self entriesRecursive: true on: OrderedCollection new ! !!FileDirectory methodsFor: '*packageinfo-base' stamp: 'kph 12/6/2008 02:44'!entriesAsFDs	^ self entriesRecursive: false on: OrderedCollection new ! !!FileDirectory methodsFor: '*packageinfo-base' stamp: 'kph 12/6/2008 05:47'!entriesRecursive: isRecursive on: aCollection		| aFD |			self entries do: [ :dirEntry | 			aFD := self fullNameFor: dirEntry name.		dirEntry isDirectory 			ifTrue: [ isRecursive ifTrue: [ (FileDirectory on: aFD) entriesRecursive: isRecursive on: aCollection ] ]			ifFalse: [ aCollection add: (FileDirectory on: aFD) ]	]. 	^ aCollection! !!Character methodsFor: '*packageinfo-base' stamp: 'ab 5/31/2003 17:15' prior: 18447622!escapeEntities	#($< '&lt;' $> '&gt;' $& '&amp;') pairsDo:		[:k :v |		self = k ifTrue: [^ v]].	^ String with: self! !!PositionableStream methodsFor: '*packageinfo-base' stamp: 'nk 6/17/2003 07:45' prior: 27646484!untilEnd: aBlock displayingProgress: aString	aString		displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:			[:bar |			[self atEnd] whileFalse:				[bar value: self position.				aBlock value]].! !!String methodsFor: '*packageinfo-base' stamp: 'ab 5/31/2003 17:13' prior: 31262515!escapeEntities	^ String streamContents: [:s | self do: [:c | s nextPutAll: c escapeEntities]]! !----End fileIn of a stream----!!String methodsFor: '*monticello' stamp: 'kph 5/26/2007 10:52'!displayProgress: existingBarOrNil at: aPoint from: minVal to: maxVal during: workBlock   	existingBarOrNil ifNil: [		self displayProgressAt: Sensor cursorPoint			from: minVal to: maxVal			during: workBlock.		]	ifNotNil: [ 		existingBarOrNil value: (existingBarOrNil value: #setMax) + (maxVal - minVal). 		existingBarOrNil value: self.		workBlock value: existingBarOrNil.	].! !!String methodsFor: '*monticello' stamp: 'avi 2/4/2004 14:14' prior: 31262173!extractNumber	^ ('0', self select: [:ea | ea isDigit]) asNumber! !!TimeStamp class methodsFor: '*monticello-instance creation' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 32765618!fromMethodTimeStamp: aString	| stream |	stream := ReadStream on: aString.	stream skipSeparators.	stream skipTo: Character space.	^self readFrom: stream.! !!TimeStamp class methodsFor: '*monticello-instance creation' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 32766151!readFrom: stream	| date time |	stream skipSeparators.	date := Date readFrom: stream.	stream skipSeparators.	time := Time readFrom: stream.	^self 		date: date		time: time! !!Stream methodsFor: '*monticello' stamp: 'cwp 8/9/2003 12:02' prior: 31023110!isMessageStream	^ false! !!Class methodsFor: '*monticello' stamp: 'al 3/26/2006 21:31' prior: 18548632!asClassDefinition	^ MCClassDefinition		name: self name		superclassName: self superclass name		traitComposition: self traitCompositionString		classTraitComposition: self class traitCompositionString		category: self category 		instVarNames: self instVarNames		classVarNames: self classVarNames		poolDictionaryNames: self poolDictionaryNames		classInstVarNames: self class instVarNames		type: self typeOfClass		comment: self organization classComment	 asString		commentStamp: self organization commentStamp	! !!Class methodsFor: '*monticello' stamp: 'avi 3/10/2004 13:32' prior: 18549217!classDefinitions	^ Array with: self asClassDefinition! !!Class methodsFor: '*monticello' stamp: 'ab 4/14/2003 22:30' prior: 18549338!poolDictionaryNames	^ self sharedPools collect: [:ea | self environment keyAtIdentityValue: ea]! !!Trait methodsFor: '*monticello' stamp: 'al 3/26/2006 21:44' prior: 32868047!asClassDefinition	^ MCTraitDefinition		name: self name		traitComposition: self traitCompositionString		category: self category 		comment: self organization classComment asString		commentStamp: self organization commentStamp.! !!Trait methodsFor: '*monticello' stamp: 'al 3/26/2006 21:45' prior: 32868344!classDefinitions	| definitions |	definitions := OrderedCollection with: self asClassDefinition.	(self hasClassTrait		and: [self classTrait hasTraitComposition]		and: [self classTrait traitComposition isEmpty not])			ifTrue: [definitions add: self classTrait asMCDefinition].	^definitions asArray! !!MethodReference methodsFor: '*monticello' stamp: 'ab 8/22/2003 17:55' prior: 24484227!asMethodDefinition	^ MCMethodDefinition forMethodReference: self! !!MethodReference methodsFor: '*monticello' stamp: 'ab 8/22/2003 17:58' prior: 24484519!compiledMethod	^ self actualClass compiledMethodAt: methodSymbol! !!MethodReference methodsFor: '*monticello' stamp: 'ab 8/22/2003 17:59' prior: 24484815!source	^ (self actualClass sourceCodeAt: methodSymbol) asString withSqueakLineEndings! !!MethodReference methodsFor: '*monticello' stamp: 'ab 8/22/2003 17:58' prior: 24484978!timeStamp	^ self compiledMethod timeStamp! !!PseudoClass methodsFor: '*monticello' stamp: 'bf 7/25/2005 15:50' prior: 28351178!asClassDefinition	^ MCClassDefinition		name: self name		superclassName: self superclass name		category: self category 		instVarNames: self instVarNames		classVarNames: self classVarNames asSortedCollection		poolDictionaryNames: self poolDictionaryNames		classInstVarNames: self class instVarNames		type: self typeOfClass		comment: self organization classComment	 asString		commentStamp: self organization commentStamp	! !!PseudoClass methodsFor: '*monticello-override' stamp: 'nk 2/18/2004 18:30' prior: 28351690!isMeta	^false! !!CrLfFileStream methodsFor: '*monticello' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 19355351!lineEndingConvention: aSymbol		lineEndConvention := aSymbol! !!ClassTrait methodsFor: '*monticello' stamp: 'al 3/26/2006 21:31' prior: 18700810!asMCDefinition	^MCClassTraitDefinition		baseTraitName: self baseTrait name		classTraitComposition: self traitCompositionString			! !!PseudoMetaclass methodsFor: '*monticello-override' stamp: 'nk 2/18/2004 18:30' prior: 28356678!isMeta	^true! !!MCAncestry commentStamp: '<historical>' prior: 23200497!Abstract superclass of records of ancestry.!!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:57' prior: 23200609!allAncestorsDo: aBlock	self ancestors do:		[:ea |		aBlock value: ea.		ea allAncestorsDo: aBlock]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:57' prior: 23200779!allAncestorsOnPathTo: aVersionInfo	^ MCFilteredVersionSorter new		target: aVersionInfo;		addAllVersionInfos: self ancestors;		sortedVersionInfos! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:57' prior: 23200997!ancestorString	^ String streamContents:		[:s | self ancestors do: [:ea | s nextPutAll: ea name] separatedBy: [s nextPutAll: ', ']]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:57' prior: 23201199!ancestors	^ ancestors ifNil: [#()]! !!MCAncestry methodsFor: 'ancestry' stamp: 'bf 12/22/2004 21:55' prior: 23201304!ancestorsDoWhileTrue: aBlock	self ancestors do:		[:ea |		(aBlock value: ea) ifTrue: 			[ea ancestorsDoWhileTrue: aBlock]]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 9/17/2005 16:03' prior: 23201499!breadthFirstAncestors	^ Array streamContents: [:s | self breadthFirstAncestorsDo: [:ea | s nextPut: ea]]! !!MCAncestry methodsFor: 'ancestry' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23201685!breadthFirstAncestorsDo: aBlock	| seen todo next |	seen := Set with: self.	todo := OrderedCollection with: self.	[todo isEmpty] whileFalse:		[next := todo removeFirst.		next ancestors do:			[:ea |			(seen includes: ea) ifFalse:				[aBlock value: ea.				seen add: ea.				todo add: ea]]]! !!MCAncestry methodsFor: 'ancestry' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23202518!commonAncestorWith: aNode	| commonAncestors |	commonAncestors := self commonAncestorsWith: aNode.	^ commonAncestors at: 1 ifAbsent: [nil]! !!MCAncestry methodsFor: 'ancestry' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23202062!commonAncestorsWith: aVersionInfo	| sharedAncestors mergedOrder sorter |	sorter := MCVersionSorter new						addVersionInfo: self;						addVersionInfo: aVersionInfo.	mergedOrder := sorter sortedVersionInfos.	sharedAncestors := (sorter allAncestorsOf: self) intersection: (sorter allAncestorsOf: aVersionInfo).	^ mergedOrder select: [:ea | sharedAncestors includes: ea]! !!MCAncestry methodsFor: 'ancestry' stamp: 'jrp 7/12/2004 08:16' prior: 23202728!hasAncestor: aVersionInfo	^ self		hasAncestor: aVersionInfo		alreadySeen: OrderedCollection new! !!MCAncestry methodsFor: 'ancestry' stamp: 'jrp 7/12/2004 08:16' prior: 23202896!hasAncestor: aVersionInfo alreadySeen: aList	(aList includes: self) ifTrue: [^ false].	aList add: self.	^ self = aVersionInfo or: [self ancestors anySatisfy: [:ea | ea hasAncestor: aVersionInfo alreadySeen: aList]]! !!MCAncestry methodsFor: 'initializing' stamp: 'kph 5/17/2007 05:50' prior: 23204181!initialize ! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 2/12/2004 20:58' prior: 23203185!isRelatedTo: aVersionInfo	^ aVersionInfo timeStamp < self timeStamp		ifTrue: [self hasAncestor: aVersionInfo]		ifFalse: [aVersionInfo hasAncestor: self]! !!MCAncestry methodsFor: 'ancestry' stamp: 'kph 5/30/2008 21:01'!size^ self ancestors size! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 9/11/2004 15:08' prior: 23203410!stepChildren	^ stepChildren ifNil: [#()]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 9/14/2004 15:21' prior: 23203521!stepChildrenString	^ String streamContents:		[:s | self stepChildren do: [:ea | s nextPutAll: ea name] separatedBy: [s nextPutAll: ', ']]! !!MCAncestry methodsFor: 'ancestry' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23203741!topologicalAncestors	| frontier f |	^ Array streamContents:		[:s |		frontier := MCFrontier frontierOn: self.		[f := frontier frontier.		s nextPutAll: f.		frontier removeAll: f.		f isEmpty] whileFalse] ! !!MCAncestry methodsFor: 'ancestry' stamp: 'mtf 6/9/2008 20:03'!trimAfterVersionInfo: aVersionInfo	aVersionInfo = self		ifTrue: [ancestors := #()]		ifFalse:			[aVersionInfo date <= self date ifTrue:				[self ancestors do: [:ea | ea trimAfterVersionInfo: aVersionInfo]]		]! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 9/17/2005 16:03' prior: 23204020!withBreadthFirstAncestors	^ (Array with: self), self breadthFirstAncestors! !!MCVersionInfo commentStamp: 'kph 6/2/2008 14:11' prior: 23590049!I am used as a handle for the UI to reference persisted versions and to obtain the relationships between versions.Some repositories only supply a filename as an initial handle, and so to realise thefull data from the repository, use #realizeFrom: aRepositoryAdds to the record of ancestry, other identifying details.Names:The defining point in the name is the 'firstDot' after the first $- (i.e. in some cases it may not actually be the first dot overall), all parts in the name are parsed relative to this. My-Package-kph.234.mcz is split into 'My-Package-kph' and '234.mcz' first. The #namePreFirstDot is split on the last $- to obtain the packgeName/author. The version is obtained upTo the last $( or $. in the second #postFirstDot portion,  this may be a uuid or, it may even contain $. as in traditional version numbering schemes.   VersionInfo does not have any notion of a file extn, whereas VersionInfoFilename does, and this is taken to be everything after the last $. PackageName - any characters including $- .Author - any characters except $- or $.Version - any characters including $- or $.Any older packages which have $- in the author/version suffix must be renamedUUID's are valid versionnumbers if $- is replcaed by $.!!MCSystemChangeSetVersionInfo class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 13:51'!on: cs	^ (self new) initializeFromCS: cs! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 14:04'!= other	^ other species = self species		and: [other csName = self csName]! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:36'!author	^ Utilities authorInitials! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:33'!csName	"Answer the value of csName"	^ csName! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:33'!csName: anObject	"Set the value of csName"	csName := anObject! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 14:03'!hash^ csName hash! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:45'!initializeFromCS: cs	csName := cs name.		message := 'System Change Set'.! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:43'!name	^ csName, '-', self author! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:37'!packageName	^ csName! !!MCSystemChangeSetVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:36'!version	^ '1'! !!MCVersionInfo class methodsFor: 'as yet unclassified' stamp: 'kph 6/29/2007 03:47'!firstVersionForPackage: packageName	^ (self new) name: (packageName, '-', Utilities authorInitials, '.1')! !!MCVersionInfo class methodsFor: 'as yet unclassified' stamp: 'kph 8/1/2007 01:40'!name: vName id: id author: author 	^ self new		name: vName		id: id 		author: author	 ! !!MCVersionInfo class methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:44' prior: 23593117!name: vName id: id message: message date: date time: time author: author ancestors: ancestors	^ self 		name: vName		id: id		message: message		date: date		time: time		author: author		ancestors: ancestors		stepChildren: #()! !!MCVersionInfo class methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:43' prior: 23593437!name: vName id: id message: message date: date time: time author: author ancestors: ancestors stepChildren: stepChildren	^ self new		initializeWithName: vName		id: id		message: message		date: date		time: time		author: author		ancestors: ancestors		stepChildren: stepChildren! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'mtf 6/27/2008 22:53'!<= otherInfo	^ (self versionNumbers copyWithFirst: self packageName)		mcLessThan: (otherInfo versionNumbers copyWithFirst: otherInfo packageName)		ifEqual: [self name <= otherInfo name]! !!MCVersionInfo methodsFor: 'comparing' stamp: 'ab 7/5/2003 14:23' prior: 23591509!= other	^ other species = self species		and: [other hasID: id]! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'mtf 6/27/2008 23:08'!> otherInfo	^ (self <= otherInfo) not! !!MCVersionInfo methodsFor: 'converting' stamp: 'kph 5/17/2007 13:40' prior: 23591648!asDictionary	^ Dictionary new		at: #name put: self name;		at: #id put: self id;		at: #message put: self message;		at: #date put: self date;		at: #time put: self time;		at: #author put: self author;		at: #ancestors put: (self ancestors collect: [:a | a asDictionary]);		yourself! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 5/17/2007 03:01' prior: 23592382!author	^ author ifNil: [ self authorFromName ]		 ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 2/7/2009 18:25'!authorFromName 	 	| authorTokens out |		authorTokens := OrderedCollection new.		self nameAfterLastDashAsTokens do: [ : token |		token first isDigit ifFalse: [ authorTokens add: token ].		].	out := String streamContents: [:str | 	   authorTokens do: [ :ea | str nextPutAll: ea ; nextPut: $. ]	].	^ out allButLast ! !!MCVersionInfo methodsFor: '' stamp: 'kph 8/1/2007 12:24'!browseVersionFrom: repository	(repository versionWithInfo: self) browseFrom: repository		! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'cwp 8/1/2003 00:26' prior: 23592471!date	^ date! !!MCVersionInfo methodsFor: 'printing' stamp: 'kph 11/16/2007 23:23'!description^ self name! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 6/29/2007 06:50'!extractLeastSignificantVersionNumberPartFrom: v	| foundDigits first num |	foundDigits := nil.	first := nil.	v size to: 1 by: -1 do: [ :i | 		first ifNil: [ (v at: i) isDigit ifTrue: [ foundDigits := i	]						ifFalse: [ foundDigits ifNotNil: [ first := foundDigits ] ] ]	].	first ifNil: [ first := 1 ].	^ Array 		with: (first > 1 ifTrue: [ v copyFrom: 1 to: first -1  ] ifFalse: [ '' ])		with: (num := (v copyFrom: first to: v size) asNumber)		with: (((num := first + num asString size) > v size) ifTrue: ['']				ifFalse: [ v copyFrom: num to: v size ])  ! !!MCVersionInfo methodsFor: 'private' stamp: 'ab 7/5/2003 14:10' prior: 23592893!hasID: aUUID	^ id = aUUID! !!MCVersionInfo methodsFor: '' stamp: 'kph 8/1/2007 12:30'!hasSnapshot	^ true! !!MCVersionInfo methodsFor: 'comparing' stamp: 'ab 7/5/2003 14:09' prior: 23591422!hash	^ id hash! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'cwp 8/1/2003 00:24' prior: 23592556!id	^ id ! !!MCVersionInfo methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23591999!initializeWithName: vName id: aUUID message: aString date: aDate time: aTime author: initials ancestors: aCollection stepChildren: stepCollection	name := vName.	id := aUUID.	message := aString.	date := aDate.	time := aTime.	author := initials.	ancestors :=  aCollection.	stepChildren := stepCollection! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 5/17/2007 05:52'!isFilename	^ false! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 6/28/2008 09:39'!isUIDVersion  	self versionTokens reverse 		in: [ :vn |			((vn size > 2 and: [ vn third size = 8]) and: [ vn second size = 9 ]) ifFalse: [ ^ false ]	].	^ true! !!MCVersionInfo methodsFor: '' stamp: 'kph 12/8/2008 10:00'!loadVersionFrom: repository	(version := repository versionWithInfo: self) loadFrom: repository.		version package packageInfo propertyAt: #repository put: repository description! !!MCVersionInfo methodsFor: '' stamp: 'kph 8/1/2007 12:52'!mergeVersionFrom: repository	(repository versionWithInfo: self) mergeFrom: repository		! !!MCVersionInfo methodsFor: 'accessing' stamp: 'ab 7/12/2003 00:04' prior: 23590179!message	^ message ifNil: ['']! !!MCVersionInfo methodsFor: 'accessing' stamp: 'ab 7/11/2003 23:33' prior: 23590282!name	^ name ifNil: ['<working copy>']! !!MCVersionInfo methodsFor: 'accessing' stamp: 'kph 6/29/2007 02:44'!name: aName		name := aName! !!MCVersionInfo methodsFor: '' stamp: 'kph 8/1/2007 01:41'!name: vName id: anId author: anAuthor 	self name: vName.	id := anId.	author := anAuthor.! !!MCVersionInfo methodsFor: 'accessing' stamp: 'kph 6/2/2008 13:27'!nameAfterLastDash	^ name copyAfterLast: $- ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 6/28/2008 08:02'!nameAfterLastDashAsTokens	| stream tokens |	stream := self nameAfterLastDashUpToBracket readStream.	tokens := OrderedCollection new.	[stream atEnd] whileFalse: [				tokens add: (stream upTo: $.)	].	^ tokens! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 6/28/2008 07:38'!nameAfterLastDashUpToBracket		"version string includes the author initials and the version numbers" 		^ self nameAfterLastDash copyUpTo: $(! !!MCVersionInfo methodsFor: 'accessing' stamp: 'kph 6/2/2008 13:29'!nameBeforeLastDash	^ name copyUpToLast: $- ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 2/7/2009 18:24'!nextUIDBasedVersion		^ self class new name: (self packageName, '-', Utilities authorInitials, '.' , (self versionStringFrom: self nextUIDBasedVersionTokens)); yourself ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 2/7/2009 18:24'!nextUIDBasedVersionTokens		"The Universal ID is not a true GUID but a simpler sortable timestamp based equivalent."	 	| t count tokens |		"copyReplaceAll is more backwards compatible than replacing:with: "		tokens := self versionTokens.		count := tokens last asNumber.		t := DateAndTime now.	tokens at: (tokens size - 2) put: (t asDate printFormat: #(3 2 1 0 1 1 2)).	t := t asTime.	tokens at: (tokens size - 1) put: (t print24 reject: [ :ea | ea = $: ]), 	(t milliSecond asString padded: #left to: 3	with: $0).	tokens at: tokens size put: (count + 1) asString.		^ tokens	! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 6/28/2008 07:45'!nextVersion	|v num newVersion result  |	self isUIDVersion		ifTrue: [ ^self nextUIDBasedVersion ].	"we hunt backwards through the version string, starting at the first number we constuce thatnumber until we find a non digit. e.g. from 4.1.13b we would obtain 13."	v := self versionString.	 	result := 	self extractLeastSignificantVersionNumberPartFrom: v.		num := result second.	num = 0 ifTrue: [ " no number found"  self error: 'no version number found' ].	newVersion := result first , (num + 1) asString , result last.  	^ self copy name: (self packageName, '-', Utilities authorInitials, '.', newVersion)	 ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 7/11/2007 07:44'!nextVersionConsidering: ancestry	| v  myParts ancestorParts num | 	v := self versionString.	myParts := self extractLeastSignificantVersionNumberPartFrom: v.	num := myParts second.	ancestry ancestors do: [ :each | 			ancestorParts := each extractLeastSignificantVersionNumberPartFrom: v.			((myParts first = ancestorParts first) and: [ myParts last = ancestorParts last ]) 		ifTrue: [ num := num max: ancestorParts second ].	].  	^ self copy name: (self packageName, '-', Utilities authorInitials, '.', myParts first , (num + 1) asString , myParts last). ! !!MCVersionInfo methodsFor: 'accessing' stamp: 'kph 6/2/2008 13:29'!packageName	^ self nameBeforeLastDash! !!MCVersionInfo methodsFor: 'printing' stamp: 'ab 7/5/2003 18:00' prior: 23592722!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self name; nextPut: $)	! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 5/17/2007 05:54'!realizeFrom: aRepository	^ self ! !!MCVersionInfo methodsFor: 'accessing' stamp: 'avi 1/20/2004 16:08' prior: 23590394!summary	^ String streamContents:		[:s |		s			nextPutAll: self summaryHeader; cr; cr;			nextPutAll: self message.		]! !!MCVersionInfo methodsFor: 'accessing' stamp: 'kph 5/17/2007 13:42' prior: 23590589!summaryHeader	^ String streamContents:		[:s |		s			nextPutAll: 'Name: '; nextPutAll: self name; cr.		date ifNotNil:			[s				nextPutAll: 'Author: '; nextPutAll: self author; cr;				nextPutAll: 'Time: '; nextPutAll:  self date asString, ', ', self time asString; cr].		id ifNotNil:			[s nextPutAll: 'UUID: '; nextPutAll: self id asString; cr].		s			nextPutAll: 'Ancestors: '; nextPutAll: self ancestorString.		self stepChildren isEmpty ifFalse:			[s cr; nextPutAll: 'Backported From: '; nextPutAll: self stepChildrenString].		]! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'cwp 8/1/2003 00:26' prior: 23592638!time	^ time! !!MCVersionInfo methodsFor: 'accessing' stamp: 'avi 1/22/2004 16:45' prior: 23591183!timeStamp	^ TimeStamp date: date time: time! !!MCVersionInfo methodsFor: 'accessing' stamp: 'avi 9/17/2003 11:24' prior: 23591301!timeString	^ date asString, ', ', time asString! !!MCVersionInfo methodsFor: 'accessing' stamp: 'kph 8/16/2007 18:14'!versionName	^ name! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'mtf 6/28/2008 11:02'!versionNumbers"To enable a smooth transition to more informative version numbers, we cause old, single-digit version numbers to sort prior to newer version numbers, by sorting as if old versions are 0.0.x"	| array |	array := self versionTokens collect: [ :ea | ea asInteger ].	^ array size <= 1		ifTrue: [#(0 0), array]		ifFalse: [array]	 ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 2/7/2009 18:24'!versionString		^ self versionStringFrom: self versionTokens	 ! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'kph 2/7/2009 18:24'!versionStringFrom: tokens	 	"version string includes the author initials and the version numbers" 		^ String streamContents: [:stream | tokens		do: [:ea | stream nextPutAll: ea]		separatedBy: [stream nextPut: $.]]! !!MCVersionInfo methodsFor: 'pillaging' stamp: 'mtf 7/21/2008 21:52'!versionTokens	^ self nameAfterLastDashAsTokens select: [ :ea | ea notEmpty and: [ ea first isDigit ] ]  ! !!MCVersionInfoFilename commentStamp: 'kph 6/28/2007 23:55' prior: 0!For filenamesProject-Subcategory-author.123.mczEverything after the first $. is the version string, this allows for more variation, and is more flexible in the case of different file types and conventions, e.g. .mcm!!MCVersionInfoFilename class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 05:51'!filename: filename	"using MCVersionInfo to represent a filename"		^ (self new) 		setFilename: filename; yourself		! !!MCVersionInfoFilename methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 06:16'!= other	^ other species = self species		and: [other name = name]! !!MCVersionInfoFilename methodsFor: '' stamp: 'kph 9/28/2007 11:13'!ext 	^ name  copyAfterLast: $.! !!MCVersionInfoFilename methodsFor: '' stamp: 'kph 9/28/2007 11:13'!hasSnapshot	^ self ext = 'mcz'! !!MCVersionInfoFilename methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 06:43'!hash	^ name hash! !!MCVersionInfoFilename methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 05:53'!isFilename	^ true! !!MCVersionInfoFilename methodsFor: 'accessing' stamp: 'mtf 6/27/2008 01:18'!nameAfterLastDash	"we strip the extension and everyone else should be happy"	^ super nameAfterLastDash copyUpToLast: $. ! !!MCVersionInfoFilename methodsFor: 'accessing' stamp: 'kph 2/7/2009 18:24'!nextUIDBasedVersion		^ self class new name: (self packageName, '-', Utilities authorInitials, '.' , (self versionStringFrom: self nextUIDBasedVersionTokens), '.', self ext); yourself ! !!MCVersionInfoFilename methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 05:54'!realizeFrom: aRepository	^ aRepository realizeFullVersionInfo: self ! !!MCVersionInfoFilename methodsFor: 'accessing' stamp: 'kph 5/17/2007 05:55'!setFilename: n	name := n. ! !!MCVersionInfoFilename methodsFor: 'accessing' stamp: 'kph 1/28/2008 02:09'!versionName	"we probably dont need to but..."	^ versionName ifNil: [versionName := name copyUpToLast: $.  ] ! !!MCWorkingAncestry commentStamp: '<historical>' prior: 23620895!The interim record of ancestry for a working copy, gets merged version added to the ancestry, and is used to create the VersionInfo when the working copy becomes a version. !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'bf 11/7/2005 11:37' prior: 23621166!addAncestor: aNode	"Add aNode, remove ancestors of it, preserve original order"	| writeNode |	writeNode := true.	"Write aNode only once, replacing the first of its ancestors, or add last"	ancestors := Array streamContents: [:newAncestors |		self ancestors do: [:each |			(aNode hasAncestor: each)				ifTrue: [writeNode ifTrue: [newAncestors nextPut: aNode. writeNode := false]]				ifFalse: [newAncestors nextPut: each]].		writeNode ifTrue: [newAncestors nextPut: aNode. writeNode := false]].! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'abc 7/3/2007 22:07' prior: 23621374!addStepChild: aVersionInfo	stepChildren := self stepChildren copyWith: aVersionInfo! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'avi 10/22/2005 19:58'!date	^ Date today! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'ul 6/8/2007 01:31' prior: 23621541!infoWithName: nameString message: messageString	^ MCVersionInfo		name: nameString		id: UUID new		message: messageString		date: Date today		time: Time now		author: Utilities authorInitials		ancestors: (ancestors ifNil: [ #() ]) asArray		stepChildren: self stepChildren asArray! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:14' prior: 23621896!name	^ '<working copy>'! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:14' prior: 23622008!summary	^ 'Ancestors: ', self ancestorString! !!MCConfiguration class methodsFor: 'class initialization' stamp: 'bf 4/20/2005 17:20' prior: 23260439!initialize	"MCConfiguration initialize"	Preferences addPreference: #upgradeIsMerge		categories: #('updates') default: false 		balloonHelp: 'When upgrading packages, use merge instead of load'.! !!MCConfiguration class methodsFor: 'accessing' stamp: 'ar 5/27/2005 17:27' prior: 23260122!defaultLog	"Answer the default configuration log"	^DefaultLog! !!MCConfiguration class methodsFor: 'accessing' stamp: 'ar 5/27/2005 17:27' prior: 23260266!defaultLog: aStream	"Set the default configuration log"	DefaultLog := aStream.! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 3/24/2005 01:43' prior: 23260719!dependencyFromArray: anArray	^MCVersionDependency		package: (MCPackage named: anArray first)		info: (			MCVersionInfo			name: anArray second			id: (UUID fromString: anArray third)			message: nil			date: nil			time: nil			author: nil			ancestors: nil)! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 3/24/2005 01:44' prior: 23261062!dependencyToArray: aDependency	^ {		aDependency package name . 		aDependency versionInfo name . 		aDependency versionInfo id asString }! !!MCConfiguration class methodsFor: 'instance creation' stamp: 'bf 3/24/2005 01:51' prior: 23261727!fromArray: anArray	| configuration |	configuration := self new.	anArray pairsDo: [:key :value |		key = #repository			ifTrue: [configuration repositories add: (self repositoryFromArray: value)].		key = #dependency			ifTrue: [configuration dependencies add: (self dependencyFromArray: value)].	].	^configuration! !!MCConfiguration class methodsFor: 'converting' stamp: 'djr 7/1/2008 16:51' prior: 23261282!repositoryFromArray: anArray 	^ MCRepositoryGroup default repositories		detect: [:repo | repo description = anArray first]		ifNone: [(self seeIfRelativeDirectory: anArray first)				ifNil: [MCHttpRepository						location: anArray first						user: ''						password: '']]! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 3/24/2005 01:51' prior: 23261578!repositoryToArray: aRepository	^ {aRepository description}! !!MCConfiguration class methodsFor: 'converting' stamp: 'djr 7/1/2008 16:52'!seeIfRelativeDirectory: aPath 	| possiblePath |	possiblePath := FileDirectory				on: (FileDirectory default fullNameFor: aPath).	^ possiblePath exists		ifTrue: [MCDirectoryRepository new directory: possiblePath]		ifFalse: [ nil ]! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 3/22/2005 22:09' prior: 23253114!browse	(MCConfigurationBrowser new configuration: self) show! !!MCConfiguration methodsFor: 'faking' stamp: 'bf 3/24/2005 01:19' prior: 23254276!changes	^MCPatch operations: #()! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/21/2005 16:32' prior: 23251731!dependencies	^dependencies ifNil: [dependencies := OrderedCollection new]! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/21/2005 18:40' prior: 23251880!dependencies: aCollection	dependencies := aCollection! !!MCConfiguration methodsFor: 'private' stamp: 'kph 8/2/2007 00:01' prior: 23256157!depsSatisfying: selectBlock versionDo: verBlock displayingProgress: progressString	| repoMap count |	repoMap := Dictionary new. 	self repositories do: [:repo |		MCRepositoryGroup default addRepository: repo.		repo allVersionNames			ifEmpty: [self logWarning: 'cannot read from ', repo description]			ifNotEmptyDo: [:all | all do: [:ver | repoMap at: ver put: repo]]].	count := 0.	self dependencies do: [:dep |		| ver repo |		ver := dep versionInfo.		repo := repoMap at: ver versionName ifAbsent: [			self logError: 'Version ', ver name, ' not found in any repository'.			self logError: 'Aborting'.			^count].		(selectBlock value: dep) ifTrue: [			| new |			new := self versionNamed: ver for: dep from: repo.			new ifNil: [					self logError: 'Could not download version ', ver name, ' from ', repo description.					self logError: 'Aborting'.					^count]				ifNotNil: [					self logUpdate: dep package with: new.					ProgressNotification signal: '' extra: 'Installing ', ver name.					verBlock value: new.					count := count + 1.				]		].		dep package workingCopy repositoryGroup addRepository: repo.	] displayingProgress: progressString.	^count! !!MCConfiguration methodsFor: 'private' stamp: 'kph 8/1/2007 15:23'!diffVersionInfoFor: aDependency	| wc |	aDependency package hasWorkingCopy  ifFalse: [^nil].	wc := aDependency package workingCopy.	wc ancestors ifEmpty: [^nil].	^wc ancestors first  ! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 18:22' prior: 23252009!fileName	^ self name, '.', self writerClass extension! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 3/22/2005 10:51' prior: 23253248!fileOutOn: aStream	self writerClass fileOut: self on: aStream! !!MCConfiguration methodsFor: 'faking' stamp: 'bf 3/24/2005 01:17' prior: 23254381!info	^MCVersionInfo new! !!MCConfiguration methodsFor: 'initialize' stamp: 'ar 5/27/2005 17:28' prior: 23254482!initialize	super initialize.	log := DefaultLog.! !!MCConfiguration methodsFor: 'testing' stamp: 'bf 3/22/2005 22:56' prior: 23254605!isCacheable	^false! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 4/22/2005 17:19' prior: 23253383!load	^self depsSatisfying: [:dep | dep isCurrent not]		versionDo: [:ver | ver load]		displayingProgress: 'loading packages'! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 6/9/2005 15:58' prior: 23252138!log	^log ifNil: [Transcript]! !!MCConfiguration methodsFor: 'accessing' stamp: 'ar 4/28/2005 11:55' prior: 23252242!log: aStream	log := aStream.! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 16:07' prior: 23257638!logError: aString	self log		cr; nextPutAll: 'ERROR: ';		nextPutAll: aString; cr;		flush.! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 15:59' prior: 23257803!logUpdate: aPackage with: aVersion	self log		cr; nextPutAll: '========== ', aVersion info name, ' =========='; cr;		cr; nextPutAll: aVersion info message asString; cr;		flush.	aPackage hasWorkingCopy ifFalse: [^self].	aPackage workingCopy ancestors do: [:each |		(aVersion info hasAncestor: each)			ifTrue: [(aVersion info allAncestorsOnPathTo: each)				do: [:ver | self log cr; nextPutAll: '>>> ', ver name, ' <<<'; cr;							nextPutAll: ver message; cr; flush]]]! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 16:08' prior: 23258351!logWarning: aString	self log		cr; nextPutAll: 'WARNING: ';		nextPutAll: aString; cr;		flush.! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 4/22/2005 17:19' prior: 23253583!merge	^self depsSatisfying: [:dep | dep isFulfilledByAncestors not]		versionDo: [:ver | ver merge]		displayingProgress: 'merging packages'! !!MCConfiguration methodsFor: 'private' stamp: 'bf 5/23/2005 14:47' prior: 23258521!mustMerge: aVersion	"answer true if we have to do a full merge and false if we can simply load instead"		| pkg wc current |	(pkg := aVersion package) hasWorkingCopy ifFalse: [^false "no wc -> load"].	(wc := pkg workingCopy) modified ifTrue: [^true "modified -> merge"].	wc ancestors isEmpty ifTrue: [^true "no ancestor info -> merge"].	current := wc ancestors first.	(aVersion info hasAncestor: current) ifTrue: [^false "direct descendant of wc -> load"].	"new branch -> merge"	^true! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 18:23' prior: 23252346!name	^name! !!MCConfiguration methodsFor: 'accessing' stamp: 'kph 8/1/2007 15:01' prior: 23252432!name: aString	(aString endsWith: self writerClass extension) 		ifTrue: [ ^ name := aString allButLast: self writerClass extension size + 1 ].	name := aString! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/23/2005 17:35' prior: 23252537!repositories	^repositories ifNil: [repositories := OrderedCollection new]! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/23/2005 17:36' prior: 23252686!repositories: aCollection	repositories := aCollection! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/23/2005 00:44' prior: 23252815!summary	^String streamContents: [:stream |		self dependencies			do: [:ea | stream nextPutAll: ea versionInfo name; cr ]]! !!MCConfiguration methodsFor: 'updating' stamp: 'bf 5/23/2005 17:43' prior: 23254699!updateFromImage	self dependencies: (self dependencies collect: [:dep |		dep package hasWorkingCopy			ifTrue: [				dep package workingCopy in: [:wc |					MCVersionDependency package: wc package info: wc ancestors first]]			ifFalse: [dep]]).! !!MCConfiguration methodsFor: 'updating' stamp: 'mtf 6/28/2008 12:00' prior: 23255019!updateFromRepositories	| oldInfos newNames sortedNames newDeps |	oldInfos := self dependencies collect: [:dep | dep versionInfo].	newNames := Dictionary new.	self repositories		do: [:repo | 			ProgressNotification signal: '' extra: 'Checking ', repo description.			(repo possiblyNewerVersionsOfAnyOf: oldInfos)				do: [:newName | newNames at: newName put: repo]]		displayingProgress: 'Searching new versions'.	sortedNames := newNames keys asSortedCollection:		[:a :b | a > b ].	newDeps := OrderedCollection new.	self dependencies do: [:dep |		| newName |		newName := sortedNames			detect: [:each | each packageName = dep versionInfo packageName]			ifNone: [nil].		newDeps add: (newName			ifNil: [dep]			ifNotNil: [				| repo ver  |				repo := newNames at: newName.				ver := self versionNamed: newName for: dep from: repo.				ver ifNil: [dep]					ifNotNil: [MCVersionDependency package: ver package info: ver info]			])	] displayingProgress: 'downloading new versions'.	self dependencies: newDeps.! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 5/23/2005 15:40' prior: 23253798!upgrade	^self depsSatisfying: [:dep | dep isFulfilledByAncestors not]		versionDo: [:ver | 			(Preferences upgradeIsMerge and: [self mustMerge: ver])				ifFalse: [ver load]				ifTrue: [[ver merge]					on: MCMergeResolutionRequest do: [:request |						request merger conflicts isEmpty							ifTrue: [request resume: true]							ifFalse: [request pass]]]]		displayingProgress: 'upgrading packages'! !!MCConfiguration methodsFor: 'private' stamp: 'kph 8/2/2007 00:05' prior: 23259087!versionNamed: verInfo for: aDependency from: repo 	|  fileName ver depVersionInfo |	(repo filterFileNames: repo cachedFileNames forVersionNamed: verInfo name) ifNotEmptyDo: [:cachedNames |		fileName := cachedNames anyOne.		ProgressNotification signal: '' extra: 'Using cached ', fileName.		ver := repo versionFromFileNamed: fileName].	ver ifNil: [	 		depVersionInfo := self diffVersionInfoFor: aDependency.		(depVersionInfo notNil and: [depVersionInfo versionName ~= verInfo versionName and: [repo includesVersionNamed: depVersionInfo versionName]]) ifTrue: [			fileName := (MCDiffyVersion nameForVer: verInfo versionName  base: depVersionInfo versionName ), '.mcd'.			(repo includesVersionNamed: fileName)  			ifTrue:[ 				ProgressNotification signal: '' extra: 'Downloading ', fileName.				ver := repo versionFromFileNamed: fileName			]	]].	ver ifNil: [	 		ProgressNotification signal: '' extra: 'Downloading ', verInfo name.		ver := repo versionWithInfo: verInfo].	^ver! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 10:50' prior: 23253013!writerClass	^ MCMcmWriter ! !!MCConflict class methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:07' prior: 23283305!operation: anOperation	^ self new operation: anOperation	! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 11/10/2003 21:57' prior: 23279893!annotations	^operation ifNotNilDo: [ :op | op annotations ]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:04' prior: 23280032!applyTo: anObject	self isResolved ifFalse: [self error: 'Cannot continue until this conflict has been resolved'].	self remoteChosen ifTrue: [operation applyTo: anObject].! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23280296!chooseLocal	chooseRemote := false! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:16' prior: 23280411!chooseNewer	self isLocalNewer ifTrue: [ self chooseLocal ]		ifFalse: [ self isRemoteNewer ifTrue: [ self chooseRemote ]]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:22' prior: 23280614!chooseOlder	self isRemoteNewer ifTrue: [ self chooseLocal ]		ifFalse: [ self isLocalNewer ifTrue: [ self chooseRemote ]]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23280828!chooseRemote	chooseRemote := true! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23280954!clearChoice	chooseRemote := nil! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 11/10/2003 21:58' prior: 23281067!definition	^operation ifNotNilDo: [ :op | op definition ]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'dvf 8/10/2004 23:24' prior: 23281206!isConflict	^true! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:11' prior: 23281304!isLocalNewer	^ self localDefinition fullTimeStamp > self remoteDefinition fullTimeStamp! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:15' prior: 23281473!isRemoteNewer	^ self localDefinition fullTimeStamp < self remoteDefinition fullTimeStamp! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:02' prior: 23281641!isResolved	^ chooseRemote notNil! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:45' prior: 23281753!localChosen	^ chooseRemote notNil and: [chooseRemote not]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:10' prior: 23281890!localDefinition	^ operation baseDefinition! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:19' prior: 23282014!operation	^ operation! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23282128!operation: anOperation	operation := anOperation! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:45' prior: 23282255!remoteChosen	^ chooseRemote notNil and: [chooseRemote]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:10' prior: 23282389!remoteDefinition	^ operation targetDefinition! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 16:47' prior: 23282515!source	^ self localChosen		ifTrue: [operation fromSource]		ifFalse: [operation source]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 13:48' prior: 23282683!status	^ self isResolved		ifFalse: ['']		ifTrue: [self remoteChosen					ifFalse: ['L']					ifTrue: ['R']]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23282885!summary	| attribute |	attribute := 		self isResolved			ifTrue: [self remoteChosen ifTrue: [#underlined] ifFalse: [#struckOut]]			ifFalse: [#bold].	^ Text string: operation summary attribute: (TextEmphasis perform: attribute)! !!MCDefinition commentStamp: 'kph 8/1/2007 10:10' prior: 0!Notes:Given that monticello uses a binary fileOut, it is not possible to add instance vars to MCDefinition or its subclasses. With the benefit of hindsight this is a slight oversight by the original developers. It makes it almost impossible to improve this heirarchy without breaking compatibility.First of all we implement a flag which enables us to enforce MC compatibility #storeAsMC1CompatibleBinary.MCDefinition's #storeDataOn: defers to #storeMC1DataOn: which enforces a fixed number of instVars (defined in #storeMaxInstVarsForMC1 and a fixed output class even for specialized subclasses, which old MC's may not recognize.This ensures that our packages can be viewed in repositoryies by old MC implementations.For the future.1) We remove ignore any restriction upon the number of inst vars that we save, unless a class wants to imlement a specific policy of its own (MCMethodDefinition has a number of instVars which are not worth persisting). 2) We implement a properties interface in each class as best we can, we cannot implement it in MCDefinition because the format comatability has to be preserved with older MCs. So we place the instance var in subclasses of MCDefinition after their own inst vars.3) we change the loading code to not-care if when loading if finds extra instance variables. It puts the extra instance varables in the properties dictionary under #extraInstVars. Then when storing we write those extraInstVars so as to preseve the format that we were given.4) New subclasses save themselves as a known superclass with extra variables and their class name stored in property #class.Accessors to properties can be placed in MCDefinition to acceive the same effect as a local instVar. For an example see #because, used in #orphanedBecause:Other Monticellos need to implement the more tolerant #instVarAt: anInteger put: anObject in order to read our 'relaxed' format. At present I can see no other way of moving forward than to force all other monticellos to patch up!! !!MCDefinition class methodsFor: '' stamp: 'mtf 12/15/2007 03:06'!initialize	"MCDefinition initialize""for the future"	"	Preferences addPreference: #storeMC1CompatibleBinary		categories: #('monticello') default: true		balloonHelp: 'Save using MC1 compatibility, readable by older Monticello versions, but not extensible'			"	self clearInstances! !!MCClassDefinition commentStamp: 'kph 5/15/2007 19:25' prior: 0!The strategy for loading is to preload a class definiton is to merge the variables wanted by both the new and the old classes, and load this 'union' class definition.This should allow old code to continue running, and new code to be compiled.Since variable order is significant, the original order is preserved for the #preload, and changed on the #install.In the atomic #install phase, the new traitComposition and comment is switched in.In the atomic #postinstall phase the #initialize methods are run (note they have access to both the old and new class variables etc. In the postload phase the new class definition is loaded, eliminating the now redundant parts.!!MCClassDefinition class methodsFor: 'obsolete' stamp: 'ab 4/1/2003 01:22' prior: 23230506!name: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraycomment: commentString	^ self	name: nameString			superclassName: superclassString			category: categoryString 			instVarNames: ivarArray			classVarNames: cvarArray			poolDictionaryNames: poolArray			classInstVarNames: civarArray			type: #normal			comment: commentString! !!MCClassDefinition class methodsFor: 'obsolete' stamp: 'cwp 8/10/2003 16:33' prior: 23231053!name: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentString	^ self 		name: nameString		superclassName: superclassString		category: categoryString 		instVarNames: ivarArray		classVarNames: cvarArray		poolDictionaryNames: poolArray		classInstVarNames: civarArray		type: typeSymbol		comment: commentString		commentStamp: nil! !!MCClassDefinition class methodsFor: 'instance creation' stamp: 'al 10/9/2005 19:16' prior: 23228881!name: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampString	^ self instanceLike:		(self new initializeWithName: nameString					superclassName: superclassString					traitComposition: '{}'					classTraitComposition: '{}'					category: categoryString 					instVarNames: ivarArray					classVarNames: cvarArray					poolDictionaryNames: poolArray					classInstVarNames: civarArray					type: typeSymbol					comment: commentString					commentStamp: stampString)! !!MCClassDefinition class methodsFor: 'obsolete' stamp: 'ab 4/1/2003 01:22' prior: 23231632!name: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArraycomment: commentString	^ self	name: nameString			superclassName: superclassString			category: categoryString 			instVarNames: ivarArray			classVarNames: #()			poolDictionaryNames: #()			classInstVarNames: #()			comment: commentString! !!MCClassDefinition class methodsFor: 'instance creation' stamp: 'al 10/10/2005 13:58' prior: 23229631!name: nameStringsuperclassName: superclassStringtraitComposition: traitCompositionStringclassTraitComposition: classTraitCompositionStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampString		^ self instanceLike:		(self new initializeWithName: nameString					superclassName: superclassString					traitComposition: traitCompositionString					classTraitComposition: classTraitCompositionString					category: categoryString 					instVarNames: ivarArray					classVarNames: cvarArray					poolDictionaryNames: poolArray					classInstVarNames: civarArray					type: typeSymbol					comment: commentString					commentStamp: stampString)! !!MCClassDefinition methodsFor: 'visiting' stamp: 'kph 10/25/2008 02:10' prior: 23228269!= aDefinition	super = aDefinition ifFalse: [ ^ false ].	superclassName = aDefinition superclassName ifFalse: [ ^ false ].	self traitCompositionString = aDefinition traitCompositionString ifFalse: [ ^ false ].	self classTraitCompositionString = aDefinition classTraitCompositionString ifFalse: [ ^ false ].	category = aDefinition category ifFalse: [ ^ false ].	type = aDefinition type ifFalse: [ ^false ].	(variables = aDefinition variables			or: [self sortedVariables = aDefinition sortedVariables]) ifFalse: [ ^false ].	comment = aDefinition comment ifFalse: [ ^ false ].		^ true		! !!MCClassDefinition methodsFor: 'visiting' stamp: 'al 10/9/2005 19:33' prior: 23226802!accept: aVisitor	aVisitor visitClassDefinition: self.	(self hasClassInstanceVariables or: [self hasClassTraitComposition])		ifTrue: [aVisitor visitMetaclassDefinition: self].! !!MCClassDefinition methodsFor: 'accessing' stamp: 'nk 2/25/2005 09:49' prior: 23216896!actualClass	^Smalltalk classNamed: self className! !!MCClassDefinition methodsFor: 'visiting' stamp: 'kph 5/13/2007 05:13'!actualSuperclass	^Smalltalk at: self superclassName ifAbsent: [ ^self orphanedBecause: 'Missing superclass  ', self superclassName]! !!MCClassDefinition methodsFor: 'accessing' stamp: 'kph 5/13/2007 02:43'!actualThing 		^ self actualClass! !!MCClassDefinition methodsFor: 'initializing' stamp: 'cwp 7/7/2003 23:19' prior: 23220608!addVariables: aCollection ofType: aClass	variables addAll: (aCollection collect: [:var | aClass name: var asString]).! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 11/24/2002 06:23' prior: 23217025!category	^ category! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:32' prior: 23217122!classInstVarNames	^ self selectVariables: #isClassInstanceVariable! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/7/2003 23:35' prior: 23222481!classInstanceVariablesString	^ self stringForVariablesOfType: #isClassInstanceVariable! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 11/13/2002 01:52' prior: 23217267!className	^ name! !!MCClassDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:07' prior: 23217361!classTraitComposition	^classTraitComposition! !!MCClassDefinition methodsFor: 'testing' stamp: 'kph 6/5/2008 02:04'!classTraitComposition: aString	aString = '{}' ifTrue: [ ^ self ].	classTraitComposition := aString! !!MCClassDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 21:55' prior: 23217483!classTraitCompositionString	^self classTraitComposition ifNil: ['{}'].! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:33' prior: 23217631!classVarNames	^ self selectVariables: #isClassVariable! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/7/2003 23:36' prior: 23222644!classVariablesString	^ self stringForVariablesOfType: #isClassVariable! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 1/15/2003 13:42' prior: 23217763!comment	^ comment! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 8/10/2003 16:40' prior: 23217859!commentStamp	^ commentStamp! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 6/7/2008 01:35'!createUnionClassWith: obsDefinition	| newClass |		newClass :=  (MCClassBuilder new)			name: name 			inEnvironment: self actualSuperclass environment 			subclassOf: self actualSuperclass			type: type 			instanceVariableNames: (self stringForVariablesOfType: #isInstanceVariable plus: obsDefinition) 			classVariableNames:   (self stringForVariablesOfType: #isClassVariable plus: obsDefinition) 			poolDictionaries:  (self stringForVariablesOfType: #isPoolImport plus: obsDefinition) 			category: category.							newClass 		ifNotNil: [ newClass class instanceVariableNames: 						(self stringForVariablesOfType: #isClassInstanceVariable plus: obsDefinition) ].			^ newClass! !!MCClassDefinition methodsFor: 'initializing' stamp: 'cwp 8/10/2003 17:39' prior: 23220807!defaultCommentStamp	^ String new	"The version below avoids stomping on stamps already in the image	^ (Smalltalk at: name ifPresent: [:c | c organization commentStamp])		ifNil: ['']	"! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 8/2/2003 02:03' prior: 23222791!definitionString	^ String streamContents: [:stream | self printDefinitionOn: stream]! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 12/5/2002 21:24' prior: 23217964!description	^ Array with: name! !!MCClassDefinition methodsFor: 'system editor' stamp: 'mtf 10/24/2008 20:40'!edLoad: editor	| theClass |	theClass := (editor at: superclassName) subclass: name		instanceVariableNames: (self stringForVariablesOfType: #isInstanceVariable)		classVariableNames: (self stringForVariablesOfType: #isClassVariable)		poolDictionaries: (self stringForVariablesOfType: #isPoolImport)		category: category.	self hasTraitComposition ifTrue: [theClass setTraitCompositionFrom:		(Compiler evaluate: self traitCompositionString for: editor doItHost logged: false)].	theClass typeOfClass: type.	theClass class instanceVariableNames: (self stringForVariablesOfType: #isClassInstanceVariable). 	theClass classComment: comment stamp: commentStamp.	^ false "we dont need an edPostload"! !!MCClassDefinition methodsFor: 'system editor' stamp: 'mtf 6/9/2008 20:14'!edUnload: editor	(editor at: name) removeFromSystem.		^ false  "we dont need an edPostload"! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 6/5/2008 23:05'!extensions	^ self propertyAt: #tmpExtensions ifAbsent: [ self propertyAt: #tmpExtensions put: OrderedCollection new  ]! !!MCClassDefinition methodsFor: 'converting' stamp: 'mtf 10/7/2008 12:14'!fromImage	^ self actualClass ifNotNil: [self actualClass asClassDefinition]! !!MCClassDefinition methodsFor: 'testing' stamp: 'cwp 8/2/2003 02:54' prior: 23226050!hasClassInstanceVariables	^ (self selectVariables: #isClassInstanceVariable) isEmpty not! !!MCClassDefinition methodsFor: 'testing' stamp: 'kph 6/5/2008 02:40' prior: 23226214!hasClassTraitComposition	^ classTraitComposition notNil! !!MCClassDefinition methodsFor: 'testing' stamp: 'al 10/9/2005 20:13' prior: 23226356!hasComment	^ comment isEmptyOrNil not! !!MCClassDefinition methodsFor: 'testing' stamp: 'kph 6/5/2008 02:40' prior: 23226469!hasTraitComposition	^ traitComposition notNil! !!MCClassDefinition methodsFor: 'comparing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23219779!hash	| hash |	hash := String stringHash: name initialHash: 0.	hash := String stringHash: superclassName initialHash: hash.	hash := String stringHash: self traitCompositionString initialHash: hash.	hash := String stringHash: self classTraitComposition asString initialHash: hash.	hash := String stringHash: (category ifNil: ['']) initialHash: hash.	hash := String stringHash: type initialHash: hash.	variables do: [		:v |		hash := String stringHash: v name initialHash: hash.	].	^ hash! !!MCClassDefinition methodsFor: 'initializing' stamp: 'kph 5/11/2007 01:34' prior: 23224621!initializeWithName: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampStringOrNil	name := nameString asSymbol.	self setSuperclassName: superclassString.	category := categoryString.	name = #CompiledMethod ifTrue: [type := #compiledMethod] ifFalse: [type := typeSymbol].	comment := commentString withSqueakLineEndings.	commentStamp := stampStringOrNil ifNil: [self defaultCommentStamp].	variables := OrderedCollection  new.	self addVariables: ivarArray ofType: MCInstanceVariableDefinition.	self addVariables: cvarArray ofType: MCClassVariableDefinition.	self addVariables: poolArray ofType: MCPoolImportDefinition.	self addVariables: civarArray ofType: MCClassInstanceVariableDefinition.! !!MCClassDefinition methodsFor: 'initializing' stamp: 'kph 6/5/2008 02:04' prior: 23227068!initializeWithName: nameStringsuperclassName: superclassStringtraitComposition: traitCompositionStringclassTraitComposition: classTraitCompositionStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampStringOrNil	name := nameString asSymbol.	self setSuperclassName: superclassString.	self traitComposition: traitCompositionString.	self classTraitComposition:  classTraitCompositionString.	category := categoryString.	name = #CompiledMethod ifTrue: [type := #compiledMethod] ifFalse: [type := typeSymbol].	comment := commentString withSqueakLineEndings.	commentStamp := stampStringOrNil ifNil: [self defaultCommentStamp].	variables := OrderedCollection  new.	self addVariables: ivarArray ofType: MCInstanceVariableDefinition.	self addVariables: cvarArray ofType: MCClassVariableDefinition.	self addVariables: poolArray ofType: MCPoolImportDefinition.	self addVariables: civarArray ofType: MCClassInstanceVariableDefinition.! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:33' prior: 23218073!instVarNames	^ self selectVariables: #isInstanceVariable! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/7/2003 23:35' prior: 23222952!instanceVariablesString	^ self stringForVariablesOfType: #isInstanceVariable! !!MCClassDefinition methodsFor: 'testing' stamp: 'ab 12/4/2002 21:52' prior: 23226601!isClassDefinition	^ true! !!MCClassDefinition methodsFor: 'testing' stamp: 'ab 5/24/2003 13:49' prior: 23226701!isCodeDefinition	^ true! !!MCClassDefinition methodsFor: 'accessing' stamp: 'kph 5/15/2007 01:11'!isPartOfPackage: aPackageInfo or: orphanage	^ aPackageInfo includesSystemCategory: self category! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 11/24/2002 22:16' prior: 23223107!kindOfSubclass	type = #normal ifTrue: [^ ' subclass: '].	type = #words ifTrue: [^ ' variableWordSubclass: '].	type = #variable ifTrue: [^ ' variableSubclass: '].	type = #bytes ifTrue: [^ ' variableByteSubclass: '].	type = #weak ifTrue: [^ ' weakSubclass: ' ].	type = #compiledMethod ifTrue: [^ ' variableByteSubclass: ' ].	self error: 'Unrecognized class type'! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:53' prior: 23218207!poolDictionaries	^ self selectVariables: #isPoolImport! !!MCClassDefinition methodsFor: 'installing' stamp: 'mtf 6/10/2008 19:27'!postinstall 			(self createUnionClassWith: nil) 			ifNotNilDo: [ :newClass |	 					self hasTraitComposition ifTrue: [					newClass setTraitComposition: (Compiler					evaluate: self traitComposition) asTraitComposition ].			self hasClassTraitComposition ifTrue: [				newClass class setTraitComposition: (Compiler				evaluate: self classTraitComposition) asTraitComposition ].						self hasComment				ifTrue: [newClass classComment: comment stamp: commentStamp]				ifFalse: [newClass classComment: ''].				].		self extensions do: [ :ext | 		ext ensuredCreateCompiledMethod.		ext installMethod  ]! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 6/7/2008 02:58'!postloadOver: obs			self extensions do: [ :ext |  (ext postloadOver: nil).  ext compiledMethod ifNil: [ self error: 'class extension has been obsoleted' ]].  	self propertyRemoveKey: #tmpExtensions.		MCClassBuilder new doneCompiling: self actualClass.! !!MCClassDefinition methodsFor: 'installing' stamp: 'mtf 8/23/2008 15:19'!preloadOver: obsDefinition	| |		super preloadOver: obsDefinition.		obsDefinition ifNotNil: [ self removeExtensionsFrom: obsDefinition ].			"we ignore syntax errors on the first time around, postinstall should sort them out"	[ (self createUnionClassWith: obsDefinition).	   ] on: SyntaxErrorNotification	do: [ :ex |   ex isResumable ifTrue: [ ex resume: false] ]			! !!MCClassDefinition methodsFor: 'annotations' stamp: 'nk 7/24/2003 16:05' prior: 23219175!printAnnotations: requests on: aStream	"Add a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	requests do: [ :aRequest |		aRequest == #requirements ifTrue: [			self requirements do: [ :req | aStream nextPutAll: req ] separatedBy: [ aStream space ]]	] separatedBy: [ aStream space ].! !!MCClassDefinition methodsFor: 'printing' stamp: 'kph 5/21/2007 16:29'!printDefinitionAndCommentOn: stream		self printDefinitionOn: stream.		stream cr; cr; nextPutAll: 'comment:'; cr.		stream nextPutAll: self comment! !!MCClassDefinition methodsFor: 'printing' stamp: 'al 3/28/2006 23:42' prior: 23223550!printDefinitionOn: stream		stream 			nextPutAll: self superclassName;			nextPutAll: self kindOfSubclass;			nextPut: $# ;			nextPutAll: self className;			cr; tab.		self hasTraitComposition ifTrue: [			stream 				nextPutAll: 'uses: ';		 		nextPutAll: self traitCompositionString;				cr; tab ].		stream			nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString;			cr; tab;			nextPutAll: 'classVariableNames: ';			store: self classVariablesString;			cr; tab;			nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString;			cr; tab;			nextPutAll: 'category: ';			store: self category asString! !!MCClassDefinition methodsFor: 'comparing' stamp: 'ab 5/24/2003 14:12' prior: 23220352!provisions	^ Array with: name! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 10/1/2007 20:04'!removeExtensionsFrom: obsDefinition 	"For any Obsoleted Class Definitions, take all of the extension methods (in this and subclasses) and make them	into MethodAdditions to be applied later"			| cat |	obsDefinition actualClass withAllSubclassesDo: [ :theClass |	(Array with: theClass with: theClass classSide ) do: [ :behavior |		behavior selectorsAndMethodsDo: [ :selector :method |			cat := behavior organization categoryOfElement: selector.						cat ifNotNil: [ 				(cat beginsWith: '*')					ifTrue: [ self extensions add: method methodReference asMethodDefinition ] 				]			]		]	].		self extensions do:[ :each |  each unload ].! !!MCClassDefinition methodsFor: 'orphanage' stamp: 'kph 5/10/2007 23:24'!removeFromOrphanage: theOrphanage	super removeFromOrphanage: theOrphanage.		theOrphanage orphans removeAllSuchThat: [ :defn | 		defn isMethodDefinition and: [ defn className = self className ] ]! !!MCClassDefinition methodsFor: 'comparing' stamp: 'avi 2/17/2004 03:13' prior: 23220460!requirements	^ (Array with: superclassName), self poolDictionaries! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 7/7/2003 23:28' prior: 23218339!selectVariables: aSelector	^ variables select: [:v | v perform: aSelector] thenCollect: [:v | v name]! !!MCClassDefinition methodsFor: 'initializing' stamp: 'kph 5/11/2007 01:32'!setSuperclassName: theName	superclassName := theName.		(theName beginsWith: 'AnObsolete') ifTrue: [ superclassName := superclassName allButFirst: 10 ].		superclassName := superclassName ifNil: ['nil'] ifNotNil: [superclassName asSymbol].! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/7/2003 23:54' prior: 23224264!sharedPoolsString	^ self stringForVariablesOfType: #isPoolImport! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 7/19/2003 18:00' prior: 23218518!sortKey	^ self className! !!MCClassDefinition methodsFor: 'accessing' stamp: 'bf 8/29/2006 11:45'!sortedVariables	"sort variables for comparison purposes"	| sorted |	sorted := variables select: [:var | var isOrderDependend].	sorted addAll: ((variables reject: [:var | var isOrderDependend])		asSortedCollection: [:a :b | a name <= b name]).	^sorted! !!MCClassDefinition methodsFor: 'printing' stamp: 'cwp 7/10/2003 01:29' prior: 23224406!source	^ self definitionString! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 5/11/2007 14:44' prior: 23222109!stringForVariablesOfType: typeSymbol  	^ self stringForVariablesOfType: typeSymbol plus: nil! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 5/23/2007 02:58'!stringForVariablesOfType: typeSymbol plus: addToMe		| vars diff orig |		vars := self selectVariables: typeSymbol.		addToMe ifNotNil: [ 		orig := addToMe selectVariables: typeSymbol.		diff := vars difference: orig. 		vars := orig , diff.		vars := vars difference: (self superclassesExistingVariablesOfType: typeSymbol).	].	^ String streamContents:		[:stream |			vars				do: [:ea | stream nextPutAll: ea]				separatedBy: [stream space]]! !!MCClassDefinition methodsFor: 'printing' stamp: 'ab 11/16/2002 17:33' prior: 23224514!summary	^ name! !!MCClassDefinition methodsFor: 'accessing' stamp: 'ab 11/13/2002 17:41' prior: 23218621!superclassName	^ superclassName! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 5/22/2007 17:27'!superclassesExistingVariablesOfType: typeSymbol  			typeSymbol = #isInstanceVariable ifTrue: [ 		^ self actualSuperclass withAllSuperclasses gather: [:cl | cl instVarNames ] 	].	 	typeSymbol = #isClassVariable ifTrue: [ 		^ self actualSuperclass withAllSuperclasses gather: [:cl | cl classVarNames ] 	].	typeSymbol = #isClassInstanceVariable ifTrue: [ 		^ self actualSuperclass withAllSuperclasses gather: [:cl | cl class instVarNames ] 	].	 	typeSymbol = #isPoolImport ifTrue: [ 		^ self actualSuperclass withAllSuperclasses gather: [:cl | cl poolDictionaryNames ] 	].  	^ Set new! !!MCClassDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:16' prior: 23218730!traitComposition	^traitComposition! !!MCClassDefinition methodsFor: 'testing' stamp: 'kph 6/5/2008 02:03'!traitComposition: aString	aString = '{}' ifTrue: [ ^ self ].	traitComposition := aString! !!MCClassDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 21:55' prior: 23218842!traitCompositionString	^self traitComposition ifNil: ['{}'].! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 11/24/2002 22:35' prior: 23218982!type	^ type! !!MCClassDefinition methodsFor: 'installing' stamp: 'kph 5/11/2007 03:10' prior: 23222364!unload	Smalltalk removeClassNamed: name.! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cwp 11/25/2002 06:51' prior: 23219073!variables	^ variables! !!MCTraitDefinition class methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 20:28' prior: 23574164!name: classNameString traitComposition:  traitCompositionString category:  categoryString comment:  commentString commentStamp:   commentStamp	^ self instanceLike:		(self new initializeWithName: classNameString 			traitComposition:  traitCompositionString			category:  categoryString			comment:  commentString  			commentStamp:   commentStamp)! !!MCTraitDefinition methodsFor: 'visiting' stamp: 'kph 10/25/2008 02:11' prior: 23573634!= aDefinition	self flag: #traits. "Ugly we harcoded the super superclass method.  We will have to refactor the definition hierarchy"		(self isRevisionOf: aDefinition) ifFalse: [ ^ false ].	self traitCompositionString = aDefinition traitCompositionString  ifFalse: [ ^ false ].	category = aDefinition category ifFalse: [ ^ false ].	comment = aDefinition comment ifFalse: [ ^ false ].		^ true! !!MCTraitDefinition methodsFor: 'visiting' stamp: 'al 10/9/2005 20:28' prior: 23573312!accept: aVisitor	^ aVisitor visitTraitDefinition: self! !!MCTraitDefinition methodsFor: 'visiting' stamp: 'kph 5/1/2008 19:18'!classTrait	^ Smalltalk at: #Trait ifAbsent: [ self error: 'Trait''s are not available in this image' ].! !!MCTraitDefinition methodsFor: 'accessing' stamp: 'al 6/5/2006 14:05' prior: 23571023!classTraitCompositionString	^self traitComposition ifNil: ['{}'].! !!MCTraitDefinition methodsFor: 'visiting' stamp: 'kph 5/1/2008 19:17'!createTrait	^self classTrait		named: name		uses: (Compiler evaluate: self traitCompositionString)		category: category		! !!MCTraitDefinition methodsFor: 'system editor' stamp: 'mtf 10/13/2008 21:26'!edLoad: aSystemEditor	(aSystemEditor at: #Trait) named: self className		uses: (Compiler evaluate: self traitCompositionString for: aSystemEditor doItHost logged: false)		category: self category.	^ false.! !!MCTraitDefinition methodsFor: 'testing' stamp: 'al 10/9/2005 20:28' prior: 23573068!hasClassInstanceVariables	^ false! !!MCTraitDefinition methodsFor: 'testing' stamp: 'al 6/5/2006 14:13' prior: 23573178!hasTraitComposition	^self traitCompositionString ~= '{}'! !!MCTraitDefinition methodsFor: 'comparing' stamp: 'al 6/5/2006 14:14' prior: 23571278!hash	| hash |	hash := String stringHash: name initialHash: 0.	hash := String stringHash: self traitCompositionString initialHash: hash.	hash := String stringHash: (category ifNil: ['']) initialHash: hash.	^ hash! !!MCTraitDefinition methodsFor: 'initializing' stamp: 'kph 6/5/2008 02:02' prior: 23572060!initializeWithName: classNameString 	traitComposition:  traitCompositionString	category:  categoryString	comment:  commentString  	commentStamp:   commentStampString							name := classNameString asSymbol.		self traitComposition: traitCompositionString.	     category := categoryString.		comment := commentString withSqueakLineEndings.		commentStamp :=  commentStampString ifNil: [self defaultCommentStamp]! !!MCTraitDefinition methodsFor: 'installing' stamp: 'kph 8/1/2007 09:57'!install	! !!MCTraitDefinition methodsFor: 'installing' stamp: 'kph 5/13/2007 02:48'!obsoletion	^ nil! !!MCTraitDefinition methodsFor: '' stamp: 'kph 8/1/2007 09:55'!postinstall	 ! !!MCTraitDefinition methodsFor: '' stamp: 'kph 6/5/2008 22:58'!postloadOver: obs! !!MCTraitDefinition methodsFor: '' stamp: 'kph 8/1/2007 09:57'!preloadOver: obsDefinition 	self createTrait ifNotNilDo: [:trait |		self hasComment ifTrue: [trait classComment: comment stamp: commentStamp]]! !!MCTraitDefinition methodsFor: 'printing' stamp: 'al 6/5/2006 14:15' prior: 23572751!printDefinitionOn: stream	stream nextPutAll: 'Trait named: #', self className;		 cr;		 tab;		 nextPutAll: 'uses: ';		 nextPutAll: self traitCompositionString;		 cr;		 tab;		 nextPutAll: 'category: ';		 store: self category asString! !!MCTraitDefinition methodsFor: 'comparing' stamp: 'al 6/5/2006 14:13' prior: 23571571!requirements	"Assuming that traits in a composition can be identified by	testing for the first character beeing an uppercase character	(and thus not a special character such as {, # etc.)"	| tokens traitNames |	self hasTraitComposition ifFalse: [ ^Array new ].	tokens := Scanner new scanTokens: self traitComposition.	traitNames := tokens select: [:each | each first isUppercase].	^traitNames asArray! !!MCTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:29' prior: 23571166!traitComposition	^traitComposition! !!MCClassTraitDefinition class methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 20:22' prior: 23240292!baseTraitName: aString classTraitComposition: classTraitCompositionString	^self instanceLike: (		self new			initializeWithBaseTraitName: aString			classTraitComposition: classTraitCompositionString).! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 21:59' prior: 23239386!= aDefinition	^ (super = aDefinition)		and: [baseTrait = aDefinition baseTrait]		and: [self classTraitCompositionString = aDefinition classTraitCompositionString]! !!MCClassTraitDefinition methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 20:23' prior: 23239646!accept: aVisitor	^ aVisitor visitClassTraitDefinition: self.! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:23' prior: 23237845!baseTrait	^baseTrait! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 12/15/2005 11:31' prior: 23237950!className	^self baseTrait! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:23' prior: 23238058!classTraitComposition	^classTraitComposition! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/10/2005 10:12' prior: 23238188!classTraitCompositionString	^self classTraitComposition ifNil: ['{}'].! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 21:59' prior: 23238343!definitionString	^self baseTrait , ' classTrait	uses: ' , self classTraitCompositionString.! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:24' prior: 23238519!description	^Array		with: baseTrait		with: classTraitComposition! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 6/5/2006 14:04' prior: 23238667!hash	| hash |	hash := String stringHash: baseTrait initialHash: 0.	hash := String stringHash: self classTraitCompositionString initialHash: hash.	^hash! !!MCClassTraitDefinition methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23239946!initializeWithBaseTraitName: aTraitName classTraitComposition: aString	baseTrait := aTraitName.	classTraitComposition := aString.! !!MCClassTraitDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 19:47'!preloadOver: obs	super preloadOver: obs.		Compiler evaluate: self definitionString! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:24' prior: 23238905!requirements	^Array with: baseTrait! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:25' prior: 23239023!sortKey	^ self baseTrait name , '.classTrait'! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:25' prior: 23239151!source	^self definitionString! !!MCClassTraitDefinition methodsFor: 'accessing' stamp: 'al 10/9/2005 20:25' prior: 23239263!summary	^self baseTrait , ' classTrait'! !!MCDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 03:32'!cleanUp^ self clearInstances! !!MCDefinition class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23287056!clearInstances	WeakArray removeWeakDependent: Instances.	Instances := nil! !!MCDefinition class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23287231!instanceLike: aDefinition	Instances ifNil: [Instances := WeakSet new].	^ (Instances like: aDefinition) ifNil: [Instances add: aDefinition]! !!MCDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 5/19/2007 01:45'!storeAsClassForMC1^ self! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 17:59' prior: 23285490!<= other	^ self sortKey <= other sortKey! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:24' prior: 23285603!= aDefinition	^ self isRevisionOf: aDefinition! !!MCDefinition methodsFor: 'accessing' stamp: 'gvc 10/26/2006 12:17'!actualClass	"Since the targetClass call on a patch operation will fail	otherwise."		^nil! !!MCDefinition methodsFor: 'annotations' stamp: 'nk 7/24/2003 12:27' prior: 23283761!annotations	^self annotations: Preferences defaultAnnotationRequests! !!MCDefinition methodsFor: 'annotations' stamp: 'nk 7/24/2003 12:26' prior: 23283904!annotations: requests	"Answer a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	^String streamContents: [ :s | self printAnnotations: requests on: s ].! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 2/7/2009 21:12'!authorInitials		^ nil! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:30'!because	^ self propertyAt: #because ifAbsent: [ nil ]! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:31'!because: value		value ifNil: [ ^ self propertyRemoveKey: #because  ].	^ self propertyAt: #because put: value! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:14' prior: 23284796!description	self subclassResponsibility! !!MCDefinition methodsFor: 'system editor' stamp: 'kph 5/25/2007 07:13'!edLoad: editor	^ false! !!MCDefinition methodsFor: 'system editor' stamp: 'kph 12/12/2008 19:32'!edLoadFor: loader into: anEditor	^ self edLoad: anEditor! !!MCDefinition methodsFor: 'system editor' stamp: 'mtf 12/11/2008 21:16'!edPostload! !!MCDefinition methodsFor: 'system editor' stamp: 'kph 12/12/2008 19:31'!edPostloadFor: loader	^ self edPostload! !!MCDefinition methodsFor: 'system editor' stamp: 'mtf 12/11/2008 21:17'!edPostunload! !!MCDefinition methodsFor: 'system editor' stamp: 'kph 5/25/2007 09:09'!edUnload: editor	^ false! !!MCDefinition methodsFor: 'converting' stamp: 'mtf 10/7/2008 12:12'!fromImage"Answer a copy of myself, but at the version that exists in the image. Answers nil if no such version exists"	^ nil! !!MCDefinition methodsFor: 'comparing' stamp: 'nk 10/21/2003 23:18' prior: 23284909!fullTimeStamp	^TimeStamp current! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:14' prior: 23285014!hash	^ self description hash! !!MCDefinition methodsFor: 'annotations' stamp: 'kph 6/5/2008 01:39'!instVarAt: anInteger put: anObject 	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables. 	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	| |		<primitive: 74>	"Access beyond fixed fields"	"When loading in any definition classes we get called if #instVarAt:put: fails which will occur if in a future version if extra instVars have been added to theses classes, ok, so we dont know what to do with this extra data, so we can slap it into our properties dictionary just in case!!"	 'extra', anInteger asString in: [ :newName |			self class addInstVarName: newName. 	 		self instVarNamed: newName put: anObject. 	 ].		 ! !!MCDefinition methodsFor: 'installing' stamp: 'kph 5/11/2007 11:17'!install	! !!MCDefinition methodsFor: 'testing' stamp: 'ab 12/4/2002 21:51' prior: 23286449!isClassDefinition	^false! !!MCDefinition methodsFor: 'testing' stamp: 'bf 11/12/2004 14:46' prior: 23286545!isClassDefinitionExtension	"Answer true if this definition extends the regular class definition"	^false! !!MCDefinition methodsFor: 'testing' stamp: 'kph 12/6/2008 23:10'!isFileDefinition	^ false! !!MCDefinition methodsFor: 'testing' stamp: 'ab 12/4/2002 21:51' prior: 23286720!isMethodDefinition	^false! !!MCDefinition methodsFor: 'testing' stamp: 'cwp 7/11/2003 01:32' prior: 23286817!isOrganizationDefinition	^false! !!MCDefinition methodsFor: 'comparing' stamp: 'kph 5/15/2007 01:12'!isPartOfPackage: aPackageInfo or: orphanage	self subclassResponsibility	! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 12/5/2002 21:24' prior: 23285115!isRevisionOf: aDefinition	^ aDefinition description = self description! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:25' prior: 23285258!isSameRevisionAs: aDefinition	^ self = aDefinition! !!MCDefinition methodsFor: 'testing' stamp: 'kph 5/11/2007 13:23'!isUnlinkedClassDefinition	 	^false! !!MCDefinition methodsFor: 'installing' stamp: 'kph 2/7/2009 18:25' prior: 23285724!load	self preloadOver: nil.	self install.	self postinstall.	self postloadOver: nil.! !!MCDefinition methodsFor: 'installing' stamp: 'kph 5/13/2007 02:53'!manuallyObsoleted 	 	^ nil! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 5/10/2007 21:06'!orphanage	^ MCOrphanage current! !!MCDefinition methodsFor: 'orphanage' stamp: 'kph 5/15/2007 13:05'!orphanedBecause: explanation	"During installation anticipated errors result in the definiton becoming orphaned"		self because: explanation.		^ MCOrphanedNotification orphan: self signal: explanation! !!MCDefinition methodsFor: 'installing' stamp: 'kph 5/11/2007 12:43'!postinstall	! !!MCDefinition methodsFor: 'installing' stamp: 'kph 2/15/2009 23:05' prior: 23285993!postloadOver: aDefinition	! !!MCDefinition methodsFor: 'installing' stamp: 'kph 5/15/2007 19:22'!preloadOver: aDefinition	self because: nil. "clear out any previous" 	! !!MCDefinition methodsFor: 'annotations' stamp: 'nk 11/10/2003 21:46' prior: 23284359!printAnnotations: requests on: aStream	"Add a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	aStream nextPutAll: 'not yet implemented'! !!MCDefinition methodsFor: 'printing' stamp: 'kph 5/13/2007 05:43' prior: 23286185!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(', self summary, ') ' ! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:26'!propertiesInitialize	^ self instVarNamed: 'properties' put: IdentityDictionary new! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:28'!propertiesPrivate	^ self instVarNamed: 'properties'! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:29'!propertyAt: key ifAbsent: aBlock	self propertiesPrivate ifNil: [ ^ aBlock value ].	^ self propertiesPrivate at: key ifAbsent: aBlock! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:29'!propertyAt: key put: value	self propertiesPrivate ifNil: [ self propertiesInitialize ].	^ self propertiesPrivate at: key put: value.! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 22:03'!propertyRemoveKey: key	self propertiesPrivate ifNotNilDo: [ :p | p removeKey: key ifAbsent: nil. 		p isEmpty ifTrue: [ self instVarNamed: 'properties' put: nil ].	].! !!MCDefinition methodsFor: 'accessing' stamp: 'ab 5/24/2003 14:12' prior: 23283578!provisions	^ #()! !!MCDefinition methodsFor: 'testing' stamp: 'kph 6/5/2008 23:02'!readDataFrom: aDataStream size: varsOnDisk	| read theClass |		read := super readDataFrom: aDataStream size: varsOnDisk.			theClass := read propertyAt: #class ifAbsent: [ ^ read ].		theClass := Smalltalk at: theClass ifAbsent: [ ^ read ]. 		^ theClass basicNew copyFrom: read! !!MCDefinition methodsFor: 'orphanage' stamp: 'kph 5/10/2007 23:05'!removeFromOrphanage: theOrphanage	theOrphanage orphans remove: self ifAbsent: []! !!MCDefinition methodsFor: 'accessing' stamp: 'ab 5/24/2003 14:12' prior: 23283667!requirements	^ #()! !!MCDefinition methodsFor: 'accessing' stamp: 'kph 6/5/2008 02:26'!setProperties	^ self instVarNamed: 'properties'! !!MCDefinition methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:04' prior: 23285381!sortKey	self subclassResponsibility ! !!MCDefinition methodsFor: 'annotations' stamp: 'kph 6/19/2008 17:31'!storeDataOn: aDataStream	"we only ignore trailing instVars that are nil" 	| lastNotNil |	self class ~= self class storeAsClassForMC1 ifTrue: [ self propertyAt: #class put: self class name ].	self propertyRemoveKey: #because.	lastNotNil := (self storeMaxInstVars to: 1 by: -1) detect: [ :n |  (self instVarAt: n) notNil ].	 	aDataStream		beginInstance: self class storeAsClassForMC1		size: lastNotNil.	1 to: lastNotNil do:		[:i | aDataStream nextPut: (self instVarAt: i)].! !!MCDefinition methodsFor: '' stamp: 'kph 6/5/2008 02:18'!storeMaxInstVars ^ self class instSize! !!MCDefinition methodsFor: 'printing' stamp: 'ab 7/19/2003 18:23' prior: 23286341!summary	self subclassResponsibility ! !!MCDefinition methodsFor: 'installing' stamp: 'ab 11/14/2002 00:08' prior: 23286107!unload! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/15/2007 09:24' prior: 23388527!initialize	self cleanUp.	Smalltalk addToShutDownList: self! !!MCMethodAfterRemovalActionDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 22:09'!isModelFor: selectorString	^ selectorString beginsWith: 'mcAfterRemoval'  ! !!MCMethodAfterRemovalActionDefinition methodsFor: 'as yet unclassified' stamp: 'kph 11/18/2007 03:55'!edPostunload 	"	this hackish method, takes our method source and evaluates it	"	| return code |		return := super edPostunload.		code :=  (source copyAfter: $  ) 	 	self class compilerClass evaluate:  code.			^ return! !!MCMethodAfterRemovalActionDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/26/2007 07:11'!edUnload 	super edUnload.		^ true! !!MCMethodAfterRemovalActionDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/26/2007 07:13'!sortKey	^ '!!', super sortKey "force to the beginning so it gets run last when unloading"! !!MCMethodAfterRemovalActionDefinition methodsFor: 'as yet unclassified' stamp: 'kph 11/18/2007 03:45'!unload 	"	this hackish method, takes our method source and evaluates it	"	| return code |		return := super unload.		code :=  (source copyAfter: $  ) 	 	self class compilerClass evaluate:  code.			^ return! !!MCMethodBeforeCommitLoadDefinition commentStamp: 'kph 5/30/2007 16:20' prior: 0!MCMethodSpecialActionDefinition !!MCMethodBeforeCommitLoadDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 22:10'!isModelFor: selectorString	^ selectorString beginsWith: 'mcOnInstall'  ! !!MCMethodBeforeCommitLoadDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2007 16:23'!edLoad: theEditor	"this hackish method, takes our method source, munges it into an anonymous block.	to which we evaluate feeding the classEditor as a parameter, enabling the package	the ability to add changes anywhere, before this method or even its class has been installed!!	"	| return code ourClassEditor |		return := super edLoad: theEditor.		ourClassEditor := theEditor at: className.		code := '[ :', (source copyAfter: $: ), ' ]'.	code at: (code indexOf: (Character cr)) put: $|.		(self class compilerClass evaluate:  code) value: ourClassEditor.			^ return! !!MCMethodBeforeCommitLoadDefinition methodsFor: 'as yet unclassified' stamp: 'kph 11/18/2007 03:42'!preloadOver: thePrevious	"this hackish method, takes our method source, munges it into an anonymous block.	to which we evaluate feeding the Class as a parameter, enabling the package	the ability to add changes anywhere,  	"	| return code ourClassEditor |		return := super preLoadOver: thePrevious.		ourClassEditor := Smalltalk at: className.		code := '[ :', (source copyAfter: $: ), ' ]'.	code at: (code indexOf: (Character cr)) put: $|.		(self class compilerClass evaluate:  code) value: ourClassEditor.			^ return! !!MCMethodBeforeCommitLoadDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/26/2007 05:20'!sortKey	^ 'zzz', super sortKey "force to the end so it gets loaded last"! !!MCMethodBeforeCommitUnloadDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 22:10'!isModelFor: selectorString	^ selectorString beginsWith: 'mcOnUninstall'  ! !!MCMethodBeforeCommitUnloadDefinition methodsFor: 'as yet unclassified' stamp: 'kph 11/18/2007 03:52'!edUnload: theEditor	"this hackish method, takes our method source, munges it into an anonymous block.	to which we evaluate feeding the classEditor as a parameter, enabling the package	the ability to add changes anywhere, before this method or even its class has been installed!!	"	| return code ourClassEditor |		return := super edUnload: theEditor.		ourClassEditor := theEditor at: className.		code := '[ :', (source copyAfter: $: ), ' ]'.	code at: (code indexOf: (Character cr)) put: $|.		(self class compilerClass evaluate:  code) value: ourClassEditor.			^ return! !!MCMethodBeforeCommitUnloadDefinition methodsFor: 'as yet unclassified' stamp: 'kph 11/18/2007 03:55'!sortKey	^ 'aaa', super sortKey "force to the beginning so it gets unloaded last"! !!MCMethodBeforeCommitUnloadDefinition methodsFor: 'as yet unclassified' stamp: 'kph 11/18/2007 03:52'!unload	"this hackish method, takes our method source, munges it into an anonymous block.	to which we evaluate feeding the Class as a parameter, enabling the package	the ability to add changes anywhere,  	"	| return code ourClassEditor |		return := super unload.		ourClassEditor := Smalltalk at: className.		code := '[ :', (source copyAfter: $: ), ' ]'.	code at: (code indexOf: (Character cr)) put: $|.		(self class compilerClass evaluate:  code) value: ourClassEditor.			^ return! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 8/2/2007 15:02' prior: 23386605!cachedDefinitions	Definitions ifNil: [Definitions := WeakIdentityKeyDictionary new.   "WeakArray addWeakDependent: Definitions" "instead we call tidyCache on (un)loading a package" ].	^ Definitions! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 18:35'!classForSelector: selectorString meta: isMeta	isMeta ifFalse: [ ^ self ].		^ self subclasses detect: [ :ea | ea isModelFor: selectorString ] ifNone: [ self ]	 ! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 17:05' prior: 23386841!className: classStringclassIsMeta: metaBooleanselector: selectorStringcategory: catStringtimeStamp: timeStringsource: sourceString	^ self instanceLike:		((self classForSelector: selectorString meta: metaBoolean) new					initializeWithClassName: classString					classIsMeta: metaBoolean					selector: selectorString					category: catString					timeStamp: timeString					source: sourceString)! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'ab 4/1/2003 01:40' prior: 23387279!className: classStringselector: selectorStringcategory: catStringtimeStamp: timeStringsource: sourceString	^ self	className: classString			classIsMeta: false			selector: selectorString			category: catString			timeStamp: timeString			source: sourceString! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 8/2/2007 15:19' prior: 23387636!forMethodReference: aMethodReference	| definition | 	definition := self cachedDefinitions at: aMethodReference compiledMethod ifAbsent: [].	(definition isNil		or: [definition selector ~= aMethodReference methodSymbol]		or: [definition className ~= aMethodReference classSymbol]		or: [definition classIsMeta ~= aMethodReference classIsMeta]		or: [definition category ~= aMethodReference category])			ifTrue: [definition := self 						className: aMethodReference classSymbol						classIsMeta: aMethodReference classIsMeta						selector: aMethodReference methodSymbol						category: aMethodReference category						timeStamp: aMethodReference timeStamp						source: aMethodReference source.					self cachedDefinitions at: aMethodReference compiledMethod put: definition].	^ definition	! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 6/2/2008 17:26'!freeSomeSpace	Definitions := nil! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 7/4/2007 16:38' prior: 23388678!shutDown		Definitions := nil.! !!MCMethodDefinition class methodsFor: 'file format' stamp: 'kph 5/19/2007 04:46'!storeAsClassForMC1^ MCMethodDefinition! !!MCMethodDefinition class methodsFor: 'as yet unclassified' stamp: 'mtf 5/8/2008 10:01'!tidyCache	Smalltalk garbageCollect.	self cachedDefinitions finalizeValues.! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'kph 10/25/2008 02:10' prior: 23381151!= aDefinition	super = aDefinition ifFalse: [ ^ false ].	aDefinition source = self source ifFalse: [ ^ false ].	aDefinition category = self category ifFalse: [ ^ false ].	aDefinition timeStamp = self timeStamp ifFalse: [ ^ false ].		^ true! !!MCMethodDefinition methodsFor: 'visiting' stamp: 'ab 7/18/2003 21:47' prior: 23386330!accept: aVisitor	^ aVisitor visitMethodDefinition: self! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'mtf 6/12/2008 23:05' prior: 23378612!actualClass	^ self actualClassIn: Smalltalk! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'mtf 6/12/2008 23:04'!actualClassIn: anEnvironment	^ theClass := anEnvironment at: className 		ifPresent: [:class | classIsMeta ifTrue: [class classSide] ifFalse: [class]]! !!MCMethodDefinition methodsFor: 'obsolete' stamp: 'kph 8/1/2007 01:02'!addMethodAdditionTo: a	"dummy to enable loading into 3.10"! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'kph 2/7/2009 21:12'!authorInitials	^ self timeStamp upTo: $ .! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 11/13/2002 01:59' prior: 23378807!category	^ category! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'cwp 11/25/2002 07:26' prior: 23378907!classIsMeta	^ classIsMeta! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 11/15/2002 01:12' prior: 23379012!className	^className! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'mtf 10/8/2008 01:17'!compileMethod	methodAndNode := self actualClass 							compile: self source 							classified: self category 							notifying: requestor							trailer: self actualClass defaultMethodTrailer ifFail: [^nil].	compiledSelector := methodAndNode selector.	compiledMethod := methodAndNode method.	  ! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'kph 8/2/2007 11:19'!compiledMethod	^ compiledMethod! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'kph 10/24/2007 14:30'!compiledMethod: aCM 	compiledSelector := aCM selector.	compiledMethod := aCM.	  ! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'kph 8/2/2007 11:19'!compiledSelector	^ compiledSelector! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'kph 10/24/2007 14:33'!createCompiledMethod	"compiledSelector and selector should not be different, but just in case we use a searate instVar" 	self actualClass 		ifNil: [ ^self orphanedBecause: ('class {1} not present' format: {className}) ].			defnToInstall := self.		((self isOverrideCategory: priorMethodCategory) and: [ (self isOverrideCategory: category) not ])		ifTrue: [ "if we have been overriden, compile and add our source, then set defnToInstall to be the original"		  			defnToInstall := priorMethodOrNil.			self compileMethod ].		defnToInstall actualClass; compileMethod.						 	 ! !!MCMethodDefinition methodsFor: 'printing' stamp: 'kph 5/23/2007 00:46' prior: 23384903!description	^ Array			with: className		with: selector		with: classIsMeta! !!MCMethodDefinition methodsFor: 'system editor' stamp: 'mtf 6/12/2008 23:06'!edLoad: editor	"priorMethodOrNil := self actualClass compiledMethodAt: selector ifAbsent: [nil]."	methodAndNode := (self actualClassIn: editor)							compile: self source 							classified: self category							withStamp: timeStamp							notifying: requestor.							 	^ false "dont ask for edPostLoad, switch our notifications off not sure if needed with SystemEditor-#commit" ! !!MCMethodDefinition methodsFor: 'system editor' stamp: 'kph 10/24/2007 14:34'!edPostload		compiledMethod := self actualClass compiledMethodAt: selector ifAbsent: [ ^nil]. 	SystemChangeNotifier uniqueInstance 		doSilently: [self actualClass organization classify: selector under: category].		priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: compiledMethod selector: selector inProtocol: category class: self actualClass requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil compiledMethod to: compiledMethod selector: selector inClass: self actualClass requestor: requestor].	"The following code doesn't seem to do anything."	self actualClass instanceSide noteCompilationOf: selector meta: self actualClass isClassSide.! !!MCMethodDefinition methodsFor: 'system editor' stamp: 'mtf 6/12/2008 23:18'!edUnload: editor	(self actualClassIn: editor) removeSelector: selector.					 	^ false   "we dont need an edPostUnload"! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'mtf 6/10/2008 20:21'!ensuredCreateCompiledMethod	"Create the compiled method from my source, or from user-provided source in the event of a syntax error"	[ self createCompiledMethod ] on: SyntaxErrorNotification do: [ :ex |		"Let the user install the fixed code into the system"		ex defaultAction.		"Now fetch and use that code instead"		source := theClass sourceCodeAt: self selector ifAbsent: [^ nil].		self createCompiledMethod]! !!MCMethodDefinition methodsFor: 'converting' stamp: 'mtf 10/7/2008 12:38'!fromImage	| class |	class := self actualClass ifNil: [^ nil].	(class includesLocalSelector: selector) ifFalse: [^ nil].	^(MethodReference new setStandardClass: class methodSymbol: selector) asMethodDefinition! !!MCMethodDefinition methodsFor: 'printing' stamp: 'kph 5/24/2007 01:10' prior: 23385056!fullClassName	"Using #class selector for classes for backwards compatibility"	"The old implementation assumed that the definition is installed and refers to an existing class. This is not always the case, so we have to rely upon our self knowledge.Note if we are a trait's method we probably need more state!!"		^ self classIsMeta		ifFalse: [self className]		ifTrue: [ self isTraitMethod 					ifFalse: [ self className, ' class']					ifTrue: [ self className, ' classSide' ] ].! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'nk 10/21/2003 23:08' prior: 23379112!fullTimeStamp	^TimeStamp fromMethodTimeStamp: timeStamp! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23380518!hash	| hash |	hash := String stringHash: classIsMeta asString initialHash: 0.	hash := String stringHash: source initialHash: hash.	hash := String stringHash: category initialHash: hash.	hash := String stringHash: className initialHash: hash.	^ hash! !!MCMethodDefinition methodsFor: 'serializing' stamp: 'mtf 6/10/2008 21:48' prior: 23385556!initializeWithClassName: classStringclassIsMeta: metaBooleanselector: selectorStringcategory: catStringtimeStamp: timeStringsource: sourceString	className := classString asSymbol.	selector := selectorString asSymbol.	category :=  (catString ifNil: [ '' ]) asSymbol.	timeStamp := timeString.	classIsMeta := metaBoolean.	source := sourceString withSqueakLineEndings.	requestor := nil. "Always handle syntax errors thru SyntaxErrorNotification, never directly"! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'kph 10/24/2007 14:20'!install	compiledMethod ifNil: [ 	self protectedCreateCompiledMethod ].		compiledMethod ifNotNil: [ self installMethod ].! !!MCMethodDefinition methodsFor: 'installing' stamp: 'kph 8/6/2007 15:08'!installCompiledMethod	compiledMethod ifNil: [ ^ false ].		self actualClass addSelectorSilently: compiledSelector withMethod: compiledMethod.	 	^ true! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'kph 8/6/2007 15:10'!installMethod 	self writeSourceToLog.	self installCompiledMethod.	defnToInstall ifNil: [ ^ nil ].	self ~= defnToInstall ifTrue: [ 			defnToInstall writeSourceToLog.			defnToInstall installCompiledMethod ]! !!MCMethodDefinition methodsFor: 'testing' stamp: 'ab 5/24/2003 13:49' prior: 23385992!isCodeDefinition	^ true! !!MCMethodDefinition methodsFor: 'installing' stamp: 'avi 9/17/2003 22:27' prior: 23381405!isExtensionMethod	^ category beginsWith: '*'! !!MCMethodDefinition methodsFor: 'testing' stamp: 'kph 5/15/2007 17:19' prior: 23386091!isInitializer	^ false! !!MCMethodDefinition methodsFor: 'testing' stamp: 'ab 12/4/2002 21:52' prior: 23386227!isMethodDefinition	^true! !!MCMethodDefinition methodsFor: 'testing' stamp: 'kph 8/2/2007 13:28'!isOverrideCategory: cat 	^ cat notNil and: [ (cat beginsWith: '*') and: [cat endsWith: '-override'] ]! !!MCMethodDefinition methodsFor: 'installing' stamp: 'kph 8/2/2007 13:29' prior: 23381531!isOverrideMethod	"this oughta check the package"	^ self isOverrideCategory: category ! !!MCMethodDefinition methodsFor: 'testing' stamp: 'kph 10/25/2008 01:34'!isPartOfPackage: aPackageInfo or: orphanage	| myOrphanedClassDefiniton |	 	(aPackageInfo isYourClassExtension: self category) ifTrue: [ ^ true ].		myOrphanedClassDefiniton := orphanage orphans				detect: [ :c | c isClassDefinition and: [ c className = self className ] ] ifNone: [ ^ false ].		^ aPackageInfo includesSystemCategory: myOrphanedClassDefiniton category		! !!MCMethodDefinition methodsFor: 'printing' stamp: 'kph 5/24/2007 01:10'!isTraitMethod	"TODO support traits properly"	^ false			 ! !!MCMethodDefinition methodsFor: 'testing' stamp: 'kph 1/18/2008 10:30'!isUnloader	^ false! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'kph 5/11/2007 16:49'!logSource	 ^ true! !!MCMethodDefinition methodsFor: 'installing' stamp: 'kph 10/24/2007 14:40'!notifyObservers	SystemChangeNotifier uniqueInstance 		doSilently: [self actualClass organization classify: selector under: category].	priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: compiledMethod selector: selector inProtocol: category class: self actualClass requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil compiledMethod to: compiledMethod selector: selector inClass: self actualClass requestor: requestor].	"The following code doesn't seem to do anything."	self actualClass instanceSide noteCompilationOf: compiledSelector meta: self actualClass isClassSide.! !!MCMethodDefinition methodsFor: 'serializing' stamp: 'kph 8/2/2007 14:55'!objectForDataStream: refStrm    "nil out any compiled methods"	methodAndNode := requestor := compiledMethod := priorMethodCategory := priorMethodOrNil := compiledSelector := isInstalled := theClass := defnToInstall :=  nil.	    ^ self! !!MCMethodDefinition methodsFor: 'installing' stamp: 'mtf 6/10/2008 19:25'!postloadOver: obs	compiledMethod ifNil: [ 		  self ensuredCreateCompiledMethod.	  self installMethod	].	defnToInstall ifNotNil: [ defnToInstall notifyObservers ].! !!MCMethodDefinition methodsFor: 'installing' stamp: 'kph 10/24/2007 14:32'!preloadOver: obs	| | 	"we trap errors the first time and retry later"	super preloadOver: obs.				(obs notNil & self actualClass notNil) ifTrue: [ 			theClass := self actualClass.							priorMethodOrNil :=  self priorMethod.						priorMethodCategory := theClass organization categoryOfElement: selector  .			theClass removeSelector: obs selector 				 ].					self protectedCreateCompiledMethod.	 ! !!MCMethodDefinition methodsFor: 'annotations' stamp: 'nk 7/24/2003 16:06' prior: 23379757!printAnnotations: requests on: aStream	"Add a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	requests do: [ :aRequest |		aRequest == #timeStamp ifTrue: [ aStream nextPutAll: self timeStamp ].		aRequest == #messageCategory ifTrue: [ aStream nextPutAll: self category ].		aRequest == #requirements ifTrue: [			self requirements do: [ :req |				aStream nextPutAll: req ] separatedBy: [ aStream space ]].	] separatedBy: [ aStream space ].! !!MCMethodDefinition methodsFor: 'installing' stamp: 'kph 10/24/2007 14:28'!priorMethod	| comp |		comp :=	theClass compiledMethodAt: selector ifAbsent: [ ^nil ].			^ (comp methodReference asMethodDefinition)		compiledMethod: comp;		yourself! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'kph 5/23/2007 00:55'!protectedCreateCompiledMethod	[ self createCompiledMethod ] on: Error, SyntaxErrorNotification do: [ :ex | ]. ! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'kph 4/14/2008 14:29'!readDataFrom: aDataStream size: varsOnDisk	| read leClass |		read := super readDataFrom: aDataStream size: varsOnDisk.		read classIsMeta ifFalse: [ ^ read ].		leClass := self class classForSelector: read selector meta: true.	^ leClass new copyFrom: read	 ! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'kph 5/16/2007 05:13'!requestor	^ requestor! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'ab 5/24/2003 14:11' prior: 23380850!requirements	^ Array with: className! !!MCMethodDefinition methodsFor: 'installing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23381938!scanForPreviousVersion	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp method file methodCategory |	method := self actualClass compiledMethodAt: selector ifAbsent: [^ nil].	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		methodCategory = category ifFalse:			[methodCategory = (Smalltalk 									at: #Categorizer 									ifAbsent: [Smalltalk at: #ClassOrganizer]) 										default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: className category: methodCategory meta: classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 11/15/2002 01:11' prior: 23379462!selector	^selector! !!MCMethodDefinition methodsFor: 'comparing' stamp: 'kph 5/10/2007 04:55' prior: 23380965!sortKey	^ self className, '.', (self classIsMeta ifTrue: ['meta'] ifFalse: ['nonmeta']), '.', self selector, '.' , self category! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 11/13/2002 01:59' prior: 23379560!source	^ source! !!MCMethodDefinition methodsFor: 'visiting' stamp: 'kph 6/19/2008 17:33'!storeDataOn: aDataStream	"we only ignore trailing instVars that are nil" 	| lastNotNil |	self propertyRemoveKey: #because.	lastNotNil := (self storeMaxInstVars to: 1 by: -1) detect: [ :n |  (self instVarAt: n) notNil ].	 	aDataStream		beginInstance: self class storeAsClassForMC1		size: lastNotNil.	1 to: lastNotNil do:		[:i | aDataStream nextPut: (self instVarAt: i)].! !!MCMethodDefinition methodsFor: 'serializing' stamp: 'kph 6/5/2008 02:43'!storeMaxInstVars^ 9! !!MCMethodDefinition methodsFor: 'printing' stamp: 'kph 8/2/2007 12:08' prior: 23385416!summary	^ self fullClassName , '>>' , selector, '{',category,'}' ! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'ab 1/15/2003 13:42' prior: 23379654!timeStamp	^ timeStamp! !!MCMethodDefinition methodsFor: 'installing' stamp: 'kph 5/10/2007 21:15' prior: 23384580!unload	| previousVersion | 		self isOverrideMethod ifTrue: [previousVersion := self scanForPreviousVersion].	previousVersion		ifNil: [self actualClass ifNotNilDo: [:class | class removeSelector: selector]]		ifNotNil: [previousVersion fileIn] ! !!MCMethodDefinition methodsFor: 'compiling' stamp: 'kph 8/6/2007 15:10'!writeSourceToLog	self logSource ifTrue: [		self actualClass logMethodSource: self source forMethodWithNode: methodAndNode 			inCategory: self category withStamp: timeStamp notifying: self requestor.	].! !!MCMethodExternalFieldDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 22:10'!isModelFor: selectorString	^ selectorString = 'fields'! !!MCMethodExternalFieldDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/23/2007 00:58'!postinstall 	super postinstall.		(Smalltalk at: #ExternalStructure ifPresent: [:externalStructure |			self actualClass theNonMetaClass inheritsFrom: externalStructure]) == true				 ifTrue: [ self actualClass theNonMetaClass compileFields ]				! !!MCMethodInitializerDefinition commentStamp: 'kph 1/16/2008 09:39' prior: 0!MCMethodInitializerDefinition 	is loaded as a normal method.	at #postloadOver:, it runs itself.	!!MCMethodInitializerDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 22:10'!isModelFor: selectorString	^ selectorString = 'initialize' or: [ selectorString beginsWith: 'mcAfterInstall' ] ! !!MCMethodInitializerDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/26/2007 04:51'!edLoad: editor	super edLoad: editor.		^ true		 ! !!MCMethodInitializerDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/26/2007 04:57'!edPostload		super edPostload.		self actualClass isTrait ifTrue: [ ^ self ].	 	self actualClass theNonMetaClass perform: selector.! !!MCMethodInitializerDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 17:19'!isInitializer		^ true! !!MCMethodInitializerDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 18:29'!postloadOver: old	super postloadOver: old.		self actualClass isTrait ifTrue: [ ^ self ].	 	self actualClass theNonMetaClass perform: selector.! !!MCMethodInitializerDefinition methodsFor: '' stamp: 'kph 8/2/2007 01:10'!sortKey	^ '!!!!!!initialize'   ! !!MCMethodUnloaderDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/5/2008 22:10'!isModelFor: selectorString	^ selectorString = 'unload' ! !!MCMethodUnloaderDefinition methodsFor: 'as yet unclassified' stamp: 'kph 1/18/2008 10:31'!isUnloader		^ true! !!MCMethodUnloaderDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 02:53'!sortKey	^ '¼¼¼unload'   ! !!MCMethodUnloaderDefinition methodsFor: 'as yet unclassified' stamp: 'kph 1/18/2008 10:55'!unload	self actualClass soleInstance unload.	super unload.! !!MCFileDefinition commentStamp: 'kph 12/6/2008 02:59' prior: 0!Although we are not strictly a Script, we have similar loading behaviour!!MCFileDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:56'!cacheDir	^ FileDirectory default directoryNamed: 'package-cache'! !!MCFileDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 03:54'!freeSomeSpace	| dir |	dir := self cacheDir directoryNamed: 'files'.	dir exists ifTrue: [ dir recursiveDelete ].! !!MCFileDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 01:31'!from: aPackageInfo addTo: definitions		| trim |		trim := FileDirectory default fullName size + 1.		^ aPackageInfo externalFiles collect: [ :aFD | 		definitions add: (self path: (aFD fullName allButFirst: trim) packageName: aPackageInfo name) realize ].	! !!MCFileDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:56'!path: aString packageName: packageString	^ self instanceLike: (self new initializeWithPath: aString packageName: packageString)! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:37'!description	^ Array with: self fileSize with: self path! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/14/2008 00:31'!edLoad: editor	FileDirectory default copyFileNamed: self pathToSnapshotFull toFileNamed: self pathToOriginalFull.		^ false! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 03:02'!evaluate	self error! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:36'!fileSize	^ self propertyAt: #fileSize ifAbsent: [ ]! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:36'!fileSize: n 	^ self propertyAt: #fileSize put: n! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:55'!initializeWithPath: aString packageName: packageString	self path:aString.	"packageName := packageString"! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 2/13/2009 04:48'!install	| file |	file := self pathToOriginalFull.	(FileDirectory on: file) containingDirectory assureExistence.	FileDirectory default copyFileNamed: self pathToSnapshotFull toFileNamed: file.! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 03:00'!installScript	self error! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:09'!isFileDefinition	^ true! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:58'!path	^ self propertyAt: #path ifAbsent: [ ]! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 03:42'!path: p 	^ self propertyAt: #path put: p! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:05'!pathToOriginalFull	^ FileDirectory default fullNameFor: self path! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:04'!pathToSnapshot	^ 'files/' , self uuid asString, '/', self path.	! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:04'!pathToSnapshotFull	^ self class cacheDir fullNameFor: self pathToSnapshot ! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:40'!realize		| f1 f2 |	f1 := self pathToOriginalFull.		self fileSize: (FileDirectory on: f1) directoryEntry fileSize.		f2 := self pathToSnapshotFull.	(FileDirectory on: f2) containingDirectory assureExistence.		FileDirectory default deleteFileNamed: f2.	 	FileDirectory default copyFileNamed: f1						 toFileNamed: f2.! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 03:03'!script	self error! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 22:44'!sortKey	^ self summary! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 22:50'!source	| fs |		fs := self class cacheDir oldFileNamed: self pathToSnapshot.			[ ^ fs next: 1000 ] ensure: [ fs close ]! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:48'!summary	^ ':FILE: ', self path , ' (' , self fileSize asString , ' bytes)'! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 23:50'!unload		FileDirectory default deleteFileNamed: self pathToOriginalFull ! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 00:52'!uuid	^ self propertyAt: #uuid ifAbsent: [ self uuid: UUID new ]! !!MCFileDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 00:52'!uuid: id	^ self propertyAt: #uuid put: id! !!MCMiscDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 22:31'!accept: writer! !!MCOrganizationDefinition class methodsFor: 'as yet unclassified' stamp: 'ab 7/26/2003 02:06' prior: 23409731!categories: anArray	^ self instanceLike: (self new categories: anArray)! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 18:25' prior: 23409429!= aDefinition	^ (super = aDefinition)		and: [categories = aDefinition categories]! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 21:47' prior: 23407161!accept: aVisitor	^ aVisitor visitOrganizationDefinition: self! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 5/24/2003 13:51' prior: 23407317!categories	^ categories! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23407447!categories: anArray	categories := anArray! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'kph 10/23/2008 23:00' prior: 23407595!commonPrefix	| stream |	categories isEmpty ifTrue: [^ ''].		stream := String new writeStream.	categories first keysAndValuesDo:		[:i :c |		categories do:			[:ea |			(ea at: i ifAbsent: []) = c ifFalse: [^ stream contents]].		stream nextPut: c].	^ stream contents! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'avi 9/28/2004 14:53' prior: 23407958!description	^ Array with: #organization with: self commonPrefix! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'mtf 12/11/2008 20:47'!edLoad: editor	"editor organization categories: categories."	^ true! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/12/2008 19:31'!edPostloadFor: loader	self postloadOver: (loader obsoletionFor: self)! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 7/11/2003 01:33' prior: 23408117!isOrganizationDefinition	^ true! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/22/2004 13:46' prior: 23408244!postloadOver: oldDefinition	SystemOrganization categories:		(self			reorderCategories: SystemOrganization categories			original: (oldDefinition ifNil: [#()] ifNotNil: [oldDefinition categories]))! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23408549!reorderCategories: allCategories original: oldCategories	| first |	first := allCategories detect: [:ea | categories includes: ea] ifNone: [^ allCategories].	^ 	((allCategories copyUpTo: first) copyWithoutAll: oldCategories, categories),		categories,		((allCategories copyAfter: first) copyWithoutAll: oldCategories, categories)! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 18:01' prior: 23408976!sortKey	^ '<organization>'! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/22/2003 01:14' prior: 23409097!source	^ String streamContents:		[:s |		categories do: [:ea | s nextPutAll: ea] separatedBy: [s cr]]! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'ab 5/24/2003 13:55' prior: 23409294!summary	^ categories asArray printString! !!MCOrganizationDefinition methodsFor: 'as yet unclassified' stamp: 'kph 2/17/2009 12:18'!unload	Smalltalk organization removeEmptyCategories! !!MCPostscriptDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04' prior: 23446800!scriptSelector	^ #postscript! !!MCPostscriptDefinition methodsFor: 'as yet unclassified' stamp: 'kph 2/15/2009 23:06'!postloadOver: obs	super postloadOver: obs.	self evaluate! !!MCPostscriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:16' prior: 23446526!sortKey	^ 'zzz' "force to the end so it gets loaded late"! !!MCPreambleDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04' prior: 23447322!scriptSelector	^ #preamble! !!MCPreambleDefinition methodsFor: 'as yet unclassified' stamp: 'kph 2/15/2009 23:17'!preloadOver: obs	super preloadOver: obs.	self evaluate ! !!MCRemovalPostscriptDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04' prior: 23451909!scriptSelector	^ #postscriptOfRemoval ! !!MCRemovalPostscriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:15' prior: 23451643!unload	super unload.	self evaluate! !!MCRemovalPreambleDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04' prior: 23452632!scriptSelector	^ #preambleOfRemoval! !!MCRemovalPreambleDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:14' prior: 23452211!sortKey	^ 'zzz' "force to the end so it gets unloaded early"! !!MCRemovalPreambleDefinition methodsFor: 'as yet unclassified' stamp: 'kph 2/17/2009 12:32' prior: 23452370!unload	self evaluate	super unload.! !!MCScriptDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 2/17/2009 12:12'!from: aPackageInfo addTo: definitions		| script default |	(aPackageInfo respondsTo: #propertyAt:) ifFalse: [ ^ self ].		script := (aPackageInfo propertyAt: self scriptSelector) ifNil: [ ^ self ].	default := aPackageInfo propertyDefaultAt: self scriptSelector.		script contents ~= default contents 		ifTrue: [ definitions add: (self script: script contents asString packageName: aPackageInfo name) ]! !!MCScriptDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 16:59' prior: 23484109!script: aString packageName: packageString	^ self instanceLike: (self new initializeWithScript: aString packageName: packageString)! !!MCScriptDefinition class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:00' prior: 23483971!scriptSelector	self subclassResponsibility! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 16:55' prior: 23483468!= aDefinition	^ (super = aDefinition)		and: [script = aDefinition script]! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:19' prior: 23481410!accept: aVisitor	"do nothing for now - this means it won't appear in the .st file"! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:12' prior: 23481582!description	^ Array with: packageName with: self scriptSelector! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:03' prior: 23481735!evaluate	Compiler evaluate: script! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23481870!initializeWithScript: aString packageName: packageString	script := aString.	packageName := packageString! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:11' prior: 23482065!installScript	self installScript: script! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'kph 2/15/2009 23:23' prior: 23482195!installScript: aString		self packageInfo propertyAt: self scriptSelector put: (StringHolder new contents: aString).	! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:22' prior: 23482565!packageInfo	^ PackageInfo named: packageName! !!MCScriptDefinition methodsFor: '' stamp: 'kph 2/7/2009 18:25'!preloadOver: aDefinition 	super preloadOver: aDefinition.	self installScript! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 16:54' prior: 23482699!script	^ script! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:10' prior: 23482804!scriptSelector	^ self class scriptSelector! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'bf 10/25/2005 19:05' prior: 23482936!sortKey	^ '!!', self scriptSelector "force to the front so it gets loaded first"! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:04' prior: 23483106!source	^ script! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:12' prior: 23483211!summary	^ packageName, ' ', self scriptSelector! !!MCScriptDefinition methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2005 17:12' prior: 23483348!unload	self installScript: nil! !!MCUnlinkedClassDefinition commentStamp: 'kph 5/11/2007 04:32' prior: 0!When a class has its super class removed, this definition is placed in the orphanage with the responsibility of relinking the class with its superclass if it is loaded.!!MCUnlinkedClassDefinition class methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:56'!class: unlinkedClass 	^ self new class: unlinkedClass name superclass: unlinkedClass superclass name	! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:27'!actualClass	^Smalltalk classNamed: self className! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 12/4/2008 15:07'!category	^( self actualClass ifNil: [ ^ '' ])category ifNil: [ '' ]! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:05'!class: className superclass: scName	name :=  className.	superclassName := scName! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:27'!className	^ name! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:24'!description	^ Array with: name! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:26'!hash	| hash |		hash := String stringHash: name initialHash: 0.	hash := String stringHash: superclassName initialHash: hash.	 	hash := String stringHash: self category initialHash: hash.	 	^ hash! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:33'!isClassDefinitionExtension	"Answer true if this definition extends the regular class definition"	^true! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 01:12'!isPartOfPackage: aPackageInfo or: orphanage	^ aPackageInfo includesSystemCategory: self category! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 13:22'!isUnlinkedClassDefinition	 	^true! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:35'!kindOfSubclass	^ ' subclass: '! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2008 01:23'!preloadOver: obs	super preloadOver: obs.	self actualClass superclass: ((Smalltalk classNamed: self superclassName) ifNil: [ self error: 'not ready yet']).	self actualClass superclass addSubclass: self actualClass.	self actualClass class superclass: ((Smalltalk classNamed: self superclassName) class ifNil: [ self error: 'not ready yet']).		self actualClass class superclass addSubclass: self actualClass class.		(SystemNavigation default obsoleteBehaviors	detect: [ :obsClass | 						([ obsClass nonObsoleteClass ] ifError: [ nil ]) = self actualClass ] ifNone: [ ^self ])	in: [ :obsClass | 		| metaClass |		metaClass := obsClass metaclass.		self actualClass updateInstancesFrom: obsClass. 		obsClass becomeForward: self actualClass.		metaClass becomeForward: self actualClass class ].	(SystemNavigation default obsoleteBehaviors select: [ :c | c isMeta not ])	do: [ :obsClass | 		| metaClass |		metaClass := obsClass metaclass.		self actualClass updateInstancesFrom: obsClass. 		obsClass becomeForward: self actualClass.		metaClass becomeForward: self actualClass class ]		 ! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/22/2007 01:52'!printDefinitionAndCommentOn: stream		self printDefinitionOn: stream.	  ! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:40'!printDefinitionOn: stream		stream 			nextPutAll: '"Class has an obsolete superclass, will relink..."';			cr; cr;			nextPutAll: self superclassName;			nextPutAll: self kindOfSubclass;			nextPut: $# ;			nextPutAll: self className			 ! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:55'!requirements	^ (Array with: superclassName) ! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:27'!sortKey	^ self className! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:29'!summary	^ name! !!MCUnlinkedClassDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 04:37'!superclassName	^ superclassName! !!MCDefinitionIndex class methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:29' prior: 23288788!definitions: aCollection	^ self new addAll: aCollection! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:38' prior: 23287754!add: aDefinition	definitions at: aDefinition description put: aDefinition! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:38' prior: 23287611!addAll: aCollection	aCollection do: [:ea | self add: ea]! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23287927!definitionLike: aDefinition ifPresent: foundBlock ifAbsent: errorBlock	| definition |	definition := definitions at: aDefinition description ifAbsent: [].	^ definition		ifNil: errorBlock		ifNotNil: [foundBlock value: definition]! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:42' prior: 23288245!definitions	^ definitions values! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23288377!initialize	definitions := Dictionary new! !!MCDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:40' prior: 23288504!remove: aDefinition	definitions removeKey: aDefinition description ifAbsent: []! !!MCImageBackedDefinitionIndex commentStamp: '<historical>' prior: 0!When using definitionLike: ... I go to the image before giving up!!MCImageBackedDefinitionIndex methodsFor: 'as yet unclassified' stamp: 'mtf 10/7/2008 13:43'!definitionLike: aDefinition ifPresent: foundBlock ifAbsent: errorBlock	| definition |	^ super definitionLike: aDefinition ifPresent: foundBlock ifAbsent: [		definition := aDefinition fromImage.		definition			ifNil: [errorBlock value]			ifNotNil: [foundBlock value: definition]]! !!MCDependencySorter commentStamp: 'kph 5/3/2007 18:46' prior: 0!MCDependencySorter   * #orderedItems     has an OrderedCollection of the item Definitions that have                   all of their requirements when added.   * #required         A dictionary of Sets, keyed on the 'required' item, the Set                   containing the items which require that item   * #provided         A set of provided items, i.e. those which might be required.As each item is added using #add, or #addAll, it obtains the items requirements, subtracting those items which it already has listed as #provided. Items with all of their requirements are added to the #orderedItems. In doing so each of those items is added to the #provided set. When adding to the provided set, a check is made in the #required items to see if the newly provided item is required. If so, it is cleared out of the required list and those items that were waiting for that requirement are then added via #add:/#addAll:Finally you have:   * #orderedItems                         - the collection of items which should load.   * #itemsWithMissingRequirements     - the collection of items that will not yet load.   * #externalRequirements             - the list of requirements still needed after                                         all the internal provisions are accounted for.Typical use (e.g. MCPackageLoader-#analyse) is to instantiate via #items, which adds all of the items and sorts them as they are added. Then calling #addExternalProvisions: with the set of class keys avalable in the image. This gives the ready to load result.The #sortItems: instanciation method sorts the items as above, it assumes that all of the #externalProvisions are available so as to get the complete sorted order. This is used when writing the definitions.!!MCDependencySorter class methodsFor: 'as yet unclassified' stamp: 'ab 5/23/2003 14:17' prior: 23291887!items: aCollection	^ self new addAll: aCollection! !!MCDependencySorter class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23292169!sortItems: aCollection	| sorter |	sorter := self items: aCollection.	sorter externalRequirements do: [:req  | sorter addProvision: req].	^ sorter orderedItems.! !!MCDependencySorter methodsFor: 'building' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23290095!add: anItem	| requirements |	requirements := self unresolvedRequirementsFor: anItem.	requirements isEmpty		ifTrue: [self addToOrder: anItem]		ifFalse: [self addRequirements: requirements for: anItem]! !!MCDependencySorter methodsFor: 'building' stamp: 'bf 11/12/2004 14:50' prior: 23289733!addAll: aCollection	aCollection asArray sort do: [:ea | self add: ea]! !!MCDependencySorter methodsFor: 'building' stamp: 'avi 10/7/2004 22:47' prior: 23289881!addExternalProvisions: aCollection	(aCollection intersection: self externalRequirements)		do: [:ea | self addProvision: ea]! !!MCDependencySorter methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23290694!addProvision: anObject	| newlySatisfied |	provided add: anObject.	newlySatisfied := required removeKey: anObject ifAbsent: [#()].	self addAll: newlySatisfied.! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:24' prior: 23291113!addRequirement: reqObject for: itemObject	(self itemsRequiring: reqObject) add: itemObject! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:23' prior: 23290932!addRequirements: aCollection for: anObject	aCollection do: [:ea | self addRequirement: ea for: anObject]! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:15' prior: 23291280!addToOrder: anItem	orderedItems add: anItem.	anItem provisions do: [:ea | self addProvision: ea].! !!MCDependencySorter methodsFor: 'accessing' stamp: 'dvf 9/8/2004 00:49' prior: 23289220!externalRequirements	| unloaded providedByUnloaded |	unloaded := self itemsWithMissingRequirements.	providedByUnloaded := (unloaded gather: [:e | e provisions]) asSet.	^ required keys reject: [:ea | providedByUnloaded includes: ea ]! !!MCDependencySorter methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23290399!initialize	provided := Set new.	required := Dictionary new.	orderedItems := OrderedCollection new.! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:24' prior: 23291455!itemsRequiring: anObject	^ required at: anObject ifAbsentPut: [Set new]! !!MCDependencySorter methodsFor: 'accessing' stamp: 'kph 5/15/2007 13:13' prior: 23289546!itemsWithMissingRequirements	| items |	items := Set new.	required keysAndValuesDo: [ :ea :waiting | 		waiting do: [ :eaWaiting | eaWaiting because: ' needs ', ea  ]. 		items addAll: waiting	].	^ items! !!MCDependencySorter methodsFor: 'sorting' stamp: 'ab 5/22/2003 23:25' prior: 23290577!orderedItems	^ orderedItems! !!MCDependencySorter methodsFor: 'private' stamp: 'ab 5/22/2003 23:22' prior: 23291603!unresolvedRequirementsFor: anItem	^ anItem requirements difference: provided! !!MCClassTraitParser class methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 20:43' prior: 23241321!pattern	^ '*classTrait*uses:*'! !!MCClassTraitParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23240745!addDefinitionsTo: aCollection	| tokens  definition traitCompositionString |	tokens := Scanner new scanTokens: source.	traitCompositionString := ((ReadStream on: source)		match: 'uses:';		upToEnd) withBlanksTrimmed.	definition := MCClassTraitDefinition		baseTraitName: (tokens at: 1) 		classTraitComposition: traitCompositionString.	aCollection add: definition! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:29' prior: 23309209!concreteSubclasses	^ self allSubclasses reject: [:c | c isAbstract]! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:40' prior: 23309366!forDoit: aString	^ (self subclassForDoit: aString) ifNotNilDo: [:c | c new source: aString]! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:51' prior: 23309547!isAbstract	^ self pattern isNil! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:30' prior: 23309668!pattern	^ nil! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:30' prior: 23309771!subclassForDoit: aString	^ self concreteSubclasses detect: [:ea | ea pattern match: aString] ifNone: []! !!MCDoItParser methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:40' prior: 23308727!addDefinitionsTo: aCollection	self subclassResponsibility ! !!MCDoItParser methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:40' prior: 23308869!source	^ source! !!MCDoItParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23308979!source: aString	source := aString! !!MCSystemCategoryParser class methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:41' prior: 23544948!pattern	^ 'SystemOrganization*'! !!MCSystemCategoryParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23544211!addDefinitionsTo: aCollection	| definition |	definition := aCollection detect: [:ea | ea isOrganizationDefinition ] ifNone: [aCollection add: (MCOrganizationDefinition categories: #())].	definition categories: (definition categories copyWith: self category).! !!MCSystemCategoryParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23544576!category	| tokens  |	tokens := Scanner new scanTokens: source.	tokens size = 3 ifFalse: [self error: 'Unrecognized category definition'].	^ tokens at: 3! !!MCTraitParser class methodsFor: 'as yet unclassified' stamp: 'al 10/9/2005 21:09' prior: 23575377!pattern	^ 'Trait named:*'! !!MCTraitParser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23574754!addDefinitionsTo: aCollection	| tokens  definition traitCompositionString |	tokens := Scanner new scanTokens: source.	traitCompositionString := ((ReadStream on: source)		match: 'uses:';		upToAll: 'category:') withBlanksTrimmed.	definition := MCTraitDefinition		name: (tokens at: 3) 		traitComposition: traitCompositionString		category:  tokens last		comment:  ''  		commentStamp:   ''.	aCollection add: definition.! !!MCDocumentation commentStamp: 'kph 5/3/2007 18:52' prior: 0!Pulling MC enhancements together:source.wiresong.ca/mv avi.276 !!MCDocumentation methodsFor: 'as yet unclassified' stamp: 'kph 6/29/2007 00:37'!releaseNotes! !!MCDocumentation methodsFor: 'as yet unclassified' stamp: 'kph 6/29/2007 02:56'!releaseNotes28062007"Clarified the parsing of the package name into its constituent parts, aiming to make things more resilient, and flexible.also ensured more flexibility to version numbersMonticelloTest-xxx.1.mcz - standard mcMonticelloTest1.2.3-xxx.1.mcz - standard mc with dots in package name (must occur before first $-)MonticelloTest-xxx.1.3.4b.mcz - traditional sw (note numberic #versionNumber only gives 1.3)MonticelloTest-xxx.1bd9def2-25d1-11dc-909f-000a95edb42a.mcz - uuid version"! !!MCFrontier class methodsFor: 'instance creation' stamp: 'avi 9/17/2005 22:07' prior: 23330959!frontierOn: aVersionInfo	^ self frontierOnAll: (Array with: aVersionInfo)! !!MCFrontier class methodsFor: 'instance creation' stamp: 'avi 9/17/2005 22:07' prior: 23331118!frontierOn: aVersionInfo and: otherVersionInfo	^ self frontierOnAll: (Array with: aVersionInfo with: otherVersionInfo)! !!MCFrontier class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23330610!frontierOnAll: aCollection	| remaining  allVersions |	remaining := Bag new.	allVersions := (aCollection gather: [:ea | ea withBreadthFirstAncestors]) asSet.	allVersions do: [:ea | remaining addAll: ea ancestors].	^self new frontier: aCollection bag: remaining! !!MCFrontier methodsFor: 'accessing' stamp: 'avi 9/17/2005 22:02' prior: 23329817!frontier	^frontier! !!MCFrontier methodsFor: 'initialization' stamp: 'avi 9/17/2005 22:11' prior: 23330329!frontier: f bag: remaining	frontier := f asOrderedCollection.	bag := remaining! !!MCFrontier methodsFor: 'advancing' stamp: 'avi 9/17/2005 22:13' prior: 23330039!remove: aVersionInfo	frontier remove: aVersionInfo.	aVersionInfo ancestors  do:		[ :ancestor |			bag remove: ancestor.			(bag occurrencesOf: ancestor) = 0				ifTrue: [frontier add: ancestor]].	^aVersionInfo! !!MCFrontier methodsFor: 'advancing' stamp: 'avi 9/17/2005 22:02' prior: 23329908!removeAll: collection	collection do: [ :n | self remove: n]! !!MCMergeRecord class methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 15:52' prior: 23370124!version: aVersion	^ self basicNew initializeWithVersion: aVersion! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23368067!ancestorInfo	^ ancestorInfo ifNil: [ancestorInfo := version info commonAncestorWith: version workingCopy ancestry]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23368277!ancestorSnapshot	^ ancestorSnapshot ifNil: [ancestorSnapshot := version workingCopy findSnapshotWithVersionInfo: self ancestorInfo]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23368504!imageIsClean	| ancestors |	ancestors := version workingCopy ancestors.	^ ancestors size = 1		and: [ancestors first = self ancestorInfo]			and: [self imagePatch isEmpty]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23368772!imagePatch	^ imagePatch ifNil: [imagePatch := self packageSnapshot patchRelativeToBase: self ancestorSnapshot]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23368978!initializeWithVersion: aVersion	version := aVersion! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 17:14' prior: 23369114!isAncestorMerge	^ version workingCopy ancestry hasAncestor: version info! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23369282!mergePatch	^ mergePatch ifNil: [mergePatch := version snapshot patchRelativeToBase: self ancestorSnapshot]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23369484!packageSnapshot	^ packageSnapshot ifNil: [packageSnapshot := version package snapshot]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 17:14' prior: 23369655!updateWorkingCopy	self isAncestorMerge ifFalse:		[self imageIsClean			ifTrue: [version workingCopy loaded: version]			ifFalse: [version workingCopy merged: version]]! !!MCMergeRecord methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 15:52' prior: 23369908!version	^ version! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:10' prior: 23371124!addConflictWithOperation: anOperation	self conflicts add: (MCConflict operation: anOperation)! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:01' prior: 23371295!applyTo: anObject	self isMerged ifFalse: [self error: 'You must resolve all the conflicts first'].	conflicts do: [:ea | ea applyTo: anObject]! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23371528!conflicts	^ conflicts ifNil: [conflicts := OrderedCollection new]! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/5/2003 19:09' prior: 23371671!isMerged	^ self conflicts allSatisfy: [:ea | ea isResolved]! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:29' prior: 23371821!load	| loader |	loader := MCPackageLoader newCurrent.	loader provisions addAll: self provisions.	self applyTo: loader.	loader load! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:29' prior: 23372039!loadWithNameLike: baseName	| loader |	loader := MCPackageLoader newCurrent.	loader provisions addAll: self provisions.	self applyTo: loader.	loader loadWithNameLike: baseName! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:11' prior: 23372288!mergedSnapshot	^ MCPatcher apply: self to: self baseSnapshot! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 16:34' prior: 23372427!operations	^ #()! !!MCMerger methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 15:19' prior: 23372523!provisions	^ #()! !!MCThreeWayMerger class methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:53' prior: 23555866!base: aSnapshot patch: aPatch	aPatch isEmpty ifTrue: [MCNoChangesException signal].	^ self new		addBaseSnapshot: aSnapshot;		applyPatch: aPatch;		yourself		! !!MCThreeWayMerger class methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:09' prior: 23556119!base: aSnapshot target: targetSnapshot ancestor: ancestorSnapshot	^ self base: aSnapshot patch: (targetSnapshot patchRelativeToBase: ancestorSnapshot)! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 15:18' prior: 23551748!addBaseSnapshot: aSnapshot	aSnapshot definitions do:		[:ea |		index add: ea.		provisions addAll: ea provisions]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'mtf 10/7/2008 14:40' prior: 23551950!addDefinition: aDefinition	index		definitionLike: aDefinition		ifPresent: [:other |			(self removalForDefinition: aDefinition)				ifNotNilDo:					[:op |					self addOperation: (MCModification of: other to: aDefinition).					self removeOperation: op.					^ self].			other = aDefinition				ifFalse: [(aDefinition isMethodDefinition and: [aDefinition isOverrideMethod])					ifTrue: [self addOperation: (MCModification of: other to: aDefinition)]					ifFalse: [self addConflictWithOperation: (MCModification of: other to: aDefinition)]]				ifTrue: [self redundantAdds add: aDefinition]]		ifAbsent: [self addOperation: (MCAddition of: aDefinition)]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:30' prior: 23552531!addOperation: anOperation	self operations add: anOperation! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:52' prior: 23552677!applyPatch: aPatch	aPatch applyTo: self! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:32' prior: 23552802!applyTo: anObject	super applyTo: anObject.	self operations do: [:ea | ea applyTo: anObject]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 01:49' prior: 23552982!baseSnapshot	^ (MCSnapshot fromDefinitions: index definitions)! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'mtf 10/7/2008 14:12' prior: 23553143!initialize	index := MCImageBackedDefinitionIndex new.	provisions := Set new! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:22' prior: 23553296!modificationConflictForDefinition: aDefinition	^ conflicts ifNotNil:		[conflicts detect:			[:ea | (ea definition isRevisionOf: aDefinition) and:				[ea operation isModification]] ifNone: []]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 01:34' prior: 23553575!modifyDefinition: baseDefinition to: targetDefinition	index		definitionLike: baseDefinition		ifPresent: [:other | other = baseDefinition								ifTrue: [self addOperation: (MCModification of:  baseDefinition to: targetDefinition)]								ifFalse: [other = targetDefinition											ifFalse: [self addConflictWithOperation:														(MCModification of: other to: targetDefinition)]]]		ifAbsent: [self addConflictWithOperation: (MCAddition of: targetDefinition)]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23554146!operations	^ operations ifNil: [operations := OrderedCollection new]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 15:19' prior: 23554302!provisions	^ provisions! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23554424!redundantAdds	^ redundantAdds ifNil: [redundantAdds := Set new]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:40' prior: 23554575!removalForDefinition: aDefinition	^ operations ifNotNil:		[operations			detect: [:ea | (ea definition isRevisionOf: aDefinition) and: [ea isRemoval]]			ifNone: []]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:40' prior: 23554829!removeConflict: aConflict	conflicts remove: aConflict! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 03:23' prior: 23554970!removeDefinition: aDefinition	index		definitionLike: aDefinition		ifPresent: [:other | other = aDefinition								ifTrue:									[(self modificationConflictForDefinition: aDefinition)										ifNotNilDo:											[:c |											self addOperation: c operation.											self removeConflict: c.											^ self]. 									(self redundantAdds includes: aDefinition)										ifFalse: [self addOperation: (MCRemoval of: aDefinition)]]								ifFalse:									[self addConflictWithOperation: (MCRemoval of: other)]]		ifAbsent: []! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'avi 9/19/2005 02:40' prior: 23555602!removeOperation: anOperation	operations remove: anOperation! !!MCOrphanage commentStamp: 'kph 5/15/2007 01:16' prior: 0!MCOrphanage. supports out-of-order loading of packages, and safe unloading.This enables a package to 'extend', and 'override' methods in not-yet-loaded packages. Not yet actually loaded ('orphaned') extensions should also save with the package so as not to be lost. For Detailed Specification: OrphanageTest1 class comment, available in the OrphanageTest-Test1 package. Hooks:MCPackageLoader calls #loading: before loading a package, and #loadComplete afterwards.Orphans are added to the package prior to loading and afterwards.#onClassRemoved: theClass is called by the environment notification system. Orphaned class extension methods are mopped up into the orphanage, and each subclass is given a MCUnlinkedClassDefinition poised to await the reloading of that class. (there may be a better way, but it is a good idicator of any unlinked classes having obsolete superclasses)Each definition that is loaded without error sends us #successfullyLoaded: so we can remove that defn from the orphanage.Design decision: packageInfo collates its info via #orphansFor: aPackage, which use polyMorphism to call #isPartOfPackage or: orphanage , which doesnt use any packageInfo 'monticello-orphanage' methods which call orphansFor: (think infinite loop).!!MCOrphanage class methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 20:10'!current 	^ Current ifNil: [ self initializeTheOrphanage ].! !!MCOrphanage class methodsFor: 'as yet unclassified' stamp: 'kph 9/2/2008 03:50'!initializeTheOrphanage	Current := self named: '.Orphanage'.	 	MCWorkingOrphanage forPackage: Current.		^ Current! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 5/9/2007 06:24'!addOrphans: some	some ifNil: [ ^self ].	orphans addAll: some! !!MCOrphanage methodsFor: 'ui actions' stamp: 'kph 5/10/2007 17:24'!clearOrphans	self initialize! !!MCOrphanage methodsFor: 'initialize-release' stamp: 'kph 7/16/2008 16:16'!initialize 	orphans := Set new.	unlinkedCount := nil.! !!MCOrphanage methodsFor: 'events' stamp: 'kph 5/11/2007 13:26'!loadComplete	unlinkedCount := nil! !!MCOrphanage methodsFor: 'loading' stamp: 'kph 5/10/2007 23:42'!loading: aPackageLoader	"when the package loader is about to do a load the orphanage applys ALL orphans"		self orphans do: [ :orphanDefn | (MCAddition of: orphanDefn) applyTo: aPackageLoader ].! !!MCOrphanage methodsFor: 'events' stamp: 'kph 1/18/2008 10:10'!onClassRemoved: theClass		| cat |	orphans := orphans reject: [ :defn | defn className = theClass name ].				theClass subclasses do: [ :aSubclass | orphans add: (MCUnlinkedClassDefinition class: aSubclass) ]. 	(Array with: theClass with: theClass classSide ) do: [ :behavior |		behavior selectorsAndMethodsDo: [ :selector :method |			cat := behavior organization categoryOfElement: selector.						cat ifNotNil: [ 				(cat beginsWith: '*')					ifTrue: [ orphans add: method methodReference asMethodDefinition ]			]		]	].	unlinkedCount := nil.! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 10/25/2008 01:34'!orphanClasses	^ self orphans asOrderedCollection select: [ :o | o isClassDefinition ].	 ! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 5/15/2007 01:31'!orphanMethods	^ self orphans select: [ :o | o isMethodDefinition ].! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 4/30/2007 00:48'!orphans	"Answer the value of orphans, an MCPackageLoader"	^ orphans! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 5/15/2007 01:13'!orphansFor: packageInfo 	^ self orphans select: [ :defn  | defn isPartOfPackage: packageInfo or: self  ]! !!MCOrphanage methodsFor: 'events' stamp: 'kph 5/15/2007 16:39'!packageUnloaded: aPackageInfo 	"while an unlinked class exists the power to relink it remains"	((self orphansFor: aPackageInfo) difference: self unlinkedClasses)		do: [ :ea | ea removeFromOrphanage: self ]! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 4/30/2007 01:21'!snapshot		^ MCSnapshot fromDefinitions: self orphans! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 4/30/2007 01:07'!storeOn: aStream	self halt. "when is this used?"	aStream		nextPutAll: self class name;		space; nextPutAll: 'named: '; store: name.! !!MCOrphanage methodsFor: 'events' stamp: 'kph 5/10/2007 17:54'!successfullyLoaded: aDefinition	self orphans remove: aDefinition ifAbsent: [ ^ self ].	 ! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 5/15/2007 01:18'!unlinkedClasses     ^ orphans select: [ :orphan | orphan isUnlinkedClassDefinition ] ! !!MCOrphanage methodsFor: 'accessing' stamp: 'kph 5/15/2007 01:18'!unlinkedCount	^ unlinkedCount ifNil: [ unlinkedCount := self unlinkedClasses size ] ! !!MCPackage class methodsFor: 'as yet unclassified' stamp: 'ab 7/10/2003 01:17' prior: 23415305!named: aString	^ self new name: aString! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ar 4/26/2005 21:57' prior: 23415046!= other	^ other species = self species and: [other name sameAs: name]! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'kph 8/3/2008 04:16' prior: 23412639!hasWorkingCopy	MCWorkingCopy organizer packageNamed: self name ifAbsent: [ ^ false ].		^ true! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ar 4/26/2005 21:57' prior: 23412531!hash	^ name asLowercase hash! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 00:57' prior: 23412775!name	^ name! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23412878!name: aString	name := aString! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'kph 5/10/2007 05:36'!orphanage	^ MCOrphanage current! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'kph 8/3/2008 03:26' prior: 23412986!packageInfo	^ PackageInfo named: name ! !!MCPackage methodsFor: 'patching' stamp: 'mtf 10/7/2008 14:04'!patchSnapshot	^ self snapshot asPatchSnapshot! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'nk 7/28/2003 13:30' prior: 23413103!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: name;		nextPut: $)! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 03:31' prior: 23413281!snapshot	| definitions categories packageInfo | 	packageInfo := self packageInfo.	definitions := OrderedCollection new.	categories := packageInfo systemCategories.		definitions addAll: (self orphanage orphansFor: packageInfo). 	definitions removeAllFoundIn: self orphanage unlinkedClasses.	   	categories isEmpty ifFalse: [ definitions add: (MCOrganizationDefinition categories: categories) ].	packageInfo		classesDo: [:ea | definitions addAll: ea classDefinitions]		methodsDo: [:ea | definitions add: ea asMethodDefinition]		displayingProgress: 'Snapshotting...'.		MCScriptDefinition subclassesDo: [ :ea | ea from: packageInfo addTo: definitions ].	MCFileDefinition from: packageInfo addTo: definitions.		^ MCSnapshot fromDefinitions: definitions 	! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ab 7/10/2003 01:13' prior: 23414629!storeOn: aStream	aStream		nextPutAll: 'MCPackage';		space; nextPutAll: 'named: '; store: name.! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'cwp 11/13/2003 13:32' prior: 23414807!unload	^ self workingCopy unload! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'cwp 11/13/2003 13:33' prior: 23414921!workingCopy	^ MCWorkingCopy forPackage: self.! !!MCPackageCache class methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:12' prior: 23416248!new	^ self basicNew initialize! !!MCPackageCache methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23415601!initialize	sorter := MCVersionSorter new.	fileNames := Dictionary new.! !!MCPackageCache methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:25' prior: 23415758!recordVersionInfo: aVersionInfo forFileNamed: aString	Transcript cr; show: aString.	fileNames at: aVersionInfo put: aString.	sorter addVersionInfo: aVersionInfo! !!MCPackageCache methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:21' prior: 23416006!versionInfos	^ sorter sortedVersionInfos ! !!MCPackageLoader commentStamp: 'kph 5/26/2007 04:22' prior: 0!This loader is the old MC1 code essentially untouched, thoug this class is now obsolete.This is kept here so that when loading this new version of mc into a system with an older version of mc it is running this code and so we do not wish to disturb it. In loading this version, the class #new method is updated to switch future instanciations to the new package loader, this old one being obsolete.This loader remains potentially usable but does not know about the orphanage. #installOrphanage is implemented here as a unused noop, just in case someone wants to revert to using this loader.!!MCPackageLoader class methodsFor: 'as yet unclassified' stamp: 'mtf 10/8/2008 00:36'!initialize	"MCPackageLoader initialize"	Preferences addPreference: #useMonticelloAtomicLoader categories: #(monticello) default: false balloonHelp:	'Use the experimental atomic loader for Monticello. You must have SystemEditor for this to work'! !!MCPackageLoader class methodsFor: 'as yet unclassified' stamp: 'kph 5/26/2007 01:18' prior: 23423385!new	^ (self theChosenLoaderClass basicNew) initialize; yourself! !!MCPackageLoader class methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:29'!newCurrent	^ (self theChosenLoaderClass basicNew) initialize; yourself! !!MCPackageLoader class methodsFor: 'as yet unclassified' stamp: 'mtf 6/17/2008 09:21'!theChosenLoaderClass	^ (Preferences useMonticelloAtomicLoader and: [Smalltalk includesKey: #SystemEditor])		ifTrue: [MCPackageLoader2]		ifFalse: [MCPackageLoader1b]! !!MCPackageLoader1b commentStamp: 'kph 5/25/2007 04:43' prior: 0!MCPackageLoader1b - Attempt to improve loading with a number of tricksIn #basicLoad the loading process starts with a collection of definitions in #additions, and another in #removals. #analyse should have sorted these so that dependencies shouldnt cause errors.The load sequence sent to each addidion is: #preLoadOver: [ #install #postinstall ] #postloadOver:The load sequence sent to each removal is                    [ #unload ]The brackets above mark the fact that the 'load' itself which is perfromed by #install/#postinstall and #unload are performed in a tight loop and this is our attempt at atomicity.For methods, #preloadOver:, and #postloadOver: obsoletions are supplied, being the original item being overwritten.InstVar #defn is the currently loading definition. This allows error handlers to know what was being processed when the error occured.-----Note that to support loading this Monicello over a version which does not support atomic loading, soe things have to remain in place that are otherwise obsolete.MCDefinition-#loadOver:MCPackageLoader instVar's errorDefinitions, addtions, removals cant be renamed.!!MCPackageLoader1b class methodsFor: 'as yet unclassified' stamp: 'kph 5/25/2007 04:26'!new	^ self basicNew initialize! !!MCPackageLoader1b methodsFor: 'patch ops' stamp: 'kph 5/25/2007 04:26'!addDefinition: aDefinition	additions add: aDefinition! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 6/12/2007 09:36'!analyze	| sorter |		self isMultiplePackage ifTrue: [ self analyzeMulti ].		sorter := self sorterForItems: additions.	additions := sorter orderedItems.	requirements := sorter externalRequirements.	unloadableDefinitions := sorter itemsWithMissingRequirements asSortedCollection.		sorter := self sorterForItems: removals.	removals := sorter orderedItems reversed.! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 6/12/2007 09:35'!analyzeMulti	| index |	index := MCDefinitionIndex definitions: additions.	removals removeAllSuchThat: [:removal |		(index definitionLike: removal			ifPresent: [:addition | obsoletions at: addition put: removal]			ifAbsent: []) notNil].! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 4/14/2008 13:18'!basicLoad  	additions do: [:ea | ea preloadOver: (self obsoletionFor: ea).   ] displayingProgress: 'Loading...'.			self shouldWarnAboutErrors ifTrue: [ self warnAboutErrors: errorDefinitions ].	(1 to: 2) do: [:ea |  ] displayingProgress: (self isUnloading ifFalse: [ 'Installing...' ] 																ifTrue: [ 'Unloading...' ]).	"begin the psuedo atomic bit"				removals do: [:ea | ea unload ].	additions do: [:ea | ea install ].	additions do: [:ea | ea postinstall ].	"end the psuedo atomic bit" 	 additions reverse do: [:ea | 				ea postloadOver: (self obsoletionFor: ea).		self successfullyLoaded: ea.	] displayingProgress: 'Integration...'.! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 6/12/2007 09:33'!beMultiplePackage	isMultiplePackage := true! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 5/25/2007 04:26'!beUnloading	isUnloading := true! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!dependencyWarning	^ String streamContents:		[:s |		s nextPutAll: 'This package, or the orphanage is looking for the following classes:'; cr.		requirements do: [:ea | s space; space; nextPutAll: ea; cr].		s nextPutAll: 'These definitions will be orphaned until the classes are loaded: '; cr.		unloadableDefinitions do: [:ea | s space; space; nextPutAll: (ea summary, ea because); cr]] ! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!errorDefinitionWarning: erroredDefns	^ String streamContents:		[:s |		s nextPutAll: 'The following definitions had errors while loading.  Press Proceed to try to load them again (they may work on a second pass):'; cr.		erroredDefns do: [:ea | 			s space; space; 			  nextPutAll: ea summary;			  space; 			  nextPutAll: (ea because ifNil: [ '' ]); cr]] ! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!flushChangesFile	"The changes file is second in the SourceFiles array"	(SourceFiles at: 2) flush! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/26/2007 00:29'!initialize	additions := OrderedCollection new.	removals := OrderedCollection new.	obsoletions := Dictionary new. ! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!installOrphanage	self orphanage loading: self.! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 5/25/2007 04:26'!installSnapshot: aSnapshot	| patch |	patch := aSnapshot patchRelativeToBase: MCSnapshot empty.	patch applyTo: self.	 ! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 6/12/2007 09:33'!isMultiplePackage	^ isMultiplePackage == true! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 5/25/2007 04:26'!isUnloading 	^ isUnloading ifNil: [ false ]! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 5/25/2007 04:26'!load	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useNewChangeSetDuring: [self protectedLoad].	self loadComplete.! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 12/6/2008 02:49'!loadComplete	MCMethodDefinition tidyCache.	self orphanage 		addOrphans: unloadableDefinitions;	 	addOrphans: errorDefinitions;		loadComplete.	Behavior flushObsoleteSubclasses.	self loadFiles.! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 12/6/2008 02:50'!loadFiles! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 5/25/2007 04:26'!loadWithName: baseName 	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useChangeSetNamed: baseName during: [self protectedLoad].	self loadComplete.! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 5/25/2007 04:26'!loadWithNameLike: baseName 	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useNewChangeSetNamedLike: baseName during: [self protectedLoad].	self loadComplete.! !!MCPackageLoader1b methodsFor: 'patch ops' stamp: 'kph 5/25/2007 04:26'!modifyDefinition: old to: new	self addDefinition: new.	obsoletions at: new put: old.! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!obsoletionFor: aDefinition	^ obsoletions at: aDefinition ifAbsent: [nil]! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!orderedAdditions	^ additions! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!orphanage	^ MCOrphanage current! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 12/18/2007 01:05'!protectedLoad		errorDefinitions := OrderedCollection new. 		[			[				[ self basicLoad ] on: InMidstOfFileinNotification do: [:n |  n resume: true]			] ensure: [self flushChangesFile].				]  on: MCOrphanedNotification do: [ :ex | additions remove: ex orphan ifAbsent: [].											errorDefinitions add: ex orphan. 									 		ex resume.					  		] ! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!provisions	^ provisions ifNil: [provisions := Set withAll: Smalltalk keys]! !!MCPackageLoader1b methodsFor: 'patch ops' stamp: 'kph 5/25/2007 04:26'!removeDefinition: aDefinition	removals add: aDefinition! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!shouldWarnAboutErrors	^ false "should make this a preference"! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!sorterForItems: aCollection	| sorter |	sorter := MCDependencySorter items: aCollection.	sorter addExternalProvisions: self provisions.	^ sorter! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!successfullyLoaded: aDefinition	self orphanage successfullyLoaded: aDefinition! !!MCPackageLoader1b methodsFor: 'obsolete' stamp: 'kph 5/25/2007 04:26'!tryToLoad: aDefinition errors: errs 	self tryToLoad: aDefinition errors: errorDefinitions ! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/26/2007 10:02'!unloadPackage: aPackage 	(self 		updatePackage: aPackage withSnapshot: MCSnapshot empty;		beUnloading;		loadWithNameLike: aPackage name, '-unload';		yourself)		orphanage packageUnloaded: aPackage packageInfo.	! !!MCPackageLoader1b methodsFor: 'public' stamp: 'kph 8/2/2007 14:45'!updatePackage: aPackage withSnapshot: aSnapshot	|  patch packageSnap |	packageSnap := aPackage snapshot.	patch := aSnapshot patchRelativeToBase: packageSnap.	patch applyTo: self.	packageSnap definitions do: [:ea | self provisions addAll: ea provisions]! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!useChangeSetNamed: baseName during: aBlock	"Use the named change set, or create one with the given name."	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := (ChangeSorter changeSetNamed: baseName) ifNil: [ ChangeSet new name: baseName ].	changeHolder newChanges: newChanges.	[aBlock value] ensure: [changeHolder newChanges: oldChanges].! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!useNewChangeSetDuring: aBlock	^self useNewChangeSetNamedLike: 'MC' during: aBlock! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!useNewChangeSetNamedLike: baseName during: aBlock	^self useChangeSetNamed: (ChangeSet uniqueNameLike: baseName) during: aBlock! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 8/2/2007 00:22'!warnAboutDependencies 	"self notify: self dependencyWarning"! !!MCPackageLoader1b methodsFor: 'private' stamp: 'kph 5/25/2007 04:26'!warnAboutErrors: errors	errors isEmpty ifFalse: [ self notify: (self errorDefinitionWarning: errors) ]! !!MCPackageLoader2 commentStamp: 'kph 5/26/2007 09:32' prior: 0!MCPackageLoader2ProgressBar has great improvements.#setProgressBar: is used for clients to control how progress is displayed.If no one indicates a preference we display our own progress bar.Otherwise we use the one passed to us.To not have any progress bar displayed give us an empty block.#setProgressBar: [:v |  ] !!MCMultiPackageLoader commentStamp: '<historical>' prior: 0!A PackageLoader doing some additional cross-package checks!!MCMultiPackageLoader methodsFor: 'private' stamp: 'bf 3/17/2006 15:51'!analyze	| index |	index := MCDefinitionIndex definitions: additions.	removals removeAllSuchThat: [:removal |		(index definitionLike: removal			ifPresent: [:addition | obsoletions at: addition put: removal]			ifAbsent: []) notNil].	super analyze! !!MCPackageLoader2 class methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 18:03'!new	^ self basicNew initialize! !!MCPackageLoader2 methodsFor: 'patch ops' stamp: 'ab 5/24/2003 16:13'!addDefinition: aDefinition	additions add: aDefinition! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 6/12/2007 09:36'!analyze	| sorter |		self isMultiplePackage ifTrue: [ self analyzeMulti ].		sorter := self sorterForItems: additions.	additions := sorter orderedItems.	requirements := sorter externalRequirements.	unloadableDefinitions := sorter itemsWithMissingRequirements asSortedCollection.		sorter := self sorterForItems: removals.	removals := sorter orderedItems reversed.! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 6/12/2007 09:35'!analyzeMulti	| index |	index := MCDefinitionIndex definitions: additions.	removals removeAllSuchThat: [:removal |		(index definitionLike: removal			ifPresent: [:addition | obsoletions at: addition put: removal]			ifAbsent: []) notNil].! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 12/12/2008 23:22'!basicLoad	| postloads postunloads |	editor := SystemEditor new.	postloads := OrderedCollection new.	postunloads := OrderedCollection new.	additions do: [:defn |		(defn edLoadFor: self into: editor)			ifTrue: [postloads add: defn]]		displayingProgress: 'Assembling Changes...'.	removals do: [:defn |		(defn edUnload: editor)			ifTrue: [postunloads add: defn]]		displayingProgress: 'Assembling Removals...'.	"the business"	editor commitWithProgress.	postloads do: [:ea | ea edPostloadFor: self ] displayingProgress: 'Running post-load scripts...'.	postunloads do: [ :ea |  ea edPostunload] displayingProgress: 'Running post-unload scripts...'.! !!MCPackageLoader2 methodsFor: 'patch ops' stamp: 'kph 6/12/2007 09:32'!beMultiplePackage	isMultiplePackage := true! !!MCPackageLoader2 methodsFor: 'public' stamp: 'kph 5/15/2007 15:38'!beUnloading	isUnloading := true! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/15/2007 13:38'!dependencyWarning	^ String streamContents:		[:s |		s nextPutAll: 'This package, or the orphanage is looking for the following classes:'; cr.		requirements do: [:ea | s space; space; nextPutAll: ea; cr].		s nextPutAll: 'These definitions will be orphaned until the classes are loaded: '; cr.		unloadableDefinitions do: [:ea | s space; space; nextPutAll: (ea summary, ea because); cr]] ! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/15/2007 12:53'!errorDefinitionWarning: erroredDefns	^ String streamContents:		[:s |		s nextPutAll: 'The following definitions had errors while loading.  Press Proceed to try to load them again (they may work on a second pass):'; cr.		erroredDefns do: [:ea | 			s space; space; 			  nextPutAll: ea summary;			  space; 			  nextPutAll: (ea because ifNil: [ '' ]); cr]] ! !!MCPackageLoader2 methodsFor: 'private' stamp: 'cwp 11/13/2003 02:01'!flushChangesFile	"The changes file is second in the SourceFiles array"	(SourceFiles at: 2) flush! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 7/4/2007 05:28'!initialize	additions := OrderedCollection new.	removals := OrderedCollection new.	obsoletions := Dictionary new.! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/15/2007 12:12'!installOrphanage	self orphanage loading: self.! !!MCPackageLoader2 methodsFor: 'public' stamp: 'kph 5/11/2007 07:28'!installSnapshot: aSnapshot	| patch |	patch := aSnapshot patchRelativeToBase: MCSnapshot empty.	patch applyTo: self.	 ! !!MCPackageLoader2 methodsFor: 'patch ops' stamp: 'kph 6/12/2007 09:33'!isMultiplePackage	^ isMultiplePackage == true! !!MCPackageLoader2 methodsFor: 'public' stamp: 'kph 5/15/2007 15:39'!isUnloading 	^ isUnloading ifNil: [ false ]! !!MCPackageLoader2 methodsFor: 'public' stamp: 'kph 5/15/2007 12:13'!load	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useNewChangeSetDuring: [self protectedLoad].	self loadComplete.! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 12/6/2008 02:50'!loadComplete	MCMethodDefinition tidyCache.	self orphanage 		addOrphans: unloadableDefinitions;	 	addOrphans: errorDefinitions;		loadComplete.	self loadFiles.! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 12/6/2008 02:49'!loadFiles	MCMethodDefinition tidyCache.	self orphanage 		addOrphans: unloadableDefinitions;	 	addOrphans: errorDefinitions;		loadComplete.! !!MCPackageLoader2 methodsFor: 'public' stamp: 'kph 5/15/2007 12:26'!loadWithName: baseName 	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useChangeSetNamed: baseName during: [self protectedLoad].	self loadComplete.! !!MCPackageLoader2 methodsFor: 'public' stamp: 'kph 5/15/2007 12:26'!loadWithNameLike: baseName 	self analyze.	unloadableDefinitions isEmpty ifFalse: [self warnAboutDependencies].	self useNewChangeSetNamedLike: baseName during: [self protectedLoad].	self loadComplete.! !!MCPackageLoader2 methodsFor: 'patch ops' stamp: 'avi 2/17/2004 13:14'!modifyDefinition: old to: new	self addDefinition: new.	obsoletions at: new put: old.! !!MCPackageLoader2 methodsFor: 'private' stamp: 'avi 2/17/2004 13:15'!obsoletionFor: aDefinition	^ obsoletions at: aDefinition ifAbsent: [nil]! !!MCPackageLoader2 methodsFor: 'private' stamp: 'ab 5/24/2003 16:52'!orderedAdditions	^ additions! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 4/30/2007 00:39'!orphanage	^ MCOrphanage current! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/26/2007 10:06'!progressBar	^ progressBar ! !!MCPackageLoader2 methodsFor: 'private' stamp: 'mtf 8/6/2008 01:13'!protectedLoad 		[			[				[ self basicLoad ] on: InMidstOfFileinNotification do: [:n | n resume: true]			] ensure: [self flushChangesFile].				]  on: MCOrphanedNotification do: [ :ex | additions remove: ex orphan ifAbsent: [].											errorDefinitions add: ex orphan. 									 		ex resume.					  		] ! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/25/2007 03:43'!provisions	^ provisions ifNil: [provisions := Set withAll: Smalltalk keys]! !!MCPackageLoader2 methodsFor: 'patch ops' stamp: 'ab 5/24/2003 16:14'!removeDefinition: aDefinition	removals add: aDefinition! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/26/2007 09:22'!setProgressBar: aBar	progressBar := aBar! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/4/2007 00:24'!shouldWarnAboutErrors	^ false "should make this a preference"! !!MCPackageLoader2 methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!sorterForItems: aCollection	| sorter |	sorter := MCDependencySorter items: aCollection.	sorter addExternalProvisions: self provisions.	^ sorter! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/10/2007 17:30'!successfullyLoaded: aDefinition	self orphanage successfullyLoaded: aDefinition! !!MCPackageLoader2 methodsFor: 'obsolete' stamp: 'kph 5/22/2007 18:45'!tryToLoad: aDefinition errors: errs 	self tryToLoad: aDefinition errors: errorDefinitions ! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/26/2007 10:02'!unloadPackage: aPackage 	(self 		updatePackage: aPackage withSnapshot: MCSnapshot empty;		beUnloading;		loadWithNameLike: aPackage name, '-unload';		yourself)		orphanage packageUnloaded: aPackage packageInfo.	! !!MCPackageLoader2 methodsFor: 'public' stamp: 'stephaneducasse 2/4/2006 20:47'!updatePackage: aPackage withSnapshot: aSnapshot	|  patch packageSnap |	packageSnap := aPackage snapshot.	patch := aSnapshot patchRelativeToBase: packageSnap.	patch applyTo: self.	packageSnap definitions do: [:ea | self provisions addAll: ea provisions]! !!MCPackageLoader2 methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!useChangeSetNamed: baseName during: aBlock	"Use the named change set, or create one with the given name."	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := (ChangeSorter changeSetNamed: baseName) ifNil: [ ChangeSet new name: baseName ].	changeHolder newChanges: newChanges.	[aBlock value] ensure: [changeHolder newChanges: oldChanges].! !!MCPackageLoader2 methodsFor: 'private' stamp: 'nk 8/30/2004 08:38'!useNewChangeSetDuring: aBlock	^self useNewChangeSetNamedLike: 'MC' during: aBlock! !!MCPackageLoader2 methodsFor: 'private' stamp: 'nk 2/23/2005 07:50'!useNewChangeSetNamedLike: baseName during: aBlock	^self useChangeSetNamed: (ChangeSet uniqueNameLike: baseName) during: aBlock! !!MCPackageLoader2 methodsFor: 'private' stamp: 'ab 5/25/2003 01:22'!warnAboutDependencies 	self notify: self dependencyWarning! !!MCPackageLoader2 methodsFor: 'private' stamp: 'kph 5/4/2007 00:23'!warnAboutErrors: errors	errors isEmpty ifFalse: [ self notify: (self errorDefinitionWarning: errors) ]! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'kph 8/3/2008 04:43' prior: 23427178!allManagers	^ self packageInfos collect:[ :pi | pi manager ifNil: [ self forPackage: (MCPackage named: pi name) ] ]! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/27/2005 14:28' prior: 23427995!classModified: anEvent	self managersForClass: anEvent item do:[:mgr| mgr modified: true].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 21:31' prior: 23428172!classMoved: anEvent	self classModified: anEvent.	self managersForCategory: anEvent oldCategory do:[:mgr| mgr modified: true].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'kph 5/11/2007 03:17' prior: 23428386!classRemoved: anEvent	MCOrphanage current onClassRemoved: anEvent item.	self classModified: anEvent! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'kph 8/3/2008 04:02' prior: 23427317!forPackage: aPackage	^ (PackageInfo named: aPackage name) in: [ :pi | 				pi manager ifNil: [ pi manager: (self new initializeWithPackage: aPackage).							self changed: #allManagers.							pi manager ]				] ! !!MCPackageManager class methodsFor: 'system changes' stamp: 'kph 9/2/2008 04:33' prior: 23428523!managersForCategory: aSystemCategory do: aBlock	"Got to be careful here - we might get method categories where capitalization is problematic."	| cat foundOne index |	foundOne := false.	cat := aSystemCategory ifNil:[^nil]. "yes this happens; for example in eToy projects"	"first ask PackageInfos, their package name might not match the category"	self packageInfos do: [:pi | 		((pi includesSystemCategory: aSystemCategory) and: [ pi manager notNil ])	ifTrue: [			aBlock value: pi manager.			foundOne := true.		]	].	foundOne ifTrue: [^self].	["Loop over categories until we found a matching one"		(self organizer packageNamed: cat ifAbsent: nil) ifNotNilDo:[:pi |		aBlock value: pi manager.		foundOne := true.	].	index := cat lastIndexOf: $-.	index > 0]whileTrue:[		"Step up to next level package"		cat := cat copyFrom: 1 to: index-1.	].	foundOne ifFalse:[		"Create a new (but only top-level)"		aBlock value: (MCWorkingCopy forPackage: (MCPackage named: (aSystemCategory copyUpTo: $-) capitalized)).	].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/27/2005 14:11' prior: 23429593!managersForClass: aClass category: methodCategory do: aBlock	(methodCategory isEmptyOrNil or:[methodCategory first ~= $*]) ifTrue:[		"Not an extension method"		^self managersForClass: aClass do: aBlock.	].	self managersForCategory: methodCategory allButFirst do: aBlock.! !!MCPackageManager class methodsFor: 'system changes' stamp: 'kph 9/2/2008 04:34' prior: 23429955!managersForClass: aClass do: aBlock	self packageInfos do: [:pi |		((pi includesClass: aClass) and: [ pi manager notNil ])			ifTrue: [aBlock value: pi manager]]! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 21:40' prior: 23430179!managersForClass: aClass selector: aSelector do: aBlock	^self managersForClass: aClass category: (aClass organization categoryOfElement: aSelector) do: aBlock! !!MCPackageManager class methodsFor: 'system changes' stamp: 'kph 2/7/2009 18:25' prior: 23430425!methodModified: anEvent	^ self managersForClass: anEvent itemClass selector: anEvent itemSelector do:[:mgr| mgr modified: true].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 21:40' prior: 23430640!methodMoved: anEvent	self managersForClass: anEvent itemClass category: anEvent oldCategory do:[:mgr| mgr modified: true].	self methodModified: anEvent.! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:12' prior: 23430881!methodRemoved: anEvent	self managersForClass: anEvent itemClass category: anEvent itemProtocol do:[:mgr| mgr modified: true].! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'kph 8/3/2008 04:07'!organizer	^ PackageOrganizer default  ! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'kph 8/3/2008 04:07'!packageInfos	^ self organizer packageInfos! !!MCPackageManager class methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:18' prior: 23431095!registerForNotifications	Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|	(cls uniqueInstance)		noMoreNotificationsFor: self;		notify: self ofSystemChangesOfItem: #class change: #Added using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Modified using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Renamed using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Commented using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Recategorized using: #classMoved:;		notify: self ofSystemChangesOfItem: #class change: #Removed using: #classRemoved:;		notify: self ofSystemChangesOfItem: #method change: #Added using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Modified using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Recategorized using: #methodMoved:;		notify: self ofSystemChangesOfItem: #method change: #Removed using: #methodRemoved:	].! !!MCPackageManager class methodsFor: 'as yet unclassified' stamp: 'kph 9/2/2008 04:05' prior: 23427851!registry	 	"if we have a registry migrate to using PackageOrganizer" 	^ registry	! !!MCPackageManager methodsFor: 'initialize-release' stamp: 'kph 5/10/2007 18:01' prior: 23425008!initialize	modified := false.	 ! !!MCPackageManager methodsFor: 'initialize-release' stamp: 'kph 2/23/2009 06:54' prior: 23425167!initializeWithPackage: aPackage	package := aPackage.	self initialize.! !!MCPackageManager methodsFor: 'accessing' stamp: 'cwp 11/13/2003 14:12' prior: 23424055!modified	^ modified! !!MCPackageManager methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23424163!modified: aBoolean     modified = aBoolean ifTrue: [^ self].	modified := aBoolean.	self changed: #modified.		modified ifFalse:		[(((Smalltalk classNamed: 'SmalltalkImage') ifNotNilDo: [:si | si current]) ifNil: [Smalltalk])			logChange: '"', self packageName, '"'].! !!MCPackageManager methodsFor: 'accessing' stamp: 'ab 7/7/2003 16:47' prior: 23424510!package	^ package! !!MCPackageManager methodsFor: 'accessing' stamp: 'ab 7/7/2003 13:33' prior: 23424603!packageInfo	^ package packageInfo! !!MCPackageManager methodsFor: 'accessing' stamp: 'ab 7/7/2003 12:18' prior: 23424712!packageName	^ package name! !!MCPackageManager methodsFor: 'accessing' stamp: 'ab 7/5/2003 23:18' prior: 23424814!packageNameWithStar	^ modified		ifTrue: ['* ', self packageName]		ifFalse: [self packageName]! !!MCPackageManager methodsFor: 'system changes' stamp: 'ar 4/26/2005 22:17' prior: 23426578!systemChange: anEvent	"obsolete - remove this later"! !!MCPackageManager methodsFor: 'operations' stamp: 'kph 8/3/2008 04:18' prior: 23425316!unregister	self class organizer unregisterPackageNamed: self package name.	self class changed: #allManagers! !!MCPackageManager methodsFor: 'system changes' stamp: 'avi 11/11/2003 12:06' prior: 23426714!update: aSymbol	InMidstOfFileinNotification signal ifFalse: [	[((aSymbol = #recentMethodSubmissions)		and: [self packageInfo				includesMethodReference: Utilities recentMethodSubmissions last])					ifTrue: [self modified: true]]		on: Error do: []]! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'kph 9/3/2008 15:41' prior: 23631985!initialize	Smalltalk 		at: #MczInstaller		ifPresent: [:installer | self adoptVersionInfoFrom: installer].	registry ifNotNil:[registry rehash]. "changed #="	self allInstancesDo:[:each| "moved notifications"		Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			cls uniqueInstance noMoreNotificationsFor: each.		].	].	self registerForNotifications.		registry ifNotNil: [ 		PackageOrganizer forcefullyClearCache.		registry values collect: [ :mgr | mgr package packageInfo manager: mgr  ].		registry := nil.	].! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'kph 11/13/2007 22:55' prior: 23630824!adoptVersionInfoFrom: anInstaller	|viCache|	viCache := Dictionary new.	anInstaller versionInfo keysAndValuesDo: [:packageName :info |			[(self forPackage: (MCPackage named: packageName))			versionInfo: (self infoFromDictionary:  info cache: viCache) ] ifError: ["backwards compat"] ].					[anInstaller clearVersionInfo] on: Error do: ["backwards compat"].! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 01:23' prior: 23631236!ancestorsFromArray: anArray cache: aDictionary	^ anArray ifNotNil: [anArray collect: [:dict | self infoFromDictionary: dict cache: aDictionary]]! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23631482!infoFromDictionary: aDictionary cache: cache	| id |	id := aDictionary at: #id.	^ cache at: id ifAbsentPut:		[MCVersionInfo			name: (aDictionary at: #name)			id: (aDictionary at: #id)			message: (aDictionary at: #message)			date: (aDictionary at: #date)			time: (aDictionary at: #time)			author: (aDictionary at: #author)			ancestors: (self ancestorsFromArray: (aDictionary at: #ancestors) cache: cache)]! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 02:36' prior: 23632500!updateInstVars	self allInstances do: [:ea | ea updateInstVars]! !!MCWorkingCopy methodsFor: 'operations' stamp: 'avi 2/13/2004 01:07' prior: 23624121!adopt: aVersion	ancestry addAncestor: aVersion info.	self changed.! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 01:07' prior: 23622451!ancestors	^ ancestry ancestors! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 01:13' prior: 23622556!ancestry	^ ancestry! !!MCWorkingCopy methodsFor: 'operations' stamp: 'kph 12/7/2008 02:31' prior: 23624264!backportChangesTo: aVersionInfo	| baseVersion fullPatch currentVersionInfo currentVersion newSnapshot newAncestry |	currentVersionInfo := self currentVersionInfo.	baseVersion := self repositoryGroup versionWithInfo: aVersionInfo.	currentVersion := self repositoryGroup versionWithInfo: currentVersionInfo.	fullPatch := currentVersion snapshot patchRelativeToBase: baseVersion snapshot.	(MCChangeSelectionRequest new		patch: fullPatch;		label: 'Changes to Backport';		signal ) ifNotNilDo:		[:partialPatch |		newSnapshot := MCPatcher apply: partialPatch to: baseVersion snapshot.		newAncestry := MCWorkingAncestry new							addAncestor: aVersionInfo;							addStepChild: currentVersionInfo;							yourself.		(MCPackageLoader newCurrent) 			updatePackage: package withSnapshot: newSnapshot;			installOrphanage.					ancestry := newAncestry.		self modified: false; modified: true]! !!MCWorkingCopy methodsFor: 'operations' stamp: 'kph 5/11/2007 05:08'!canBackport	^ true! !!MCWorkingCopy methodsFor: 'operations' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23625204!changesRelativeToRepository: aRepository	| ancestorVersion ancestorSnapshot |	ancestorVersion := aRepository closestAncestorVersionFor: ancestry ifNone: [].	ancestorSnapshot := ancestorVersion ifNil: [MCSnapshot empty] ifNotNil: [ancestorVersion snapshot].	^ package snapshot patchRelativeToBase: ancestorSnapshot! !!MCWorkingCopy methodsFor: 'obsolete' stamp: 'kph 5/19/2007 14:14'!classModified: aMethod	"this is a dummy to enable MC to be loaded in by older MC's who have Working copies registered for events for some reason"	 Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			self class allInstances do: [ :i | 			(cls uniqueInstance) noMoreNotificationsFor: i.		].	].! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23622661!clearRequiredPackages	requiredPackages := nil! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 20:01' prior: 23622781!currentVersionInfo	^ (self needsSaving or: [ancestry ancestors isEmpty])		ifTrue: [self newVersion info]		ifFalse: [ancestry ancestors first]! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 2/13/2004 01:05' prior: 23622999!description	^ self packageNameWithStar, ' (', ancestry ancestorString, ')'! !!MCWorkingCopy methodsFor: 'private' stamp: 'avi 9/24/2004 12:15' prior: 23628724!findSnapshotWithVersionInfo: aVersionInfo	^ aVersionInfo		ifNil: [MCSnapshot empty]		ifNotNil: [(self repositoryGroup versionWithInfo: aVersionInfo) snapshot]! !!MCWorkingCopy methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23628968!initialize	super initialize.	ancestry := MCWorkingAncestry new! !!MCWorkingCopy methodsFor: 'testing' stamp: 'kph 5/13/2007 01:05'!isOrphanage	^ false! !!MCWorkingCopy methodsFor: 'operations' stamp: 'kph 12/13/2008 17:38' prior: 23625607!loaded: aVersion	ancestry := MCWorkingAncestry new addAncestor: aVersion info.	requiredPackages := OrderedCollection withAll: (aVersion dependencies collect: [:ea | ea package]).	self setMyRepositoryFromLastAdded.	self modified: false.	self changed! !!MCWorkingCopy methodsFor: 'operations' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23626053!merge: targetVersion	| ancestorInfo merger ancestorSnapshot packageSnapshot |	targetVersion dependencies do: [:ea | ea resolve merge].	ancestorInfo := targetVersion info commonAncestorWith: ancestry.		ancestorInfo = targetVersion info ifTrue: [^ MCNoChangesException signal].		packageSnapshot := package snapshot.	ancestorSnapshot := ancestorInfo							ifNotNil: [(self findSnapshotWithVersionInfo: ancestorInfo)]							ifNil: [self notifyNoCommonAncestorWith: targetVersion.  MCSnapshot empty].		(ancestry ancestors size = 1		and: [ancestry ancestors first = ancestorInfo]		and: [(packageSnapshot patchRelativeToBase: ancestorSnapshot) isEmpty])				ifTrue: [^ targetVersion load].		merger := MCThreeWayMerger 				base: packageSnapshot				target: targetVersion snapshot				ancestor: ancestorSnapshot.	((MCMergeResolutionRequest new merger: merger)		signal: 'Merging ', targetVersion info name) = true ifTrue:			[merger loadWithNameLike: targetVersion info name.			ancestry addAncestor: targetVersion info].	self changed! !!MCWorkingCopy methodsFor: 'operations' stamp: 'abc 2/13/2004 15:57' prior: 23625899!merged: aVersion	ancestry addAncestor: aVersion info.	self changed! !!MCWorkingCopy methodsFor: 'obsolete' stamp: 'kph 5/19/2007 14:14'!methodModified: aMethod	"this is a dummy to enable MC to be loaded in by older MC's who have Working copies registered for events for some reason"		Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			self class allInstances do: [ :i | 			(cls uniqueInstance) noMoreNotificationsFor: i.		].	].! !!MCWorkingCopy methodsFor: 'obsolete' stamp: 'kph 5/19/2007 14:14'!methodRemoved: aMethod	"this is a dummy to enable MC to be loaded in by older MC's who have Working copies registered for events for some reason"		Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			self class allInstances do: [ :i | 			(cls uniqueInstance) noMoreNotificationsFor: i.		].	].! !!MCWorkingCopy methodsFor: 'menu' stamp: 'kph 2/12/2009 00:39'!myMenu: aMenu inBrowser: browser 	"note these actions are sent to the browser"		browser fillMenu: aMenu fromSpecs:		#(			('add required package' #addRequiredPackage)			('clear required packages' #clearRequiredPackages)			('add repository...' #addPackageRepository)			"('browse package' #browseWorkingCopy)			('view changes' #viewChanges)			('view history' #viewHistory)"			('recompile package' #recompilePackage)			('recompile all packages' #recompileAllPackages)					('memory use for all packages' #viewMemoryUseAll)					('memory use' #viewMemoryUse)					('revert package...' #revertPackage)			('unload package code' #unloadPackage)			('trim ancestry' #trimAncestry)			('ancestry go back one' #ancestryGoBackOne)			('remove package name from list' #deleteWorkingCopy)			('explore working copy' #exploreWorkingCopy)		).	self class selectors select: [ :sel | (sel beginsWith: #myMenu) and: [ sel ~= #myMenu:inBrowser: ]]		thenDo: [ :ea | self perform: ea with: aMenu ].	^ aMenu! !!MCWorkingCopy methodsFor: 'menu' stamp: 'kph 12/11/2008 23:59'!myMenuForSARDumper: aMenu	(Smalltalk classNamed: 'SARMCPackageDumper') ifNotNil: [		aMenu add: 'make SAR' target: self selector: #fileOutAsSAR	].		! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'kph 2/23/2009 00:20' prior: 23623148!needsSaving	^ ((self ancestry size = 0) or: [ self modified ]) or: [self requiredPackages anySatisfy: [:ea | ea workingCopy needsSaving]]! !!MCWorkingCopy methodsFor: 'private' stamp: 'kph 6/29/2007 04:12'!newMcFilenameUUID	| uuid |	uuid := (UUID new asString copyFrom: 1 to: 18) copyWithout: $-! !!MCWorkingCopy methodsFor: 'operations' stamp: 'avi 1/19/2004 16:18' prior: 23627172!newVersion	^ (self requestVersionNameAndMessageWithSuggestion: self uniqueVersionName) ifNotNilDo:		[:pair |		self newVersionWithName: pair first message: pair last].! !!MCWorkingCopy methodsFor: 'operations' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23627428!newVersionWithName: nameString message: messageString	| info deps |	info := ancestry infoWithName: nameString message: messageString.	ancestry := MCWorkingAncestry new addAncestor: info.	self modified: true; modified: false.		deps := self requiredPackages collect:		[:ea | 		MCVersionDependency			package: ea			info: ea workingCopy currentVersionInfo].	^ MCVersion		package: package		info: info		snapshot: package snapshot		dependencies: deps! !!MCWorkingCopy methodsFor: 'private' stamp: 'kph 6/29/2007 03:49'!nextVersionNameHaveAlreadyTried: previousAttempt	 	previousAttempt ifNotNil:[ ^ previousAttempt nextVersion ].	ancestry ancestors isEmpty		ifTrue: [ ^ MCVersionInfo firstVersionForPackage: package name ].	^ ancestry ancestors first nextVersionConsidering: ancestry. ! !!MCWorkingCopy methodsFor: 'operations' stamp: 'avi 2/13/2004 01:07' prior: 23627961!notifyNoCommonAncestorWith: aVersion	self notify:'Could not find a common ancestor between (',aVersion info name,') and (',ancestry ancestorString, ').Proceeding with this merge may cause spurious conflicts.'! !!MCWorkingCopy methodsFor: 'private' stamp: 'bf 9/8/2005 10:58' prior: 23629758!possiblyNewerVersions	^Array streamContents: [:strm |		self repositoryGroup repositories do: [:repo |			strm nextPutAll: (self possiblyNewerVersionsIn: repo)]]! !!MCWorkingCopy methodsFor: 'private' stamp: 'bf 9/8/2005 10:58' prior: 23629991!possiblyNewerVersionsIn: aRepository	^aRepository possiblyNewerVersionsOfAnyOf: self ancestors! !!MCWorkingCopy methodsFor: 'printing' stamp: 'kph 2/14/2007 11:54'!printOn: streamsuper printOn: stream.stream space.self description printOn: stream.! !!MCWorkingCopy methodsFor: 'operations' stamp: 'kph 5/12/2007 01:22'!recompilePackage	self packageInfo methods		do: [:ea | ea actualClass recompile: ea methodSymbol]		displayingProgress: 'Recompiling...'! !!MCWorkingCopy methodsFor: 'repositories' stamp: 'kph 12/8/2008 04:46'!repository	^ repository! !!MCWorkingCopy methodsFor: 'repositories' stamp: 'kph 12/13/2008 17:58'!repository: aRepo	aRepo ifNil: [ ^ self ].	self packageInfo propertyAt: #repository put: aRepo description.			repository := aRepo! !!MCWorkingCopy methodsFor: 'repositories' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23628409!repositoryGroup	^ repositoryGroup ifNil: [repositoryGroup := MCRepositoryGroup new]! !!MCWorkingCopy methodsFor: 'repositories' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23628581!repositoryGroup: aRepositoryGroup	repositoryGroup := aRepositoryGroup! !!MCWorkingCopy methodsFor: 'private' stamp: 'ab 8/24/2003 20:38' prior: 23630158!requestVersionNameAndMessageWithSuggestion: aString	^ (MCVersionNameAndMessageRequest new suggestedName: aString) signal! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'avi 1/20/2004 16:04' prior: 23623497!requirePackage: aPackage	(self requiredPackages includes: aPackage) ifFalse: [requiredPackages add: aPackage]! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23623336!requiredPackages	^ requiredPackages ifNil: [requiredPackages := OrderedCollection new]! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'kph 12/13/2008 18:05'!setMyRepositoryFromLastAdded	self repository: self repositoryGroup lastAdded.! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'kph 2/12/2009 00:48'!trimAncestry	 	self ancestry ancestors do: [ :ea | ea trimAfterVersionInfo: ea ]! !!MCWorkingCopy methodsFor: 'private' stamp: 'kph 1/28/2008 02:23' prior: 23630362!uniqueVersionName	|version | 	 	version := nil.	[version  := self nextVersionNameHaveAlreadyTried: version .	self repositoryGroup includesVersionNamed: version name ] whileTrue.	^ version name! !!MCWorkingCopy methodsFor: 'operations' stamp: 'kph 12/7/2008 02:31' prior: 23628250!unload	MCPackageLoader newCurrent unloadPackage: self package.	self unregister.! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23623692!versionInfo: aVersionInfo	ancestry := MCWorkingAncestry new addAncestor: aVersionInfo! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 05:04'!adopt: aVersion! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 05:03'!backportChangesTo: aVersionInfo! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 05:08'!canBackport	^ false! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 15:40'!description	^ self packageNameWithStar, ' ( ', self package orphans size printString, ' orphans ', (self package unlinkedCount > 0 ifTrue: [ self package unlinkedCount printString, ' unlinked )' ] ifFalse: [ ')' ])! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/13/2007 01:05'!isOrphanage	^ true! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 05:05'!merge: targetVersion! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2007 07:19'!myMenu: aMenu inBrowser: browser	 		browser fillMenu: aMenu fromSpecs:		#(			 			('browse orphans' #browseWorkingCopy) 			('reload orphans' #recompilePackage)			('clearOrphans' 	  #clearOrphans)			('explore orphans' #exploreWorkingCopy)			('recompile all packages' #recompileAllPackages)			('fix all obsolete references' #fixAllObsoleteReferences )).				 	^ aMenu! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/13/2007 00:57'!recompilePackage		"for the orphanage this means attempt to re-home them"		 	self package snapshot install.! !!MCWorkingOrphanage methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 05:04'!unload! !!MCPasswordManager commentStamp: '<historical>' prior: 0!Simple password manager to avoid storing passwords in the image.!!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 15:23'!default	^Default ifNil:[Default := self new]! !!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 16:53'!editPasswords	^self default editPasswords! !!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 16:14'!passwordAt: location user: user	^self default passwordAt: location user: user! !!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 16:14'!passwordAt: location user: user put: password	^self default passwordAt: location user: user put: password! !!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 16:37'!queryPasswordAt: location user: user	^self default queryPasswordAt: location user: user! !!MCPasswordManager methodsFor: 'accessing' stamp: 'bf 11/7/2005 14:58'!directory	"Answer the directory in which to find the passwords"	^directory ifNil:[ExternalSettings assuredPreferenceDirectory]! !!MCPasswordManager methodsFor: 'accessing' stamp: 'ar 11/4/2005 15:01'!directory: aDirectory	"Indicate the directory in which to find the passwords"	directory := aDirectory! !!MCPasswordManager methodsFor: 'editing' stamp: 'ar 11/4/2005 16:48'!editPasswords	"Edit the passwords"	(self directory fileNamesMatching: '*.pwd') do:[:fName|		self editPasswordsIn: (self directory fullNameFor: fName).	].! !!MCPasswordManager methodsFor: 'editing' stamp: 'ar 11/4/2005 16:53'!editPasswordsIn: pwdFile	"Edit the passwords"	| file data |	file := FileStream readOnlyFileNamed: pwdFile.	data := file contents.	file close.	UIManager default edit: data label: pwdFile accept:[:text|		file := FileStream forceNewFileNamed: pwdFile.		file nextPutAll: text asString.		file close.	].! !!MCPasswordManager methodsFor: 'queries' stamp: 'ar 11/4/2005 17:14'!passwordAt: location user: user	"Answer the password stored under the given key, or nil if none can be found"	| file stream tokens pwdFile |	(location indexOf: Character space) = 0 		ifFalse:[^self error: 'Location must not contain spaces'].	(user indexOf: Character space) = 0 		ifFalse:[^self error: 'User name must not contain spaces'].	pwdFile := user,'.pwd'.	file := [self directory readOnlyFileNamed: pwdFile] on: Error do:[:ex| ex return: nil].	file ifNil:[^nil].	[stream := file contents readStream] ensure:[file close].	[stream atEnd] whileFalse:[		tokens := stream nextLine findTokens: ' '.		(tokens size = 2 and:[tokens first match: location]) ifTrue:[			^(Base64MimeConverter mimeDecode: tokens last as: String)		].	].	^nil! !!MCPasswordManager methodsFor: 'queries' stamp: 'kph 6/3/2008 11:36'!passwordAt: location user: user put: password	"Store the password under the given key"	| file tokens pwd in out done sz pwdFile |	user ifNil:[ ^ self ].	(location indexOf: Character space) = 0 		ifFalse:[^self error: 'Key must not contain spaces'].	(user indexOf: Character space) = 0 		ifFalse:[^self error: 'Key must not contain spaces'].	password ifNotNil:[		pwd := (Base64MimeConverter mimeEncode: password readStream) contents.	].	pwdFile := user,'.pwd'.	file := [self directory readOnlyFileNamed: pwdFile] on: Error do:[:ex| ex return: nil].	file ifNotNil:[		[in := file contents readStream] ensure:[file close].	] ifNil:[in := String new readStream].	out := WriteStream on: (String new: 1000).	done := pwd == nil. "if clearing passwords, we're done already"	[in atEnd] whileFalse:[		tokens := in nextLine findTokens: ' '.		tokens size = 2 ifTrue:[			(tokens first match: location) 				ifTrue:[pwd ifNotNil:[out nextPutAll: location; space; nextPutAll: pwd; cr. done := true]]				ifFalse:[out nextPutAll: tokens first; space; nextPutAll: tokens last; cr]]].	done ifFalse:[out nextPutAll: location; space; nextPutAll: pwd; cr].	file := [self directory forceNewFileNamed: pwdFile] on: Error do:[:ex| ex return: nil].	file ifNil:[^nil].	[file nextPutAll: out contents.	sz := file size] ensure:[file close].	sz = 0 ifTrue:[self directory deleteFileNamed: pwdFile ifAbsent:[]].! !!MCPasswordManager methodsFor: 'queries' stamp: 'kph 12/19/2007 00:18'!queryPasswordAt: location user: user	"Answer the password for the given user/location. 	If the password is absent, query the user if interactive."	| pwd |	"search for existing password" 	pwd := self passwordAt: location user: user.	pwd ifNotNil:[^pwd].	user = 'squeak' ifTrue: [ ^ 'squeak' ].	user = '' ifTrue: [ ^ 'squeak' ].	pwd := FillInTheBlank requestPassword: 'Password for "', user, '" at ', location.	pwd isEmptyOrNil ifTrue:[^nil].	(self confirm: 'Remember password for "', user, '" at ', location,'?') ifTrue:[		self passwordAt: location user: user put: pwd.	].	^pwd	 ! !!MCPatch class methodsFor: 'as yet unclassified' stamp: 'mtf 10/7/2008 13:01' prior: 23434440!fromBase: baseSnapshot target: targetSnapshot	^ self new initializeWithBase: baseSnapshot definitionIndex		target: targetSnapshot definitionIndex! !!MCPatch class methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 15:50' prior: 23434637!operations: aCollection	^ self basicNew initializeWithOperations: aCollection! !!MCPatch methodsFor: 'applying' stamp: 'ab 5/24/2003 16:12' prior: 23433129!applyTo: anObject	operations do: [:ea | ea applyTo: anObject].! !!MCPatch methodsFor: 'ui' stamp: 'cwp 8/2/2003 13:34' prior: 23434208!browse	^ (MCPatchBrowser forPatch: self) show! !!MCPatch methodsFor: 'intializing' stamp: 'mtf 10/7/2008 11:39' prior: 23433275!initializeWithBase: base target: target"Generates operation from the given MCDefinitionIndexes"	operations := OrderedCollection new.		target definitions do:		[:t |		base			definitionLike: t			ifPresent: [:b | (b isSameRevisionAs: t) ifFalse: [operations add: (MCModification of: b to: t)]]			ifAbsent: [operations add: (MCAddition of: t)]]		displayingProgress: 'Diffing...'.			base definitions do:		[:b |		target			definitionLike: b			ifPresent: [:t]			ifAbsent: [operations add: (MCRemoval of: b)]]		! !!MCPatch methodsFor: 'intializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23433987!initializeWithOperations: aCollection	operations := aCollection! !!MCPatch methodsFor: 'querying' stamp: 'cwp 6/9/2003 11:53' prior: 23434118!isEmpty	^ operations isEmpty! !!MCPatch methodsFor: 'accessing' stamp: 'ab 5/13/2003 12:18' prior: 23433038!operations	^ operations! !!MCAddition class methodsFor: 'as yet unclassified' stamp: 'cwp 11/27/2002 10:03' prior: 23200218!of: aDefinition	^ self new intializeWithDefinition: aDefinition! !!MCAddition methodsFor: 'accessing' stamp: 'ab 5/24/2003 16:11' prior: 23198670!applyTo: anObject	anObject addDefinition: definition! !!MCAddition methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:09' prior: 23198792!baseDefinition	^ nil! !!MCAddition methodsFor: 'accessing' stamp: 'cwp 11/27/2002 09:32' prior: 23198885!definition	^ definition! !!MCAddition methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:45' prior: 23198979!fromSource	^ ''! !!MCAddition methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23199873!intializeWithDefinition: aDefinition	definition := aDefinition! !!MCAddition methodsFor: 'as yet unclassified' stamp: 'ab 8/22/2003 02:26' prior: 23199629!inverse	^ MCRemoval of: definition! !!MCAddition methodsFor: 'testing' stamp: 'cwp 11/28/2002 07:22' prior: 23200007!isAddition	^ true! !!MCAddition methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 17:28' prior: 23199744!isClassPatch	^definition isClassDefinition! !!MCAddition methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:39' prior: 23199065!sourceString	^(self toSource asText)		addAttribute: TextColor red;		yourself! !!MCAddition methodsFor: 'accessing' stamp: 'ab 5/13/2003 12:18' prior: 23199214!summary	^ definition summary! !!MCAddition methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:17' prior: 23199313!targetClass	^definition actualClass ! !!MCAddition methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:09' prior: 23199419!targetDefinition	^ definition! !!MCAddition methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:45' prior: 23199519!toSource	^ definition source! !!MCModification class methodsFor: 'as yet unclassified' stamp: 'cwp 11/28/2002 07:19' prior: 23406434!of: base to: target	^ self new initializeWithBase: base target: target! !!MCModification methodsFor: 'accessing' stamp: 'ab 5/24/2003 16:12' prior: 23404290!applyTo: anObject	anObject modifyDefinition: obsoletion to: modification! !!MCModification methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:10' prior: 23404436!baseDefinition	^ obsoletion! !!MCModification methodsFor: 'accessing' stamp: 'cwp 11/28/2002 06:55' prior: 23404540!definition	^ modification! !!MCModification methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:44' prior: 23404640!fromSource	^ obsoletion source! !!MCModification methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23406051!initializeWithBase: base target: target	obsoletion := base.	modification := target.! !!MCModification methodsFor: 'as yet unclassified' stamp: 'ab 8/22/2003 02:27' prior: 23405478!inverse	^ MCModification of: modification to: obsoletion! !!MCModification methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 17:29' prior: 23405619!isClassPatch	^obsoletion isClassDefinition! !!MCModification methodsFor: 'testing' stamp: 'cwp 11/28/2002 07:23' prior: 23406211!isModification	^ true! !!MCModification methodsFor: 'accessing' stamp: 'cwp 11/27/2002 09:46' prior: 23404747!modification	^ modification! !!MCModification methodsFor: 'accessing' stamp: 'cwp 11/27/2002 09:48' prior: 23404851!obsoletion	^ obsoletion! !!MCModification methodsFor: 'as yet unclassified' stamp: 'nk 11/10/2003 21:44' prior: 23405747!printAnnotations: request on: aStream	aStream nextPutAll: 'old: '.	obsoletion printAnnotations: request on: aStream.	aStream cr.	aStream nextPutAll: 'new: '.	modification printAnnotations: request on: aStream.! !!MCModification methodsFor: 'accessing' stamp: 'nk 10/21/2003 22:54' prior: 23404950!summarySuffix	^self fromSource = self toSource		ifTrue: [ ' (source same but rev changed)' ]		ifFalse: [ ' (changed)' ]! !!MCModification methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:18' prior: 23405146!targetClass	^ obsoletion actualClass! !!MCModification methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:10' prior: 23405256!targetDefinition	^ modification! !!MCModification methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:44' prior: 23405362!toSource	^ modification source! !!MCPatchOperation methodsFor: 'comparing' stamp: 'ab 7/19/2003 18:11' prior: 23442772!<= other	^ self definition <= other definition! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 11/10/2003 21:38' prior: 23440183!annotations	^self annotations: Preferences defaultAnnotationRequests! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 11/10/2003 21:39' prior: 23440329!annotations: requests	"Answer a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	^String streamContents: [ :s | self printAnnotations: requests on: s ].! !!MCPatchOperation methodsFor: 'accessing' stamp: 'cwp 11/28/2002 06:59' prior: 23440787!definition	^ self subclassResponsibility ! !!MCPatchOperation methodsFor: 'accessing' stamp: 'cwp 11/27/2002 09:26' prior: 23440907!inverse	self subclassResponsibility! !!MCPatchOperation methodsFor: 'testing' stamp: 'cwp 11/27/2002 09:30' prior: 23442896!isAddition	^ false! !!MCPatchOperation methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 17:28' prior: 23442548!isClassPatch	^false! !!MCPatchOperation methodsFor: 'testing' stamp: 'cwp 11/27/2002 09:30' prior: 23442991!isModification	^ false! !!MCPatchOperation methodsFor: 'testing' stamp: 'cwp 11/27/2002 09:30' prior: 23443090!isRemoval	^ false! !!MCPatchOperation methodsFor: 'accessing' stamp: 'avi 8/31/2003 17:53' prior: 23441020!prefixForOperation: aSymbol	aSymbol == #insert ifTrue: [^ '+'].	aSymbol == #remove ifTrue: [^ '-'].	^ ' '! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 11/10/2003 21:40' prior: 23441205!printAnnotations: requests on: aStream	"Add a string for an annotation pane, trying to fulfill the annotation requests.	These might include anything that		Preferences defaultAnnotationRequests 	might return. Which includes anything in		Preferences annotationInfo	To edit these, use:"	"Preferences editAnnotations"	self definition printAnnotations: requests on: aStream.! !!MCPatchOperation methodsFor: 'accessing' stamp: 'avi 8/31/2003 17:55' prior: 23441660!source	^ self sourceText! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 2/25/2005 17:26' prior: 23441761!sourceString	^self sourceText asString! !!MCPatchOperation methodsFor: 'accessing' stamp: 'nk 2/25/2005 17:29' prior: 23441876!sourceText	| builder |	builder := (Preferences diffsWithPrettyPrint and: [ self targetClass notNil and: [ self isClassPatch not ] ])				ifTrue: 					[PrettyTextDiffBuilder 						from: self fromSource						to: self toSource						inClass: self targetClass]				ifFalse: [TextDiffBuilder from: self fromSource to: self toSource].	^builder buildDisplayPatch.! !!MCPatchOperation methodsFor: 'accessing' stamp: 'ab 7/6/2003 00:06' prior: 23442313!summary	^ self definition summary, self summarySuffix! !!MCPatchOperation methodsFor: 'accessing' stamp: 'ab 7/6/2003 00:06' prior: 23442442!summarySuffix	^ ''! !!MCPatchOperation methodsFor: 'as yet unclassified' stamp: 'nk 2/23/2005 18:17' prior: 23442654!targetClass	self subclassResponsibility.! !!MCRemoval class methodsFor: 'as yet unclassified' stamp: 'cwp 11/27/2002 10:03' prior: 23451312!of: aDefinition	^ self new intializeWithDefinition: aDefinition! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 5/24/2003 16:11' prior: 23449623!applyTo: anObject	anObject removeDefinition: definition! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:10' prior: 23449747!baseDefinition	^ definition! !!MCRemoval methodsFor: 'accessing' stamp: 'cwp 11/27/2002 10:02' prior: 23449846!definition	^ definition! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:44' prior: 23449939!fromSource	^ definition source! !!MCRemoval methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23450971!intializeWithDefinition: aDefinition	definition := aDefinition! !!MCRemoval methodsFor: 'as yet unclassified' stamp: 'ab 8/22/2003 02:26' prior: 23450728!inverse	^ MCAddition of: definition! !!MCRemoval methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 17:28' prior: 23450843!isClassPatch	^definition isClassDefinition! !!MCRemoval methodsFor: 'testing' stamp: 'cwp 11/28/2002 07:24' prior: 23451104!isRemoval	^ true! !!MCRemoval methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:38' prior: 23450039!sourceString	^self fromSource asText		addAttribute: TextEmphasis struckOut;		addAttribute: TextColor blue;		yourself! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 5/13/2003 12:22' prior: 23450228!summary	^ definition summary, ' (removed)'! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 7/6/2003 00:05' prior: 23450339!summarySuffix	^ ' (removed)'! !!MCRemoval methodsFor: 'accessing' stamp: 'nk 2/25/2005 17:23' prior: 23450437!targetClass	^ definition actualClass! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 6/1/2003 13:10' prior: 23450542!targetDefinition	^ nil! !!MCRemoval methodsFor: 'accessing' stamp: 'ab 7/18/2003 16:44' prior: 23450634!toSource	^ ''! !!MCPatcher class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23445269!apply: aPatch to: aSnapshot	| loader |	loader := self snapshot: aSnapshot.	aPatch applyTo: loader.	^ loader patchedSnapshot! !!MCPatcher class methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 14:22' prior: 23445480!snapshot: aSnapshot	^ self new initializeWithSnapshot: aSnapshot! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:46' prior: 23444362!addDefinition: aDefinition	definitions add: aDefinition! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23444509!initializeWithSnapshot: aSnapshot	definitions := MCDefinitionIndex definitions: aSnapshot definitions! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'ab 6/1/2003 14:23' prior: 23444689!modifyDefinition: baseDefinition to: targetDefinition	self addDefinition: targetDefinition! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'ab 7/6/2003 23:48' prior: 23444858!patchedSnapshot	^ MCSnapshot fromDefinitions: definitions definitions! !!MCPatcher methodsFor: 'as yet unclassified' stamp: 'ab 6/2/2003 00:46' prior: 23445006!removeDefinition: aDefinition	definitions remove: aDefinition! !!MCReader class methodsFor: 'testing' stamp: 'avi 1/21/2004 19:00' prior: 23448878!canReadFileNamed: fileName	^ (fileName endsWith: self extension)! !!MCReader class methodsFor: 'testing' stamp: 'avi 1/21/2004 19:01' prior: 23449016!concreteSubclasses	^ self allSubclasses reject: [:c | c isAbstract]! !!MCReader class methodsFor: 'testing' stamp: 'avi 1/21/2004 19:01' prior: 23449157!isAbstract	^ (self respondsTo: #extension) not! !!MCReader class methodsFor: 'instance creation' stamp: 'avi 1/21/2004 19:02' prior: 23448484!on: aStream	^ self new stream: aStream! !!MCReader class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23448617!on: aStream name: aFileName	| class |	class := self readerClassForFileNamed: aFileName.	^ class		ifNil: [self error: 'Unsupported format: ', aFileName]		ifNotNil: [class on: aStream]! !!MCReader class methodsFor: 'testing' stamp: 'avi 1/21/2004 19:03' prior: 23449277!readerClassForFileNamed: fileName	^ self concreteSubclasses		detect: [:c | c canReadFileNamed: fileName]		ifNone: [nil]! !!MCReader methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23448070!stream: aStream	stream := aStream! !!MCSnapshotReader class methodsFor: 'as yet unclassified' stamp: 'avi 1/21/2004 22:56' prior: 23515630!snapshotFromStream: aStream	^ (self on: aStream) snapshot! !!MCSnapshotReader methodsFor: 'as yet unclassified' stamp: 'avi 1/21/2004 23:09' prior: 23515213!definitions	definitions ifNil: [self loadDefinitions].	^ definitions! !!MCSnapshotReader methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:21' prior: 23515370!snapshot	snapshot ifNil: [self loadSnapshot].	^ snapshot! !!MCCsReader commentStamp: 'abc 7/4/2007 01:25' prior: 0!In order to designate a changeset for loading with Monticello use the extension .mcs Monticello does not execute preambles or postscripts.!!MCCsReader class methodsFor: 'as yet unclassified' stamp: 'abc 7/4/2007 01:17'!extension	^ 'mcs'! !!MCStReader class methodsFor: 'as yet unclassified' stamp: 'avi 1/20/2004 00:17' prior: 23525402!extension	^ 'st'! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 12:52' prior: 23520676!addDefinitionsFromDoit: aString	(MCDoItParser forDoit: aString) ifNotNilDo:		[:parser |		parser addDefinitionsTo: definitions]! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23520897!categoryFromDoIt: aString	| tokens  |	tokens := Scanner new scanTokens: aString.	tokens size = 3 ifFalse: [self error: 'Unrecognized category definition'].	^ tokens at: 3! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23521163!classDefinitionFrom: aPseudoClass	| tokens traitCompositionString lastIndex classTraitCompositionString |	tokens := Scanner new scanTokens: aPseudoClass definition.	traitCompositionString := ((ReadStream on: aPseudoClass definition)		match: 'uses:';		upToAll: 'instanceVariableNames:') withBlanksTrimmed.	classTraitCompositionString := ((ReadStream on: aPseudoClass metaClass definition asString)		match: 'uses:';		upToAll: 'instanceVariableNames:') withBlanksTrimmed.	traitCompositionString isEmpty ifTrue: [traitCompositionString := '{}'].	classTraitCompositionString isEmpty ifTrue: [classTraitCompositionString := '{}'].	lastIndex := tokens size.	^ MCClassDefinition		name: (tokens at: 3)		superclassName: (tokens at: 1)		traitComposition: traitCompositionString		classTraitComposition: classTraitCompositionString		category: (tokens at: lastIndex)		instVarNames: ((tokens at: lastIndex - 6) findTokens: ' ')		classVarNames: ((tokens at: lastIndex - 4) findTokens: ' ')		poolDictionaryNames: ((tokens at: lastIndex - 2) findTokens: ' ')		classInstVarNames: (self classInstVarNamesFor: aPseudoClass)		type: (self typeOfSubclass: (tokens at: 2))		comment: (self commentFor: aPseudoClass)		commentStamp: (self commentStampFor: aPseudoClass)! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23522520!classInstVarNamesFor: aPseudoClass	| tokens |		self flag: #traits.	aPseudoClass metaClass hasDefinition ifFalse: [^ #()].	tokens := Scanner new scanTokens: aPseudoClass metaClass definition.	"tokens size = 4 ifFalse: [self error: 'Unrecognized metaclass definition']."	^ tokens last findTokens: ' '! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23522917!commentFor: aPseudoClass	| comment |	comment := aPseudoClass organization classComment.	^ comment asString = ''		ifTrue: [comment]		ifFalse: [comment string]! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23523171!commentStampFor: aPseudoClass	| comment |	comment := aPseudoClass organization classComment.	^  [comment stamp] on: MessageNotUnderstood do: [nil]! !!MCStReader methodsFor: 'evaluating' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23524559!loadDefinitions	| filePackage |	filePackage :=		FilePackage new			fullName: 'ReadStream';			fileInFrom: self readStream.	definitions := OrderedCollection new.	filePackage classes do:		[:pseudoClass |		pseudoClass hasDefinition			ifTrue: [definitions add:					(self classDefinitionFrom: pseudoClass)].		definitions addAll: (self methodDefinitionsFor: pseudoClass).		definitions addAll: (self methodDefinitionsFor: pseudoClass metaClass)].	filePackage doIts do:		[:ea |		self addDefinitionsFromDoit: ea string].	! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'avi 3/3/2004 15:23' prior: 23523400!methodDefinitionsFor: aPseudoClass	^ aPseudoClass selectors collect: 		[:ea |		 MCMethodDefinition			className: aPseudoClass name			classIsMeta: aPseudoClass isMeta			selector: ea			category: (aPseudoClass organization categoryOfElement: ea)			timeStamp: (aPseudoClass stampAt: ea)			source: (aPseudoClass sourceCodeAt: ea)]! !!MCStReader methodsFor: 'evaluating' stamp: 'avi 1/21/2004 14:21' prior: 23525158!readStream	^ ('!!!!', stream contents) readStream! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23523825!systemOrganizationFromRecords: changeRecords	| categories |	categories := changeRecords					select: [:ea | 'SystemOrganization*' match: ea string]					thenCollect: [:ea | (self categoryFromDoIt: ea string)].	^ categories isEmpty ifFalse: [MCOrganizationDefinition categories: categories asArray]! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'avi 1/19/2004 21:56' prior: 23524206!typeOfSubclass: aSymbol	#(		(subclass: normal)		(variableSubclass: variable)		(variableByteSubclass: bytes)		(variableWordSubclass: words)		(weakSubclass: weak)		) do: [:ea | ea first = aSymbol ifTrue: [^ ea second]].	self error: 'Unrecognized class definition'! !!MCVersionReader class methodsFor: 'file services' stamp: 'kph 2/11/2009 16:12' prior: 23610001!initialize	"MCVersionReader initialize"	Smalltalk 		at: #MczInstaller		ifPresent: [:installer | FileList unregisterFileReader: installer].	self freeSomeSpace.! !!MCMcmReader class methodsFor: 'instance creation' stamp: 'kph 2/11/2009 18:50'!initialize	self register! !!MCMcmReader class methodsFor: 'accessing' stamp: 'bf 3/22/2005 10:47' prior: 23350425!extension	^ 'mcm'! !!MCMcmReader class methodsFor: 'instance creation' stamp: 'kph 8/2/2007 02:38'!loadVersionFile: fileName 	(self versionFromFile: fileName) load! !!MCMcmReader class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23350541!on: aStream fileName: aFileName	| reader |	reader := self on: aStream.	reader fileName: aFileName.	^reader! !!MCMcmReader class methodsFor: 'instance creation' stamp: 'kph 8/2/2007 02:22'!versionFromFile: fileName	^ self file: fileName streamDo: [:aStream | (self on: aStream fileName: fileName) version ]! !!MCMcmReader methodsFor: 'accessing' stamp: 'kph 8/1/2007 12:25'!browseVersionFrom: aRepository	self version browse! !!MCMcmReader methodsFor: 'accessing' stamp: 'bf 3/23/2005 01:17' prior: 23349813!configurationName	^fileName ifNotNil: [(fileName findTokens: '/\:') last copyUpToLast: $.]! !!MCMcmReader methodsFor: 'accessing' stamp: 'bf 3/23/2005 01:17' prior: 23349975!fileName: aString	fileName := aString! !!MCMcmReader methodsFor: 'accessing' stamp: 'kph 8/1/2007 02:11'!info	^ self  ! !!MCMcmReader methodsFor: 'accessing' stamp: 'kph 8/1/2007 12:16'!loadVersionFrom: aRepository	self version load! !!MCMcmReader methodsFor: 'accessing' stamp: 'kph 8/1/2007 12:54'!mergeVersionFrom: aRepository	self version merge! !!MCMcmReader methodsFor: 'accessing' stamp: 'kph 8/1/2007 02:13'!summary	| s |		s := 'Monticello Configuration: ', fileName, '', (self version summary).	stream reset.	^ s! !!MCMcmReader methodsFor: 'accessing' stamp: 'kph 8/1/2007 02:06' prior: 23350084!version	| configuration |	stream reset.	configuration := MCConfiguration fromArray: (MCScanner scan: stream).	configuration name: self configurationName.	^configuration! !!MCMcmReader methodsFor: 'MonticelloConfigurations' stamp: 'mtf 10/8/2008 00:16'!versionFromFile: fileName	^ self file: fileName streamDo: [:aStream | (self on: aStream fileName: fileName) version ]! !!MCMczReader class methodsFor: 'accessing' stamp: 'kph 2/11/2009 18:50'!initialize		self register! !!MCMcdReader class methodsFor: 'as yet unclassified' stamp: 'kph 2/11/2009 18:50'!initialize		self register! !!MCMcdReader class methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:09' prior: 23347816!extension	^ 'mcd'! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'avi 2/14/2004 21:33' prior: 23346191!baseInfo	^ baseInfo ifNil: [self loadBaseInfo]! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:41' prior: 23346320!basicVersion	^ MCDiffyVersion		package: self package		info: self info		dependencies: self dependencies		baseInfo: self baseInfo		patch: self patch! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'avi 2/14/2004 21:37' prior: 23346554!buildPatchFrom: oldDefinitions to: newDefinitions	^ MCPatch		fromBase: (MCSnapshot fromDefinitions: oldDefinitions)		target: (MCSnapshot fromDefinitions: newDefinitions)! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23346819!loadBaseInfo	^ baseInfo := self extractInfoFrom: (self parseMember: 'base')! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23346988!loadPatch	| old new |	(self zip memberNamed: 'patch.bin') ifNotNilDo:		[:m | [^ patch := (DataStream on: m contentStream) next ]			on: Error do: [:fallThrough ]].	definitions := OrderedCollection new.	(self zip membersMatching: 'old/*')		do: [:m | self extractDefinitionsFrom: m].	old := definitions asArray.	definitions := OrderedCollection new.	(self zip membersMatching: 'new/*')		do: [:m | self extractDefinitionsFrom: m].	new := definitions asArray.	^ patch := self buildPatchFrom: old to: new.	! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'avi 2/14/2004 21:34' prior: 23347584!patch	^ patch ifNil: [self loadPatch]! !!MCMczReader class methodsFor: 'accessing' stamp: 'cwp 8/1/2003 14:59' prior: 23358315!extension	^ 'mcz'! !!MCMczReader class methodsFor: 'testing' stamp: 'avi 1/19/2004 14:48' prior: 23358410!supportsDependencies	^ true! !!MCMczReader class methodsFor: 'testing' stamp: 'cwp 8/1/2003 12:19' prior: 23358513!supportsVersions	^ true! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23354947!associate: tokens	| result |	result := Dictionary new.	tokens pairsDo: [:key :value | 					value isString ifFalse: [value := value collect: [:ea | self associate: ea]].					result at: key put: value].	^ result! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 02:25'!basicVersion	| v |		v := super basicVersion.		self loadFiles.		^ v ! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 1/16/2009 13:36' prior: 23355255!extractDefinitionsFrom: member	| reader |	(MCSnapshotReader readerClassForFileNamed: member fileName)		ifNotNilDo: [:rc | reader := rc on: member contentStream text.					snapshot definitions addAll: reader definitions]! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'avi 1/19/2004 16:11' prior: 23355551!extractDependencyFrom: zipMember	^ MCVersionDependency		package: (MCPackage named: (zipMember fileName copyAfterLast: $/))		info: (self extractInfoFrom: (self parseMember: zipMember fileName))! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 00:54'!extractFileFrom: member	definitions add: (MCFileDefinition new 		path: member fileName;		uuid: ((member fileName readStream upTo: $/; yourself) upTo: $/);		fileSize: member uncompressedSize;		yourself)! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'mtf 1/18/2008 10:11' prior: 23355828!extractInfoFrom: dict	^ self infoCache at: (dict at: #id) ifAbsentPut:		[MCVersionInfo			name: (dict at: #name ifAbsent: [''])			id: (UUID fromString: (dict at: #id))			message: (dict at: #message ifAbsent: [''])			date: ([Date fromString: (dict at: #date) ] on: Error do: [ :ex | ex return: nil ])			time: ([ Time fromString:(dict at: #time)] on: Error do: [ :ex | ex return: nil ])			author: (dict at: #author ifAbsent: [''])			ancestors: (dict at: #ancestors ifPresent: [:ancestors |				ancestors collect: [:ea | self extractInfoFrom: ea]])			stepChildren: ((dict at: #stepChildren ifAbsent: [#()]) collect: [:ea | self extractInfoFrom: ea])]! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23356539!infoCache	^ infoCache ifNil: [infoCache := Dictionary new]! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 00:56' prior: 23356691!loadDefinitions	definitions := self snapshot definitions! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23357103!loadDependencies	dependencies := (self zip membersMatching: 'dependencies/*') collect: [:m | self extractDependencyFrom: m].	dependencies := dependencies asArray.! !!MCMczReader methodsFor: 'files' stamp: 'kph 12/7/2008 01:00'!loadFiles	| dir |	dir := MCFileDefinition cacheDir.		^ (self zip membersMatching: 'files/*') collect: [:m | m extractInDirectory: dir. m localFileName ].! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 00:01' prior: 23357361!loadPackage	| dict |	dict := self parseMember: 'package'.	package := MCPackage named: (dict at: #name)! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 1/16/2009 13:36'!loadSnapshot 	(self zip memberNamed: 'snapshot.bin') ifNotNilDo:		[:m | [^ snapshot := (DataStream on: m contentStream) next ] 			on: Error do: [:fallThrough |  self halt ]].		snapshot := MCSnapshot empty.		"otherwise"	(self zip membersMatching: 'snapshot/*')		do: [:m | self extractDefinitionsFrom: m].	(self zip membersMatching: 'files/*')		do: [:m | self extractFileFrom: m].! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23357559!loadVersionInfo	info := self extractInfoFrom: (self parseMember: 'version')! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23357728!parseMember: fileName	| tokens |	tokens := (self scanner scanTokens: (self zip contentsOf: fileName)) first.	^ self associate: tokens! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:33' prior: 23357946!scanner	^ MCScanner! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'kph 12/6/2008 05:24'!snapshot	snapshot ifNil: [self loadSnapshot].	^ snapshot! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23358059!zip	zip ifNil:		[zip := ZipArchive new.		zip readFrom: stream].	^ zip! !!MCVersionReader class methodsFor: 'reading' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23611479!file: fileName streamDo: aBlock	| file |	^ 	[file := FileStream readOnlyFileNamed: fileName.		aBlock value: file]			ensure: [file close]! !!MCVersionReader class methodsFor: 'file services' stamp: 'avi 10/15/2003 02:01' prior: 23609724!fileReaderServicesForFile: fullName suffix: suffix	self isAbstract ifTrue: [^ #()].	^ ((suffix = self extension) or: [ suffix = '*' ])		ifTrue: [self services]		ifFalse: [Array new: 0]		! !!MCVersionReader class methodsFor: 'file services' stamp: 'kph 2/11/2009 16:11'!freeSomeSpace	"get rid of AnObsoleteMCMcReader and AnObsoleteMCMcvReader"	(FileList registeredFileReaderClasses  select: [ :ea | ea isObsolete ]) do: 		[ :ea | FileList unregisterFileReader: ea ]! !!MCVersionReader class methodsFor: 'file services' stamp: 'kph 8/16/2007 17:43'!installFileNamed: filename "this method makes invocation of MczInstaller and MczReader similar" "fix for mc < 1.5" ^ self loadVersionFile: filename! !!MCVersionReader class methodsFor: 'file services' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23610505!loadVersionFile: fileName	| version |	version := self versionFromFile: fileName.	version workingCopy repositoryGroup addRepository:		(MCDirectoryRepository new directory:			(FileDirectory on: (FileDirectory dirPathFor: fileName))).	version load.! !!MCVersionReader class methodsFor: 'file services' stamp: 'cwp 8/1/2003 14:46' prior: 23610842!mergeVersionFile: fileName	(self versionFromFile: fileName) merge! !!MCVersionReader class methodsFor: 'reading' stamp: 'bf 3/23/2005 01:20' prior: 23611698!on: s fileName: f	^ self on: s! !!MCVersionReader class methodsFor: 'file services' stamp: 'cwp 8/1/2003 14:46' prior: 23610993!openVersionFile: fileName	(self versionFromFile: fileName) open! !!MCVersionReader class methodsFor: 'reading' stamp: 'kph 2/11/2009 18:50'!register	FileList unregisterFileReader: self; registerFileReader: self.! !!MCVersionReader class methodsFor: 'file services' stamp: 'BEL 2/8/2009 12:59' prior: 23613152!serviceLoadVersion	^ (SimpleServiceEntry		provider: self		label: 'load version'		selector: #loadVersionFile:		description: 'load a package version'		buttonLabel: 'load')! !!MCVersionReader class methodsFor: 'file services' stamp: 'BEL 2/8/2009 13:12' prior: 23613541!serviceMergeVersion	^ (SimpleServiceEntry		provider: self		label: 'merge version'		selector: #mergeVersionFile:		description: 'merge a package version into the image'		buttonLabel: 'merge')! !!MCVersionReader class methodsFor: 'file services' stamp: 'BEL 2/8/2009 13:12' prior: 23613911!serviceOpenVersion	^ (SimpleServiceEntry		provider: self		label: 'open version'		selector: #openVersionFile:		description: 'open a package version'		buttonLabel: 'open')! !!MCVersionReader class methodsFor: 'file services' stamp: 'avi 1/21/2004 22:55' prior: 23611143!services	^ Array 		with: self serviceLoadVersion		with: self serviceMergeVersion		with: self serviceOpenVersion! !!MCVersionReader class methodsFor: 'reading' stamp: 'cwp 7/31/2003 23:03' prior: 23611809!versionFromFile: fileName	^ self file: fileName streamDo: [:stream | self versionFromStream: stream]! !!MCVersionReader class methodsFor: 'reading' stamp: 'avi 1/21/2004 22:58' prior: 23611990!versionFromStream: aStream	^ (self on: aStream) version! !!MCVersionReader class methodsFor: 'reading' stamp: 'avi 1/21/2004 22:59' prior: 23612126!versionInfoFromStream: aStream	^ (self on: aStream) info! !!MCVersionReader methodsFor: 'accessing' stamp: 'avi 1/19/2004 16:52' prior: 23608060!basicVersion	^ MCVersion		package: self package		info: self info		snapshot: self snapshot		dependencies: self dependencies! !!MCVersionReader methodsFor: 'accessing' stamp: 'avi 1/21/2004 23:10' prior: 23608263!definitions	definitions ifNil: [self loadDefinitions].	^ definitions! !!MCVersionReader methodsFor: 'accessing' stamp: 'avi 1/19/2004 14:50' prior: 23608409!dependencies	dependencies ifNil: [self loadDependencies].	^ dependencies! !!MCVersionReader methodsFor: 'accessing' stamp: 'ab 8/20/2003 19:53' prior: 23608558!info	info ifNil: [self loadVersionInfo].	^ info! !!MCVersionReader methodsFor: 'loading' stamp: 'ab 8/20/2003 19:54' prior: 23609131!loadDefinitions	self subclassResponsibility ! !!MCVersionReader methodsFor: 'loading' stamp: 'avi 1/19/2004 14:50' prior: 23609250!loadDependencies	self subclassResponsibility ! !!MCVersionReader methodsFor: 'loading' stamp: 'ab 8/20/2003 19:54' prior: 23609369!loadPackage	self subclassResponsibility ! !!MCVersionReader methodsFor: 'loading' stamp: 'ab 8/20/2003 19:54' prior: 23609483!loadVersionInfo	self subclassResponsibility! !!MCVersionReader methodsFor: 'accessing' stamp: 'ab 8/20/2003 19:53' prior: 23608682!package	package ifNil: [self loadPackage].	^ package! !!MCVersionReader methodsFor: 'accessing' stamp: 'kph 8/2/2007 15:21' prior: 23608811!snapshot 	^ MCSnapshot fromDefinitions: self definitions! !!MCVersionReader methodsFor: 'accessing' stamp: 'avi 10/9/2003 12:38' prior: 23608943!version	^ self basicVersion! !!MCVersionReader class methodsFor: 'file services' stamp: 'cwp 8/1/2003 14:33' prior: 23611343!unload	FileList unregisterFileReader: self ! !!MCRepository commentStamp: 'kph 5/17/2007 14:31' prior: 0!MCRepository subclasses appear in the UI list of avaiable repository types if they return #description.!!MCRepository class methodsFor: 'class initialization' stamp: 'ar 11/4/2005 17:30' prior: 23458808!initialize	"self initialize"	ExternalSettings registeredClients remove: self ifAbsent:[].! !!MCDictionaryRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 12:29'!description^ 'In Memory Cache'! !!MCDictionaryRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 12:44'!morphicConfigure	| nameIt |	nameIt := FillInTheBlankMorph request: 'Name this cache:'.	^ nameIt isEmpty ifFalse: [self new description: nameIt]! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 12:56' prior: 23299114!= other	^ self == other! !!MCDictionaryRepository methodsFor: 'baseclass required' stamp: 'kph 5/16/2007 22:18' prior: 23296733!basicStoreVersion: aVersion	dictionary at: aVersion info put: aVersion! !!MCDictionaryRepository methodsFor: 'baseclass overrides' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23296902!closestAncestorVersionFor: anAncestry ifNone: errorBlock	| info |	info := anAncestry breadthFirstAncestors			detect: [:ea | self includesVersionWithInfo: ea]			ifNone: [^ errorBlock value].	^ self versionWithInfo: info! !!MCDictionaryRepository methodsFor: 'accessing' stamp: 'kph 5/16/2007 12:28' prior: 23297217!description	^ description ifNil: [ self class description ]! !!MCDictionaryRepository methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23297365!description: aString	description := aString ! !!MCDictionaryRepository methodsFor: 'baseclass overrides' stamp: 'kph 5/16/2007 22:51'!descriptionDisplay	^ 'In Memory: ', self description! !!MCDictionaryRepository methodsFor: 'accessing' stamp: 'kph 5/16/2007 22:17' prior: 23297503!dictionary	^ dictionary! !!MCDictionaryRepository methodsFor: 'accessing' stamp: 'kph 5/16/2007 22:17' prior: 23297626!dictionary: aDictionary	dictionary := aDictionary! !!MCDictionaryRepository methodsFor: 'baseclass overrides' stamp: 'kph 5/17/2007 00:23'!heldVersionInfos	^ dictionary keys! !!MCDictionaryRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 00:20'!heldVersions 	^ dictionary values! !!MCDictionaryRepository methodsFor: 'baseclass overrides' stamp: 'kph 5/16/2007 23:12' prior: 23297935!includesVersionWithInfo: aVersionInfo	"quicker implementation than inherited"	^ dictionary includesKey: aVersionInfo! !!MCDictionaryRepository methodsFor: 'initialization' stamp: 'kph 5/16/2007 22:42' prior: 23298110!initialize	dictionary := Dictionary new.! !!MCDictionaryRepository methodsFor: 'initialization' stamp: 'kph 5/16/2007 12:55'!openAndEditTemplateCopy 	| nameIt |	nameIt := FillInTheBlankMorph request: 'Rename In Memory Cache: ' initialAnswer: self description.	^ nameIt isEmpty ifFalse: [self class new description: nameIt]! !!MCDictionaryRepository methodsFor: 'baseclass required' stamp: 'kph 6/12/2008 23:01'!storeVersion: aVersion	aVersion info name: aVersion info name withBlanksTrimmed.	aVersion info allAncestorsDo: [ :each | each name: each name withBlanksTrimmed ].	^ super storeVersion: aVersion! !!MCDictionaryRepository methodsFor: 'baseclass required' stamp: 'kph 5/16/2007 22:20' prior: 23298926!versionWithInfo: aVersionInfo ifAbsent: errorBlock	^ dictionary at: aVersionInfo ifAbsent: errorBlock! !!MCSystemChangeSetsRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 14:30'!description	^ " 'System Change Sets'" nil! !!MCSystemChangeSetsRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 13:21'!ignoreMonticelloChangeSets	^ true! !!MCSystemChangeSetsRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 15:06'!isValid^ false! !!MCSystemChangeSetsRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 11:45'!morphicConfigure	 	^ self new! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 14:04'!addCSFrom: cs 		|   info |	  	info := MCSystemChangeSetVersionInfo on: cs.		dictionary 	at: info 				put: info 	 ! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 13:55'!addMCVersionFrom: cs 		| filename wc info |		self class ignoreMonticelloChangeSets ifTrue: [ ^self ].		filename := MCVersionInfoFilename filename: cs name.		wc := (MCPackage named: filename packageName) workingCopy.	info := wc ancestry infoWithName: cs name message: 'testing'.		dictionary 	at: (wc ancestry infoWithName: cs name message: 'testing') 				put: (MCVersion package: wc package info: info) 	 ! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 12:49'!initialize 	self loadFromChangeSet.	! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 12:51'!isChangeSetAMonticelloPackage: name	| number pa author |		number := name copyAfterLast: $..		number isEmpty ifTrue: [ ^ false ].		(number allSatisfy: [ :n | n isDigit ]) ifFalse: [ ^ false ].		pa := name copyUpToLast: $..		author := pa copyAfterLast: $-.		(author allSatisfy: [ :n | n isLetter ]) ifFalse: [ ^ false ].		^ true! !!MCSystemChangeSetsRepository methodsFor: 'testing' stamp: 'kph 5/17/2007 15:06'!isValid	^ false! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 13:56'!loadFromChangeSet	| |	dictionary := Dictionary new.		ChangeSet allChangeSets do: [ :cs |	 		( self isChangeSetAMonticelloPackage: cs name )				ifTrue: [ self addMCVersionFrom: cs ]				ifFalse: [ self addCSFrom: cs ]		]	! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 12:40'!loadFromChangeSetTmp	| |	dictionary := Dictionary new.		ChangeSet allChangeSets do: [ :cs |				(self isChangeSetAMonticelloPackage: cs name)						ifTrue: [ self addMCVersionFrom: cs name ]								ifFalse: [ 		 					dictionary at: (MCVersionInfo 								name: (self createMCNameFromCSName: cs name) 								id: nil "id added on copy into a proper repository" 								message: 'System Change Set: ', (cs name) 								date: Date today 								time: Time now								author: 'system' 								ancestors: #() 							 )						put: MCSystemChangeSetVersion new ]	]	! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 11:43'!openAndEditTemplateCopy! !!MCSystemChangeSetsRepository methodsFor: 'as yet unclassified' stamp: 'mtf 6/27/2008 23:22'!sortedHeldVersionInfos	^ self heldVersionInfos asSortedCollection: [ :a :b | a > b ]! !!MCFileBasedRepository commentStamp: 'kph 5/17/2007 04:42' prior: 0!For the FileBased repository we use versionInfo's as before, but they are based on only what info we can obtain from the file system and fileName. We are using instances of MCVersionInfo to represent fileNames in order that the UIdoesnt see anything special about a file based repository. This saves us special UI implementations for File based repositories."	!!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/19/2007 00:27' prior: 23211074!initialize	default := nil! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:46' prior: 23210357!cacheDirectory	^ (FileDirectory default directoryNamed: 'package-cache')		assureExistence;		yourself! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23210565!checkCacheDirectory	default notNil and: [default directory exists ifFalse: [default := nil]]! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 12:38'!creationTemplate	^'In Memory Cache'! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23210763!default	self checkCacheDirectory.	^ default ifNil: [default := self new directory: self cacheDirectory]! !!MCCacheRepository class methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:56' prior: 23210962!description	^ nil! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'bf 3/23/2005 00:52' prior: 23208623!basicStoreVersion: aVersion	(aVersion isCacheable and: [self allFileNames includes: aVersion fileName])		ifFalse: [super basicStoreVersion: aVersion]! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23208874!cacheForPackage: aPackage	packageCaches ifNil: [packageCaches := Dictionary new].	^ packageCaches at: aPackage ifAbsentPut: [MCPackageCache new]! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:15' prior: 23209108!newFileNames 	^ self allFileNames difference: self seenFileNames! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 15:13' prior: 23209261!packageForFileNamed: aString	^ self packageCache at: aString ifAbsentPut: [self versionReaderForFileNamed: aString do: [:r | r package]]! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 18:29' prior: 23209486!rescan	self newFileNames do:		[:ea |		self versionReaderForFileNamed: ea do:			[:reader |			(self cacheForPackage: reader package)				recordVersionInfo: reader info				forFileNamed: ea.			self seenFileNames add: ea]]		displayingProgress: 'Scanning cache...'! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23209851!seenFileNames	^ seenFiles ifNil: [seenFiles := OrderedCollection new]! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 15:05' prior: 23210009!versionInfoForFileNamed: aString	^ self infoCache at: aString ifAbsentPut: [self versionReaderForFileNamed: aString do: [:r | r info]]! !!MCDirectoryRepository class methodsFor: 'instance creation' stamp: 'ab 7/24/2003 21:20' prior: 23306122!description	^ 'directory'! !!MCDirectoryRepository class methodsFor: 'instance creation' stamp: 'ab 7/24/2003 21:01' prior: 23306243!morphicConfigure	^ FileList2 modalFolderSelector ifNotNilDo:		[:directory |		self new directory: directory]! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/31/2003 15:28' prior: 23304388!allFileNames	^ (directory entries sortBy: [:a :b | a modificationTime >= b modificationTime]) collect: [:ea | ea name]! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'mtf 6/28/2008 12:32'!creationTemplate	^ self class name, ' new directory: (FileDirectory on: ''', self description, ''')'.! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/14/2007 15:27'!delete: versionFileName		[ self directory deleteFileNamed: versionFileName ifAbsent: [ ^false ] ]		 on: Error do: [ :ex | ^ false ].		^ true! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:57' prior: 23304599!description	^ directory pathName! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'ab 7/6/2003 17:49' prior: 23304722!directory	^ directory! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23304847!directory: aDirectory	directory := aDirectory! !!MCDirectoryRepository methodsFor: 'comparing' stamp: 'ab 7/19/2003 21:40' prior: 23305880!hash	^ directory pathName hash! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'mtf 6/28/2008 13:52'!heldVersionInfos	" If you manipulate the underlying file system the caching will get you. If for example, you store your Monticello repo in a Git repo"	^ heldVersionInfos := self getHeldVersionInfos! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23304996!initialize	directory := FileDirectory default! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/14/2007 14:17'!isDeletingAllowed	^ true! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'nk 11/2/2003 10:55' prior: 23305133!isValid	^directory exists! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23305262!readStreamForFileNamed: aString do: aBlock	| file val |	file := FileStream readOnlyFileNamed: (directory fullNameFor: aString).	val := aBlock value: file.	file close.	^ val! !!MCDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23305542!writeStreamForFileNamed: aString replace: aBoolean do: aBlock	| file sel |	sel := aBoolean ifTrue: [#forceNewFileNamed:] ifFalse: [#newFileNamed:].	file := FileStream perform: sel with: (directory fullNameFor: aString).	aBlock value: file.	file close.! !!MCSubDirectoryRepository commentStamp: 'nk 6/11/2004 18:56' prior: 23540269!A MCDirectoryRepository that looks in subdirectories too.!!MCSubDirectoryRepository class methodsFor: 'user interface' stamp: 'nk 6/11/2004 18:48' prior: 23543903!description	^ 'directory with subdirectories'! !!MCSubDirectoryRepository methodsFor: 'enumeration' stamp: 'nk 6/11/2004 18:55' prior: 23542775!allDirectories	| remaining dir dirs |	remaining := OrderedCollection new.	dirs := OrderedCollection new.	remaining addLast: directory.	[remaining isEmpty]		whileFalse: [dir := remaining removeFirst.			dirs add: dir.			dir entries				do: [:ent | ent isDirectory						ifTrue: [remaining								addLast: (dir directoryNamed: ent name)]]].	^ dirs! !!MCSubDirectoryRepository methodsFor: 'enumeration' stamp: 'nk 6/11/2004 20:25' prior: 23543215!allFileNames	"sorting {entry. dirName. name}"	| sorted |	sorted := SortedCollection sortBlock: [:a :b |		a first modificationTime >= b first modificationTime ].	self allDirectories		do: [:dir | dir entries				do: [:ent | ent isDirectory						ifFalse: [sorted add: {ent. dir fullName. ent name}]]].	^ sorted		collect: [:ea | ea third ]! !!MCSubDirectoryRepository methodsFor: 'user interface' stamp: 'nk 6/11/2004 18:23' prior: 23543650!description	^ directory pathName, '/*'! !!MCSubDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23540431!findFullNameForReading: aBaseName	"Answer the latest version of aBaseName"	| possible |	possible := SortedCollection sortBlock: [ :a :b | b first modificationTime < a first modificationTime ].	self allDirectories		do: [:dir | dir entries				do: [:ent | ent isDirectory						ifFalse: [							(ent name = aBaseName) ifTrue: [ possible add: {ent. dir fullNameFor: ent name}]]]].	^(possible at: 1 ifAbsent: [ ^nil ]) second! !!MCSubDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23540966!findFullNameForWriting: aBaseName	| possible split dirScore fileScore prefix fpattern parts now |	split := directory splitNameVersionExtensionFor: aBaseName.	fpattern := split first, '*'.	possible := SortedCollection sortBlock: [ :a :b |		a first = b first			ifTrue: [ a second = b second					ifFalse: [ a second < b second ]					ifTrue: [ a third fullName size < b third fullName size ]]			ifFalse: [ a first > b first ] ].	now := Time totalSeconds.	prefix := directory pathParts size.	self allDirectories do: [:dir |		parts := dir pathParts allButFirst: prefix.		dirScore := (parts select: [ :part | fpattern match: part ]) size.		fileScore := (dir entries collect: [ :ent |			(ent isDirectory not and: [ fpattern match: ent name ])				ifFalse: [ SmallInteger maxVal ]				ifTrue: [ now - ent modificationTime ]]).	"minimum age"		fileScore := fileScore isEmpty ifTrue: [ SmallInteger maxVal  ]			ifFalse: [ fileScore min ].		possible add: { dirScore. fileScore. dir } ].	^ (possible first third) fullNameFor: aBaseName! !!MCSubDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23542113!readStreamForFileNamed: aString do: aBlock	| file val |	file := FileStream readOnlyFileNamed: (self findFullNameForReading: aString).	val := aBlock value: file.	file close.	^ val! !!MCSubDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'nk 6/11/2004 20:34' prior: 23542390!writeStreamForFileNamed: aString replace: aBoolean do: aBlock 	| file |	file := aBoolean				ifTrue: [FileStream						forceNewFileNamed: (self findFullNameForReading: aString)]				ifFalse: [FileStream						newFileNamed: (self findFullNameForWriting: aString)].	aBlock value: file.	file close! !!MCFileBasedRepository class methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:58' prior: 23317369!flushAllCaches	self allSubInstancesDo: [:ea | ea flushCache].	MCFileDefinition freeSomeSpace.! !!MCFileBasedRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 12:35'!freeSomeSpace	"system request for memory cleanup (e.g. prior to an image publication)"	self flushAllCaches! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'ab 8/21/2003 00:35' prior: 23311003!allFileNames	self subclassResponsibility! !!MCFileBasedRepository methodsFor: 'filesystem' stamp: 'ab 8/21/2003 20:01' prior: 23311135!allFileNamesForVersionNamed: aString	^ self filterFileNames: self readableFileNames forVersionNamed: aString! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'kph 9/28/2007 10:29' prior: 23311336!allFileNamesOrCache	^ allFileNames ifNil: [ self allFileNames]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 02:30' prior: 23311683!basicStoreVersion: aVersion	self		writeStreamForFileNamed: aVersion fileName		do: [:s | aVersion fileOutOn: s].	aVersion isCacheable ifTrue: [ self cache at: aVersion fileName put: aVersion].! !!MCFileBasedRepository methodsFor: 'cache' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23312021!cache	^ cache ifNil: [cache := Dictionary new]! !!MCFileBasedRepository methodsFor: 'cache' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23312171!cacheAllFileNamesDuring: aBlock	allFileNames := self allFileNames.	^ aBlock ensure: [allFileNames := nil]! !!MCFileBasedRepository methodsFor: 'cache' stamp: 'bf 6/9/2005 15:47' prior: 23312368!cachedFileNames	^cache == nil		ifTrue: [#()]		ifFalse: [cache keys]! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23312541!canReadFileNamed: aString	| reader |	reader := MCVersionReader readerClassForFileNamed: aString.	^ reader notNil! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 16:40' prior: 23312748!closestAncestorVersionFor: anAncestry ifNone: errorBlock	^ self cacheAllFileNamesDuring:		[super closestAncestorVersionFor: anAncestry ifNone: errorBlock]! !!MCFileBasedRepository methodsFor: 'filesystem' stamp: 'ab 8/21/2003 20:01' prior: 23312995!filterFileNames: aCollection forVersionNamed: aString	^ aCollection select: [:ea | (self versionNameFromFileName: ea) = aString] ! !!MCFileBasedRepository methodsFor: 'cache' stamp: 'kph 9/28/2007 10:53' prior: 23313228!flushCache	cache := nil.	heldVersionInfos := nil! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 9/28/2007 10:30'!getHeldVersionInfos	^ self readableFileNames collect: [:ea | MCVersionInfoFilename filename: ea]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 9/28/2007 10:43'!heldVersionInfos	^ heldVersionInfos ifNil: [ heldVersionInfos := self getHeldVersionInfos ]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 9/28/2007 10:31'!heldVersionInfosClearCacheheldVersionInfos := nil! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 02:32'!heldVersions	self error: 'I dont plan to load every version in from disk'! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 06:03' prior: 23313343!includesVersionNamed: aString	^ self heldVersionNames includes: aString! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'avi 1/22/2004 13:34' prior: 23313506!loadVersionFromFileNamed: aString	^ self versionReaderForFileNamed: aString do: [:r | r version]! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'mtf 10/29/2008 19:17' prior: 23313695!loadVersionInfoFromFileNamed: aString	^ [ self versionReaderForFileNamed: aString do: [:r | r info]	 	] on: Error 			do: [ :ex | self error: 'Could not read ', aString. 		].! !!MCFileBasedRepository methodsFor: 'cache' stamp: 'avi 9/17/2005 16:52' prior: 23313887!maxCacheSize	^ 8! !!MCFileBasedRepository methodsFor: 'notify' stamp: 'avi 8/26/2004 14:34' prior: 23314192!notifyList	| list |	(self allFileNames includes: 'notify') ifFalse: [^ #()].	^ self readStreamForFileNamed: 'notify' do:		[:s |		s upToEnd withSqueakLineEndings findTokens: (String with: Character cr)]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'mtf 6/27/2008 23:17' prior: 23314489!possiblyNewerVersionsOfAnyOf: someVersions	| pkgs |	pkgs := Dictionary new.	someVersions do: [:aVersionInfo |		pkgs at: aVersionInfo packageName			put: aVersionInfo]. 	^[self heldVersionInfos select: [:got |		pkgs at: (got packageName) ifPresent: [:verInfo | got > verInfo]			]] on: Error do: [:ex | ex return: #()]! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'avi 9/17/2005 16:39' prior: 23315117!readableFileNames	| all cached new |	all := self allFileNamesOrCache.	"from repository"	cached := self cachedFileNames.	"in memory"	new := all difference: cached.	^ (cached asArray, new)		select: [:ea | self canReadFileNamed: ea]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 03:15'!realizeFullVersionInfo: aStubVersionInfoInstance	^ self versionInfoFromFileNamed: aStubVersionInfoInstance name! !!MCFileBasedRepository methodsFor: 'cache' stamp: 'avi 9/18/2005 22:43' prior: 23315444!resizeCache: aDictionary	[aDictionary size <= self maxCacheSize] whileFalse:		[aDictionary removeKey: aDictionary keys atRandom]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'mtf 6/27/2008 23:22'!sortedHeldVersionInfos	^ self heldVersionInfos asSortedCollection: [ :a :b | a > b ]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'mtf 6/27/2008 23:22'!sortedVersionInfosAvailableForPackageNamed: aPackageName	^ (self versionInfosAvailableForPackageNamed: aPackageName) asSortedCollection: [ :a :b | a > b ]! !!MCFileBasedRepository methodsFor: 'filesystem' stamp: 'avi 9/17/2005 23:09' prior: 23315666!versionFromFileNamed: aString	| v |	v := self cache at: aString ifAbsent: [self loadVersionFromFileNamed: aString].	self resizeCache: cache.	(v notNil and: [v isCacheable]) ifTrue: [cache at: aString put: v].	^ v! !!MCFileBasedRepository methodsFor: 'filesystem' stamp: 'avi 9/17/2005 18:37' prior: 23315975!versionInfoFromFileNamed: aString	self cache at: aString ifPresent: [:v | ^ v info].	^ self loadVersionInfoFromFileNamed: aString! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'bf 5/30/2005 22:52' prior: 23316197!versionNameFromFileName: aString	^ (aString copyUpToLast: $.) copyUpTo: $(! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'kph 8/1/2007 01:50' prior: 23316363!versionReaderForFileNamed: aString do: aBlock	^ self		readStreamForFileNamed: aString		do: [:s |			(MCVersionReader readerClassForFileNamed: aString) 				ifNil:  [ MCNoVersionInfoAvailable signal ]				ifNotNilDo: [:class | aBlock value: (class on: s fileName: aString)]]! !!MCFileBasedRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 04:56' prior: 23316694!versionWithInfo: aStubOrRealVersionInfo ifAbsent: errorBlock	| realVersionInfo version |	 	"aVersionInfo could be a real one or a stub"		realVersionInfo := aStubOrRealVersionInfo realizeFrom: self.		(self allFileNamesForVersionNamed: realVersionInfo name) do:		[:fileName |		version := self versionFromFileNamed: fileName.		version info = realVersionInfo ifTrue: [^ version]].	^ errorBlock value! !!MCFileBasedRepository methodsFor: 'filesystem-private' stamp: 'avi 10/31/2003 14:32' prior: 23317046!writeStreamForFileNamed: aString do: aBlock	^ self writeStreamForFileNamed: aString replace: false do: aBlock! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'avi 9/16/2003 13:57' prior: 23333848!creationTemplate	^'MCFtpRepository	host: ''modules.squeakfoundation.org''	directory: ''mc''	user: ''squeak''	password: ''squeak'''	! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'avi 9/16/2003 13:57' prior: 23334078!description	^ 'FTP'! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:02' prior: 23334190!fillInTheBlankRequest	^ 'FTP Repository:'	! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'avi 9/16/2003 13:57' prior: 23334327!host: host directory: directory user: user password: password	^ self new		host: host;		directory: directory;		user: user;		password: password! !!MCFtpRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:02' prior: 23334565!morphicConfigure	^ self fillInTheBlankConfigure! !!MCFtpRepository methodsFor: 'required' stamp: 'avi 9/16/2003 14:04' prior: 23332762!allFileNames	^ self clientDo:		[:client |		self parseDirectoryListing: client getDirectory]! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/10/2007 01:52' prior: 23331533!clientDo: aBlock	| client |	client := FTPClient openOnHostNamed: host.	client loginUser: user password: self password.	directory isEmpty ifFalse: [client changeDirectoryTo: directory].	^ [aBlock value: client] ensure: [client close]! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/14/2007 15:13'!delete: versionFileName	self clientDo: [ :ftp |					 [ ftp deleteFileNamed: versionFileName ] on: Error do: [ :ex | ^ false ].	].	^ true! !!MCFtpRepository methodsFor: 'required' stamp: 'avi 9/17/2003 12:52' prior: 23332931!description	^ 'ftp://', user, '@', host, '/', directory! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23331862!directory: dirPath	directory := dirPath! !!MCFtpRepository methodsFor: 'required' stamp: 'ar 11/4/2005 17:26'!flushPasswords	MCPasswordManager default passwordAt: 'ftp://',host user: user put: nil.! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23331999!host: hostname	host := hostname! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'kph 12/19/2007 00:14'!isDeletingAllowed	| p |	p := self password.	^ p notEmpty and: [ p ~= 'squeak' ].! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'kph 12/1/2008 20:26'!locationHost	^ host! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23332128!parseDirectoryListing: aString	| stream files line tokens |	stream := aString readStream.	files := OrderedCollection new.	[stream atEnd] whileFalse:		[line := stream nextLine.		tokens := line findTokens: ' '.		tokens size > 2 ifTrue: [files add: tokens last]].	^ files! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!password	^(MCPasswordManager default queryPasswordAt: 'ftp://',host user: user) ifNil:[^''].! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26' prior: 23332501!password: passwordString	| pwd |	passwordString isEmpty ifTrue:[pwd := nil] ifFalse:[pwd := passwordString].	MCPasswordManager default passwordAt: 'ftp://',host user: user put: pwd.! !!MCFtpRepository methodsFor: 'required' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23333073!readStreamForFileNamed: aString do: aBlock	| stream |	^ self clientDo:		[:client |		client binary.		stream := RWBinaryOrTextStream on: String new.		stream nextPutAll: (client getFileNamed: aString).		aBlock value: stream reset]! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23332650!user: userString	user := userString! !!MCFtpRepository methodsFor: 'required' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23333393!writeStreamForFileNamed: aString replace: ignoreBoolean do: aBlock	| stream |	stream := RWBinaryOrTextStream on: String new.	aBlock value: stream.	self clientDo:		[:client |		client binary.		client putFileStreamContents: stream reset as: aString]! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'mtf 7/21/2008 18:13' prior: 23343372!creationTemplate	^self creationTemplateLocation: 'http://www.squeaksource.com/mc'		user: ''		password: ''! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'bf 4/14/2005 15:27' prior: 23343573!creationTemplateLocation: location user: user password: password	^'MCHttpRepository	location: {1}	user: {2}	password: {3}' format: {location printString. user printString. password printString}! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'ab 7/24/2003 21:20' prior: 23343863!description	^ 'HTTP'! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:00' prior: 23343977!fillInTheBlankRequest	^ 'HTTP Repository:'			! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'ab 7/24/2003 21:32' prior: 23344116!location: location user: user password: password	^ self new		location: location;		user: user;		password: password! !!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:01' prior: 23344326!morphicConfigure	^ self fillInTheBlankConfigure! !!MCHttpRepository methodsFor: 'required' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23341830!allFileNames	| index |	index := HTTPSocket httpGet: self locationWithTrailingSlash, '?C=M;O=D' args: nil user: self user passwd: self password.	index isString ifTrue: [self error: 'Could not access ', location].	^ self parseFileNamesFromStream: index	! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26' prior: 23337841!asCreationTemplate	^self class creationTemplateLocation: location user: user password: (		(MCPasswordManager default passwordAt: location user: user) ifNil:['']	)! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'bf 11/7/2005 17:28'!creationTemplate	^ self asCreationTemplate! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/10/2007 02:17'!creationTemplate: ignored	creationTemplate := nil.! !!MCHttpRepository methodsFor: 'required' stamp: 'ab 7/24/2003 21:10' prior: 23342160!description	^ location! !!MCHttpRepository methodsFor: 'required' stamp: 'al 12/12/2005 11:06' prior: 23342259!flushCache	super flushCache.	readerCache := nil.! !!MCHttpRepository methodsFor: 'required' stamp: 'kph 5/10/2007 03:43'!flushPasswords	MCPasswordManager default passwordAt: self locationHost user: user put: nil.! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 07:49' prior: 23338222!location: aUrlString	location := (aUrlString beginsWith: 'http://') 		ifTrue: [ aUrlString ]		ifFalse: [ 'http://', aUrlString ]! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/11/2007 07:50'!locationHost	| end |		(end := (location lastIndexOf: $/) - 1) < 9 ifTrue: [ ^ location ].  		^ location copyFrom: 1 to: end.! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ab 7/24/2003 22:17' prior: 23338023!locationWithTrailingSlash	^ (location endsWith: '/')		ifTrue: [location]		ifFalse: [location, '/']! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23338364!parseFileNamesFromStream: aStream	| names fullName |	names := OrderedCollection new.	[aStream atEnd] whileFalse:		[[aStream upTo: $<. {$a. $A. nil} includes: aStream next] whileFalse.		aStream upTo: $".		aStream atEnd ifFalse: [			fullName := aStream upTo: $".			names add: fullName unescapePercents]].	^ names! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'kph 4/25/2008 00:42' prior: 23338781!password	self user isEmpty ifTrue: [^''].	^(MCPasswordManager default queryPasswordAt: self locationHost user: self user) ifNil:[^'']! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/10/2007 03:42' prior: 23339380!password: passwordString	| pwd |	passwordString isEmpty ifTrue:[pwd := nil] ifFalse:[pwd := passwordString].	MCPasswordManager default passwordAt: self locationHost user: self user put: pwd.! !!MCHttpRepository methodsFor: 'required' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23342396!readStreamForFileNamed: aString do: aBlock	| contents |	contents := HTTPSocket httpGet: (self urlForFileNamed: aString) args: nil user: self user passwd: self password.	^ contents isString ifFalse: [aBlock value: contents]! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 13:08' prior: 23339518!urlForFileNamed: aString	^ self locationWithTrailingSlash, aString encodeForHTTP! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'kph 4/25/2008 00:42' prior: 23339685!user	^user ifNil: [ '' ]! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'mtf 6/9/2008 20:56' prior: 23341146!user: userString	user := userString! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23341280!versionReaderForFileNamed: aString	readerCache ifNil: [readerCache := Dictionary new].	^ readerCache at: aString ifAbsent:		[self resizeCache: readerCache.		super versionReaderForFileNamed: aString do:			[:r |			r ifNotNil: [readerCache at: aString put: r]]]	! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 23:06' prior: 23341633!versionReaderForFileNamed: aString do: aBlock	^ (self versionReaderForFileNamed: aString) ifNotNilDo: aBlock! !!MCHttpRepository methodsFor: 'required' stamp: 'kph 2/8/2009 03:05' prior: 23342708!writeStreamForFileNamed: aString replace: ignoreBoolean do: aBlock	| stream response statusLine code |	stream := RWBinaryOrTextStream on: String new.	aBlock value: stream.	response := HTTPSocket					httpPut: stream contents					to: (self urlForFileNamed: aString)					user: self user					passwd: self password.	statusLine := response copyUpTo: Character cr.	code := statusLine findTokens: ' '. 	code := code second asInteger.	(code >= 200 and: [code < 300])			ifFalse: [self error: response].			! !!MCSMCacheRepository commentStamp: 'nk 1/23/2004 09:57' prior: 23470135!I am a Monticello repository that reflects the caching of SqueakMap v2.I refer write attempts to the default MCCacheRepository.!!MCSMCacheRepository class methodsFor: 'instance creation' stamp: 'nk 1/23/2004 10:04' prior: 23472933!description	^ 'SqueakMap Cache'! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:46' prior: 23470342!allFileNames	^self allFullFileNames collect: [ :ea | self directory localNameFor: ea ]! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23470520!allFullFileNames	| cachedPackages |	cachedPackages := smCache map installedPackages select: [ :ea | ea isCached ].	^Array streamContents: [ :s |		cachedPackages do: [ :ea | | d |			d := ea cacheDirectory.			(d fileNamesMatching: '*.mcz') do: [ :fn | s nextPut: (d fullNameFor: fn) ]]]! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:40' prior: 23470889!description	^ smCache directory pathName! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:40' prior: 23471009!directory	^ smCache directory! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:40' prior: 23471118!directory: aDirectory! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:55' prior: 23471219!fullNameFor: aFileName	^self allFullFileNames detect: [ :ffn | (self directory localNameFor: ffn) = aFileName ] ifNone: []! !!MCSMCacheRepository methodsFor: 'comparing' stamp: 'nk 1/23/2004 09:55' prior: 23471691!hash	^ smCache hash! !!MCSMCacheRepository methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23472525!initialize	super initialize.	smCache := SMSqueakMap default cache.! !!MCSMCacheRepository methodsFor: 'testing' stamp: 'nk 1/23/2004 09:47' prior: 23472671!isValid	^smCache notNil and: [ self directory exists ]! !!MCSMCacheRepository methodsFor: 'file streaming' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23471808!readStreamForFileNamed: aString do: aBlock	| file fileName |	fileName := self fullNameFor: aString.	fileName ifNil: [		"assume that this will come from the cache."		^MCCacheRepository default readStreamForFileNamed: aString do: aBlock ].	file := FileStream readOnlyFileNamed: fileName.	^[ aBlock value: file ] ensure: [ file close ].! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:37' prior: 23471421!smCache	^smCache! !!MCSMCacheRepository methodsFor: 'accessing' stamp: 'nk 1/23/2004 09:45' prior: 23471517!smCache: aSMFileCache	| |	smCache := aSMFileCache.	self directory: aSMFileCache directory.! !!MCSMCacheRepository methodsFor: 'file streaming' stamp: 'nk 1/23/2004 09:57' prior: 23472233!writeStreamForFileNamed: aString replace: aBoolean do: aBlock	"Can't write into the SM cache, so..."	^MCCacheRepository default writeStreamForFileNamed: aString replace: aBoolean do: aBlock! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:36' prior: 23336918!creationTemplate	^'MCGOODSRepository	host: ''localhost''	port: 6100'! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 14:33' prior: 23337084!description	^ 'GOODS'! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:33' prior: 23337200!fillInTheBlankRequest	^ 'GOODS Repository:'! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:36' prior: 23337338!host: hostname port: portNumber	^ self new		host: hostname;		port: portNumber! !!MCGOODSRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:35' prior: 23337512!morphicConfigure	^ self fillInTheBlankConfigure! !!MCGOODSRepository methodsFor: 'baseclass required' stamp: 'avi 8/26/2004 14:20' prior: 23335029!basicStoreVersion: aVersion	self root at: aVersion info put: aVersion.	self db commit.! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'mtf 6/9/2008 20:57' prior: 23335203!db	Smalltalk at: #KKDatabase ifPresent: [:classKKDatabase |	(connection isNil or: [connection isConnected not]) ifTrue: [		connection := classKKDatabase onHost:hostname port: port].	].	^ connection! !!MCGOODSRepository methodsFor: 'baseclass overides' stamp: 'avi 2/28/2004 20:35' prior: 23335473!description	^ 'goods://', hostname asString, ':', port asString! !!MCGOODSRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 01:44'!heldVersionInfos	^ self root keys  ! !!MCGOODSRepository methodsFor: 'baseclass required' stamp: 'kph 5/17/2007 00:23'!heldVersions	^ self root asArray  ! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23335636!host: aString	hostname := aString! !!MCGOODSRepository methodsFor: 'baseclass overides' stamp: 'avi 2/28/2004 20:17' prior: 23335944!packages	^ (self root collect: [:ea | ea package]) asSet asSortedCollection! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23336119!port: aNumber	port := aNumber! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 14:35' prior: 23336237!root	self db root ifNil: [self db root: Dictionary new].	^ self db root! !!MCGOODSRepository methodsFor: 'baseclass required' stamp: 'avi 2/28/2004 20:21' prior: 23336611!versionWithInfo: aVersionInfo ifAbsent: errorBlock	^ self root at: aVersionInfo ifAbsent: errorBlock! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 00:30' prior: 23457192!allConcreteSubclasses	^ self withAllSubclasses reject: [:ea | ea isAbstract]! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/3/2007 20:22'!clearPasswords	self allSubInstancesDo: [:ea | (ea respondsTo: #flushPasswords) ifTrue:[ ea flushPasswords ] ].! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 20:59' prior: 23457358!creationTemplate	self subclassResponsibility.! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 00:29' prior: 23457492!description	^ nil! !!MCRepository class methodsFor: 'obsolete' stamp: 'kph 5/15/2007 20:16' prior: 23458978!fetchExternalSettingsIn: dir	"no longer used"! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:05' prior: 23457599!fillInTheBlankConfigure	^ self fillInTheBlankConfigure: self creationTemplate			! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23457781!fillInTheBlankConfigure: aTemplateString	| chunk repo |		aTemplateString ifNil: [ ^ false ].	chunk := FillInTheBlankMorph 			request: self fillInTheBlankRequest			initialAnswer: aTemplateString			centerAt: Sensor cursorPoint			inWorld: World			onCancelReturn: nil			acceptOnCR: false			answerExtent: 400@120.				chunk 		ifNotNil: [ 			repo := self readFrom: chunk readStream.			repo creationTemplate: chunk. 	].	^ repo! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 20:58' prior: 23458307!fillInTheBlankRequest	self subclassResponsibility.! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'ab 8/21/2003 12:59' prior: 23458446!isAbstract	^ self description isNil! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'ab 7/24/2003 21:01' prior: 23458570!morphicConfigure	^ self new! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 09:04'!uiClass	^ ui ifNil: [ MCRepositoryPackagesVersionsInspector ]! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 09:05'!uiClassUseOneColumn	^ ui := MCRepositoryVersionsInspector ! !!MCRepository class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 09:05'!uiClassUseTwoColumn	^ ui := nil! !!MCRepository methodsFor: 'testing' stamp: 'ab 8/21/2003 12:36' prior: 23455987!= other	^ other species = self species and: [other description = self description]! !!MCRepository methodsFor: '' stamp: 'kph 8/1/2007 12:47'!allVersionNames 	"method for comapibility with MCConfigurations"	^ self heldVersionNames! !!MCRepository methodsFor: 'accessing' stamp: 'avi 8/31/2004 01:08' prior: 23452928!alwaysStoreDiffs	^ storeDiffs ifNil: [false]! !!MCRepository methodsFor: 'initialization' stamp: 'bkv 2/18/2004 20:48' prior: 23453056!asCreationTemplate	^ self creationTemplate! !!MCRepository methodsFor: 'required in subclasses' stamp: 'avi 8/26/2004 14:20' prior: 23453182!basicStoreVersion: aVersion	self subclassResponsibility! !!MCRepository methodsFor: 'misc' stamp: 'kph 5/16/2007 23:31'!cacheAllFileNamesDuring: aBlock 	^ aBlock value! !!MCRepository methodsFor: 'storing' stamp: 'avi 9/17/2005 16:12' prior: 23453321!closestAncestorVersionFor: anAncestry ifNone: errorBlock	anAncestry breadthFirstAncestorsDo:		[:ancestorInfo |		(self versionWithInfo: ancestorInfo) ifNotNilDo: [:v | ^ v]].	^ errorBlock value! !!MCRepository methodsFor: 'initialization' stamp: 'bkv 2/18/2004 20:46' prior: 23453600!creationTemplate	^ creationTemplate! !!MCRepository methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23453730!creationTemplate: aString	self creationTemplate ifNotNil: [ self error: 'Creation template already set for this MCRepository instance.' ].		creationTemplate := aString.! !!MCRepository methodsFor: 'accessing' stamp: 'avi 10/9/2003 12:53' prior: 23453984!description	^ self class name! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/16/2007 22:48'!descriptionDisplay	^ self description! !!MCRepository methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23454108!doAlwaysStoreDiffs	storeDiffs := true! !!MCRepository methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23454240!doNotAlwaysStoreDiffs	storeDiffs := false! !!MCRepository methodsFor: 'actions' stamp: 'ar 11/4/2005 16:58'!flushPasswords! !!MCRepository methodsFor: 'testing' stamp: 'ab 8/21/2003 12:36' prior: 23454364!hash	^ self description hash! !!MCRepository methodsFor: 'required in subclasses' stamp: 'kph 5/17/2007 00:21'!heldVersionInfos	^ self heldVersions collect: [ :ver | ver info ]! !!MCRepository methodsFor: '' stamp: 'kph 6/2/2008 19:35'!heldVersionInfosClearCache! !!MCRepository methodsFor: '' stamp: 'kph 8/1/2007 12:46'!heldVersionNames	^ self heldVersionInfos collect: [:v |  v versionName ]! !!MCRepository methodsFor: 'required in subclasses' stamp: 'kph 5/17/2007 00:22'!heldVersions	self subclassResponsibility! !!MCRepository methodsFor: 'required in subclasses' stamp: 'kph 1/28/2008 02:17' prior: 23456143!includesVersionNamed: aString	^ self heldVersionInfos anySatisfy: [:ea | ea versionName = aString]! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 00:21'!includesVersionWithInfo: aVersionInfo	^ self heldVersionInfos includes: aVersionInfo! !!MCRepository methodsFor: 'testing' stamp: 'kph 5/14/2007 13:56'!isDeletingAllowed	^ false! !!MCRepository methodsFor: 'testing' stamp: 'nk 11/2/2003 10:55' prior: 23456983!isValid	^true! !!MCRepository methodsFor: 'interface' stamp: 'lr 9/26/2003 20:03' prior: 23456273!morphicOpen	self morphicOpen: nil! !!MCRepository methodsFor: 'required in subclasses' stamp: 'mtf 6/7/2008 12:28' prior: 23456379!morphicOpen: aWorkingCopy	(self class uiClass 		repository: self 		selectedPackage: (aWorkingCopy ifNotNilDo: [ :wc |  wc package ]) 		selectedVersion: nil ) show! !!MCRepository methodsFor: 'notifications' stamp: 'avi 8/26/2004 14:27' prior: 23454568!notificationForVersion: aVersion	^ MCVersionNotification version: aVersion repository: self! !!MCRepository methodsFor: 'notifications' stamp: 'avi 8/26/2004 14:23' prior: 23454743!notifyList	^ #()! !!MCRepository methodsFor: 'initialization' stamp: 'bf 4/14/2005 17:30' prior: 23456506!openAndEditTemplateCopy	^ self class fillInTheBlankConfigure: (self asCreationTemplate ifNil: [^nil])! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 01:50'!packageNames	^ (self heldVersionInfos collect: [:ea | ea packageName]) asSet asSortedCollection! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 00:21'!packages	^ (self heldVersions collect: [:ea | ea package]) asSet asSortedCollection! !!MCRepository methodsFor: 'storing' stamp: 'bf 3/10/2005 23:01' prior: 23454842!possiblyNewerVersionsOfAnyOf: someVersions	^#()! !!MCRepository methodsFor: 'storing' stamp: 'avi 8/31/2004 01:06' prior: 23454973!prepareVersionForStorage: aVersion	^ self alwaysStoreDiffs		ifTrue: [aVersion asDiffAgainst:				 (self closestAncestorVersionFor: aVersion info ifNone: [^ aVersion])]		ifFalse: [aVersion]! !!MCRepository methodsFor: 'printing' stamp: 'mas 9/24/2003 04:21' prior: 23455247!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self description;		nextPut: $).! !!MCRepository methodsFor: 'required in subclasses' stamp: 'kph 5/17/2007 03:14'!realizeFullVersionInfo: aStubVersionInfoInstance	"we use full versionInfos anyway"		^ aStubVersionInfoInstance! !!MCRepository methodsFor: 'notifications' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23455453!sendNotificationsForVersion: aVersion	| notification notifyList |	notifyList := self notifyList.	notifyList isEmpty ifFalse:		[notification := self notificationForVersion: aVersion.		notifyList do: [:ea | notification notify: ea]]! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 00:28'!sortedHeldVersionInfos 	 	^ self sortedVersionInfos select: [:ea | self heldVersionInfos includes: ea]! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 03:51'!sortedVersionInfos 	| sorter |	sorter := MCVersionSorter new.	self heldVersionInfos do: [:ea | sorter addVersionInfo: ea].	^ sorter sortedVersionInfos! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 02:03'!sortedVersionInfosAvailableForPackageNamed: aPackageName 	 	^ self sortedVersionInfos 		select: [:ea | (self versionInfosAvailableForPackageNamed: aPackageName)  includes: ea]! !!MCRepository methodsFor: 'storing' stamp: 'avi 8/31/2004 01:05' prior: 23455771!storeVersion: aVersion	self basicStoreVersion: (self prepareVersionForStorage: aVersion).	self sendNotificationsForVersion: aVersion! !!MCRepository methodsFor: 'accessing' stamp: 'kph 5/17/2007 02:02'!versionInfosAvailableForPackageNamed: aPackageName	^ self heldVersionInfos select: [:ea | ea packageName = aPackageName] ! !!MCRepository methodsFor: 'interface' stamp: 'avi 10/9/2003 12:42' prior: 23456681!versionWithInfo: aVersionInfo	^ self versionWithInfo: aVersionInfo ifAbsent: [nil]! !!MCRepository methodsFor: 'required in subclasses' stamp: 'ab 8/16/2003 18:22' prior: 23456836!versionWithInfo: aVersionInfo ifAbsent: aBlock	self subclassResponsibility ! !!MCRepository methodsFor: 'required in subclasses' stamp: 'kph 5/16/2007 22:56'!versions	self subclassResponsibility! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 14:15' prior: 23475670!creationTemplate	^'MCSMReleaseRepository	package: ''mypackage''	user: ''squeak''	password: ''squeak'''	! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 13:42' prior: 23475877!description	^ 'SqueakMap Release'! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:03' prior: 23476009!fillInTheBlankRequest	^  'SqueakMap Release Repository:'		! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'bkv 2/18/2004 21:03' prior: 23476167!morphicConfigure	^ self fillInTheBlankConfigure! !!MCSMReleaseRepository class methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 14:14' prior: 23476313!package: packageString user: userString password: passString	^ self basicNew initializeWithPackage: packageString user: userString password: passString! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23473379!basicStoreVersion: aVersion	| url |	url := self uploadVersion: aVersion.	self releaseVersion: aVersion url: url! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 14:11' prior: 23473585!checkResult: resultString(#( 'HTTP/1.1 201 ' 'HTTP/1.1 200 ' 'HTTP/1.0 201 ' 'HTTP/1.0 200 ')		anySatisfy: [:code | resultString beginsWith: code ])			ifFalse: [self error: resultString].! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 14:15' prior: 23473868!description	^ 'sm://', packageName! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!flushPasswords	MCPasswordManager default passwordAt: self squeakMapUrl user: user put: nil! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/3/2007 19:56' prior: 23474006!initializeWithPackage: packageString user: userString password: passString	packageName := packageString.	user := userString.	self password: passString.! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!password	^(MCPasswordManager default queryPasswordAt: self squeakMapUrl user: user) ifNil:[^''].! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!password: passwordString	| pwd |	passwordString isEmpty ifTrue:[pwd := nil] ifFalse:[pwd := passwordString].	MCPasswordManager default passwordAt: self squeakMapUrl user: user put: pwd.! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/3/2007 19:55' prior: 23474261!releaseVersion: aVersion url: urlString	| result |	result := HTTPSocket		httpPost: self squeakMapUrl, '/packagebyname/', packageName, '/newrelease'		args: {'version' -> {(aVersion info name copyAfter: $.) extractNumber asString}.			   'note' -> {aVersion info message}.			   'downloadURL' -> {urlString}}		user: user		passwd: self password.	result contents size > 4 ifTrue: [self error: result contents]! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'kph 6/9/2008 00:46' prior: 23474761!squeakMapUrl 	^ 'http://map.squeak.org/sm' ! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23474908!stringForVersion: aVersion	| stream |	stream := RWBinaryOrTextStream on: String new.	aVersion fileOutOn: stream.	^ stream contents! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'kph 5/3/2007 19:55' prior: 23475145!uploadVersion: aVersion	| result stream |	result := HTTPSocket		httpPut: (self stringForVersion: aVersion)		to: self squeakMapUrl, '/upload/', aVersion fileName		user: user		passwd: self password.	self checkResult: result.	stream := result readStream.	stream upToAll: 'http://'.	^ 'http://', stream upToEnd! !!MCSmtpRepository class methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:56' prior: 23489979!description	^ 'SMTP'! !!MCSmtpRepository class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23490104!morphicConfigure	| address |	address := FillInTheBlankMorph request: 'Email address:'.	^ address isEmpty ifFalse: [self new emailAddress: address]! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 14:21' prior: 23488412!basicStoreVersion: aVersion	MailSender sendMessage: (self messageForVersion: aVersion)! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 13:11' prior: 23488586!bodyForVersion: aVersion	^ String streamContents:		[ :s |		s nextPutAll: 'from version info:'; cr; cr.		s nextPutAll:  aVersion info summary]! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:56' prior: 23488818!description	^ 'mailto://', email! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23488949!emailAddress: aString	email := aString	! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23489087!messageForVersion: aVersion	| message data |	message := MailMessage empty.	message setField: 'from' toString: MailSender userName.	message setField: 'to' toString: email.	message setField: 'subject' toString: (self subjectForVersion: aVersion). 	message body:		(MIMEDocument			contentType: 'text/plain'			content: (self bodyForVersion: aVersion)).	"Prepare the gzipped data"	data := RWBinaryOrTextStream on: String new.	aVersion fileOutOn: data.	message addAttachmentFrom: data reset withName: aVersion fileName.	^ message! !!MCSmtpRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 13:14' prior: 23489712!subjectForVersion: aVersion	^ '[Package] ', aVersion info name! !!MCWriteOnlyRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:52' prior: 23663450!includesVersionNamed: aString	^ false! !!MCWriteOnlyRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:53' prior: 23663580!morphicOpen: aWorkingCopy	self inform: 'This repository is write-only'! !!MCWriteOnlyRepository methodsFor: 'as yet unclassified' stamp: 'avi 10/9/2003 12:52' prior: 23663743!versionWithInfo: aVersionInfo ifAbsent: aBlock	^ aBlock value! !!MCRepositoryGroup commentStamp: '<historical>' prior: 23459848!A singleton class, holds the list of repositories. Can look for a requested VersionInfo among its repositories.!!MCRepositoryGroup class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23462084!default	^ default ifNil: [default := self new]! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'mtf 2/7/2009 12:27' prior: 23460046!addRepository: aRepository	aRepository ifNil: [ ^ self ].	lastAdded := aRepository.		aRepository == MCCacheRepository default ifTrue: [ ^ self ].	(repositories includes: aRepository)		ifFalse: [repositories add: aRepository.				self class default addRepository: aRepository]		ifTrue: [ 			repositories remove: aRepository.			repositories add: aRepository.		].		self changed: #repositories! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'NorbertHartl 6/20/2008 10:11'!disableCache	useCache := false! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2003 00:20' prior: 23460581!includes: aRepository	^ self repositories includes: aRepository! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'abc 11/6/2004 20:32' prior: 23460371!includesVersionNamed: aString	self repositoriesDo: [:ea | (ea includesVersionNamed: aString) ifTrue: [^ true]].	^ false	! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23460744!initialize	repositories := OrderedCollection new! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'kph 12/13/2008 17:34'!lastAdded	^ lastAdded! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'ab 7/22/2003 00:11' prior: 23460880!removeRepository: aRepository	repositories remove: aRepository ifAbsent: [].	self changed: #repositories! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'mtf 2/7/2009 12:23' prior: 23461073!repositories	| r |	r := repositories select: [ :ea | ea isValid ].	self useCache ifFalse: [ ^ r ].		r size > 0 		ifTrue: [ r addFirst: MCCacheRepository default ]		ifFalse: [ r := Array with: MCCacheRepository default ].			^ r	! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2003 00:51' prior: 23461261!repositoriesDo: aBlock	self repositories do: [:ea | [aBlock value: ea] on: Error do: []]! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'abc 6/20/2008 10:02'!useCache	^ useCache ifNil: [		useCache := true	]! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'dvf 8/10/2004 23:02' prior: 23461438!versionWithInfo: aVersionInfo	^self versionWithInfo: aVersionInfo ifNone: [ self error: 'Could not find version ', aVersionInfo name printString,'. Maybe you need to add a repository?' ]! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'nk 1/23/2004 18:15' prior: 23461712!versionWithInfo: aVersionInfo ifNone: aBlock	self repositoriesDo: [:ea | (ea versionWithInfo: aVersionInfo) ifNotNilDo: [:v | ^ v]].	^aBlock value! !!MCScanner class methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:14' prior: 23479968!scan: aStream	^ (self new stream: aStream) next! !!MCScanner class methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:32' prior: 23479799!scanTokens: aString	"compatibility"	^ Array with: (self scan: aString readStream)! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23478604!next	| c |	stream skipSeparators.	c := stream peek.	c = $# ifTrue: [c := stream next; peek].	c = $' ifTrue: [^ self nextString].	c = $( ifTrue: [^ self nextArray].	c isAlphaNumeric ifTrue: [^ self nextSymbol].	self error: 'Unknown token type'.	! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:27' prior: 23478936!nextArray	stream next. "("	^ Array streamContents:		[:s |		[stream skipSeparators.		(stream peek = $)) or: [stream atEnd]] whileFalse: [s nextPut: self next].		stream next = $) ifFalse: [self error: 'Unclosed array']]! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:09' prior: 23479239!nextString	^ stream nextDelimited: $'! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 20:16' prior: 23479357!nextSymbol	^ (String streamContents:		[:s |		[stream peek isAlphaNumeric] whileTrue: [s nextPut: stream next]]) asSymbol			! !!MCScanner methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23479575!stream: aStream	stream := aStream! !!MCImageBackedSnapshot methodsFor: 'as yet unclassified' stamp: 'mtf 10/7/2008 17:05'!asPatchSnapshot	^ self! !!MCImageBackedSnapshot methodsFor: 'as yet unclassified' stamp: 'mtf 10/7/2008 12:58'!definitionIndex	^ MCImageBackedDefinitionIndex definitions: definitions! !!MCSnapshot class methodsFor: 'as yet unclassified' stamp: 'kph 1/16/2009 13:36' prior: 23491472!empty	^ self fromDefinitions: OrderedCollection new! !!MCSnapshot class methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 01:43' prior: 23491591!fromDefinitions: aCollection 	^ self new initializeWithDefinitions: aCollection! !!MCSnapshot methodsFor: 'accessing' stamp: 'ab 7/10/2003 01:05' prior: 23490664!= other	^ definitions asArray = other definitions asArray! !!MCSnapshot methodsFor: 'patching' stamp: 'mtf 10/7/2008 14:02'!asPatchSnapshot	^ MCImageBackedSnapshot fromDefinitions: definitions! !!MCSnapshot methodsFor: 'authorship' stamp: 'kph 2/7/2009 20:57'!authorInitials	| authors |	authors := Set new.		self definitions do: [ :ea | ea authorInitials ifNotNilDo: [ :a | authors add: a ]].			^ authors! !!MCSnapshot methodsFor: 'patching' stamp: 'mtf 10/7/2008 12:57'!definitionIndex	^ MCDefinitionIndex definitions: definitions! !!MCSnapshot methodsFor: 'accessing' stamp: 'ab 12/4/2002 18:09' prior: 23490466!definitions	^ definitions! !!MCSnapshot methodsFor: 'authorship' stamp: 'kph 2/8/2009 00:13'!definitionsWithAnyAuthor: initialsList		^ self definitions select: [ :ea | initialsList anySatisfy: [ :init | init = ea authorInitials ]]! !!MCSnapshot methodsFor: 'accessing' stamp: 'ab 7/10/2003 01:05' prior: 23490562!hash	^ definitions asArray hash! !!MCSnapshot methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23490808!initializeWithDefinitions: aCollection	definitions := aCollection.! !!MCSnapshot methodsFor: 'loading' stamp: 'kph 12/7/2008 02:30' prior: 23490943!install	(MCPackageLoader newCurrent)		installSnapshot: self;		installOrphanage;		load! !!MCSnapshot methodsFor: 'accessing' stamp: 'kph 5/10/2007 18:10'!isEmpty	^ definitions isEmpty! !!MCSnapshot methodsFor: 'patching' stamp: 'ab 7/7/2003 00:37' prior: 23491208!patchRelativeToBase: aSnapshot	^ MCPatch fromBase: aSnapshot target: self! !!MCSnapshot methodsFor: 'loading' stamp: 'kph 12/7/2008 02:30' prior: 23491056!updatePackage: aPackage	(MCPackageLoader newCurrent)		updatePackage: aPackage withSnapshot: self;		installOrphanage;		load		! !!MCCodeTool commentStamp: 'nk 11/10/2003 22:00' prior: 23242067!MCCodeTool is an abstract superclass for those Monticello browsers that display code.It contains copies of the various CodeHolder methods that perform the various menu operations in the method list.!!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 21:00' prior: 23242333!adoptMessageInCurrentChangeset	"Add the receiver's method to the current change set if not already there"	self selectedClassOrMetaClass ifNotNilDo: [ :cl |		self selectedMessageName ifNotNilDo: [ :sel |			ChangeSet current adoptSelector: sel forClass: cl.			self changed: #annotations ]]! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:01' prior: 23250552!annotations	"Build an annotations string for the various browsers"	^''! !!MCCodeTool methodsFor: 'menus' stamp: 'sd 5/10/2008 17:31' prior: 23242705!browseFullProtocol	"Open up a protocol-category browser on the value of the	receiver's current selection."		^ self spawnFullProtocol! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 21:26' prior: 23243325!browseMessages	"Present a menu of the currently selected message, as well as all messages sent by it.  Open a message set browser of all implementors of the selector chosen."	self systemNavigation browseAllImplementorsOf: (self selectedMessageName ifNil: [ ^nil ])! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23243670!browseMethodFull	"Create and schedule a full Browser and then select the current class and message."	| myClass |	(myClass := self selectedClassOrMetaClass) ifNotNil:		[Browser fullOnClass: myClass selector: self selectedMessageName]! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 20:54' prior: 23243974!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all messages sent by it.  Open a message set browser of all senders of the selector chosen."	self systemNavigation browseAllCallsOn: (self selectedMessageName ifNil: [ ^nil ])! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23244316!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector compiledMethod |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	compiledMethod := class compiledMethodAt: selector ifAbsent: [ ^self ].	VersionsBrowser		browseVersionsOf: compiledMethod		class: class theNonMetaClass		meta: class isMeta		category: self selectedMessageCategoryName		selector: selector! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 7/30/2004 17:56' prior: 23244862!classHierarchy	"Create and schedule a class list browser on the receiver's hierarchy."	self systemNavigation  spawnHierarchyForClass: self selectedClassOrMetaClass		selector: self selectedMessageName	"OK if nil"! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 6/12/2004 14:01' prior: 23245143!classListMenu: aMenu 	aMenu addList: #(		-		('browse full (b)'			browseMethodFull)		('browse hierarchy (h)'		classHierarchy)		('browse protocol (p)'		browseFullProtocol)"		-		('printOut'					printOutClass)		('fileOut'					fileOutClass)"		-		('show hierarchy'			methodHierarchy)"		('show definition'			editClass)		('show comment'			editComment)""		-		('inst var refs...'			browseInstVarRefs)		('inst var defs...'			browseInstVarDefs)		-		('class var refs...'			browseClassVarRefs)		('class vars'					browseClassVariables)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class'				copyClass)		('remove class (x)'			removeClass)"		-		('find method...'				findMethodInChangeSets)).								^aMenu! !!MCCodeTool methodsFor: 'menus' stamp: 'jl 11/1/2006 10:40'!copyClassAndSelector	"Copy the selected selector to the clipboard"	Clipboard clipboardText: '',self selectedClassOrMetaClass,'>>',self selectedMessageName! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23245980!copySelector	"Copy the selected selector to the clipboard"	| selector |	(selector := self selectedMessageName) ifNotNil:		[Clipboard clipboardText: selector asString]! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 20:55' prior: 23246218!fileOutMessage	"Put a description of the selected message on a file"	self selectedMessageName ifNotNil:		[Cursor write showWhile:			[self selectedClassOrMetaClass fileOutMethod: self selectedMessageName]]! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23246505!findMethodInChangeSets	"Find and open a changeSet containing the current method."	| aName |	(aName := self selectedMessageName) ifNotNil: [		ChangeSorter browseChangeSetsWithClass: self selectedClassOrMetaClass					selector: aName]! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 7/30/2004 17:56' prior: 23246808!methodHierarchy	"Create and schedule a method browser on the hierarchy of implementors."	self systemNavigation methodHierarchyBrowserForClass: self selectedClassOrMetaClass		selector: self selectedMessageName! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 2/16/2004 17:00' prior: 23247086!methodListKey: aKeystroke from: aListMorph 	aKeystroke caseOf: {		[$b] -> [self browseMethodFull].		[$h] -> [self classHierarchy].		[$O] -> [self openSingleMessageBrowser].		[$p] -> [self browseFullProtocol].		[$o] -> [self fileOutMessage].		[$c] -> [self copySelector].		[$n] -> [self browseSendersOfMessages].		[$m] -> [self browseMessages].		[$i] -> [self methodHierarchy].		[$v] -> [self browseVersions]}		 otherwise: []! !!MCCodeTool methodsFor: 'menus' stamp: 'md 4/30/2008 15:39' prior: 23247589!methodListMenu: aMenu	"Build the menu for the selected method, if any."		self selectedMessageName ifNotNil: [	aMenu addList:#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('copy selector (c)'						copySelector)).		aMenu addList: #(			-			('browse senders (n)'						browseSendersOfMessages)			('browse implementors (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)		('change sets with this method'			findMethodInChangeSets)"		('x revert to previous version'				revertToPreviousVersion)"		('remove from current change set'		removeFromCurrentChanges)"		('x revert & remove from changes'		revertAndForget)"		('add to current change set'				adoptMessageInCurrentChangeset)"		('x copy up or copy down...'				copyUpOrCopyDown)""		('x remove method (x)'					removeMessage)"		"-"		).	]."	aMenu addList: #(			('x inst var refs...'						browseInstVarRefs)			('x inst var defs...'						browseInstVarDefs)			('x class var refs...'						browseClassVarRefs)			('x class variables'						browseClassVariables)			('x class refs (N)'							browseClassRefs)	)."	^ aMenu! !!MCCodeTool methodsFor: 'menus' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23249044!openSingleMessageBrowser	| msgName mr |	"Create and schedule a message list browser populated only by the currently selected message"	(msgName := self selectedMessageName) ifNil: [^ self].	mr := MethodReference new		setStandardClass: self selectedClassOrMetaClass		methodSymbol: msgName.	self systemNavigation 		browseMessageList: (Array with: mr)		name: mr asStringOrText		autoSelect: nil! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 20:55' prior: 23249513!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!MCCodeTool methodsFor: 'menus' stamp: 'nk 11/10/2003 21:00' prior: 23250237!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	ChangeSet current removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.	self changed: #annotations! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:02' prior: 23250708!selectedClass	"Answer the class that is selected, or nil"	self subclassResponsibility! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:02' prior: 23250879!selectedClassOrMetaClass	"Answer the class that is selected, or nil"	self subclassResponsibility! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:02' prior: 23251061!selectedMessageCategoryName	"Answer the method category of the method that is selected, or nil"	self subclassResponsibility! !!MCCodeTool methodsFor: 'subclassResponsibility' stamp: 'nk 11/10/2003 22:02' prior: 23251270!selectedMessageName	"Answer the name of the selected message"	self subclassResponsibility! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:07' prior: 23214199!buttonSpecs	^ #((Select select 'Select these changes')		 (Cancel cancel 'Cancel the operation')		)! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:26' prior: 23214387!cancel	self answer: nil! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/14/2004 15:01' prior: 23214498!defaultLabel	^ 'Change Selector'! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:13' prior: 23214618!innerButtonRow	^ self buttonRow:		#(('Select All' selectAll 'select all changes')		  ('Select None' selectNone 'select no changes'))! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23214851!kept	^ kept ifNil: [kept := Set new]! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:22' prior: 23214975!listSelectionAt: aNumber	^ self kept includes: (self items at: aNumber)! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23215145!listSelectionAt: aNumber put: aBoolean	| item |	item := self items at: aNumber.	aBoolean		ifTrue: [self kept add: item ]		ifFalse: [self kept remove: item ifAbsent: []]! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:26' prior: 23215405!select	self answer: (MCPatch operations: kept)! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/14/2004 15:00' prior: 23215539!selectAll	kept addAll: self items.	self changed: #list! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23215693!selectNone	kept := Set new.	self changed: #list! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 16:25' prior: 23215829!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((buttonRow) (0 0 1 0) (0 0 0 30))		((multiListMorph:selection:listSelection:menu: list selection listSelectionAt: methodListMenu:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: text) (0 0.4 1 1) (0 30 0 0))		)].	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((multiListMorph:selection:listSelection:menu: list selection listSelectionAt: methodListMenu:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: annotations) (0 0.4 1 0.4) (0 30 0 60))		((textMorph: text) (0 0.4 1 1) (0 60 0 0))		)! !!MCMergeBrowser class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23367634!resolveConflictsInMerger: aMerger	| inst |	inst := self new merger: aMerger.	^ inst showModally ifNil: [false]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:35' prior: 23362658!buttonSpecs	^ #((Merge merge 'Proceed with the merge' canMerge)		 (Cancel cancel 'Cancel the merge')		('All Newer' chooseAllNewerConflicts 'Choose all newer conflict versions')		('All Older' chooseAllOlderConflicts 'Choose all older conflict versions')		('Rest Local' chooseAllUnchosenLocal 'Choose local versions of all remaining conflicts')		('Rest Remote' chooseAllUnchosenRemote 'Choose remote versions of all remaining conflicts'))! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/22/2003 00:51' prior: 23363295!canMerge	^ merger isMerged! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 17:52' prior: 23363185!cancel	self answer: false! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:21' prior: 23363407!chooseAllNewerConflicts	conflicts do: [ :ea | ea chooseNewer ].	self changed: #text; changed: #list.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:22' prior: 23363594!chooseAllOlderConflicts	conflicts do: [ :ea | ea chooseOlder ].	self changed: #text; changed: #list.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:34' prior: 23363781!chooseAllUnchosenLocal	conflicts do: [ :ea | ea isResolved ifFalse: [ ea chooseLocal ] ].	self changed: #text; changed: #list.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/21/2003 23:34' prior: 23363994!chooseAllUnchosenRemote	conflicts do: [ :ea | ea isResolved ifFalse: [ ea chooseRemote ] ].	self changed: #text; changed: #list.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:41' prior: 23364208!chooseLocal	self conflictSelectionDo:		[selection chooseLocal.		self changed: #text; changed: #list]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:41' prior: 23364395!chooseRemote	self conflictSelectionDo:		[selection chooseRemote.		self changed: #text; changed: #list]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:41' prior: 23364584!clearChoice	self conflictSelectionDo:		[selection clearChoice.		self changed: #text; changed: #list]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:42' prior: 23364771!conflictSelectionDo: aBlock	self selectionIsConflicted		ifTrue: aBlock		ifFalse: [self inform: 'You must have a conflict selected']! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 21:31' prior: 23364989!defaultLabel	^ 'Merge Browser'! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:04' prior: 23365104!getConflictMenu: aMenu	selection remoteChosen		ifTrue: [aMenu add: 'undo keep change' target: self selector: #clearChoice]		ifFalse: [aMenu add: 'keep change' target: self selector: #chooseRemote].	selection localChosen		ifTrue: [aMenu add: 'undo reject change' target: self selector: #clearChoice]			ifFalse: [aMenu add: 'reject change' target: self selector: #chooseLocal].	^ aMenu! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:07' prior: 23365578!getMenu: aMenu	selection ifNil: [^ aMenu].	^ self selectionIsConflicted		ifTrue: [self getConflictMenu: aMenu]		ifFalse: [self getOperationMenu: aMenu]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 16:37' prior: 23365817!getOperationMenu: aMenu	^ aMenu! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/22/2003 00:49' prior: 23365933!innerButtonRow	^ self buttonRow:		#((Keep chooseRemote 'keep the selected change' selectionIsConflicted)		  (Reject chooseLocal 'reject the selected change' selectionIsConflicted))! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 16:32' prior: 23366200!items	^ conflicts, items! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 17:52' prior: 23366309!merge	merger isMerged		ifFalse: [self inform: 'You must resolve all the conflicts first']		ifTrue: [self answer: true] ! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23366527!merger: aMerger	merger := aMerger.	items := aMerger operations asSortedCollection.	conflicts := aMerger conflicts.! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:07' prior: 23366728!selectionIsConflicted	^ selection isKindOf: MCConflict! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nk 11/10/2003 22:08' prior: 23366868!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph:selection:menu: list selection methodListMenu:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: text) (0 0.4 1 1) (0 30 0 0))		)].	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph:selection:menu: list selection methodListMenu:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: annotations) (0 0.4 1 0.4) (0 30 0 60))		((textMorph: text) (0 0.4 1 1) (0 60 0 0))		)! !!MCPatchBrowser class methodsFor: 'as yet unclassified' stamp: 'ab 7/16/2003 14:35' prior: 23439922!forPatch: aPatch	^ self new patch: aPatch! !!MCPatchBrowser methodsFor: 'as yet unclassified' stamp: 'nk 11/10/2003 21:41' prior: 23435302!annotations	^selection ifNil: [ super annotations ]		ifNotNil: [ selection annotations ]! !!MCPatchBrowser methodsFor: 'morphic ui' stamp: 'ab 8/22/2003 02:21' prior: 23436530!buttonSpecs	^ #((Invert invert 'Show the reverse set of changes')		 (Export export 'Export the changes as a change set'))! !!MCPatchBrowser methodsFor: 'as yet unclassified' stamp: 'nk 2/23/2005 08:04' prior: 23435476!changeSetNameForInstall	"Answer the name of the change set into which my selection will be installed.	Derive this from my label.	If I have no label, use the current change set."	| tokens |	label ifNil: [ ^ChangeSet current name ].	tokens := label findTokens: ' '.	tokens removeAllFoundIn: { 'changes'. 'between'. 'and' }.	(tokens size = 3 and: [ tokens second = '<working' ]) ifTrue: [ ^tokens first, '-to-working' ].	tokens size = 2 ifFalse: [ ^'InstalledPatches' ].	^'{1}-to-{2}' format: tokens ! !!MCPatchBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 21:31' prior: 23436728!defaultLabel	^ 'Patch Browser'! !!MCPatchBrowser methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:30' prior: 23436080!installSelection	| loader |	selection ifNotNil:		[loader := MCPackageLoader newCurrent.		selection applyTo: loader.		loader loadWithName: self changeSetNameForInstall ]! !!MCPatchBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23437796!invert	items := items collect: [:ea | ea inverse].	self changed: #list; changed: #text; changed: #selection! !!MCPatchBrowser methodsFor: 'accessing' stamp: 'ab 7/16/2003 14:36' prior: 23434936!items	^ items! !!MCPatchBrowser methodsFor: 'accessing' stamp: 'ab 7/16/2003 14:39' prior: 23435024!list	^ self items collect: [:ea | ea summary]! !!MCPatchBrowser methodsFor: 'menus' stamp: 'bf 3/5/2006 14:10' prior: 23436318!methodListMenu: aMenu	selection ifNotNil:		[aMenu addList:#(			('install'	 installSelection)			('revert'	 revertSelection)			-)].	super methodListMenu: aMenu.	^ aMenu! !!MCPatchBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23435156!patch: aPatch	items := aPatch operations asSortedCollection! !!MCPatchBrowser methodsFor: 'morphic ui' stamp: 'nk 11/10/2003 20:55' prior: 23436835!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!MCPatchBrowser methodsFor: 'as yet unclassified' stamp: 'kph 12/7/2008 02:30'!revertSelection	| loader |	selection ifNotNil:		[loader := MCPackageLoader newCurrent.		selection inverse applyTo: loader.		loader loadWithName: self changeSetNameForInstall ]! !!MCPatchBrowser methodsFor: 'subclassResponsibility' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23438389!selectedClass	| definition |	selection ifNil: [ ^nil ].	(definition := selection definition) ifNil: [ ^nil ].	definition isMethodDefinition ifFalse: [ ^nil ].	^Smalltalk at: definition className ifAbsent: [ ]! !!MCPatchBrowser methodsFor: 'subclassResponsibility' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23438701!selectedClassOrMetaClass	| definition |	selection ifNil: [ ^nil ].	(definition := selection definition) ifNil: [ ^nil ].	definition isMethodDefinition ifFalse: [ ^nil ].	^definition actualClass! !!MCPatchBrowser methodsFor: 'subclassResponsibility' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23438998!selectedMessageCategoryName	| definition |	selection ifNil: [ ^nil ].	(definition := selection definition) ifNil: [ ^nil ].	definition isMethodDefinition ifFalse: [ ^nil ].	^definition category! !!MCPatchBrowser methodsFor: 'subclassResponsibility' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23439295!selectedMessageName	| definition |	selection ifNil: [ ^nil ].	(definition := selection definition) ifNil: [ ^nil ].	definition isMethodDefinition ifFalse: [ ^nil ].	^definition  selector! !!MCPatchBrowser methodsFor: 'selecting' stamp: 'ab 7/16/2003 14:30' prior: 23437979!selection	^ selection 		ifNil: [0]		ifNotNil: [self items indexOf: selection]! !!MCPatchBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23438145!selection: aNumber	selection := aNumber = 0 ifFalse: [self items at: aNumber].	self changed: #selection; changed: #text; changed: #annotations! !!MCPatchBrowser methodsFor: 'text' stamp: 'ab 7/16/2003 14:40' prior: 23439556!text	^ selection ifNil: [''] ifNotNil: [selection source]! !!MCPatchBrowser methodsFor: 'text' stamp: 'ab 7/16/2003 14:27' prior: 23439683!text: aTextOrString	self changed: #text! !!MCPatchBrowser methodsFor: 'morphic ui' stamp: 'mtf 10/7/2008 18:32' prior: 23437245!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((listMorph:selection:menu:keystroke: list selection methodListMenu: methodListKey:from: ) (0 0 1 0.4) (0 0 0 0))		((textMorph: text) (0 0.4 1 1))		) ].	^ {		#((listMorph:selection:menu:keystroke: list selection methodListMenu: methodListKey:from: ) (0 0 1 0.4) (0 0 0 0)).		{ #(textMorph: annotations). #(0 0.4 1 0.4). { 0. 0. 0. self defaultAnnotationPaneHeight. } }.		{ #(textMorph: text). #(0 0.4 1 1). { 0. self defaultAnnotationPaneHeight. 0. 0. } }.		}! !!MCSnapshotBrowser class methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 18:03' prior: 23504206!forSnapshot: aSnapshot	^ self new snapshot: aSnapshot! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 12/6/2008 23:29' prior: 23491961!allClassNames	^ (items 		select: [:ea | ea isOrganizationDefinition not and: [ ea isFileDefinition not ]] 		thenCollect: [:ea | ea className]) asSet.! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'nk 7/24/2003 13:40' prior: 23502738!annotations	methodSelection ifNotNil: [^ methodSelection annotations ].	^ ''! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'nk 7/24/2003 13:41' prior: 23502888!annotations: stuff	self changed: #annotations! !!MCSnapshotBrowser methodsFor: 'morphic ui' stamp: 'bf 5/27/2005 19:33' prior: 23498262!buttonSpecs	^ #(('instance' switchBeInstance 'show instance' buttonEnabled switchIsInstance)		('?' switchBeComment 'show comment' buttonEnabled switchIsComment)		('class' switchBeClass 'show class' buttonEnabled switchIsClass))! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/10/2003 18:33' prior: 23494614!categoryList	^ self visibleCategories! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'nk 4/17/2004 09:52' prior: 23496135!categoryListMenu: aMenu 	categorySelection		ifNotNil: [aMenu				add: (categorySelection = '*Extensions'						ifTrue: ['load all extension methods' translated]						ifFalse: ['load class category {1}' translated format: {categorySelection}])				action: #loadCategorySelection].	^ aMenu! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'cwp 7/10/2003 18:33' prior: 23499684!categorySelection	^ categorySelection ifNil: [0] ifNotNil: [self visibleCategories indexOf: categorySelection]! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23499884!categorySelection: aNumber	categorySelection := aNumber = 0 ifFalse: [self visibleCategories at: aNumber].	self classSelection: 0.	self changed: #categorySelection;		changed: #annotations;		changed: #classList.! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'ab 7/18/2003 15:48' prior: 23503006!classCommentString	^ (items 		detect: [:ea | ea isClassDefinition and: [ea className = classSelection]]		ifNone: [^ '']) comment.! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'kph 12/7/2008 04:15' prior: 23503222!classDefinitionString	| def |	def := self packageClasses 			detect: [ : ea | ea className = classSelection] ifNone: [ ^ 'This class is defined elsewhere.' ].	^ String streamContents: [:stream | 		def printDefinitionAndCommentOn: stream	].! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/10/2003 20:20' prior: 23494728!classList	^ self visibleClasses! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 5/13/2007 04:29' prior: 23496499!classListMenu: aMenu 	classSelection ifNil: [ ^aMenu ].	super classListMenu: aMenu.	aMenu		addLine;				add: ('load class {1} (all)' translated format: {classSelection})				action: #loadClassSelection;				add: ('load class {1} (defn only) '  format: {classSelection})				action: #loadClassSelectionDefinition.	^ aMenu! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'cwp 7/10/2003 18:28' prior: 23500178!classSelection	^ classSelection ifNil: [0] ifNotNil: [self visibleClasses indexOf: classSelection]! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23500366!classSelection: aNumber	classSelection := aNumber = 0 ifFalse: [self visibleClasses at: aNumber].	self protocolSelection: 0.	self changed: #classSelection; 		changed: #protocolList;		changed: #annotations;		changed: #methodList.! !!MCSnapshotBrowser methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:29' prior: 23498570!defaultExtent	^ 650@400.! !!MCSnapshotBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 21:31' prior: 23498673!defaultLabel	^ 'Snapshot Browser'! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'kph 5/13/2007 04:29'!definitionsForSelectedClassCategory	| visibleClasses |	visibleClasses := self visibleClasses.	^ items select: [:ea | visibleClasses includes: ea className ]								! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 5/11/2007 04:45' prior: 23492159!extensionClassNames 	^ (self allClassNames difference: self packageClassNames) asSortedCollection! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'ab 7/5/2003 23:41' prior: 23492332!extensionsCategory	^ '*Extensions'! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 12/6/2008 23:09'!fileDefinitions	^ items select: [:ea | ea isFileDefinition ]! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 12/6/2008 23:05'!filesCategory	^ ':FILES'! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'cwp 7/10/2003 18:03' prior: 23496784!inspectSelection	^ self methodSelection inspect! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'kph 5/13/2007 04:13' prior: 23496905!loadCategorySelection 	categorySelection ifNil: [ ^self ]. 	(MCSnapshot fromDefinitions: self definitionsForSelectedClassCategory ) install! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'kph 5/15/2007 11:59' prior: 23497132!loadClassSelection	| defns |	classSelection ifNil: [ ^self ].		"defns := self methodsForSelectedClass.		defns add: (self packageClasses 						detect: [ :ea | ea className = classSelection ] 						ifNone: [ ^self ])."	"easier implementation"		defns := items select: [ :d | (d respondsTo: #className) and: [ d className = classSelection ] ].		(MCSnapshot fromDefinitions: defns) install! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'kph 12/7/2008 02:30'!loadClassSelectionDefinition	| classDefinition |		classSelection ifNil: [ ^self ].	classDefinition := items 		detect: [ :defn | defn isClassDefinition and: [ defn className = classSelection ] ].		(MCPackageLoader newCurrent) 		addDefinition: classDefinition;		load	! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'kph 2/7/2009 18:24' prior: 23497403!loadMethodSelection	methodSelection ifNil: [ ^self ].	(MCPackageLoader1b new) 		addDefinition: methodSelection;		load ! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'kph 5/13/2007 04:07' prior: 23497553!loadProtocolSelection	protocolSelection ifNil: [ ^self ].		(MCSnapshot fromDefinitions: self methodsForSelectedProtocol) install! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/13/2003 02:11' prior: 23494836!methodList	^ self visibleMethods collect: [:ea | ea selector]! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'kph 5/13/2007 04:23' prior: 23497738!methodListMenu: aMenu 	super methodListMenu: aMenu.	self selectedMessageName		ifNotNilDo: [:msgName | aMenu addLine; add: 'debug/load method' translated action: #loadMethodSelection].	^ aMenu! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'cwp 7/10/2003 20:26' prior: 23500679!methodSelection	^ methodSelection			ifNil: [0] 			ifNotNil: [self visibleMethods indexOf: methodSelection]! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23500877!methodSelection: aNumber	methodSelection := aNumber = 0 ifFalse: [self visibleMethods at: aNumber].	self changed: #methodSelection; changed: #text; changed: #annotations! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 5/3/2007 19:17' prior: 23492444!methodsForSelectedClass 	^ items select: [:ea | (ea className = classSelection) 									and: [ea isMethodDefinition] ].! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 5/3/2007 19:17'!methodsForSelectedClassSide 	^  self methodsForSelectedClass select: [:ea | ea classIsMeta = self switchIsClass ].! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 5/3/2007 19:17' prior: 23493042!methodsForSelectedProtocol	| methods |	protocolSelection ifNil: [^ Array new].	methods := self methodsForSelectedClassSide asOrderedCollection.	(protocolSelection = '-- all --') 		ifFalse: [methods removeAllSuchThat: [:ea | ea category ~= protocolSelection]].	^ methods 									! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'ab 7/18/2003 15:48' prior: 23493539!packageClassNames	^ self packageClasses collect: [:ea | ea className]! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'kph 5/11/2007 04:47' prior: 23493402!packageClasses	^ items select: [:ea | (ea isClassDefinition or: [ea isClassDefinitionExtension]) ]! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/10/2003 19:07' prior: 23494974!protocolList	^ self visibleProtocols! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'nk 4/17/2004 09:43' prior: 23498000!protocolListMenu: aMenu 	protocolSelection		ifNotNil: [aMenu				add: ('load protocol ''{1}''' translated format: {protocolSelection})				action: #loadProtocolSelection ].	^ aMenu! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'cwp 7/10/2003 19:35' prior: 23501126!protocolSelection	^ protocolSelection 		ifNil: [0]		ifNotNil: [self visibleProtocols indexOf: protocolSelection]! !!MCSnapshotBrowser methodsFor: 'selecting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23501330!protocolSelection: anInteger	protocolSelection := (anInteger = 0 ifFalse: [self visibleProtocols at: anInteger]).	self methodSelection: 0.	self changed: #protocolSelection;		changed: #methodList;			changed: #annotations! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'nk 10/11/2003 16:53' prior: 23493687!selectedClass	classSelection ifNil: [ ^nil ].	^Smalltalk at: classSelection ifAbsent: [ nil ].! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23493873!selectedClassOrMetaClass	| class |	classSelection ifNil: [ ^nil ].	class := Smalltalk at: classSelection ifAbsent: [ ^nil ].	^self switchIsClass ifTrue: [ class class ]		ifFalse: [ class ].! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'kph 12/6/2008 23:26'!selectedFileSource 		^ (self fileDefinitions detect: [ :ea | ea path = classSelection ] ifNone: [ ^ 'file?' ]) source! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'nk 11/10/2003 21:29' prior: 23494145!selectedMessageCategoryName	^protocolSelection! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'nk 10/11/2003 16:45' prior: 23494270!selectedMessageName	^methodSelection ifNotNil: [^ methodSelection selector ].! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'cwp 7/12/2003 18:57' prior: 23501630!signalSwitchChanged	self protocolSelection: 0.	self 		changed: #switchIsInstance;		changed: #switchIsComment;		changed: #switchIsClass;		changed: #protocolList;		changed: #methodList;		changed: #text.! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23494438!snapshot: aSnapshot	items := aSnapshot definitions asSortedCollection.	self categorySelection: 0.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23501924!switchBeClass	switch := #class.	self signalSwitchChanged.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23502069!switchBeComment	switch := #comment.	self signalSwitchChanged.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23502218!switchBeInstance	switch := #instance.	self signalSwitchChanged.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'cwp 7/12/2003 18:05' prior: 23502358!switchIsClass	^ switch = #class! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'cwp 7/12/2003 18:04' prior: 23502465!switchIsComment	^ switch = #comment.! !!MCSnapshotBrowser methodsFor: 'switch' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23502588!switchIsInstance	switch ifNil: [switch := #instance].	^ switch = #instance.! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'kph 12/6/2008 23:22' prior: 23503669!text	self switchIsComment ifTrue: [^ self classCommentString].	methodSelection ifNotNil: [^ methodSelection source].	protocolSelection ifNotNil: [^ ''].	categorySelection = self filesCategory ifTrue: [ ^ self selectedFileSource ].	classSelection ifNotNil: [^ self classDefinitionString].		^ ''! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'cwp 7/11/2003 00:30' prior: 23503961!text: aTextOrString	self changed: #text! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'kph 12/6/2008 23:24' prior: 23495086!visibleCategories	| cl |	cl := (self packageClasses collect: [:ea | ea category]) 			asSet asSortedCollection 			add: self extensionsCategory;			yourself.				self fileDefinitions size > 0 ifTrue: [ cl add: self filesCategory ].		^ cl! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'kph 2/15/2009 16:08' prior: 23495301!visibleClasses	categorySelection = self filesCategory ifTrue: [ 		^ self fileDefinitions collect: [:f | f path]	].	^ categorySelection = self extensionsCategory		ifTrue: [self extensionClassNames]		ifFalse: [self packageClasses					select: [:ea | ea category = categorySelection]					thenCollect: [:ea | ea className]].! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'cwp 7/10/2003 19:46' prior: 23495601!visibleMethods	^ classSelection 		ifNil: [#()]		ifNotNil: [self methodsForSelectedProtocol]! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'kph 5/3/2007 19:18' prior: 23495782!visibleProtocols	| methods protocols |	self switchIsComment ifTrue: [^ Array new].	methods := self methodsForSelectedClassSide.	protocols := (methods collect: [:ea | ea category]) asSet asSortedCollection.	(protocols size > 1) ifTrue: [protocols add: '-- all --'].	^ protocols ! !!MCSnapshotBrowser methodsFor: 'morphic ui' stamp: 'bf 5/27/2005 19:13' prior: 23498785!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((listMorph: category) (0 0 0.25 0.4))		((listMorph: class) (0.25 0 0.50 0.4) (0 0 0 -30))		((listMorph: protocol) (0.50 0 0.75 0.4))		((listMorph:selection:menu:keystroke:  methodList methodSelection methodListMenu: methodListKey:from:) (0.75 0 1 0.4))		((buttonRow) (0.25 0.4 0.5 0.4) (0 -30 0 0))		((textMorph: text) (0 0.4 1 1))		) ].	^#(		((listMorph: category) (0 0 0.25 0.4))		((listMorph: class) (0.25 0 0.50 0.4) (0 0 0 -30))		((listMorph: protocol) (0.50 0 0.75 0.4))		((listMorph:selection:menu:keystroke:  methodList methodSelection methodListMenu: methodListKey:from:) (0.75 0 1 0.4))		((buttonRow) (0.25 0.4 0.5 0.4) (0 -30 0 0))		((textMorph: annotations) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: text) (0 0.4 1 1) (0 30 0 0))		)! !!MCConfigurationBrowser class methodsFor: 'class initialization' stamp: 'bf 3/21/2005 19:46' prior: 23279415!initialize	TheWorldMenu registerOpenCommand: { 'Monticello Configurations' . { self . #open }. 'Monticello Configuration Browser' }.! !!MCConfigurationBrowser class methodsFor: 'opening' stamp: 'bf 3/21/2005 19:50' prior: 23279635!open	^self new show! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 22:08' prior: 23263247!add	(self pickWorkingCopiesSatisfying: [:each | (self includesPackage: each package) not])		do: [:wc |			wc ancestors isEmpty				ifTrue: [self inform: 'You must save ', wc packageName, ' first!!Skipping this package']				ifFalse: [					self dependencies add: (MCVersionDependency						package: wc package						info: wc ancestors first)]].	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 3/23/2005 22:08' prior: 23267810!addDependency	(self pickWorkingCopiesSatisfying: [:each | (self includesPackage: each package) not])		do: [:wc |			wc ancestors isEmpty				ifTrue: [self inform: 'You must save ', wc packageName, ' first!!Skipping this package']				ifFalse: [					self dependencies add: (MCVersionDependency						package: wc package						info: wc ancestors first)]].	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'djr 6/27/2008 18:41' prior: 23274190!addRepository	(self pickRepositorySatisfying: [:ea | (self repositories includes: ea) not])		ifNotNilDo: [:repo |			((repo isKindOf: MCHttpRepository) | (repo isKindOf: MCDirectoryRepository))				ifFalse: [^self inform: 'Only HTTP or Directory repositories are supported'].			self repositories add: repo.			self changed: #repositoryList.		]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 6/22/2005 12:26' prior: 23271159!buttonSpecs	^ #(('Add' add 'Add a dependency')		('Update' updateMenu 'Update dependencies')		('Install' installMenu 'Load/Merge/Upgrade into image')		('Up' up 'Move item up in list' canMoveUp)		('Down' down 'Move item down in list' canMoveDown)		('Remove' remove 'Remove item' canRemove)		('Store' store 'store configuration')		('Post' post 'Post this configuration to an update stream')		)! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/23/2005 20:44' prior: 23278366!canMoveDown	^self index between: 1 and: self maxIndex - 1 ! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/23/2005 20:44' prior: 23278505!canMoveUp	^self index > 1! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/23/2005 20:45' prior: 23278611!canRemove	^self index > 0! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 5/27/2005 19:54' prior: 23275873!changedButtons	self changed: #canMoveDown.	self changed: #canMoveUp.	self changed: #canRemove.! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:55' prior: 23276052!changedList	self dependencyIndex > 0 ifTrue: [^self changed: #dependencyList].	self repositoryIndex > 0 ifTrue: [^self changed: #repositoryList].	self error: 'nothing selected'! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:36' prior: 23268306!checkDependencies	^self checkModified and: [self checkMissing]! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:35' prior: 23268454!checkMissing	| missing |	missing := (self dependencies collect: [:ea | ea versionInfo name]) asSet.	self repositories		do: [:repo |			repo allVersionNames				do: [:found | missing remove: found ifAbsent: []]]		displayingProgress: 'searching versions'.	^missing isEmpty or: [		self selectDependency: missing anyOne.		self confirm: (String streamContents: [:strm |			strm nextPutAll: 'No repository found for'; cr.			missing do: [:r | strm nextPutAll: r; cr].			strm nextPutAll: 'Do you still want to store?'])]	! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:37' prior: 23269065!checkModified	| modified |	modified := self dependencies select: [:dep |		dep isFulfilled and: [dep package workingCopy modified]].		^modified isEmpty or: [		self selectDependency: modified anyOne.		self confirm: (String streamContents: [:strm |			strm nextPutAll: 'These packages are modified:'; cr.			modified do: [:dep | strm nextPutAll: dep package name; cr].			strm nextPutAll: 'Do you still want to store?'])]	! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'djr 6/27/2008 18:41' prior: 23274566!checkRepositories	| bad |	bad := self repositories reject: [:repo | (repo isKindOf: MCHttpRepository) | (repo isKindOf: MCDirectoryRepository)].	^bad isEmpty or: [		self selectRepository: bad first.		self inform: (String streamContents: [:strm |			strm nextPutAll: 'Please remove these repositories:'; cr.			bad do: [:r | strm nextPutAll: r description; cr].			strm nextPutAll: '(only HTTP or Directory repositories are supported)']).		false].! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/24/2005 00:47' prior: 23275048!checkRepositoryTemplates	"unused for now - we only do HTTP"	| bad |	bad := self repositories select: [:repo | repo creationTemplate isNil].	^bad isEmpty or: [		self selectRepository: bad first.		self inform: (String streamContents: [:strm |			strm nextPutAll: 'Creation template missing for'; cr.			bad do: [:r | strm nextPutAll: r description; cr].			strm nextPutAll: 'Please fill in the details first!!']).		false].! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/21/2005 16:03' prior: 23262325!configuration	^configuration ifNil: [configuration := MCConfiguration new]! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/21/2005 14:56' prior: 23262482!configuration: aConfiguration	configuration := aConfiguration! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 4/19/2005 16:51' prior: 23271641!defaultExtent	^ 350@500! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/21/2005 16:35' prior: 23262626!dependencies	^self configuration dependencies! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 4/19/2005 16:02' prior: 23262755!dependencies: aCollection	self configuration dependencies: aCollection.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 17:56' prior: 23276313!dependencyIndex	^dependencyIndex ifNil: [0]! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 5/27/2005 19:55' prior: 23276439!dependencyIndex: anInteger	dependencyIndex := anInteger.	dependencyIndex > 0		ifTrue: [self repositoryIndex: 0].	self changed: #dependencyIndex; changed: #description.	self changedButtons.! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:28' prior: 23269577!dependencyList	^self dependencies collect: [:dep | 		Text string: dep versionInfo name			attributes: (Array streamContents: [:attr |				dep isFulfilledByAncestors					ifFalse: [attr nextPut: TextEmphasis bold]					ifTrue: [dep isCurrent ifFalse: [attr nextPut: TextEmphasis italic]].			])]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/24/2005 00:20' prior: 23271748!dependencyMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add dependency...' addDependency)).	self selectedDependency ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove dependency...' remove))].	^aMenu! !!MCConfigurationBrowser methodsFor: 'description' stamp: 'bf 4/14/2005 15:37' prior: 23270281!description	self selectedDependency ifNotNilDo: [:dep | ^ ('Package: ', dep package name, String cr,		dep versionInfo summary) asText].	self selectedRepository ifNotNilDo: [:repo | ^repo creationTemplate		ifNotNil: [repo creationTemplate asText]		ifNil: [repo asCreationTemplate asText addAttribute: TextColor red]].	^ ''! !!MCConfigurationBrowser methodsFor: 'description' stamp: 'bf 3/23/2005 22:49' prior: 23270693!description: aText	self selectedRepository ifNotNilDo: [:repo | 		| new | 		new := MCRepository readFrom: aText asString.		(new class = repo class 			and: [new description = repo description])				ifTrue: [					repo creationTemplate: aText asString.					self changed: #description]				ifFalse: [					self inform: 'This does not match the previous definition!!'				]	].! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 21:01' prior: 23263728!down	self canMoveDown ifTrue: [		self list swap: self index with: self index + 1.		self index: self index + 1.		self changedList.	].! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/21/2005 17:15' prior: 23278717!includesPackage: aPackage	^self dependencies anySatisfy: [:each | each package = aPackage]! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:43' prior: 23276714!index	^self dependencyIndex max: self repositoryIndex! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 21:00' prior: 23276850!index: anInteger	self dependencyIndex > 0 ifTrue: [^self dependencyIndex: anInteger].	self repositoryIndex > 0 ifTrue: [^self repositoryIndex: anInteger].	anInteger > 0 ifTrue: [self error: 'cannot select']! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23263958!installMenu	| menu |	menu := MenuMorph new defaultTarget: self.	menu add: 'load packages' action: #load.	menu add: 'merge packages' action: #merge.	menu add: 'upgrade packages' action: #upgrade.	menu popUpInWorld.! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:51' prior: 23277141!list	self dependencyIndex > 0 ifTrue: [^self dependencies].	self repositoryIndex > 0 ifTrue: [^self repositories].	^#()! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 17:42' prior: 23264258!load	self configuration load.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23264435!loadMenu	| menu |	menu := MenuMorph new defaultTarget: self.	menu add: 'update from image' action: #updateFromImage.	menu add: 'update from repositories' action: #updateFromRepositories.	menu popUpInWorld.! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:52' prior: 23277345!maxIndex	^ self list size! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 17:42' prior: 23264727!merge	self configuration merge.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/22/2005 22:01' prior: 23272042!pickName	| name |	name := FillInTheBlank		request: 'Name (.', self configuration writerClass extension, ' will be appended):'		initialAnswer: (self configuration name ifNil: ['']).	^ name isEmpty ifFalse: [name]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/23/2005 21:11' prior: 23272341!pickRepository	^self pickRepositorySatisfying: [:ea | true]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23272497!pickRepositorySatisfying: aBlock	| index list |	list := MCRepositoryGroup default repositories select: aBlock.	index := (PopUpMenu labelArray: (list collect: [:ea | ea description]))		startUpWithCaption: 'Repository:'.	^ index = 0 ifFalse: [list at: index]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23272853!pickWorkingCopiesSatisfying: aBlock	| copies item |	copies := (MCWorkingCopy allManagers select: aBlock)		asSortedCollection: [:a :b | a packageName <= b packageName].	item := (PopUpMenu labelArray: #('match ...'),(copies collect: [:ea | ea packageName]) lines: #(1))				startUpWithCaption: 'Package:'.	item = 1 ifTrue: [		| pattern |		pattern := FillInTheBlank request: 'Packages matching:' initialAnswer: '*'.		^pattern isEmptyOrNil			ifTrue: [#()]			ifFalse: [				(pattern includes: $*) ifFalse: [pattern := '*', pattern, '*'].				copies select: [:ea | pattern match: ea packageName]]	].	^ item = 0		ifTrue: [#()]		ifFalse: [{copies at: item - 1}]! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23264906!post	"Take the current configuration and post an update"	| name update managers names choice |	(self checkRepositories and: [self checkDependencies]) ifFalse: [^self].	name := FillInTheBlank		request: 'Update name (.cs) will be appended):'		initialAnswer: (self configuration name ifNil: ['']).	name isEmpty ifTrue:[^self].	self configuration name: name.	update := MCPseudoFileStream on: (String new: 100).	update localName: name, '.cs'.	update nextPutAll: '"Change Set:		', name.	update cr; nextPutAll: 'Date:			', Date today printString.	update cr; nextPutAll: 'Author:			Posted by Monticello'.	update cr; cr; nextPutAll: 'This is a configuration map created by Monticello."'.	update cr; cr; nextPutAll: '(MCConfiguration fromArray: #'.	self configuration fileOutOn: update.	update nextPutAll: ') upgrade.'.	update position: 0.	managers := Smalltalk at: #UpdateManager ifPresent:[:mgr| mgr allRegisteredManagers].	managers ifNil:[managers := #()].	managers size > 0 ifTrue:[		| servers index |		servers := ServerDirectory groupNames asSortedArray.		names := (managers collect:[:each| each packageVersion]), servers.		index := UIManager default chooseFrom: names lines: {managers size}.		index = 0 ifTrue:[^self].		index <= managers size ifTrue:[			| mgr |			mgr := managers at: index.			^mgr publishUpdate: update.		].		choice := names at: index.	] ifFalse:[		names := ServerDirectory groupNames asSortedArray.		choice := (SelectionMenu labelList: names selections: names) startUp.		choice == nil ifTrue: [^ self].	].	(ServerDirectory serverInGroupNamed: choice) putUpdate: update.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 21:05' prior: 23266609!remove	self canRemove ifTrue: [		self list removeAt: self index.		self changedList.		self updateIndex.	].! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/23/2005 17:41' prior: 23262964!repositories	^ self configuration repositories! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/23/2005 21:15' prior: 23263093!repositories: aCollection	^self configuration repositories: aCollection! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 17:57' prior: 23277453!repositoryIndex	^repositoryIndex ifNil: [0]! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 5/27/2005 19:55' prior: 23277579!repositoryIndex: anInteger	repositoryIndex := anInteger.	repositoryIndex > 0		ifTrue: [self dependencyIndex: 0].	self changed: #repositoryIndex; changed: #description.	self changedButtons.! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/23/2005 21:15' prior: 23275561!repositoryList	^self repositories collect: [:ea | ea description]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/23/2005 21:27' prior: 23273603!repositoryMenu: aMenu	^self fillMenu: aMenu fromSpecs: #(		('add repository...' addRepository)	)! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 23:16' prior: 23277854!selectDependency: aDependency	self dependencyIndex: (self dependencies indexOf: aDependency)! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 23:15' prior: 23278029!selectRepository: aRepository	self repositoryIndex: (self repositories indexOf: aRepository)! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 3/23/2005 17:56' prior: 23269959!selectedDependency	^ self dependencies at: self dependencyIndex ifAbsent: []! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 3/21/2005 16:30' prior: 23270121!selectedPackage	^ self selectedDependency ifNotNilDo: [:dep | dep package]! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/23/2005 17:58' prior: 23275713!selectedRepository	^ self repositories at: self repositoryIndex ifAbsent: []! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 23:38' prior: 23266800!store	(self checkRepositories and: [self checkDependencies]) ifFalse: [^self].	self pickName ifNotNilDo: [:name |		self configuration name: name.		self pickRepository ifNotNilDo: [:repo |			repo storeVersion: self configuration]].! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 20:53' prior: 23267115!up	self canMoveUp ifTrue: [		self list swap: self index with: self index - 1.		self index: self index - 1.		self changedList.	].! !!MCConfigurationBrowser methodsFor: 'updating' stamp: 'bf 5/23/2005 17:44' prior: 23278890!updateFromImage	self configuration updateFromImage.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'updating' stamp: 'bf 5/23/2005 17:44' prior: 23279078!updateFromRepositories	self configuration updateFromRepositories.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 21:00' prior: 23278204!updateIndex	self index > 0 ifTrue: [self index: (self index min: self maxIndex)]! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23267340!updateMenu	| menu |	menu := MenuMorph new defaultTarget: self.	menu add: 'update from image' action: #updateFromImage.	menu add: 'update from repositories' action: #updateFromRepositories.	menu popUpInWorld.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 17:43' prior: 23267633!upgrade	self configuration upgrade.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/23/2005 22:01' prior: 23273785!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph:selection:menu: dependencyList dependencyIndex dependencyMenu:) (0 0 1 1) (0 30 0 -180))		((listMorph:selection:menu: repositoryList repositoryIndex repositoryMenu:) (0 1 1 1) (0 -180 0 -120))		((textMorph: description) (0 1 1 1) (0 -120 0 0))	 	)! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 8/1/2008 12:17' prior: 23476705!accept	self addAsLastComment: (self findTextMorph: #logMessage) text asString.	self answer:		(Array			with: (self findTextMorph: #versionName) text asString			with: (self findTextMorph: #logMessage) text asString)	! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 8/1/2008 12:22'!addAsLastComment: aString	((self lastComments size > 0) and: [self lastComments first = aString])		ifTrue: [ ^ self ].			self lastComments addFirst: aString.	(self lastComments size > self maxCommentHistory)		ifTrue: [LastComments := LastComments copyFrom: 1 to: self maxCommentHistory]! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 8/1/2008 11:59' prior: 23476941!buttonSpecs	^ #((Accept accept 'accept version name and log message')		(Cancel cancel 'cancel saving version')		('Comments...' comment 'use previous comment')		) ! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:41' prior: 23477147!cancel	self answer: nil! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'mtf 12/11/2008 20:25'!comment	| list index |	list := self lastComments collect: [:s | s copyFrom: 1 to: (s size min: 20)].	list ifEmpty: [UIManager default inform: 'No previous comments was entered'. ^ self].	index := UIManager default chooseFrom: list.		"no comment was selected"	index isZero ifTrue: [ ^ self ].		message := self lastComments at: index.	self changed: #logMessage! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:07' prior: 23477260!defaultExtent 	^ 400@300! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:43' prior: 23477374!defaultLabel	^ 'Edit Version Name and Message:'! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 8/1/2008 12:01'!lastComments	LastComments ifNil: [ LastComments := OrderedCollection new].	^ LastComments! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'mtf 12/11/2008 20:24' prior: 23477511!logMessage	^ message ifNil: ['']! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'mtf 7/22/2008 11:00' prior: 23477662!logMessage: aString	message := aString.	self changed: #logMessage.	self accept.! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'AlexandreBergel 8/1/2008 12:21'!maxCommentHistory	^ 15! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:37' prior: 23477818!versionName	^ name! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'kph 6/2/2008 19:41' prior: 23477938!versionName: aString	name := aString withBlanksTrimmed.	self changed: #versionName! !!MCSaveVersionDialog methodsFor: 'as yet unclassified' stamp: 'jrp 7/2/2005 10:33' prior: 23478093!widgetSpecs	^ #(			((textMorph: versionName) (0 0 1 0) (0 0 0 30))		((textMorph: logMessage) (0 0 1 1) (0 30 0 -30))		((buttonRow) (0 1 1 1) (0 -40 0 0))		)! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23556627!answer: anObject	modalValue := anObject.	self close.! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 2/16/2004 16:50' prior: 23556748!arrowKey: aCharacter from: aPluggableListMorph 	"backstop"! !!MCTool methodsFor: 'morphic ui' stamp: 'kph 5/19/2007 00:29'!buildPanelWith: builder	|  panelBuilder |	panelBuilder := MCToolWindowBuilder builder: builder tool: self.	panelBuilder startWithWindow.	self widgetSpecs do:		[:spec | | send fractions offsets origin corner |		send := spec first.		fractions := spec at: 2 ifAbsent: [#(0 0 1 1)].		offsets := spec at: 3 ifAbsent: [#(0 0 0 0)].		origin := (offsets first @ offsets second) 			/ self defaultExtent asFloatPoint			+ (fractions first @ fractions second).		corner := (offsets third @ offsets fourth) 			/ self defaultExtent asFloatPoint			+ (fractions third @ fractions fourth).		panelBuilder frame: (origin corner: corner).		panelBuilder perform: send first withArguments: send allButFirst].	^ panelBuilder build submorphs! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23556886!buildWindow	| window |	window := SystemWindow labelled: self label.	window model: self.	self widgetSpecs do:		[:pair | |send fractions offsets|		send := pair first.		fractions := pair at: 2 ifAbsent: [#(0 0 1 1)].		offsets := pair at: 3 ifAbsent: [#(0 0 0 0)].		window			addMorph: (self perform: send first withArguments: send allButFirst )			fullFrame:				(LayoutFrame					fractions: 					((fractions first)@(fractions second) corner: 						(fractions third)@(fractions fourth))					offsets:						((offsets first)@(offsets second)  corner:							(offsets third)@(offsets fourth)))].	^ window! !!MCTool methodsFor: 'morphic ui' stamp: 'kph 5/18/2007 12:49' prior: 23557576!buildWith: builder	|  windowBuilder |	windowBuilder := MCToolWindowBuilder builder: builder tool: self.	windowBuilder startWithWindow.	self widgetSpecs do:		[:spec | | send fractions offsets origin corner |		send := spec first.		fractions := spec at: 2 ifAbsent: [#(0 0 1 1)].		offsets := spec at: 3 ifAbsent: [#(0 0 0 0)].		origin := (offsets first @ offsets second) 			/ self defaultExtent asFloatPoint			+ (fractions first @ fractions second).		corner := (offsets third @ offsets fourth) 			/ self defaultExtent asFloatPoint			+ (fractions third @ fractions fourth).		windowBuilder frame: (origin corner: corner).		windowBuilder perform: send first withArguments: send allButFirst]. 	^ windowBuilder build! !!MCTool methodsFor: 'morphic ui' stamp: 'bf 5/27/2005 19:19' prior: 23558338!buttonEnabled	^ true! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 18:34' prior: 23558426!buttonRow	^ self buttonRow: self buttonSpecs! !!MCTool methodsFor: 'morphic ui' stamp: 'al 6/21/2008 23:45' prior: 23558550!buttonRow: specArray	| aRow aButton state |	aRow := AlignmentMorph newRow.	aRow 		color: (Display depth <= 8 ifTrue: [Color transparent] ifFalse: [Color gray alpha: 0.2]);		borderWidth: 0.	aRow hResizing: #spaceFill; vResizing: #spaceFill; rubberBandCells: true.	aRow clipSubmorphs: true.	aRow layoutInset: 2@2; cellInset: 1; color: Color white.	aRow wrapCentering: #center; cellPositioning: #leftCenter.	specArray do:		[:triplet |			state := triplet at: 5 ifAbsent: [#buttonState].			aButton := PluggableButtonMorph				on: self				getState: state				action: #performButtonAction:enabled:.			aButton				hResizing: #spaceFill;				vResizing: #spaceFill;				label: triplet first asString;				arguments: (Array with: triplet second with: (triplet at: 4 ifAbsent: [#buttonEnabled])); 				onColor: Color white offColor: Color white.			aRow addMorphBack: aButton.			aButton setBalloonText: triplet third].	^ aRow! !!MCTool methodsFor: 'morphic ui' stamp: 'bf 5/27/2005 19:22' prior: 23559511!buttonSelected	^ false! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:23' prior: 23559601!buttonSpecs	^ #()! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/22/2003 00:45' prior: 23559686!buttonState	^ true! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:42' prior: 23559772!close	self window delete! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 7/24/2003 13:31' prior: 23559864!defaultAnnotationPaneHeight 	"Answer the receiver's preferred default height for new annotation panes."	^ Preferences parameterAt: #defaultAnnotationPaneHeight ifAbsentPut: [25]! !!MCTool methodsFor: 'morphic ui' stamp: 'avi 2/18/2004 19:56' prior: 23560111!defaultBackgroundColor 	^ (Color r: 0.627 g: 0.69 b: 0.976)! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:22' prior: 23560238!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:10' prior: 23560468!defaultExtent	^ 500@500! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:11' prior: 23560559!defaultLabel	^ self class name! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 22:33' prior: 23560657!fillMenu: aMenu fromSpecs: anArray	anArray do:		[:pair |		aMenu add: pair first target: self selector: pair second].	^ aMenu! !!MCTool methodsFor: 'morphic ui' stamp: 'bf 3/16/2005 14:48' prior: 23560852!findListMorph: aSymbol	^ morph submorphs detect: [:ea | (ea respondsTo: #getListSelector) and: [ea getListSelector = aSymbol]] ifNone: []! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 8/24/2003 20:15' prior: 23561057!findTextMorph: aSymbol	^ morph submorphs detect: [:ea | (ea respondsTo: #getTextSelector) and: [ea getTextSelector = aSymbol]] ifNone: []! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:23' prior: 23561262!getMenu: aMenu	^aMenu! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:36' prior: 23561351!label	^ label ifNil: [self defaultLabel]! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23561471!label: aString	label := aString! !!MCTool methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 17:30' prior: 23561570!listMorph: listSymbol	^ self		listMorph: (listSymbol, 'List') asSymbol		selection: (listSymbol, 'Selection') asSymbol		menu: (listSymbol, 'ListMenu:') asSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 2/16/2004 17:03' prior: 23561800!listMorph: listSymbol keystroke: keystrokeSymbol	^ (self		listMorph: (listSymbol, 'List') asSymbol		selection: (listSymbol, 'Selection') asSymbol		menu: (listSymbol, 'ListMenu:') asSymbol)		keystrokeActionSelector: keystrokeSymbol;		yourself! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:46' prior: 23562114!listMorph: listSymbol selection: selectionSymbol	^ PluggableListMorph		on: self		list: listSymbol		selected: selectionSymbol		changeSelected: (selectionSymbol, ':') asSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:46' prior: 23562359!listMorph: listSymbol selection: selectionSymbol menu: menuSymbol	^ PluggableListMorph		on: self		list: listSymbol		selected: selectionSymbol		changeSelected: (selectionSymbol, ':') asSymbol		menu: menuSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 2/16/2004 16:50' prior: 23562640!listMorph: listSymbol selection: selectionSymbol menu: menuSymbol keystroke: keystrokeSymbol	^ (PluggableListMorph		on: self		list: listSymbol		selected: selectionSymbol		changeSelected: (selectionSymbol, ':') asSymbol		menu: menuSymbol)		keystrokeActionSelector: keystrokeSymbol;		yourself! !!MCTool methodsFor: 'morphic ui' stamp: 'avi 9/11/2004 16:19' prior: 23563006!multiListMorph: listSymbol selection: selectionSymbol listSelection: listSelectionSymbol menu: menuSymbol	^ PluggableListMorphOfMany		on: self		list: listSymbol		primarySelection: selectionSymbol		changePrimarySelection: (selectionSymbol, ':') asSymbol		listSelection: listSelectionSymbol		changeListSelection: (listSelectionSymbol, 'put:') asSymbol		menu: menuSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 17:18' prior: 23563660!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!MCTool methodsFor: 'morphic ui' stamp: 'lr 10/5/2003 09:09' prior: 23563448!performButtonAction: anActionSelector enabled: anEnabledSelector	(self perform: anEnabledSelector) 		ifTrue: [ self perform: anActionSelector ]! !!MCTool methodsFor: 'morphic ui' stamp: 'kph 5/13/2007 16:53' prior: 23564074!show	modal := false.	Smalltalk at: #ToolBuilder ifPresent: [:tb |   ^ tb open: self.  ].	^self window openInWorldExtent: self defaultExtent; yourself! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23564306!showLabelled: labelString	modal := false.	self label: labelString.	^(self window)		openInWorldExtent: self defaultExtent;		yourself! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23564521!showModally	modal := true.	self window openInWorldExtent: (400@400).	[self window world notNil] whileTrue: [		self window outermostWorldMorph doOneCycle.	].	morph := nil.	^ modalValue! !!MCTool methodsFor: 'morphic ui' stamp: 'nk 6/12/2004 14:11' prior: 23564778!step! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:36' prior: 23564850!textMorph: aSymbol	^ PluggableTextMorph on: self text: aSymbol accept: (aSymbol, ':') asSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'kph 5/21/2007 12:58'!toolPanel: selectorForTool	| subTool |		subTool := self perform: selectorForTool.		subTool ifNil:[ ^#() ].		^ subTool buildPanelWith: ToolBuilder default. ! !!MCTool methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:27' prior: 23565012!treeMorph: listSymbol	^ self		treeMorph: (listSymbol, 'Tree') asSymbol		selection: (listSymbol, 'SelectionWrapper') asSymbol		menu: (listSymbol, 'TreeMenu:') asSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:43' prior: 23565249!treeMorph: listSymbol selection: selectionSymbol menu: menuSymbol	^ SimpleHierarchicalListMorph		on: self		list: listSymbol		selected: selectionSymbol		changeSelected: (selectionSymbol, ':') asSymbol		menu: menuSymbol		keystroke: nil! !!MCTool methodsFor: 'morphic ui' stamp: 'avi 3/6/2005 22:31' prior: 23565556!treeOrListMorph: aSymbol	^ self treeMorph: aSymbol! !!MCTool methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:40' prior: 23565674!widgetSpecs	^ #()! !!MCTool methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23565771!window	^ morph ifNil: [morph := self buildWindow]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23586340!ancestry: anAncestry	ancestry := anAncestry! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'avi 2/13/2004 01:10' prior: 23586468!baseSnapshot	^ self snapshotForInfo: ancestry! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'ab 7/17/2003 15:41' prior: 23588389!defaultExtent	^ 440@169.	! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'avi 2/13/2004 01:09' prior: 23588501!defaultLabel	^ ancestry name, ' History'! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'avi 2/13/2004 01:09' prior: 23588627!getMenu: aMenu	index < 2 ifTrue: [^ aMenu].	self fillMenu: aMenu fromSpecs: 		(Array			with: (Array with: 'view changes -> ', ancestry name with: #viewChanges)			with: #('spawn history' spawnHistory)).	^ aMenu! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 8/22/2003 01:41' prior: 23586597!index	"Answer the value of index"	^ index! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23586736!index: anObject	"Set the value of index"	index := anObject! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23586892!infos	^ infos ifNil: [infos := ancestry withBreadthFirstAncestors]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'avi 9/17/2005 16:10' prior: 23587043!list	^ self infos collect: [:ea | ea name]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23587181!package: aMCPackage	package := aMCPackage! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 8/7/2003 21:27' prior: 23587305!repositoryGroup	^ MCRepositoryGroup default! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'avi 9/17/2005 16:09' prior: 23587433!selectedInfo	^ self infos at: self selection ifAbsent: [nil]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 8/22/2003 01:39' prior: 23587577!selectedSnapshot	^ self snapshotForInfo: self selectedInfo! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 7/11/2003 23:24' prior: 23587719!selection	^ index ifNil: [0]! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23587843!selection: aNumber	index := aNumber.	self changed: #selection; changed: #summary! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'ab 8/22/2003 01:38' prior: 23588008!snapshotForInfo: aVersionInfo	^ (self repositoryGroup versionWithInfo: aVersionInfo) snapshot! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'avi 2/13/2004 01:10' prior: 23588927!spawnHistory	MCVersionHistoryBrowser new		ancestry: self selectedInfo;		package: package;		show! !!MCVersionHistoryBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23588197!summary	| selInfo |	selInfo := self selectedInfo.	^ selInfo 		ifNil: ['']		ifNotNil: [selInfo summary]! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23589122!viewChanges	"Note that the patchLabel will be parsed in MCPatchBrowser>>installSelection, so don't translate it!!"	| patch patchLabel |	patchLabel := 'changes between {1} and {2}' format: { self selectedInfo name. ancestry name }.	patch := self baseSnapshot patchRelativeToBase: self selectedSnapshot.	(MCPatchBrowser forPatch: patch) label: patchLabel; show! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'nk 7/28/2003 18:05' prior: 23589569!widgetSpecs	^ #(		((listMorph:selection:menu: list selection getMenu:) (0 0 0.3 1))		((textMorph: summary) (0.3 0 1 1))	 	)! !!MCWorkingHistoryBrowser methodsFor: 'as yet unclassified' stamp: 'ab 8/22/2003 01:37' prior: 23663051!baseSnapshot	^ package snapshot! !!MCChangeLogEntry class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 10:36'!forVersion: aVersion in: repository	^self basicNew		version: aVersion;		repository: repository;		show;		yourself.		! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 2/8/2009 03:26'!ancestors	^ancestors ifNil: [ |  infosOfAncestors |		infosOfAncestors := self version info ancestors.		ancestors := infosOfAncestors collect: [:each | self versionForName: each name ] ]	! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 2/8/2009 03:26'!changesAccordingTo: anAncestor	^ anAncestor snapshot patchRelativeToBase: version snapshot! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 2/8/2009 03:26'!fileNameForVersionName: aVersionName	| fileNames |	fileNames := [(repository allFileNamesForVersionNamed: aVersionName)]		on: Error do: [self error: 'No such version in this repository'].	(fileNames size = 0) ifTrue: [self error: 'No file for this version'].	(fileNames size = 1) ifFalse: [self error: 'What to do with multiple files?' ].	^fileNames first	! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 10:54'!report	^ String streamContents: [ :str | self writeOn: str ].! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 2/8/2009 03:26'!repository: aRepository	repository := aRepository! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 10:43'!versionForName: aVersionName	^ repository versionFromFileNamed: (self fileNameForVersionName: aVersionName)! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 10:56'!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((textMorph: summary) (0 0 1 0.5) (0 30 0 0))		((textMorph: report) (0 0.5 1 1) (0 0 0 0))		)! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 10:39'!writeChanges: anMCPatch  on: aStream	anMCPatch operations asSortedCollection do: [:each |		aStream nextPutAll: each summary; cr ]! !!MCChangeLogEntry methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 10:57'!writeOn: aStream	"aStream 		nextPutAll: version info summary; cr."	self ancestors do: [:each |		aStream 			cr; 			nextPutAll: 'Changes from: ';			nextPutAll: each info name;			cr.		self writeChanges: (self changesAccordingTo: each) on: aStream]! !!MCRepositoryVersionsInspector commentStamp: 'kph 5/16/2007 23:22' prior: 0!Customize the MCVersionInspector to show a list of versions from a repository.!!MCDictionaryRepositoryInspector class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:44'!initialOpenOnLeft: aDictRepository right: aWorkingCopy	 	^ (self new) initialSetLeft: aDictRepository andRight: (self workingCopyRepositoryWith: aWorkingCopy)! !!MCDictionaryRepositoryInspector class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:49'!workingCopyRepositoryWith: aWorkingCopy 	| dict |		dict :=  (MCDictionaryRepository new)		 		description: 'Working Copy (In Memory)'.					aWorkingCopy ifNotNil: [ 			dict	 at: aWorkingCopy name put: aWorkingCopy 	].	^ dict! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:45'!defaultLabel	^'Compare: ' , repositories first description, ' vs ', repositories second description! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:23'!initialSetLeft: l andRight: rrepositories := Array with: l with: r ! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 15:21'!sortedAndHighlightedVersions: someVersions	 	^ (self sortedVersions: (someVersions)) collect: [ :each | self versionHighlight: each fourth ]! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 15:23'!sortedVersions: someVersions	| sorter |	sorter := MCVersionSorter new.	sorter addAllVersionInfos: someVersions.	^ sorter sortedVersionInfos select: [:ea | someVersions includes: ea]! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:40'!swapSides	repositories := repositories reverse.	! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 00:20'!versionsLeftList	 	^ self sortedAndHighlightedVersions: repositories first heldVersions! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 00:20'!versionsRightList	 	^ self sortedAndHighlightedVersions: repositories last heldVersions! !!MCDictionaryRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:34'!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph: versionsLeft) (0 0 0.30 0.6) (0 30 0 0))		((listMorph: middle) (0.30 0 0.70 1) (0 30 0 0))		((textMorph: versionsRight) (0.70 0 1 0.6) (0 30 0 0)) )			! !!MCRepositoryDualVersionsInspector commentStamp: 'kph 6/4/2008 14:42' prior: 0!Known IssuesSome crosstalk between the two versions list... very mystifying!!MCRepositoryDualVersionsInspector class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 15:18'!repository: r repository2: r2 	^(self new) setRepository: r  repository2: r2;				yourself! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 16:36'!adopt2	(self confirm:'Modifying ancestry can be dangerous unless you knowwhat you are doing.  Are you sure you want to adopt',self version info name, ' as an ancestor of your working copy?')		ifTrue: [self version2 adopt]! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 17:41'!browse2	^ self version2 browse ! !!MCRepositoryDualVersionsInspector methodsFor: 'THE BUSINESS' stamp: 'kph 5/18/2007 13:51'!browseDiffAB 	| diff |		diff := self version asDiffAgainst: self version2.     centerPanelModel := MCSnapshotBrowser forSnapshot: diff snapshot.	 	self changed: #buildCenterPanel.! !!MCRepositoryDualVersionsInspector methodsFor: 'panel' stamp: 'kph 5/18/2007 13:35'!buildCenterPanel	centerPanelModel ifNil:[ ^#() ].		^ centerPanelModel buildPanelWith: ToolBuilder default. ! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 13:47'!buttonSpecs	^#(			('Refresh' refresh 'refresh the version-list')          		 ('Browse A' browse 'Browse this version' hasVersion)           		 ('Changes A-B' changesAB 'Browse Changes From A to B' hasVersions)			 ('Diff A-B' diffAB 'Diff From A to B' hasVersions)			 ('Browse A-B' browseDiffAB 'Browse Diff From A to B' hasVersions)			 ('Stages A..B' stagesAB 'Browse Steps from A to B' hasVersions	)	 	          		('Browse B' browse2 'Browse the second version' hasVersion2)         	)			"	 (Changes changes 'Browse the changes F' hasVersion)                           (Merge merge 'Merge this version into the image' hasVersion)              (Adopt adopt 'Adopt this version as an ancestor of your working copy'hasVersion)               (Copy copy 'Copy this version to another repository' hasVersion)              (Diff diff 'Create an equivalent version based on an earlier release'hasVersion)" 	 	! !!MCRepositoryDualVersionsInspector methodsFor: 'panel' stamp: 'kph 5/17/2007 19:37'!centerPanelSpecs	^ centerPanelModel widgetSpecs	! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 16:30'!changes2	(MCPatchBrowser forPatch: self version2 changes)		showLabelled: 'Changes from ', self version2 info name! !!MCRepositoryDualVersionsInspector methodsFor: 'THE BUSINESS' stamp: 'kph 5/18/2007 13:32'!changesAB 	thePatch := MCPatch fromBase: (self version snapshot) target: (self version2 snapshot).	centerPanelModel := MCPatchBrowser forPatch: thePatch.	self changed: #buildCenterPanel.! !!MCRepositoryDualVersionsInspector methodsFor: 'panel' stamp: 'kph 5/17/2007 19:05'!changesPanel! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 18:27'!copy2	self pickRepository ifNotNilDo:		[:ea |		ea storeVersion: self version2]! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 10:48'!defaultExtent	^550@350! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 10:50'!defaultLabel	^'Dual Change Log:  ' , repository description , ' & ',  repository2 description! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 14:34'!delete2	self isVersionDeletable ifFalse: [ ^ self ].		(self confirm: 'Are you sure you wish to delete ', selectedVersionInfo2 name, 'from ', repository description)		ifFalse: [ ^ self ].	 (repository delete: selectedVersionInfo2)		ifTrue: [ self inform: ('Successfully deleted ', selectedVersionInfo2 name) ]		ifFalse: [ self inform: ('Sorry, could not delete, ', selectedVersionInfo2 name) ].! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 16:35'!diff2	| ancestorVersion |	self pickAncestor ifNotNilDo:		[:ancestor |		ancestorVersion := self version2 workingCopy repositoryGroup versionWithInfo: ancestor.		(self version2 asDiffAgainst: ancestorVersion) open]! !!MCRepositoryDualVersionsInspector methodsFor: 'THE BUSINESS' stamp: 'kph 5/18/2007 13:49'!diffAB 	| diff |		diff := self version asDiffAgainst: self version2.     centerPanelModel :=   (MCVersionInspector new version: diff)  .	self changed: #buildCenterPanel.! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 13:19'!hasVersion2 	^ selectedVersionInfo2 notNil! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 13:19'!hasVersions 	^ self hasVersion and: [ self hasVersion2 ]! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 13:33'!initialize! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 14:36'!isVersionDeletable2"disable version deleting until sure its ok"	^ false 	"^ self repository2 ifNotNilDo:[ :r | r isDeletingAllowed ] ifNil: [ false ]"! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 12/8/2008 04:42'!load2 	self version2 isCacheable			ifTrue: [ self version2 workingCopy repositoryGroup addRepository: repository2].			Cursor wait showWhile: [ self version2 load]		self refresh	! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 18:20'!merge2	self version2 merge.	self refresh.! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 12:54'!obtainPatch	^ MCPatch operations: #()! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 10:45'!order2: anInteger 	order2 := anInteger.	self refresh! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 10:48'!order2String: anIndex	^ self order: order2 string: anIndex! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'mtf 6/27/2008 23:18'!orderSpecs	^{		'unchanged' -> nil.		'order by package' -> [ :x :y | x <= y ].		}! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'mtf 6/27/2008 23:18'!orderSpecs2	^{		'unchanged' -> nil.		'order by package' -> [ :x :y | x <= y ].		}! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 14:39'!refresh	self versionListObtain.	self version2ListObtain.	self versionListSort.	self version2ListSort.	 	self collateHighlightingData.	self changed: #versionList.	self changed: #version2List. ! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 10:42'!repository	^ repository ! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'mtf 10/12/2008 22:40'!repository2	^ repository2! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 15:13'!setRepository: r1 repository2: r2   	order := order2 := self class order.	repository := r1.	repository2 := r2.    	self refresh! !!MCRepositoryDualVersionsInspector methodsFor: 'THE BUSINESS' stamp: 'kph 5/17/2007 16:37'!stagesAB! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 17:42'!summary2	^self hasVersion2		ifTrue: [ self version2Summary ]		ifFalse: [ String new ]! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 17:33'!version2 	^ self repository2 versionWithInfo: selectedVersionInfo2! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 6/4/2008 14:44'!version2List	^ versionInfos2 collect: [:ea | self versionHighlight: ea ]! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 18:25'!version2ListMenu: aMenu	 		self hasVersion ifNotNil: [		self fillMenu: aMenu fromSpecs:			#(			('changes B to image' #changes2)			('merge B to image' #merge2)			('load B into image' #load2)			('adopt B' #adopt2)			('copy B' #copy2)			('diff B to image' #diff2)  			('change log entry' #openChangeLogEntry2)						).		aMenu add:  'copy all' target: self selector: #copyAll2.		aMenu add:  'copy all (forked)' target: self selector: #copyAllFork2.		aMenu addLine.		self isVersionDeletable ifTrue: [   			aMenu add: 'delete' target: self selector: #delete2.		].		 	].	aMenu addLine.		self version2ListOrderMenu: aMenu.		^ aMenu! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 15:19'!version2ListObtain 	 versionInfos2 := self repository2 sortedHeldVersionInfos.	! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 6/4/2008 14:18'!version2ListOrderMenu: aMenu 	1 to: self orderSpecs2 size do: [ :index |		aMenu addUpdating: #order2String: target: self selector: #order2: argumentList: { index } ].	 	^aMenu! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 6/4/2008 14:46'!version2ListSort	 ^ self version2SortBlock ifNotNilDo: [ :sb | sb fixTemps. versionInfos2 := versionInfos2 asSortedCollection: [:b :a | [sb value: a value: b] on: Error do: [true]]].		 ! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 14:46'!version2Selection  	^ versionInfos2 indexOf: selectedVersionInfo2! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/19/2007 01:05'!version2Selection: aNumber	aNumber isZero 		ifTrue: [ selectedVersionInfo2 := nil ]		ifFalse: [ 			selectedVersionInfo2 := versionInfos2 at: aNumber].	self changed:#version2Selection; 		changed: #summary2 ;		changed: #hasVersion2;		changed: #hasVersions.! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 6/4/2008 14:17'!version2SortBlock	^ (self orderSpecs2 at: order2) value ! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 15:28'!version2Summary	selectedVersionInfo2 ifNil: [ ^ '' ].	^ (inherited detect: [ :info | info versionName = selectedVersionInfo2 versionName ] ifNone: [ self version2 ]) summary! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 18:24'!versionListMenu: aMenu	 		self hasVersion ifNotNil: [		self fillMenu: aMenu fromSpecs:			#(			('changes A to image' #changes)			('merge A to image' #merge)			('load A into image' #load)			('adopt A' #adopt)			('copy A' #copy)				('diff A to image' #diff)  			('change log entry' #openChangeLogEntry)			('spawn dual changes browser' #openDual)						).		aMenu add:  'copy all' target: self selector: #copyAll.		aMenu add:  'copy all (forked)' target: self selector: #copyAllFork.		aMenu addLine.		self isVersionDeletable ifTrue: [   			aMenu add: 'delete' target: self selector: #delete.		].		 	].	aMenu addLine.		self versionListOrderMenu: aMenu.	(self class = MCRepositoryVersionsInspector) 		ifTrue: [			aMenu addLine.			aMenu add: 'open two column display' target: self selector: #twoColumnOpen.			aMenu add: 'always use two column display' target: self selector: #twoColumnAlways.		].		^ aMenu! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 13:20'!versionSelection: aNumber	super versionSelection: aNumber.	self changed: #hasVersions.! !!MCRepositoryDualVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/21/2007 13:02'!widgetSpecs"left top right bottom"	^#(	((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph: version ) (0 0 0.25 0.6) (0 30 0 0))		((textMorph: summary) (0 0.6 0.25 1) (0 0 0 0)) 				((panel: buildCenterPanel) (0.25 0 0.75 1) (0 30 0 0))		((textMorph: summary2) (0.75 0.6 1 1) (0 0 0 0)) 		((listMorph: version2 ) (0.75 0 1 0.6) (0 30 0 0))													)! !!MCRepositoryPackagesVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 08:41'!hasPackage	^ selectedPackageName notNil! !!MCRepositoryPackagesVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:09'!menuItem900SwitchToTwoColumnInspector: aMenu	"null"! !!MCRepositoryPackagesVersionsInspector methodsFor: 'actions' stamp: 'kph 5/17/2007 10:12'!oneColumnAlways	repository class uiClassUseOneColumn. ! !!MCRepositoryPackagesVersionsInspector methodsFor: 'actions' stamp: 'kph 5/17/2007 10:20'!oneColumnOpen	| newUI |		newUI := MCRepositoryVersionsInspector				repository: repository 				selectedPackage: selectedPackageName	 			selectedVersion: selectedVersionInfo.		 newUI show.! !!MCRepositoryPackagesVersionsInspector methodsFor: 'actions' stamp: 'kph 5/17/2007 10:11'!oneColumnSwitch	| newUI newWindow |		newUI := repository class uiClassUseOneColumn 				repository: repository 				selectedPackage: selectedPackageName	 			selectedVersion: selectedVersionInfo.		Smalltalk at: #ToolBuilder ifPresent: [:tb |  		newWindow := (tb default build: newUI)		 	].		newWindow ifNil: [ 		newWindow := self window  openInWorldExtent: self defaultExtent; yourself 			].	"newWindow bounds: self window fullBounds.."	 	newWindow openInWorldExtent: self window extent; yourself. 		 	self  window closeBoxHit..! !!MCRepositoryPackagesVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 08:35'!packageHighlight: aPackageName	newer ifNil: [newer := #()].		^(loaded anySatisfy: [:each | each packageName = aPackageName])		ifTrue: [			Text string: (MCPackage named: aPackageName)					workingCopy packageNameWithStar				attribute: (TextEmphasis new emphasisCode: (					((newer includes: aPackageName)						ifTrue: [5] ifFalse: [4])))]		ifFalse: [aPackageName]! !!MCRepositoryPackagesVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 08:38'!packageList	^ packageNames collect: [ :n | self packageHighlight: n ]! !!MCRepositoryPackagesVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 10:18'!packageListMenu: aMenu			aMenu add: 'open to one column display' target: self selector: #oneColumnOpen.			aMenu add: 'always use one column display' target: self selector: #oneColumnAlways.		^ aMenu! !!MCRepositoryPackagesVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/17/2007 01:55'!packageListObtain	^ packageNames := repository packageNames ! !!MCRepositoryPackagesVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 01:54'!packageSelection	^ packageNames indexOf: selectedPackageName! !!MCRepositoryPackagesVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 9/28/2007 10:39'!packageSelection: aNumber	selectedPackageName := aNumber isZero ifFalse: [ packageNames at: aNumber ].	selectedVersionInfo := nil.	self update.	self changed: #packageSelection; changed: #versionList ; changed: #versionSelection ; changed: #summary	! !!MCRepositoryPackagesVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 01:53'!packagesNames	^  packageNames! !!MCRepositoryPackagesVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/17/2007 04:25'!setSelectedPackage: aPackage	selectedPackageName := aPackage name! !!MCRepositoryPackagesVersionsInspector methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2007 10:38'!update	self packageListObtain.	self changed: #packageList. 		super update.  	! !!MCRepositoryPackagesVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/17/2007 02:03'!versionListObtain	^ versionInfos := self repository 		sortedVersionInfosAvailableForPackageNamed: selectedPackageName! !!MCRepositoryPackagesVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/17/2007 01:57'!widgetSpecs	^#(	((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph: package) (0 0 0.5 0.6) (0 30 0 0))		((listMorph: version) (0.5 0 1 0.6) (0 30 0 0))		((textMorph: summary) (0 0.6 1 1) (0 0 0 0)) )! !!MCRepositoryVersionsInspector class methodsFor: 'as yet unclassified' stamp: 'mtf 6/7/2008 11:34'!order	Order isNil		ifTrue: [ Order := 2 ].	^Order! !!MCRepositoryVersionsInspector class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 03:46'!order: anInteger	Order := anInteger! !!MCRepositoryVersionsInspector class methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 08:56'!repository: r selectedPackage: p selectedVersion: v	^(self new) setRepository: r selectedPackage: p selectedVersion: v! !!MCRepositoryVersionsInspector class methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 14:13'!repository: r workingCopy: wc	^(self new) setRepository: r workingCopy: wc! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/7/2009 21:16'!authorNameFor: init	^ ((Smalltalk classNamed: 'Authorship') ifNil: [ ^ '-' ]) nameFor: init! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/7/2009 21:33'!authors	(self authorsPrint: (self authorsForVersionInfo: selectedVersionInfo on: Set new)) explore! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/7/2009 21:36'!authorsAll	 | authors |	 authors := Set new.		 [versionInfos do: [ :ea | 		Transcript cr show: 'inspecting ', ea description.		self authorsForVersionInfo: ea on: authors ].		self authorsPrint: authors.	authors explore ] fork! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/8/2009 01:56'!authorsFind	(self authorsFindIn: (Array with: selectedVersionInfo)) ifEmpty:[ self inform: 'nothing found' ]! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'test 2/8/2009 02:09'!authorsFindAll	 [		self authorsFindIn: versionInfos. 		self inform: 'search complete'	] fork! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/8/2009 01:55'!authorsFindIn: vis	| list defns snap string |	string := FillInTheBlank request: 'Please enter authors'.	list := string findTokens: ','.	(string includesSubString: ',,') ifTrue: [ list add: '' ].	vis do: [ :ea |		Transcript cr; show: 'inspecting ', ea description.		version := repository versionWithInfo: ea. 		defns := version snapshot definitionsWithAnyAuthor: list.		defns ifNotEmpty: [			snap := MCSnapshot fromDefinitions: defns.			  ((MCPatchBrowser forPatch: (snap patchRelativeToBase: (MCSnapshot empty)))				label: version description;				yourself) show.		]	].	^ defns! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/7/2009 22:39'!authorsForVersionInfo: versionInfo on: aCollection 					| authors |	authors :=  [		(repository versionWithInfo: versionInfo) snapshot authorInitials 	] on: Error do: [ :ex | self notify: 'Could not read ', versionInfo description. #() ]	.		 	aCollection addAll: authors.	^ aCollection	! !!MCRepositoryVersionsInspector methodsFor: 'authorship' stamp: 'kph 2/7/2009 21:33'!authorsPrint: authors	authors do: [ :init |		Transcript cr show: (init printString, ' -> ', (self authorNameFor: init) printString), '.'.	].	  	^ authors! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 8/2/2007 15:37'!browse	self hasVersion ifTrue: [ self versionInfo browseVersionFrom: repository ].	 	self refresh	! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 5/14/2007 14:47'!buttonSpecs	^#(('Refresh' refresh 'refresh the version-list')) , super buttonSpecs! !!MCRepositoryVersionsInspector methodsFor: 'highlighting' stamp: 'mtf 6/27/2008 23:20'!collateHighlightingDataloaded := Set new.inherited := Set new.newer := Set new.loadedNames := nil.inheritedNames := nil.	(MCWorkingCopy allManagers 	   	"select: [ :each | self packageNames includes: each packageName]")			do: [:each |				each ancestors do: [ :ancestor |					loaded add: ancestor  .					ancestor ancestorsDoWhileTrue: [:heir | 						(inherited includes: heir )							ifTrue: [false]							ifFalse: [inherited add: heir . true]]].									latest := (versionInfos select: [:v | v packageName = each package name])						detectMax: [:v | v ].									(latest notNil and: [					each ancestors allSatisfy: [:ancestor | latest > ancestor]])					ifTrue: [newer add: each package name ]			].		"self changed: #packageList; changed: #versionList"	 ! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 6/2/2008 19:31'!copyAll		| versionsToCopy   aVersion gotAlready | 	self pickRepository ifNotNilDo: [:aRepository |.		gotAlready := aRepository heldVersionInfos collect: [ :v | v versionName ].	versionsToCopy := versionInfos removeAllSuchThat: [ :v | gotAlready includes: v versionName ].				 		Transcript cr; show: 'versions: ', versionsToCopy asArray printString.		Cursor wait showWhile: [			versionsToCopy do: [:each |				[ aVersion := repository versionWithInfo: each.				Transcript cr; show: '',aRepository description,' storeVersion: ', aVersion description. 		aVersion info name: aVersion info name withBlanksTrimmed.		aVersion info allAncestorsDo: [ :ea | ea name: ea name withBlanksTrimmed ]. 				aRepository storeVersion: aVersion ] ifError: [ Transcript cr; show: each description, ' not readable'. ]						]		]	]! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 11/16/2007 23:24'!copyAllFork		| versionsToCopy   aVersion gotAlready | 	self pickRepository ifNotNilDo: [:aRepository |.		gotAlready := aRepository heldVersionInfos collect: [ :v | v versionName ].	versionsToCopy := versionInfos removeAllSuchThat: [ :v | gotAlready includes: v versionName ].		Transcript cr; show: 'versions: ', versionsToCopy asArray printString.	[   [		versionsToCopy do: [:each |						 [ aVersion := repository versionWithInfo: each. 				Transcript cr; show: '',aRepository description,' storeVersion: ', aVersion printString.				aRepository storeVersion: aVersion ] ifError: [ Transcript cr; show: each description, ' not readable'. ]						]		] on: Notification do: [ :ex | ex resume ].	] forkAt: Processor userBackgroundPriority.]	! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/14/2007 14:46'!defaultExtent	^450@300! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/14/2007 14:48'!defaultLabel	^'Repository: ' , repository description! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 5/14/2007 15:06'!delete	self isVersionDeletable ifFalse: [ ^ self ].		(self confirm: 'Are you sure you wish to delete ', selectedVersion, 'from ', repository description)		ifFalse: [ ^ self ].	 (repository delete: selectedVersion)		ifTrue: [ self inform: ('Successfully deleted ', selectedVersion) ]		ifFalse: [ self inform: ('Sorry, could not delete, ', selectedVersion) ].			! !!MCRepositoryVersionsInspector methodsFor: 'testing' stamp: 'kph 8/7/2007 14:09'!hasSnapshot	 	^ selectedVersionInfo notNil and: [ selectedVersionInfo hasSnapshot ]! !!MCRepositoryVersionsInspector methodsFor: 'testing' stamp: 'kph 5/17/2007 00:09'!hasVersion	^ selectedVersionInfo notNil! !!MCRepositoryVersionsInspector methodsFor: 'highlighting' stamp: 'kph 5/17/2007 07:24'!inheritedNames	^ inheritedNames ifNil: [ inheritedNames := inherited collect: [ :v | v name ]] ! !!MCRepositoryVersionsInspector methodsFor: 'testing' stamp: 'kph 5/14/2007 16:21'!isVersionDeletable"disable version deleting until sure its ok"	^ false 	"^ self repository ifNotNilDo:[ :r | r isDeletingAllowed ] ifNil: [ false ]"! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 8/1/2007 12:11'!load 	self hasVersion ifTrue: [ self versionInfo loadVersionFrom: repository ].	 	self refresh	! !!MCRepositoryVersionsInspector methodsFor: 'highlighting' stamp: 'kph 5/17/2007 07:24'!loadedNames	^ loadedNames ifNil: [ loadedNames := loaded collect: [ :v | v name ]] ! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 16:45'!menuItem010Adopt: aMenu	 		self hasSnapshot ifTrue: [ aMenu add:  'adopt' target: self selector: #adopt ].	! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 16:46'!menuItem020Diff: aMenu	 		self hasSnapshot ifTrue: [ aMenu add:  'diff' target: self selector: #diff ].	! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 16:47'!menuItem030ChangeLogEntry: aMenu	 		self hasSnapshot ifTrue: [ aMenu add:  'change log entry' target: self selector: #openChangeLogEntry ].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 16:48'!menuItem040DualChangesBrowser: aMenu	 		self hasSnapshot ifTrue: [ aMenu add: 'open dual changes browser' target: self selector: #openDual ].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 16:55'!menuItem050CopyAll: aMenu	 		aMenu add:  'copy all' target: self selector: #copyAll.! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 16:56'!menuItem051CopyAllForked: aMenu	 			aMenu add:  'copy all (forked)' target: self selector: #copyAllFork.! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:04'!menuItem060FindAuthors: aMenu	 		self hasSnapshot ifTrue: [ aMenu add:  'find authors'' code' target: self selector: #authorsFind ].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:00'!menuItem061ExploreAuthors: aMenu	 		self hasSnapshot ifTrue: [ aMenu add:  'explore authors' target: self selector: #authors. ].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:05'!menuItem070ExploreAllAuthors: aMenu	 		self hasSnapshot ifFalse: [ 		aMenu add:  'explore all authors (forked)' target: self selector: #authorsAll.	].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:04'!menuItem071FindAuthorsCode: aMenu	 		self hasSnapshot ifFalse: [ 		aMenu add:  'find authors'' code (forked)' target: self selector: #authorsFindAll.		].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:01'!menuItem100Delete: aMenu	 		self isVersionDeletable ifTrue: [ aMenu add: 'delete' target: self selector: #delete ].! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:09'!menuItem200ListOrderOptions: aMenu	 		aMenu addLine.	self versionListOrderMenu: aMenu.	! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 2/11/2009 17:09'!menuItem900SwitchToTwoColumnInspector: aMenu	 		aMenu addLine.	aMenu add: 'open two column display' target: self selector: #twoColumnOpen.	aMenu add: 'always use two column display' target: self selector: #twoColumnAlways.! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 8/1/2007 12:51'!merge 	self hasVersion ifTrue: [ self versionInfo mergeVersionFrom: repository ].	 	self refresh	! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 5/16/2007 21:02'!openChangeLogEntry	(MCChangeLogEntry new version: self version; repository: repository) show.! !!MCRepositoryVersionsInspector methodsFor: 'menu items' stamp: 'kph 5/17/2007 15:23'!openDual   |  dual r2 |	r2 := self pickRepository.		dual :=	MCRepositoryDualVersionsInspector repository: self repository repository2: r2.			dual versionSelection: self versionSelection.		dual show.! !!MCRepositoryVersionsInspector methodsFor: 'ordering' stamp: 'kph 5/17/2007 06:18'!order: anInteger	self class order: (order := anInteger).	self refresh! !!MCRepositoryVersionsInspector methodsFor: 'ordering' stamp: 'kph 5/17/2007 10:46'!order: setting string: anIndex	^String streamContents: [ :stream |		setting = anIndex			ifTrue: [ stream nextPutAll: '<yes>' ]			ifFalse: [ stream nextPutAll: '<no>' ].		stream nextPutAll: (self orderSpecs at: anIndex) key ]! !!MCRepositoryVersionsInspector methodsFor: 'ordering' stamp: 'mtf 6/27/2008 23:20'!orderSpecs	^{		'unchanged' -> nil.		'order by package' -> [ :x :y | x <= y ].		}! !!MCRepositoryVersionsInspector methodsFor: 'ordering' stamp: 'kph 5/17/2007 10:47'!orderString: anIndex	^ self order: order string: anIndex! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 9/28/2007 11:02'!refresh	self repository heldVersionInfosClearCache. 	self update  	! !!MCRepositoryVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/16/2007 23:38'!repository	^ repository ! !!MCRepositoryVersionsInspector methodsFor: 'initialize-release' stamp: 'mtf 6/7/2008 12:27'!setRepository: aRepository selectedPackage: package selectedVersion: versionInfo	order := self class order.	repository := aRepository.     package isNil ifFalse: [ self setSelectedPackage: package].	self refresh! !!MCRepositoryVersionsInspector methodsFor: 'initialize-release' stamp: 'kph 5/17/2007 04:24'!setRepository: aRepository workingCopy: aWorkingCopy	order := self class order.	repository := aRepository.     aWorkingCopy isNil ifFalse: [ self setSelectedPackage: aWorkingCopy package].	self refresh! !!MCRepositoryVersionsInspector methodsFor: 'initialize-release' stamp: 'kph 5/17/2007 04:25'!setSelectedPackage: aPackage! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 5/17/2007 10:20'!twoColumnOpen	| newUI |		newUI := MCRepositoryPackagesVersionsInspector				repository: repository 				selectedPackage: nil	 			selectedVersion: selectedVersionInfo.		 newUI show.	! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 5/17/2007 10:15'!twoColumnSwitch	 ! !!MCRepositoryVersionsInspector methodsFor: 'actions' stamp: 'kph 5/17/2007 09:28'!twoColumnsAlways	repository class uiClassUseTwoColumn.	self twoColumnSwitch! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 9/28/2007 10:41'!update	self versionListObtain.	self versionListSort.	 	self collateHighlightingData.	self changed: #versionList. ! !!MCRepositoryVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/17/2007 00:55'!version 	^ self repository versionWithInfo: selectedVersionInfo! !!MCRepositoryVersionsInspector methodsFor: 'highlighting' stamp: 'kph 5/17/2007 07:26'!versionHighlight: anInfo	^Text		string: anInfo name		attribute: (TextEmphasis new emphasisCode: (			(self loadedNames includes: anInfo versionName) ifTrue: [ 4 "underlined" ]				ifFalse: [ (self inheritedNames includes: anInfo versionName)					ifTrue: [ 0 ]					ifFalse: [ 1 "bold" ] ]))							! !!MCRepositoryVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/22/2007 16:56'!versionInfo 	^ selectedVersionInfo realizeFrom: repository! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 16:18'!versionList	^ versionInfos collect: [:ea | (self versionHighlight: ea) ]! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 2/11/2009 17:13'!versionListMenu: aMenu		((self class allSelectorsBelow: MCTool) 		select: [ :sel | (sel beginsWith: #menuItem) ]) asSortedCollection		do: [ :ea | self perform: ea with: aMenu ].	^ aMenu! !!MCRepositoryVersionsInspector methodsFor: 'accessing-model' stamp: 'kph 5/17/2007 08:08'!versionListObtain 	 versionInfos := self repository sortedHeldVersionInfos.	! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 03:43'!versionListOrderMenu: aMenu 	1 to: self orderSpecs size do: [ :index |		aMenu addUpdating: #orderString: target: self selector: #order: argumentList: { index } ].	 	^aMenu! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 6/4/2008 14:46'!versionListSort	 self versionsSortBlock ifNotNilDo: [ :sb | versionInfos := versionInfos asSortedCollection: [:b :a | [sb value: a value: b] on: Error do: [true]]].		 ! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 06:17'!versionSelection  	^ versionInfos indexOf: selectedVersionInfo! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 8/1/2007 13:18'!versionSelection: aNumber	aNumber isZero 		ifTrue: [ selectedVersionInfo := nil ]		ifFalse: [ 			selectedVersionInfo := versionInfos at: aNumber].				 	self changed:#versionSelection; changed: #summary ; changed: #hasVersion; changed: #hasSnapshot.! !!MCRepositoryVersionsInspector methodsFor: 'highlighting' stamp: 'kph 5/22/2007 16:48'!versionSummary	^ (inherited detect: [ :info | info versionName = selectedVersionInfo versionName ] ifNone: [ self versionInfo ]) summary! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 6/4/2008 14:06'!versionsSortBlock	^ (self orderSpecs at: order) value ! !!MCRepositoryVersionsInspector methodsFor: 'morphic ui' stamp: 'kph 5/16/2007 23:23'!widgetSpecs	^#(	((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph: version) (0 0 1 0.6) (0 30 0 0))		((textMorph: summary) (0 0.6 1 1) (0 0 0 0)) )! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:19' prior: 23595372!adopt	(self confirm:'Modifying ancestry can be dangerous unless you knowwhat you are doing.  Are you sure you want to adopt',self version info name, ' as an ancestor of your working copy?')		ifTrue: [self version adopt]! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 8/2/2007 15:22' prior: 23595684!browse 	self version browse! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'kph 8/7/2007 14:10' prior: 23597666!buttonSpecs       ^ #((Browse browse 'Browse this version' hasVersion)               (History history 'Browse the history of this version' hasVersion)               (Changes changes 'Browse the changes this version would make to theimage' hasVersion)               (Load load 'Load this version into the image' hasVersion)               (Merge merge 'Merge this version into the image' hasVersion)             "  (Adopt adopt 'Adopt this version as an ancestor of your working copy'hasVersion)"               (Copy copy 'Copy this version to another repository' hasVersion)            "   (Diff diff 'Create an equivalent version based on an earlier release'hasVersion)" )! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 8/7/2007 14:13' prior: 23595799!changes 	(MCPatchBrowser forPatch: self version changes)		showLabelled: 'Changes from ', self version info name! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 6/12/2008 23:02'!copy 	self pickRepository ifNotNilDo: [:ea | ea storeVersion: self version ]	  ! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 6/2/2008 19:38'!copyAll	self halt.! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'avi 8/31/2003 00:45' prior: 23598424!defaultExtent	^ 400@200! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'avi 2/28/2004 20:18' prior: 23598528!defaultLabel	^ 'Version: ', self version info name! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23596011!diff	| ancestorVersion |	self pickAncestor ifNotNilDo:		[:ancestor |		ancestorVersion := self version workingCopy repositoryGroup versionWithInfo: ancestor.		(self version asDiffAgainst: ancestorVersion) open]! !!MCVersionInspector methodsFor: '' stamp: 'kph 8/7/2007 14:08'!hasSnapshot	^ self version notNil! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 00:07' prior: 23596313!hasVersion	^ self version notNil! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 17:14' prior: 23596429!history	(MCVersionHistoryBrowser new ancestry: self versionInfo) show! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 15:46' prior: 23596587!load	Cursor wait showWhile: [ self version load]! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/17/2007 18:19' prior: 23596724!merge	self version merge.	self refresh.! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23598670!pickAncestor	| index versions |	versions := self version info breadthFirstAncestors.	index := (PopUpMenu labelArray: (versions collect: [:ea | ea name]))				startUpWithCaption: 'Ancestor:'.	^ index = 0 ifFalse: [versions at: index]! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23598997!pickRepository	| index |	index := (PopUpMenu labelArray: (self repositories collect: [:ea | ea description]))				startUpWithCaption: 'Repository:'.	^ index = 0 ifFalse: [self repositories at: index]! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'avi 8/31/2003 00:44' prior: 23599279!repositories	^ MCRepositoryGroup default repositories! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'kph 5/14/2007 14:32'!repository 	^ nil! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 17:16' prior: 23597006!summary	^self hasVersion		ifTrue: [ self versionSummary ]		ifFalse: [ String new ]! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 20:19' prior: 23597180!version	^ version! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23597546!version: aVersion	version := aVersion! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 17:16' prior: 23597287!versionInfo	^ self version info! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'avi 9/17/2005 17:16' prior: 23597408!versionSummary	^ self version summary! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'ab 7/18/2003 18:43' prior: 23599412!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((textMorph: summary) (0 0 1 1) (0 30 0 0))		)! !!MCWorkingCopyBrowser class methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 23:38' prior: 23651307!initialize	 (TheWorldMenu respondsTo: #registerOpenCommand:)         ifTrue: [TheWorldMenu registerOpenCommand: {'Monticello Browser'. {self. #open}}]! !!MCWorkingCopyBrowser class methodsFor: 'as yet unclassified' stamp: 'kph 5/13/2007 16:47' prior: 23651683!open	^ self new show! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 11/4/2005 17:46'!addPackageRepository	workingCopy ifNotNil:		[		(self pickRepositorySatisfying: [ :repos | (workingCopy repositoryGroup includes: repos) not ])			ifNotNilDo:				[:repos |					workingCopy repositoryGroup addRepository: repos.					self repository: repos.						self						changed: #repositoryList;						changed: #repositorySelection.					self changedButtons]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bkv 2/18/2004 21:22' prior: 23632832!addRepository	self newRepository ifNotNilDo:		[:repos | self addRepository: repos ].! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/21/2005 15:58' prior: 23633828!addRepository: aRepository	self repository: aRepository.	self repositoryGroup addRepository: aRepository.	self changed: #repositoryList; changed: #repositorySelection.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23633009!addRepositoryToPackage	self repository ifNotNilDo:		[:repos |		(self pickWorkingCopySatisfying: [ :p | (p repositoryGroup includes: repos) not ]) ifNotNilDo:			[:wc |			workingCopy := wc.			workingCopy repositoryGroup addRepository: repos.			self repository: repos.				self				changed: #workingCopySelection;				changed: #repositoryList;				changed: #repositorySelection.			self changedButtons]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 6/28/2007 22:58'!addRepositoryToPackagesMatching	| result |	result := FillInTheBlank request: 'packages matching: ' initialAnswer: 'My*'.	result size > 0 ifTrue: [		self addRepositoryToPackagesMatching: result.	]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 5/17/2007 00:34'!addRepositoryToPackagesMatching: aString	self repository ifNotNilDo:  		[:repos |			(self workingCopies select: [:each | aString match: each package name ]) 				do: [ :wc | 					Transcript cr; show: 'add ', wc package name, ' to ', repos description.					wc repositoryGroup addRepository: repos]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/21/2005 15:57' prior: 23633494!addRepositoryToWorkingCopy	workingCopy ifNotNilDo:		[:wc |			workingCopy repositoryGroup addRepository: self repository.			self				changed: #workingCopySelection;				changed: #repositoryList;				changed: #repositorySelection.			self changedButtons]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'AlexandreBergel 7/30/2008 13:47'!addRequiredDirtyPackage	| dirtyPackages |	dirtyPackages := self workingCopies select: [:copy | copy needsSaving].	workingCopy ifNotNilDo:		[:wc |		dirtyPackages do:			[:required |			wc requirePackage: required package]].		self workingCopyListChanged! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 2/14/2004 02:45' prior: 23634098!addRequiredPackage	workingCopy ifNotNilDo:		[:wc |		self pickWorkingCopy ifNotNilDo:			[:required |			wc requirePackage: required package.			self workingCopyListChanged]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 2/22/2009 23:53' prior: 23634364!addWorkingCopy	|name|	name := FillInTheBlankMorph request: 'Name of package:'.	name isEmptyOrNil ifFalse:		[workingCopy := (MCPackage new name: name) workingCopy.		workingCopyWrapper := nil.		self repositorySelection: 0].	self workingCopyListChanged; changed: #workingCopySelection; changed: #repositoryList.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 12/7/2008 03:51'!ancestryGoBackOne	(self notify: 'are you sure you want to discard the most recent history entry').	 		workingCopy ancestry ancestors in: [ :a | a at: 1 put: a first ancestors first ].			self workingCopyListChanged.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/21/2005 15:38' prior: 23634834!backportChanges	self canBackport ifFalse: [^self].	workingCopy ifNotNil:		[workingCopy needsSaving ifTrue: [^ self inform: 'You must save the working copy before backporting.'].		self pickAncestorVersionInfo ifNotNilDo:			[:baseVersionInfo |			workingCopy backportChangesTo: baseVersionInfo]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ab 7/19/2003 22:58' prior: 23635210!browseWorkingCopy	workingCopy ifNotNil:		[(MCSnapshotBrowser forSnapshot: workingCopy package snapshot)			label: 'Snapshot Browser: ', workingCopy packageName;			show]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 2/28/2005 16:28' prior: 23641113!buttonSpecs       ^ #(               ('+Package' addWorkingCopy 'Add a new package and make it the working copy')               (Browse browseWorkingCopy 'Browse the working copy of the selected package' hasWorkingCopy)               (Scripts editLoadScripts 'Edit the load/unload scripts of this package' hasWorkingCopy)               (History viewHistory 'View the working copy''s history' hasWorkingCopy)               (Changes viewChanges 'View the working copy''s changes relative to the installed version from the repository' canSave)               (Backport backportChanges 'Backport the working copy''s changes to an ancestor' canBackport)               (Save saveVersion 'Save the working copy as a new version to the selected repository' canSave)             ('+Repository' addRepository 'Add an existing repository to the list of those visible')               (Open openRepository 'Open a browser on the selected repository' hasRepository)               )! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 5/11/2007 05:07' prior: 23635460!canBackport	^ self hasWorkingCopy and: [ workingCopy canBackport ]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 8/7/2003 21:22' prior: 23642170!canSave	^ self hasWorkingCopy and: [self hasRepository]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'bf 6/21/2005 15:50' prior: 23642307!changedButtons	self changed: #hasWorkingCopy.	self changed: #canSave.	self changed: #canBackport.	self changed: #hasRepository.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 8/1/2007 11:42' prior: 23635619!checkForNewerVersions	| newer | 	newer := workingCopy possiblyNewerVersionsIn: self repository.	^ newer isEmpty or: [		self confirm: 'CAUTION!! These versions in the repository may be newer:', 			String cr, newer asString, String cr,			'Do you really want to save this version?'].! !!MCWorkingCopyBrowser methodsFor: 'orphanage' stamp: 'kph 5/10/2007 17:24'!clearOrphans	self orphanage clearOrphans.	self workingCopyListChanged.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 2/14/2004 02:46' prior: 23635982!clearRequiredPackages	workingCopy ifNotNilDo:		[:wc |		wc clearRequiredPackages.		self workingCopyListChanged]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 2/7/2009 18:27' prior: 23642521!defaultExtent	^ 620@400! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 23:38' prior: 23642626!defaultLabel	^ 'Monticello Browser'! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23642755!defaults	^ defaults ifNil: [defaults := Dictionary new]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 2/14/2004 02:46' prior: 23636174!deleteWorkingCopy	workingCopy unregister.	self workingCopySelection: 0.	self workingCopyListChanged.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23642904!editLoadScripts	| menu |	self hasWorkingCopy ifFalse: [^self].	menu := MenuMorph new defaultTarget: self.	menu add: 'edit preamble' selector: #editScript: argument: #preamble.	menu add: 'edit postscript' selector: #editScript: argument: #postscript.	menu add: 'edit preambleOfRemoval' selector: #editScript: argument: #preambleOfRemoval.	menu add: 'edit postscriptOfRemoval' selector: #editScript: argument: #postscriptOfRemoval.	menu popUpInWorld.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 5/16/2007 12:53' prior: 23636355!editRepository	| newRepo |		newRepo := self repository openAndEditTemplateCopy.	newRepo ifNotNil: [ 		newRepo class = self repository class			ifTrue: [self repository copyFrom: newRepo]			ifFalse: [self inform: 'Must not change repository type!!']].	self changed: #repositoryList.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 2/17/2009 12:05' prior: 23643454!editScript: scriptSymbol	| script |		workingCopy packageInfo in: [ :pi |		 script := (pi propertyAt: scriptSymbol) ifNil: [ pi propertyDefaultAt: scriptSymbol ].	].	script openLabel: scriptSymbol asString, ' of the Package ', workingCopy package name.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 5/14/2007 13:14'!exploreWorkingCopy	workingCopy ifNotNil: [workingCopy explore]! !!MCWorkingCopyBrowser methodsFor: 'orphanage' stamp: 'kph 10/2/2007 18:40'!fixAllObsoleteReferences"self fixAllObsoleteReferences"(SystemNavigation default obsoleteBehaviors select: [ :c | c isMeta not ])	do: [ :obsClass | 				([obsClass nonObsoleteClass] ifError: [ nil]) ifNotNilDo: 			[ :actualClass |								actualClass updateInstancesFrom: obsClass. 				obsClass becomeForward: actualClass.								([obsClass metaclass] ifError:[nil]) ifNotNilDo:					[:metaClass |						metaClass becomeForward: actualClass class ]]].					SmalltalkImage current fixObsoleteReferences! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/3/2005 15:08' prior: 23636688!flushAllCaches	| beforeBytes afterBytes beforeVersions afterVersions |	Cursor wait showWhile: [		beforeBytes := Smalltalk garbageCollect.		beforeVersions := MCVersion allSubInstances size.		MCFileBasedRepository flushAllCaches.		afterBytes := Smalltalk garbageCollect.		afterVersions := MCVersion allSubInstances size.	].	^self inform: (beforeVersions - afterVersions) asString, ' versions flushed', String cr, 		(afterBytes - beforeBytes) asStringWithCommas, ' bytes reclaimed'! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 11/4/2005 16:57'!flushPasswords	MCRepository allSubInstancesDo:[:repo| repo flushPasswords].! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/22/2003 02:21' prior: 23643715!hasRepository	^ self repository notNil! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/22/2003 00:46' prior: 23643835!hasWorkingCopy	^ workingCopy notNil! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 11/16/2003 20:21' prior: 23643954!initialize	MCWorkingCopy addDependent: self.	self workingCopies do: [:ea | ea addDependent: self].! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/21/2005 15:58' prior: 23637396!loadRepositories	FileStream fileIn: 'MCRepositories.st'.	self changed: #repositoryList.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23637598!newRepository	| types index |	types := MCRepository allConcreteSubclasses asArray.	index := (PopUpMenu labelArray: (types collect: [:ea | ea description]))				startUpWithCaption: 'Repository type:'.	^ index = 0 ifFalse: [(types at: index) morphicConfigure]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 17:15'!openDual   |  dual r2 |	r2 := self pickRepositorySatisfying: [:ea | true].		dual :=	MCRepositoryDualVersionsInspector repository: self repository repository2: r2.	 	dual show.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 4/25/2008 00:48' prior: 23637937!openRepository	 	[ self repository ifNotNilDo: [:repos | repos morphicOpen: workingCopy ] ] fork! !!MCWorkingCopyBrowser methodsFor: 'orphanage' stamp: 'kph 5/5/2007 04:00'!orphanage	^ MCOrphanage current! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23644147!pickAncestorVersionInfo	| ancestors index |	ancestors := workingCopy ancestry breadthFirstAncestors.	index := (PopUpMenu labelArray: (ancestors collect: [:ea | ea name]))				startUpWithCaption: 'Ancestor:'.	^ index = 0 ifFalse: [ ancestors at: index]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'mtf 6/9/2008 20:58'!pickRepositorySatisfying: aBlock	| repos index |	repos := MCRepositoryGroup default repositories select: aBlock.	index := (PopUpMenu labelArray: (repos collect: [:ea | ea descriptionDisplay ]))				startUpWithCaption: 'Repository:'.	^ index = 0 ifFalse: [repos at: index]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'nk 3/9/2004 14:39' prior: 23644482!pickWorkingCopy	^self pickWorkingCopySatisfying: [ :c | true ]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23644638!pickWorkingCopySatisfying: aBlock	| copies index |	copies := self workingCopies select: aBlock.	copies isEmpty ifTrue: [ ^nil ].	index := (PopUpMenu labelArray: (copies collect: [:ea | ea packageName]))				startUpWithCaption: 'Package:'.	^ index = 0 ifFalse: [ copies at: index]! !!MCWorkingCopyBrowser methodsFor: 'orphanage' stamp: 'kph 4/24/2008 01:07'!recompileAllPackages	self workingCopies do: [ :each | self log monticello recompilingPackage: each packageName. each recompilePackage. ]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 5/13/2007 01:43' prior: 23638101!recompilePackage 	workingCopy recompilePackage! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 6/21/2005 15:58' prior: 23638331!removeRepository	self repository ifNotNilDo:		[:repos |		self repositoryGroup removeRepository: repos.		self repositorySelection: (1 min: self repositories size)].	self changed: #repositoryList.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 6/28/2007 22:59'!removeRepositoryFromPackagesMatching	| result |	result := FillInTheBlank request: 'packages matching: ' initialAnswer: 'My*'.	result size > 0 ifTrue: [		self removeRepositoryFromPackagesMatching: result.	]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 5/17/2007 00:37'!removeRepositoryFromPackagesMatching: aString	self repository ifNotNilDo:		[:repos |			(self workingCopies select: [:each | aString match: each package name ]) 				do: [ :wc | 					Transcript cr; show: 'remove ', repos description, ' from ', wc package name.					wc repositoryGroup removeRepository: repos]]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 8/7/2003 21:32' prior: 23645002!repositories	^ self repositoryGroup repositories! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23638643!repository	workingCopy ifNotNil: [repository := self defaults at: workingCopy ifAbsent: []].	^ repository! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23638840!repository: aRepository	repository := aRepository.	workingCopy ifNotNil: [self defaults at: workingCopy put: aRepository]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 8/7/2003 21:32' prior: 23645131!repositoryGroup	^ workingCopy		ifNil: [MCRepositoryGroup default]		ifNotNil: [workingCopy repositoryGroup]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 5/16/2007 22:48' prior: 23645321!repositoryList	^ self repositories collect: [:ea | ea descriptionDisplay]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 5/17/2007 17:14' prior: 23645468!repositoryListMenu: aMenu	self repository ifNil: [^ aMenu].	self fillMenu: aMenu fromSpecs:		#(('open repository' #openRepository)		    ('edit repository info' #editRepository)		   ('add to package...' #addRepositoryToPackage)		   ('add to packages matching...' #addRepositoryToPackagesMatching)		   ('remove from packages matching...' #removeRepositoryFromPackagesMatching)		   ('show feed' #showFeed)		   ('remove repository' #removeRepository)			   ('load repositories' #loadRepositories)			   ('save repositories' #saveRepositories)		   ('flush cached versions' #flushAllCaches)			   ('flush passwords' #flushPasswords)			   ('open dual changes browser' #openDual)			).		aMenu		add: (self repository alwaysStoreDiffs					ifTrue: ['store full versions']					ifFalse: ['store diffs'])		target: self		selector: #toggleDiffs.	^ aMenu				! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/22/2003 02:22' prior: 23646142!repositorySelection	^ self repositories indexOf: self repository! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'bf 6/21/2005 15:56' prior: 23646288!repositorySelection: aNumber	aNumber = 0		ifTrue: [self repository: nil]		ifFalse: [self repository: (self repositories at: aNumber)].	self changed: #repositorySelection.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 5/11/2005 15:20' prior: 23639041!revertPackage	self pickAncestorVersionInfo ifNotNilDo: [:info |		(self repositoryGroup versionWithInfo: info			ifNone: [^self inform: 'No repository found for ', info name]		) load]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'avi 9/10/2004 17:46' prior: 23639305!saveRepositories	| f |	f := FileStream forceNewFileNamed: 'MCRepositories.st'.	MCRepositoryGroup default repositoriesDo: [:r |		f nextPutAll: 'MCRepositoryGroup default addRepository: (', r asCreationTemplate, ')!!'; cr.]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 12/8/2008 04:34' prior: 23639608!saveVersion	| repo |		self canSave ifFalse: [^self].	self checkForNewerVersions ifFalse: [^self].	repo := self repository.	workingCopy newVersion ifNotNilDo: [:v |		'Saving package' displayProgressAt: Sensor cursorPoint		from: 0 to:100		during:[:bar|			bar value: 10.			repo storeVersion: v.			bar value: 80.						MCCacheRepository default cacheAllFileNamesDuring: 			[ repo cacheAllFileNamesDuring: [				v allAvailableDependenciesDo:					[:dep |					(repo includesVersionNamed: dep info name)						ifFalse: [repo storeVersion: dep]].			]].			bar value: 100.		].		workingCopy repositoryGroup addRepository: repository.	]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 1/27/2006 18:31'!showFeed	| parser xml text |	parser := Smalltalk at: #XMLDOMParser		ifAbsent: [^self inform: 'Yaxo not installed'].	Cursor wait showWhile: [		xml := self repository readStreamForFileNamed: 'feed.rss'			do: [:stream | parser parseDocumentFrom: stream ]].	xml ifNil: [^self inform: 'feed.rss not found'].	text := Text streamContents: [:stream |		xml tagsNamed: #item do: [:item |			#(title bold author italic pubDate normal description normal) pairsDo: [:tag :attr |				stream withAttribute: (TextEmphasis perform: attr) do: [					item tagsNamed: tag do: [:element | 						stream nextPutAll: (element contentString							copyReplaceAll: '<br/>' with: String cr) ; space]].				attr = #normal ifTrue: [stream cr]]]].	UIManager default edit: text label: 'Feed: ', self repository description! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 8/31/2004 01:14' prior: 23646567!toggleDiffs	self repository alwaysStoreDiffs		ifTrue: [self repository doNotAlwaysStoreDiffs]		ifFalse: [self repository doAlwaysStoreDiffs]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'avi 10/22/2005 19:34'!trimAncestry	self pickAncestorVersionInfo ifNotNilDo:		[:ancestor |		workingCopy ancestry trimAfterVersionInfo: ancestor]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 2/12/2009 00:42'!trimAncestryAll	self workingCopies do: [ :ea | ea  trimAncestry ]			 ! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 12/7/2008 03:38'!trimOldestAncestry	self pickAncestorVersionInfo ifNotNilDo:		[:ancestor |		workingCopy ancestry trimAfterVersionInfo: ancestor]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 2/14/2004 02:46' prior: 23640176!unloadPackage	workingCopy unload.	self workingCopySelection: 0.	self workingCopyListChanged.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 9/10/2004 17:54' prior: 23646792!unsortedWorkingCopies	^ MCWorkingCopy allManagers ! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 9/10/2004 17:54' prior: 23646925!update: aSymbol	self unsortedWorkingCopies do: [:ea | ea addDependent: self].	self workingCopyListChanged.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'mtf 6/9/2008 20:58' prior: 23640361!viewChanges	| patch |	'Finding changes' displayProgressAt: Sensor cursorPoint from: 0 to: 10 during:[:bar|		self canSave ifTrue:[		bar value: 1.		patch := workingCopy changesRelativeToRepository: self repository].		patch isNil ifTrue: [^ self].		bar value:3.		patch isEmpty			ifTrue: [ workingCopy modified: false.				bar value: 10.				self inform: 'No changes' ]			ifFalse:				[ workingCopy modified: true.				bar value: 5.				(MCPatchBrowser forPatch: patch)					label: 'Patch Browser: ', workingCopy description;					show]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'avi 2/13/2004 01:13' prior: 23640827!viewHistory	workingCopy ifNotNil:		[(MCWorkingHistoryBrowser new				ancestry: workingCopy ancestry;				package: workingCopy package)			label:  'Version History: ',  workingCopy packageName;			show]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 4/24/2008 04:33'!viewMemoryUse	| total sizeCalc classes  |		total := 0.        	sizeCalc := [ :roots | (ImageSegment new 							copyFromRoots: 								(roots reject: [:aRoot | 										aRoot isNil or: 										[ aRoot indexIfCompact > 0]]) 								sizeHint: 100000) segment byteSize ].                    classes :=                 ((workingCopy packageInfo classes collect: [ :cls |                | size  | 			size := sizeCalc value: ((cls classPool values asOrderedCollection) add: cls ; add: cls class; yourself).                                   	        		total := total + size.			cls name -> size.                     ]) asSortedCollection: [ :a :b | b value <= a value ]) asOrderedCollection.        classes addFirst: 'Total' -> total.                 classes explore.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'kph 4/24/2008 04:23'!viewMemoryUseAll	| total sizeCalc packages globals  |		total := 0.        	sizeCalc := [ :roots | (ImageSegment new 							copyFromRoots: 								(roots reject: [:aRoot | 										aRoot isNil or: 										[ aRoot indexIfCompact > 0]]) 								sizeHint: 100000) segment byteSize ].                    packages :=                 ((MCWorkingCopy allManagers collect: [ :each |                | size  | 			size := sizeCalc value:			                                         (each packageInfo classes in: [ :cls |                        (cls , (cls collect: [ :c | c class ]), (cls gather: [ :c | c classPool ]))                         ]).               	        		total := total + size.		     each package name -> size.                     ]) asSortedCollection: [ :a :b | b value <= a value ]) asOrderedCollection.	   globals := Smalltalk globals collect: [ :assoc |				| size | 				size := (sizeCalc value: (Array with: assoc value)).		total := total + size.		assoc key -> size.				].		   packages addFirst: (#Globals -> globals).        packages addFirst: 'Total' -> total.                 packages explore.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 2/7/2009 18:27' prior: 23647114!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 29))		((treeOrListMorph: workingCopy) (0 0 0.5 1) (0 30 0 0))		((listMorph: repository) (0.5 0 1 1) (0 30 0 0))		)! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'mtf 7/21/2008 18:41' prior: 23647363!workingCopies"List the working copies with the changed packages at the top"	| c |	c := MCWorkingCopy allManagers asSortedCollection:		[ :a :b | a package name <= b package name ].	^ (c select: [:mc| mc needsSaving]) asOrderedCollection, (c reject: [:mc| mc needsSaving]) asOrderedCollection.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23650947!workingCopy: wc	workingCopy := wc.	self changed: #workingCopyList; changed: #workingCopySelection; changed: #repositoryList.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 2/12/2009 00:28'!workingCopyAllMenu: aMenu 	aMenu add: 'trim ALL ancestry' target: self selector: #trimAncestryAll.	^aMenu! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'avi 1/19/2004 16:41' prior: 23647554!workingCopyList	^ self workingCopies collect:		[:ea |		(workingCopy notNil and: [workingCopy requiredPackages includes: ea package])			ifTrue: [Text string: ea description emphasis: (Array with: TextEmphasis bold)]			ifFalse: [ea description]]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/23/2006 18:30' prior: 23647883!workingCopyListChanged	self changed: #workingCopyList.	self changed: #workingCopyTree.	self changed: #workingCopyTreeRoots.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 2/12/2009 00:32' prior: 23648075!workingCopyListMenu: aMenu 	workingCopy ifNil: [ ^ self workingCopyAllMenu: aMenu ] ifNotNilDo: [ :wc | wc myMenu: aMenu inBrowser: self  ].		^ aMenu! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 23:11' prior: 23648753!workingCopyListMorph	^ PluggableMultiColumnListMorph		on: self		list: #workingCopyList		selected: #workingCopySelection		changeSelected: #workingCopySelection:		menu: #workingCopyListMenu:! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ab 7/19/2003 22:05' prior: 23649028!workingCopySelection	^ self workingCopies indexOf: workingCopy! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:48' prior: 23649552!workingCopySelection: aNumber	self workingCopy: 		(aNumber = 0 			ifTrue:[nil]			ifFalse:[self workingCopies at: aNumber]).	! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:38' prior: 23649172!workingCopySelectionWrapper	^workingCopyWrapper! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:57' prior: 23649301!workingCopySelectionWrapper: aWrapper	workingCopyWrapper := aWrapper.	self changed: #workingCopySelectionWrapper.	self workingCopy: (aWrapper ifNotNil:[aWrapper item])! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:30' prior: 23649761!workingCopyTree	^ self workingCopies collect:[:each| MCDependentsWrapper with: each model: self].! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/23/2006 18:10'!workingCopyTreeChildrenOf: aWorkingCopy	| workingCopies |	workingCopies := self unsortedWorkingCopies.	^aWorkingCopy requiredPackages collect:[:each | 			workingCopies detect: [:wc | wc package = each] ifNone: [nil]]			thenSelect: [:x | x notNil].! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/23/2006 18:15'!workingCopyTreeLabelOf: aWorkingCopy	^aWorkingCopy description! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'kph 2/12/2009 00:40' prior: 23649940!workingCopyTreeMenu: aMenu 	workingCopy ifNil: [ ^ self workingCopyAllMenu: aMenu ] ifNotNilDo: [ :wc | wc myMenu: aMenu inBrowser: self  ].		^ aMenu! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/14/2004 02:24' prior: 23650666!workingCopyTreeMorph	^ SimpleHierarchicalListMorph		on: self		list: #workingCopyTree		selected: #workingCopyWrapper		changeSelected: #workingCopyWrapper:		menu: #workingCopyListMenu:! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/23/2006 18:18'!workingCopyTreeRoots	^self workingCopies! !!MCToolWindowBuilder class methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:02' prior: 23570703!builder: aBuilder tool: aTool	^ self basicNew initializeWithBuilder: aBuilder tool: aTool! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:03' prior: 23566183!build	^ builder build: window! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:04' prior: 23566303!buttonRow	^ self buttonRow: tool buttonSpecs! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23566449!buttonRow: specArray	| panel button |	panel := builder pluggablePanelSpec new.	panel children: OrderedCollection new.	specArray do:		[:spec |				button := builder pluggableButtonSpec new.		button model: tool.		button label: spec first asString.		button action: spec second.		button help: spec third.		button enabled: (spec at: 4 ifAbsent: [#buttonEnabled]).		button state: (spec at: 5 ifAbsent: [#buttonSelected]).		panel children add: button].	panel layout: #horizontal.	panel frame: currentFrame.	window children add: panel! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23567092!frame: aLayoutFrame	currentFrame := aLayoutFrame! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 12:46' prior: 23567242!initializeWithBuilder: aBuilder tool: aTool	builder := aBuilder.	tool := aTool.! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:04' prior: 23567591!listMorph: listSymbol	^ self		listMorph: (listSymbol, 'List') asSymbol		selection: (listSymbol, 'Selection') asSymbol		menu: (listSymbol, 'ListMenu:') asSymbol! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:04' prior: 23567844!listMorph: listSymbol keystroke: keystrokeSymbol	^ (self		listMorph: (listSymbol, 'List') asSymbol		selection: (listSymbol, 'Selection') asSymbol		menu: (listSymbol, 'ListMenu:') asSymbol)		keystrokeActionSelector: keystrokeSymbol;		yourself! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:15' prior: 23568181!listMorph: listSymbol selection: selectionSymbol	self listMorph: listSymbol selection: selectionSymbol menu: nil! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/11/2005 12:16' prior: 23568384!listMorph: listSymbol selection: selectionSymbol menu: menuSymbol	self listMorph: listSymbol selection: selectionSymbol menu: menuSymbol keystroke: nil! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2005 17:51' prior: 23568626!listMorph: listSymbol selection: selectionSymbol menu: menuSymbol keystroke: keystrokeSymbol	| list |	list := builder pluggableListSpec new.	list 		model: tool;		list: listSymbol; 		getIndex: selectionSymbol; 		setIndex: (selectionSymbol, ':') asSymbol;		frame: currentFrame.	menuSymbol ifNotNil: [list menu: menuSymbol].	keystrokeSymbol ifNotNil: [list keyPress: keystrokeSymbol].	window children add: list! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2005 17:52' prior: 23569135!multiListMorph: listSymbol selection: selectionSymbol listSelection: listSelectionSymbol menu: menuSymbol	| list |	list := builder pluggableMultiSelectionListSpec new.	list 		model: tool;		list: listSymbol; 		getIndex: selectionSymbol; 		setIndex: (selectionSymbol, ':') asSymbol;		getSelectionList: listSelectionSymbol;		setSelectionList: (listSelectionSymbol, 'put:') asSymbol;		frame: currentFrame.	menuSymbol ifNotNil: [list menu: menuSymbol].	window children add: list! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'kph 5/21/2007 13:01'!panel: getChildrenSelector 	| panel |	panel := builder pluggablePanelSpec new.	panel children: getChildrenSelector.	panel model: tool.	panel frame: currentFrame.	window children add: panel! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 12:58'!startWithPanel	window := builder pluggablePanelSpec new.	window children: OrderedCollection new.	window model: tool.! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'kph 5/18/2007 12:47'!startWithWindow 	window := builder pluggableWindowSpec new.	window children: OrderedCollection new.	window label: tool label asString.	window model: tool.	window extent: tool defaultExtent.! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2005 17:52' prior: 23569711!textMorph: aSymbol	| text |	text := builder pluggableTextSpec new.	text 		model: tool;		getText: aSymbol; 		setText: (aSymbol, ':') asSymbol;		frame: currentFrame.	window children add: text! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2006 18:24' prior: 23569998!treeMorph: listSymbol	^ self		treeMorph: listSymbol		selection: listSymbol		menu: (listSymbol, 'TreeMenu:') asSymbol! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2006 17:46' prior: 23570258!treeMorph: listSymbol selection: selectionSymbol menu: menuSymbol	^self treeMorph: listSymbol selection: selectionSymbol menu: menuSymbol keystroke: nil! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2006 18:25'!treeMorph: treeSymbol selection: selectionSymbol menu: menuSymbol keystroke: keystrokeSymbol	| tree |	tree := builder pluggableTreeSpec new.	tree 		model: tool;		roots: (treeSymbol, 'TreeRoots') asSymbol;		setSelected: (selectionSymbol, ':') asSymbol;		getChildren: (treeSymbol,'TreeChildrenOf:') asSymbol;		label: (treeSymbol,'TreeLabelOf:') asSymbol;		frame: currentFrame.	menuSymbol ifNotNil: [tree menu: menuSymbol].	keystrokeSymbol ifNotNil: [tree keyPress: keystrokeSymbol].	window children add: tree! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2006 17:46' prior: 23570436!treeOrListMorph: listSymbol	^self treeMorph: listSymbol! !!MCClassInstanceVariableDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 22:59' prior: 23237556!type	^ #classInstance! !!MCClassInstanceVariableDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 23:31' prior: 23237288!isClassInstanceVariable	^ true! !!MCClassVariableDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 22:58' prior: 23241856!type	^ #class! !!MCClassVariableDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 23:32' prior: 23241612!isClassVariable	^ true! !!MCClassVariableDefinition methodsFor: 'as yet unclassified' stamp: 'bf 8/29/2006 11:41'!isOrderDependend	^false! !!MCInstanceVariableDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 22:59' prior: 23345937!type	^ #instance! !!MCInstanceVariableDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 23:32' prior: 23345684!isInstanceVariable	^ true! !!MCPoolImportDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 22:59' prior: 23446022!type	^ #pool! !!MCPoolImportDefinition methodsFor: 'testing' stamp: 'bf 8/29/2006 11:41'!isOrderDependend	^false! !!MCPoolImportDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:51' prior: 23445787!isPoolImport	^ true! !!MCVariableDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2003 23:18' prior: 23577072!name: aString	^ self new name: aString	! !!MCVariableDefinition methodsFor: 'comparing' stamp: 'cwp 7/7/2003 23:02' prior: 23576136!= other	^ (self species = other species)		and: [self name = other name]! !!MCVariableDefinition methodsFor: 'comparing' stamp: 'cwp 7/7/2003 23:02' prior: 23576039!hash	^ name hash! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:31' prior: 23576288!isClassInstanceVariable	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:08' prior: 23576398!isClassInstanceVariableDefinition	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:30' prior: 23576518!isClassVariable	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:31' prior: 23576620!isInstanceVariable	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:10' prior: 23576725!isInstanceVariableDefinition	^ false! !!MCVariableDefinition methodsFor: 'testing' stamp: 'bf 8/29/2006 11:41'!isOrderDependend	^true! !!MCVariableDefinition methodsFor: 'testing' stamp: 'cwp 7/7/2003 23:51' prior: 23576840!isPoolImport	^ false! !!MCVariableDefinition methodsFor: 'accessing' stamp: 'cwp 11/25/2002 05:57' prior: 23575635!name	^ name! !!MCVariableDefinition methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23575739!name: aString	name := aString! !!MCVariableDefinition methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 14:56' prior: 23575860!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self name; nextPut: $)! !!MCDiffyVersion class methodsFor: 'name utilities' stamp: 'bf 5/30/2005 18:45' prior: 23302983!baseNameFrom: diffName	| baseId verName |	baseId := (diffName copyAfter: $() copyUpTo: $).	baseId ifEmpty: [^baseId].	(baseId beginsWith: '@')		ifTrue: [^baseId copyAfter: $@].	verName := self verNameFrom: diffName.	^(baseId includes: $.)		ifTrue: [(verName copyUpToLast: $-), '-', baseId]		ifFalse: [(verName copyUpToLast: $.), '.', baseId]! !!MCDiffyVersion class methodsFor: 'name utilities' stamp: 'bf 5/30/2005 18:58' prior: 23303419!canonicalNameFor: aFileName	^(self nameForVer: (self verNameFrom: aFileName)		base: (self baseNameFrom: aFileName))			, '.', MCMcdReader extension! !!MCDiffyVersion class methodsFor: 'name utilities' stamp: 'bf 5/30/2005 17:39' prior: 23303654!nameForVer: versionName base: baseName	| baseId |	baseId := (versionName copyUpToLast: $.) = (baseName copyUpToLast: $.)		ifTrue: [baseName copyAfterLast: $.]		ifFalse: [(versionName copyUpToLast: $-) = (baseName copyUpToLast: $-)			ifTrue: [baseName copyAfterLast: $-]			ifFalse: ['@', baseName]].	^ versionName, '(', baseId, ')'! !!MCDiffyVersion class methodsFor: 'instance creation' stamp: 'avi 2/13/2004 23:07' prior: 23302304!package: aPackage info: aVersionInfo dependencies: aCollection baseInfo: baseVersionInfo patch:aPatch	^ self basicNew initializeWithPackage: aPackage info: aVersionInfo dependencies: aCollection baseInfo: baseVersionInfo patch:aPatch! !!MCDiffyVersion class methodsFor: 'instance creation' stamp: 'avi 2/13/2004 23:06' prior: 23302629!package: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection baseVersion: aVersion	^ self 		package: aPackage		info: aVersionInfo		dependencies: aCollection		baseInfo: aVersion info		patch: (aSnapshot patchRelativeToBase: aVersion snapshot)! !!MCDiffyVersion class methodsFor: 'name utilities' stamp: 'bf 5/30/2005 18:19' prior: 23304076!verNameFrom: diffName	^diffName copyUpTo: $(! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:17' prior: 23300411!baseInfo	^ base! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:39' prior: 23300512!baseSnapshot	^ (self workingCopy repositoryGroup versionWithInfo: base) snapshot! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'bf 5/23/2005 15:42' prior: 23300677!canOptimizeLoading	"Answer wether I can provide a patch for the working copy without the usual diff pass"	^ package hasWorkingCopy		and: [package workingCopy modified not			and: [package workingCopy ancestors includes: self baseInfo]]! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'bf 5/30/2005 17:39' prior: 23300999!fileName	^ (self class nameForVer: info name base: base name), '.', self writerClass extension! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23301190!initializeWithPackage: aPackage info: aVersionInfo dependencies: aCollection baseInfo: baseVersionInfo patch: aPatch	patch := aPatch.	base := baseVersionInfo.	super initializeWithPackage: aPackage info: aVersionInfo snapshot: nil dependencies: aCollection.! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:24' prior: 23301535!isDiffy	^ true! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:17' prior: 23301635!patch	^ patch! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23301745!snapshot	^ snapshot ifNil: [snapshot := MCPatcher apply: patch to: self baseSnapshot]! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/19/2004 22:03' prior: 23301916!summary	^ '(Diff against ', self baseInfo name, ')', String cr, super summary! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:17' prior: 23302079!writerClass	^ MCMcdWriter ! !!MCVersion class methodsFor: 'instance creation' stamp: 'ab 7/7/2003 16:13' prior: 23582610!package: aPackage	^ self package: aPackage info: MCVersionInfo new! !!MCVersion class methodsFor: 'instance creation' stamp: 'kph 12/6/2008 03:27' prior: 23582759!package: aPackage info: aVersionInfo	^ self package: aPackage info: aVersionInfo snapshot: (aPackage snapshotFor: aVersionInfo)! !!MCVersion class methodsFor: 'instance creation' stamp: 'cwp 11/7/2004 13:02' prior: 23582952!package: aPackage info: aVersionInfo snapshot: aSnapshot	^ self package: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: #()! !!MCVersion class methodsFor: 'instance creation' stamp: 'avi 1/19/2004 13:11' prior: 23583175!package: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection	^ self new initializeWithPackage: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection! !!MCVersion methodsFor: 'actions' stamp: 'kph 5/16/2007 11:44' prior: 23578565!addToCache	| repository |	MCCacheRepository default storeVersion: self.	 ! !!MCVersion methodsFor: 'actions' stamp: 'avi 2/12/2004 19:37' prior: 23578689!adopt	self workingCopy adopt: self! !!MCVersion methodsFor: 'enumerating' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23579755!allAvailableDependenciesDo: aBlock	| version |	self dependencies do:		[:ea |		[version := ea resolve.		version allAvailableDependenciesDo: aBlock.		aBlock value: version]			on: Error do: []]! !!MCVersion methodsFor: 'enumerating' stamp: 'cwp 11/7/2004 11:58' prior: 23580024!allDependenciesDo: aBlock	self allDependenciesDo: aBlock ifUnresolved: [:ignored | true]! !!MCVersion methodsFor: 'enumerating' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23580196!allDependenciesDo: aBlock ifUnresolved: failBlock	| dict |	dict := Dictionary new.	self allDependenciesNotIn: dict do: aBlock ifUnresolved: failBlock! !!MCVersion methodsFor: 'enumerating' stamp: 'cwp 11/7/2004 14:24' prior: 23580420!allDependenciesNotIn: aDictionary do: aBlock ifUnresolved: failBlock	| version |	self dependencies do: 		[:ea | 		version := aDictionary at: ea ifAbsent: [ea resolve].		version 			ifNil: [failBlock value: ea]			ifNotNil: [(aDictionary includes: version) ifFalse:						[aDictionary at: ea put: version.						version 							allDependenciesNotIn: aDictionary 							do: aBlock							ifUnresolved: failBlock.						aBlock value: version]]]! !!MCVersion methodsFor: 'converting' stamp: 'avi 2/19/2004 21:00' prior: 23579425!asDiffAgainst: aVersion	aVersion info = self info ifTrue: [self error: 'Cannot diff against self!!'].	^ MCDiffyVersion		package: self package		info: self info		snapshot: self snapshot		dependencies: self dependencies		baseVersion: aVersion! !!MCVersion methodsFor: 'actions' stamp: 'bf 3/22/2005 22:12' prior: 23578791!browse	(MCSnapshotBrowser forSnapshot: self snapshot)		showLabelled: 'Snapshot of ', self fileName! !!MCVersion methodsFor: '' stamp: 'kph 8/1/2007 12:25'!browseFrom: repository	 	self browse! !!MCVersion methodsFor: 'testing' stamp: 'bf 5/23/2005 15:43' prior: 23582141!canOptimizeLoading	"Answer wether I can provide a patch for the working copy without the usual diff pass"	^false! !!MCVersion methodsFor: 'accessing' stamp: 'mtf 10/7/2008 13:29' prior: 23577354!changes	^ self snapshot patchRelativeToBase: package patchSnapshot! !!MCVersion methodsFor: 'accessing' stamp: 'avi 1/22/2004 00:24' prior: 23577486!dependencies	^ dependencies ifNil: [#()]! !!MCVersion methodsFor: 'printing' stamp: 'kph 5/6/2007 03:05'!description	^ self info name 	 ! !!MCVersion methodsFor: 'accessing' stamp: 'avi 1/22/2004 12:44' prior: 23577597!fileName	^ info name, '.', self writerClass extension! !!MCVersion methodsFor: 'actions' stamp: 'avi 1/22/2004 12:44' prior: 23578959!fileOutOn: aStream	self writerClass fileOut: self on: aStream! !!MCVersion methodsFor: 'accessing' stamp: 'ab 7/7/2003 14:28' prior: 23577719!info	^ info! !!MCVersion methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23581397!initializeWithPackage: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection	package := aPackage.	info := aVersionInfo.	snapshot := aSnapshot.	dependencies := aCollection.	self addToCache.! !!MCVersion methodsFor: 'actions' stamp: 'kph 5/9/2007 18:41'!install	^ self load! !!MCVersion methodsFor: 'testing' stamp: 'bf 3/22/2005 23:00' prior: 23582322!isCacheable	^true! !!MCVersion methodsFor: 'testing' stamp: 'avi 2/13/2004 23:24' prior: 23582408!isDiffy	^ false! !!MCVersion methodsFor: 'actions' stamp: 'avi 1/24/2004 20:13' prior: 23579089!load	MCVersionLoader loadVersion: self! !!MCVersion methodsFor: '' stamp: 'kph 12/13/2008 17:38'!loadFrom: repository	self isCacheable			ifTrue: [ self workingCopy repositoryGroup addRepository: repository ].	 	self load.! !!MCVersion methodsFor: 'actions' stamp: 'abc 2/13/2004 15:58' prior: 23579196!merge	MCVersionMerger mergeVersion: self! !!MCVersion methodsFor: '' stamp: 'kph 12/13/2008 17:39'!mergeFrom: repository	self isCacheable			ifTrue: [ 					self workingCopy repositoryGroup addRepository: repository.				  	 .].	 	self merge.! !!MCVersion methodsFor: 'actions' stamp: 'kph 5/13/2007 16:48' prior: 23579304!open	^ (MCVersionInspector new version: self) show! !!MCVersion methodsFor: 'accessing' stamp: 'ab 7/7/2003 14:19' prior: 23577799!package	^ package! !!MCVersion methodsFor: 'printing' stamp: 'kph 5/6/2007 03:06' prior: 23581951!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self description.	aStream nextPut: $).! !!MCVersion methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23581700!setPackage: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection	package := aPackage.	info := aVersionInfo.	snapshot := aSnapshot.	dependencies := aCollection! !!MCVersion methodsFor: 'accessing' stamp: 'ab 7/7/2003 14:10' prior: 23577885!snapshot	^ snapshot! !!MCVersion methodsFor: 'accessing' stamp: 'avi 1/20/2004 16:07' prior: 23577975!summary	^ String streamContents:		[:s |		s nextPutAll: info summaryHeader.		(dependencies isNil or: [dependencies isEmpty]) ifFalse:			[s cr; nextPutAll: 'Dependencies: '.			dependencies				do: [:ea | s nextPutAll: ea versionInfo name]				separatedBy: [s nextPutAll: ', ']].		s cr; cr; nextPutAll: info message]! !!MCVersion methodsFor: 'enumerating' stamp: 'cwp 11/7/2004 14:24' prior: 23580939!withAllDependenciesDo: aBlock	self allDependenciesDo: aBlock ifUnresolved: [:ignored].	aBlock value: self! !!MCVersion methodsFor: 'enumerating' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23581129!withAllDependenciesDo: aBlock ifUnresolved: failBlock	| dict |	dict := Dictionary new.	self allDependenciesNotIn: dict do: aBlock ifUnresolved: failBlock.	aBlock value: self! !!MCVersion methodsFor: 'accessing' stamp: 'avi 2/12/2004 19:38' prior: 23578365!workingCopy	^ package workingCopy! !!MCVersion methodsFor: 'accessing' stamp: 'avi 1/22/2004 12:44' prior: 23578469!writerClass	^ MCMczWriter ! !!MCVersionDependency class methodsFor: 'as yet unclassified' stamp: 'avi 1/19/2004 13:13' prior: 23585954!package: aPackage info: aVersionInfo	^ self basicNew initializeWithPackage: aPackage info: aVersionInfo! !!MCVersionDependency methodsFor: 'comparing' stamp: 'avi 1/19/2004 16:12' prior: 23584060!= other	^ other species = self species		and: [other versionInfo = versionInfo				and: [other package = package]]! !!MCVersionDependency methodsFor: 'comparing' stamp: 'avi 1/19/2004 16:06' prior: 23583956!hash	^ versionInfo hash! !!MCVersionDependency methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23584276!initializeWithPackage: aPackage info: aVersionInfo	package := aPackage.	versionInfo := aVersionInfo! !!MCVersionDependency methodsFor: 'testing' stamp: 'bf 4/19/2005 16:29' prior: 23584676!isCurrent	^ package hasWorkingCopy		and: [self isFulfilled			and: [package workingCopy modified not]]! !!MCVersionDependency methodsFor: 'testing' stamp: 'bf 4/19/2005 16:29' prior: 23584857!isFulfilled	^package hasWorkingCopy		and: [self isFulfilledBy: package workingCopy ancestry]! !!MCVersionDependency methodsFor: 'testing' stamp: 'avi 3/4/2004 00:34' prior: 23585374!isFulfilledBy: anAncestry	^ anAncestry ancestors includes: versionInfo! !!MCVersionDependency methodsFor: 'testing' stamp: 'bf 4/19/2005 16:29' prior: 23585028!isFulfilledByAncestors	^ package hasWorkingCopy		and: [self isFulfilledByAncestorsOf: package workingCopy ancestry]! !!MCVersionDependency methodsFor: 'testing' stamp: 'nk 7/13/2004 08:45' prior: 23585222!isFulfilledByAncestorsOf: anAncestry	^ anAncestry hasAncestor: versionInfo! !!MCVersionDependency methodsFor: 'testing' stamp: 'bf 4/19/2005 16:29' prior: 23585522!isOlder	"Answer true if I represent an older version of a package that is loaded."	^ package hasWorkingCopy		and: [self isFulfilled not			and: [ self isFulfilledByAncestors				and: [package workingCopy modified not]]]! !!MCVersionDependency methodsFor: 'accessing' stamp: 'avi 1/19/2004 15:40' prior: 23583612!package	^ package! !!MCVersionDependency methodsFor: 'accessing' stamp: 'avi 2/12/2004 19:38' prior: 23583710!repositoryGroup	^ self package workingCopy repositoryGroup! !!MCVersionDependency methodsFor: 'resolving' stamp: 'nk 6/13/2004 19:21' prior: 23584457!resolve	^ self repositoryGroup		versionWithInfo: versionInfo		ifNone: [ MCRepositoryGroup default versionWithInfo: versionInfo ifNone: []]! !!MCVersionDependency methodsFor: 'accessing' stamp: 'avi 1/19/2004 15:40' prior: 23583849!versionInfo	^ versionInfo! !!MCVersionLoader class methodsFor: 'as yet unclassified' stamp: 'avi 1/24/2004 20:06' prior: 23602490!loadVersion: aVersion	self new		addVersion: aVersion;		load! !!MCVersionLoader methodsFor: 'loading' stamp: 'cwp 11/7/2004 17:06' prior: 23601402!addDependency: aDependency	| dep |	aDependency isCurrent ifTrue: [^ self].	(self depAgeIsOk: aDependency) ifFalse: [^ self].	dep := aDependency resolve.	dep		ifNil: [self confirmMissingDependency: aDependency]		ifNotNil: [(versions includes: dep) ifFalse: [self addVersion: dep]]! !!MCVersionLoader methodsFor: 'loading' stamp: 'cwp 11/7/2004 17:04' prior: 23601762!addVersion: aVersion	aVersion dependencies do: [ :ea | self addDependency: ea].	versions add: aVersion.! !!MCVersionLoader methodsFor: 'loading' stamp: 'kph 12/3/2008 17:27'!browse	^ versions do: #browse! !!MCVersionLoader methodsFor: 'checking' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23599863!checkForModifications	| modifications |	modifications := versions select: [:ea | ea package workingCopy modified].	modifications isEmpty ifFalse: [self warnAboutLosingChangesTo: modifications].! !!MCVersionLoader methodsFor: 'checking' stamp: 'cwp 11/7/2004 17:00' prior: 23600134!checkIfDepIsOlder: aDependency	^ aDependency isOlder not 		or: [self confirm: 'load older dependency ', aDependency versionInfo name , '?']! !!MCVersionLoader methodsFor: 'checking' stamp: 'cwp 11/7/2004 17:06' prior: 23600350!confirmMissingDependency: aDependency	| name |	name := aDependency versionInfo name.	(self confirm: 'Can''t find dependency ', name, '. ignore?')		ifFalse: [self error: 'Can''t find dependency ', name]! !!MCVersionLoader methodsFor: 'checking' stamp: 'cwp 11/7/2004 17:02' prior: 23600630!depAgeIsOk: aDependency	^ aDependency isOlder not 		or: [self confirm: 'load older dependency ', aDependency versionInfo name , '?']! !!MCVersionLoader methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23601282!initialize	versions := OrderedCollection new! !!MCVersionLoader methodsFor: 'loading' stamp: 'bf 3/16/2006 19:03' prior: 23601953!load	self loadWithNameLike: versions first info name.! !!MCVersionLoader methodsFor: 'loading' stamp: 'kph 12/7/2008 02:30'!loadWithNameLike: aString	| loader |	self checkForModifications.	loader := MCPackageLoader newCurrent.	versions size > 1 ifTrue: [ loader beMultiplePackage ].	 	versions do: [:ea |		ea canOptimizeLoading			ifTrue: [ea patch applyTo: loader]			ifFalse: [loader updatePackage: ea package withSnapshot: ea snapshot			]	].	loader 	installOrphanage;			loadWithNameLike: aString.	versions do: [:ea | ea workingCopy loaded: ea]! !!MCVersionLoader methodsFor: 'loading' stamp: 'kph 12/2/2008 20:13'!open	^ versions do: #open! !!MCVersionLoader methodsFor: 'checking' stamp: 'avi 1/24/2004 20:17' prior: 23600839!warnAboutLosingChangesTo: versionCollection	self notify: (String streamContents: [:s |		s nextPutAll: 'You are about to load new versions of the following packages that have unsaved changes in the image.  If you continue, you will lose these changes.'; cr.		versionCollection do:			[:ea |			s cr; space; space; nextPutAll: ea package name]])! !!MCVersionMerger class methodsFor: 'as yet unclassified' stamp: 'bf 12/5/2004 12:35' prior: 23604480!mergeVersion: aVersion	self new		addVersion: aVersion;		mergeWithNameLike: aVersion info name! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23602929!addVersion: aVersion	| dep |	records add: (MCMergeRecord version: aVersion).	aVersion dependencies do:		[:ea |		dep := ea resolve.		(records anySatisfy: [:r | r version = dep]) ifFalse: [self addVersion: dep]]! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23603241!initialize	records := OrderedCollection new.	merger := MCThreeWayMerger new.! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'abc 2/13/2004 17:15' prior: 23603405!merge	records do: [:ea | merger addBaseSnapshot: ea packageSnapshot].	records do: [:ea | merger applyPatch: ea mergePatch].	self resolveConflicts ifTrue:		[merger load.		records do: [:ea | ea updateWorkingCopy]].! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'bf 12/5/2004 12:32' prior: 23603707!mergeWithNameLike: baseName	records do: [:ea | merger addBaseSnapshot: ea packageSnapshot].	records do: [:ea | merger applyPatch: ea mergePatch].	self resolveConflicts ifTrue:		[merger loadWithNameLike: baseName.		records do: [:ea | ea updateWorkingCopy]].! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'bf 4/26/2005 14:29' prior: 23604053!resolveConflicts	(records allSatisfy: [:ea | ea isAncestorMerge]) ifTrue: [MCNoChangesException signal. ^ false].	^ ((MCMergeResolutionRequest new merger: merger)		signal: 'Merging ', records first version info name) = true! !!MCVersionNotification class methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 14:27' prior: 23607678!version: aVersion repository: aRepository	^ self basicNew initializeWithVersion: aVersion repository: aRepository! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 15:13' prior: 23605741!fromAddress	^ 'monticello@beta4.com'! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23605881!initializeWithVersion: aVersion repository: aRepository	version := aVersion.	repository := aRepository.	ancestor := repository closestAncestorVersionFor: version info ifNone: []. 	changes := ancestor				ifNil: [#()]				ifNotNil: [(version snapshot patchRelativeToBase: ancestor snapshot) 							operations asSortedCollection]! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'avi 8/26/2004 15:12' prior: 23606304!messageText	^ String streamContents:		[:s |		s nextPutAll: 'Committed to repository: ', repository description; cr; cr.		s nextPutAll: version summary.		changes isEmpty ifFalse:			[s cr; cr.			s nextPutAll: '-----------------------------------------------------'; cr.			s nextPutAll: 'Changes since ', ancestor info name, ':'; cr.			changes do:			[:ea |			s cr; nextPutAll: ea summary; cr.			s nextPutAll: ea sourceString]]]! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23606843!messageTo: aString	| message |	message := MailMessage empty.	message setField: 'from' toString: self fromAddress.	message setField: 'to' toString: aString.	message setField: 'subject' toString: '[MC] ', version info name.	message body: (MIMEDocument contentType: 'text/plain' content: self messageText).	^ message! !!MCVersionNotification methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23607266!notify: aString	| message |	message := self messageTo: aString.	SMTPClient		deliverMailFrom: message from		to: (Array with: message to)		text: message text		usingServer: MailSender smtpServer! !!MCVersionSorter commentStamp: 'kph 5/16/2007 19:47' prior: 0!For sorting versions.MCFileRepositories use their own scheme for sorting versions.!!MCFilteredVersionSorter methodsFor: 'as yet unclassified' stamp: 'bf 5/28/2005 01:14' prior: 23328821!addVersionInfo: aVersionInfo	(aVersionInfo hasAncestor: target)		ifTrue: [super addVersionInfo: aVersionInfo]! !!MCFilteredVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23329038!processVersionInfo: aVersionInfo	| success |	aVersionInfo = target ifTrue: [^ true].	self pushLayer.	success := (self knownAncestorsOf: aVersionInfo) anySatisfy:				[:ea | self processVersionInfo: ea].	self popLayer.	success ifTrue: [self addToCurrentLayer: aVersionInfo].	^ success	! !!MCFilteredVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23329434!target: aVersionInfo	target := aVersionInfo! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 14:19' prior: 23614421!addAllAncestorsOf: aVersionInfo to: aSet	(aSet includes: aVersionInfo) ifTrue: [^ self].	aSet add: aVersionInfo.	(self knownAncestorsOf: aVersionInfo) do:		[:ea |		self addAllAncestorsOf: ea to: aSet]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 8/31/2003 21:30' prior: 23614712!addAllVersionInfos: aCollection	aCollection do: [:ea | self addVersionInfo: ea]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'kph 5/16/2007 20:06'!addAllVersions: aCollection	aCollection do: [:ea | self addVersionInfo: ea info]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23614889!addToCurrentLayer: aVersionInfo	| layer |	layer := layers at: depthIndex.	(layer includes: aVersionInfo) ifFalse:		[depths at: aVersionInfo ifPresent:			[:i |			i < depthIndex				ifTrue: [(layers at: i) remove: aVersionInfo]				ifFalse: [^ false]].		layer add: aVersionInfo.		depths at: aVersionInfo put: depthIndex.		^ true].	^ false ! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:49' prior: 23615322!addVersionInfo: aVersionInfo	roots add: aVersionInfo.	self registerStepChildrenOf: aVersionInfo seen: Set new! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23615530!allAncestorsOf: aVersionInfo	| all |	all := Set new.	self addAllAncestorsOf: aVersionInfo to: all.	^ all! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23615735!initialize	stepparents := Dictionary new.	roots := OrderedCollection new.! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 14:37' prior: 23615896!knownAncestorsOf: aVersionInfo	^ aVersionInfo ancestors, (self stepParentsOf: aVersionInfo) asArray! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'ab 8/17/2003 15:53' prior: 23616081!layers	^ layers! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23616194!popLayer	depthIndex := depthIndex - 1! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:39' prior: 23616318!processVersionInfo: aVersionInfo	(self addToCurrentLayer: aVersionInfo) ifTrue:		[self pushLayer.		(self knownAncestorsOf: aVersionInfo) do: [:ea | self processVersionInfo: ea].		self popLayer]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23616613!pushLayer	depthIndex := depthIndex + 1.	depthIndex > layers size ifTrue: [layers add: OrderedCollection new].	! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 14:34' prior: 23616812!registerStepChildrenOf: aVersionInfo seen: aSet	(aSet includes: aVersionInfo) ifTrue: [^ self].	aSet add: aVersionInfo.	aVersionInfo stepChildren do: [:ea | (self stepParentsOf: ea) add: aVersionInfo].	aVersionInfo ancestors do: [:ea | self registerStepChildrenOf: ea seen: aSet].! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23617193!sortedVersionInfos	layers := OrderedCollection with: OrderedCollection new.	depthIndex := 1.	depths := Dictionary new.	roots do: [:ea | self processVersionInfo: ea].	^ layers gather: [:ea | ea]! !!MCVersionSorter methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 10:40' prior: 23617477!stepParentsOf: aVersionInfo	^ (stepparents at: aVersionInfo ifAbsentPut: [Set new])! !!MCMcmWriter class methodsFor: 'writing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23351669!fileOut: aConfiguration on: aStream	| inst |	inst := self on: aStream.	inst writeConfiguration: aConfiguration.	inst close.	! !!MCMcmWriter class methodsFor: 'accessing' stamp: 'bf 3/22/2005 10:49' prior: 23351555!readerClass	^ MCMcmReader! !!MCMcmWriter methodsFor: 'writing' stamp: 'bf 3/22/2005 18:00' prior: 23350864!close	stream close! !!MCMcmWriter methodsFor: 'writing' stamp: 'bf 3/24/2005 01:50' prior: 23350952!writeConfiguration: aConfiguration	stream nextPut: $(.	aConfiguration repositories do: [:ea | 		stream cr.		stream nextPutAll: 'repository '.		(MCConfiguration repositoryToArray: ea) printElementsOn: stream].	aConfiguration dependencies do: [:ea | 		stream cr.		stream nextPutAll: 'dependency '.		(MCConfiguration dependencyToArray: ea) printElementsOn: stream].	stream cr.	stream nextPut: $).	stream cr.! !!MCMcdWriter class methodsFor: 'as yet unclassified' stamp: 'avi 2/13/2004 23:09' prior: 23349557!readerClass	^ MCMcdReader! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23348068!writeBaseInfo: aVersionInfo	| string |	string := self serializeVersionInfo: aVersionInfo.	self addString: string at: 'base'.! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 01:48' prior: 23348278!writeDefinitions: aVersion	self writeBaseInfo: aVersion baseInfo.	self writePatch: aVersion patch.! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 02:07' prior: 23348460!writeNewDefinitions: aCollection	self addString: (self serializeDefinitions: aCollection) at: 'new/source.', self snapshotWriterClass extension.! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'avi 2/17/2004 02:07' prior: 23348687!writeOldDefinitions: aCollection	self addString: (self serializeDefinitions: aCollection) at: 'old/source.', self snapshotWriterClass extension.! !!MCMcdWriter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23348925!writePatch: aPatch	| old new |	old := OrderedCollection new.	new := OrderedCollection new.	aPatch operations do:		[:ea |		ea isRemoval ifTrue: [old add: ea definition].		ea isAddition ifTrue: [new add: ea definition].		ea isModification ifTrue: [old add: ea baseDefinition. new add: ea definition]].	self writeOldDefinitions: old.	self writeNewDefinitions: new.	self addString: (self serializeInBinary: aPatch) at: 'patch.bin'.! !!MCMczWriter class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23362068!fileOut: aVersion on: aStream	| inst |	inst := self on: aStream.	inst writeVersion: aVersion.	inst flush.	! !!MCMczWriter class methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 12:35' prior: 23362386!readerClass	^ MCMczReader! !!MCMczWriter methodsFor: 'writing' stamp: 'kph 12/6/2008 00:09'!addFile: aFile at: path	(zip addFile: aFile as: path) desiredCompressionMethod: ZipArchive compressionDeflated 	! !!MCMczWriter methodsFor: 'writing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23361603!addString: string at: path	| member |	member := zip addString: string as: path.	member desiredCompressionMethod: ZipArchive compressionDeflated 	! !!MCMczWriter methodsFor: 'writing' stamp: 'avi 2/17/2004 02:17' prior: 23361822!flush	zip writeTo: stream.	stream close! !!MCMczWriter methodsFor: 'accessing' stamp: 'avi 2/17/2004 01:54' prior: 23358761!format	^ '1'! !!MCMczWriter methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23359047!initialize	zip := ZipArchive new.! !!MCMczWriter methodsFor: 'serializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23359168!serializeDefinitions: aCollection	| writer s |	s := RWBinaryOrTextStream on: String new.	writer := self snapshotWriterClass on: s.	writer writeDefinitions: aCollection.	^ s contents! !!MCMczWriter methodsFor: 'serializing' stamp: 'kph 12/7/2008 03:27' prior: 23359439!serializeInBinary: anObject	| writer s |	s := RWBinaryOrTextStream on: String new.	writer := DataStream on: s.	writer nextPut: anObject.	^ s contents! !!MCMczWriter methodsFor: 'serializing' stamp: 'cwp 8/13/2003 01:06' prior: 23359669!serializePackage: aPackage	^ '(name ''', aPackage name, ''')'! !!MCMczWriter methodsFor: 'serializing' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23359816!serializeVersionInfo: aVersionInfo	infoWriter ifNil: [infoWriter := MCVersionInfoWriter new].	^ String streamContents:		[:s |		infoWriter stream: s.		infoWriter writeVersionInfo: aVersionInfo]! !!MCMczWriter methodsFor: 'accessing' stamp: 'avi 2/17/2004 02:07' prior: 23358846!snapshotWriterClass	^ MCStWriter! !!MCMczWriter methodsFor: 'visiting' stamp: 'kph 12/6/2008 04:48' prior: 23360085!writeDefinitions: aVersion	self writeSnapshot: aVersion snapshot.	! !!MCMczWriter methodsFor: 'files' stamp: 'kph 12/6/2008 05:37'!writeFile: definition	self addFile: definition pathToSnapshotFull at: definition pathToSnapshot	 ! !!MCMczWriter methodsFor: 'writing' stamp: 'kph 12/7/2008 03:33'!writeFiles: definitions	definitions ifNil: [ ^ self ].	definitions ifEmpty: [ ^self ]. 	definitions do: [ :ea | self writeFile: ea ].! !!MCMczWriter methodsFor: 'visiting' stamp: 'avi 2/17/2004 01:56' prior: 23360221!writeFormat"	self addString: self format at: 'format'."! !!MCMczWriter methodsFor: 'visiting' stamp: 'avi 2/17/2004 01:48' prior: 23360348!writePackage: aPackage	self addString: (self serializePackage: aPackage) at: 'package'! !!MCMczWriter methodsFor: 'visiting' stamp: 'avi 9/28/2004 14:26' prior: 23360506!writeSnapshot: aSnapshot	self addString: (self serializeDefinitions: aSnapshot definitions) at: 'snapshot/source.', self snapshotWriterClass extension.	self addString: (self serializeInBinary: aSnapshot) at: 'snapshot.bin'! !!MCMczWriter methodsFor: 'visiting' stamp: 'kph 12/7/2008 03:33' prior: 23361302!writeVersion: aVersion	self writeFormat.	self writePackage: aVersion package.	self writeVersionInfo: aVersion info.	self writeDefinitions: aVersion.	aVersion dependencies do: [:ea | self writeVersionDependency: ea].	self writeFiles: (aVersion snapshot definitions select: [ :ea | ea isFileDefinition ]).! !!MCMczWriter methodsFor: 'visiting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23360812!writeVersionDependency: aVersionDependency	| string |	string := (self serializeVersionInfo: aVersionDependency versionInfo).	self addString: string at: 'dependencies/', aVersionDependency package name! !!MCMczWriter methodsFor: 'visiting' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23361097!writeVersionInfo: aVersionInfo	| string |	string := self serializeVersionInfo: aVersionInfo.	self addString: string at: 'version'.! !!MCMczWriter methodsFor: 'accessing' stamp: 'cwp 8/1/2003 00:06' prior: 23358950!zip	^ zip! !!MCStWriter class methodsFor: 'as yet unclassified' stamp: 'avi 1/20/2004 00:16' prior: 23532904!readerClass	^ MCStReader! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/2/2003 02:34' prior: 23530129!chunkContents: aBlock	stream cr; nextChunkPut: (String streamContents: aBlock); cr! !!MCStWriter methodsFor: 'visiting' stamp: 'cwp 8/2/2003 11:02' prior: 23528752!visitClassDefinition: definition	self writeClassDefinition: definition.	definition hasClassInstanceVariables ifTrue: [self writeMetaclassDefinition: definition].	definition hasComment ifTrue: [self writeClassComment: definition].! !!MCStWriter methodsFor: 'visiting' stamp: 'al 10/9/2005 19:52' prior: 23529053!visitClassTraitDefinition: definition	self chunkContents: [:s | s		nextPutAll: definition baseTrait;		nextPutAll: ' classTrait';		cr; tab;		nextPutAll: 'uses: ';		nextPutAll: (definition classTraitComposition ifNil: ['{}'])]! !!MCStWriter methodsFor: 'visiting' stamp: 'al 10/9/2005 19:40' prior: 23529353!visitMetaclassDefinition: definition	self writeMetaclassDefinition: definition! !!MCStWriter methodsFor: 'visiting' stamp: 'avi 2/17/2004 02:23' prior: 23529502!visitMethodDefinition: definition	self writeMethodPreamble: definition.	self writeMethodSource: definition.	self writeMethodPostscript.	self writeMethodInitializer: definition.! !!MCStWriter methodsFor: 'visiting' stamp: 'cwp 8/2/2003 11:02' prior: 23529751!visitOrganizationDefinition: defintion	defintion categories do: [:cat | self writeCategory: cat].! !!MCStWriter methodsFor: 'visiting' stamp: 'al 10/9/2005 19:40' prior: 23529919!visitTraitDefinition: definition	self writeClassDefinition: definition.	definition hasComment ifTrue: [self writeClassComment: definition].! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/2/2003 01:46' prior: 23530280!writeCategory: categoryName	stream		nextChunkPut: 'SystemOrganization addCategory: ', categoryName printString;		cr! !!MCStWriter methodsFor: 'writing' stamp: 'ab 8/17/2003 17:09' prior: 23530466!writeClassComment: definition	stream		cr;		nextPut: $!!;		nextPutAll: definition className;		nextPutAll: ' commentStamp: ';		store: definition commentStamp;		nextPutAll: ' prior: 0!!';		cr;		nextChunkPut: definition comment;		cr.! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/2/2003 02:16' prior: 23530773!writeClassDefinition: definition	self chunkContents: [:s | definition printDefinitionOn: stream]! !!MCStWriter methodsFor: 'writing' stamp: 'dvf 9/8/2004 10:28' prior: 23530938!writeDefinitions: aCollection	"initStream is an ugly hack until we have proper init defs"	initStream := String new writeStream.	(MCDependencySorter sortItems: aCollection)		do: [:ea | ea accept: self]		displayingProgress: 'Writing definitions...'.		stream nextPutAll: initStream contents.! !!MCStWriter methodsFor: 'writing' stamp: 'al 12/2/2005 15:17' prior: 23531302!writeMetaclassDefinition: definition	self chunkContents: [:str |		str	nextPutAll: definition className;			nextPutAll: ' class';			cr; tab.			definition hasClassTraitComposition ifTrue: [				str	nextPutAll: 'uses: ';					nextPutAll: definition classTraitCompositionString;					cr; tab].			str	nextPutAll: 'instanceVariableNames: ''';				nextPutAll: definition classInstanceVariablesString;				nextPut: $']! !!MCStWriter methodsFor: 'writing' stamp: 'avi 2/17/2004 02:24' prior: 23531786!writeMethodInitializer: aMethodDefinition	aMethodDefinition isInitializer ifTrue:		[initStream nextChunkPut: aMethodDefinition className, ' initialize'; cr]! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/2/2003 12:43' prior: 23532012!writeMethodPostscript	stream		space;		nextPut: $!!;		cr! !!MCStWriter methodsFor: 'writing' stamp: 'avi 9/23/2003 17:42' prior: 23532140!writeMethodPreamble: definition	stream		cr;		nextPut: $!!;		nextPutAll: definition fullClassName;		nextPutAll: ' methodsFor: ';		nextPutAll: definition category asString printString;		nextPutAll: ' stamp: ';		nextPutAll: definition timeStamp asString printString;		nextPutAll: '!!';		cr! !!MCStWriter methodsFor: 'writing' stamp: 'cwp 8/4/2003 01:35' prior: 23532504!writeMethodSource: definition	stream nextChunkPut: definition source! !!MCStWriter methodsFor: 'writing' stamp: 'avi 2/17/2004 02:25' prior: 23532642!writeSnapshot: aSnapshot	self writeDefinitions: aSnapshot definitions! !!MCVersionInfoWriter methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 21:10' prior: 23593963!isWritten: aVersionInfo	^ self written includes: aVersionInfo! !!MCVersionInfoWriter methodsFor: 'as yet unclassified' stamp: 'avi 9/13/2004 16:53' prior: 23594115!writeVersionInfo: aVersionInfo	(self isWritten: aVersionInfo)		ifTrue: [^ stream nextPutAll: '(id ', aVersionInfo id asString printString, ')'].	stream nextPut: $(.	#(name message id date time author) 		do: [:sel | 			stream nextPutAll: sel.			stream nextPut: $ .			((aVersionInfo perform: sel) ifNil: ['']) asString printOn: stream.			stream nextPut: $ ].	stream nextPutAll: 'ancestors ('.	aVersionInfo ancestors do: [:ea | self writeVersionInfo: ea].	stream nextPutAll: ') stepChildren ('.	aVersionInfo stepChildren do: [:ea | self writeVersionInfo: ea].	stream nextPutAll: '))'.	self wrote: aVersionInfo! !!MCVersionInfoWriter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23594837!written	^ written ifNil: [written := Set new]! !!MCVersionInfoWriter methodsFor: 'as yet unclassified' stamp: 'avi 1/22/2004 21:10' prior: 23594973!wrote: aVersionInfo	self written add: aVersionInfo! !!MCWriter class methodsFor: 'accessing' stamp: 'cwp 8/1/2003 15:00' prior: 23664455!extension	^ self readerClass extension! !!MCWriter class methodsFor: 'writing' stamp: 'cwp 8/1/2003 01:16' prior: 23664685!on: aStream	^ self new stream: aStream! !!MCWriter class methodsFor: 'accessing' stamp: 'cwp 7/28/2003 23:46' prior: 23664569!readerClass	^ self subclassResponsibility ! !!MCWriter methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 01:14' prior: 23664138!stream	^ stream! !!MCWriter methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23664244!stream: aStream	stream := aStream! !!Object methodsFor: '*monticello' stamp: 'dvf 8/10/2004 23:25' prior: 25830784!isConflict	^false! !!FilePackage methodsFor: '*monticello' stamp: 'al 12/2/2005 13:58' prior: 20718545!classDefinition: string with: chgRec	| tokens theClass |		self flag: #traits.			tokens := Scanner new scanTokens: string.	"tokens size = 11 ifFalse:[^doIts add: chgRec]."	theClass := self getClass: (tokens at: 3).	theClass definition: string.	classOrder add: theClass.! !!FilePackage methodsFor: '*monticello' stamp: 'avi 1/19/2004 23:47' prior: 20718898!doIts	^ doIts! !!MCDependentsWrapper methodsFor: 'as yet unclassified' stamp: 'ar 2/14/2004 02:31' prior: 23295555!asString	^item description! !!MCDependentsWrapper methodsFor: 'as yet unclassified' stamp: 'avi 9/10/2004 17:54' prior: 23295672!contents	| list workingCopies |	workingCopies := model unsortedWorkingCopies.	list := item requiredPackages collect: 					[:each | 					workingCopies detect: [:wc | wc package = each] ifNone: [nil]]				thenSelect: [:x | x notNil].	^list collect: [:each | self class with: each model: model]! !!MCDependentsWrapper methodsFor: 'as yet unclassified' stamp: 'ar 2/14/2004 02:31' prior: 23296058!hasContents	^item requiredPackages isEmpty not! !!MCDependentsWrapper methodsFor: 'as yet unclassified' stamp: 'ar 2/14/2004 02:41' prior: 23296194!item	^item! !!MCPseudoFileStream commentStamp: '<historical>' prior: 23447584!A pseudo file stream which can be used for updates.!!MCPseudoFileStream methodsFor: 'accessing' stamp: 'ar 4/14/2005 19:54' prior: 23447712!localName	^localName! !!MCPseudoFileStream methodsFor: 'accessing' stamp: 'ar 4/14/2005 19:54' prior: 23447811!localName: aString	localName := aString! !!ChangeList class methodsFor: '*monticello' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 18224817!recent: charCount on: origChangesFile 	"Opens a changeList on the end of the specified changes log file"	| changeList end changesFile |	changesFile := origChangesFile readOnlyCopy.	end := changesFile size.	Cursor read		showWhile: [changeList := self new						scanFile: changesFile						from: (0 max: end - charCount)						to: end].	changesFile close.	^changeList! !!ChangeList class methodsFor: '*monticello' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 18223710!recentLogOn: origChangesFile startingFrom: initialPos 	"Prompt with a menu of how far back to go when browsing a changes file."	| end banners positions pos chunk i changesFile |	changesFile := origChangesFile readOnlyCopy.	banners := OrderedCollection new.	positions := OrderedCollection new.	end := changesFile size.	pos := initialPos.	[pos = 0		or: [banners size > 20]]		whileFalse: [changesFile position: pos.			chunk := changesFile nextChunk.			i := chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.			i > 0				ifTrue: [positions addLast: pos.					banners						addLast: (chunk copyFrom: 5 to: i - 2).					pos := Number								readFrom: (chunk copyFrom: i + 13 to: chunk size)]				ifFalse: [pos := 0]].	changesFile close.	banners size == 0 ifTrue: [^self recent: end on: origChangesFile].	pos := (SelectionMenu labelList: banners selections: positions)				startUpWithCaption: 'Browse as far back as...'.	pos == nil		ifTrue: [^ self].	^self recent: end - pos on: origChangesFile! !!ChangeList methodsFor: '*monticello' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 18210804!changeTo: changeSubset	| newList newChangeList |	newChangeList := OrderedCollection new.	newList := OrderedCollection new.	1 to: changeList size do:		[:i | (changeSubset includes: (changeList at: i)) ifTrue:			[newChangeList add: (changeList at: i).			newList add: (list at: i)]].	newChangeList size < changeList size		ifTrue:			[changeList := newChangeList.			list := newList.			listIndex := 0.			listSelections := Array new: list size withAll: false].	self changed: #list	! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'avi 9/14/2004 15:01' prior: 23213275!defaultAction	^ (MCChangeSelector new patch: patch; label: label) showModally! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'avi 9/14/2004 15:02' prior: 23213448!label	^ label! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23213568!label: aString	label := aString! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2004 15:12' prior: 23213695!patch	^ patch! !!MCChangeSelectionRequest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23213815!patch: aPatch	patch := aPatch! !!MCMergeResolutionRequest methodsFor: 'as yet unclassified' stamp: 'bf 4/26/2005 14:25' prior: 23370448!defaultAction	^ (MCMergeBrowser new		merger: merger;		label: messageText) showModally! !!MCMergeResolutionRequest methodsFor: 'as yet unclassified' stamp: 'ab 7/18/2003 18:19' prior: 23370630!merger	^ merger! !!MCMergeResolutionRequest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23370752!merger: aMerger	merger := aMerger! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 20:39' prior: 23604973!defaultAction	^ MCSaveVersionDialog new		versionName: suggestion;		showModally! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'ab 7/10/2003 01:07' prior: 23605154!suggestedName	^ suggestion! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47' prior: 23605293!suggestedName: aString	suggestion := aString! !!MCOrphanedNotification class methodsFor: 'as yet unclassified' stamp: 'kph 5/15/2007 13:05'!orphan: aDefinition signal: reason		^(self new)		orphan: aDefinition;		signal: reason		yourself! !!MCOrphanedNotification methodsFor: 'accessing' stamp: 'kph 5/13/2007 04:53'!orphan	"Answer the value of orphan"	^ orphan! !!MCOrphanedNotification methodsFor: 'accessing' stamp: 'kph 5/13/2007 04:53'!orphan: anObject	"Set the value of orphan"	orphan := anObject! !!PackageInfo class methodsFor: '*monticello-orphanage' stamp: 'kph 5/14/2007 13:28'!orphanage	^ MCOrphanage current! !!PackageInfo methodsFor: '*monticello-orphanage' stamp: 'kph 5/14/2007 16:58'!allClassesAsDefinitions	^ self loadedClassesAsDefinitions , self orphanedClassesAsDefinitons! !!PackageInfo methodsFor: '*monticello-base' stamp: 'kph 8/3/2008 03:57'!manager	^ self propertyAt: #mc! !!PackageInfo methodsFor: '*monticello-base' stamp: 'kph 8/3/2008 03:58'!manager: mcPackageManager	^ self propertyAt: #mc put: mcPackageManager! !!PackageInfo methodsFor: '*monticello-orphanage' stamp: 'kph 5/14/2007 13:36'!orphanedClassesAsDefinitons	  "convenience method implemented here to enable users of packageInfo to be aware that there are additional classes in the orphanage which belong to this package."		^ (self class orphanage orphansFor: self) select: [ :m | m isClassDefinition ]  ! !!PackageInfo methodsFor: '*monticello-orphanage' stamp: 'kph 5/14/2007 13:31'!orphanedMethodsAsDefinitons	  "convenience method implemented here to enable users of packageInfo to be aware that there are additional methods in the orphanage which belong to this package."		^ (self class orphanage orphansFor: self) select: [ :m | m isMethodDefinition ]  ! !!ChangeRecord methodsFor: '*monticello' stamp: 'avi 9/14/2004 14:27' prior: 18234082!asMethodDefinition	^ MCMethodDefinition 		className: class		classIsMeta: meta		selector: self methodSelector		category: category		timeStamp: stamp		source: self string! !!Encoder methodsFor: '*monticello-override' stamp: 'mtf 6/9/2008 20:43' prior: 20176268!undeclared: name	| sym | 	requestor interactive ifTrue: [		requestor requestor == #error: ifTrue: [requestor error: 'Undeclared'].		^ self notify: 'Undeclared'].	"Transcript show: ' (' , name , ' is Undeclared) '."	sym := name asSymbol.	Undeclared at: sym put: nil.	^self global: (Undeclared associationAt: sym) name: sym! !!SequenceableCollection methodsFor: '*monticello' stamp: 'mtf 6/27/2008 23:03'!mcLessThan: otherCollection ifEqual: aBlock	| a b |	1 to: (self size min: otherCollection size) do: [:index |		a := self at: index. b := otherCollection at: index.		a ~= b ifTrue: [ ^ a <= b ]].	^ self size ~= otherCollection size		ifTrue: [self size <= otherCollection size]		ifFalse: [aBlock value]! !!MCNoChangesException methodsFor: 'as yet unclassified' stamp: 'jf 8/21/2003 19:49' prior: 23406746!defaultAction	self inform: 'No changes'! !!MCClassBuilder methodsFor: 'as yet unclassified' stamp: 'kph 6/7/2008 03:28'!doneCompiling: aClass	"The receiver has finished modifying the class hierarchy.	Do any necessary cleanup."	aClass doneCompiling.	! !!MCClassBuilder methodsFor: 'as yet unclassified' stamp: 'kph 6/7/2008 01:31'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class in the given environment.	If unsafe is true do not run any validation checks.	This facility is provided to implement important system changes."	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory | 	environ := env.	instVars := Scanner new scanFieldNames: instVarString.	classVars := (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass := env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse: [oldClass := nil]  "Already checked in #validateClassName:"		ifTrue: [			copyOfOldClass := oldClass copy.			copyOfOldClass superclass addSubclass: copyOfOldClass].			[unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"See if we need a new subclass"	needNew := self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.	needNew == nil ifTrue:[^nil]. "some error"	(needNew and:[unsafe not]) ifTrue:[		"Make sure we don't redefine any dangerous classes"		(self tooDangerousClasses includes: oldClass name) ifTrue:[			self error: oldClass name, ' cannot be changed'.		].		"Check if the receiver should not be redefined"		(oldClass ~~ nil and:[oldClass shouldNotBeRedefined]) ifTrue:[			self notify: oldClass name asText allBold, 						' should not be redefined. \Proceed to store over it.' withCRs]].	needNew ifTrue:[		"Create the new class"		newClass := self 			newSubclassOf: newSuper 			type: type 			instanceVariables: instVars			from: oldClass.		newClass == nil ifTrue:[^nil]. "Some error"		newClass setName: className.	] ifFalse:[		"Reuse the old class"		newClass := oldClass.	].	"Install the class variables and pool dictionaries... "	force := (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	newCategory := category asSymbol.	organization := environ ifNotNil:[environ organization].	oldClass isNil ifFalse: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].	organization classify: newClass name under: newCategory.	newClass environment: environ.	"... recompile ..."	newClass := self recompile: force from: oldClass to: newClass mutate: false.	"... export if not yet done ..."	(environ at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		[environ at: newClass name put: newClass]			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].		Smalltalk flushClassNameCache.	].	"... notify interested clients ..."	oldClass isNil ifTrue: [		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.		^ newClass].	newCategory ~= oldCategory 		ifTrue: [SystemChangeNotifier uniqueInstance class: newClass recategorizedFrom: oldCategory to: category]		ifFalse: [SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.].] ensure: 		[copyOfOldClass ifNotNil: [copyOfOldClass superclass removeSubclass: copyOfOldClass].		Behavior flushObsoleteSubclasses.		].	^newClass! !----End fileIn of a stream----!MCMethodUnloaderDefinition removeSelector: #sortKey!MCAncestry class removeSelector: #new!MCVersionMerger class removeSelector: #new!MCMethodDefinition removeSelector: #postload!MCMethodDefinition removeSelector: #load!MCRepository removeSelector: #initialize!MCRepository class removeSelector: #settingsFileName!MCRepository class removeSelector: #releaseExternalSettings!MCRepository class removeSelector: #new!MCWorkingCopyBrowser removeSelector: #inspectWorkingCopy!MCWorkingCopyBrowser class removeSelector: #new!MCReader removeSelector: #initialize!MCReader class removeSelector: #new!MCPreambleDefinition removeSelector: #load!MCSnapshotBrowser removeSelector: #methodsForSelectedClassCategory!MCClassDefinition removeSelector: #storeDataOn:!MCClassDefinition removeSelector: #load!MCClassDefinition removeSelector: #createClass!MCClassTraitDefinition removeSelector: #load!MCMockPackageInfo removeSelector: #systemCategories!MCMockPackageInfo removeSelector: #packageName!MCMockPackageInfo removeSelector: #includesSystemCategory:!MCMockPackageInfo removeSelector: #includesClass:!MCMockPackageInfo removeSelector: #extensionMethods!MCMockPackageInfo removeSelector: #classes!MCMockPackageInfo removeSelector: #classNames!MCMockPackageInfo class removeSelector: #initialize!Smalltalk removeClassNamed: #MCMockPackageInfo!MCEmptyPackageInfo removeSelector: #packageName!MCEmptyPackageInfo removeSelector: #methods!MCEmptyPackageInfo removeSelector: #classes!MCEmptyPackageInfo class removeSelector: #wantsChangeSetLogging!MCEmptyPackageInfo class removeSelector: #initialize!Smalltalk removeClassNamed: #MCEmptyPackageInfo!MCDirtyPackageInfo removeSelector: #packageName!MCDirtyPackageInfo removeSelector: #methods!MCDirtyPackageInfo removeSelector: #classes!MCDirtyPackageInfo class removeSelector: #wantsChangeSetLogging!MCDirtyPackageInfo class removeSelector: #initialize!Smalltalk removeClassNamed: #MCDirtyPackageInfo!MCPackageLoader removeSelector: #warnAboutErrors!MCPackageLoader removeSelector: #warnAboutDependencies!MCPackageLoader removeSelector: #useNewChangeSetNamedLike:during:!MCPackageLoader removeSelector: #useNewChangeSetDuring:!MCPackageLoader removeSelector: #useChangeSetNamed:during:!MCPackageLoader removeSelector: #updatePackage:withSnapshot:!MCPackageLoader removeSelector: #unloadPackage:!MCPackageLoader removeSelector: #tryToLoad:!MCPackageLoader removeSelector: #sorterForItems:!MCPackageLoader removeSelector: #shouldWarnAboutErrors!MCPackageLoader removeSelector: #removeDefinition:!MCPackageLoader removeSelector: #provisions!MCPackageLoader removeSelector: #orderedAdditions!MCPackageLoader removeSelector: #orderDefinitionsForLoading:!MCPackageLoader removeSelector: #obsoletionFor:!MCPackageLoader removeSelector: #modifyDefinition:to:!MCPackageLoader removeSelector: #loadWithNameLike:!MCPackageLoader removeSelector: #loadWithName:!MCPackageLoader removeSelector: #load!MCPackageLoader removeSelector: #installSnapshot:!MCPackageLoader removeSelector: #initialize!MCPackageLoader removeSelector: #flushChangesFile!MCPackageLoader removeSelector: #errorDefinitionWarning!MCPackageLoader removeSelector: #dependencyWarning!MCPackageLoader removeSelector: #basicLoad!MCPackageLoader removeSelector: #analyze!MCPackageLoader removeSelector: #addDefinition:!MCPackageLoader class removeSelector: #updatePackage:withSnapshot:!MCPackageLoader class removeSelector: #unloadPackage:!MCPackageLoader class removeSelector: #installSnapshot:!MCMockDependency removeSelector: #uuidForName:!MCMockDependency removeSelector: #resolve!MCMockDependency removeSelector: #name!MCMockDependency removeSelector: #mockVersionInfo!MCMockDependency removeSelector: #initializeWithTree:!MCMockDependency removeSelector: #hash!MCMockDependency removeSelector: #hasResolution!MCMockDependency removeSelector: #children!MCMockDependency removeSelector: #=!MCMockDependency class removeSelector: #fromTree:!Smalltalk removeClassNamed: #MCMockDependency!Smalltalk removeClassNamed: #MCMockClassI!Smalltalk removeClassNamed: #MCMockClassH!Smalltalk removeClassNamed: #MCMockClassG!Smalltalk removeClassNamed: #MCMockClassF!MCMockClassE class removeSelector: #two!Smalltalk removeClassNamed: #MCMockClassE!MCMockClassD removeSelector: #one!Smalltalk removeClassNamed: #MCMockClassD!MCMockDependentItem removeSelector: #requires:!MCMockDependentItem removeSelector: #requirements!MCMockDependentItem removeSelector: #provisions!MCMockDependentItem removeSelector: #provides:!MCMockDependentItem removeSelector: #name:!MCMockDependentItem removeSelector: #name!MCMockDependentItem removeSelector: #<=!Smalltalk removeClassNamed: #MCMockDependentItem!MCMockClassB removeSelector: #two!Smalltalk removeClassNamed: #MCMockClassB!MCMockClassA removeSelector: #two!MCMockClassA removeSelector: #truth!MCMockClassA removeSelector: #q!MCMockClassA removeSelector: #one!MCMockClassA removeSelector: #moreTruth!MCMockClassA removeSelector: #falsehood!MCMockClassA removeSelector: #d!MCMockClassA removeSelector: #c!MCMockClassA removeSelector: #b!MCMockClassA removeSelector: #a!MCMockClassA class removeSelector: #touchCVar!MCMockClassA class removeSelector: #one!MCMockClassA class removeSelector: #cVar!MCMockASubclass removeSelector: #variables2!MCMockASubclass removeSelector: #variables!Smalltalk removeClassNamed: #MCMockASubclass!MCMockClassA class removeSelector: #initialize!Smalltalk removeClassNamed: #MCMockClassA!MCMock class removeSelector: #wantsChangeSetLogging!Smalltalk removeClassNamed: #MCMock!MCSMCacheRepository class removeSelector: #morphicConfigure!MethodReference removeSelector: #isLocalSelector!MCMockDefinition removeSelector: #token:!MCMockDefinition removeSelector: #token!MCMockDefinition removeSelector: #summary!MCMockDefinition removeSelector: #printString!MCMockDefinition removeSelector: #hash!MCMockDefinition removeSelector: #description!MCMockDefinition removeSelector: #asString!MCMockDefinition removeSelector: #=!MCMockDefinition class removeSelector: #wantsChangeSetLogging!MCMockDefinition class removeSelector: #token:!Smalltalk removeClassNamed: #MCMockDefinition!MCDefinition removeSelector: #postload!MCDefinition removeSelector: #loadOver:!Smalltalk removeClassNamed: #MCMockAPoolDictionary!MCPostscriptDefinition removeSelector: #postload!MCPostscriptDefinition removeSelector: #accept:!MCVersionReader removeSelector: #initialize!MCVersionReader class removeSelector: #openVersionFromStream:!MCVersionReader class removeSelector: #mergeVersionStream:!MCVersionReader class removeSelector: #loadVersionStream:fromDirectory:!MCVersionReader class removeSelector: #canReadFileNamed:!MCWorkingCopy removeSelector: #versionSeparator!MCWorkingCopy removeSelector: #updateInstVars!MCWorkingCopy removeSelector: #nextVersionName!MCVersionSorter class removeSelector: #new!MCThreeWayMerger class removeSelector: #new!MCSnapshotTest removeSelector: #mockClassExtension!MCFtpRepository class removeSelector: #templateCreationSelector!MCDictionaryRepository removeSelector: #sortedVersionInfos!MCDictionaryRepository removeSelector: #morphicOpen:!MCDictionaryRepository removeSelector: #includesVersionNamed:!MCDictionaryRepository removeSelector: #allVersionInfos!MCConfiguration removeSelector: #diffBaseFor:!MCRepositoryGroup class removeSelector: #new!MCDependencySorter class removeSelector: #new!MCTraitDefinition removeSelector: #load!MCTraitDefinition removeSelector: #createClass!MCHttpRepository removeSelector: #userAndPasswordFromSettingsDo:!MCHttpRepository class removeSelector: #clearPasswords!MCFileBasedRepository removeSelector: #morphicOpen:!MCFileBasedRepository removeSelector: #allVersionNames!MCGOODSRepository removeSelector: #versionsAvailableForPackage:!MCGOODSRepository removeSelector: #morphicOpen:!MCScriptDefinition removeSelector: #load!MCScriptDefinition class removeSelector: #from:!MCDefinitionIndex class removeSelector: #new!MCPackageManager removeSelector: #registerForNotificationsFrom:!MCPackageManager removeSelector: #registerForNotifications!MCPackageManager removeSelector: #methodRemoved:!MCPackageManager removeSelector: #methodMoved:!MCPackageManager removeSelector: #methodModified:!MCPackageManager removeSelector: #classRemoved:!MCPackageManager removeSelector: #classMoved:!MCPackageManager removeSelector: #classModified:!MCPackageManager class removeSelector: #initialize!MCVersionLoader class removeSelector: #new!TimeStamp class removeSelector: #fromString:!MCMczWriter class removeSelector: #new!MCVersionInspector removeSelector: #save!MCRepositoryInspector removeSelector: #widgetSpecs!MCRepositoryInspector removeSelector: #versionSelection:!MCRepositoryInspector removeSelector: #versionSelection!MCRepositoryInspector removeSelector: #versionListMenu:!MCRepositoryInspector removeSelector: #versionList!MCRepositoryInspector removeSelector: #version!MCRepositoryInspector removeSelector: #summary!MCRepositoryInspector removeSelector: #sortedVersions!MCRepositoryInspector removeSelector: #setRepository:workingCopy:!MCRepositoryInspector removeSelector: #refresh!MCRepositoryInspector removeSelector: #packageSelection:!MCRepositoryInspector removeSelector: #packageSelection!MCRepositoryInspector removeSelector: #packageListMenu:!MCRepositoryInspector removeSelector: #packageList!MCRepositoryInspector removeSelector: #load!MCRepositoryInspector removeSelector: #hasVersion!MCRepositoryInspector removeSelector: #defaultLabel!MCRepositoryInspector removeSelector: #defaultExtent!MCRepositoryInspector removeSelector: #buttonSpecs!MCRepositoryInspector class removeSelector: #repository:workingCopy:!Smalltalk removeClassNamed: #MCRepositoryInspector!MCFileRepositoryInspector removeSelector: #widgetSpecs!MCFileRepositoryInspector removeSelector: #versionSummary!MCFileRepositoryInspector removeSelector: #versionSelection:!MCFileRepositoryInspector removeSelector: #versionSelection!MCFileRepositoryInspector removeSelector: #versionListMenu:!MCFileRepositoryInspector removeSelector: #versionList!MCFileRepositoryInspector removeSelector: #versionInfo!MCFileRepositoryInspector removeSelector: #versionHighlight:!MCFileRepositoryInspector removeSelector: #version!MCFileRepositoryInspector removeSelector: #setRepository:workingCopy:!MCFileRepositoryInspector removeSelector: #refresh!MCFileRepositoryInspector removeSelector: #packageSelection:!MCFileRepositoryInspector removeSelector: #packageSelection!MCFileRepositoryInspector removeSelector: #packageListMenu:!MCFileRepositoryInspector removeSelector: #packageList!MCFileRepositoryInspector removeSelector: #packageHighlight:!MCFileRepositoryInspector removeSelector: #orderString:!MCFileRepositoryInspector removeSelector: #orderSpecs!MCFileRepositoryInspector removeSelector: #order:!MCFileRepositoryInspector removeSelector: #merge!MCFileRepositoryInspector removeSelector: #load!MCFileRepositoryInspector removeSelector: #hasVersion!MCFileRepositoryInspector removeSelector: #defaultLabel!MCFileRepositoryInspector removeSelector: #defaultExtent!MCFileRepositoryInspector removeSelector: #buttonSpecs!MCFileRepositoryInspector class removeSelector: #repository:workingCopy:!MCFileRepositoryInspector class removeSelector: #order:!MCFileRepositoryInspector class removeSelector: #order!MCFileRepositoryInspector class removeSelector: #migrateInstances!MCFileRepositoryInspector class removeSelector: #initialize!Smalltalk removeClassNamed: #MCFileRepositoryInspector!MCCodeTool removeSelector: #printOutMessage!Time class removeSelector: #fromString:!!MCMethodUnloaderDefinition methodsFor: 'as yet unclassified' stamp: 'kph 5/30/2008 02:53'!sortKey	^ 'ÞÞÞunload'   ! !"Monticello.impl"!MethodReference removeSelector: #sourceCode!PackageInfo class removeSelector: #default!PackageInfo class removeSelector: #initialize!"PackageInfo-Base"!Smalltalk removeClassNamed: #MCWorkingCopyTest!Smalltalk removeClassNamed: #MCVersionTest!Smalltalk removeClassNamed: #MCStWriterTest!Smalltalk removeClassNamed: #MCStReaderTest!Smalltalk removeClassNamed: #MCSnapshotTest!Smalltalk removeClassNamed: #MCSnapshotBrowserTest!Smalltalk removeClassNamed: #MCSerializationTest!Smalltalk removeClassNamed: #MCScannerTest!Smalltalk removeClassNamed: #MCDirectoryRepositoryTest!Smalltalk removeClassNamed: #MCDictionaryRepositoryTest!Smalltalk removeClassNamed: #MCRepositoryTest!Smalltalk removeClassNamed: #MCPatchTest!Smalltalk removeClassNamed: #MCPackageTest!Smalltalk removeClassNamed: #MCOrganizationTest!Smalltalk removeClassNamed: #MCMethodDefinitionTest!Smalltalk removeClassNamed: #MCMergingTest!Smalltalk removeClassNamed: #MCMczInstallerTest!Smalltalk removeClassNamed: #MCInitializationTest!Smalltalk removeClassNamed: #MCFileInTest!Smalltalk removeClassNamed: #MCClassDefinitionTest!Smalltalk removeClassNamed: #MCChangeNotificationTest!Smalltalk removeClassNamed: #MCAncestryTest!Smalltalk removeClassNamed: #MCTestCase!Smalltalk removeClassNamed: #MCSortingTest!Smalltalk removeClassNamed: #MCSnapshotResource!Smalltalk removeClassNamed: #MCDependencySorterTest!!VersionNumber methodsFor: '*smbase-printing' stamp: 'gk 1/23/2004 10:13' prior: 50612448!versionString	^String streamContents: [ :strm | self versionStringOn: strm ]! !!VersionNumber methodsFor: '*smbase-override' stamp: 'svp 6/18/2002 17:23' prior: 50612220!versionStringOn: strm	| first |	first := true.	numbers do: [ :ea |		first ifFalse: [strm nextPut: $.].		first := false.		ea printOn: strm]	! !!RcsDiff class methodsFor: 'instance creation' stamp: 'gh 11/22/2001 23:44' prior: 28414300!lines: aString	"Create a new RcsDiff file."	^(self new) commandLines: aString; yourself! !!RcsDiff methodsFor: 'applying' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28413092!applyTo: aString	"Apply me to given String and return the patched String."	| space commandStream originalStream nextCommand nextLine lineCount currentLine |	space := Character space.	commandStream := ReadStream on: commandLines.	originalStream := ReadStream on: aString.	currentLine := 1.	^String streamContents: [:stream |		[nextCommand := commandStream next.		nextCommand isNil] whileFalse: [ 			nextLine := (commandStream upTo: space) asNumber.			lineCount := commandStream nextLine asNumber.			[currentLine = nextLine]				whileFalse: [stream nextPutAll: originalStream nextLine; cr. currentLine := currentLine + 1].			nextCommand = $d				ifTrue:[ lineCount timesRepeat: [originalStream nextLine. currentLine := currentLine + 1]]				ifFalse:[ nextCommand = $a							ifTrue:[ stream nextPutAll: originalStream nextLine; cr.									currentLine := currentLine + 1.									lineCount timesRepeat: [										stream nextPutAll: commandStream nextLine; cr]]]].		stream nextPutAll: originalStream upToEnd]! !!RcsDiff methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28412967!commandLines: aString	commandLines := aString! !!SMDependencyAnalysis commentStamp: '<historical>' prior: 28770399!A dependency analysis is instantiated by an SMInstallationTask as a step in calculating how the task can be performed.The analysis is done using a map and some input - for example a list of package releases that the task wants to get installed. It can then be queried for the results. The analysis is performed in a series of steps and middle results are collected in instvars. It also uses sub instances so the analysis actually forms a tree of several instances of SMDependencyAnalysis where each node describes one level of dependencies.Instvars:task - the task that instantiated this analysis.map - the SMSqueakMap to use, we get it by asking the task.wantedReleases - the releases that we want to install.alreadyInstalled - the subset of wantedReleases that are already installed.trivialToInstall - the subset of wantedReleases that do not have dependencies and can be installed directly.alreadyInstallable - 	the subset of wantedReleases that do have dependencies but for which at least one configuration is fulfilled and thus the release can already be installed.trickyReleases - the subset of wantedReleases that do have configurations but none of them are fulfilled, so some dependencies first needs to be installed before these releases can be installed.workingConfigurations - an OrderedCollection of OrderedCollections holding all working configurations for the trickyReleases.workingConfigurationsSize - size of workingConfigurations.combinations - all possible (unordered) combinations of picking one working configuration for each tricky release.suggestedInstallSetsSet - computed from combinations above. A Set of Sets of required releases. Each Set is a unique combination of the required releases to install in order to fulfill one configuration for each of the tricky releases.conflictingInstallSetsSet - the subset of suggestedInstallSetsSet that are invalid since it includes multiple releases from the same package. !!SMDependencyAnalysis class methodsFor: 'instance creation' stamp: 'gk 7/29/2004 14:31' prior: 28784250!task: ownerTask	^self new task: ownerTask! !!SMDependencyAnalysis methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 28772432!allInstallPaths	"For all paths, collect in reverse all releases to install.	At each level, first we add trivially installable releases	(those that have no dependencies), then installable releases	(those that have one configuration fulfilled) and finally	the tricky releases (those left).	Note that we also return paths with conflicting releases	of the same package and paths with releases that conflict with	already installed releases - those paths can be tweaked - and	paths that are supersets of other paths."	| installPaths releases |	installPaths := OrderedCollection new.	self allPathsDo: [:path |		releases := OrderedCollection new.		path reverseDo: [:ana |			releases addAll: (ana trivialToInstall difference: releases).			releases addAll: (ana alreadyInstallable difference: releases).			releases addAll: (ana trickyReleases difference: releases)			"Below for debugging			r := OrderedCollection new.			r add: ana trivialToInstall; add: ana alreadyInstallable; add: ana trickyReleases.			releases add: r"].		installPaths add: releases].	^ installPaths! !!SMDependencyAnalysis methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 28773591!allNormalizedInstallPaths	"Same as allInstallPaths, but with paths removed that	are clear supersets of others."	| installPaths |	installPaths := self allInstallPaths.	installPaths := installPaths reject: [:p1 |					installPaths anySatisfy: [:p2 |						(p1 ~~ p2) and: [p1 includesAllOf: p2]]].	^installPaths! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 9/22/2004 20:22' prior: 28775783!allPathsDo: aBlock	"For all paths down the tree, evaluate aBlock."	^ self allPathsDo: aBlock trail: OrderedCollection new! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 9/22/2004 20:59' prior: 28775985!allPathsDo: aBlock trail: trail	"For all paths down the tree, evaluate aBlock."	trail add: self.	subAnalysises		ifNil: [			aBlock value: trail.]		ifNotNil: [			subAnalysises do: [:sub |				sub allPathsDo: aBlock trail: trail]].	trail removeLast! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 28776316!allRoutesDo: aBlock currentRoute: currentRoute level: level	"Recursively iterate over all routes down the tree."	| newLevel |	workingConfigurationsSize = level ifTrue: ["we reached the leaves"		workingConfigurations last do: [:conf | 			currentRoute addLast: conf.			aBlock value: currentRoute.			currentRoute removeLast].		^self].	newLevel := level + 1.	(workingConfigurations at: level) do: [:conf |		currentRoute addLast: conf.		self allRoutesDo: aBlock currentRoute: currentRoute level: newLevel.		currentRoute removeLast]! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 7/27/2004 15:36' prior: 28780305!alreadyInstallable	^alreadyInstallable	! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 7/27/2004 15:36' prior: 28780426!alreadyInstalled	^alreadyInstalled	! !!SMDependencyAnalysis methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 28773984!bestInstallPath	"Using some heuristics we suggest the best path:		- No conflicts		- Fewest releases		- If same packages, the newest releases"	| paths min points point package sc |	paths := self installPathsWithoutConflicts.	paths size = 1 ifTrue: [^paths first].	min := paths inject: 999 into: [:mi :p | p size < mi ifTrue: [p size] ifFalse: [mi]].	paths := paths select: [:p | p size = min].	paths size = 1 ifTrue: [^paths first].	"Try to pick the one with newest releases"	points := Dictionary new.	paths do: [:p |		point := 0.		p do: [:r |			package := r package.			paths do: [:p2 |				p2 == p ifFalse: [					(p2 anySatisfy: [:r2 |						(r2 package == package) and: [r newerThan: r2]])							ifTrue:[point := point + 1]]]].		points at: p put: point].	points isEmpty ifTrue: [^nil].	sc := points associations asSortedCollection: [:a :b | a value >= b value].	^ sc first key! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 28776933!collectCombinationsOfConfigurations	"Given the wanted releases, find and return all possible combinations	of working configurations for all those. Perhaps not possible to do	given lots of releases and configurations, then we need smarter algorithms."		"Pick out all working configurations first."	workingConfigurations := (trickyReleases collect: [:r | r workingConfigurations]) asOrderedCollection.	workingConfigurationsSize := workingConfigurations size.		"We iterate over all possible combinations of configurations	and collect the unique set of unordered configurations."	combinations := Set new.	self allRoutesDo: [:route |		combinations add: route asSet copy] currentRoute: OrderedCollection new level: 1! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 28777733!computeInstallSets	"Given all combinations of configurations, compute all valid combinations	of depdendency releases - all possible different Sets of required releases	to install before the trickyReleases can be installed."		"For each unique combination of configurations, collect all required releases	and produce a Set of unique required release combinations." 	suggestedInstallSetsSet := (combinations collect: [:comb |								comb inject: Set new into: [:set :conf |									set addAll: conf requiredReleases.									set ]]) asSet.	"Filter out those Sets that have multiple releases of the same package, they are conflicting	and thus not valid - we can't have two different releases of the same package	installed at the same time."		"conflictingInstallSetsSet := suggestedInstallSetsSet select:								[:set | self detectConflictingReleasesIn: set].	suggestedInstallSetsSet removeAll: conflictingInstallSetsSet"! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 28778744!detectConflictingReleasesIn: collectionOfReleases	"Detect if the Set has multiple releases of the same package."	| detectedPackages |	detectedPackages := Set new.	collectionOfReleases do: [:r |		(detectedPackages includes: r package)			ifTrue: [^ true]			ifFalse: [detectedPackages add: r package]].	^false! !!SMDependencyAnalysis methodsFor: 'printing' stamp: 'gk 9/21/2004 23:59' prior: 28781116!indent: level	^'                                                  '		last: level * 6! !!SMDependencyAnalysis methodsFor: 'calculation' stamp: 'gk 5/5/2006 02:07' prior: 28782378!installPackageReleases: packageReleases	"Given a Set of wanted SMPackageReleases, calculate all possible	installation scenarios. If the analysis succeeds, return true, otherwise false."		| result subAnalysis |	wantedReleases := packageReleases copy.	"First classify the releases in different groups."	self partitionReleases.		"If there are no tricky releases, we are already done.	No extra required releases needs to be installed or upgraded."	trickyReleases isEmpty ifTrue: [^success := true].	"Ok, that was the easy part. The releases left now needs to be processed	so that we can find out the different scenarios of required releases that we need	to install first. First we calculate all combinations of available working configurations	for the tricky releases."	self collectCombinationsOfConfigurations.		"Based on all configuration combinations,	compute possible combinations of dependency releases."	self computeInstallSets.		"Check if we have failed - meaning that there are no valid scenarios without conflicts."	suggestedInstallSetsSet isEmpty ifTrue: [^success := false].		"Ok, this means we have at least one solution *on this level*!! But we need to do the	analysis recursively for all these sets of required releases..."	subAnalysises := OrderedCollection new.	success := false.	suggestedInstallSetsSet do: [:set |		subAnalysis := SMDependencyAnalysis task: task.		result := subAnalysis installPackageReleases: set.		result ifTrue: [success := true].		subAnalysises add: subAnalysis].		"Did at least one succeed? If so, then we have at least one possible scenario!!	If not, then we need to do tweaking."	^success! !!SMDependencyAnalysis methodsFor: 'queries' stamp: 'gk 9/26/2004 23:44' prior: 28774963!installPathsWithConflicts	"Same as allInstallPaths, but we only return paths	with multiple releases of the same package."	^ self allInstallPaths select: [:path | self detectConflictingReleasesIn: path] ! !!SMDependencyAnalysis methodsFor: 'queries' stamp: 'gk 9/22/2004 23:32' prior: 28775247!installPathsWithoutConflicts	"Same as allInstallPaths, but we filter out paths	with multiple releases of the same package."	^ self allInstallPaths reject: [:path | self detectConflictingReleasesIn: path] ! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 28779136!partitionReleases	"Move releases from wantedReleases to suitable other collections	if they are either installed, trivial to install, or installable as is."		trickyReleases := wantedReleases copy.	alreadyInstalled := wantedReleases select: [:r | r isInstalled ].	trickyReleases removeAll: alreadyInstalled. 	trivialToInstall := trickyReleases select: [:r | r hasNoConfigurations ].	trickyReleases removeAll: trivialToInstall.			alreadyInstallable := trickyReleases select: [:r | r hasFulfilledConfiguration ].	trickyReleases removeAll: alreadyInstallable! !!SMDependencyAnalysis methodsFor: 'printing' stamp: 'gk 9/22/2004 22:44' prior: 28781281!printAllInstallPaths	"Follow all install paths in the tree."	^String streamContents: [:s |		self allInstallPaths do: [:path |			path do: [:rel |				s nextPutAll: rel packageNameWithVersion, ', '].			s cr]] ! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'md 12/22/2006 14:31' prior: 28779776!removeOlderReleasesIn: collectionOfReleases	"Remove older multiple releases of the same package.	2 scans to retain order."	| newestReleases rel |	newestReleases := Dictionary new.	collectionOfReleases do: [:r |		rel := newestReleases at: r package ifAbsentPut: [r].		(r newerThan: rel) ifTrue: [newestReleases at: r package put: r]].	^collectionOfReleases select: [:r |		(newestReleases at: r package) == r]! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 9/20/2004 22:59' prior: 28780543!success	^success	! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 28780641!task: ownerTask	task := ownerTask.	map := task map! !!SMDependencyAnalysis methodsFor: 'printing' stamp: 'gk 9/21/2004 23:49' prior: 28781573!treeString	"Return a indented String showing the tree	structure of all possible scenarios."	^String streamContents: [:s |		self treeStringOn: s indent: 0]! !!SMDependencyAnalysis methodsFor: 'printing' stamp: 'gk 5/5/2006 02:07' prior: 28781810!treeStringOn: stream indent: level	"Print the tree	structure of all possible scenarios."	| i |	i := self indent: level.	stream nextPutAll: i, 'Wanted:'; cr.	wantedReleases do: [:r |		stream nextPutAll: i ,'  ' , r packageNameWithVersion;cr].	stream nextPutAll: i, 'Tricky:'; cr.	trickyReleases do: [:r |		stream nextPutAll: i ,'  ' , r packageNameWithVersion;cr].	stream cr.	subAnalysises ifNotNil: [		subAnalysises do: [:sub | sub treeStringOn: stream indent: level + 1]]! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 7/28/2004 15:32' prior: 28780773!trickyReleases	^trickyReleases	! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 7/27/2004 15:36' prior: 28780886!trivialToInstall	^trivialToInstall	! !!SMDependencyAnalysis methodsFor: 'queries' stamp: 'gk 9/26/2004 23:47' prior: 28775533!untestedInstallPaths	"We take the paths with conflicts and remove the older releases."	^self installPathsWithConflicts collect: [:p |		 self removeOlderReleasesIn: p] ! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 7/27/2004 15:35' prior: 28781003!wantedReleases	^wantedReleases	! !!SMDependencyEngine commentStamp: '<historical>' prior: 28784497!A dependency engine is used to perform one or more installation, upgrade or uninstallation tasks.After creation it is typically configured according to different strategies, policies etc based on the preferences of the user.Then it is used to calculate what installations, uninstallations or upgrades are needed and in which order to reach certain stated goals, like installing a set of wanted packages or upgrading the installed packages.The engine instantiates different SMInstallationTask subclasses depending on what it should calculate.Todo: both the installation information for the image and the engine should probably be kept outside of the SMSqueakMap instance.!!SMDependencyEngine class methodsFor: 'instance creation' stamp: 'gk 7/29/2004 14:29' prior: 28785989!map: aMap	^ self new map: aMap! !!SMDependencyEngine methodsFor: 'tasks' stamp: 'gk 7/29/2004 15:59' prior: 28785247!installPackages: wantedPackages	"Given a Set of wanted SMPackages, create an installation task to compute	possible installation scenarios.	Returns an SMInstallationTask which can be further configured	and then be sent #calculate after which it can be queried for results."		^SMPackageInstallationTask engine: self wantedPackages: wantedPackages! !!SMDependencyEngine methodsFor: 'accessing' stamp: 'gk 7/29/2004 14:47' prior: 28785676!map	^map! !!SMDependencyEngine methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 28785762!map: aMap	map := aMap! !!SMFileCache commentStamp: 'gk 3/8/2004 20:10' prior: 28799967!A repository for SMSqueakMap downloads. This behaves like a Set, responding to add: and include:, but also package contents may be forcibly refreshed with download:.The SqueakMap determines what path the cache resides at. Within the cache, there is a 'packages' directory containing UUID-based directories for each package containing further directories for each release. A 'resources' directory stores UUID-based directories for each Resource, with the file stored within that by its original name. Because the cache follows a Set protocol, it can be automatically traversed within Smalltalk's collection protocol, avoiding manual hassles.!!SMFileCache class methodsFor: 'instance creation' stamp: 'gk 1/23/2004 10:21' prior: 28806154!newFor: aMap	"This is the default creation method, responsible for ensuring the	paths and such exist, and filling in defaults."	^self new forMap: aMap! !!SMFileCache methodsFor: 'services' stamp: 'gk 7/16/2004 11:04' prior: 28802455!add: aDownloadable 	"Conditionally download the downloadable object into the cache.	Return true on success, otherwise false."	^(self includes: aDownloadable)		ifTrue: [true]		ifFalse: [self download: aDownloadable]! !!SMFileCache methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 28804137!cacheUrlFor: aDownloadable	"Find a cache URL for this downloadable.	Returns nil if no server is available.	Could use #relativeUrl also."	| server |	server := aDownloadable map class findServer.	server ifNil: [^ nil].	^'http://', server, '/object/', aDownloadable id asString, '/cache'! !!SMFileCache methodsFor: 'services' stamp: 'gk 4/19/2006 01:31' prior: 28802745!contents: anSMObject	"Return contents of the file for the object	or nil if not in cache."	anSMObject isCached		ifTrue: [^(anSMObject cacheDirectory readOnlyFileNamed: anSMObject downloadFileName) binary; contentsOfEntireFile]		ifFalse: [^nil]		! !!SMFileCache methodsFor: 'accessing' stamp: 'gk 1/23/2004 10:26' prior: 28800679!directory	^map packageCacheDirectory! !!SMFileCache methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28800799!directoryForPackage: aPackage	"Returns the local path for storing the package cache's package file area.	This also ensures that the path exists."	| slash path dir |	slash := FileDirectory slash.	path := 'packages' , slash , aPackage id asString36 , slash.	dir := FileDirectory default on: self directory fullName, slash, path.	dir assureExistence.	^dir! !!SMFileCache methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28801243!directoryForPackageRelease: aPackageRelease	"Returns the local path for storing the package cache's version of a  	package file. This also ensures that the path exists."	| slash path dir |	slash := FileDirectory slash.	path := 'packages' , slash , aPackageRelease package id asString36 , slash , aPackageRelease automaticVersionString.	dir := FileDirectory default on: self directory fullName, slash, path.	dir assureExistence.	^dir! !!SMFileCache methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28801767!directoryForResource: aResource	"Returns the local path for storing the package cache's version of a  	resource file. This also ensures that the path exists."	| slash path dir |	slash := FileDirectory slash.	path := 'resources' , slash , aResource id asString36.	dir := FileDirectory default on: self directory fullName, slash, path.	dir assureExistence.	^dir! !!SMFileCache methodsFor: 'services' stamp: 'gk 5/5/2006 02:07' prior: 28803065!download: aDownloadable 	"Download the file for this SMObject into the local file cache.	If the file already exists, delete it.	No unpacking or installation into the running image."	| stream file fileName dir |	[fileName := aDownloadable downloadFileName.	fileName		ifNil: [self inform: 'No download url, can not download.'.			^ false].	fileName isEmpty		ifTrue: [self inform: 'Download url lacks filename, can not download.'.			^ false].	dir := aDownloadable cacheDirectory.	[stream := self getStream: aDownloadable.	stream ifNil: [^ false].	(dir fileExists: fileName)		ifTrue: [dir deleteFileNamed: fileName].	file := dir newFileNamed: fileName.	file binary; nextPutAll: stream contents]		ensure: [file ifNotNil: [file close]]]		on: Error		do: [^ false].	^ true! !!SMFileCache methodsFor: 'initialize' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28802302!forMap: aMap	"Initialize the ache, make sure the cache dir exists."	map := aMap! !!SMFileCache methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 28804497!getStream: aDownloadable 	"Get the stream, either from the original url	or if that fails, from the server cache - unless	this is the actual server of course. :)	We also verify that the sha1sum is correct."	| stream |	[stream := aDownloadable downloadUrl asUrl retrieveContents contentStream binary.	(aDownloadable correctSha1sum: stream contents)		ifFalse: [self error: 'Incorrect SHA checksum of file from orginal URL']]		on: Exception do: [:ex |			Transcript show: 'Download from original url (', aDownloadable downloadUrl, ') failed with this exception: ', ex messageText;cr.			SMUtilities isServer				ifTrue: [^nil]				ifFalse: [					Transcript show: 'Trying server cache instead.'; cr.					[stream := (self cacheUrlFor: aDownloadable) asUrl retrieveContents contentStream binary.					(stream contents size = 21 and: [stream contents asString = 'SMFILEMISSINGONSERVER'])						ifTrue: [self error: 'File missing in server cache'].					(stream contents size = 24 and: [stream contents asString = 'SMRELEASENOTDOWNLOADABLE'])						ifTrue: [self error: 'Release not downloadable'].					(aDownloadable correctSha1sum: stream contents)						ifFalse: [self error: 'Incorrect SHA checksum of file from server']]							on: Exception do: [:ex2 | | msg |								msg := 'Download from server cache of ', aDownloadable printName, ' failed with this exception: ', ex2 messageText.								Transcript show: msg; cr.								self error: msg]]].	^ stream! !!SMFileCache methodsFor: 'services' stamp: 'gk 7/16/2004 11:10' prior: 28803921!includes: anSMObject	"Check if the cache holds the file for the object."		^(anSMObject cacheDirectory)		fileExists: anSMObject downloadFileName! !!SMFileCache methodsFor: 'accessing' stamp: 'btr 5/27/2003 16:24' prior: 28802207!map	^ map! !!SMInstallationDeviation commentStamp: '<historical>' prior: 28807484!An installation deviation is when the user decides to install or upgrade to a release that is newer than one or more used configurations specify.This means that the other installed releases which configurations will be broken may not work correctly.Instvar selectedRelease refers to the release selected to install, brokenConfigurations is a collection of all configurations that need another release of this package.!!SMInstallationDeviation class methodsFor: 'instance creation' stamp: 'gk 10/13/2004 00:51' prior: 28809131!selectedRelease: release releases: releases	^self new selectedRelease: release releases: releases! !!SMInstallationDeviation methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 28807984!otherReleases	| package |	package := selectedRelease package.	^ brokenConfigurations collect: [:conf |		conf releases detect: [:r | r package == package]]! !!SMInstallationDeviation methodsFor: 'accessing' stamp: 'gk 10/4/2004 11:14' prior: 28808225!selectedRelease	^ selectedRelease! !!SMInstallationDeviation methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 28808351!selectedRelease: aRelease releases: releases	| p others otherRequired |	selectedRelease := aRelease.	p := selectedRelease package.	brokenConfigurations := OrderedCollection new.	others := releases copyWithout: aRelease.	others := others select: [:r | r package ~= p].	others do: [:rel |		rel workingConfigurations do: [:conf |			otherRequired := conf requiredReleases select: [:r | r package ~= p].			((others includesAllOf: otherRequired) and:				[(conf requiredReleases includes: selectedRelease) not])					ifTrue: [brokenConfigurations add: conf]]]! !!SMInstallationProposal commentStamp: '<historical>' prior: 28809473!This is primarily an ordered list of package release installations or upgrades to achieve a given installation task.!!SMInstallationProposal class methodsFor: 'instance creation' stamp: 'gk 10/1/2004 10:01' prior: 28811629!installList: anOrderedCollection	^ self new installList: anOrderedCollection! !!SMInstallationProposal methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 28809679!calculateComment	comment := ''! !!SMInstallationProposal methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 28809801!calculateDeviations	"Calculate deviations. Currently we just pick the newest release."	| conflicts newest |	deviations := OrderedCollection new.	conflicts := self collectConflictsIn: installList.	conflicts keysAndValuesDo: [:package :releases |		newest := releases first.		releases do: [:r | (r newerThan: newest) ifTrue: [newest := r]].		deviations add: (SMInstallationDeviation selectedRelease: newest releases: installList)]! !!SMInstallationProposal methodsFor: 'initialize-release' stamp: 'md 12/22/2006 14:30' prior: 28810327!collectConflictsIn: collectionOfReleases	"Collect all conflicts where there are either		- multiple releases of the same package and/or		- another release of the same package already installed	Return the conflicts as an IdentityDictionary with	the package as key and the value being a Set of releases."	| conflicts set |	conflicts := IdentityDictionary new.	collectionOfReleases do: [:r |		set := conflicts at: r package ifAbsentPut: [OrderedCollection new].		set add: r].	"Add the installed releases too"	conflicts keysAndValuesDo: [:key :value |		key isInstalled ifTrue: [value add: key installedRelease]].	"Prune release sets with only one member"	^conflicts select: [:releaseSet | releaseSet size > 1]! !!SMInstallationProposal methodsFor: 'initialize-release' stamp: 'gk 10/13/2004 01:26' prior: 28811170!hasDeviations	^ deviations notEmpty! !!SMInstallationProposal methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 28811296!installList: anOrderedCollection	installList := anOrderedCollection.	self calculateDeviations.	self calculateComment! !!SMInstallationRegistry commentStamp: '<historical>' prior: 28811951!A registry instance keeps track of installations into an image. Typically used by the SMSqueakMap instance when installing package releases.!!SMInstallationRegistry class methodsFor: 'instance creation' stamp: 'gk 8/1/2004 17:42' prior: 28822090!map: aMap	"Create a new registry and make it use the given map."	^self new map: aMap! !!SMInstallationRegistry methodsFor: 'queries' stamp: 'gk 8/1/2004 17:51' prior: 28812504!clearInstalledPackageWithId: aPackageId	"Clear the fact that any release of this package is installed.	Can be used even when the map isn't loaded."	^installedPackages ifNotNil: [		installedPackages removeKey: (UUID fromString: aPackageId) ifAbsent: [nil]]! !!SMInstallationRegistry methodsFor: 'services' stamp: 'gk 5/5/2006 02:07' prior: 28812170!clearInstalledPackages	"Simply clear the dictionary with information on installed packages.	Might be good if things get corrupted etc. Also see	SMSqueakMap class>>recreateInstalledPackagesFromChangeLog"	installedPackages := nil.	installCounter := 0! !!SMInstallationRegistry methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 28815101!countInstall	"Increase the install counter."	installCounter ifNil: [installCounter := 0].	^installCounter := installCounter + 1! !!SMInstallationRegistry methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 28815833!installCounter: anInteger	"Set counter directly."	installCounter := anInteger! !!SMInstallationRegistry methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 28812843!installedPackages	"Answer all packages that we know are installed.	Lazily initialize. The Dictionary contains the installed packages	using their UUIDs as keys and the version string as the value."	| result p |	result := OrderedCollection new.	installedPackages ifNil: [^#()]		ifNotNil: [installedPackages keys					do: [:k |						p := map object: k.						p ifNotNil: [result add: p]]].	^result! !!SMInstallationRegistry methodsFor: 'accessing' stamp: 'gk 8/1/2004 17:44' prior: 28815994!installedPackagesDictionary	"Access the dictionary directly. The UUID of the installed package is the key.	The value is an OrderedCollection of Arrays.	The arrays have the smartVersion of the package, the time of the	installation in seconds and the sequence number (installCounter)."	^installedPackages ifNil: [Dictionary new]! !!SMInstallationRegistry methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 28816407!installedPackagesDictionary: aDict	"Set dictionary directly."	installedPackages := aDict! !!SMInstallationRegistry methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 28813326!installedReleaseOf: aPackage	"If the package is installed, return the release.	Otherwise return nil. SM2 stores the version as	an Association to be able to distinguish it."	| autoVersionOrOld |	installedPackages ifNil: [^nil].	autoVersionOrOld := (installedPackages at: aPackage id ifAbsent: [^nil]) last first.	(autoVersionOrOld isKindOf: Association)		ifTrue: [			^aPackage releaseWithAutomaticVersion: autoVersionOrOld value]		ifFalse: [			^aPackage releaseWithVersion: autoVersionOrOld]! !!SMInstallationRegistry methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 28814420!installedVersionOf: aPackage	"If the package is installed, return the version as a String.	If it is a package installed during SM1 it will return the manual version String,	for SM2 it returns the automatic version as a String.	If package is not installed - return nil. If you want it to work without the map loaded you	should instead use #installedVersionOfPackageWithId:."	| versionOrString |	versionOrString := self installedVersionOfPackageWithId: aPackage id.	versionOrString ifNil: [^nil].	^versionOrString isString		ifTrue: [versionOrString]		ifFalse: [versionOrString versionString]! !!SMInstallationRegistry methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 28813907!installedVersionOfPackageWithId: anId	"If the package is installed, return the automatic version or version String.	Otherwise return nil. This can be used without the map loaded."	| autoVersionOrOld |	installedPackages ifNil: [^nil].	autoVersionOrOld := (installedPackages at: anId ifAbsent: [^nil]) last first.	(autoVersionOrOld isKindOf: Association)		ifTrue: [			^autoVersionOrOld value]		ifFalse: [			^autoVersionOrOld]! !!SMInstallationRegistry methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 28816579!map: aMap	map := aMap! !!SMInstallationRegistry methodsFor: 'private' stamp: 'md 12/22/2006 14:30' prior: 28815312!markInstalled: uuid version: version time: time counter: num	"Private. Mark the installation. SM2 uses an Association	to distinguish the automatic version from old versions."	| installs |	installedPackages ifNil: [installedPackages := Dictionary new].	installs := installedPackages at: uuid ifAbsentPut: [OrderedCollection new].	installs add:		(Array with: 2->version				with: time				with: num)! !!SMInstallationRegistry methodsFor: 'installation-changelog' stamp: 'gk 5/5/2006 02:07' prior: 28817424!noteInstalledPackage: uuidString version: version	"Mark a specific version of a package as installed.	This method is called when replaying a logged installation	from before SqueakMap 1.07. Such logged installations lacked	a timestamp and a count. We take the current time and a	count starting from -10000 and upwards. This should keep	the sorting order correct."	"Find the lowest installed count."	| lowest |	lowest := 0.	installedPackages ifNotNil: [		installedPackages valuesDo: [:oc |			oc do: [:array |				array last < lowest ifTrue: [lowest := array last]]]]		ifNil: [lowest := -10000].	lowest negative ifFalse: [lowest := -10000].	^self noteInstalledPackage: uuidString version: version		atSeconds: Time totalSeconds number: lowest + 1! !!SMInstallationRegistry methodsFor: 'installation-changelog' stamp: 'gk 5/5/2006 02:07' prior: 28818277!noteInstalledPackage: uuidString version: version atSeconds: time number: num	"Mark a package as installed in the Dictionary.	This method is called when replaying a logged installation.	<time> is the point in time as totalSeconds of the installation.	<num> is the installCount of the installation.	This method is typically called from a doIt in the changelog	in order to try to keep track of packages installed."	num negative ifFalse: ["Not an emulated count from prior SM1.07"		installCounter := num max: installCounter].	self markInstalled: (UUID fromString: uuidString) version: version time: time counter: num! !!SMInstallationRegistry methodsFor: 'installation-changelog' stamp: 'gk 5/5/2006 02:07' prior: 28816697!noteInstalledPackageWithId: uuidString autoVersion: version atSeconds: time number: num	"Mark a package as installed in the Dictionary.	This method is called when replaying a logged installation.	<time> is the point in time as totalSeconds of the installation.	<num> is the installCount of the installation.	This method is typically called from a doIt in the changelog	in order to try to keep track of packages installed."	num negative ifFalse: ["Not an emulated count from prior SM1.07"		installCounter := num max: installCounter].	self markInstalled: (UUID fromString: uuidString) version: version time: time counter: num! !!SMInstallationRegistry methodsFor: 'installation' stamp: 'gk 5/5/2006 02:07' prior: 28818985!noteInstalledPackageWithId: aPackageId autoVersion: aVersion name: aName	"The package release was just successfully installed.	Can be used to inform SM of an installation not been	done using SM, even when the map isn't loaded.	We record the fact in our Dictionary of installed packages	and log a 'do it' to mark this in the changelog.	The doit helps keeping track of the packages when	recovering changes etc - not a perfect solution but should help.	The map used is the default map.	The id of the package is the key and the value is an OrderedCollection	of Arrays with the release auto version, the point in time and the current installCounter."	| time name id v |	v := aVersion isString ifTrue: [aVersion asVersion] ifFalse: [aVersion].	aName ifNil: [name := '<unknown package name>'] ifNotNil: [name := aName].	id := UUID fromString: aPackageId.	time := Time totalSeconds.	self countInstall.	self markInstalled: id version: v time: time counter: installCounter.	(((Smalltalk classNamed: 'SmalltalkImage') ifNotNilDo: [:si | si current]) ifNil: [Smalltalk])		logChange: '"Installed ', name, ' auto version ', v versionString, '".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: ', id asString storeString, ' autoVersion: ', v storeString, ' atSeconds: ', time asString, ' number: ', installCounter asString, ']'! !!SMInstallationRegistry methodsFor: 'installation' stamp: 'gk 5/5/2006 02:07' prior: 28820448!noteUninstalledPackageWithId: aPackageId autoVersion: aVersion name: aName	"The package release was just successfully uninstalled.	Can be used to inform SM of an uninstallation not been	done using SM, even when the map isn't loaded.	We record the fact in our Dictionary of installed packages	and log a 'do it' to mark this in the changelog.	The doit helps keeping track of the packages when	recovering changes etc - not a perfect solution but should help.	The map used is the default map.	The id of the package is the key and the value is an OrderedCollection	of Arrays with the release auto version, the point in time and the current installCounter."	| time name id v |	v := aVersion isString ifTrue: [aVersion asVersion] ifFalse: [aVersion].	aName ifNil: [name := '<unknown package name>'] ifNotNil: [name := aName].	id := UUID fromString: aPackageId.	time := Time totalSeconds.	self countInstall. "Used for both installs and uninstalls"	self clearInstalled: id version: v time: time counter: installCounter.	(((Smalltalk classNamed: 'SmalltalkImage') ifNotNilDo: [:si | si current]) ifNil: [Smalltalk])		logChange: '"Uninstalled ', name, ' auto version ', v versionString, '".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteUninstalledPackageWithId: ', id asString storeString, ' autoVersion: ', v storeString, ' atSeconds: ', time asString, ' number: ', installCounter asString, ']'! !!SMInstallationTask commentStamp: '<historical>' prior: 28822388!An SMInstallationProposal is effectively a list of releases to install or upgrade to in a specific order to achieve an SMInstallationTask.The task can be either an upgrade or a new installation - the proposal still involved an ordered list of installations or upgrades.!!SMInstallationTask methodsFor: 'calculation' stamp: 'gk 9/20/2004 20:49' prior: 28822738!calculate	"Calculate how the task should be performed.	After calculation the task can be inspected and presented	to the user for confirmation. Actually performing the task	is done by #execute."		self subclassResponsibility ! !!SMInstallationTask methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 28823193!engine: anEngine	engine := anEngine.	map := engine map! !!SMInstallationTask methodsFor: 'calculation' stamp: 'gk 9/20/2004 20:49' prior: 28823047!execute	"Actually perform the task."	self subclassResponsibility ! !!SMInstallationTask methodsFor: 'accessing' stamp: 'gk 7/29/2004 14:48' prior: 28823327!map	^map! !!SMPackageInstallationTask commentStamp: '<historical>' prior: 28892341!A package installation task is to install one or more given SMPackages (not specified releases) into the image.First it tries to calculate the ideal releases of the given packages that it will try to install given the policy and preferences set by the user. Then it runs an analysis to find how to install those wanted releases. This typically results in zero, one or more possible scenarios.!!SMPackageInstallationTask class methodsFor: 'instance creation' stamp: 'gk 7/29/2004 12:37' prior: 28894842!engine: engine wantedPackages: wantedPackages	^self new engine: engine; wantedPackages: wantedPackages! !!SMPackageInstallationTask methodsFor: 'queries' stamp: 'gk 9/22/2004 22:47' prior: 28892818!allInstallPaths	"Return all different ways to install - the ones requested plus all dependencies.	This includes ways where different releases of the same package are combined."	^analysis allInstallPaths! !!SMPackageInstallationTask methodsFor: 'accessing' stamp: 'gk 9/20/2004 20:50' prior: 28893392!analysis	"Return the analysis of the task."	^analysis! !!SMPackageInstallationTask methodsFor: 'calculation' stamp: 'gk 5/5/2006 02:07' prior: 28893672!calculate	"First calculate the wanted releases. Then perform a dependency analysis.	We return the most basic result of the analysis - does there exist at least one	working installation scenario without tweaks?"	self calculateWantedReleases.	analysis := SMDependencyAnalysis task: self.	analysis installPackageReleases: wantedReleases.	^analysis success! !!SMPackageInstallationTask methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 28894115!calculateWantedReleases	"The user gave us wanted packages.	We need to figure out which actual releases of those	we should try to install."	| rel |	wantedReleases := Set new.	wantedPackages do: [:p | rel := self idealReleaseFor: p.		rel ifNotNil: [wantedReleases add: rel]]! !!SMPackageInstallationTask methodsFor: 'private' stamp: 'gk 9/20/2004 20:51' prior: 28894478!idealReleaseFor: aPackage	"Return the most suitable release to install for <aPackage>."	^ aPackage lastPublishedReleaseForCurrentSystemVersion! !!SMPackageInstallationTask methodsFor: 'queries' stamp: 'gk 10/1/2004 10:06' prior: 28893107!proposals	"Return all different possible proposals to install	sorted with the best proposal first."	^analysis allNormalizedInstallPaths collect: [:path | SMInstallationProposal installList: path]! !!SMPackageInstallationTask methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 28893532!wantedPackages: packages	wantedPackages := packages! !!SMPackageUpgradeTask commentStamp: '<historical>' prior: 28914978!A package upgrade task is to upgrade one or more given SMPackages (not specified releases) in the image to newer releases.First it tries to calculate the newest available releases of the given packages that it will try to upgrade given the policy and preferences set by the user. Then it runs an analysis to find how to upgrade to those wanted releases. This typically results in zero, one or more possible scenarios.!!SMInstaller commentStamp: '<historical>' prior: 28823540!An installer takes care of installing SqueakMap packages represented by SMCards.Deciding if a package is installable and instantiating the correct installer class is done on the class side, see implementors of #canInstall:. Two methods need to be implemented by subclasses - download and install. Upgrade can also be specialized by implementing #upgrade, otherwise it will default to #install.!!SMInstaller class methodsFor: 'changeset utilities' stamp: 'pk 10/17/2006 09:43' prior: 28825527!basicNewChangeSet: newName 	"This method copied here to ensure SqueakMap is independent of 	ChangesOrganizer. "	Smalltalk		at: #ChangesOrganizer		ifPresentAndInMemory: [:cs | ^ cs basicNewChangeSet: newName].	(self changeSetNamed: newName)		ifNotNil: [self error: 'The name ' , newName , ' is already used'].	^ ChangeSet basicNewNamed: newName! !!SMInstaller class methodsFor: 'testing' stamp: 'gk 11/16/2003 23:49' prior: 28826907!canInstall: aPackageRelease	"Nope, I am an abstract class and can not install anything.	But my subclasses should reimplement this."	^ false! !!SMInstaller class methodsFor: 'changeset utilities' stamp: 'pk 10/17/2006 09:43' prior: 28825958!changeSetNamed: newName	"This method copied here to ensure SqueakMap is independent of ChangesOrganizer."	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs changeSetNamed: newName ].	^ChangeSet allInstances detect: [ :cs | cs name = newName ] ifNone: [ nil ].! !!SMInstaller class methodsFor: 'instance creation' stamp: 'gk 11/16/2003 23:33' prior: 28826316!classForPackageRelease: aPackageRelease	"Decide which subclass to instantiate. 	We detect and return the first subclass	that wants to handle the release going	recursively leaf first so that subclasses gets	first chance if several classes compete over	the same packages, like for example SMDVSInstaller	that also uses the .st file extension."	self subclasses do: [:ea |		(ea classForPackageRelease: aPackageRelease)			ifNotNilDo: [:class | ^ class]].	^(self canInstall: aPackageRelease)		ifTrue: [self]! !!SMInstaller class methodsFor: 'deprecated' stamp: 'gk 5/5/2006 02:07' prior: 28827636!forPackageRelease: aPackageRelease	"Instantiate the first class suitable to install the package release.	If no installer class is found we raise an Error."	| class |	aPackageRelease ifNil: [self error: 'No package release specified to find installer for.'].	class := self classForPackageRelease: aPackageRelease.	^class		ifNil: [self error: 'No installer found for package ', aPackageRelease name, '.']		ifNotNil: [class new packageRelease: aPackageRelease]! !!SMInstaller class methodsFor: 'testing' stamp: 'gk 11/16/2003 23:50' prior: 28827126!isInstallable: aPackageRelease	"Detect if any subclass can handle the package release."	aPackageRelease ifNil: [^false].	^(self classForPackageRelease: aPackageRelease) notNil! !!SMInstaller class methodsFor: 'testing' stamp: 'gk 11/16/2003 23:49' prior: 28827381!isUpgradeable: aPackageRelease	"Detect if any subclass can handle the release.	Currently we assume that upgrade is the same as install."	^self isInstallable: aPackageRelease! !!SMInstaller methodsFor: 'services' stamp: 'gk 11/16/2003 21:56' prior: 28824154!download	"This service should bring the package release to	the client and also unpack it on disk if needed.	It will not install it into the running image though.	Raises errors if operation does not succeed."	self subclassResponsibility ! !!SMInstaller methodsFor: 'services' stamp: 'gk 11/16/2003 21:57' prior: 28824468!install	"This service should bring the package release to the client,	unpack it if necessary and install it into the image.	The package release should be notified of the installation using	'packageRelease noteInstalled'."	self subclassResponsibility ! !!SMInstaller methodsFor: 'testing' stamp: 'gk 11/23/2005 00:06' prior: 28825266!isCached	"Check if it is in the cache."	^packageRelease isCached! !!SMInstaller methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28824016!packageRelease: aPackageRelease	packageRelease := aPackageRelease! !!SMInstaller methodsFor: 'private' stamp: 'gk 7/13/2004 02:43' prior: 28825092!silent	"Can we ask questions?"		^packageRelease ifNotNil: [packageRelease map silent] ifNil: [false]! !!SMInstaller methodsFor: 'services' stamp: 'gk 7/14/2004 15:38' prior: 28824794!upgrade	"This service performs an upgrade to the selected release.	Currently it just defaults to the same operation as an install -	which is handled fine by Monticello, but not necessarily for	other formats."	^self install! !!SMSimpleInstaller commentStamp: '<historical>' prior: 28924139!This is a base class that you can subclass if your package format can be downloaded usinga single file url and possibly also be decompressed using gzip.!!SMDefaultInstaller commentStamp: '<historical>' prior: 28766586!An installer takes care of installing SqueakMap packages represented by SMCards.This installer handles packages that consist of classical fileins (single changesets and .st-files) and optional gzip-decompression of those. Deciding if a package is installable and instantiating the correct installer class is done on the class side in SMInstaller, to see how this installer gets chosen - see SMDefaultInstaller class>>canInstall:.!!SMDVSInstaller commentStamp: '<historical>' prior: 28763508!This is an installer class for DVS packages. It handles packages categorized with packageformat as DVS and with a download filename with extensions .st or .st.gz.This class can function without DVS installed, needed classes are looked up dynamically.!!SMDVSInstaller class methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28765693!canInstall: aPackage	"Can I install this? First we check if class StreamPackageLoader	is available, otherwise DVS isn't installed.	Then we check if the package is categorized with package	format DVS - currently we have hardcoded the id of that category."	| fileName |	Smalltalk at: #StreamPackageLoader ifPresentAndInMemory: [ :loader |		fileName := aPackage downloadFileName.		fileName ifNil: [^false].		fileName := fileName asLowercase.		^((fileName endsWith: '.st') or: [fileName endsWith: '.st.gz'])			and: [aPackage categories includes: "The DVS format category"					(SMSqueakMap default						categoryWithId: 'b02f51f4-25b4-4117-9b65-f346215a8e41')]].	^false! !!SMDVSInstaller class methodsFor: 'loading' stamp: 'gk 10/1/2003 13:51' prior: 28765472!loadDVS	"Load the DVS package from SqueakMap."	SMSqueakMap default installPackageWithId: '100d59d0-bf81-4e74-a4fe-5a2fd0c6b4ec'! !!SMDVSInstaller methodsFor: 'services' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28763845!install	"Install using DVS."	| imagePackageLoader streamPackageLoader packageInfo packageManager baseName current new manager |	self cache; unpack.	imagePackageLoader := Smalltalk at: #ImagePackageLoader ifAbsent: [].	streamPackageLoader := Smalltalk at: #StreamPackageLoader ifAbsent: [].	packageInfo := Smalltalk at: #PackageInfo ifAbsent: [].	packageManager := Smalltalk at: #FilePackageManager ifAbsent: [].	({ imagePackageLoader. streamPackageLoader. packageInfo. packageManager } includes: nil)		ifTrue: [ (self confirm: ('DVS support is not loaded, but would be helpful in loading ', unpackedFileName, '.It isn''t necessary, but if you intend to use DVS later it would be a good idea to load it now.Load it from SqueakMap?'))			ifTrue: [ self class loadDVS. ^self install ]			ifFalse: [ ^self fileIn ]].	baseName := packageRelease name.	dir rename: unpackedFileName toBe: (baseName, '.st').	unpackedFileName := baseName, '.st'.	(manager := packageManager allManagers detect: [ :pm | pm packageName = baseName ] ifNone: [])		ifNotNil: [			current := imagePackageLoader new package: (packageInfo named: baseName).			new := streamPackageLoader new stream: (dir readOnlyFileNamed: unpackedFileName).			(new changesFromBase: current) fileIn ]		ifNil: [			self fileIn.			manager := packageManager named: baseName. ].	manager directory: dir.	packageManager changed: #allManagers.	packageRelease noteInstalled! !!SMDefaultInstaller class methodsFor: 'testing' stamp: 'gk 3/31/2006 09:59' prior: 28768726!canInstall: aPackage	"Answer if this class can install/upgrade the package.	This installer handles .st, .cs, .mst, .mcs (Squeak 3.9+)	with or without .gz suffix."	| fileName |	fileName := aPackage downloadFileName.	fileName ifNil: [^false].	fileName := fileName asLowercase.	^self sourceFileSuffixes anySatisfy: [:each | 			(fileName endsWith: (FileDirectory dot, each)) or: [				fileName endsWith: (FileDirectory dot, each, '.gz')]]! !!SMDefaultInstaller class methodsFor: 'private' stamp: 'gk 3/31/2006 10:05' prior: 28769253!multiSuffixes	"Unfortunately we can not tell which suffixes use multibyte encoding.	So we guess that they begin with $m."	^self sourceFileSuffixes select: [:suff | suff first = $m]! !!SMDefaultInstaller class methodsFor: 'private' stamp: 'gk 3/31/2006 10:06' prior: 28769519!nonMultiSuffixes	"Unfortunately we can not tell which suffixes use multibyte encoding.	So we guess that they begin with $m."	^self sourceFileSuffixes reject: [:suff | suff first = $m]! !!SMDefaultInstaller class methodsFor: 'private' stamp: 'gk 3/31/2006 09:59' prior: 28769788!sourceFileSuffixes	"Trying to play nice with all Squeak versions."	^(FileStream respondsTo: #sourceFileSuffixes)			ifTrue: [FileStream sourceFileSuffixes]			ifFalse: [#(cs st)].! !!SMDefaultInstaller methodsFor: 'private' stamp: 'KLC 4/27/2007 17:31' prior: 28767397!fileIn	"Installing in the standard installer is simply filing in.	Both .st and .cs files will file into a ChangeSet of their own.	We let the user confirm filing into an existing ChangeSet	or specify another ChangeSet name if	the name derived from the filename already exists."		| fileStream |	(self class nonMultiSuffixes anySatisfy: [:each | unpackedFileName endsWith: (FileDirectory dot, each)])		ifTrue:[			fileStream := dir readOnlyFileNamed: unpackedFileName.			(fileStream respondsTo: #setConverterForCode) ifTrue: [fileStream setConverterForCode].			self fileIntoChangeSetNamed: (fileStream localName sansPeriodSuffix) fromStream: fileStream.			^self].	(self class multiSuffixes anySatisfy: [:each | unpackedFileName endsWith: (FileDirectory dot, each)])		ifTrue:[			fileStream := dir readOnlyFileNamed: unpackedFileName.			"Only images with converters should have multi suffixes"			fileStream converter: (Smalltalk at: #UTF8TextConverter) new.			self fileIntoChangeSetNamed: (fileStream localName sansPeriodSuffix) fromStream: fileStream.			^self].	self error: 'Filename should end with a proper extension'.! !!SMDefaultInstaller methodsFor: 'services' stamp: 'gk 11/16/2003 20:52' prior: 28767095!install	"This service should bring the package to the client,	unpack it if necessary and install it into the image.	The package is notified of the installation."	self cache; unpack; fileIn.	packageRelease noteInstalled! !!SMLanguageInstaller class methodsFor: 'testing' stamp: 'gk 3/31/2006 00:22' prior: 28829389!canInstall: aPackage	"Answer if this class can install the package.	We handle .translation files optionally compressed."	| fileName |	((Smalltalk includesKey: #Language)		or: [Smalltalk includesKey: #NaturalLanguageTranslator]) ifFalse: [^false].	fileName := aPackage downloadFileName.	fileName ifNil: [^false].	fileName := fileName asLowercase.	^(fileName endsWith: '.translation') or: [		(fileName endsWith: '.tra') or: [			(fileName endsWith: '.tra.gz') or: [				fileName endsWith: '.translation.gz']]]! !!SMLanguageInstaller methodsFor: 'services' stamp: 'gk 3/31/2006 00:23' prior: 28828795!install	"This service should bring the package to the client, 	unpack it if necessary and install it into the image. 	The package is notified of the installation."	| translator |	self cache; unpack.	translator := Smalltalk at: #Language ifAbsent: [Smalltalk at: #NaturalLanguageTranslator].	[translator mergeTranslationFileNamed: unpackedFileName]			ensure: [packageRelease noteInstalled]! !!SMMcInstaller commentStamp: 'gk 10/8/2003 14:28' prior: 28866185!I am a SMInstaller that knows how to install .mcz (Monticello) files. If Monticello is installed I use that (MCMczReader), otherwise I file in the code more simply using the package MCInstaller (MczInstaller).!!SMMcInstaller class methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28868444!canInstall: aPackage	"Is this a Monticello package and do I have MCInstaller	or Monticello available?"	| fileName |	((Smalltalk includesKey: #MCMczReader) or: [		 Smalltalk includesKey: #MczInstaller])			ifTrue: [				fileName := aPackage downloadFileName.				fileName ifNil: [^false].				^ 'mcz' = (FileDirectory extensionFor: fileName) asLowercase].	^false! !!SMMcInstaller methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28866766!fileIn	| extension |	extension := (FileDirectory extensionFor: fileName) asLowercase.	extension = 'mcz'		ifTrue: [self installMcz]		ifFalse: [self error: 'Cannot install file of type .', extension]! !!SMMcInstaller methodsFor: 'private' stamp: 'ab 8/8/2003 18:33' prior: 28867038!fullFileName 	^ dir fullNameFor: fileName! !!SMMcInstaller methodsFor: 'services' stamp: 'gk 11/16/2003 21:55' prior: 28866466!install	"This service should bring the package to the client,	unpack it if necessary and install it into the image.	The package is notified of the installation."	self cache; fileIn.	packageRelease noteInstalled! !!SMMcInstaller methodsFor: 'private' stamp: 'gk 7/13/2004 02:44' prior: 28867151!installMcz	"Install the package, we already know that either MCInstaller or Monticello is available."	| installer monticello |	installer := MczInstaller.	(Smalltalk hasClassNamed: #MCMczReader) ifFalse: [		packageRelease package isInstalled ifTrue: [			(self silent ifFalse: [				(self confirm:'A release of package ''', packageRelease package name, ''' is already installed.You only have MCInstaller and not Monticelloinstalled and MCInstaller can not properly upgrade packages.Do you wish to install Monticello first and then proceed?If you answer no MCInstaller will be used - but at your own risk.Cancel cancels the installation.' orCancel: [self error: 'Installation cancelled.'])]			ifTrue: [false])				ifTrue: [					monticello := packageRelease map packageWithName: 'Monticello'.					monticello lastPublishedRelease						ifNotNil: [monticello lastPublishedRelease install]						ifNil: [monticello lastRelease install].					installer := (Smalltalk at: #MCMczReader)]]	] ifTrue: [installer := (Smalltalk at: #MCMczReader)].	installer loadVersionFile: self fullFileName! !!SMProjectInstaller commentStamp: '<historical>' prior: 28917515!I am a SMInstaller that knows how to install .pr (Project) files.!!SMProjectInstaller class methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28918332!canInstall: aPackage	"Answer if this class can install the package.	We handle .pr files (upper and lowercase)"	| fileName |	fileName := aPackage downloadFileName.	fileName ifNil: [^false].	^'pr' = (FileDirectory extensionFor: fileName) asLowercase! !!SMProjectInstaller methodsFor: 'services' stamp: 'gk 11/16/2003 21:55' prior: 28917657!install	"This service should bring the package to the client, 	unpack it if necessary and install it into the image. 	The package is notified of the installation."	Project canWeLoadAProjectNow ifFalse: [self error: 'Can not load Project now, probably because not in Morphic.'].	self cache.	[[ ProjectLoading openFromDirectory: dir andFileName: fileName ]		on: ProgressTargetRequestNotification do: [ :ex | ex resume ]]			ensure: [packageRelease noteInstalled]! !!SMSARInstaller commentStamp: '<historical>' prior: 28921029!I am a SqueakMap installer that knows how to deal with Zip format change-set archives.I recognize them by the file extension ".sar" (Squeak Archive).These have a couple of members with special names:install/preambleinstall/postscriptThese are loaded in order. Either or both can further load other members using fileInMemberNamed:.Inside a postscript or preamble, the pseudo-variable "self" is set to an instance of SARInstaller; you can then get to its ZipArchive using the method "zip". Or you can call its methods for filing in change sets, extracting files, etc.You can test this loading with:(SMSARInstaller new) directory: FileDirectory default; fileName: 'test.sar'; fileIn.See ChangeSet>>fileOutAsZipNamed: for one way to make these files. Here is another way of creating a multi change set archive installable by SqueakMap:"The following doit will create a .sar file with HVs preamble and postscript asseparate entries and the included changesets included as normal.Given a preamble as described below this will autoinstall in SqueakMap."(ChangeSorter changeSetNamed: 'HV')	fileOutAsZipNamed: 'httpview-021023.sar'	including: {		ChangeSorter changeSetNamed: 'HVFixes'.		ChangeSorter changeSetNamed: 'kom412'}Preamble in changeset HV that will install the changesets:"Change Set:		HVDate:			23 October 2002Author:			Gran HultgrenThis is my latest developer code drop of HttpView packaged as a Squeak selfextracting archive (courtesy Ned Konz).""Standard SqueakMap installing code follows:"(self isKindOf: SARInstaller) ifTrue:[	self fileInMemberNamed: 'HVFixes'.	self fileInMemberNamed: 'kom412'.	self fileInMemberNamed: 'HV']!!SMSARInstaller class methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28923472!canInstall: aPackage	"Answer if this class can install the package.	We handle it if the filename has the extension	.sar (upper and lowercase) and SARInstaller is	present in the image to handle the install."	| fileName |	fileName := aPackage downloadFileName.	fileName ifNil: [^false].	Smalltalk at: #SARInstaller ifPresentAndInMemory: [ :installer |			^'sar' = (FileDirectory extensionFor: fileName) asLowercase].	^false! !!SMSARInstaller methodsFor: 'private' stamp: 'gh 10/31/2002 11:19' prior: 28923069!fileIn	Smalltalk at: #SARInstaller ifPresentAndInMemory: [:installer |		(installer directory: dir fileName: fileName) fileIn. ^self].	self error: 'SAR support not installed in image, can not install.'! !!SMSARInstaller methodsFor: 'services' stamp: 'gk 11/16/2003 21:55' prior: 28922779!install	"This service should bring the package to the client,	unpack it if necessary and install it into the image.	The package is notified of the installation."	self cache; fileIn.	packageRelease noteInstalled! !!SMSimpleInstaller class methodsFor: 'testing' stamp: 'gh 10/22/2002 11:55' prior: 28928150!canInstall: aPackage	"Answer if this class can install the package.	This class is abstract so we return false."	^false! !!SMSimpleInstaller methodsFor: 'services' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28924949!cache	"Download object into cache if needed.	Set the directory and fileName for subsequent unpacking and install."	packageRelease ensureInCache ifTrue: [		fileName := packageRelease downloadFileName.		dir := packageRelease cacheDirectory]! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'gh 10/23/2002 10:54' prior: 28924369!directory	^dir! !!SMSimpleInstaller methodsFor: 'services' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28925281!download	"This service downloads the last release of the package	even if it is in the cache already."	packageRelease download ifTrue: [		fileName := packageRelease downloadFileName.		dir := packageRelease cacheDirectory]! !!SMSimpleInstaller methodsFor: 'services' stamp: 'rbb 3/1/2005 11:12' prior: 28925583!fileIntoChangeSetNamed: aString fromStream: stream	"We let the user confirm filing into an existing ChangeSet	or specify another ChangeSet name if	the name derived from the filename already exists."		| changeSet newName oldChanges global |	newName := aString.	changeSet := SMInstaller changeSetNamed: newName.	changeSet ifNotNil: [		newName := self silent ifNil: [UIManager default									request: 'ChangeSet already present, just confirm to overwrite or enter a new name:' 									initialAnswer: newName]						ifNotNil: [newName].		newName isEmpty ifTrue:[self error: 'Cancelled by user'].		changeSet := SMInstaller changeSetNamed: newName].		changeSet ifNil:[changeSet := SMInstaller basicNewChangeSet: newName].		changeSet ifNil:[self error: 'User did not specify a valid ChangeSet name'].		oldChanges := (SystemVersion current highestUpdate < 5302)						ifFalse: [global := ChangeSet. ChangeSet current]						ifTrue: [global := Smalltalk. Smalltalk changes]. 		[global newChanges: changeSet.		stream fileInAnnouncing: 'Loading ', newName, ' into change set ''', newName, ''''.		stream close] ensure: [global newChanges: oldChanges]! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'gh 10/21/2002 14:39' prior: 28924462!fileName	^fileName! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28924570!fileName: aFileName	fileName := aFileName! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'nk 2/22/2004 13:12' prior: 28924689!fullFileName 	^ self directory fullNameFor: self fileName! !!SMSimpleInstaller methodsFor: 'services' stamp: 'gk 4/18/2006 22:59' prior: 28926818!unpack	"This basic installer simply checks the file extension of	the downloaded file to choose suitable method for unpacking.	Currently it only supports .gz decompression.	If a file exists with the same name it is first deleted.	The unpacked filename is set on succesfull decompression or	if the file was not recognized as a compressed file."	| unzipped zipped buffer |	(fileName endsWith: '.gz')		ifTrue:[			unpackedFileName := fileName copyUpToLast: FileDirectory extensionDelimiter.			(dir fileExists: unpackedFileName) ifTrue:[ dir deleteFileNamed: unpackedFileName ].			unzipped := dir newFileNamed: unpackedFileName.			unzipped binary.			zipped := GZipReadStream on: ((dir readOnlyFileNamed: fileName) binary; yourself).			buffer := ByteArray new: 50000.			'Extracting ' , fileName				displayProgressAt: Sensor cursorPoint				from: 0				to: zipped sourceStream size				during: [:bar | 					[zipped atEnd]						whileFalse: 							[bar value: zipped sourceStream position.							unzipped nextPutAll: (zipped nextInto: buffer)].					zipped close.					unzipped close]]		ifFalse:[unpackedFileName := fileName]! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'gh 10/21/2002 14:39' prior: 28924825!unpackedFileName	^unpackedFileName! !!SMObject commentStamp: 'gk 9/23/2003 20:26' prior: 28869038!SMObject is the abstract superclass for all objects living in an SMSqueakMap.It has a unique UUID and a reference to the owning SMSqueakMap.It has timestamps to record the birthtime and the last modification.It has basic attributes like name, oneline summary and url.!!SMCategorizableObject commentStamp: '<historical>' prior: 28751074!A categorizable object can be associated with one or more SMCategories.The relation between the categories and the SMCategorizableObject is bidirectional.A categorizable object can also have attached resources, see SMResource.The categories are used to classify the categorizable object for different purposes.Package and package releases are classified in different ways, but so can resources and accounts be.!!SMCategorizableObject methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28753619!addCategory: aCategory	"Add <aCategory> to me. If I already have it do nothing."	categories ifNil: [categories := OrderedCollection new].	(categories includes: aCategory) ifFalse:[		aCategory addObject: self.		categories add: aCategory].	^aCategory! !!SMCategorizableObject methodsFor: 'resources' stamp: 'gk 5/5/2006 02:07' prior: 28754642!addResource: aResource	"Lazily initialize the resources collection."		resources ifNil: [resources := OrderedCollection new].	aResource object: self.	^resources add: aResource! !!SMCategorizableObject methodsFor: 'accessing' stamp: 'gk 9/23/2003 20:44' prior: 28751570!categories	"Lazily initialized."	^categories ifNil: [OrderedCollection new]! !!SMCategorizableObject methodsFor: 'categories' stamp: 'gk 9/23/2003 20:45' prior: 28751888!categoriesDo: aBlock	"Evaluate aBlock for each of the categories."	categories ifNil: [^self].	categories do: aBlock! !!SMCategorizableObject methodsFor: 'categories' stamp: 'gk 11/24/2005 11:18' prior: 28752090!categoryForParent: aCategory	"Answer one of my categories with parent <aCategory>, if I have it."	categories ifNil: [^nil].	^categories detect: [:cat | cat parent = aCategory ] ifNone: [nil]! !!SMCategorizableObject methodsFor: 'private' stamp: 'gk 8/8/2003 02:35' prior: 28753952!delete	"Delete me. Disconnect me from my categories."	super delete.	self removeFromCategories! !!SMCategorizableObject methodsFor: 'printing' stamp: 'dew 3/17/2004 16:28' prior: 28752859!describeCategoriesOn: aStream indent: tabs 	"Show a full listing of categories and their dscription on aStream, indented by the given number of tabs."	categories isEmptyOrNil		ifFalse: [aStream cr;				withAttribute: TextEmphasis bold				do: [aStream nextPutAll: 'Categories: ']; cr.			(self categories asSortedCollection: [:a :b | a path < b path])				do: [:c | 					aStream tab: tabs.					c						parentsDo: [:p | aStream nextPutAll: p name;								 nextPut: $/].					aStream nextPutAll: c name;						 nextPutAll: ' - ';												withAttributes: {TextEmphasis italic. TextIndent tabs: tabs + 1 }						do: [aStream nextPutAll: c summary];						 cr]]! !!SMCategorizableObject methodsFor: 'resources' stamp: 'gk 7/27/2004 18:12' prior: 28754902!embeddedResources	"Return all embedded resources."		^resources ifNil: [#()]		ifNotNil: [resources select: [:r | r isEmbedded ]]	! !!SMCategorizableObject methodsFor: 'categories' stamp: 'gh 11/27/2002 12:35' prior: 28752367!hasCategory: aCategory	"Answer true if I am in it."	^categories notNil and: [categories includes: aCategory]! !!SMCategorizableObject methodsFor: 'categories' stamp: 'gk 7/9/2004 02:57' prior: 28752559!hasCategoryOrSubCategoryOf: aCategory	"Answer true if I am in aCategory or if I am in any	of its sub categories recursively."	aCategory allCategoriesDo: [:cat |		(self hasCategory: cat) ifTrue: [^ true]].	^false! !!SMCategorizableObject methodsFor: 'private' stamp: 'gh 11/27/2002 12:35' prior: 28754129!removeCategory: aCategory	"Remove category from me if I am in it."	(categories notNil and: [categories includes: aCategory]) ifTrue:[		aCategory removeObject: self.		categories remove: aCategory].	^aCategory! !!SMCategorizableObject methodsFor: 'private' stamp: 'gh 11/27/2002 12:35' prior: 28754422!removeFromCategories	"Remove me from all my categories."	categories ifNotNil:[		categories copy do: [:cat | self removeCategory: cat ]]! !!SMCategorizableObject methodsFor: 'resources' stamp: 'gk 11/24/2005 11:23' prior: 28755117!removeResource: aResource	"Disconnect and remove the resource."		aResource object: nil.	^resources remove: aResource! !!SMCategorizableObject methodsFor: 'accessing' stamp: 'gk 7/27/2004 13:09' prior: 28751729!resources	"Lazily initialized."	^resources ifNil: [OrderedCollection new]! !!SMPackageRelease commentStamp: '<historical>' prior: 28895235!A package release refers to a specific version of the package.Releases are auto numbered (with a VersionNumber) and also has a designated version name which can be whatever the maintainer wants.There is also a release note and the URL for download. The inherited url is for any homepage for the release.The instvar publisher refers to the SMAccount that owned the package at the time of the release and the instvar package refers to the owning package.The instvar repository holds a String that is used to connect to the live repository for the package release, for example a Monticello repository.!!SMPackageRelease class methodsFor: 'instance creation' stamp: 'gk 12/7/2005 14:16' prior: 28911042!newFromRelease: aPackageRelease package: aPackage	"Create a new release from a given release."	^super new initializeFromRelease: aPackageRelease package: aPackage! !!SMPackageRelease methodsFor: 'configurations' stamp: 'gk 7/27/2004 17:58' prior: 28909660!addConfiguration	"Create and add a new SMPackageReleaseConfiguration and return it."	^ self addResource: (SMPackageReleaseConfiguration newIn: map)! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 11:22' prior: 28895913!automaticVersion	"Return the VersionNumber for me."	^automaticVersion! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 8/12/2003 17:21' prior: 28896061!automaticVersionString	"Return my VersionNumber as a String."	^automaticVersion versionString! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 8/13/2003 15:25' prior: 28896233!cacheDirectory	^ map cache directoryForPackageRelease: self! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 11/23/2005 01:13' prior: 28896370!calculateSha1sum	"Return the checksum of the currently cached file contents."	^SecureHashAlgorithm new hashMessage: self contents				! !!SMPackageRelease methodsFor: 'configurations' stamp: 'gk 7/27/2004 14:29' prior: 28909891!configurations	"Return all SMPackageReleaseConfigurations attached to this release."	^ self embeddedResources select: [:er | er isConfiguration]! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 11/22/2005 22:41' prior: 28896586!contents	"Return the contents of the cached file.	If it is not downloadable, or if the file	is not cached, return nil."	^map cache contents: self! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 11/23/2005 01:50' prior: 28896813!correctSha1sum: content	"Return if the checksum of the content is correct.	If we have none, then we consider that to be correct."		^sha1sum isNil or: [sha1sum = (SecureHashAlgorithm new hashMessage: content)]				! !!SMPackageRelease methodsFor: 'deletion' stamp: 'gh 11/28/2002 21:32' prior: 28898709!delete	super delete.	package removeRelease: self! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 8/13/2003 15:43' prior: 28901724!download	"Force a download into the cache regardless if it is already there."	^map cache download: self! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 14:03' prior: 28897109!downloadFileName	"Cut out the filename from the url."	downloadUrl isEmpty ifTrue: [^nil].	^downloadUrl asUrl path last! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 15:31' prior: 28897308!downloadUrl	^downloadUrl! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 15:31' prior: 28897410!downloadUrl: anObject	^downloadUrl := anObject! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 7/13/2004 00:48' prior: 28901905!eitherVersion	"Return either version:		1. If the maintainer entered a version then we use that.		2. Otherwise we use the automatic version with an 'r' prepended."	^version notEmpty			ifTrue:[version]			ifFalse:['r', automaticVersion versionString]! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 7/10/2004 03:53' prior: 28902234!ensureInCache	"Makes sure the file is in the cache.	Return true on success, otherwise false."	^map cache add: self! !!SMPackageRelease methodsFor: 'printing' stamp: 'dew 10/23/2006 18:52' prior: 28899255!fullDescription	"Return a full textual description of the package release."	| s |	s := TextStream on: (Text new: 400).	self describe: self package name withBoldLabel: 'Package Name: ' on: s.	name isEmptyOrNil ifFalse:		[self describe: self name withBoldLabel: 'Release Name: ' on: s].	summary isEmptyOrNil ifFalse:		[self describe: self summary withBoldLabel: 'Release Summary: ' on: s].	self 		describe: self version		withBoldLabel: 'Version: '		on: s.	categories isEmptyOrNil 		ifFalse: 			[s				cr;				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Categories: '];				cr.			(self categories asSortedCollection: [:a :b | a path < b path])				do: [:c | 					s						tab;						withAttribute: TextEmphasis italic							do: 								[c parentsDo: 										[:p | 										s											nextPutAll: p name;											nextPutAll: '/'].								s nextPutAll: c name];						nextPutAll: ' - ' , c summary;						cr].			s cr].	created ifNotNil: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Created: ' ];			print: self created;			cr].	updated ifNotNil: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Modified: ' ];			print: self updated;			cr].	publisher ifNotNil: [		s			withAttribute: TextEmphasis bold			do: [s nextPutAll: 'Publisher: '].		s			withAttribute: (PluggableTextAttribute					evalBlock: [self userInterface									sendMailTo: self publisher email									regardingPackageRelease: self])			do: [s nextPutAll: self publisher nameAndEmail];				cr].	self note isEmptyOrNil 		ifFalse: 			[s				cr;				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Version Comment:'].			s cr.			s withAttribute: (TextIndent tabs: 1) do: [s nextPutAll: self note withSqueakLineEndings].			s				cr;				cr].	url isEmptyOrNil 		ifFalse: 			[s				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Homepage:'];				tab;				withAttribute: (TextURL new url: url) do: [s nextPutAll: url];				cr].	self downloadUrl isEmptyOrNil 		ifFalse: 			[s				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Download:'];				tab;				withAttribute: (TextURL new url: self downloadUrl)					do: [s nextPutAll: self downloadUrl];				cr].	^s contents.! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 7/12/2004 16:04' prior: 28902427!fullVersion	"Return version followed by the automatic version	with r prepended in parenthesis."	^version, ' (r', automaticVersion versionString, ')'! !!SMPackageRelease methodsFor: 'view' stamp: 'gk 10/12/2005 12:25' prior: 28908366!getLink: aBuilder	"Return a link for using on the web."	^self getLink: aBuilder view: aBuilder view! !!SMPackageRelease methodsFor: 'view' stamp: 'gk 10/12/2005 12:27' prior: 28908540!getLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLinkTop: self relativeUrl text: self packageNameWithVersion! !!SMPackageRelease methodsFor: 'view' stamp: 'gk 10/12/2005 12:27' prior: 28908755!getShortLink: aBuilder	^aBuilder getLinkTop: self relativeUrl text: self listName! !!SMPackageRelease methodsFor: 'configurations' stamp: 'gk 9/20/2004 21:17' prior: 28910120!hasFulfilledConfiguration	"Is any of the configurations already fulfilled?	A fulfilled configuration has all required releases	already installed, this means the release can be	trivially installed."		^self workingConfigurations anySatisfy: [:c | c isFulfilled]! !!SMPackageRelease methodsFor: 'configurations' stamp: 'gk 9/20/2004 21:16' prior: 28910466!hasNoConfigurations	"Does this release lack configurations,	both working or failed ones? This is interpreted	as if the release has no dependencies."	^self configurations isEmpty! !!SMPackageRelease methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 28898844!initializeFromRelease: parentRelease package: aPackage	"Initialize package release from a given parent.	Branch if needed."	self map: aPackage map id: UUID new.	package := aPackage.	automaticVersion :=		parentRelease			ifNil: [VersionNumber first]			ifNotNil: [parentRelease nextOrBranch].	version := note := downloadUrl := ''! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 2/16/2004 20:04' prior: 28902654!install	"Install this package release."	^map installPackageRelease: self! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 8/13/2003 15:32' prior: 28905555!isCached	"Delegate to last release."	^map cache includes: self! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 5/5/2006 01:54' prior: 28905693!isCompatibleWithCurrentSystemVersion	"Return true if this release is listed as being compatible with the SystemVersion of the current image.  Only checks major/minor version number; does not differentiate between alpha/beta/gamma releases.  Checks version categories of both the SMPackageRelease and the parent SMPackage."	| current |	current := self majorMinorVersionFrom: SystemVersion current version.	self categories, self package categories do: [:c |		((c parent name = 'Squeak versions') and: [			(self majorMinorVersionFrom: c name) = current])				ifTrue: [^true]].	^ false		"	^ (self categories, self package categories		detect:			[:cat | (cat parent name = 'Squeak versions')					and: [(SystemVersion new version: cat name) majorMinorVersion = SystemVersion current majorMinorVersion]]		ifNone: []) notNil"! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 10/15/2003 12:37' prior: 28906599!isDownloadable	"Answer if I can be downloaded.	We simply verify that the download url	ends with a filename."	^self downloadFileName isEmptyOrNil not! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 11/16/2003 23:48' prior: 28906827!isInstallable	"Answer if there is any installer for me.	This depends typically on the filename of	the download url, but can in the future	depend on other things too.	It does *not* say if the release is installed or not."	^SMInstaller isInstallable: self! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 7/13/2004 13:59' prior: 28907161!isInstalled	"Answer if this release is installed."	^(map installedReleaseOf: package) == self! !!SMPackageRelease methodsFor: 'testing' stamp: 'gh 12/1/2002 19:52' prior: 28907331!isPackageRelease	^true! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 9/23/2003 21:09' prior: 28907428!isPublished	"It is published when the publisher is set."	^publisher notNil! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 11/17/2003 12:01' prior: 28907580!isUpgradeable	"Answer if there is any installer that can upgrade me.	This depends typically on the filename of	the download url, but can in the future	depend on other things too.	It does *not* say if the package is installed or not	or if there is a newer version available or not."	^SMInstaller isUpgradeable: self! !!SMPackageRelease methodsFor: 'printing' stamp: 'gk 7/10/2004 03:35' prior: 28900713!listName	"Return something suitable for showing in lists.	We list the manual version after a dash if it is available.	We don't list the release name."	^version isEmpty		ifFalse: [self automaticVersion versionString , '-', version]		ifTrue: [self automaticVersion versionString] ! !!SMPackageRelease methodsFor: 'private' stamp: 'gk 5/5/2006 01:54' prior: 28909116!majorMinorVersionFrom: aVersionName	| start |	start := aVersionName indexOf: $..	start = 0 ifTrue: [^ aVersionName].	aVersionName size = start ifTrue: [^ aVersionName].	start + 1 to: aVersionName size do: [:i |		(aVersionName at: i) isDigit ifFalse: [^aVersionName copyFrom: 1 to: i - 1]].	^aVersionName! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 7/13/2004 13:24' prior: 28907976!newerThan: aRelease	"Answer if this release was made after <aRelease>."		^aRelease automaticVersion < automaticVersion! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 5/5/2006 02:07' prior: 28902803!nextOrBranch	"Return a new automaticVersion that is either	the next following my version, or if that is taken	a branch, or if that is taken too - a branch from it and so on.	Yes, it sucks, but I don't have time hacking VersionNumber right now."	| nextVersion nextBranch |	nextVersion := automaticVersion next.	(package releaseWithAutomaticVersion: nextVersion) ifNil: [^nextVersion].	nextBranch := automaticVersion branchNext.	[(package releaseWithAutomaticVersion: nextBranch) notNil]		whileTrue: [nextBranch := nextBranch branchNext].	^nextBranch ! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 12:43' prior: 28897534!note	^note! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 12:43' prior: 28897622!note: anObject	^note := anObject! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 11/17/2003 01:25' prior: 28903441!noteInstalled	"This package release was just successfully installed.	We tell the map so that it can keep track of what	package releases are installed."	map noteInstalled: self! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 1/23/2004 10:01' prior: 28903696!noteUninstalled	"This package release was just successfully uninstalled.	We tell the map so that it can keep track of what	package releases are installed."	self error: 'Uninstall is not working yet!!'.	map noteUninstalled: self! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 7/13/2004 13:24' prior: 28908171!olderThan: aRelease	"Answer if this release was made before <aRelease>."		^automaticVersion < aRelease automaticVersion! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 3/15/2003 20:55' prior: 28897731!package	"Get the package that I belong to."	^package! !!SMPackageRelease methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28909513!package: aPackage	"Set when I am created."	package := aPackage! !!SMPackageRelease methodsFor: 'printing' stamp: 'gk 7/10/2004 03:38' prior: 28901073!packageNameWithVersion	"Return '<packageName> <autoVersion>-<version>' like:		'SqueakMap 5-0.92'	"	^package name, ' ', self listName! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 10/12/2005 13:25' prior: 28904005!parentRelease	"Return my parent release based on the automatic	version number."	^package parentReleaseFor: self! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 10/12/2005 13:23' prior: 28904196!previousRelease	"Return the release before me.	Returns nil if there is none.	This is chronological order and not how they relate."	^package previousReleaseFor: self! !!SMPackageRelease methodsFor: 'printing' stamp: 'gk 7/10/2004 03:38' prior: 28901284!printName	"Return a String identifying object without context."	^self packageNameWithVersion! !!SMPackageRelease methodsFor: 'printing' stamp: 'gk 12/9/2003 00:13' prior: 28901454!printOn: aStream	aStream nextPutAll: self class name, '[', self packageNameWithVersion, ']'! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 6/26/2003 14:59' prior: 28897862!publisher	^publisher! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 6/26/2003 15:00' prior: 28897959!publisher: anObject	publisher := anObject! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 10/12/2005 00:24' prior: 28904441!relativeUrl	"Return the relative url for this release on an SM server."		^'package/', package id asString, '/autoversion/', automaticVersion versionString! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 7/15/2004 16:26' prior: 28898077!repository	^repository! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 28898175!repository: aString	repository := aString! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 11/22/2005 22:29' prior: 28898294!sha1sum	^sha1sum! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 28898386!sha1sum: aString	sha1sum := aString! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 7/13/2004 00:49' prior: 28904673!smartVersion	"This method is used to ensure that we always have a	version name for the package release even if the maintainer didn't	bother to enter one. Is is calculated like this:		1. If the maintainer entered a version then we use that.		2. Otherwise we use the automatic version with an 'r' prepended.		3. If the release is not published we enclose it in parenthesis."	^ self isPublished ifTrue: [self eitherVersion] ifFalse: ['(', self eitherVersion, ')']! !!SMPackageRelease methodsFor: 'printing' stamp: 'gk 11/14/2003 00:11' prior: 28901623!type	^'Package release'! !!SMPackageRelease methodsFor: 'services' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28905228!upgrade	"Upgrade this package release if there is a new release available."	| newRelease |	newRelease := package lastPublishedReleaseForCurrentSystemVersionNewerThan: self.	newRelease ifNotNil: [(SMInstaller forPackageRelease: newRelease) upgrade]! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 15:30' prior: 28898499!version	^version! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 15:30' prior: 28898593!version: anObject	^version := anObject! !!SMPackageRelease methodsFor: 'view' stamp: 'gh 3/15/2003 19:37' prior: 28908909!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject packageReleaseViewOn: self! !!SMPackageRelease methodsFor: 'configurations' stamp: 'gk 7/27/2004 14:55' prior: 28910729!workingConfigurations	"Return all working configurations."		^ self configurations select: [:c | c isWorking ]! !!SMRootedObject commentStamp: '<historical>' prior: 28920656!An SMRootedObject is an SMObject that can be "rooted" in a given homeMap. This concept is for the upcoming new architecture with a tree of SM servers. Not used yet.!!SMAccount commentStamp: '<historical>' prior: 28740513!SMAccount is the object representing a user account in SqueakMap - a Squeaker that owns information in SqueakMap.It keeps track of the email address, developer initials and two passwords used to access the account. There is also an advogatoId (people.squeakfoundation.org username) and a signature field (not used yet). The flag isAdmin is a crude way of marking a user as a superuser, this will possibly be changed in the future and instead expressed using a category.Passwords are stored as secure hashes. The extra password (newPassword) is used when the regular password is forgotten - it is then randomly set and an email is sent out containing it to the registered email. This enables the original password to still work. When logging in, the user gets a chance to enter a new regular password overwriting the old one and clearing the random new password in the process.The instvar objects holds all SMPersonalObjects (instances of subclasses) that this account "owns" - these are typically instances of SMPackages and SMResources, but are not limited to be.The instvar coObjects holds all SMPersonalObjects that this account is co-maintaining - these are typically instances of SMPackages and SMResources.Finally the account also maintains a directory with uploaded files on the server. This directory has the UUID of the account as its name and it is located under sm/accounts!!SMAccount methodsFor: 'objects' stamp: 'gk 11/11/2003 16:16' prior: 28746298!addCoObject: anObject	"Add <anObject> to this account.	Only called from #addMaintainer:."		(coObjects includes: anObject)		ifFalse:[coObjects add: anObject]! !!SMAccount methodsFor: 'objects' stamp: 'gk 11/11/2003 20:49' prior: 28746527!addObject: anObject	"Add <anObject> to this account. Also makes sure the	reverse reference is correct."		(objects includes: anObject) ifFalse:[		objects add: anObject.		anObject owner: self.		map addObject: anObject]! !!SMAccount methodsFor: 'accessing' stamp: 'gk 11/13/2003 23:06' prior: 28741976!advogatoId	^advogatoId! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28742080!advogatoId: aString	advogatoId := aString! !!SMAccount methodsFor: 'objects' stamp: 'gk 11/24/2005 11:13' prior: 28746818!coPackageWithId: anIdString	"Return the correct package or nil."	^self withId: anIdString in: self coPackages! !!SMAccount methodsFor: 'objects' stamp: 'gk 11/24/2005 11:10' prior: 28746998!coPackages	"Return all co-maintained packages."	^coObjects select: [:o | o isPackage]! !!SMAccount methodsFor: 'passwords' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28748263!correctPassword: aPassword	"We store the password as a SHA hash so that we can let the slave maps	have them too. Also check the optional new random password."	| try |	aPassword isEmptyOrNil ifTrue:[^false].	try := SecureHashAlgorithm new hashMessage: aPassword.	^password = try or: [newPassword = try]! !!SMAccount methodsFor: 'passwords' stamp: 'gk 5/5/2006 02:07' prior: 28748639!createRandomPassword	"Create a random password and set it	in parallell to the regular one."	| randomPass |	randomPass := String streamContents: [:stream | 10 timesRepeat: [ stream nextPut: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' atRandom]].	self setNewPassword: randomPass.	^randomPass! !!SMAccount methodsFor: 'files' stamp: 'gk 3/8/2004 19:26' prior: 28743961!delete	"Delete this account. First delete all SM objects we own	and disconnect this account from those we co-maintain."	objects do: [:o | o delete].	coObjects do: [:co | co removeMaintainer: self].	super delete! !!SMAccount methodsFor: 'files' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28744255!deleteFiles: fileNames	"Delete all fileNames from the uploads directory."	| dir |	dir := self uploadsDirectory.	fileNames do: [:fn | dir deleteFileNamed: fn]! !!SMAccount methodsFor: 'files' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28744495!directory	"Get the directory for the account."	| dir |	dir := (map directory directoryNamed: 'accounts') assureExistence; yourself.	^(dir directoryNamed: id asString) assureExistence; yourself! !!SMAccount methodsFor: 'accessing' stamp: 'gk 6/26/2003 14:26' prior: 28742191!email	^email! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28742285!email: address	email := address! !!SMAccount methodsFor: 'files' stamp: 'gk 3/8/2004 19:26' prior: 28744757!entries	"Return all file entries in the upload directory."	^self uploadsDirectory entries! !!SMAccount methodsFor: 'files' stamp: 'gk 8/15/2003 12:08' prior: 28744914!files	"Return filenames for uploaded files."	^self uploadsDirectory fileNames! !!SMAccount methodsFor: 'view' stamp: 'gk 10/12/2005 12:24' prior: 28749952!getLink: aBuilder	"Return a link for using on the web.	Always from the top."	^aBuilder getLinkTop: 'accountbyid/', id asString text: self nameWithInitials! !!SMAccount methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28746042!initialize	"Initialize account."	super initialize.	initials := signature := advogatoId := ''.	isAdmin := false.	objects := OrderedCollection new.	coObjects := OrderedCollection new! !!SMAccount methodsFor: 'accessing' stamp: 'gk 7/30/2003 14:10' prior: 28742386!initials	^initials! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28742486!initials: aString	"If these are changed we need to update the dictionary in the map."	initials ~= aString ifTrue: [		initials := aString.		map clearUsernames]! !!SMAccount methodsFor: 'testing' stamp: 'gk 6/26/2003 16:47' prior: 28749759!isAccount	^true! !!SMAccount methodsFor: 'accessing' stamp: 'gk 11/17/2003 11:49' prior: 28742719!isAdmin	^isAdmin ifNil: [false] ifNotNil: [isAdmin]! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28742852!isAdmin: aBoolean	isAdmin := aBoolean! !!SMAccount methodsFor: 'view' stamp: 'gk 8/4/2003 14:10' prior: 28750173!logout	"Automatically called upon logout. Do nothing."! !!SMAccount methodsFor: 'objects' stamp: 'gk 8/7/2003 21:00' prior: 28747152!moveObject: aPersonalObject toAccount: anAccount	"Transfer the ownership of the given personal object to <anAccount>."	self removeObject: aPersonalObject.	anAccount addObject: aPersonalObject! !!SMAccount methodsFor: 'accessing' stamp: 'gk 11/24/2005 11:09' prior: 28742960!nameAndEmail	"This is not really correct, the name needs to be	mime encoded."	^name , ' <', email, '>'! !!SMAccount methodsFor: 'view' stamp: 'gk 8/5/2003 13:16' prior: 28750291!nameWithInitials	"Return name and developer initials within parentheses."	^name, ' (', (initials isEmptyOrNil ifTrue: ['not entered'] ifFalse: [initials]) , ')'! !!SMAccount methodsFor: 'files' stamp: 'gk 4/18/2006 22:53' prior: 28745060!newFile: fileName block: aBlock	"Create a new file. Let <aBlock> fill the file with content by calling it with a stream."	| dir stream |	dir := self uploadsDirectory.	[(dir fileExists: fileName) ifTrue:[dir deleteFileNamed: fileName].	stream := dir newFileNamed: fileName.	stream binary.	aBlock value: stream] ensure: [stream close]! !!SMAccount methodsFor: 'accessing' stamp: 'gk 8/4/2003 16:34' prior: 28743134!newPassword	"Get the parallell password hash."	^newPassword! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28743277!newPassword: aHashNumber	"Set the parallell password hash."	newPassword := aHashNumber! !!SMAccount methodsFor: 'testing' stamp: 'gk 11/11/2003 17:24' prior: 28749843!owns: anObject	^objects includes: anObject! !!SMAccount methodsFor: 'objects' stamp: 'gk 11/24/2005 11:14' prior: 28747415!packageWithId: anIdString	"Return the correct package or nil."	^self withId: anIdString in: self packages! !!SMAccount methodsFor: 'objects' stamp: 'gk 11/24/2005 11:14' prior: 28747591!packages	"Return all owned packages."	^objects select: [:o | o isPackage]! !!SMAccount methodsFor: 'accessing' stamp: 'gk 8/4/2003 15:42' prior: 28743434!password	"Get the password hash."	^password! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28743561!password: aHashNumber	"Set the password hash."	password := aHashNumber! !!SMAccount methodsFor: 'view' stamp: 'gk 8/8/2003 00:09' prior: 28750517!publicViewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject publicAccountViewOn: self! !!SMAccount methodsFor: 'objects' stamp: 'gk 11/11/2003 16:16' prior: 28747735!removeCoObject: anObject	"Remove <anObject> from this account.	Only called from #removeMaintainer:."	(coObjects includes: anObject) ifTrue: [		coObjects remove: anObject]! !!SMAccount methodsFor: 'objects' stamp: 'gk 8/7/2003 20:56' prior: 28747976!removeObject: anObject	"Remove <anObject> from this account. Also makes sure the	reverse reference is cleared."	(objects includes: anObject) ifTrue: [		anObject owner: nil.		objects remove: anObject]! !!SMAccount methodsFor: 'passwords' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28749011!setNewPassword: aString	"Set a new parallell password the user can use to get in	if the old password is forgotten. We don't delete the old	password since the request for this new password is made	anonymously. Note that the password is stored as a secured	hash large integer."	newPassword := SecureHashAlgorithm new hashMessage: aString! !!SMAccount methodsFor: 'passwords' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28749434!setPassword: aString	"We also clear the random extra password."	password := SecureHashAlgorithm new hashMessage: aString.	newPassword := nil! !!SMAccount methodsFor: 'accessing' stamp: 'gk 8/4/2003 15:56' prior: 28743702!signature	"Get the signature."	^signature! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28743827!signature: aSignature	"Set the signature."	signature := aSignature! !!SMAccount methodsFor: 'files' stamp: 'gk 4/3/2006 23:58' prior: 28745464!streamForFile: fileName	"Return a readonly stream for file <fileName>.	If the file does not exist return nil."	| stream |	[stream := StandardFileStream oldFileNamed: (self uploadsDirectory fullNameFor: fileName)]		on: FileDoesNotExistException do: [^nil].	^stream! !!SMAccount methodsFor: 'printing' stamp: 'gk 11/24/2005 11:09' prior: 28749648!type	"Used in various views."	^'Account'! !!SMAccount methodsFor: 'files' stamp: 'gk 8/14/2003 14:23' prior: 28745799!uploadsDirectory	"Get the directory for uploaded files, create it if missing."	^(self directory directoryNamed: 'uploads') assureExistence; yourself! !!SMAccount methodsFor: 'view' stamp: 'gk 6/26/2003 16:01' prior: 28750719!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject accountViewOn: self! !!SMPersonalObject commentStamp: 'gk 7/27/2004 13:28' prior: 28916690!SMPersonalObject is the abstract base class for things that belong/are owned by a user account in SqueakMap. Most things are personal objects - but the SMCategories aren't for example.A personal object has a reference to the SMAccount owning it.!!SMMaintainableObject commentStamp: '<historical>' prior: 28864193!A mainainable object is a personal object that is of such a complexity that it seems beneficial to optionally co-maintain with other people.It thus has a potential list of maintainers - other accounts that also can modify the object. It also has a field to be able to refer to an RSS feed regarding the object.!!SMDocument commentStamp: '<historical>' prior: 28795023!An SMDocument refers typically to a piece of digital information accessible through a URL. :-)This means it can be downloaded and cached.The instvar description describes the document and instvar author references the name and/or email of the original author.SMDocument has one subclasses - SMPackage. Since SqueakMap is primarily meant forkeeping track of installable source packages of Squeak software, a specific subclass handles those.!!SMDocument methodsFor: 'accessing' stamp: 'gk 3/8/2004 19:51' prior: 28795536!author	^author! !!SMDocument methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28795633!author: aString	author := aString! !!SMDocument methodsFor: 'accessing' stamp: 'gk 3/8/2004 19:52' prior: 28795736!description	^description! !!SMDocument methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28795843!description: aString	description := aString! !!SMDocument methodsFor: 'cache' stamp: 'gk 3/8/2004 19:51' prior: 28795953!ensureInCache	"Makes sure the file is in the cache."	self subclassResponsibility ! !!SMDocument methodsFor: 'initialize-release' stamp: 'gk 12/7/2005 13:51' prior: 28796282!initialize	super initialize.	description := author := ''! !!SMDocument methodsFor: 'cache' stamp: 'gk 8/12/2003 17:09' prior: 28796103!isCached	"Is the file corresponding to me in the local file cache?"	self subclassResponsibility ! !!SMDocument methodsFor: 'testing' stamp: 'gk 7/16/2004 11:08' prior: 28796410!isDownloadable	"Answer if I can be downloaded.	Default is false."		^ false		! !!SMPackage commentStamp: '<historical>' prior: 28873728!An SMPackage represents a named piece of an installable "thing" in the image. Typically it is a code package, but it can be other things too.It owns a collection of SMPackageReleases. Each release represents a version of the package, and each release has a URL that refers to the actual content that can be installed.An SMPackage also knows its packageInfoName which can tie it into the image.!!SMPackage methodsFor: 'private' stamp: 'gk 10/12/2005 15:44' prior: 28891049!addRelease: aRelease	"Add the release. Make sure package is set."	releases add: aRelease.	aRelease package: self.	^aRelease! !!SMPackage methodsFor: 'cache' stamp: 'gk 8/12/2003 17:20' prior: 28877939!cacheDirectory	^ self lastRelease cacheDirectory! !!SMPackage methodsFor: 'accessing' stamp: 'gk 7/12/2004 16:05' prior: 28874192!currentVersion	^self isPublished ifTrue: [self lastPublishedRelease version]! !!SMPackage methodsFor: 'private' stamp: 'gh 11/28/2002 21:25' prior: 28891245!delete	"Delete me. Delete my releases."	super delete.	self deleteReleases! !!SMPackage methodsFor: 'private' stamp: 'gk 10/20/2005 00:17' prior: 28891390!deleteReleases	"Delete my releases."	releases copy do: [:release | release delete]! !!SMPackage methodsFor: 'cache' stamp: 'gk 3/8/2004 19:56' prior: 28878052!download	"Force download into cache."	self isReleased ifFalse: [self error: 'There is no release for this package to download.'].	^self lastRelease download! !!SMPackage methodsFor: 'cache' stamp: 'gk 7/16/2004 11:01' prior: 28878277!ensureInCache	"Makes sure all release files are in the cache."	self releases do: [:rel | rel ensureInCache ]! !!SMPackage methodsFor: 'services' stamp: 'gk 9/26/2004 23:34' prior: 28881481!firstRelease	"Return the first release."	^releases isEmpty ifTrue: [nil] ifFalse: [releases first]! !!SMPackage methodsFor: 'accessing' stamp: 'dew 10/23/2006 19:08' prior: 28874350!fullDescription	"Return a full textual description of the package. 	Most of the description is taken from the last release."	| s publishedRelease sqDescription |	s := TextStream on: (Text new: 400).	self		describe: name		withBoldLabel: 'Name:		'		on: s.	summary isEmptyOrNil		ifFalse: [self				describe: summary				withBoldLabel: 'Summary:	'				on: s ].	author isEmptyOrNil		ifFalse: [s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Author:'];				 tab;				 tab.			s				withAttribute: (PluggableTextAttribute						evalBlock: [self userInterface										sendMailTo: (SMUtilities stripEmailFrom: author)										regardingPackageRelease: self lastRelease])				do: [s nextPutAll: author];				 cr].	self owner		ifNotNil: [s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Owner:'];				 tab; tab.			s				withAttribute: (PluggableTextAttribute						evalBlock: [self userInterface										sendMailTo: self owner email										regardingPackageRelease: self lastRelease])				do: [s nextPutAll: self owner nameAndEmail];					 cr].	self maintainers isEmpty ifFalse: [		s withAttribute: TextEmphasis bold do: [s nextPutAll: 'Co-Maintainers:']; tab.		self maintainers do: [:com |			com = self maintainers first ifFalse: [s nextPutAll: ', '].			s				withAttribute:					(PluggableTextAttribute						evalBlock: [self userInterface									sendMailTo: com email									regardingPackageRelease: self lastRelease])				do: [s nextPutAll: com nameAndEmail]].				s cr].	description isEmptyOrNil		ifFalse: [sqDescription := description withSqueakLineEndings.			s cr.			s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Description:'].			s cr.			s				withAttribute: (TextIndent tabs: 1)				do: [s next: (sqDescription findLast: [ :c | c isSeparator not ]) putAll: sqDescription].			s cr ].	self describeCategoriesOn: s indent: 1.	s cr.	publishedRelease := self lastPublishedRelease.	self		describe: (self publishedVersion ifNil: ['<not published>'])		withBoldLabel: 'Published Version: '		on: s.	self isPublished ifTrue: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Created: ' ];			print: publishedRelease created;			cr.			self note isEmptyOrNil				ifFalse: [s					withAttribute: TextEmphasis bold					do: [s nextPutAll: 'Release Note:'].			s cr.			s				withAttribute: (TextIndent tabs: 1)				do: [s nextPutAll: publishedRelease note withSqueakLineEndings].			s cr ]].	url isEmptyOrNil		ifFalse: [s cr;				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Homepage: '];				withAttribute: (TextURL new url: url)				do: [s nextPutAll: url];				 cr].	packageInfoName isEmptyOrNil		ifFalse: [self				describe: packageInfoName				withBoldLabel: 'Package Info: '				on: s ].	^ s contents! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:10' prior: 28888263!getCoEditLink: aBuilder	"Return a link for using on the web.	Relative to the current view."	^self getCoEditLink: aBuilder view: aBuilder view! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:09' prior: 28888473!getCoEditLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLink: 'copackage/', id asString, '/edit' text: 'edit' view: aView! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:11' prior: 28888693!getCoEditReleasesLink: aBuilder	"Return a link for using on the web.	Relative to the current view."	^self getCoEditReleasesLink: aBuilder view: aBuilder view! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:11' prior: 28888919!getCoEditReleasesLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLink: 'copackage/', id asString, '/editreleases' text: 'edit releases' view: aView! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:06' prior: 28889164!getCoLink: aBuilder	"Return a link for using on the web.	Relative to the current view."	^self getCoLink: aBuilder view: aBuilder view! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:06' prior: 28889366!getCoLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLink: 'copackage/', id asString text: name view: aView! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:13' prior: 28889571!getEditLink: aBuilder	"Return a link for using on the web.	Relative to the current view."	^self getEditLink: aBuilder view: aBuilder view! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:13' prior: 28889777!getEditLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLink: 'package/', id asString, '/edit' text: 'edit' view: aView! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:13' prior: 28889993!getEditReleasesLink: aBuilder	"Return a link for using on the web.	Relative to the current view."	^self getEditReleasesLink: aBuilder view: aBuilder view! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:13' prior: 28890215!getEditReleasesLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLink: 'package/', id asString, '/editreleases' text: 'edit releases' view: aView! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 12:24' prior: 28890456!getLink: aBuilder	"Return a link for using on the web.	Relative to the current view."	^self getLink: aBuilder view: aBuilder view! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 12:19' prior: 28890654!getLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLink: 'package/', id asString text: name view: aView! !!SMPackage methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 28878759!initialize	"Initialize package."	super initialize.	packageInfoName := ''.	releases := OrderedCollection new! !!SMPackage methodsFor: 'installation' stamp: 'gk 7/14/2004 17:32' prior: 28878944!install	"Install the latest newer published version for this version of Squeak."	^map installPackage: self! !!SMPackage methodsFor: 'installation' stamp: 'gk 11/17/2003 02:27' prior: 28879126!installedRelease	"Return the installed release.	We ask the map. Return nil if this package is not installed."	^map installedReleaseOf: self! !!SMPackage methodsFor: 'printing' stamp: 'gk 11/17/2003 10:14' prior: 28881133!installedVersion	"Return the version String for the installed version.	We ask the map. Return nil if this package is not installed."	^self installedRelease ifNotNilDo: [:r | r smartVersion]! !!SMPackage methodsFor: 'testing' stamp: 'gk 7/13/2004 15:11' prior: 28884837!isAvailable	"Answer if I am old or not installed regardless of	if there is installer support for me. It also does	not care if the newer release is not published	or no for this Squeak version."	^self isOld or: [self isInstalled not]! !!SMPackage methodsFor: 'testing' stamp: 'gk 7/13/2004 14:55' prior: 28885141!isCached	"Is the last release corresponding to me in the local file cache?	NOTE: This doesn't honour #published nor if the release is	intended for the current Squeak version."	^self isReleased and: [self lastRelease isCached]! !!SMPackage methodsFor: 'testing' stamp: 'gk 7/15/2004 17:21' prior: 28885438!isInstallable	"Answer if any of my releases can be installed."	^ releases anySatisfy: [:rel | rel isInstallable]! !!SMPackage methodsFor: 'testing' stamp: 'gh 10/25/2002 11:08' prior: 28885621!isInstallableAndNotInstalled	"Answer if there is any installer that	can install me and I am not yet installed."	^self isInstallable and: [self isInstalled not]! !!SMPackage methodsFor: 'testing' stamp: 'gk 11/17/2003 11:02' prior: 28885852!isInstalled	"Answer if any version of me is installed."	^(map installedReleaseOf: self) notNil! !!SMPackage methodsFor: 'testing' stamp: 'gk 7/13/2004 15:10' prior: 28886016!isOld	"Answer if I am installed and there also is a	newer version available *regardless* if it is	not published or not for this Squeak version.	This is for people who want to experiment!!"	| installed |	installed := map installedReleaseOf: self.	^installed		ifNil: [false]		ifNotNil: [			self releases anySatisfy: [:r |				r newerThan: installed ]]! !!SMPackage methodsFor: 'testing' stamp: 'gh 12/1/2002 19:40' prior: 28886443!isPackage	^true! !!SMPackage methodsFor: 'testing' stamp: 'gk 9/23/2003 21:35' prior: 28886526!isPublished	"Answer if I have public releases."	^releases anySatisfy: [:rel | rel isPublished]! !!SMPackage methodsFor: 'testing' stamp: 'btr 11/20/2003 00:05' prior: 28886692!isReleased	^ releases isEmpty not! !!SMPackage methodsFor: 'testing' stamp: 'gk 7/13/2004 15:37' prior: 28886793!isSafeToInstall	"Answer if I am NOT installed and there also is a	published version for this version of Squeak available."	^self isInstalled not and: [		self lastPublishedReleaseForCurrentSystemVersion notNil]! !!SMPackage methodsFor: 'testing' stamp: 'gk 7/14/2004 16:15' prior: 28887074!isSafelyAvailable	"Answer if I am old or not installed regardless of	if there is installer support for me. The	newer release should be published	and meant for this Squeak version."	^self isSafeToInstall or: [self isSafelyOld]! !!SMPackage methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28887384!isSafelyOld	"Answer if I am installed and there also is a	newer published version for this version of Squeak available."	| installed |	installed := self installedRelease.	^installed ifNil: [false] ifNotNil: [		^(self lastPublishedReleaseForCurrentSystemVersionNewerThan: installed) notNil]! !!SMPackage methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28887759!isSafelyOldAndUpgradeable	"Answer if I am installed and there also is a	newer published version for this version of Squeak available	that can be upgraded to (installer support)."	| installed newRelease |	installed := self installedRelease.	^installed ifNil: [false] ifNotNil: [		newRelease := self lastPublishedReleaseForCurrentSystemVersionNewerThan: installed.		^newRelease ifNil: [false] ifNotNil: [newRelease isUpgradeable]]! !!SMPackage methodsFor: 'services' stamp: 'gk 2/16/2004 20:14' prior: 28881650!lastPublishedRelease	"Return the latest published release."	^releases isEmpty ifTrue: [nil] ifFalse: [		releases reversed detect: [:r | r isPublished] ifNone:[nil]]! !!SMPackage methodsFor: 'services' stamp: 'gk 7/13/2004 13:28' prior: 28881886!lastPublishedReleaseForCurrentSystemVersion	"Return the latest published release marked	as compatible with the current SystemVersion."	^releases isEmpty ifTrue: [nil] ifFalse: [		releases reversed detect: [:r |			r isPublished and: [r isCompatibleWithCurrentSystemVersion]]				ifNone:[nil]]! !!SMPackage methodsFor: 'services' stamp: 'gk 7/14/2004 17:15' prior: 28882251!lastPublishedReleaseForCurrentSystemVersionNewerThan: aRelease	"Return the latest published release marked	as compatible with the current SystemVersion	that is newer than the given release."	^releases isEmpty ifTrue: [nil] ifFalse: [		releases reversed detect: [:r |			(r isPublished and: [r newerThan: aRelease])				and: [r isCompatibleWithCurrentSystemVersion]]				 	ifNone:[nil]]! !!SMPackage methodsFor: 'services' stamp: 'gk 8/4/2003 11:49' prior: 28882709!lastRelease	"Return the latest release."	^releases isEmpty ifTrue: [nil] ifFalse: [releases last]! !!SMPackage methodsFor: 'accessing' stamp: 'gk 1/25/2004 16:23' prior: 28877028!maintainer	"Deprecated"	^self owner! !!SMPackage methodsFor: 'deprecated' stamp: 'btr 11/20/2003 00:38' prior: 28878461!modulePath: p moduleVersion: v moduleTag: t versionComment: vc	"Deprecated. Only kept for migration from SM 1.0x.	Method used when recreating from storeOn: format."	self isReleased ifTrue: [self lastRelease note: vc]! !!SMPackage methodsFor: 'installation' stamp: 'gk 11/18/2003 02:14' prior: 28879342!nameWithVersionLabel	^name, ' (', self versionLabel, ')'! !!SMPackage methodsFor: 'private' stamp: 'gk 12/7/2005 14:15' prior: 28891542!newChildReleaseFrom: aRelease	"Create a new release."	^self addRelease: (map newObject: (SMPackageRelease newFromRelease: aRelease package: self))! !!SMPackage methodsFor: 'private' stamp: 'gk 12/7/2005 14:07' prior: 28891758!newRelease	"Create a new release. Just use the last	chronological release as parent, if this is the first release	that is nil."	^self newChildReleaseFrom: self lastRelease! !!SMPackage methodsFor: 'accessing' stamp: 'gk 7/12/2004 17:15' prior: 28877135!note	^self isPublished ifTrue: [self lastPublishedRelease note]! !!SMPackage methodsFor: 'accessing' stamp: 'gk 11/6/2003 15:24' prior: 28877268!packageInfoName	^packageInfoName! !!SMPackage methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28877382!packageInfoName: aString	packageInfoName := aString! !!SMPackage methodsFor: 'services' stamp: 'gk 5/5/2006 02:07' prior: 28882876!parentReleaseFor: aPackageRelease	"If there is none (the given release is automaticVersion '1'), return nil."	| previousVersion |	previousVersion := aPackageRelease automaticVersion previous.	^releases detect: [:r | r automaticVersion = previousVersion] ifNone: [nil]! !!SMPackage methodsFor: 'services' stamp: 'gh 11/27/2002 12:33' prior: 28883217!previousReleaseFor: aPackageRelease	"If there is none, return nil."		^releases before: aPackageRelease ifAbsent: [nil]! !!SMPackage methodsFor: 'accessing' stamp: 'gk 7/12/2004 17:13' prior: 28877503!publishedVersion	^self isPublished ifTrue: [self lastPublishedRelease version]! !!SMPackage methodsFor: 'services' stamp: 'gk 11/18/2003 17:39' prior: 28883407!releaseWithAutomaticVersion: aVersion	"Look up a specific package release of mine. Return nil if missing.	They are few so we just do a #select:."	^releases detect: [:rel | rel automaticVersion = aVersion ] ifNone: [nil]! !!SMPackage methodsFor: 'services' stamp: 'gk 11/18/2003 17:39' prior: 28883699!releaseWithAutomaticVersionString: aVersionString	"Look up a specific package release of mine. Return nil if missing.	They are few so we just do a #select:."	^self releaseWithAutomaticVersion: aVersionString asVersion! !!SMPackage methodsFor: 'services' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28884000!releaseWithId: anIdString 	"Look up a specific package release of mine. Return nil if missing.	They are few so we just do a #select:."	| anId |	anId := UUID fromString: anIdString.	releases detect: [:rel | rel id = anId ].	^nil! !!SMPackage methodsFor: 'services' stamp: 'gk 11/18/2003 17:41' prior: 28884303!releaseWithVersion: aVersionString	"Look up a specific package release of mine. Return nil if missing.	They are few so we just do a #select:."	^releases detect: [:rel | rel version = aVersionString ] ifNone: [nil]! !!SMPackage methodsFor: 'accessing' stamp: 'gh 12/1/2002 21:21' prior: 28877651!releases	^releases! !!SMPackage methodsFor: 'private' stamp: 'gh 11/28/2002 21:33' prior: 28892002!removeRelease: aRelease	"Remove the release."	releases remove: aRelease! !!SMPackage methodsFor: 'accessing' stamp: 'gk 10/12/2005 23:28' prior: 28877740!repository	^repository! !!SMPackage methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 28877831!repository: aString	repository := aString! !!SMPackage methodsFor: 'services' stamp: 'gk 7/13/2004 14:37' prior: 28884588!smartVersion	"Delegate to last published release for this SystemVersion."	| r |	r := self lastPublishedReleaseForCurrentSystemVersion.	^r ifNotNil: [r smartVersion] ifNil: ['']! !!SMPackage methodsFor: 'printing' stamp: 'gk 11/14/2003 00:12' prior: 28881395!type	^'Package'! !!SMPackage methodsFor: 'installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28879483!upgrade	"Upgrade to the latest newer published version for this version of Squeak."	| installed |	installed := self installedRelease.	installed		ifNil: [self error: 'No release installed, can not upgrade.']		ifNotNil: [^installed upgrade]! !!SMPackage methodsFor: 'installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28879812!upgradeOrInstall	"Upgrade to or install the latest newer published version for this version of Squeak."	| installed |	installed := self installedRelease.	installed		ifNil: [^self install]		ifNotNil: [^installed upgrade]! !!SMPackage methodsFor: 'installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28880122!versionLabel	"Return a label indicating installed and available version as:		'1.0'      = 1.0 is installed and no new published version for this version of Squeak is available		'1.0->1.1' = 1.0 is installed and 1.1 is published for this version of Squeak		'->1.1'    = No version is installed and 1.1 is published for this version of Squeak		'->(1.1)	 = No version is installed and there is only a non published version available for this version of Squeak	The version showed is the one that #smartVersion returns.	If a version name is in parenthesis it is not published."	| installedVersion r r2 |	r := self installedRelease.	r ifNotNil: [		installedVersion := r smartVersion.		r2 := self lastPublishedReleaseForCurrentSystemVersionNewerThan: r]	ifNil: [		installedVersion := ''.		r2 := self lastPublishedReleaseForCurrentSystemVersion ].	^r2 ifNil: [installedVersion ] ifNotNil: [installedVersion, '->', r2 smartVersion].! !!SMPackage methodsFor: 'view' stamp: 'gh 3/15/2003 18:05' prior: 28890854!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject packageViewOn: self! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 5/5/2006 02:07' prior: 28864584!addMaintainer: anAccount	"Add anAccount as a maintainer."	maintainers ifNil: [maintainers := OrderedCollection new].	maintainers add: anAccount.	anAccount addCoObject: self! !!SMMaintainableObject methodsFor: 'deletion' stamp: 'gk 7/27/2004 13:27' prior: 28865666!delete	"Disconnect from maintainers."	super delete.	maintainers ifNotNil: [		maintainers copy do: [:m | self removeMaintainer: m]]! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 10/12/2005 23:25' prior: 28864844!feedbackEmail	^feedbackEmail! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 5/5/2006 02:07' prior: 28864954!feedbackEmail: anEmail	feedbackEmail := anEmail! !!SMMaintainableObject methodsFor: 'testing' stamp: 'gk 7/27/2004 13:26' prior: 28865880!isOwnerOrMaintainer: anAccount	^ owner = anAccount or: [self maintainers includes: anAccount]! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 7/27/2004 13:26' prior: 28865084!maintainers	"Return all maintainers."	^maintainers ifNil: [#()]! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 7/27/2004 13:26' prior: 28865232!removeMaintainer: anAccount	"Remove anAccount as a maintainer."	maintainers ifNil: [^self].	maintainers remove: anAccount.	anAccount removeCoObject: self! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 7/27/2004 13:26' prior: 28865472!rss	^rss! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 5/5/2006 02:07' prior: 28865562!rss: anUrl	rss := anUrl! !!SMPersonalObject methodsFor: 'deletion' stamp: 'gk 10/20/2005 00:12' prior: 28917225!delete	"Disconnect from owner."	super delete.	owner removeObject: self! !!SMPersonalObject methodsFor: 'accessing' stamp: 'gk 8/7/2003 20:56' prior: 28917011!owner	^owner! !!SMPersonalObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28917112!owner: anAccount	owner := anAccount! !!SMResource commentStamp: '<historical>' prior: 28918795!A resource is a document that is NOT a package. Thus, it is used for all the things interesting to register on SM that aren't packages. The are three major differences with resources:- A resource keeps no track of version history like packages do with package releases. It only has a field for the current version.- A resource can be embedded inside the map instead of being a document reached by a URL.- A resource can be associated with another SMObject, the instvar object.However, resources respond to some of the same actions as PackageReleases.!!SMEmbeddedResource commentStamp: '<historical>' prior: 28796698!An embedded resource is a resource that is stored inside the map. No download is needed.This means that embedded resources should be "small" and typically only be used for information thatis needed to be available at all times without downloading. A typical example is meta data for other SMObjects.!!SMEmbeddedResource methodsFor: 'services' stamp: 'gk 3/8/2004 19:58' prior: 28797077!download	"A dummy method to respond as other resources would."	^true! !!SMEmbeddedResource methodsFor: 'services' stamp: 'gk 7/16/2004 11:03' prior: 28797225!ensureInCache	"Makes sure the file is in the cache.	An embedded resource doesn't have a file."	^true! !!SMEmbeddedResource methodsFor: 'testing' stamp: 'gk 8/12/2003 17:10' prior: 28797406!isCached	"Is the file corresponding to me in the local file cache?	Well consider it as true since I am embedded in the map."	^true! !!SMEmbeddedResource methodsFor: 'testing' stamp: 'gk 7/27/2004 14:31' prior: 28797616!isEmbedded	^ true! !!SMGenericEmbeddedResource commentStamp: 'gk 10/12/2005 23:01' prior: 28806551!A generic embedded resource is simply some kind of object, held in instvar #contents, that is stored inside the map. No download is needed.Embedded resources should be "small" and typically only be used for resources thatare needed to be available at all times without downloading. A typical example is meta data for other SMObjects.!!SMGenericEmbeddedResource methodsFor: 'as yet unclassified' stamp: 'gk 10/12/2005 23:00' prior: 28806983!contents	"Answers the contents object."	^contents! !!SMGenericEmbeddedResource methodsFor: 'as yet unclassified' stamp: 'gk 5/5/2006 02:07' prior: 28807129!contents: obj	"Sets the actual contents of this resource.	SM does not know what it is."		contents := obj! !!SMKabunguHint methodsFor: 'as yet unclassified' stamp: 'gk 10/12/2005 20:47' prior: 28828342!account		^ self owner! !!SMKabunguHint methodsFor: 'as yet unclassified' stamp: 'mist 8/22/2005 23:52' prior: 28828450!type	^ type! !!SMKabunguHint methodsFor: 'as yet unclassified' stamp: 'gk 5/5/2006 02:07' prior: 28828545!type: t	type := t! !!SMPackageReleaseConfiguration commentStamp: '<historical>' prior: 28911465!A package release configuration describes the result of testing the specific release with a set of other releases that it depends on.The status instvar holds a symbol which reflects the result. Currently there are two valid values:	#working	#failing	The intention is that users and maintainers post these configurations to the map as "known working combinations of required releases".Each SMPackageRelease can then have multiple of these configurations.!!SMPackageReleaseConfiguration methodsFor: 'dependencies' stamp: 'gk 5/5/2006 02:07' prior: 28912014!addRequiredRelease: aRelease	"Add <aRelease> as a required release. The release added	can not indirectly refer back to this release."		(self isCircular: aRelease) ifTrue: [self error: 'Circular dependencies not allowed.'].	requiredReleases := requiredReleases copyWith: aRelease.	^aRelease! !!SMPackageReleaseConfiguration methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 28912648!initialize	super initialize.	requiredReleases := #().	status := #working! !!SMPackageReleaseConfiguration methodsFor: 'private' stamp: 'gk 9/25/2004 00:22' prior: 28912811!isCircular: aRelease	"Answer if there is a reference that goes back	to the release of this configuration."	"This is the base case"	aRelease == object ifTrue: [^ true].		aRelease configurations do: [:conf |		conf requiredReleases do: [:rel |			(self isCircular: rel) ifTrue: [^ true]]].	^false! !!SMPackageReleaseConfiguration methodsFor: 'testing' stamp: 'gk 7/27/2004 14:29' prior: 28913201!isConfiguration	^true! !!SMPackageReleaseConfiguration methodsFor: 'testing' stamp: 'gk 7/27/2004 18:23' prior: 28913310!isFailing	^status == #failing! !!SMPackageReleaseConfiguration methodsFor: 'testing' stamp: 'gk 7/27/2004 14:56' prior: 28913427!isFulfilled	"Are all my required releases already installed?"		^requiredReleases allSatisfy: [:r | r isInstalled ]! !!SMPackageReleaseConfiguration methodsFor: 'testing' stamp: 'gk 7/27/2004 18:23' prior: 28913631!isWorking	^status == #working! !!SMPackageReleaseConfiguration methodsFor: 'printing' stamp: 'gk 7/28/2004 11:43' prior: 28913750!printOn: aStream	aStream nextPutAll: 'Cfg['.	requiredReleases do: [:r |		aStream nextPutAll: r printString; space].	aStream nextPutAll: ']'! !!SMPackageReleaseConfiguration methodsFor: 'dependencies' stamp: 'gk 5/5/2006 02:07' prior: 28912400!removeRequiredRelease: aRelease	"Remove <aRelease> as a required release."		requiredReleases := requiredReleases copyWithout: aRelease.	^ aRelease! !!SMPackageReleaseConfiguration methodsFor: 'accessing' stamp: 'gk 7/27/2004 14:22' prior: 28913984!requiredReleases	^ requiredReleases! !!SMPackageReleaseConfiguration methodsFor: 'accessing' stamp: 'gk 7/27/2004 14:22' prior: 28914109!status	^ status! !!SMExternalResource commentStamp: 'gk 3/8/2004 20:09' prior: 28797855!An external resource is a downloadable resource.The instance variable downloadUrl holds the URL to the resource and the resource is cacheable in the FileCache for the SqueakMap.An external resource can be used for any kind of document that is to be attached to another SMObject.!!SMExternalResource methodsFor: 'accessing' stamp: 'btr 5/28/2003 04:13' prior: 28798213!cacheDirectory	^ map cache directoryForResource: self! !!SMExternalResource methodsFor: 'accessing' stamp: 'gk 4/19/2006 01:32' prior: 28798345!contents	"Return the contents of a stream from the downloaded resource.	Not yet tested, this resource returns the stream and not its contents."	map cache add: self.	^(self cacheDirectory readOnlyFileNamed: self downloadFileName) binary; yourself! !!SMExternalResource methodsFor: 'services' stamp: 'gk 8/13/2003 15:42' prior: 28799340!download	"Force a download into the cache regardless if it is already there."	^map cache download: self! !!SMExternalResource methodsFor: 'accessing' stamp: 'btr 5/28/2003 04:13' prior: 28798674!downloadFileName	"Cut out the filename from the url."	downloadUrl isEmpty ifTrue: [^nil].	^downloadUrl asUrl path last! !!SMExternalResource methodsFor: 'accessing' stamp: 'btr 5/28/2003 04:14' prior: 28798875!downloadUrl	^ downloadUrl! !!SMExternalResource methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28798991!downloadUrl: anUrl	downloadUrl := anUrl! !!SMExternalResource methodsFor: 'services' stamp: 'gk 8/13/2003 15:54' prior: 28799523!ensureInCache	"Makes sure the file is in the cache."	^map cache add: self! !!SMExternalResource methodsFor: 'testing' stamp: 'gk 8/13/2003 15:32' prior: 28799676!isCached	"Is the file corresponding to me in the local file cache?"	^map cache includes: self! !!SMExternalResource methodsFor: 'accessing' stamp: 'gk 7/16/2004 11:09' prior: 28799109!isDownloadable	"Answer if I can be downloaded.	We simply verify that the download url	ends with a filename."	^self downloadFileName isEmptyOrNil not! !!SMResource class methodsFor: 'instance creation' stamp: 'btr 5/28/2003 04:31' prior: 28920234!forString: aString	^ SMEmbeddedResource new content: aString! !!SMResource class methodsFor: 'instance creation' stamp: 'btr 5/28/2003 04:30' prior: 28920380!forUrl: anUrl	^ SMExternalResource new downloadUrl: anUrl; yourself! !!SMResource methodsFor: 'testing' stamp: 'gk 7/27/2004 14:30' prior: 28919847!isConfiguration	^ false! !!SMResource methodsFor: 'testing' stamp: 'gk 7/27/2004 14:31' prior: 28919939!isEmbedded	^false! !!SMResource methodsFor: 'testing' stamp: 'btr 5/28/2003 04:25' prior: 28920026!isResource	^ true! !!SMResource methodsFor: 'accessing' stamp: 'gk 7/27/2004 13:12' prior: 28919420!object	^object! !!SMResource methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 28919504!object: anSMCategorizableObject	object := anSMCategorizableObject! !!SMResource methodsFor: 'accessing' stamp: 'gk 9/23/2003 21:55' prior: 28919640!version	^ version! !!SMResource methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28919740!version: aVersion	version := aVersion! !!SMCategory commentStamp: 'gk 3/8/2004 19:44' prior: 28755467!An SMCategory is a "tag" that can be attached to SMCategorizableObjects in order to classify them.The SMCategories are arranged in a strict hierarchy and each SMCategory both knows it's parent and it's subcategories.The instvar objects holds all SMObjects belonging to this category.Instvars name and summary are already inherited from SMObject and describe the category.The instvar url can be used to refer to a web page that can explain the category in more detail, typically a page at the Squeak Swiki.SMCategory adds an instance variable called mandatory holding a Set with the classes (SMPackage, SMPackageRelease, SMAccount, SMResource etc) that must belong to at least one subcategory of this SMCategory. Obviously not many categories will be mandatory for each class.The category tree is maintained by a few trusted people so that chaos will not reign. :-)!!SMCategory methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28760250!addCategory: cat	"Add a category as a subcategory to self.	The collection of subcategories is lazily instantiated."	subCategories ifNil: [subCategories := OrderedCollection new].	cat parent ifNotNil: [cat parent removeCategory: cat ].	subCategories add: cat.	cat parent: self.	^cat! !!SMCategory methodsFor: 'private' stamp: 'gk 9/23/2003 21:59' prior: 28760607!addObject: anObject	"Add <anObject> to this category. This should only be called	from SMCategorizableObject>>addCategory: to ensure consistency."		(objects includes: anObject) ifFalse:[objects add: anObject]! !!SMCategory methodsFor: 'services' stamp: 'gk 11/17/2003 10:48' prior: 28758059!allCategoriesDo: aBlock	"Evaluate <aBlock> for all categories below me including me,	bottom up breadth-first."	self allSubCategoriesDo: aBlock.	aBlock value: self! !!SMCategory methodsFor: 'services' stamp: 'gk 7/9/2004 02:59' prior: 28758294!allSubCategoriesDo: aBlock	"Evaluate <aBlock> for all categories below me NOT including me,	bottom up breadth-first."	subCategories ifNil: [^self].	subCategories do: [:sub |		sub allSubCategoriesDo: aBlock.		aBlock value: sub]! !!SMCategory methodsFor: 'services' stamp: 'gh 8/5/2002 17:10' prior: 28758595!categoryBefore	"Return the category listed before me in my parent.	If I am first or I have no parent, return nil."	parent isNil ifTrue:[^nil].	parent subCategories first = self ifTrue:[^nil].	^parent subCategories before: self	! !!SMCategory methodsFor: 'private' stamp: 'gk 11/24/2005 11:37' prior: 28760887!delete	"Delete me. Disconnect me from my objects and my parent.	Then delete my subcategories."	super delete.	self removeFromObjects; removeFromParent.	self subCategories do: [:c | c delete ]! !!SMCategory methodsFor: 'view' stamp: 'gk 10/12/2005 12:24' prior: 28759840!getLink: aBuilder	"Return a link for using on the web.	Always from the top."	^aBuilder getLinkTop: 'category/', id asString text: name! !!SMCategory methodsFor: 'testing' stamp: 'gh 12/1/2002 20:24' prior: 28759383!hasSubCategories	^subCategories isEmptyOrNil not! !!SMCategory methodsFor: 'testing' stamp: 'gk 8/7/2003 22:31' prior: 28759499!includes: anObject	"Answer if <anObject> is in this category."	^objects includes: anObject! !!SMCategory methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28757352!initialize	super initialize.	name := summary := url := ''.	objects := OrderedCollection new! !!SMCategory methodsFor: 'testing' stamp: 'gh 12/1/2002 19:51' prior: 28759660!isCategory	^true! !!SMCategory methodsFor: 'testing' stamp: 'gh 6/27/2002 13:31' prior: 28759745!isTopCategory	^parent isNil! !!SMCategory methodsFor: 'accessing' stamp: 'gk 11/17/2003 13:51' prior: 28756410!mandatory	^mandatory! !!SMCategory methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28756513!mandatory: aSet	mandatory := aSet! !!SMCategory methodsFor: 'accessing' stamp: 'gk 11/17/2003 21:35' prior: 28756618!mandatoryFor: aClass	"Is this category mandatory for instances of <aClass>?"	^mandatory ifNil: [false] ifNotNil: [mandatory includes: aClass]! !!SMCategory methodsFor: 'services' stamp: 'gh 8/5/2002 14:36' prior: 28758897!move: cat toAfter: before	"Move a category to be after the category <before>."	subCategories remove: cat.	before ifNil: [subCategories addFirst: cat] ifNotNil: [subCategories add: cat after: before]! !!SMCategory methodsFor: 'accessing' stamp: 'gh 8/1/2002 16:54' prior: 28756831!objects	"Return all objects in this category."	^objects! !!SMCategory methodsFor: 'accessing' stamp: 'gk 8/7/2003 23:42' prior: 28756958!packages	"Return all packages in this category."	^objects select: [:p | p isPackage]! !!SMCategory methodsFor: 'accessing' stamp: 'gh 6/27/2002 16:01' prior: 28757115!parent	^parent! !!SMCategory methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28761163!parent: aCategory	"Change the parent category.	This method relies on that somebody else	updates the parent's subCategories collection."		parent := aCategory! !!SMCategory methodsFor: 'services' stamp: 'gh 8/1/2002 17:30' prior: 28759167!parentsDo: aBlock	"Run a block for all my parents starting from the top."	parent ifNotNil: [		parent parentsDo: aBlock.		aBlock value: parent]! !!SMCategory methodsFor: 'printing' stamp: 'gk 1/29/2004 00:14' prior: 28757516!path	"Return my name with a full path of my	parent names separated with slashes like:		'Squeak versions/Squeak3.5' "	^String streamContents: [:s |		self parentsDo: [:cat |			s nextPutAll: cat name; nextPutAll: '/'].		s nextPutAll: self name]! !!SMCategory methodsFor: 'printing' stamp: 'gh 8/16/2002 06:04' prior: 28757834!printOn: aStream	aStream nextPutAll: self class name, ': ', name! !!SMCategory methodsFor: 'private' stamp: 'gk 11/24/2005 11:34' prior: 28761393!removeDeepFromObjects	"Remove myself from my objects and then ask	my subCategories to do the same."	self removeFromObjects.	subCategories do: [:cat | cat removeDeepFromObjects]! !!SMCategory methodsFor: 'private' stamp: 'gh 12/1/2002 20:03' prior: 28761642!removeFromObjects	"Remove myself from my objects."	objects copy do: [:obj | obj removeCategory: self]! !!SMCategory methodsFor: 'private' stamp: 'gh 12/1/2002 20:28' prior: 28761814!removeFromParent	"Remove me from my parent."	parent ifNotNil: [parent removeCategory: self]! !!SMCategory methodsFor: 'private' stamp: 'gh 12/1/2002 20:28' prior: 28761976!removeObject: anObject	"Remove <anObject> from this category. This should only be called	from SMCategorizableObject>>removeCategory: to ensure consistency."		^objects remove: anObject! !!SMCategory methodsFor: 'accessing' stamp: 'gh 6/27/2002 12:25' prior: 28757200!subCategories	subCategories ifNil: [^#()].	^subCategories! !!SMCategory methodsFor: 'printing' stamp: 'gk 11/14/2003 00:13' prior: 28757970!type	^'Category'! !!SMCategory methodsFor: 'view' stamp: 'gh 8/1/2002 16:38' prior: 28760042!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject categoryViewOn: self! !!SMObject class methodsFor: 'instance creation' stamp: 'gk 12/7/2005 13:53' prior: 28873374!newIn: aMap	"Create a new object in a given map with an UUID to ensure unique identity."	^(super basicNew) map: aMap id: UUID new! !!SMObject methodsFor: 'comparing' stamp: 'gk 9/22/2004 23:21' prior: 28873149!<= anSMObject	^name <= anSMObject name! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/16/2002 23:12' prior: 28869382!created	^TimeStamp fromSeconds: created! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28869502!created: c	created := c! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/16/2002 23:12' prior: 28869594!createdAsSeconds	^created! !!SMObject methodsFor: 'deletion' stamp: 'gk 8/8/2003 10:10' prior: 28871079!delete	"Delete from map."	map deleteObject: self! !!SMObject methodsFor: 'printing' stamp: 'gk 11/14/2003 14:22' prior: 28871593!describe: string withBoldLabel: label on: stream	"Helper method for doing styled text."	stream withAttribute: (TextEmphasis bold) do: [ stream nextPutAll: label ].	stream nextPutAll: string; cr! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/16/2002 23:12' prior: 28869688!id	^id! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28869775!id: anId	id := anId! !!SMObject methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28871220!initialize	"Initialize the receiver."	updated := created := TimeStamp current asSeconds.	name := summary := url := ''.! !!SMObject methodsFor: 'testing' stamp: 'gk 6/26/2003 16:47' prior: 28872243!isAccount	^false! !!SMObject methodsFor: 'testing' stamp: 'gh 12/1/2002 19:51' prior: 28872326!isCategory	^false! !!SMObject methodsFor: 'testing' stamp: 'gh 12/1/2002 19:40' prior: 28872410!isPackage	^false! !!SMObject methodsFor: 'testing' stamp: 'gh 12/1/2002 19:51' prior: 28872493!isPackageRelease	^false! !!SMObject methodsFor: 'testing' stamp: 'gh 12/1/2002 19:51' prior: 28872583!isResource	^false! !!SMObject methodsFor: 'accessing' stamp: 'gh 8/15/2002 08:50' prior: 28869863!map	^map! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28869952!map: aMap	map := aMap! !!SMObject methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28871431!map: aMap id: anId	"Initialize the receiver."	self initialize.	map := aMap.	id := anId! !!SMObject methodsFor: 'accessing' stamp: 'gh 6/26/2002 15:31' prior: 28870042!name	^name! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28870133!name: aName	name := aName! !!SMObject methodsFor: 'printing' stamp: 'gk 7/10/2004 03:39' prior: 28871857!printName	"Return a String identifying receiver without a context.	Default is name."	^self name! !!SMObject methodsFor: 'printing' stamp: 'gk 8/4/2003 11:56' prior: 28872022!printOn: aStream	aStream nextPutAll: self class name, '[', name, ']'! !!SMObject methodsFor: 'updating' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28872682!stampAsUpdated	"This method should be called whenever the object is modified."	updated := TimeStamp current asSeconds! !!SMObject methodsFor: 'accessing' stamp: 'gh 6/26/2002 15:33' prior: 28870227!summary	^summary! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28870324!summary: aString	summary := aString! !!SMObject methodsFor: 'printing' stamp: 'gk 11/14/2003 00:11' prior: 28872160!type	^'Object'! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:44' prior: 28870428!updated	^TimeStamp fromSeconds: updated! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28870548!updated: c	updated := c! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:45' prior: 28870640!updatedAsSeconds	^updated! !!SMObject methodsFor: 'accessing' stamp: 'gh 6/26/2002 15:36' prior: 28870734!url	^url! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28870823!url: aString	url := aString! !!SMObject methodsFor: 'accessing' stamp: 'gh 11/27/2002 12:21' prior: 28870920!userInterface	"Return the object that we use for interacting with the user."	^SMUtilities! !!SMObject methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 28872869!withId: aUUIDString in: aCollection	"Return the object with the corresponding id	and nil if not found."	| uuid |	uuid := UUID fromString: aUUIDString.	^aCollection detect: [:o | o id = uuid ] ifNone: [nil]! !!SMSqueakMap commentStamp: '<historical>' prior: 28928597!SqueakMap is a Squeak meta catalog, primarily a catalog of all available Squeak packages.SMSqueakMap is the class for the domain model.One master instance lives on a server on the Internet at map1.squeakfoundation.org (but there are fallback servers too). Then each Squeak connected to the Internet has one instance that is synchronized against the master. This way every user can have an updated catalog of all available Squeak software on the planet locally on their machine. :-)Typically you only need one instance of SMSqueakMap per image and it is held by a singleton class variable reached with "SMSqueakMap default". If it is not there it will then be created together with it's own directory on disk by default the "sm" directory created in your default directory.Synching with the master is the only action that affects the map so you can actually use the same map from multiple images (they will by default use the same snapshot files if the images have the same default directory) and multiple tools (SMLoader, SMBrowser or others).An instance of SMSqueakMap contains instances of SMPackage which which represent Squeak packages and SMCategories which are centrally registered values that can be included as attributes in an SMPackage. An example of such a category would be different kinds of licenses, topic etc. etc.It also contains instances of SMAccount which are registered Squeak developers, the maintainers of the packages.Finally SMSqueakMap also refers to a registry object (SMInstallationRegistry) which records what packages and releases of them have been installed in the image--------------------"Simplest use of SMSqueakMap - this will create a map if you don't have one and open a simple UI""SMLoader openUse these doits to play "hands on" with a SqueakMap."Creating another SqueakMap in directory 'slavemap' instead of default 'sm'"Smalltalk at: #AnotherSqueakMap put: (SMSqueakMap newIn: 'slavemap')"Update the default map by synching it with the master - check Transcript for some numbers."SMSqueakMap default loadUpdates"If the map is broken in some way, reload it from disk"SMSqueakMap default reload"Clear out the contents of the map to save image space, this does not remove the registry."SMSqueakMap default purge!!SMSqueakMap class methodsFor: 'changelog replay' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28974714!askUser	"Ask user about how to handle a replayed installation note	when there is no current SqueakMap in the image."	| choice |	[choice := UIManager default chooseFrom: #('Yes' 'No' 'More info')				title:'There is no SqueakMap in this image,do you wish to create/recreate it? (typical answer is Yes)' .			choice = 3] whileTrue: [self inform:'When packages are installed using SqueakMap a little mark is madein the change log. When an image is reconstructed from the changelogthese marks are intended to keep your map informed about what packagesare installed. You probably already have a map on disk which will automatically bereloaded if you choose ''Yes'', otherwise an new empty map will be created.If you choose ''No'', it will only result in that SqueakMap will not know that this packageis installed in your image.If you are still unsure - answer ''Yes'' since that is probably the best.'].	^choice = 1! !!SMSqueakMap class methodsFor: 'bootstrap upgrade' stamp: 'gk 3/31/2006 01:05' prior: 28974057!bootStrap	"Bootstrap upgrade. Only used when SqueakMap itself is too old to	communicate with the server. This relies on the existence of a package	called SqueakMap that is a .st loadscript. The loadscript needs to do its	own changeset management."	| server url |	server := self findServer.	server ifNotNil: ["Ok, found a SqueakMap server"		url := (('http://', server, '/packagebyname/squeakmap/downloadurl')				asUrl retrieveContents content) asUrl.		(url retrieveContents content unzipped readStream)				fileInAnnouncing: 'Upgrading SqueakMap...']! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28980086!clear	"Clear out the model in the image. This will forget	about what packages are installed and what versions.	The map is itself on disk though and will be reloaded.		If you only want to reload the map and not forget about	installed packages then use 'SMSqueakMap default reload'.	If you want to throw out the map perhaps when shrinking	an image, then use 'SMSqueakMap default purge'."	"SMSqueakMap clear"	DefaultMap := nil! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28980619!default	"Return the default map, create one if missing."	"SMSqueakMap default"	^DefaultMap ifNil: [DefaultMap := self new]! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'gh 10/21/2002 15:05' prior: 28980832!defaultNoCreate	"Return the default map or nil if there is none."	"SMSqueakMap defaultNoCreate"	^DefaultMap! !!SMSqueakMap class methodsFor: 'discarding' stamp: 'gk 7/14/2003 15:04' prior: 28979771!discardSM	"Discard SqueakMapBase. All the map state is kept in	the class var DefaultMap in SMSqueakMap and is thus also removed."	"SMSqueakMap discardSM"	SystemOrganization removeCategoriesMatching: 'SM-domain'.! !!SMSqueakMap class methodsFor: 'server detection' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28982506!findServer	"Go through the list of known master servers, ping 	each one using simple http get on a known 'ping'-url 	until one responds return the server name. 	If some servers are bypassed we write that to Transcript. 	If all servers are down we inform the user and return nil."	| notAnswering deafServers |	Socket initializeNetwork.	notAnswering := OrderedCollection new.	Cursor wait		showWhile: [ServerList				do: [:server | (self pingServer: server)						ifTrue: [notAnswering isEmpty								ifFalse: [deafServers := String												streamContents: [:str | notAnswering														do: [:srvr | str nextPutAll: srvr printString;																 nextPut: Character cr]].									Transcript show: ('These SqueakMap master servers did not respond:\' , deafServers , 'Falling back on ' , server printString , '.') withCRs].							^ server]						ifFalse: [notAnswering add: server]]].	deafServers := String				streamContents: [:str | notAnswering						do: [:srvr | str nextPutAll: srvr printString;								 nextPut: Character cr]].	self error: ('All SqueakMap master servers are down:\' , deafServers , '\ \Can not update SqueakMap...') withCRs.	^ nil! !!SMSqueakMap class methodsFor: 'class initialization' stamp: 'gk 5/5/2006 02:07' prior: 28978943!initialize	"Initialize the list of master servers.	The last one is for debugging/development."	"self initialize"	ServerList := #('map.squeak.org' 'map1.squeakfoundation.org' 'map2.squeakfoundation.org' '127.0.0.1:8080')! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'gh 10/22/2002 17:41' prior: 28981030!new	"Create a new server in a new directory	under the default directory called 'sm'."	^super new initializeOn: 'sm'! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'gh 8/15/2002 07:02' prior: 28981234!newIn: directoryName	"Create a new server in a new directory	under the default directory called <directoryName>."	^super new initializeOn: directoryName! !!SMSqueakMap class methodsFor: 'changelog replay' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28975736!noteInstalledPackage: uuidString version: version	"We are replaying a change that indicates that a package	was just installed. If there is a map we let it record this,	otherwise we ask the user if we should create/recreate the map."	| choice |	DefaultMap		ifNotNil: [DefaultMap noteInstalledPackage: uuidString version: version]		ifNil: [			[choice := UIManager default chooseFrom: #('Yes' 'No' 'More info')				title:'There is no SqueakMap in this image,do you wish to create/recreate it? (typical answer is Yes)' .			choice = 3] whileTrue: [self inform:'When packages are installed using SqueakMap a little mark is madein the change log. When an image is reconstructed from the changelogthese marks are intended to keep your map informed about what packagesare installed. You probably already have a map on disk which will automatically bereloaded if you choose ''Yes'', otherwise an new empty map will be created.If you choose ''No'', it will only result in that SqueakMap will not know that this packageis installed in your image.If you are still unsure - answer ''Yes'' since that is probably the best.'].			choice = 1				ifTrue:[self default noteInstalledPackage: uuidString version: version]]! !!SMSqueakMap class methodsFor: 'changelog replay' stamp: 'gk 7/29/2003 01:01' prior: 28977041!noteInstalledPackage: uuidString version: version atSeconds: sec number: num	"We are replaying a change that indicates that a package	was just installed. If there is a map we let it record this,	otherwise we ask the user if we should create/recreate the map."	DefaultMap		ifNotNil: [DefaultMap noteInstalledPackage: uuidString version: version					atSeconds: sec number: num]		ifNil: [			self askUser				ifTrue:[self default noteInstalledPackage: uuidString version: version							atSeconds: sec number: num]]! !!SMSqueakMap class methodsFor: 'changelog replay' stamp: 'gk 11/17/2003 01:20' prior: 28977646!noteInstalledPackageWithId: uuidString autoVersion: version atSeconds: sec number: num	"We are replaying a change that indicates that a package release	was just installed using SM2. If there is a map we let it record this,	otherwise we ask the user if we should create/recreate the map."	DefaultMap		ifNotNil: [DefaultMap noteInstalledPackageWithId: uuidString autoVersion: version					atSeconds: sec number: num]		ifNil: [			self askUser				ifTrue:[self default noteInstalledPackageWithId: uuidString autoVersion: version							atSeconds: sec number: num]]! !!SMSqueakMap class methodsFor: 'changelog replay' stamp: 'gk 11/17/2003 01:18' prior: 28978299!noteInstalledPackageWithId: uuidString version: version atSeconds: sec number: num	"We are replaying a change that indicates that a package release	was just installed using SM2. If there is a map we let it record this,	otherwise we ask the user if we should create/recreate the map."	DefaultMap		ifNotNil: [DefaultMap noteInstalledPackageWithId: uuidString version: version					atSeconds: sec number: num]		ifNil: [			self askUser				ifTrue:[self default noteInstalledPackageWithId: uuidString version: version							atSeconds: sec number: num]]! !!SMSqueakMap class methodsFor: 'server detection' stamp: 'gk 5/5/2006 02:07' prior: 28983768!pingServer: aServerName	"Check if the SqueakMap server is responding.	For an old image we first make sure the name resolves -	the #httpGet: had such a long timeout (and hanging?)	for resolving the name."	| url answer |	"Only test name lookup first if image is before the network rewrite,	after the rewrite it works."	[(SystemVersion current highestUpdate < 5252)		ifTrue: [NetNameResolver addressForName: (aServerName upTo: $:) timeout: 5].	url := 'http://', aServerName, '/ping'.	answer := HTTPSocket httpGet: url]				on: Error do: [:ex | ^false].	^answer isString not and: [answer contents = 'pong']! !!SMSqueakMap class methodsFor: 'migration' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28981480!recreateInstalledPackagesFromChangeLog	"Clear and recreate the Dictionary with information on installed packages.	NOTE: This takes some time to run and will only find packages installed using SM	and since the last changelog condense.	For packages installed prior to SqueakMap 1.07 there is no timestamp nor counter	logged. These packages will be given the time of the replay and a separate count	(from -10000 upwards) maintaining correct order of installation."	"SMSqueakMap recreateInstalledPackagesFromChangeLog"	| changesFile chunk |	SMSqueakMap default clearInstalledPackages.	changesFile := (SourceFiles at: 2) readOnlyCopy.	[changesFile atEnd]		whileFalse: [			chunk := changesFile nextChunk.			((chunk beginsWith: '"Installed') and: [				(chunk indexOfSubCollection: 'SMSqueakMap noteInstalledPackage:'					startingAt: 10) > 0])				ifTrue: [Compiler evaluate: chunk logged: false]].	changesFile close! !!SMSqueakMap class methodsFor: 'constants' stamp: 'gk 4/4/2006 01:13' prior: 28979245!version	"This is the protocol version number used for clients to decide if	they need to update SMSqueakMap before synching with	the master. In short - only increase this if changes have made	the clients incompatible so that they need to be updated.	2.0: Removed Module stuff and added Package releases.	2.1: Various changes/additions and class shape changes.	2.2: Various 3.9 related fixes and bug fix in segment compression etc."	^'2.2'! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 8/4/2003 11:50' prior: 28956873!accountForEmail: email	"Find account given email."	^self accounts detect: [:a | a email = email] ifNone: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28957067!accountForName: name	"Find account given full name. Disregarding case	and allows up to 2 different characters.	Size must match though, someone else can be smarter -	this is just for migrating accounts properly."	| lowerName size aName |	lowerName := name asLowercase.	size := lowerName size.	^self accounts		detect: [:a |			aName := a name asLowercase.			(aName size = size) and: [| errors |				errors := 0.				aName with: lowerName do: [:c1 :c2 |					c1 ~= c2 ifTrue: [errors := errors + 1]].				errors < 3			]]		ifNone: [nil]		! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 7/30/2003 14:11' prior: 28957684!accountForUsername: username	"Find account given username. The username used	is the developer initials of the account."	^self users at: username ifAbsent: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28957929!accountWithId: anIdString 	"Look up an account. Return nil if missing.	Raise error if it is not an account."	| account |	account := self objectWithId: anIdString.	account ifNil: [^nil].	account isAccount ifTrue:[^account].	self error: 'UUID did not map to a account.'! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 2/7/2004 14:55' prior: 28958272!accountWithName: aName	"Look up an account by name. Return nil if missing."	^self accounts values detect: [:a | a name = aName ] ifNone: [nil]! !!SMSqueakMap methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28930958!accounts	"Lazily maintain a cache of all known account objects."	accounts ifNotNil: [^accounts].	accounts := objects select: [:o | o isAccount].	^accounts! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 12/3/2004 12:03' prior: 28958486!accountsByInitials	"Return the accounts sorted by the developer initials."	^self accounts asSortedCollection: [:x :y | x initials caseInsensitiveLessOrEqual: y initials]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 12/3/2004 12:03' prior: 28958727!accountsByName	"Return the accounts sorted by their name."	^self accounts asSortedCollection: [:x :y | x name caseInsensitiveLessOrEqual: y name].! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gk 11/17/2003 10:30' prior: 28952256!addCategory: category inObject: object	"Add a category in an object."	^object addCategory: category! !!SMSqueakMap methodsFor: 'transactions' stamp: 'gk 10/10/2003 11:30' prior: 28963375!addDirty: anSMObject	"Add the SMObject to the dirty list making	sure it gets committed when transaction ends.""In first SM2 version we do nothing""	dirtyList add: anSMObject"! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gk 2/7/2004 14:56' prior: 28952433!addObject: anSMObject 	"Add a new object, only if not already added."	(self object: anSMObject id) ifNil: [		self transaction: [self newObject: anSMObject]]! !!SMSqueakMap methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28931200!adminPassword: aString	"We store the password as a SHA hash so that we can let the slave maps	have it too."	adminPassword := SecureHashAlgorithm new hashMessage: aString! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gk 11/14/2003 12:06' prior: 28954943!allPackages	"Answer all packages."	^self packages! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 12/1/2002 19:53' prior: 28955072!availablePackages	"Answer all packages that are old or not installed."	^self packages select: [:package | package isAvailable]! !!SMSqueakMap methodsFor: 'accessing' stamp: 'btr 5/28/2003 02:16' prior: 28931445!cache	^ fileCache! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 2/13/2009 15:11' prior: 28931546!categories	"Lazily maintain a cache of all known category objects."	categories ifNotNil: [^categories].	objects isNil ifTrue: [ ^ #() ].	categories := objects select: [:o | o isCategory].	^categories! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28958957!categoryWithId: anIdString 	"Look up a category. Return nil if missing.	Raise error if it is not a category."	| cat |	cat := self objectWithId: anIdString.	cat ifNil: [^nil].	cat isCategory ifTrue:[^cat].	self error: 'UUID did not map to a category.'! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28959296!categoryWithNameBeginning: aString	"Look up a category beginning with <aString>. Return nil if missing.	We return the shortest matching one. We also strip out spaces and	ignore case in both <aString> and the names."	| candidates shortest answer searchString |	searchString := (aString asLowercase) copyWithout: Character space.	candidates := self categories select: [:cat |		((cat name asLowercase) copyWithout: Character space)			beginsWith: searchString ].	shortest := 1000.	candidates do: [:ca |		ca name size < shortest ifTrue:[answer := ca. shortest := ca name size]].	^answer	! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 11/28/2002 20:44' prior: 28952669!changeCategoriesTo: newCategories inObject: object	"Remove or add categories in an object such that	it belongs to the categories in <newCategories>.	Logs the changes."	newCategories do: [:cat |		(object hasCategory: cat)			ifFalse:[self addCategory: cat inObject: object]].	object categories do: [:cat |		(newCategories includes: cat)			ifFalse: [self removeCategory: cat inObject: object]]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 28959959!check	"Sanity checks."	"SMSqueakMap default check"		(((self packages inject: 0 into: [:sum :p | sum := sum + p releases size]) +	self accounts size +	self packages size +	self categories size) = SMSqueakMap default objects size)		ifFalse: [self error: 'Count inconsistency in map'].		objects do: [:o |		o map == self			ifFalse: [self error: 'Object with wrong map']].	self packages do: [:p |		(p releases allSatisfy: [:r | r map == self])			ifFalse: [self error: 'Package with release pointing to wrong map']].			self packageReleases do: [:r |		r package map == self ifFalse: [self error: 'Release pointing to package in wrong map']]! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 10/31/2002 11:59' prior: 28965121!checkVersion: string	"Check the content for a SqueakMap version conflict notification.	Return true if no conflict is reported, otherwise ask user if we	should upgrade SqueakMap using the bootstrap method."	(string beginsWith: 'Server version:')		ifTrue:[(self confirm: ('The SqueakMap master server is running another version (', (string last: (string size - 15)), ') than the client (', SMSqueakMap version, ').You need to upgrade the SqueakMap package, would you like to do that now?'))			ifTrue: [self class bootStrap. ^false]			ifFalse: [^false]	].	^true! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 10/21/2003 23:02' prior: 28931789!checkpointNumber	^checkpointNumber! !!SMSqueakMap methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28965771!clearCaches	"Clear the caches."	packages := accounts := users := categories := nil! !!SMSqueakMap methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28965938!clearCachesFor: anObject 	"Clear the valid caches."	anObject isPackage ifTrue:[packages := nil].	anObject isAccount ifTrue:[accounts := users := nil].	anObject isCategory ifTrue:[categories := nil]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 28940212!clearInstalledPackageWithId: aPackageId	"Clear the fact that any release of this package is installed.	Can be used even when the map isn't loaded."	^self registry clearInstalledPackageWithId: aPackageId! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 28940498!clearInstalledPackages	"Simply clear the dictionary with information on installed packages.	Might be good if things get corrupted etc. Also see	SMSqueakMap class>>recreateInstalledPackagesFromChangeLog"	^self registry clearInstalledPackages! !!SMSqueakMap methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28966222!clearUsernames	"Clear the username cache."	users := nil! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 3/31/2006 20:58' prior: 28933768!compressFile: aFileStream	"Shamelessly copied and modified from StandardFileStream>>compressFile."		| zipped buffer |	aFileStream binary.	zipped := StandardFileStream newFileNamed: (self directory fullNameFor: (aFileStream name, 'gz')).	zipped binary; setFileTypeToObject.	"Type and Creator not to be text, so can be enclosed in an email"	zipped := GZipWriteStream on: zipped.	buffer := ByteArray new: 50000.	[[aFileStream atEnd] whileFalse: [		zipped nextPutAll: (aFileStream nextInto: buffer)]]		ensure: [zipped close. aFileStream close].	self directory deleteFileNamed: aFileStream name! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 28966348!copyFrom: aMap	"Copy all relevant info from the other map."	objects := aMap objects.	objects do: [:o | o map: self].	accounts := users := packages := categories := nil.	checkpointNumber := aMap checkpointNumber! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 14:47' prior: 28934444!createCheckpoint	"Export a new checkpoint of me using an ImageSegment."	^self createCheckpointNumber: 		(self nextFileNameForCheckPoint findTokens: '.') second asNumber.! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28934703!createCheckpointNumber: number	"Export me using an ImageSegment.	This is used for checkpointing the map on disk	in a form that can be brought into an independent image.	We do not overwrite older versions, since using ImageSegments	is an intermediate hack anyway we don't care about the disk waste!!	Sidenote: Some refactoring was needed to produce a .gz file directly so	I didn't bother."	| is fname stream oldMutex |	fname := self filename, '.', number asString, '.s'.	(self directory fileExists: fname) ifTrue: [self error: 'Checkpoint already exists!!'].	stream := StandardFileStream newFileNamed: (self directory fullNameFor: fname).	checkpointNumber := number.	oldMutex := mutex.	mutex := nil. self clearCaches.	[is := ImageSegment new.	is copyFromRoots: (Array with: self) sizeHint: 1000000 areUnique: true.	is writeForExportOn: stream.	self compressFile: (StandardFileStream oldFileNamed: (self directory fullNameFor: fname)).	isDirty := false]		ensure: [mutex := oldMutex].	^is! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 8/8/2003 19:10' prior: 28966632!deleteObject: anObject 	"Delete an object, remove it from objects.	This method is called from the #delete method of	anObject so it will take care of the rest of the	cleaning up. Clear the valid caches."	objects removeKey: anObject id.	self clearCachesFor: anObject! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 5/22/2004 21:56' prior: 28931896!directory	"Return the subdirectory that SqueakMap uses."		(FileDirectory default directoryExists: dir)		ifFalse:[FileDirectory default createDirectory: dir].	^FileDirectory default directoryNamed: dir! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 8/4/2003 15:22' prior: 28966972!emailOccupied: aUsername	"Return true if email already taken."	^(self accountForEmail: aUsername) notNil! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 12:07' prior: 28935784!extension	^'sgz'! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 12:07' prior: 28935875!filename	^'map'! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 3/31/2006 09:30' prior: 28935964!getLastCheckpointWithFilename	"Return a readstream on a fresh checkpoint gzipped imagesegment.	First we check if we are dirty and must create a new checkpoint.	The filename is tacked on at the end so that the checkpoint number	can be used on the client side too."	| directory fname |	isDirty ifTrue: [self createCheckpoint].	directory := self directory.	fname := self lastCheckpointFilename.	fname ifNil: [self error: 'No checkpoint available'].	^((StandardFileStream oldFileNamed: (directory fullNameFor: fname))		contentsOfEntireFile), ':', fname! !!SMSqueakMap methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 28938102!initializeOn: directoryName	"Create the local directory for SqueakMap."	dir := directoryName.	(FileDirectory default directoryExists: dir)		ifFalse:[FileDirectory default createDirectory: dir].	fileCache := SMFileCache newFor: self.	checkpointNumber := 1! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28940836!installPackage: aPackage	"Install the package.	Note: This method should not be used anymore, better	to specify a specific release."	| rel |	rel := aPackage lastPublishedReleaseForCurrentSystemVersion			ifNil: [self error: 'No published release for this system version found to install.'].	^self installPackageRelease: rel! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28941259!installPackage: aPackage autoVersion: version	"Install the release <version> of <aPackage.	<version> is the automatic version name."	| r |	r := aPackage releaseWithAutomaticVersionString: version.	r ifNil: [self error: 'No package release found with automatic version ', version].	^self installPackageRelease: r! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28941670!installPackageNamed: aString	"Install the last published release	for this Squeak version of the package with a name	beginning with aString (see method comment	of #packageWithNameBeginning:).	Note: This method should not be used anymore.	Better to specify a specific release."	| p |	p := self packageWithNameBeginning: aString.	p ifNil: [self error: 'No package found with name beginning with ', aString].	^self installPackage: p! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28942203!installPackageNamed: aString autoVersion: version	"Install the release <version> of the package with a name	beginning with aString (see method comment	of #packageWithNameBeginning:). <version> is the	automatic version name."	| p r |	p := self packageWithNameBeginning: aString.	p ifNil: [self error: 'No package found with name beginning with ', aString].	r := p releaseWithAutomaticVersionString: version.	r ifNil: [self error: 'No package release found with automatic version ', version].	^self installPackageRelease: r! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 7/14/2004 15:57' prior: 28942816!installPackageRelease: aPackageRelease	"Install the given package release, no checks made."	(SMInstaller forPackageRelease: aPackageRelease) install! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28943060!installPackageReleaseWithId: anUUIDString	"Look up and install the given release."	| r |	r := self packageReleaseWithId: anUUIDString.	r ifNil: [self error: 'No package release available with id: ''', anUUIDString, ''''].	^self installPackageRelease: r! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28943411!installPackageWithId: anUUIDString	"Look up and install the latest release of the given package.		Note: This method should not be used anymore.	Better to specify a specific release."	| package |	package := self packageWithId: anUUIDString.	package ifNil: [self error: 'No package available with id: ''', anUUIDString, ''''].	^self installPackage: package! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28943867!installPackageWithId: anUUIDString autoVersion: version	"Install the release <version> of the package with id <anUUIDString>.	<version> is the automatic version name."	| p |	p := self packageWithId: anUUIDString.	p ifNil: [self error: 'No package available with id: ''', anUUIDString, ''''].	^self installPackage: p autoVersion: version! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 12/1/2002 19:54' prior: 28955278!installableAndNotInstalledPackages	"Answer all installable but not installed packages."	^self packages select: [:package | package isInstallableAndNotInstalled]! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 12/1/2002 19:54' prior: 28955518!installablePackages	"Answer all packages that can be (auto)installed -	we have installers that can install them."	^self packages select: [:package | package isInstallable]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 1/18/2004 15:29' prior: 28944291!installedPackageReleases	"Answer all package releases that we know are installed.	Lazily initialize. The Dictionary contains the installed packages	using their UUIDs as keys and the version string as the value."	^self installedPackages collect: [:p | self installedReleaseOf: p]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 28944654!installedPackages	"Answer all packages that we know are installed."	^self registry installedPackages! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 28944837!installedPackagesDictionary	"Access the dictionary directly. The UUID of the installed package is the key.	The value is an OrderedCollection of Arrays.	The arrays have the smartVersion of the package, the time of the	installation in seconds and the sequence number (installCounter)."	^self registry installedPackagesDictionary! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 28945249!installedPackagesDictionary: aDict	"Set dictionary directly."	^self registry installedPackagesDictionary: aDict! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:23' prior: 28945443!installedReleaseOf: aPackage	"If the package is installed, return the release.	Otherwise return nil. SM2 stores the version as	an Association to be able to distinguish it."	^self registry installedReleaseOf: aPackage! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 28945744!installedVersionOf: aPackage	"If the package is installed, return the version as a String.	If it is a package installed during SM1 it will return the manual version String,	for SM2 it returns the automatic version as a String.	If package is not installed - return nil. If you want it to work without the map loaded you	should instead use #installedVersionOfPackageWithId:."	^self registry installedVersionOf: aPackage! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 28946248!installedVersionOfPackageWithId: anId	"If the package is installed, return the automatic version or version String.	Otherwise return nil. This can be used without the map loaded."	^self registry installedVersionOfPackageWithId: anId! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 15:02' prior: 28936598!isCheckpointAvailable	"Check that there is an 'sm' directory	and that it contains at least one checkpoint."	[^self lastCheckpointFilename notNil] on: Error do: [:ex | ^false]! !!SMSqueakMap methodsFor: 'transactions' stamp: 'gk 11/4/2003 00:19' prior: 28963629!isDirty	"Is the map modified but not yet checkpointed to disk?"	^isDirty! !!SMSqueakMap methodsFor: 'public' stamp: 'gk 2/13/2009 09:12'!isPurged	"Is this instance purged (empty)?"		^checkpointNumber isZero! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 14:21' prior: 28936850!lastCheckpointFilename	"Return the filename for the newest checkpoint."	^self directory lastNameFor: self filename extension: self extension! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 14:52' prior: 28937067!lastCheckpointNumberOnDisk	"Return the last checkpoint number on disk."	^(self nextFileNameForCheckPoint findTokens: '.') second asNumber - 1! !!SMSqueakMap methodsFor: 'public' stamp: 'gh 10/21/2002 14:08' prior: 28938434!loadFull	"Go through the list of known master servers, ping	each one using simple http get on a known 'ping'-url	until one responds and then load the full map from it." 	self loadUpdatesFull: true! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 28967147!loadFullFrom: aServerName	"Contact the SqueakMap at the url <aSqueakMapUrl>	and load a full map from scratch."	| url  zipped |	url := 'http://', aServerName, '/loadgz?mapversion=', SMSqueakMap version, '&checkpoint=', checkpointNumber asString.	Transcript show: 'Fetch: ', (Time millisecondsToRun: [ zipped := (HTTPSocket httpGet: url) contents]) asString, ' ms';cr.	Transcript show: 'Size: ', zipped size asString, ' bytes';cr.	((self checkVersion: zipped) and: [zipped ~= 'UPTODATE'])		ifTrue:[			Transcript show: 'Save checkpoint to disk: ', (Time millisecondsToRun: [			self saveCheckpoint: zipped]) asString, ' ms';cr.			Transcript show: 'Full reload from checkpoint: ', (Time millisecondsToRun: [			self reload]) asString, ' ms';cr.]! !!SMSqueakMap methodsFor: 'public' stamp: 'gk 11/17/2003 23:16' prior: 28938704!loadUpdates	"Go through the list of known master servers, ping	each one using simple http get on a known 'ping'-url	until one responds and then load updates from it."	"SM2 starts with using full always"	self loadFull! !!SMSqueakMap methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28967980!loadUpdatesFull: full	"Find a server and load updates from it." 	| server |	server := self class findServer.	server ifNotNil: [		self synchWithDisk.		full ifTrue: [self loadFullFrom: server]			ifFalse:[self error: 'Not supported yet!!'."self loadUpdatesFrom: server"]]! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 11/17/2003 22:57' prior: 28968326!mandatoryCategoriesFor: aClass	"Return the categories that are mandatory for instances of <aClass>."	^self categories select: [:c | c mandatoryFor: aClass]! !!SMSqueakMap methodsFor: 'private-installation' stamp: 'gk 8/3/2004 13:24' prior: 28970491!markInstalled: uuid version: version time: time counter: num	"Private. Mark the installation. SM2 uses an Association	to distinguish the automatic version from old versions."	^self registry markInstalled: uuid version: version time: time counter: num! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gk 11/17/2003 14:56' prior: 28953146!moveCategory: category toAfter: categoryBefore inParent: parent	"Move a category to be listed after <categoryBefore> in <parent>."	parent move: category toAfter: categoryBefore.	^category	! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gk 5/22/2004 22:22' prior: 28953415!moveCategory: category toParent: parentCategory	"Move a category into another parent category."	parentCategory		ifNil: [category parent: nil]		ifNotNil: [parentCategory addCategory: category].	^category	! !!SMSqueakMap methodsFor: 'transactions' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28963790!mutex	"Lazily initialize the Semaphore."	^mutex ifNil: [mutex := Semaphore forMutualExclusion]! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 8/3/2003 23:23' prior: 28968552!newAccount	"Create a new account."	^SMAccount newIn: self! !!SMSqueakMap methodsFor: 'public-master' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28953713!newAccount: name username: username email: email	"Create an account. Checking for previous account should already have been done.	To add the account to the map, use SMSqueakMap>>addObject:"	| account |	account := self newAccount					name: name;					initials: username;					email: email.	^account	! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 9/26/2003 00:04' prior: 28968681!newObject: anSMObject 	"Add an SMObject to me. Clear the valid caches."	self addDirty: anSMObject.	self clearCachesFor: anSMObject.	^objects at: anSMObject id put: anSMObject! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 12:12' prior: 28937285!nextFileNameForCheckPoint	"Return the next available filename for a checkpoint."	^self directory nextNameFor: self filename extension: self extension! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 12/1/2002 19:54' prior: 28955770!notInstalledPackages	"Answer all packages that are not installed."	^self packages reject: [:package | package isInstalled]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 11/18/2003 17:49' prior: 28946566!noteInstalled: aPackageRelease	"The package release was just successfully installed using SM.	This is the method being called by SM upon a successful installation.	We record this in our Dictionary of installed package releases	and log a 'do it' to mark this in the changelog.	The map used is the default map."	^self noteInstalledPackageWithId: aPackageRelease package id asString		autoVersion: aPackageRelease automaticVersion		name: aPackageRelease package name! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 11/18/2003 17:50' prior: 28947120!noteInstalledPackage: aPackage autoVersion: aVersion	"Mark that the package release was just successfully installed.	Can be used to inform SM of an installation not been done using SM."	^self noteInstalledPackageWithId: aPackage id asString		autoVersion: aVersion		name: aPackage name! !!SMSqueakMap methodsFor: 'private-installation' stamp: 'gk 8/3/2004 13:24' prior: 28970826!noteInstalledPackage: uuidString version: version	"Mark a specific version of a package as installed.	This method is called when replaying a logged installation	from before SqueakMap 1.07. Such logged installations lacked	a timestamp and a count. We take the current time and a	count starting from -10000 and upwards. This should keep	the sorting order correct."	^self registry noteInstalledPackage: uuidString version: version! !!SMSqueakMap methodsFor: 'private-installation' stamp: 'gk 8/3/2004 13:24' prior: 28971342!noteInstalledPackage: uuidString version: version atSeconds: time number: num	"Mark a package as installed in the Dictionary.	This method is called when replaying a logged installation.	<time> is the point in time as totalSeconds of the installation.	<num> is the installCount of the installation.	This method is typically called from a doIt in the changelog	in order to try to keep track of packages installed."	^self registry noteInstalledPackage: uuidString version: version atSeconds: time number: num! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28947504!noteInstalledPackageNamed: aString autoVersion: aVersion	"Mark that the package release was just successfully installed.	<aVersion> is the automatic version as a String.	Can be used to inform SM of an installation not been done using SM."	| p |	p := self packageWithNameBeginning: aString.	p ifNil: [self error: 'No package found with name beginning with ', aString].	^self noteInstalledPackage: p autoVersion: aVersion asVersion! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 11/18/2003 11:59' prior: 28948024!noteInstalledPackageWithId: aPackageId autoVersion: aVersion	"The package release was just successfully installed.	Can be used to inform SM of an installation not been	done using SM, even when the map isn't loaded."	^self noteInstalledPackageWithId: aPackageId		autoVersion: aVersion		name: '<unknown name>'! !!SMSqueakMap methodsFor: 'private-installation' stamp: 'gk 8/3/2004 13:24' prior: 28971936!noteInstalledPackageWithId: uuidString autoVersion: version atSeconds: time number: num	"Mark a package as installed in the Dictionary.	This method is called when replaying a logged installation.	<time> is the point in time as totalSeconds of the installation.	<num> is the installCount of the installation.	This method is typically called from a doIt in the changelog	in order to try to keep track of packages installed."	^self registry noteInstalledPackageWithId: uuidString autoVersion: version atSeconds: time number: num! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 28948419!noteInstalledPackageWithId: aPackageId autoVersion: aVersion name: aName	"The package release was just successfully installed.	Can be used to inform SM of an installation not been	done using SM, even when the map isn't loaded.	We record the fact in our Dictionary of installed packages	and log a 'do it' to mark this in the changelog.	The doit helps keeping track of the packages when	recovering changes etc - not a perfect solution but should help.	The map used is the default map.	The id of the package is the key and the value is an OrderedCollection	of Arrays with the release auto version, the point in time and the current installCounter."	^self registry noteInstalledPackageWithId: aPackageId autoVersion: aVersion name: aName! !!SMSqueakMap methodsFor: 'private-installation' stamp: 'gk 1/22/2004 12:01' prior: 28972551!noteUninstalled: aPackageRelease	"The package release was just successfully uninstalled using SM.	This is the method being called by SM upon a successful uninstallation.	We record this in our Dictionary of installed package releases	and log a 'do it' to mark this in the changelog.	The map used is the default map."	^self noteUninstalledPackageWithId: aPackageRelease package id asString		autoVersion: aPackageRelease automaticVersion		name: aPackageRelease package name! !!SMSqueakMap methodsFor: 'private-installation' stamp: 'gk 8/3/2004 13:25' prior: 28973112!noteUninstalledPackageWithId: aPackageId autoVersion: aVersion name: aName	"The package release was just successfully uninstalled.	Can be used to inform SM of an uninstallation not been	done using SM, even when the map isn't loaded.	We record the fact in our Dictionary of installed packages	and log a 'do it' to mark this in the changelog.	The doit helps keeping track of the packages when	recovering changes etc - not a perfect solution but should help.	The map used is the default map.	The id of the package is the key and the value is an OrderedCollection	of Arrays with the release auto version, the point in time and the current installCounter."	^self registry noteUninstalledPackageWithId: aPackageId autoVersion: aVersion name: aName! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 11/18/2003 02:06' prior: 28960681!object: aUUID	"Look up a categorizable object. Return nil if missing."	^objects at: aUUID ifAbsent: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 12/1/2002 19:25' prior: 28960858!objectWithId: anIdString	"Look up a categorizable object. Return nil if missing."	^objects at: (UUID fromString: anIdString) ifAbsent: [nil]! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gh 11/28/2002 22:00' prior: 28932173!objects	^objects! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gk 7/13/2004 15:12' prior: 28955972!oldPackages	"Answer all packages that are installed with a	newer published version for this Squeak version available."	^self installedPackages select: [:package | package isSafelyOld]! !!SMSqueakMap methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28932273!packageCacheDirectory	"Return a FileDirectory for the package cache of the map.	Creates it if it is missing."	| dirName baseDir |	dirName := self packageCacheDirectoryName.	baseDir := self directory.	(baseDir fileOrDirectoryExists: dirName)		ifFalse:[baseDir createDirectory: dirName].	^baseDir directoryNamed: dirName! !!SMSqueakMap methodsFor: 'private' stamp: 'btr 5/28/2003 00:56' prior: 28968930!packageCacheDirectoryName	"What is the name of the cache directory?"	^'cache'! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28961082!packageReleaseWithId: anIdString 	"Look up a package release. Return nil if missing.	Raise error if it is not a package release."	| r |	r := self objectWithId: anIdString.	r ifNil: [^nil].	r isPackageRelease ifTrue:[^r].	self error: 'UUID did not map to a package release.'! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 10/19/2005 23:53' prior: 28932672!packageReleases	"Return subset of objects."	objects ifNil: [^#()].	^objects select: [:o | o isPackageRelease]! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28961444!packageWithId: anIdString 	"Look up a package. Return nil if missing.	Raise error if it is not a package."	| package |	package := self objectWithId: anIdString.	package ifNil: [^nil].	package isPackage ifTrue:[^package].	self error: 'UUID did not map to a package.'! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 12/1/2002 19:54' prior: 28961786!packageWithName: aName	"Look up a package by exact match on name. Return nil if missing."	^self packages detect: [:package | package name = aName ] ifNone: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28962031!packageWithNameBeginning: aString	"Look up a package beginning with <aString>. Return nil if missing.	We return the shortest matching one. We also strip out spaces and	ignore case in both <aString> and the names."	| candidates shortest answer searchString |	searchString := (aString asLowercase) copyWithout: Character space.	candidates := self packages select: [:package |		((package name asLowercase) copyWithout: Character space)			beginsWith: searchString ].	shortest := 1000.	candidates do: [:package |		package name size < shortest ifTrue:[answer := package. shortest := package name size]].	^answer	! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 11/11/2003 18:37' prior: 28962720!packageWithPI: aPIName	"Look up a package by exact match on PackageInfo name. Return nil if missing."	aPIName isEmptyOrNil ifTrue: [^nil].	^self packages detect: [:package | package packageInfoName = aPIName ] ifNone: [nil]! !!SMSqueakMap methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28932868!packages	"Lazily maintain a cache of all known package objects."	packages ifNotNil: [^packages].	objects ifNil: [^#()].	packages := objects select: [:o | o isPackage].	^packages! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 12/3/2004 12:01' prior: 28963016!packagesByName	"Return the packages sorted by their name."	^self packages asSortedCollection: [:x :y | x name caseInsensitiveLessOrEqual: y name]! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 9/30/2003 17:03' prior: 28969079!pingServer: aServerName	^self class pingServer: aServerName! !!SMSqueakMap methodsFor: 'public' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28939007!purge	"Clear out the map from memory. Use this to reclaim space,	no information is lost because it does not remove information	about what packages are installed, and the map itself is checkpointed	to disk. Use #reload to get it back from the latest checkpoint on disk."	objects := accounts := users := packages := categories := nil.	checkpointNumber := 0.! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 28933121!registry	^registry ifNil: [registry := SMInstallationRegistry map: self]! !!SMSqueakMap methodsFor: 'public' stamp: 'gk 3/31/2006 10:32' prior: 28939437!reload	"Reload the map from the latest checkpoint on disk.	The opposite of #purge."	| fname stream map |	fname := self lastCheckpointFilename.	fname ifNil: [self error: 'No checkpoint available!!'].	"Code below uses good ole StandardFileStream to avoid m17n issues (this is binary data) and	also uses #unzipped since it works in older Squeaks"	stream := (StandardFileStream oldFileNamed: (self directory fullNameFor: fname)) asUnZippedStream.	"stream := (RWBinaryOrTextStream with: contents) reset."	stream ifNil: [self error: 'Couldn''t open stream on checkpoint file!!'].	[map := (stream fileInObjectAndCode) install arrayOfRoots first] ensure: [stream close].	self copyFrom: map! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gk 11/17/2003 10:30' prior: 28954096!removeCategory: category inObject: object	"Remove a category from an object."	^object removeCategory: category! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gk 5/5/2006 02:07' prior: 28954284!repair	"Integrity repairs. This should not be neeed, but	for some reason the map can obviously get messed up,	not sure how."	"SMSqueakMap default repair"		"all objects should point back to me and not at another map"	objects do: [:o | o map: self].		"all releases should point back at the package they are in"	self packages do: [:p | p releases do: [:r | r package: p]].		"all releases in this map should point at a package in this map"	self packageReleases do: [:r | | p |		p := self object: r package id.		p ifNil: [self error: 'Unknown package'].		r package: p]! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 3/31/2006 09:34' prior: 28937510!saveCheckpoint: contentWithFilename	"Save the map checkpoint to disk if it is not there already."	| file directory sz fname content |	directory := self directory.	sz := contentWithFilename size.	fname := contentWithFilename last: sz - (contentWithFilename lastIndexOf: $:).	content := contentWithFilename first: sz - fname size - 1.	(directory fileExists: fname) ifFalse: [		[file := StandardFileStream newFileNamed: (directory fullNameFor: fname).		file nextPutAll: content]			ensure: [file close]]! !!SMSqueakMap methodsFor: 'transactions' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28963973!setDirty	"Set the map modified so that it will get written to disk."	isDirty := true! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 7/13/2004 02:51' prior: 28933265!silent	"Can installations ask questions or should they be silent	and us good defaults?"	^ silent ifNil: [false] ifNotNil: [true]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28949258!silentlyDo: aBlock	"Execute <aBlock> with the Silent flag set.	This is a crude way of avoiding user interaction	during batch operations, like loading updates."	[silent := true.	aBlock value]		ensure: [silent := nil]! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 2/13/2009 09:14' prior: 28969221!synchWithDisk	"Synchronize myself with the checkpoints on disk.	If there is a newer checkpoint than I know of, load it.	If there is no checkpoint or if I have a higher checkpoint number,	create a new checkpoint from me.	The end result is that I am in synch with the disk and we are both as	updated as possible."	| checkpointNumberOnDisk |	 "If there is no checkpoint, save one from me."	(self isCheckpointAvailable) ifFalse: [		"If I am purged - don't checkpoint, no point"		self isPurged ifTrue: [^self].		^self createCheckpointNumber: checkpointNumber].	"If the one on disk is newer, load it"	checkpointNumberOnDisk := self lastCheckpointNumberOnDisk.	(checkpointNumber < checkpointNumberOnDisk)		ifTrue: [^self reload].	"If I am newer, recreate me on disk"	(checkpointNumberOnDisk < checkpointNumber)		ifTrue: [^self createCheckpointNumber: checkpointNumber]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 12/1/2002 20:12' prior: 28963233!topCategories	^self categories select: [:cat | cat isTopCategory]! !!SMSqueakMap methodsFor: 'transactions' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28964146!transaction: aBlock	"Execute aBlock and then make sure any modified SMObjects	are committed to disk. We do this inside a mutex in order to	serialize transactions. Transactions must be initiated from	service methods in this class and not from inside the domain	objects - otherwise they could get nested and a deadlock occurs.""In first version of SM2 we simply set the isDirty flag,when next client asks for updates, or 30 minutes has passed,we checkpoint.""	self mutex critical: ["		aBlock value.		isDirty := true"	]""	self mutex critical: [		dirtyList := OrderedCollection new.		aBlock value.		dirtyList do: [:obj | obj commit].		dirtyList := nil	]"! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 11/17/2003 13:06' prior: 28949562!upgradeOldPackages	"Upgrade all upgradeable old packages without confirmation on each."	^self upgradeOldPackagesConfirmBlock: [:package | true ]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28949802!upgradeOldPackagesConfirmBlock: aBlock	"First we find out which of the installed packages are upgradeable and old.	Then we upgrade them if confirmation block yields true.	The block will be called with each SMPackage to upgrade.	We return a Dictionary with the packages we tried to upgrade as keys	and the value being the result of the upgrade, true or false."	| result |	result := Dictionary new.	self upgradeableAndOldPackages		do: [:package |			(aBlock value: package)				ifTrue:[ result at: package put: package upgrade]].	^result! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 7/14/2004 17:33' prior: 28950962!upgradeOrInstallPackage: aPackage	"Upgrade package (or install) to the latest published release for this Squeak version."	^aPackage upgradeOrInstall! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28951206!upgradeOrInstallPackageWithId: anUUIDString	"Upgrade package (or install) to the latest published release for this Squeak version."	| package |	package := self packageWithId: anUUIDString.	package ifNil: [self error: 'No package available with id: ''', anUUIDString, ''''].	^package upgradeOrInstall! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 5/5/2006 02:07' prior: 28950429!upgradeOrInstallPackageWithId: anUUIDString asOf: aTimeStamp	"Upgrade package (or install) to the latest published release as it was	on <aTimeStamp> for this Squeak version. This ensures that the same	release will be installed (for all Squeak versions) as when it was tested."	| package |	package := self packageWithId: anUUIDString.	package ifNil: [self error: 'No package available with id: ''', anUUIDString, ''''].	^package upgradeOrInstall! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 7/14/2004 17:16' prior: 28951592!upgradePackage: aPackage	"Upgrade package to the latest published release for this Squeak version."	^aPackage upgrade! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28951805!upgradePackageWithId: anUUIDString	"Upgrade package to the latest published release for this Squeak version.	Will raise error if there is no release installed, otherwise use	#upgradeOrInstallPackageWithId: "	| package |	package := self packageWithId: anUUIDString.	package ifNil: [self error: 'No package available with id: ''', anUUIDString, ''''].	^package upgrade! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 10/25/2002 11:33' prior: 28956237!upgradeableAndOldOrInstallableAndNotInstalledPackages	"This would give you all packages that are available now	for automatic install or automatic upgrade."	^self upgradeableAndOldPackages union: self installableAndNotInstalledPackages! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gk 7/14/2004 16:17' prior: 28956552!upgradeableAndOldPackages	"Answer all packages that are installed and which have a	newer published release for this Squeak version that also	can be to by an installer."	^self installedPackages select: [:package | package isSafelyOldAndUpgradeable]! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 8/3/2003 23:13' prior: 28970087!usernameOccupied: aUsername	"Return true if name already taken."	^(self accountForUsername: aUsername) notNil! !!SMSqueakMap methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28933480!users	"Lazily maintain a cache of all known account objects	keyed by their developer initials."	users ifNotNil: [^users].	users := Dictionary new.	self accounts do: [:a | users at: a initials put: a].	^users! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 10/21/2003 23:05' prior: 28970269!verifyAdminPassword: aString	"Answer true if it is the correct password."	^adminPassword = (SecureHashAlgorithm new hashMessage: aString)! !!SMSqueakMap methodsFor: 'views' stamp: 'gh 11/28/2002 22:06' prior: 28964886!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis. Used primarily by the web frontend."	^uiObject squeakMapViewOn: self! !!SMUtilities commentStamp: 'gk 11/13/2003 23:39' prior: 28990615!Various loose functions in SM.!!SMUtilities class methodsFor: 'class initialization' stamp: 'gk 5/5/2006 02:07' prior: 28990837!initialize	"Initialize server settings."	"self initialize"	MasterServer := nil.	MailServer := nil! !!SMUtilities class methodsFor: 'server' stamp: 'gk 10/13/2005 00:18' prior: 28991236!isServer	"Is this a running server?"		^MasterServer notNil! !!SMUtilities class methodsFor: 'private' stamp: 'gk 10/12/2005 23:10' prior: 28995266!mail: anAccount subject: sub message: msg	"Send a mail to the holder of <anAccount>."	SMTPClient		deliverMailFrom: 'squeakmap@squeak.org'		to: {anAccount email}		text:('From: SqueakMap <squeakmap@squeak.org>To: ', anAccount email, 'Subject: ', sub,'', msg, (self randomPhrase), ', SqueakMap') squeakToIso usingServer: MailServer! !!SMUtilities class methodsFor: 'server' stamp: 'gk 8/4/2003 16:15' prior: 28991370!mailPassword: randomPass for: anAccount	"Change the password to a random generated one	and mail it to the holder of the account."	self mail: anAccount subject: 'New password at SqueakMap!!' message:'Hi!!An extra random password has been added for the account held by "', anAccount name, '":"', randomPass, '"You can login to SqueakMap at:', MasterServer, '/loginThe regular password still works, so if it was not you who requested this extrarandom password you can safely just delete this email.This extra password will stop working when you change your regular password.'! !!SMUtilities class methodsFor: 'server' stamp: 'gk 8/4/2003 16:15' prior: 28992033!mailPassword: aPassword forNew: anAccount	"Mail the password to the person who just registered the account."	self mail: anAccount subject: 'Your new account at SqueakMap!!' message:'Hi!!You or someone else has registered an account on SqueakMap. You can login to it using this link:',MasterServer, '/autologin?u=', anAccount initials, '&p=', aPassword,'If it was not you who performed this registration you can safely just delete this email.'! !!SMUtilities class methodsFor: 'class initialization' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28991040!mailServer: ipName masterServer: httpUrl	"Initialize server settings."	MailServer := ipName.	MasterServer := httpUrl! !!SMUtilities class methodsFor: 'private' stamp: 'rbb 3/1/2005 11:12' prior: 28995680!mailUserName	"Answer the mail user's name, but deal with some historical mail senders."	| mailSender |	mailSender := (Smalltalk at: #MailSender ifAbsent: [ Smalltalk at: #Celeste ifAbsent: []]).	^mailSender		ifNil: [ UIManager default request: 'What is your email address?' ]		ifNotNil: [ mailSender userName ]! !!SMUtilities class methodsFor: 'server' stamp: 'gk 8/15/2003 12:25' prior: 28992562!masterServer	"Return the master server url."	^MasterServer! !!SMUtilities class methodsFor: 'private' stamp: 'gh 11/27/2002 12:37' prior: 28996073!randomPhrase	"Pick a nice phrase."	^#('Debug safely' 'Happy Squeaking' 'Just do it' 'Yours truly' 'Stay a Squeaker' 'Squeak rocks') atRandom! !!SMUtilities class methodsFor: 'utilities' stamp: 'gk 3/31/2006 09:50' prior: 28992701!sendMail: aString	"Send the given mail message, but check for modern mail senders."	| server |	Smalltalk at: #MailSender ifPresent: [ :mailSender |		^mailSender sendMessage: ((Smalltalk at: #MailMessage) from: aString).	].	Smalltalk at: #MailComposition ifPresent: [ :mailComposition |		^mailComposition new			messageText:  aString;			open	].		Smalltalk at: #Celeste ifPresent: [ :celeste |		celeste isSmtpServerSet ifTrue: [			Smalltalk at: #CelesteComposition ifPresent: [ :celesteComposition |				^celesteComposition					openForCeleste: celeste current 					initialText: aString			]		]	].	Smalltalk at: #AdHocComposition ifPresent: [ :adHocComposition |		server := UIManager default request: 'What is your mail server for outgoing mail?'.		^adHocComposition 			openForCeleste: server			initialText: aString	].	^self inform: 'Sorry, no known way to send the message'.	 	! !!SMUtilities class methodsFor: 'utilities' stamp: 'gk 7/10/2004 03:43' prior: 28993683!sendMailTo: recipient regardingPackageRelease: pr	"Send mail to the given recipient. Try to use the first of:	- MailSender (with its registered composition class)	- Celeste	- AdHocComposition	for compatibility with 3.5 and 3.6 images"	self sendMail: (String streamContents: [:stream |		stream			nextPutAll: 'From: '; nextPutAll: self mailUserName; cr;			nextPutAll: 'To: '; nextPutAll: recipient; cr;			nextPutAll: 'Subject: Regarding '; nextPutAll: pr printName; cr])! !!SMUtilities class methodsFor: 'utilities' stamp: 'gk 3/31/2006 09:52' prior: 28994239!stripEmailFrom: aString	"Picks out the email from:		'Robert Robertson <rob@here.com>' => 'rob@here.com'	Spamblockers 'no_spam', 'no_canned_ham' and 'spam_block'	(case insensitive) will be filtered out."	| lessThan moreThan email pos |	lessThan := aString indexOf: $<.	moreThan := aString indexOf: $>.	(lessThan * moreThan = 0) ifTrue: [^ aString].	email := (aString copyFrom: lessThan + 1 to: moreThan - 1) asLowercase.	#('no_spam' 'no_canned_ham' 'spam_block') do: [:block |		pos := email findString: block.		pos = 0 ifFalse:[email := (email copyFrom: 1 to: pos - 1), (email copyFrom: pos + block size to: email size)]].	^email! !!SMUtilities class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 28994970!stripNameFrom: aString	"Picks out the name from:		'Robert Robertson <rob@here.com>' => 'Robert Robertson'	"	| lessThan |	lessThan := aString indexOf: $<.	^(aString copyFrom: 1 to: lessThan - 1) withBlanksTrimmed ! !!ImageSegment methodsFor: '*SMBase-export' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 22068576!writeForExportOn: fileStream	"Write the segment on the disk with all info needed to reconstruct it in a new image.  For export.  Out pointers are encoded as normal objects on the disk."	| temp |	state = #activeCopy ifFalse: [self error: 'wrong state'].	temp := endMarker.	endMarker := nil.	fileStream fileOutClass: nil andObject: self.		"remember extra structures.  Note class names."	endMarker := temp.! !!SystemVersion methodsFor: '*smbase-extension' stamp: 'jcg 11/2/2004 10:03' prior: 31800799!majorMinorVersion	"Return the major/minor version number of the form X.Y, without any 'alpha' or 'beta' or other suffix."	"(SystemVersion new version: 'Squeak3.7alpha') majorMinorVersion" "  -->  'Squeak3.7' "	"SystemVersion current majorMinorVersion"		| char stream |	stream := ReadStream on: version, 'x'.	stream upTo: $..	char := stream next.	char ifNil: [^ version].	"eg: 'Jasmine-rc1' has no $. in it."	[char isDigit]		whileTrue: [char := stream next].	^ version copyFrom: 1 to: stream position - 1! !!UUID class methodsFor: '*smbase-macsafe' stamp: 'dvf 9/10/2004 23:11' prior: 50367812!fromString36: aString	"Decode the UUID from a base 36 string using 0-9 and lowercase a-z.	This is the shortest representation still being able to work as	filenames etc since it does not depend on case nor characters	that might cause problems."	| object num |	object := self nilUUID.	num := Integer readFrom: aString asUppercase readStream base: 36.	16 to: 1 by: -1 do: [:i |		num size < i			ifTrue: [object at: i put: 0]			ifFalse: [object at: i put: (num digitAt: i)]].	^object! !!UUID methodsFor: '*smbase-macsafe' stamp: 'gk 4/18/2006 22:15' prior: 50366484!asString36	"Encode the UUID as a base 36 string using 0-9 and lowercase a-z.	This is the shortest representation still being able to work as	filenames etc since it does not depend on case nor characters	that might cause problems, and it fits into short filenames like on	the old MacOS HFS filesystem. The check for 36r is to make this code	work in versions before Squeak 3.8."	| num candidate |	num := 0.	1 to: self size do: [:i | num := num + ((256 raisedTo: i - 1) * (self at: i))].	candidate := num printStringBase: 36.	^((candidate beginsWith: '36r')			ifTrue: [candidate copyFrom: 4 to: candidate size]			ifFalse: [candidate]) asLowercase! !!SMDependencyTest commentStamp: '<historical>' prior: 28786243!Tests for the dependency engine.!!SMDependencyTest methodsFor: 'as yet unclassified' stamp: 'gk 5/5/2006 02:07' prior: 28786359!setUp	| package trivial1rel installed1rel installed2rel tricky2rel conf1 conf2 tricky3rel1 tricky3rel2 tricky1rel seaside httpview kom1 kom2 |	map := SMSqueakMap new reload.	goranAccount := map newAccount: 'Goran' username: 'Goran' email: 'g@g.com'.		"Add a few packages to test with:		Tricky1 1		Installed1 1		Tricky2 1	Tricky2 1		Installed1 1		TrivialToInstall1 1		Tricky3 1			Installed1 1		TrivialToInstall1 1		Tricky3 2	Tricky3 2		TrivialToInstall1 1		Installed2 1		Seaside		KomHttpServer 1		HttpView		KomHttpServer 2	"	{		{'A'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 3}.		{'B'. {'Squeak3.6'. 'Stable'}. 2}.		{'TrivialToInstall1'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Installed1'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Installed2'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'AlreadyInstallable1'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Tricky1'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Tricky2'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Tricky3'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 2}.		{'Circular1'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Circular2'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Circular3'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Seaside'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'KomHttpServer'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 2}.		{'HttpView'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.	} do: [:arr |			package := SMPackage newIn: map.			package name: arr first.			arr second do: [:cn | package addCategory: (map categoryWithNameBeginning: cn)].			arr third timesRepeat: [package newRelease ].			goranAccount addObject: package].		trivial1rel := (map packageWithName: 'TrivialToInstall1') lastRelease.	trivial1rel publisher: goranAccount.		installed1rel := (map packageWithName: 'Installed1') lastRelease.	installed1rel publisher: goranAccount; noteInstalled.	installed2rel := (map packageWithName: 'Installed2') lastRelease.	installed2rel publisher: goranAccount; noteInstalled.	((map packageWithName: 'AlreadyInstallable1') lastRelease		publisher: goranAccount;		addConfiguration)				addRequiredRelease: installed1rel.	"Tricky1 has just a single configuration with one installed and one not installed."	tricky1rel := (map packageWithName: 'Tricky1') lastRelease.	tricky2rel := (map packageWithName: 'Tricky2') lastRelease.				(tricky1rel publisher: goranAccount; addConfiguration)				addRequiredRelease: installed1rel; "already installed"				addRequiredRelease: tricky2rel. "not installed"	"Tricky2 has two configurations:		1: an installed, a trivial one and Tricky3 r1.		2: an installed, a trivial one and Tricky3 r2."	conf1 := tricky2rel publisher: goranAccount; addConfiguration.	conf2 := tricky2rel addConfiguration.		tricky3rel1 := (map packageWithName: 'Tricky3') releases first.	tricky3rel2 := (map packageWithName: 'Tricky3') lastRelease.	tricky3rel1 publisher: goranAccount.	tricky3rel2 publisher: goranAccount.	conf1 addRequiredRelease: installed1rel; addRequiredRelease: trivial1rel; addRequiredRelease: tricky3rel1.	conf2 addRequiredRelease: installed1rel; addRequiredRelease: trivial1rel; addRequiredRelease: tricky3rel2.		"Tricky3rel2 has two configurations:		1: trivial1		2: installed2rel"	conf1 := tricky3rel2 publisher: goranAccount; addConfiguration.	conf2 := tricky3rel2 addConfiguration.	conf1 addRequiredRelease: trivial1rel.	conf2 addRequiredRelease: installed2rel.		seaside := (map packageWithName: 'Seaside') lastRelease.	seaside publisher: goranAccount.	httpview := (map packageWithName: 'HttpView') lastRelease.	httpview publisher: goranAccount.	kom1 := (map packageWithName: 'KomHttpServer') firstRelease.	kom1 publisher: goranAccount.	kom2 := (map packageWithName: 'KomHttpServer') lastRelease.	kom2 publisher: goranAccount.		conf1 := seaside addConfiguration.	conf2 := httpview addConfiguration.	conf1 addRequiredRelease: kom1.	conf2 addRequiredRelease: kom2! !!SMDependencyTest methodsFor: 'as yet unclassified' stamp: 'gk 5/5/2006 02:07' prior: 28793317!test2	"Checking construction of model:	- verify test for circular dependencies (not allowed)."	"Circular1rel has a conf to Circular2rel, which in turn has one back."	| circular1rel circular2rel circular3rel |	circular1rel := (map packageWithName: 'Circular1') lastRelease.	circular2rel := (map packageWithName: 'Circular2') lastRelease.	circular3rel := (map packageWithName: 'Circular3') lastRelease.	(circular1rel publisher: goranAccount; addConfiguration)		addRequiredRelease: circular2rel.	(circular2rel publisher: goranAccount; addConfiguration)		addRequiredRelease: circular3rel.		self should: [		(circular3rel publisher: goranAccount; addConfiguration)			addRequiredRelease: circular1rel]		raise: Error! !----End fileIn of a stream----!!VersionNumber methodsFor: '*smbase-printing' stamp: 'gk 1/23/2004 10:13' prior: 34717992!versionString	^String streamContents: [ :strm | self versionStringOn: strm ]! !!VersionNumber methodsFor: '*smbase-override' stamp: 'svp 6/18/2002 17:23' prior: 34718166!versionStringOn: strm	| first |	first := true.	numbers do: [ :ea |		first ifFalse: [strm nextPut: $.].		first := false.		ea printOn: strm]	! !!RcsDiff class methodsFor: 'instance creation' stamp: 'gh 11/22/2001 23:44' prior: 34718410!lines: aString	"Create a new RcsDiff file."	^(self new) commandLines: aString; yourself! !!RcsDiff methodsFor: 'applying' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34718592!applyTo: aString	"Apply me to given String and return the patched String."	| space commandStream originalStream nextCommand nextLine lineCount currentLine |	space := Character space.	commandStream := ReadStream on: commandLines.	originalStream := ReadStream on: aString.	currentLine := 1.	^String streamContents: [:stream |		[nextCommand := commandStream next.		nextCommand isNil] whileFalse: [ 			nextLine := (commandStream upTo: space) asNumber.			lineCount := commandStream nextLine asNumber.			[currentLine = nextLine]				whileFalse: [stream nextPutAll: originalStream nextLine; cr. currentLine := currentLine + 1].			nextCommand = $d				ifTrue:[ lineCount timesRepeat: [originalStream nextLine. currentLine := currentLine + 1]]				ifFalse:[ nextCommand = $a							ifTrue:[ stream nextPutAll: originalStream nextLine; cr.									currentLine := currentLine + 1.									lineCount timesRepeat: [										stream nextPutAll: commandStream nextLine; cr]]]].		stream nextPutAll: originalStream upToEnd]! !!RcsDiff methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34719710!commandLines: aString	commandLines := aString! !!SMDependencyAnalysis commentStamp: '<historical>' prior: 34719828!A dependency analysis is instantiated by an SMInstallationTask as a step in calculating how the task can be performed.The analysis is done using a map and some input - for example a list of package releases that the task wants to get installed. It can then be queried for the results. The analysis is performed in a series of steps and middle results are collected in instvars. It also uses sub instances so the analysis actually forms a tree of several instances of SMDependencyAnalysis where each node describes one level of dependencies.Instvars:task - the task that instantiated this analysis.map - the SMSqueakMap to use, we get it by asking the task.wantedReleases - the releases that we want to install.alreadyInstalled - the subset of wantedReleases that are already installed.trivialToInstall - the subset of wantedReleases that do not have dependencies and can be installed directly.alreadyInstallable - 	the subset of wantedReleases that do have dependencies but for which at least one configuration is fulfilled and thus the release can already be installed.trickyReleases - the subset of wantedReleases that do have configurations but none of them are fulfilled, so some dependencies first needs to be installed before these releases can be installed.workingConfigurations - an OrderedCollection of OrderedCollections holding all working configurations for the trickyReleases.workingConfigurationsSize - size of workingConfigurations.combinations - all possible (unordered) combinations of picking one working configuration for each tricky release.suggestedInstallSetsSet - computed from combinations above. A Set of Sets of required releases. Each Set is a unique combination of the required releases to install in order to fulfill one configuration for each of the tricky releases.conflictingInstallSetsSet - the subset of suggestedInstallSetsSet that are invalid since it includes multiple releases from the same package. !!SMDependencyAnalysis class methodsFor: 'instance creation' stamp: 'gk 7/29/2004 14:31' prior: 34721892!task: ownerTask	^self new task: ownerTask! !!SMDependencyAnalysis methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 34722027!allInstallPaths	"For all paths, collect in reverse all releases to install.	At each level, first we add trivially installable releases	(those that have no dependencies), then installable releases	(those that have one configuration fulfilled) and finally	the tricky releases (those left).	Note that we also return paths with conflicting releases	of the same package and paths with releases that conflict with	already installed releases - those paths can be tweaked - and	paths that are supersets of other paths."	| installPaths releases |	installPaths := OrderedCollection new.	self allPathsDo: [:path |		releases := OrderedCollection new.		path reverseDo: [:ana |			releases addAll: (ana trivialToInstall difference: releases).			releases addAll: (ana alreadyInstallable difference: releases).			releases addAll: (ana trickyReleases difference: releases)			"Below for debugging			r := OrderedCollection new.			r add: ana trivialToInstall; add: ana alreadyInstallable; add: ana trickyReleases.			releases add: r"].		installPaths add: releases].	^ installPaths! !!SMDependencyAnalysis methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 34723201!allNormalizedInstallPaths	"Same as allInstallPaths, but with paths removed that	are clear supersets of others."	| installPaths |	installPaths := self allInstallPaths.	installPaths := installPaths reject: [:p1 |					installPaths anySatisfy: [:p2 |						(p1 ~~ p2) and: [p1 includesAllOf: p2]]].	^installPaths! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 9/22/2004 20:22' prior: 34723610!allPathsDo: aBlock	"For all paths down the tree, evaluate aBlock."	^ self allPathsDo: aBlock trail: OrderedCollection new! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 9/22/2004 20:59' prior: 34723827!allPathsDo: aBlock trail: trail	"For all paths down the tree, evaluate aBlock."	trail add: self.	subAnalysises		ifNil: [			aBlock value: trail.]		ifNotNil: [			subAnalysises do: [:sub |				sub allPathsDo: aBlock trail: trail]].	trail removeLast! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 34724173!allRoutesDo: aBlock currentRoute: currentRoute level: level	"Recursively iterate over all routes down the tree."	| newLevel |	workingConfigurationsSize = level ifTrue: ["we reached the leaves"		workingConfigurations last do: [:conf | 			currentRoute addLast: conf.			aBlock value: currentRoute.			currentRoute removeLast].		^self].	newLevel := level + 1.	(workingConfigurations at: level) do: [:conf |		currentRoute addLast: conf.		self allRoutesDo: aBlock currentRoute: currentRoute level: newLevel.		currentRoute removeLast]! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 7/27/2004 15:36' prior: 34724808!alreadyInstallable	^alreadyInstallable	! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 7/27/2004 15:36' prior: 34724944!alreadyInstalled	^alreadyInstalled	! !!SMDependencyAnalysis methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 34725073!bestInstallPath	"Using some heuristics we suggest the best path:		- No conflicts		- Fewest releases		- If same packages, the newest releases"	| paths min points point package sc |	paths := self installPathsWithoutConflicts.	paths size = 1 ifTrue: [^paths first].	min := paths inject: 999 into: [:mi :p | p size < mi ifTrue: [p size] ifFalse: [mi]].	paths := paths select: [:p | p size = min].	paths size = 1 ifTrue: [^paths first].	"Try to pick the one with newest releases"	points := Dictionary new.	paths do: [:p |		point := 0.		p do: [:r |			package := r package.			paths do: [:p2 |				p2 == p ifFalse: [					(p2 anySatisfy: [:r2 |						(r2 package == package) and: [r newerThan: r2]])							ifTrue:[point := point + 1]]]].		points at: p put: point].	points isEmpty ifTrue: [^nil].	sc := points associations asSortedCollection: [:a :b | a value >= b value].	^ sc first key! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 34726066!collectCombinationsOfConfigurations	"Given the wanted releases, find and return all possible combinations	of working configurations for all those. Perhaps not possible to do	given lots of releases and configurations, then we need smarter algorithms."		"Pick out all working configurations first."	workingConfigurations := (trickyReleases collect: [:r | r workingConfigurations]) asOrderedCollection.	workingConfigurationsSize := workingConfigurations size.		"We iterate over all possible combinations of configurations	and collect the unique set of unordered configurations."	combinations := Set new.	self allRoutesDo: [:route |		combinations add: route asSet copy] currentRoute: OrderedCollection new level: 1! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 34726881!computeInstallSets	"Given all combinations of configurations, compute all valid combinations	of depdendency releases - all possible different Sets of required releases	to install before the trickyReleases can be installed."		"For each unique combination of configurations, collect all required releases	and produce a Set of unique required release combinations." 	suggestedInstallSetsSet := (combinations collect: [:comb |								comb inject: Set new into: [:set :conf |									set addAll: conf requiredReleases.									set ]]) asSet.	"Filter out those Sets that have multiple releases of the same package, they are conflicting	and thus not valid - we can't have two different releases of the same package	installed at the same time."		"conflictingInstallSetsSet := suggestedInstallSetsSet select:								[:set | self detectConflictingReleasesIn: set].	suggestedInstallSetsSet removeAll: conflictingInstallSetsSet"! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 34727907!detectConflictingReleasesIn: collectionOfReleases	"Detect if the Set has multiple releases of the same package."	| detectedPackages |	detectedPackages := Set new.	collectionOfReleases do: [:r |		(detectedPackages includes: r package)			ifTrue: [^ true]			ifFalse: [detectedPackages add: r package]].	^false! !!SMDependencyAnalysis methodsFor: 'printing' stamp: 'gk 9/21/2004 23:59' prior: 34728316!indent: level	^'                                                  '		last: level * 6! !!SMDependencyAnalysis methodsFor: 'calculation' stamp: 'gk 5/5/2006 02:07' prior: 34728498!installPackageReleases: packageReleases	"Given a Set of wanted SMPackageReleases, calculate all possible	installation scenarios. If the analysis succeeds, return true, otherwise false."		| result subAnalysis |	wantedReleases := packageReleases copy.	"First classify the releases in different groups."	self partitionReleases.		"If there are no tricky releases, we are already done.	No extra required releases needs to be installed or upgraded."	trickyReleases isEmpty ifTrue: [^success := true].	"Ok, that was the easy part. The releases left now needs to be processed	so that we can find out the different scenarios of required releases that we need	to install first. First we calculate all combinations of available working configurations	for the tricky releases."	self collectCombinationsOfConfigurations.		"Based on all configuration combinations,	compute possible combinations of dependency releases."	self computeInstallSets.		"Check if we have failed - meaning that there are no valid scenarios without conflicts."	suggestedInstallSetsSet isEmpty ifTrue: [^success := false].		"Ok, this means we have at least one solution *on this level*!! But we need to do the	analysis recursively for all these sets of required releases..."	subAnalysises := OrderedCollection new.	success := false.	suggestedInstallSetsSet do: [:set |		subAnalysis := SMDependencyAnalysis task: task.		result := subAnalysis installPackageReleases: set.		result ifTrue: [success := true].		subAnalysises add: subAnalysis].		"Did at least one succeed? If so, then we have at least one possible scenario!!	If not, then we need to do tweaking."	^success! !!SMDependencyAnalysis methodsFor: 'queries' stamp: 'gk 9/26/2004 23:44' prior: 34730254!installPathsWithConflicts	"Same as allInstallPaths, but we only return paths	with multiple releases of the same package."	^ self allInstallPaths select: [:path | self detectConflictingReleasesIn: path] ! !!SMDependencyAnalysis methodsFor: 'queries' stamp: 'gk 9/22/2004 23:32' prior: 34730553!installPathsWithoutConflicts	"Same as allInstallPaths, but we filter out paths	with multiple releases of the same package."	^ self allInstallPaths reject: [:path | self detectConflictingReleasesIn: path] ! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 34730853!partitionReleases	"Move releases from wantedReleases to suitable other collections	if they are either installed, trivial to install, or installable as is."		trickyReleases := wantedReleases copy.	alreadyInstalled := wantedReleases select: [:r | r isInstalled ].	trickyReleases removeAll: alreadyInstalled. 	trivialToInstall := trickyReleases select: [:r | r hasNoConfigurations ].	trickyReleases removeAll: trivialToInstall.			alreadyInstallable := trickyReleases select: [:r | r hasFulfilledConfiguration ].	trickyReleases removeAll: alreadyInstallable! !!SMDependencyAnalysis methodsFor: 'printing' stamp: 'gk 9/22/2004 22:44' prior: 34731510!printAllInstallPaths	"Follow all install paths in the tree."	^String streamContents: [:s |		self allInstallPaths do: [:path |			path do: [:rel |				s nextPutAll: rel packageNameWithVersion, ', '].			s cr]] ! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'md 12/22/2006 14:31' prior: 34731817!removeOlderReleasesIn: collectionOfReleases	"Remove older multiple releases of the same package.	2 scans to retain order."	| newestReleases rel |	newestReleases := Dictionary new.	collectionOfReleases do: [:r |		rel := newestReleases at: r package ifAbsentPut: [r].		(r newerThan: rel) ifTrue: [newestReleases at: r package put: r]].	^collectionOfReleases select: [:r |		(newestReleases at: r package) == r]! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 9/20/2004 22:59' prior: 34732329!success	^success	! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 34732442!task: ownerTask	task := ownerTask.	map := task map! !!SMDependencyAnalysis methodsFor: 'printing' stamp: 'gk 9/21/2004 23:49' prior: 34732588!treeString	"Return a indented String showing the tree	structure of all possible scenarios."	^String streamContents: [:s |		self treeStringOn: s indent: 0]! !!SMDependencyAnalysis methodsFor: 'printing' stamp: 'gk 5/5/2006 02:07' prior: 34732840!treeStringOn: stream indent: level	"Print the tree	structure of all possible scenarios."	| i |	i := self indent: level.	stream nextPutAll: i, 'Wanted:'; cr.	wantedReleases do: [:r |		stream nextPutAll: i ,'  ' , r packageNameWithVersion;cr].	stream nextPutAll: i, 'Tricky:'; cr.	trickyReleases do: [:r |		stream nextPutAll: i ,'  ' , r packageNameWithVersion;cr].	stream cr.	subAnalysises ifNotNil: [		subAnalysises do: [:sub | sub treeStringOn: stream indent: level + 1]]! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 7/28/2004 15:32' prior: 34733421!trickyReleases	^trickyReleases	! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 7/27/2004 15:36' prior: 34733549!trivialToInstall	^trivialToInstall	! !!SMDependencyAnalysis methodsFor: 'queries' stamp: 'gk 9/26/2004 23:47' prior: 34733679!untestedInstallPaths	"We take the paths with conflicts and remove the older releases."	^self installPathsWithConflicts collect: [:p |		 self removeOlderReleasesIn: p] ! !!SMDependencyAnalysis methodsFor: 'accessing' stamp: 'gk 7/27/2004 15:35' prior: 34733945!wantedReleases	^wantedReleases	! !!SMDependencyEngine commentStamp: '<historical>' prior: 34734048!A dependency engine is used to perform one or more installation, upgrade or uninstallation tasks.After creation it is typically configured according to different strategies, policies etc based on the preferences of the user.Then it is used to calculate what installations, uninstallations or upgrades are needed and in which order to reach certain stated goals, like installing a set of wanted packages or upgrading the installed packages.The engine instantiates different SMInstallationTask subclasses depending on what it should calculate.Todo: both the installation information for the image and the engine should probably be kept outside of the SMSqueakMap instance.!!SMDependencyEngine class methodsFor: 'instance creation' stamp: 'gk 7/29/2004 14:29' prior: 34734830!map: aMap	^ self new map: aMap! !!SMDependencyEngine methodsFor: 'tasks' stamp: 'gk 7/29/2004 15:59' prior: 34734951!installPackages: wantedPackages	"Given a Set of wanted SMPackages, create an installation task to compute	possible installation scenarios.	Returns an SMInstallationTask which can be further configured	and then be sent #calculate after which it can be queried for results."		^SMPackageInstallationTask engine: self wantedPackages: wantedPackages! !!SMDependencyEngine methodsFor: 'accessing' stamp: 'gk 7/29/2004 14:47' prior: 34735394!map	^map! !!SMDependencyEngine methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 34735495!map: aMap	map := aMap! !!SMFileCache commentStamp: 'gk 3/8/2004 20:10' prior: 34735585!A repository for SMSqueakMap downloads. This behaves like a Set, responding to add: and include:, but also package contents may be forcibly refreshed with download:.The SqueakMap determines what path the cache resides at. Within the cache, there is a 'packages' directory containing UUID-based directories for each package containing further directories for each release. A 'resources' directory stores UUID-based directories for each Resource, with the file stored within that by its original name. Because the cache follows a Set protocol, it can be automatically traversed within Smalltalk's collection protocol, avoiding manual hassles.!!SMFileCache class methodsFor: 'instance creation' stamp: 'gk 1/23/2004 10:21' prior: 34736325!newFor: aMap	"This is the default creation method, responsible for ensuring the	paths and such exist, and filling in defaults."	^self new forMap: aMap! !!SMFileCache methodsFor: 'services' stamp: 'gk 7/16/2004 11:04' prior: 34736565!add: aDownloadable 	"Conditionally download the downloadable object into the cache.	Return true on success, otherwise false."	^(self includes: aDownloadable)		ifTrue: [true]		ifFalse: [self download: aDownloadable]! !!SMFileCache methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 34736868!cacheUrlFor: aDownloadable	"Find a cache URL for this downloadable.	Returns nil if no server is available.	Could use #relativeUrl also."	| server |	server := aDownloadable map class findServer.	server ifNil: [^ nil].	^'http://', server, '/object/', aDownloadable id asString, '/cache'! !!SMFileCache methodsFor: 'services' stamp: 'gk 4/19/2006 01:31' prior: 34737245!contents: anSMObject	"Return contents of the file for the object	or nil if not in cache."	anSMObject isCached		ifTrue: [^(anSMObject cacheDirectory readOnlyFileNamed: anSMObject downloadFileName) binary; contentsOfEntireFile]		ifFalse: [^nil]		! !!SMFileCache methodsFor: 'accessing' stamp: 'gk 1/23/2004 10:26' prior: 34737582!directory	^map packageCacheDirectory! !!SMFileCache methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34737717!directoryForPackage: aPackage	"Returns the local path for storing the package cache's package file area.	This also ensures that the path exists."	| slash path dir |	slash := FileDirectory slash.	path := 'packages' , slash , aPackage id asString36 , slash.	dir := FileDirectory default on: self directory fullName, slash, path.	dir assureExistence.	^dir! !!SMFileCache methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34738176!directoryForPackageRelease: aPackageRelease	"Returns the local path for storing the package cache's version of a  	package file. This also ensures that the path exists."	| slash path dir |	slash := FileDirectory slash.	path := 'packages' , slash , aPackageRelease package id asString36 , slash , aPackageRelease automaticVersionString.	dir := FileDirectory default on: self directory fullName, slash, path.	dir assureExistence.	^dir! !!SMFileCache methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34738715!directoryForResource: aResource	"Returns the local path for storing the package cache's version of a  	resource file. This also ensures that the path exists."	| slash path dir |	slash := FileDirectory slash.	path := 'resources' , slash , aResource id asString36.	dir := FileDirectory default on: self directory fullName, slash, path.	dir assureExistence.	^dir! !!SMFileCache methodsFor: 'services' stamp: 'gk 5/5/2006 02:07' prior: 34739167!download: aDownloadable 	"Download the file for this SMObject into the local file cache.	If the file already exists, delete it.	No unpacking or installation into the running image."	| stream file fileName dir |	[fileName := aDownloadable downloadFileName.	fileName		ifNil: [self inform: 'No download url, can not download.'.			^ false].	fileName isEmpty		ifTrue: [self inform: 'Download url lacks filename, can not download.'.			^ false].	dir := aDownloadable cacheDirectory.	[stream := self getStream: aDownloadable.	stream ifNil: [^ false].	(dir fileExists: fileName)		ifTrue: [dir deleteFileNamed: fileName].	file := dir newFileNamed: fileName.	file binary; nextPutAll: stream contents]		ensure: [file ifNotNil: [file close]]]		on: Error		do: [^ false].	^ true! !!SMFileCache methodsFor: 'initialize' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34740052!forMap: aMap	"Initialize the ache, make sure the cache dir exists."	map := aMap! !!SMFileCache methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 34740217!getStream: aDownloadable 	"Get the stream, either from the original url	or if that fails, from the server cache - unless	this is the actual server of course. :)	We also verify that the sha1sum is correct."	| stream |	[stream := aDownloadable downloadUrl asUrl retrieveContents contentStream binary.	(aDownloadable correctSha1sum: stream contents)		ifFalse: [self error: 'Incorrect SHA checksum of file from orginal URL']]		on: Exception do: [:ex |			Transcript show: 'Download from original url (', aDownloadable downloadUrl, ') failed with this exception: ', ex messageText;cr.			SMUtilities isServer				ifTrue: [^nil]				ifFalse: [					Transcript show: 'Trying server cache instead.'; cr.					[stream := (self cacheUrlFor: aDownloadable) asUrl retrieveContents contentStream binary.					(stream contents size = 21 and: [stream contents asString = 'SMFILEMISSINGONSERVER'])						ifTrue: [self error: 'File missing in server cache'].					(stream contents size = 24 and: [stream contents asString = 'SMRELEASENOTDOWNLOADABLE'])						ifTrue: [self error: 'Release not downloadable'].					(aDownloadable correctSha1sum: stream contents)						ifFalse: [self error: 'Incorrect SHA checksum of file from server']]							on: Exception do: [:ex2 | | msg |								msg := 'Download from server cache of ', aDownloadable printName, ' failed with this exception: ', ex2 messageText.								Transcript show: msg; cr.								self error: msg]]].	^ stream! !!SMFileCache methodsFor: 'services' stamp: 'gk 7/16/2004 11:10' prior: 34741768!includes: anSMObject	"Check if the cache holds the file for the object."		^(anSMObject cacheDirectory)		fileExists: anSMObject downloadFileName! !!SMFileCache methodsFor: 'accessing' stamp: 'btr 5/27/2003 16:24' prior: 34742002!map	^ map! !!SMInstallationDeviation commentStamp: '<historical>' prior: 34742087!An installation deviation is when the user decides to install or upgrade to a release that is newer than one or more used configurations specify.This means that the other installed releases which configurations will be broken may not work correctly.Instvar selectedRelease refers to the release selected to install, brokenConfigurations is a collection of all configurations that need another release of this package.!!SMInstallationDeviation class methodsFor: 'instance creation' stamp: 'gk 10/13/2004 00:51' prior: 34742617!selectedRelease: release releases: releases	^self new selectedRelease: release releases: releases! !!SMInstallationDeviation methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 34742812!otherReleases	| package |	package := selectedRelease package.	^ brokenConfigurations collect: [:conf |		conf releases detect: [:r | r package == package]]! !!SMInstallationDeviation methodsFor: 'accessing' stamp: 'gk 10/4/2004 11:14' prior: 34743068!selectedRelease	^ selectedRelease! !!SMInstallationDeviation methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 34743208!selectedRelease: aRelease releases: releases	| p others otherRequired |	selectedRelease := aRelease.	p := selectedRelease package.	brokenConfigurations := OrderedCollection new.	others := releases copyWithout: aRelease.	others := others select: [:r | r package ~= p].	others do: [:rel |		rel workingConfigurations do: [:conf |			otherRequired := conf requiredReleases select: [:r | r package ~= p].			((others includesAllOf: otherRequired) and:				[(conf requiredReleases includes: selectedRelease) not])					ifTrue: [brokenConfigurations add: conf]]]! !!SMInstallationProposal commentStamp: '<historical>' prior: 34743846!This is primarily an ordered list of package release installations or upgrades to achieve a given installation task.!!SMInstallationProposal class methodsFor: 'instance creation' stamp: 'gk 10/1/2004 10:01' prior: 34744072!installList: anOrderedCollection	^ self new installList: anOrderedCollection! !!SMInstallationProposal methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 34744254!calculateComment	comment := ''! !!SMInstallationProposal methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 34744391!calculateDeviations	"Calculate deviations. Currently we just pick the newest release."	| conflicts newest |	deviations := OrderedCollection new.	conflicts := self collectConflictsIn: installList.	conflicts keysAndValuesDo: [:package :releases |		newest := releases first.		releases do: [:r | (r newerThan: newest) ifTrue: [newest := r]].		deviations add: (SMInstallationDeviation selectedRelease: newest releases: installList)]! !!SMInstallationProposal methodsFor: 'initialize-release' stamp: 'md 12/22/2006 14:30' prior: 34744934!collectConflictsIn: collectionOfReleases	"Collect all conflicts where there are either		- multiple releases of the same package and/or		- another release of the same package already installed	Return the conflicts as an IdentityDictionary with	the package as key and the value being a Set of releases."	| conflicts set |	conflicts := IdentityDictionary new.	collectionOfReleases do: [:r |		set := conflicts at: r package ifAbsentPut: [OrderedCollection new].		set add: r].	"Add the installed releases too"	conflicts keysAndValuesDo: [:key :value |		key isInstalled ifTrue: [value add: key installedRelease]].	"Prune release sets with only one member"	^conflicts select: [:releaseSet | releaseSet size > 1]! !!SMInstallationProposal methodsFor: 'initialize-release' stamp: 'gk 10/13/2004 01:26' prior: 34745761!hasDeviations	^ deviations notEmpty! !!SMInstallationProposal methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 34745902!installList: anOrderedCollection	installList := anOrderedCollection.	self calculateDeviations.	self calculateComment! !!SMInstallationRegistry commentStamp: '<historical>' prior: 34746096!A registry instance keeps track of installations into an image. Typically used by the SMSqueakMap instance when installing package releases.!!SMInstallationRegistry class methodsFor: 'instance creation' stamp: 'gk 8/1/2004 17:42' prior: 34746344!map: aMap	"Create a new registry and make it use the given map."	^self new map: aMap! !!SMInstallationRegistry methodsFor: 'queries' stamp: 'gk 8/1/2004 17:51' prior: 34746525!clearInstalledPackageWithId: aPackageId	"Clear the fact that any release of this package is installed.	Can be used even when the map isn't loaded."	^installedPackages ifNotNil: [		installedPackages removeKey: (UUID fromString: aPackageId) ifAbsent: [nil]]! !!SMInstallationRegistry methodsFor: 'services' stamp: 'gk 5/5/2006 02:07' prior: 34746880!clearInstalledPackages	"Simply clear the dictionary with information on installed packages.	Might be good if things get corrupted etc. Also see	SMSqueakMap class>>recreateInstalledPackagesFromChangeLog"	installedPackages := nil.	installCounter := 0! !!SMInstallationRegistry methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 34747228!countInstall	"Increase the install counter."	installCounter ifNil: [installCounter := 0].	^installCounter := installCounter + 1! !!SMInstallationRegistry methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 34747456!installCounter: anInteger	"Set counter directly."	installCounter := anInteger! !!SMInstallationRegistry methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 34747630!installedPackages	"Answer all packages that we know are installed.	Lazily initialize. The Dictionary contains the installed packages	using their UUIDs as keys and the version string as the value."	| result p |	result := OrderedCollection new.	installedPackages ifNil: [^#()]		ifNotNil: [installedPackages keys					do: [:k |						p := map object: k.						p ifNotNil: [result add: p]]].	^result! !!SMInstallationRegistry methodsFor: 'accessing' stamp: 'gk 8/1/2004 17:44' prior: 34748130!installedPackagesDictionary	"Access the dictionary directly. The UUID of the installed package is the key.	The value is an OrderedCollection of Arrays.	The arrays have the smartVersion of the package, the time of the	installation in seconds and the sequence number (installCounter)."	^installedPackages ifNil: [Dictionary new]! !!SMInstallationRegistry methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 34748558!installedPackagesDictionary: aDict	"Set dictionary directly."	installedPackages := aDict! !!SMInstallationRegistry methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 34748743!installedReleaseOf: aPackage	"If the package is installed, return the release.	Otherwise return nil. SM2 stores the version as	an Association to be able to distinguish it."	| autoVersionOrOld |	installedPackages ifNil: [^nil].	autoVersionOrOld := (installedPackages at: aPackage id ifAbsent: [^nil]) last first.	(autoVersionOrOld isKindOf: Association)		ifTrue: [			^aPackage releaseWithAutomaticVersion: autoVersionOrOld value]		ifFalse: [			^aPackage releaseWithVersion: autoVersionOrOld]! !!SMInstallationRegistry methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 34749339!installedVersionOf: aPackage	"If the package is installed, return the version as a String.	If it is a package installed during SM1 it will return the manual version String,	for SM2 it returns the automatic version as a String.	If package is not installed - return nil. If you want it to work without the map loaded you	should instead use #installedVersionOfPackageWithId:."	| versionOrString |	versionOrString := self installedVersionOfPackageWithId: aPackage id.	versionOrString ifNil: [^nil].	^versionOrString isString		ifTrue: [versionOrString]		ifFalse: [versionOrString versionString]! !!SMInstallationRegistry methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 34750034!installedVersionOfPackageWithId: anId	"If the package is installed, return the automatic version or version String.	Otherwise return nil. This can be used without the map loaded."	| autoVersionOrOld |	installedPackages ifNil: [^nil].	autoVersionOrOld := (installedPackages at: anId ifAbsent: [^nil]) last first.	(autoVersionOrOld isKindOf: Association)		ifTrue: [			^autoVersionOrOld value]		ifFalse: [			^autoVersionOrOld]! !!SMInstallationRegistry methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 34750564!map: aMap	map := aMap! !!SMInstallationRegistry methodsFor: 'private' stamp: 'md 12/22/2006 14:30' prior: 34750683!markInstalled: uuid version: version time: time counter: num	"Private. Mark the installation. SM2 uses an Association	to distinguish the automatic version from old versions."	| installs |	installedPackages ifNil: [installedPackages := Dictionary new].	installs := installedPackages at: uuid ifAbsentPut: [OrderedCollection new].	installs add:		(Array with: 2->version				with: time				with: num)! !!SMInstallationRegistry methodsFor: 'installation-changelog' stamp: 'gk 5/5/2006 02:07' prior: 34751198!noteInstalledPackage: uuidString version: version	"Mark a specific version of a package as installed.	This method is called when replaying a logged installation	from before SqueakMap 1.07. Such logged installations lacked	a timestamp and a count. We take the current time and a	count starting from -10000 and upwards. This should keep	the sorting order correct."	"Find the lowest installed count."	| lowest |	lowest := 0.	installedPackages ifNotNil: [		installedPackages valuesDo: [:oc |			oc do: [:array |				array last < lowest ifTrue: [lowest := array last]]]]		ifNil: [lowest := -10000].	lowest negative ifFalse: [lowest := -10000].	^self noteInstalledPackage: uuidString version: version		atSeconds: Time totalSeconds number: lowest + 1! !!SMInstallationRegistry methodsFor: 'installation-changelog' stamp: 'gk 5/5/2006 02:07' prior: 34752066!noteInstalledPackage: uuidString version: version atSeconds: time number: num	"Mark a package as installed in the Dictionary.	This method is called when replaying a logged installation.	<time> is the point in time as totalSeconds of the installation.	<num> is the installCount of the installation.	This method is typically called from a doIt in the changelog	in order to try to keep track of packages installed."	num negative ifFalse: ["Not an emulated count from prior SM1.07"		installCounter := num max: installCounter].	self markInstalled: (UUID fromString: uuidString) version: version time: time counter: num! !!SMInstallationRegistry methodsFor: 'installation-changelog' stamp: 'gk 5/5/2006 02:07' prior: 34752798!noteInstalledPackageWithId: uuidString autoVersion: version atSeconds: time number: num	"Mark a package as installed in the Dictionary.	This method is called when replaying a logged installation.	<time> is the point in time as totalSeconds of the installation.	<num> is the installCount of the installation.	This method is typically called from a doIt in the changelog	in order to try to keep track of packages installed."	num negative ifFalse: ["Not an emulated count from prior SM1.07"		installCounter := num max: installCounter].	self markInstalled: (UUID fromString: uuidString) version: version time: time counter: num! !!SMInstallationRegistry methodsFor: 'installation' stamp: 'gk 5/5/2006 02:07' prior: 34753530!noteInstalledPackageWithId: aPackageId autoVersion: aVersion name: aName	"The package release was just successfully installed.	Can be used to inform SM of an installation not been	done using SM, even when the map isn't loaded.	We record the fact in our Dictionary of installed packages	and log a 'do it' to mark this in the changelog.	The doit helps keeping track of the packages when	recovering changes etc - not a perfect solution but should help.	The map used is the default map.	The id of the package is the key and the value is an OrderedCollection	of Arrays with the release auto version, the point in time and the current installCounter."	| time name id v |	v := aVersion isString ifTrue: [aVersion asVersion] ifFalse: [aVersion].	aName ifNil: [name := '<unknown package name>'] ifNotNil: [name := aName].	id := UUID fromString: aPackageId.	time := Time totalSeconds.	self countInstall.	self markInstalled: id version: v time: time counter: installCounter.	(((Smalltalk classNamed: 'SmalltalkImage') ifNotNilDo: [:si | si current]) ifNil: [Smalltalk])		logChange: '"Installed ', name, ' auto version ', v versionString, '".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: ', id asString storeString, ' autoVersion: ', v storeString, ' atSeconds: ', time asString, ' number: ', installCounter asString, ']'! !!SMInstallationRegistry methodsFor: 'installation' stamp: 'gk 5/5/2006 02:07' prior: 34755008!noteUninstalledPackageWithId: aPackageId autoVersion: aVersion name: aName	"The package release was just successfully uninstalled.	Can be used to inform SM of an uninstallation not been	done using SM, even when the map isn't loaded.	We record the fact in our Dictionary of installed packages	and log a 'do it' to mark this in the changelog.	The doit helps keeping track of the packages when	recovering changes etc - not a perfect solution but should help.	The map used is the default map.	The id of the package is the key and the value is an OrderedCollection	of Arrays with the release auto version, the point in time and the current installCounter."	| time name id v |	v := aVersion isString ifTrue: [aVersion asVersion] ifFalse: [aVersion].	aName ifNil: [name := '<unknown package name>'] ifNotNil: [name := aName].	id := UUID fromString: aPackageId.	time := Time totalSeconds.	self countInstall. "Used for both installs and uninstalls"	self clearInstalled: id version: v time: time counter: installCounter.	(((Smalltalk classNamed: 'SmalltalkImage') ifNotNilDo: [:si | si current]) ifNil: [Smalltalk])		logChange: '"Uninstalled ', name, ' auto version ', v versionString, '".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteUninstalledPackageWithId: ', id asString storeString, ' autoVersion: ', v storeString, ' atSeconds: ', time asString, ' number: ', installCounter asString, ']'! !!SMInstallationTask commentStamp: '<historical>' prior: 34756508!An SMInstallationProposal is effectively a list of releases to install or upgrade to in a specific order to achieve an SMInstallationTask.The task can be either an upgrade or a new installation - the proposal still involved an ordered list of installations or upgrades.!!SMInstallationTask methodsFor: 'calculation' stamp: 'gk 9/20/2004 20:49' prior: 34756872!calculate	"Calculate how the task should be performed.	After calculation the task can be inspected and presented	to the user for confirmation. Actually performing the task	is done by #execute."		self subclassResponsibility ! !!SMInstallationTask methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 34757193!engine: anEngine	engine := anEngine.	map := engine map! !!SMInstallationTask methodsFor: 'calculation' stamp: 'gk 9/20/2004 20:49' prior: 34757344!execute	"Actually perform the task."	self subclassResponsibility ! !!SMInstallationTask methodsFor: 'accessing' stamp: 'gk 7/29/2004 14:48' prior: 34757505!map	^map! !!SMPackageInstallationTask commentStamp: '<historical>' prior: 34757591!A package installation task is to install one or more given SMPackages (not specified releases) into the image.First it tries to calculate the ideal releases of the given packages that it will try to install given the policy and preferences set by the user. Then it runs an analysis to find how to install those wanted releases. This typically results in zero, one or more possible scenarios.!!SMPackageInstallationTask class methodsFor: 'instance creation' stamp: 'gk 7/29/2004 12:37' prior: 34758098!engine: engine wantedPackages: wantedPackages	^self new engine: engine; wantedPackages: wantedPackages! !!SMPackageInstallationTask methodsFor: 'queries' stamp: 'gk 9/22/2004 22:47' prior: 34758299!allInstallPaths	"Return all different ways to install - the ones requested plus all dependencies.	This includes ways where different releases of the same package are combined."	^analysis allInstallPaths! !!SMPackageInstallationTask methodsFor: 'accessing' stamp: 'gk 9/20/2004 20:50' prior: 34758605!analysis	"Return the analysis of the task."	^analysis! !!SMPackageInstallationTask methodsFor: 'calculation' stamp: 'gk 5/5/2006 02:07' prior: 34758762!calculate	"First calculate the wanted releases. Then perform a dependency analysis.	We return the most basic result of the analysis - does there exist at least one	working installation scenario without tweaks?"	self calculateWantedReleases.	analysis := SMDependencyAnalysis task: self.	analysis installPackageReleases: wantedReleases.	^analysis success! !!SMPackageInstallationTask methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 34759219!calculateWantedReleases	"The user gave us wanted packages.	We need to figure out which actual releases of those	we should try to install."	| rel |	wantedReleases := Set new.	wantedPackages do: [:p | rel := self idealReleaseFor: p.		rel ifNotNil: [wantedReleases add: rel]]! !!SMPackageInstallationTask methodsFor: 'private' stamp: 'gk 9/20/2004 20:51' prior: 34759597!idealReleaseFor: aPackage	"Return the most suitable release to install for <aPackage>."	^ aPackage lastPublishedReleaseForCurrentSystemVersion! !!SMPackageInstallationTask methodsFor: 'queries' stamp: 'gk 10/1/2004 10:06' prior: 34759840!proposals	"Return all different possible proposals to install	sorted with the best proposal first."	^analysis allNormalizedInstallPaths collect: [:path | SMInstallationProposal installList: path]! !!SMPackageInstallationTask methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 34760138!wantedPackages: packages	wantedPackages := packages! !!SMPackageUpgradeTask commentStamp: '<historical>' prior: 34760263!A package upgrade task is to upgrade one or more given SMPackages (not specified releases) in the image to newer releases.First it tries to calculate the newest available releases of the given packages that it will try to upgrade given the policy and preferences set by the user. Then it runs an analysis to find how to upgrade to those wanted releases. This typically results in zero, one or more possible scenarios.!!SMInstaller commentStamp: '<historical>' prior: 34760744!An installer takes care of installing SqueakMap packages represented by SMCards.Deciding if a package is installable and instantiating the correct installer class is done on the class side, see implementors of #canInstall:. Two methods need to be implemented by subclasses - download and install. Upgrade can also be specialized by implementing #upgrade, otherwise it will default to #install.!!SMInstaller class methodsFor: 'changeset utilities' stamp: 'pk 10/17/2006 09:43' prior: 34761239!basicNewChangeSet: newName 	"This method copied here to ensure SqueakMap is independent of 	ChangesOrganizer. "	Smalltalk		at: #ChangesOrganizer		ifPresentAndInMemory: [:cs | ^ cs basicNewChangeSet: newName].	(self changeSetNamed: newName)		ifNotNil: [self error: 'The name ' , newName , ' is already used'].	^ ChangeSet basicNewNamed: newName! !!SMInstaller class methodsFor: 'testing' stamp: 'gk 11/16/2003 23:49' prior: 34761681!canInstall: aPackageRelease	"Nope, I am an abstract class and can not install anything.	But my subclasses should reimplement this."	^ false! !!SMInstaller class methodsFor: 'changeset utilities' stamp: 'pk 10/17/2006 09:43' prior: 34761927!changeSetNamed: newName	"This method copied here to ensure SqueakMap is independent of ChangesOrganizer."	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs changeSetNamed: newName ].	^ChangeSet allInstances detect: [ :cs | cs name = newName ] ifNone: [ nil ].! !!SMInstaller class methodsFor: 'instance creation' stamp: 'gk 11/16/2003 23:33' prior: 34762307!classForPackageRelease: aPackageRelease	"Decide which subclass to instantiate. 	We detect and return the first subclass	that wants to handle the release going	recursively leaf first so that subclasses gets	first chance if several classes compete over	the same packages, like for example SMDVSInstaller	that also uses the .st file extension."	self subclasses do: [:ea |		(ea classForPackageRelease: aPackageRelease)			ifNotNilDo: [:class | ^ class]].	^(self canInstall: aPackageRelease)		ifTrue: [self]! !!SMInstaller class methodsFor: 'deprecated' stamp: 'gk 5/5/2006 02:07' prior: 34762913!forPackageRelease: aPackageRelease	"Instantiate the first class suitable to install the package release.	If no installer class is found we raise an Error."	| class |	aPackageRelease ifNil: [self error: 'No package release specified to find installer for.'].	class := self classForPackageRelease: aPackageRelease.	^class		ifNil: [self error: 'No installer found for package ', aPackageRelease name, '.']		ifNotNil: [class new packageRelease: aPackageRelease]! !!SMInstaller class methodsFor: 'testing' stamp: 'gk 11/16/2003 23:50' prior: 34763470!isInstallable: aPackageRelease	"Detect if any subclass can handle the package release."	aPackageRelease ifNil: [^false].	^(self classForPackageRelease: aPackageRelease) notNil! !!SMInstaller class methodsFor: 'testing' stamp: 'gk 11/16/2003 23:49' prior: 34763740!isUpgradeable: aPackageRelease	"Detect if any subclass can handle the release.	Currently we assume that upgrade is the same as install."	^self isInstallable: aPackageRelease! !!SMInstaller methodsFor: 'services' stamp: 'gk 11/16/2003 21:56' prior: 34764003!download	"This service should bring the package release to	the client and also unpack it on disk if needed.	It will not install it into the running image though.	Raises errors if operation does not succeed."	self subclassResponsibility ! !!SMInstaller methodsFor: 'services' stamp: 'gk 11/16/2003 21:57' prior: 34764332!install	"This service should bring the package release to the client,	unpack it if necessary and install it into the image.	The package release should be notified of the installation using	'packageRelease noteInstalled'."	self subclassResponsibility ! !!SMInstaller methodsFor: 'testing' stamp: 'gk 11/23/2005 00:06' prior: 34764673!isCached	"Check if it is in the cache."	^packageRelease isCached! !!SMInstaller methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34764838!packageRelease: aPackageRelease	packageRelease := aPackageRelease! !!SMInstaller methodsFor: 'private' stamp: 'gk 7/13/2004 02:43' prior: 34764988!silent	"Can we ask questions?"		^packageRelease ifNotNil: [packageRelease map silent] ifNil: [false]! !!SMInstaller methodsFor: 'services' stamp: 'gk 7/14/2004 15:38' prior: 34765176!upgrade	"This service performs an upgrade to the selected release.	Currently it just defaults to the same operation as an install -	which is handled fine by Monticello, but not necessarily for	other formats."	^self install! !!SMSimpleInstaller commentStamp: '<historical>' prior: 34765473!This is a base class that you can subclass if your package format can be downloaded usinga single file url and possibly also be decompressed using gzip.!!SMDefaultInstaller commentStamp: '<historical>' prior: 34765694!An installer takes care of installing SqueakMap packages represented by SMCards.This installer handles packages that consist of classical fileins (single changesets and .st-files) and optional gzip-decompression of those. Deciding if a package is installable and instantiating the correct installer class is done on the class side in SMInstaller, to see how this installer gets chosen - see SMDefaultInstaller class>>canInstall:.!!SMDVSInstaller commentStamp: '<historical>' prior: 34766190!This is an installer class for DVS packages. It handles packages categorized with packageformat as DVS and with a download filename with extensions .st or .st.gz.This class can function without DVS installed, needed classes are looked up dynamically.!!SMDVSInstaller class methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34766546!canInstall: aPackage	"Can I install this? First we check if class StreamPackageLoader	is available, otherwise DVS isn't installed.	Then we check if the package is categorized with package	format DVS - currently we have hardcoded the id of that category."	| fileName |	Smalltalk at: #StreamPackageLoader ifPresentAndInMemory: [ :loader |		fileName := aPackage downloadFileName.		fileName ifNil: [^false].		fileName := fileName asLowercase.		^((fileName endsWith: '.st') or: [fileName endsWith: '.st.gz'])			and: [aPackage categories includes: "The DVS format category"					(SMSqueakMap default						categoryWithId: 'b02f51f4-25b4-4117-9b65-f346215a8e41')]].	^false! !!SMDVSInstaller class methodsFor: 'loading' stamp: 'gk 10/1/2003 13:51' prior: 34767317!loadDVS	"Load the DVS package from SqueakMap."	SMSqueakMap default installPackageWithId: '100d59d0-bf81-4e74-a4fe-5a2fd0c6b4ec'! !!SMDVSInstaller methodsFor: 'services' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34767547!install	"Install using DVS."	| imagePackageLoader streamPackageLoader packageInfo packageManager baseName current new manager |	self cache; unpack.	imagePackageLoader := Smalltalk at: #ImagePackageLoader ifAbsent: [].	streamPackageLoader := Smalltalk at: #StreamPackageLoader ifAbsent: [].	packageInfo := Smalltalk at: #PackageInfo ifAbsent: [].	packageManager := Smalltalk at: #FilePackageManager ifAbsent: [].	({ imagePackageLoader. streamPackageLoader. packageInfo. packageManager } includes: nil)		ifTrue: [ (self confirm: ('DVS support is not loaded, but would be helpful in loading ', unpackedFileName, '.It isn''t necessary, but if you intend to use DVS later it would be a good idea to load it now.Load it from SqueakMap?'))			ifTrue: [ self class loadDVS. ^self install ]			ifFalse: [ ^self fileIn ]].	baseName := packageRelease name.	dir rename: unpackedFileName toBe: (baseName, '.st').	unpackedFileName := baseName, '.st'.	(manager := packageManager allManagers detect: [ :pm | pm packageName = baseName ] ifNone: [])		ifNotNil: [			current := imagePackageLoader new package: (packageInfo named: baseName).			new := streamPackageLoader new stream: (dir readOnlyFileNamed: unpackedFileName).			(new changesFromBase: current) fileIn ]		ifNil: [			self fileIn.			manager := packageManager named: baseName. ].	manager directory: dir.	packageManager changed: #allManagers.	packageRelease noteInstalled! !!SMDefaultInstaller class methodsFor: 'testing' stamp: 'gk 3/31/2006 09:59' prior: 34769084!canInstall: aPackage	"Answer if this class can install/upgrade the package.	This installer handles .st, .cs, .mst, .mcs (Squeak 3.9+)	with or without .gz suffix."	| fileName |	fileName := aPackage downloadFileName.	fileName ifNil: [^false].	fileName := fileName asLowercase.	^self sourceFileSuffixes anySatisfy: [:each | 			(fileName endsWith: (FileDirectory dot, each)) or: [				fileName endsWith: (FileDirectory dot, each, '.gz')]]! !!SMDefaultInstaller class methodsFor: 'private' stamp: 'gk 3/31/2006 10:05' prior: 34769625!multiSuffixes	"Unfortunately we can not tell which suffixes use multibyte encoding.	So we guess that they begin with $m."	^self sourceFileSuffixes select: [:suff | suff first = $m]! !!SMDefaultInstaller class methodsFor: 'private' stamp: 'gk 3/31/2006 10:06' prior: 34769906!nonMultiSuffixes	"Unfortunately we can not tell which suffixes use multibyte encoding.	So we guess that they begin with $m."	^self sourceFileSuffixes reject: [:suff | suff first = $m]! !!SMDefaultInstaller class methodsFor: 'private' stamp: 'gk 3/31/2006 09:59' prior: 34770190!sourceFileSuffixes	"Trying to play nice with all Squeak versions."	^(FileStream respondsTo: #sourceFileSuffixes)			ifTrue: [FileStream sourceFileSuffixes]			ifFalse: [#(cs st)].! !!SMDefaultInstaller methodsFor: 'private' stamp: 'KLC 4/27/2007 17:31' prior: 34770464!fileIn	"Installing in the standard installer is simply filing in.	Both .st and .cs files will file into a ChangeSet of their own.	We let the user confirm filing into an existing ChangeSet	or specify another ChangeSet name if	the name derived from the filename already exists."		| fileStream |	(self class nonMultiSuffixes anySatisfy: [:each | unpackedFileName endsWith: (FileDirectory dot, each)])		ifTrue:[			fileStream := dir readOnlyFileNamed: unpackedFileName.			(fileStream respondsTo: #setConverterForCode) ifTrue: [fileStream setConverterForCode].			self fileIntoChangeSetNamed: (fileStream localName sansPeriodSuffix) fromStream: fileStream.			^self].	(self class multiSuffixes anySatisfy: [:each | unpackedFileName endsWith: (FileDirectory dot, each)])		ifTrue:[			fileStream := dir readOnlyFileNamed: unpackedFileName.			"Only images with converters should have multi suffixes"			fileStream converter: (Smalltalk at: #UTF8TextConverter) new.			self fileIntoChangeSetNamed: (fileStream localName sansPeriodSuffix) fromStream: fileStream.			^self].	self error: 'Filename should end with a proper extension'.! !!SMDefaultInstaller methodsFor: 'services' stamp: 'gk 11/16/2003 20:52' prior: 34771694!install	"This service should bring the package to the client,	unpack it if necessary and install it into the image.	The package is notified of the installation."	self cache; unpack; fileIn.	packageRelease noteInstalled! !!SMLanguageInstaller class methodsFor: 'testing' stamp: 'gk 3/31/2006 00:22' prior: 34772017!canInstall: aPackage	"Answer if this class can install the package.	We handle .translation files optionally compressed."	| fileName |	((Smalltalk includesKey: #Language)		or: [Smalltalk includesKey: #NaturalLanguageTranslator]) ifFalse: [^false].	fileName := aPackage downloadFileName.	fileName ifNil: [^false].	fileName := fileName asLowercase.	^(fileName endsWith: '.translation') or: [		(fileName endsWith: '.tra') or: [			(fileName endsWith: '.tra.gz') or: [				fileName endsWith: '.translation.gz']]]! !!SMLanguageInstaller methodsFor: 'services' stamp: 'gk 3/31/2006 00:23' prior: 34772628!install	"This service should bring the package to the client, 	unpack it if necessary and install it into the image. 	The package is notified of the installation."	| translator |	self cache; unpack.	translator := Smalltalk at: #Language ifAbsent: [Smalltalk at: #NaturalLanguageTranslator].	[translator mergeTranslationFileNamed: unpackedFileName]			ensure: [packageRelease noteInstalled]! !!SMMcInstaller commentStamp: 'gk 10/8/2003 14:28' prior: 34773096!I am a SMInstaller that knows how to install .mcz (Monticello) files. If Monticello is installed I use that (MCMczReader), otherwise I file in the code more simply using the package MCInstaller (MczInstaller).!!SMMcInstaller class methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34773407!canInstall: aPackage	"Is this a Monticello package and do I have MCInstaller	or Monticello available?"	| fileName |	((Smalltalk includesKey: #MCMczReader) or: [		 Smalltalk includesKey: #MczInstaller])			ifTrue: [				fileName := aPackage downloadFileName.				fileName ifNil: [^false].				^ 'mcz' = (FileDirectory extensionFor: fileName) asLowercase].	^false! !!SMMcInstaller methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34773873!fileIn	| extension |	extension := (FileDirectory extensionFor: fileName) asLowercase.	extension = 'mcz'		ifTrue: [self installMcz]		ifFalse: [self error: 'Cannot install file of type .', extension]! !!SMMcInstaller methodsFor: 'private' stamp: 'ab 8/8/2003 18:33' prior: 34774160!fullFileName 	^ dir fullNameFor: fileName! !!SMMcInstaller methodsFor: 'services' stamp: 'gk 11/16/2003 21:55' prior: 34774290!install	"This service should bring the package to the client,	unpack it if necessary and install it into the image.	The package is notified of the installation."	self cache; fileIn.	packageRelease noteInstalled! !!SMMcInstaller methodsFor: 'private' stamp: 'gk 7/13/2004 02:44' prior: 34774592!installMcz	"Install the package, we already know that either MCInstaller or Monticello is available."	| installer monticello |	installer := MczInstaller.	(Smalltalk hasClassNamed: #MCMczReader) ifFalse: [		packageRelease package isInstalled ifTrue: [			(self silent ifFalse: [				(self confirm:'A release of package ''', packageRelease package name, ''' is already installed.You only have MCInstaller and not Monticelloinstalled and MCInstaller can not properly upgrade packages.Do you wish to install Monticello first and then proceed?If you answer no MCInstaller will be used - but at your own risk.Cancel cancels the installation.' orCancel: [self error: 'Installation cancelled.'])]			ifTrue: [false])				ifTrue: [					monticello := packageRelease map packageWithName: 'Monticello'.					monticello lastPublishedRelease						ifNotNil: [monticello lastPublishedRelease install]						ifNil: [monticello lastRelease install].					installer := (Smalltalk at: #MCMczReader)]]	] ifTrue: [installer := (Smalltalk at: #MCMczReader)].	installer loadVersionFile: self fullFileName! !!SMProjectInstaller commentStamp: '<historical>' prior: 34775758!I am a SMInstaller that knows how to install .pr (Project) files.!!SMProjectInstaller class methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34775930!canInstall: aPackage	"Answer if this class can install the package.	We handle .pr files (upper and lowercase)"	| fileName |	fileName := aPackage downloadFileName.	fileName ifNil: [^false].	^'pr' = (FileDirectory extensionFor: fileName) asLowercase! !!SMProjectInstaller methodsFor: 'services' stamp: 'gk 11/16/2003 21:55' prior: 34776277!install	"This service should bring the package to the client, 	unpack it if necessary and install it into the image. 	The package is notified of the installation."	Project canWeLoadAProjectNow ifFalse: [self error: 'Can not load Project now, probably because not in Morphic.'].	self cache.	[[ ProjectLoading openFromDirectory: dir andFileName: fileName ]		on: ProgressTargetRequestNotification do: [ :ex | ex resume ]]			ensure: [packageRelease noteInstalled]! !!SMSARInstaller commentStamp: '<historical>' prior: 34776811!I am a SqueakMap installer that knows how to deal with Zip format change-set archives.I recognize them by the file extension ".sar" (Squeak Archive).These have a couple of members with special names:install/preambleinstall/postscriptThese are loaded in order. Either or both can further load other members using fileInMemberNamed:.Inside a postscript or preamble, the pseudo-variable "self" is set to an instance of SARInstaller; you can then get to its ZipArchive using the method "zip". Or you can call its methods for filing in change sets, extracting files, etc.You can test this loading with:(SMSARInstaller new) directory: FileDirectory default; fileName: 'test.sar'; fileIn.See ChangeSet>>fileOutAsZipNamed: for one way to make these files. Here is another way of creating a multi change set archive installable by SqueakMap:"The following doit will create a .sar file with HVs preamble and postscript asseparate entries and the included changesets included as normal.Given a preamble as described below this will autoinstall in SqueakMap."(ChangeSorter changeSetNamed: 'HV')	fileOutAsZipNamed: 'httpview-021023.sar'	including: {		ChangeSorter changeSetNamed: 'HVFixes'.		ChangeSorter changeSetNamed: 'kom412'}Preamble in changeset HV that will install the changesets:"Change Set:		HVDate:			23 October 2002Author:			Gran HultgrenThis is my latest developer code drop of HttpView packaged as a Squeak selfextracting archive (courtesy Ned Konz).""Standard SqueakMap installing code follows:"(self isKindOf: SARInstaller) ifTrue:[	self fileInMemberNamed: 'HVFixes'.	self fileInMemberNamed: 'kom412'.	self fileInMemberNamed: 'HV']!!SMSARInstaller class methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34778591!canInstall: aPackage	"Answer if this class can install the package.	We handle it if the filename has the extension	.sar (upper and lowercase) and SARInstaller is	present in the image to handle the install."	| fileName |	fileName := aPackage downloadFileName.	fileName ifNil: [^false].	Smalltalk at: #SARInstaller ifPresentAndInMemory: [ :installer |			^'sar' = (FileDirectory extensionFor: fileName) asLowercase].	^false! !!SMSARInstaller methodsFor: 'private' stamp: 'gh 10/31/2002 11:19' prior: 34779110!fileIn	Smalltalk at: #SARInstaller ifPresentAndInMemory: [:installer |		(installer directory: dir fileName: fileName) fileIn. ^self].	self error: 'SAR support not installed in image, can not install.'! !!SMSARInstaller methodsFor: 'services' stamp: 'gk 11/16/2003 21:55' prior: 34779403!install	"This service should bring the package to the client,	unpack it if necessary and install it into the image.	The package is notified of the installation."	self cache; fileIn.	packageRelease noteInstalled! !!SMSimpleInstaller class methodsFor: 'testing' stamp: 'gh 10/22/2002 11:55' prior: 34779716!canInstall: aPackage	"Answer if this class can install the package.	This class is abstract so we return false."	^false! !!SMSimpleInstaller methodsFor: 'services' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34779941!cache	"Download object into cache if needed.	Set the directory and fileName for subsequent unpacking and install."	packageRelease ensureInCache ifTrue: [		fileName := packageRelease downloadFileName.		dir := packageRelease cacheDirectory]! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'gh 10/23/2002 10:54' prior: 34780278!directory	^dir! !!SMSimpleInstaller methodsFor: 'services' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34780396!download	"This service downloads the last release of the package	even if it is in the cache already."	packageRelease download ifTrue: [		fileName := packageRelease downloadFileName.		dir := packageRelease cacheDirectory]! !!SMSimpleInstaller methodsFor: 'services' stamp: 'rbb 3/1/2005 11:12' prior: 34780713!fileIntoChangeSetNamed: aString fromStream: stream	"We let the user confirm filing into an existing ChangeSet	or specify another ChangeSet name if	the name derived from the filename already exists."		| changeSet newName oldChanges global |	newName := aString.	changeSet := SMInstaller changeSetNamed: newName.	changeSet ifNotNil: [		newName := self silent ifNil: [UIManager default									request: 'ChangeSet already present, just confirm to overwrite or enter a new name:' 									initialAnswer: newName]						ifNotNil: [newName].		newName isEmpty ifTrue:[self error: 'Cancelled by user'].		changeSet := SMInstaller changeSetNamed: newName].		changeSet ifNil:[changeSet := SMInstaller basicNewChangeSet: newName].		changeSet ifNil:[self error: 'User did not specify a valid ChangeSet name'].		oldChanges := (SystemVersion current highestUpdate < 5302)						ifFalse: [global := ChangeSet. ChangeSet current]						ifTrue: [global := Smalltalk. Smalltalk changes]. 		[global newChanges: changeSet.		stream fileInAnnouncing: 'Loading ', newName, ' into change set ''', newName, ''''.		stream close] ensure: [global newChanges: oldChanges]! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'gh 10/21/2002 14:39' prior: 34781965!fileName	^fileName! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34782088!fileName: aFileName	fileName := aFileName! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'nk 2/22/2004 13:12' prior: 34782222!fullFileName 	^ self directory fullNameFor: self fileName! !!SMSimpleInstaller methodsFor: 'services' stamp: 'gk 4/18/2006 22:59' prior: 34782371!unpack	"This basic installer simply checks the file extension of	the downloaded file to choose suitable method for unpacking.	Currently it only supports .gz decompression.	If a file exists with the same name it is first deleted.	The unpacked filename is set on succesfull decompression or	if the file was not recognized as a compressed file."	| unzipped zipped buffer |	(fileName endsWith: '.gz')		ifTrue:[			unpackedFileName := fileName copyUpToLast: FileDirectory extensionDelimiter.			(dir fileExists: unpackedFileName) ifTrue:[ dir deleteFileNamed: unpackedFileName ].			unzipped := dir newFileNamed: unpackedFileName.			unzipped binary.			zipped := GZipReadStream on: ((dir readOnlyFileNamed: fileName) binary; yourself).			buffer := ByteArray new: 50000.			'Extracting ' , fileName				displayProgressAt: Sensor cursorPoint				from: 0				to: zipped sourceStream size				during: [:bar | 					[zipped atEnd]						whileFalse: 							[bar value: zipped sourceStream position.							unzipped nextPutAll: (zipped nextInto: buffer)].					zipped close.					unzipped close]]		ifFalse:[unpackedFileName := fileName]! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'gh 10/21/2002 14:39' prior: 34783602!unpackedFileName	^unpackedFileName! !!SMObject commentStamp: 'gk 9/23/2003 20:26' prior: 34783703!SMObject is the abstract superclass for all objects living in an SMSqueakMap.It has a unique UUID and a reference to the owning SMSqueakMap.It has timestamps to record the birthtime and the last modification.It has basic attributes like name, oneline summary and url.!!SMCategorizableObject commentStamp: '<historical>' prior: 34784051!A categorizable object can be associated with one or more SMCategories.The relation between the categories and the SMCategorizableObject is bidirectional.A categorizable object can also have attached resources, see SMResource.The categories are used to classify the categorizable object for different purposes.Package and package releases are classified in different ways, but so can resources and accounts be.!!SMCategorizableObject methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34784571!addCategory: aCategory	"Add <aCategory> to me. If I already have it do nothing."	categories ifNil: [categories := OrderedCollection new].	(categories includes: aCategory) ifFalse:[		aCategory addObject: self.		categories add: aCategory].	^aCategory! !!SMCategorizableObject methodsFor: 'resources' stamp: 'gk 5/5/2006 02:07' prior: 34784921!addResource: aResource	"Lazily initialize the resources collection."		resources ifNil: [resources := OrderedCollection new].	aResource object: self.	^resources add: aResource! !!SMCategorizableObject methodsFor: 'accessing' stamp: 'gk 9/23/2003 20:44' prior: 34785196!categories	"Lazily initialized."	^categories ifNil: [OrderedCollection new]! !!SMCategorizableObject methodsFor: 'categories' stamp: 'gk 9/23/2003 20:45' prior: 34785371!categoriesDo: aBlock	"Evaluate aBlock for each of the categories."	categories ifNil: [^self].	categories do: aBlock! !!SMCategorizableObject methodsFor: 'categories' stamp: 'gk 11/24/2005 11:18' prior: 34785588!categoryForParent: aCategory	"Answer one of my categories with parent <aCategory>, if I have it."	categories ifNil: [^nil].	^categories detect: [:cat | cat parent = aCategory ] ifNone: [nil]! !!SMCategorizableObject methodsFor: 'private' stamp: 'gk 8/8/2003 02:35' prior: 34785875!delete	"Delete me. Disconnect me from my categories."	super delete.	self removeFromCategories! !!SMCategorizableObject methodsFor: 'printing' stamp: 'dew 3/17/2004 16:28' prior: 34786068!describeCategoriesOn: aStream indent: tabs 	"Show a full listing of categories and their dscription on aStream, indented by the given number of tabs."	categories isEmptyOrNil		ifFalse: [aStream cr;				withAttribute: TextEmphasis bold				do: [aStream nextPutAll: 'Categories: ']; cr.			(self categories asSortedCollection: [:a :b | a path < b path])				do: [:c | 					aStream tab: tabs.					c						parentsDo: [:p | aStream nextPutAll: p name;								 nextPut: $/].					aStream nextPutAll: c name;						 nextPutAll: ' - ';												withAttributes: {TextEmphasis italic. TextIndent tabs: tabs + 1 }						do: [aStream nextPutAll: c summary];						 cr]]! !!SMCategorizableObject methodsFor: 'resources' stamp: 'gk 7/27/2004 18:12' prior: 34786832!embeddedResources	"Return all embedded resources."		^resources ifNil: [#()]		ifNotNil: [resources select: [:r | r isEmbedded ]]	! !!SMCategorizableObject methodsFor: 'categories' stamp: 'gh 11/27/2002 12:35' prior: 34787063!hasCategory: aCategory	"Answer true if I am in it."	^categories notNil and: [categories includes: aCategory]! !!SMCategorizableObject methodsFor: 'categories' stamp: 'gk 7/9/2004 02:57' prior: 34787270!hasCategoryOrSubCategoryOf: aCategory	"Answer true if I am in aCategory or if I am in any	of its sub categories recursively."	aCategory allCategoriesDo: [:cat |		(self hasCategory: cat) ifTrue: [^ true]].	^false! !!SMCategorizableObject methodsFor: 'private' stamp: 'gh 11/27/2002 12:35' prior: 34787582!removeCategory: aCategory	"Remove category from me if I am in it."	(categories notNil and: [categories includes: aCategory]) ifTrue:[		aCategory removeObject: self.		categories remove: aCategory].	^aCategory! !!SMCategorizableObject methodsFor: 'private' stamp: 'gh 11/27/2002 12:35' prior: 34787890!removeFromCategories	"Remove me from all my categories."	categories ifNotNil:[		categories copy do: [:cat | self removeCategory: cat ]]! !!SMCategorizableObject methodsFor: 'resources' stamp: 'gk 11/24/2005 11:23' prior: 34788126!removeResource: aResource	"Disconnect and remove the resource."		aResource object: nil.	^resources remove: aResource! !!SMCategorizableObject methodsFor: 'accessing' stamp: 'gk 7/27/2004 13:09' prior: 34788342!resources	"Lazily initialized."	^resources ifNil: [OrderedCollection new]! !!SMPackageRelease commentStamp: '<historical>' prior: 34788486!A package release refers to a specific version of the package.Releases are auto numbered (with a VersionNumber) and also has a designated version name which can be whatever the maintainer wants.There is also a release note and the URL for download. The inherited url is for any homepage for the release.The instvar publisher refers to the SMAccount that owned the package at the time of the release and the instvar package refers to the owning package.The instvar repository holds a String that is used to connect to the live repository for the package release, for example a Monticello repository.!!SMPackageRelease class methodsFor: 'instance creation' stamp: 'gk 12/7/2005 14:16' prior: 34789191!newFromRelease: aPackageRelease package: aPackage	"Create a new release from a given release."	^super new initializeFromRelease: aPackageRelease package: aPackage! !!SMPackageRelease methodsFor: 'configurations' stamp: 'gk 7/27/2004 17:58' prior: 34789452!addConfiguration	"Create and add a new SMPackageReleaseConfiguration and return it."	^ self addResource: (SMPackageReleaseConfiguration newIn: map)! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 11:22' prior: 34789694!automaticVersion	"Return the VersionNumber for me."	^automaticVersion! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 8/12/2003 17:21' prior: 34789857!automaticVersionString	"Return my VersionNumber as a String."	^automaticVersion versionString! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 8/13/2003 15:25' prior: 34790044!cacheDirectory	^ map cache directoryForPackageRelease: self! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 11/23/2005 01:13' prior: 34790196!calculateSha1sum	"Return the checksum of the currently cached file contents."	^SecureHashAlgorithm new hashMessage: self contents				! !!SMPackageRelease methodsFor: 'configurations' stamp: 'gk 7/27/2004 14:29' prior: 34790431!configurations	"Return all SMPackageReleaseConfigurations attached to this release."	^ self embeddedResources select: [:er | er isConfiguration]! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 11/22/2005 22:41' prior: 34790671!contents	"Return the contents of the cached file.	If it is not downloadable, or if the file	is not cached, return nil."	^map cache contents: self! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 11/23/2005 01:50' prior: 34790913!correctSha1sum: content	"Return if the checksum of the content is correct.	If we have none, then we consider that to be correct."		^sha1sum isNil or: [sha1sum = (SecureHashAlgorithm new hashMessage: content)]				! !!SMPackageRelease methodsFor: 'deletion' stamp: 'gh 11/28/2002 21:32' prior: 34791223!delete	super delete.	package removeRelease: self! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 8/13/2003 15:43' prior: 34791363!download	"Force a download into the cache regardless if it is already there."	^map cache download: self! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 14:03' prior: 34791561!downloadFileName	"Cut out the filename from the url."	downloadUrl isEmpty ifTrue: [^nil].	^downloadUrl asUrl path last! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 15:31' prior: 34791775!downloadUrl	^downloadUrl! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 15:31' prior: 34791892!downloadUrl: anObject	^downloadUrl := anObject! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 7/13/2004 00:48' prior: 34792029!eitherVersion	"Return either version:		1. If the maintainer entered a version then we use that.		2. Otherwise we use the automatic version with an 'r' prepended."	^version notEmpty			ifTrue:[version]			ifFalse:['r', automaticVersion versionString]! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 7/10/2004 03:53' prior: 34792373!ensureInCache	"Makes sure the file is in the cache.	Return true on success, otherwise false."	^map cache add: self! !!SMPackageRelease methodsFor: 'printing' stamp: 'dew 10/23/2006 18:52' prior: 34792583!fullDescription	"Return a full textual description of the package release."	| s |	s := TextStream on: (Text new: 400).	self describe: self package name withBoldLabel: 'Package Name: ' on: s.	name isEmptyOrNil ifFalse:		[self describe: self name withBoldLabel: 'Release Name: ' on: s].	summary isEmptyOrNil ifFalse:		[self describe: self summary withBoldLabel: 'Release Summary: ' on: s].	self 		describe: self version		withBoldLabel: 'Version: '		on: s.	categories isEmptyOrNil 		ifFalse: 			[s				cr;				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Categories: '];				cr.			(self categories asSortedCollection: [:a :b | a path < b path])				do: [:c | 					s						tab;						withAttribute: TextEmphasis italic							do: 								[c parentsDo: 										[:p | 										s											nextPutAll: p name;											nextPutAll: '/'].								s nextPutAll: c name];						nextPutAll: ' - ' , c summary;						cr].			s cr].	created ifNotNil: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Created: ' ];			print: self created;			cr].	updated ifNotNil: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Modified: ' ];			print: self updated;			cr].	publisher ifNotNil: [		s			withAttribute: TextEmphasis bold			do: [s nextPutAll: 'Publisher: '].		s			withAttribute: (PluggableTextAttribute					evalBlock: [self userInterface									sendMailTo: self publisher email									regardingPackageRelease: self])			do: [s nextPutAll: self publisher nameAndEmail];				cr].	self note isEmptyOrNil 		ifFalse: 			[s				cr;				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Version Comment:'].			s cr.			s withAttribute: (TextIndent tabs: 1) do: [s nextPutAll: self note withSqueakLineEndings].			s				cr;				cr].	url isEmptyOrNil 		ifFalse: 			[s				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Homepage:'];				tab;				withAttribute: (TextURL new url: url) do: [s nextPutAll: url];				cr].	self downloadUrl isEmptyOrNil 		ifFalse: 			[s				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Download:'];				tab;				withAttribute: (TextURL new url: self downloadUrl)					do: [s nextPutAll: self downloadUrl];				cr].	^s contents.! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 7/12/2004 16:04' prior: 34794911!fullVersion	"Return version followed by the automatic version	with r prepended in parenthesis."	^version, ' (r', automaticVersion versionString, ')'! !!SMPackageRelease methodsFor: 'view' stamp: 'gk 10/12/2005 12:25' prior: 34795150!getLink: aBuilder	"Return a link for using on the web."	^self getLink: aBuilder view: aBuilder view! !!SMPackageRelease methodsFor: 'view' stamp: 'gk 10/12/2005 12:27' prior: 34795339!getLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLinkTop: self relativeUrl text: self packageNameWithVersion! !!SMPackageRelease methodsFor: 'view' stamp: 'gk 10/12/2005 12:27' prior: 34795569!getShortLink: aBuilder	^aBuilder getLinkTop: self relativeUrl text: self listName! !!SMPackageRelease methodsFor: 'configurations' stamp: 'gk 9/20/2004 21:17' prior: 34795748!hasFulfilledConfiguration	"Is any of the configurations already fulfilled?	A fulfilled configuration has all required releases	already installed, this means the release can be	trivially installed."		^self workingConfigurations anySatisfy: [:c | c isFulfilled]! !!SMPackageRelease methodsFor: 'configurations' stamp: 'gk 9/20/2004 21:16' prior: 34796109!hasNoConfigurations	"Does this release lack configurations,	both working or failed ones? This is interpreted	as if the release has no dependencies."	^self configurations isEmpty! !!SMPackageRelease methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 34796390!initializeFromRelease: parentRelease package: aPackage	"Initialize package release from a given parent.	Branch if needed."	self map: aPackage map id: UUID new.	package := aPackage.	automaticVersion :=		parentRelease			ifNil: [VersionNumber first]			ifNotNil: [parentRelease nextOrBranch].	version := note := downloadUrl := ''! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 2/16/2004 20:04' prior: 34796815!install	"Install this package release."	^map installPackageRelease: self! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 8/13/2003 15:32' prior: 34796979!isCached	"Delegate to last release."	^map cache includes: self! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 5/5/2006 01:54' prior: 34797132!isCompatibleWithCurrentSystemVersion	"Return true if this release is listed as being compatible with the SystemVersion of the current image.  Only checks major/minor version number; does not differentiate between alpha/beta/gamma releases.  Checks version categories of both the SMPackageRelease and the parent SMPackage."	| current |	current := self majorMinorVersionFrom: SystemVersion current version.	self categories, self package categories do: [:c |		((c parent name = 'Squeak versions') and: [			(self majorMinorVersionFrom: c name) = current])				ifTrue: [^true]].	^ false		"	^ (self categories, self package categories		detect:			[:cat | (cat parent name = 'Squeak versions')					and: [(SystemVersion new version: cat name) majorMinorVersion = SystemVersion current majorMinorVersion]]		ifNone: []) notNil"! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 10/15/2003 12:37' prior: 34798053!isDownloadable	"Answer if I can be downloaded.	We simply verify that the download url	ends with a filename."	^self downloadFileName isEmptyOrNil not! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 11/16/2003 23:48' prior: 34798296!isInstallable	"Answer if there is any installer for me.	This depends typically on the filename of	the download url, but can in the future	depend on other things too.	It does *not* say if the release is installed or not."	^SMInstaller isInstallable: self! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 7/13/2004 13:59' prior: 34798645!isInstalled	"Answer if this release is installed."	^(map installedReleaseOf: package) == self! !!SMPackageRelease methodsFor: 'testing' stamp: 'gh 12/1/2002 19:52' prior: 34798830!isPackageRelease	^true! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 9/23/2003 21:09' prior: 34798942!isPublished	"It is published when the publisher is set."	^publisher notNil! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 11/17/2003 12:01' prior: 34799109!isUpgradeable	"Answer if there is any installer that can upgrade me.	This depends typically on the filename of	the download url, but can in the future	depend on other things too.	It does *not* say if the package is installed or not	or if there is a newer version available or not."	^SMInstaller isUpgradeable: self! !!SMPackageRelease methodsFor: 'printing' stamp: 'gk 7/10/2004 03:35' prior: 34799521!listName	"Return something suitable for showing in lists.	We list the manual version after a dash if it is available.	We don't list the release name."	^version isEmpty		ifFalse: [self automaticVersion versionString , '-', version]		ifTrue: [self automaticVersion versionString] ! !!SMPackageRelease methodsFor: 'private' stamp: 'gk 5/5/2006 01:54' prior: 34799894!majorMinorVersionFrom: aVersionName	| start |	start := aVersionName indexOf: $..	start = 0 ifTrue: [^ aVersionName].	aVersionName size = start ifTrue: [^ aVersionName].	start + 1 to: aVersionName size do: [:i |		(aVersionName at: i) isDigit ifFalse: [^aVersionName copyFrom: 1 to: i - 1]].	^aVersionName! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 7/13/2004 13:24' prior: 34800294!newerThan: aRelease	"Answer if this release was made after <aRelease>."		^aRelease automaticVersion < automaticVersion! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 5/5/2006 02:07' prior: 34800504!nextOrBranch	"Return a new automaticVersion that is either	the next following my version, or if that is taken	a branch, or if that is taken too - a branch from it and so on.	Yes, it sucks, but I don't have time hacking VersionNumber right now."	| nextVersion nextBranch |	nextVersion := automaticVersion next.	(package releaseWithAutomaticVersion: nextVersion) ifNil: [^nextVersion].	nextBranch := automaticVersion branchNext.	[(package releaseWithAutomaticVersion: nextBranch) notNil]		whileTrue: [nextBranch := nextBranch branchNext].	^nextBranch ! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 12:43' prior: 34801158!note	^note! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 12:43' prior: 34801261!note: anObject	^note := anObject! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 11/17/2003 01:25' prior: 34801385!noteInstalled	"This package release was just successfully installed.	We tell the map so that it can keep track of what	package releases are installed."	map noteInstalled: self! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 1/23/2004 10:01' prior: 34801655!noteUninstalled	"This package release was just successfully uninstalled.	We tell the map so that it can keep track of what	package releases are installed."	self error: 'Uninstall is not working yet!!'.	map noteUninstalled: self! !!SMPackageRelease methodsFor: 'testing' stamp: 'gk 7/13/2004 13:24' prior: 34801977!olderThan: aRelease	"Answer if this release was made before <aRelease>."		^automaticVersion < aRelease automaticVersion! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 3/15/2003 20:55' prior: 34802190!package	"Get the package that I belong to."	^package! !!SMPackageRelease methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34802346!package: aPackage	"Set when I am created."	package := aPackage! !!SMPackageRelease methodsFor: 'printing' stamp: 'gk 7/10/2004 03:38' prior: 34802501!packageNameWithVersion	"Return '<packageName> <autoVersion>-<version>' like:		'SqueakMap 5-0.92'	"	^package name, ' ', self listName! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 10/12/2005 13:25' prior: 34802728!parentRelease	"Return my parent release based on the automatic	version number."	^package parentReleaseFor: self! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 10/12/2005 13:23' prior: 34802934!previousRelease	"Return the release before me.	Returns nil if there is none.	This is chronological order and not how they relate."	^package previousReleaseFor: self! !!SMPackageRelease methodsFor: 'printing' stamp: 'gk 7/10/2004 03:38' prior: 34803193!printName	"Return a String identifying object without context."	^self packageNameWithVersion! !!SMPackageRelease methodsFor: 'printing' stamp: 'gk 12/9/2003 00:13' prior: 34803378!printOn: aStream	aStream nextPutAll: self class name, '[', self packageNameWithVersion, ']'! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 6/26/2003 14:59' prior: 34803562!publisher	^publisher! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 6/26/2003 15:00' prior: 34803674!publisher: anObject	publisher := anObject! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 10/12/2005 00:24' prior: 34803807!relativeUrl	"Return the relative url for this release on an SM server."		^'package/', package id asString, '/autoversion/', automaticVersion versionString! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 7/15/2004 16:26' prior: 34804055!repository	^repository! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 34804168!repository: aString	repository := aString! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 11/22/2005 22:29' prior: 34804302!sha1sum	^sha1sum! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 34804409!sha1sum: aString	sha1sum := aString! !!SMPackageRelease methodsFor: 'services' stamp: 'gk 7/13/2004 00:49' prior: 34804535!smartVersion	"This method is used to ensure that we always have a	version name for the package release even if the maintainer didn't	bother to enter one. Is is calculated like this:		1. If the maintainer entered a version then we use that.		2. Otherwise we use the automatic version with an 'r' prepended.		3. If the release is not published we enclose it in parenthesis."	^ self isPublished ifTrue: [self eitherVersion] ifFalse: ['(', self eitherVersion, ')']! !!SMPackageRelease methodsFor: 'printing' stamp: 'gk 11/14/2003 00:11' prior: 34805094!type	^'Package release'! !!SMPackageRelease methodsFor: 'services' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34805221!upgrade	"Upgrade this package release if there is a new release available."	| newRelease |	newRelease := package lastPublishedReleaseForCurrentSystemVersionNewerThan: self.	newRelease ifNotNil: [(SMInstaller forPackageRelease: newRelease) upgrade]! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 15:30' prior: 34805565!version	^version! !!SMPackageRelease methodsFor: 'accessing' stamp: 'gh 11/27/2002 15:30' prior: 34805674!version: anObject	^version := anObject! !!SMPackageRelease methodsFor: 'view' stamp: 'gh 3/15/2003 19:37' prior: 34805799!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject packageReleaseViewOn: self! !!SMPackageRelease methodsFor: 'configurations' stamp: 'gk 7/27/2004 14:55' prior: 34806028!workingConfigurations	"Return all working configurations."		^ self configurations select: [:c | c isWorking ]! !!SMRootedObject commentStamp: '<historical>' prior: 34806206!An SMRootedObject is an SMObject that can be "rooted" in a given homeMap. This concept is for the upcoming new architecture with a tree of SM servers. Not used yet.!!SMAccount commentStamp: '<historical>' prior: 34806429!SMAccount is the object representing a user account in SqueakMap - a Squeaker that owns information in SqueakMap.It keeps track of the email address, developer initials and two passwords used to access the account. There is also an advogatoId (people.squeakfoundation.org username) and a signature field (not used yet). The flag isAdmin is a crude way of marking a user as a superuser, this will possibly be changed in the future and instead expressed using a category.Passwords are stored as secure hashes. The extra password (newPassword) is used when the regular password is forgotten - it is then randomly set and an email is sent out containing it to the registered email. This enables the original password to still work. When logging in, the user gets a chance to enter a new regular password overwriting the old one and clearing the random new password in the process.The instvar objects holds all SMPersonalObjects (instances of subclasses) that this account "owns" - these are typically instances of SMPackages and SMResources, but are not limited to be.The instvar coObjects holds all SMPersonalObjects that this account is co-maintaining - these are typically instances of SMPackages and SMResources.Finally the account also maintains a directory with uploaded files on the server. This directory has the UUID of the account as its name and it is located under sm/accounts!!SMAccount methodsFor: 'objects' stamp: 'gk 11/11/2003 16:16' prior: 34807904!addCoObject: anObject	"Add <anObject> to this account.	Only called from #addMaintainer:."		(coObjects includes: anObject)		ifFalse:[coObjects add: anObject]! !!SMAccount methodsFor: 'objects' stamp: 'gk 11/11/2003 20:49' prior: 34808148!addObject: anObject	"Add <anObject> to this account. Also makes sure the	reverse reference is correct."		(objects includes: anObject) ifFalse:[		objects add: anObject.		anObject owner: self.		map addObject: anObject]! !!SMAccount methodsFor: 'accessing' stamp: 'gk 11/13/2003 23:06' prior: 34808456!advogatoId	^advogatoId! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34808575!advogatoId: aString	advogatoId := aString! !!SMAccount methodsFor: 'objects' stamp: 'gk 11/24/2005 11:13' prior: 34808700!coPackageWithId: anIdString	"Return the correct package or nil."	^self withId: anIdString in: self coPackages! !!SMAccount methodsFor: 'objects' stamp: 'gk 11/24/2005 11:10' prior: 34808895!coPackages	"Return all co-maintained packages."	^coObjects select: [:o | o isPackage]! !!SMAccount methodsFor: 'passwords' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34809079!correctPassword: aPassword	"We store the password as a SHA hash so that we can let the slave maps	have them too. Also check the optional new random password."	| try |	aPassword isEmptyOrNil ifTrue:[^false].	try := SecureHashAlgorithm new hashMessage: aPassword.	^password = try or: [newPassword = try]! !!SMAccount methodsFor: 'passwords' stamp: 'gk 5/5/2006 02:07' prior: 34809470!createRandomPassword	"Create a random password and set it	in parallell to the regular one."	| randomPass |	randomPass := String streamContents: [:stream | 10 timesRepeat: [ stream nextPut: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' atRandom]].	self setNewPassword: randomPass.	^randomPass! !!SMAccount methodsFor: 'files' stamp: 'gk 3/8/2004 19:26' prior: 34809840!delete	"Delete this account. First delete all SM objects we own	and disconnect this account from those we co-maintain."	objects do: [:o | o delete].	coObjects do: [:co | co removeMaintainer: self].	super delete! !!SMAccount methodsFor: 'files' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34810149!deleteFiles: fileNames	"Delete all fileNames from the uploads directory."	| dir |	dir := self uploadsDirectory.	fileNames do: [:fn | dir deleteFileNamed: fn]! !!SMAccount methodsFor: 'files' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34810404!directory	"Get the directory for the account."	| dir |	dir := (map directory directoryNamed: 'accounts') assureExistence; yourself.	^(dir directoryNamed: id asString) assureExistence; yourself! !!SMAccount methodsFor: 'accessing' stamp: 'gk 6/26/2003 14:26' prior: 34810686!email	^email! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34810795!email: address	email := address! !!SMAccount methodsFor: 'files' stamp: 'gk 3/8/2004 19:26' prior: 34810906!entries	"Return all file entries in the upload directory."	^self uploadsDirectory entries! !!SMAccount methodsFor: 'files' stamp: 'gk 8/15/2003 12:08' prior: 34811078!files	"Return filenames for uploaded files."	^self uploadsDirectory fileNames! !!SMAccount methodsFor: 'view' stamp: 'gk 10/12/2005 12:24' prior: 34811239!getLink: aBuilder	"Return a link for using on the web.	Always from the top."	^aBuilder getLinkTop: 'accountbyid/', id asString text: self nameWithInitials! !!SMAccount methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34811502!initialize	"Initialize account."	super initialize.	initials := signature := advogatoId := ''.	isAdmin := false.	objects := OrderedCollection new.	coObjects := OrderedCollection new! !!SMAccount methodsFor: 'accessing' stamp: 'gk 7/30/2003 14:10' prior: 34811773!initials	^initials! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34811888!initials: aString	"If these are changed we need to update the dictionary in the map."	initials ~= aString ifTrue: [		initials := aString.		map clearUsernames]! !!SMAccount methodsFor: 'testing' stamp: 'gk 6/26/2003 16:47' prior: 34812133!isAccount	^true! !!SMAccount methodsFor: 'accessing' stamp: 'gk 11/17/2003 11:49' prior: 34812234!isAdmin	^isAdmin ifNil: [false] ifNotNil: [isAdmin]! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34812382!isAdmin: aBoolean	isAdmin := aBoolean! !!SMAccount methodsFor: 'view' stamp: 'gk 8/4/2003 14:10' prior: 34812498!logout	"Automatically called upon logout. Do nothing."! !!SMAccount methodsFor: 'objects' stamp: 'gk 8/7/2003 21:00' prior: 34812634!moveObject: aPersonalObject toAccount: anAccount	"Transfer the ownership of the given personal object to <anAccount>."	self removeObject: aPersonalObject.	anAccount addObject: aPersonalObject! !!SMAccount methodsFor: 'accessing' stamp: 'gk 11/24/2005 11:09' prior: 34812914!nameAndEmail	"This is not really correct, the name needs to be	mime encoded."	^name , ' <', email, '>'! !!SMAccount methodsFor: 'view' stamp: 'gk 8/5/2003 13:16' prior: 34813098!nameWithInitials	"Return name and developer initials within parentheses."	^name, ' (', (initials isEmptyOrNil ifTrue: ['not entered'] ifFalse: [initials]) , ')'! !!SMAccount methodsFor: 'files' stamp: 'gk 4/18/2006 22:53' prior: 34813341!newFile: fileName block: aBlock	"Create a new file. Let <aBlock> fill the file with content by calling it with a stream."	| dir stream |	dir := self uploadsDirectory.	[(dir fileExists: fileName) ifTrue:[dir deleteFileNamed: fileName].	stream := dir newFileNamed: fileName.	stream binary.	aBlock value: stream] ensure: [stream close]! !!SMAccount methodsFor: 'accessing' stamp: 'gk 8/4/2003 16:34' prior: 34813764!newPassword	"Get the parallell password hash."	^newPassword! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34813922!newPassword: aHashNumber	"Set the parallell password hash."	newPassword := aHashNumber! !!SMAccount methodsFor: 'testing' stamp: 'gk 11/11/2003 17:24' prior: 34814094!owns: anObject	^objects includes: anObject! !!SMAccount methodsFor: 'objects' stamp: 'gk 11/24/2005 11:14' prior: 34814220!packageWithId: anIdString	"Return the correct package or nil."	^self withId: anIdString in: self packages! !!SMAccount methodsFor: 'objects' stamp: 'gk 11/24/2005 11:14' prior: 34814411!packages	"Return all owned packages."	^objects select: [:o | o isPackage]! !!SMAccount methodsFor: 'accessing' stamp: 'gk 8/4/2003 15:42' prior: 34814570!password	"Get the password hash."	^password! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34814712!password: aHashNumber	"Set the password hash."	password := aHashNumber! !!SMAccount methodsFor: 'view' stamp: 'gk 8/8/2003 00:09' prior: 34814863!publicViewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject publicAccountViewOn: self! !!SMAccount methodsFor: 'objects' stamp: 'gk 11/11/2003 16:16' prior: 34815084!removeCoObject: anObject	"Remove <anObject> from this account.	Only called from #removeMaintainer:."	(coObjects includes: anObject) ifTrue: [		coObjects remove: anObject]! !!SMAccount methodsFor: 'objects' stamp: 'gk 8/7/2003 20:56' prior: 34815340!removeObject: anObject	"Remove <anObject> from this account. Also makes sure the	reverse reference is cleared."	(objects includes: anObject) ifTrue: [		anObject owner: nil.		objects remove: anObject]! !!SMAccount methodsFor: 'passwords' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34815641!setNewPassword: aString	"Set a new parallell password the user can use to get in	if the old password is forgotten. We don't delete the old	password since the request for this new password is made	anonymously. Note that the password is stored as a secured	hash large integer."	newPassword := SecureHashAlgorithm new hashMessage: aString! !!SMAccount methodsFor: 'passwords' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34816079!setPassword: aString	"We also clear the random extra password."	password := SecureHashAlgorithm new hashMessage: aString.	newPassword := nil! !!SMAccount methodsFor: 'accessing' stamp: 'gk 8/4/2003 15:56' prior: 34816306!signature	"Get the signature."	^signature! !!SMAccount methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34816446!signature: aSignature	"Set the signature."	signature := aSignature! !!SMAccount methodsFor: 'files' stamp: 'gk 4/3/2006 23:58' prior: 34816594!streamForFile: fileName	"Return a readonly stream for file <fileName>.	If the file does not exist return nil."	| stream |	[stream := StandardFileStream oldFileNamed: (self uploadsDirectory fullNameFor: fileName)]		on: FileDoesNotExistException do: [^nil].	^stream! !!SMAccount methodsFor: 'printing' stamp: 'gk 11/24/2005 11:09' prior: 34816948!type	"Used in various views."	^'Account'! !!SMAccount methodsFor: 'files' stamp: 'gk 8/14/2003 14:23' prior: 34817071!uploadsDirectory	"Get the directory for uploaded files, create it if missing."	^(self directory directoryNamed: 'uploads') assureExistence; yourself! !!SMAccount methodsFor: 'view' stamp: 'gk 6/26/2003 16:01' prior: 34817302!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject accountViewOn: self! !!SMPersonalObject commentStamp: 'gk 7/27/2004 13:28' prior: 34817502!SMPersonalObject is the abstract base class for things that belong/are owned by a user account in SqueakMap. Most things are personal objects - but the SMCategories aren't for example.A personal object has a reference to the SMAccount owning it.!!SMMaintainableObject commentStamp: '<historical>' prior: 34817819!A mainainable object is a personal object that is of such a complexity that it seems beneficial to optionally co-maintain with other people.It thus has a potential list of maintainers - other accounts that also can modify the object. It also has a field to be able to refer to an RSS feed regarding the object.!!SMDocument commentStamp: '<historical>' prior: 34818190!An SMDocument refers typically to a piece of digital information accessible through a URL. :-)This means it can be downloaded and cached.The instvar description describes the document and instvar author references the name and/or email of the original author.SMDocument has one subclasses - SMPackage. Since SqueakMap is primarily meant forkeeping track of installable source packages of Squeak software, a specific subclass handles those.!!SMDocument methodsFor: 'accessing' stamp: 'gk 3/8/2004 19:51' prior: 34818717!author	^author! !!SMDocument methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34818829!author: aString	author := aString! !!SMDocument methodsFor: 'accessing' stamp: 'gk 3/8/2004 19:52' prior: 34818947!description	^description! !!SMDocument methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34819069!description: aString	description := aString! !!SMDocument methodsFor: 'cache' stamp: 'gk 3/8/2004 19:51' prior: 34819193!ensureInCache	"Makes sure the file is in the cache."	self subclassResponsibility ! !!SMDocument methodsFor: 'initialize-release' stamp: 'gk 12/7/2005 13:51' prior: 34819371!initialize	super initialize.	description := author := ''! !!SMDocument methodsFor: 'cache' stamp: 'gk 8/12/2003 17:09' prior: 34819511!isCached	"Is the file corresponding to me in the local file cache?"	self subclassResponsibility ! !!SMDocument methodsFor: 'testing' stamp: 'gk 7/16/2004 11:08' prior: 34819693!isDownloadable	"Answer if I can be downloaded.	Default is false."		^ false		! !!SMPackage commentStamp: '<historical>' prior: 34819837!An SMPackage represents a named piece of an installable "thing" in the image. Typically it is a code package, but it can be other things too.It owns a collection of SMPackageReleases. Each release represents a version of the package, and each release has a URL that refers to the actual content that can be installed.An SMPackage also knows its packageInfoName which can tie it into the image.!!SMPackage methodsFor: 'private' stamp: 'gk 10/12/2005 15:44' prior: 34820314!addRelease: aRelease	"Add the release. Make sure package is set."	releases add: aRelease.	aRelease package: self.	^aRelease! !!SMPackage methodsFor: 'cache' stamp: 'gk 8/12/2003 17:20' prior: 34820522!cacheDirectory	^ self lastRelease cacheDirectory! !!SMPackage methodsFor: 'accessing' stamp: 'gk 7/12/2004 16:05' prior: 34820655!currentVersion	^self isPublished ifTrue: [self lastPublishedRelease version]! !!SMPackage methodsFor: 'private' stamp: 'gh 11/28/2002 21:25' prior: 34820815!delete	"Delete me. Delete my releases."	super delete.	self deleteReleases! !!SMPackage methodsFor: 'private' stamp: 'gk 10/20/2005 00:17' prior: 34820975!deleteReleases	"Delete my releases."	releases copy do: [:release | release delete]! !!SMPackage methodsFor: 'cache' stamp: 'gk 3/8/2004 19:56' prior: 34821139!download	"Force download into cache."	self isReleased ifFalse: [self error: 'There is no release for this package to download.'].	^self lastRelease download! !!SMPackage methodsFor: 'cache' stamp: 'gk 7/16/2004 11:01' prior: 34821379!ensureInCache	"Makes sure all release files are in the cache."	self releases do: [:rel | rel ensureInCache ]! !!SMPackage methodsFor: 'services' stamp: 'gk 9/26/2004 23:34' prior: 34821573!firstRelease	"Return the first release."	^releases isEmpty ifTrue: [nil] ifFalse: [releases first]! !!SMPackage methodsFor: 'accessing' stamp: 'dew 10/23/2006 19:08' prior: 34821760!fullDescription	"Return a full textual description of the package. 	Most of the description is taken from the last release."	| s publishedRelease sqDescription |	s := TextStream on: (Text new: 400).	self		describe: name		withBoldLabel: 'Name:		'		on: s.	summary isEmptyOrNil		ifFalse: [self				describe: summary				withBoldLabel: 'Summary:	'				on: s ].	author isEmptyOrNil		ifFalse: [s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Author:'];				 tab;				 tab.			s				withAttribute: (PluggableTextAttribute						evalBlock: [self userInterface										sendMailTo: (SMUtilities stripEmailFrom: author)										regardingPackageRelease: self lastRelease])				do: [s nextPutAll: author];				 cr].	self owner		ifNotNil: [s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Owner:'];				 tab; tab.			s				withAttribute: (PluggableTextAttribute						evalBlock: [self userInterface										sendMailTo: self owner email										regardingPackageRelease: self lastRelease])				do: [s nextPutAll: self owner nameAndEmail];					 cr].	self maintainers isEmpty ifFalse: [		s withAttribute: TextEmphasis bold do: [s nextPutAll: 'Co-Maintainers:']; tab.		self maintainers do: [:com |			com = self maintainers first ifFalse: [s nextPutAll: ', '].			s				withAttribute:					(PluggableTextAttribute						evalBlock: [self userInterface									sendMailTo: com email									regardingPackageRelease: self lastRelease])				do: [s nextPutAll: com nameAndEmail]].				s cr].	description isEmptyOrNil		ifFalse: [sqDescription := description withSqueakLineEndings.			s cr.			s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Description:'].			s cr.			s				withAttribute: (TextIndent tabs: 1)				do: [s next: (sqDescription findLast: [ :c | c isSeparator not ]) putAll: sqDescription].			s cr ].	self describeCategoriesOn: s indent: 1.	s cr.	publishedRelease := self lastPublishedRelease.	self		describe: (self publishedVersion ifNil: ['<not published>'])		withBoldLabel: 'Published Version: '		on: s.	self isPublished ifTrue: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Created: ' ];			print: publishedRelease created;			cr.			self note isEmptyOrNil				ifFalse: [s					withAttribute: TextEmphasis bold					do: [s nextPutAll: 'Release Note:'].			s cr.			s				withAttribute: (TextIndent tabs: 1)				do: [s nextPutAll: publishedRelease note withSqueakLineEndings].			s cr ]].	url isEmptyOrNil		ifFalse: [s cr;				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Homepage: '];				withAttribute: (TextURL new url: url)				do: [s nextPutAll: url];				 cr].	packageInfoName isEmptyOrNil		ifFalse: [self				describe: packageInfoName				withBoldLabel: 'Package Info: '				on: s ].	^ s contents! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:10' prior: 34824661!getCoEditLink: aBuilder	"Return a link for using on the web.	Relative to the current view."	^self getCoEditLink: aBuilder view: aBuilder view! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:09' prior: 34824886!getCoEditLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLink: 'copackage/', id asString, '/edit' text: 'edit' view: aView! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:11' prior: 34825121!getCoEditReleasesLink: aBuilder	"Return a link for using on the web.	Relative to the current view."	^self getCoEditReleasesLink: aBuilder view: aBuilder view! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:11' prior: 34825362!getCoEditReleasesLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLink: 'copackage/', id asString, '/editreleases' text: 'edit releases' view: aView! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:06' prior: 34825622!getCoLink: aBuilder	"Return a link for using on the web.	Relative to the current view."	^self getCoLink: aBuilder view: aBuilder view! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:06' prior: 34825839!getCoLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLink: 'copackage/', id asString text: name view: aView! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:13' prior: 34826059!getEditLink: aBuilder	"Return a link for using on the web.	Relative to the current view."	^self getEditLink: aBuilder view: aBuilder view! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:13' prior: 34826280!getEditLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLink: 'package/', id asString, '/edit' text: 'edit' view: aView! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:13' prior: 34826511!getEditReleasesLink: aBuilder	"Return a link for using on the web.	Relative to the current view."	^self getEditReleasesLink: aBuilder view: aBuilder view! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 13:13' prior: 34826748!getEditReleasesLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLink: 'package/', id asString, '/editreleases' text: 'edit releases' view: aView! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 12:24' prior: 34827004!getLink: aBuilder	"Return a link for using on the web.	Relative to the current view."	^self getLink: aBuilder view: aBuilder view! !!SMPackage methodsFor: 'view' stamp: 'gk 10/12/2005 12:19' prior: 34827217!getLink: aBuilder view: aView	"Return a link for using on the web."	^aBuilder getLink: 'package/', id asString text: name view: aView! !!SMPackage methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 34827445!initialize	"Initialize package."	super initialize.	packageInfoName := ''.	releases := OrderedCollection new! !!SMPackage methodsFor: 'installation' stamp: 'gk 7/14/2004 17:32' prior: 34827644!install	"Install the latest newer published version for this version of Squeak."	^map installPackage: self! !!SMPackage methodsFor: 'installation' stamp: 'gk 11/17/2003 02:27' prior: 34827841!installedRelease	"Return the installed release.	We ask the map. Return nil if this package is not installed."	^map installedReleaseOf: self! !!SMPackage methodsFor: 'printing' stamp: 'gk 11/17/2003 10:14' prior: 34828068!installedVersion	"Return the version String for the installed version.	We ask the map. Return nil if this package is not installed."	^self installedRelease ifNotNilDo: [:r | r smartVersion]! !!SMPackage methodsFor: 'testing' stamp: 'gk 7/13/2004 15:11' prior: 34828343!isAvailable	"Answer if I am old or not installed regardless of	if there is installer support for me. It also does	not care if the newer release is not published	or no for this Squeak version."	^self isOld or: [self isInstalled not]! !!SMPackage methodsFor: 'testing' stamp: 'gk 7/13/2004 14:55' prior: 34828662!isCached	"Is the last release corresponding to me in the local file cache?	NOTE: This doesn't honour #published nor if the release is	intended for the current Squeak version."	^self isReleased and: [self lastRelease isCached]! !!SMPackage methodsFor: 'testing' stamp: 'gk 7/15/2004 17:21' prior: 34828974!isInstallable	"Answer if any of my releases can be installed."	^ releases anySatisfy: [:rel | rel isInstallable]! !!SMPackage methodsFor: 'testing' stamp: 'gh 10/25/2002 11:08' prior: 34829172!isInstallableAndNotInstalled	"Answer if there is any installer that	can install me and I am not yet installed."	^self isInstallable and: [self isInstalled not]! !!SMPackage methodsFor: 'testing' stamp: 'gk 11/17/2003 11:02' prior: 34829418!isInstalled	"Answer if any version of me is installed."	^(map installedReleaseOf: self) notNil! !!SMPackage methodsFor: 'testing' stamp: 'gk 7/13/2004 15:10' prior: 34829597!isOld	"Answer if I am installed and there also is a	newer version available *regardless* if it is	not published or not for this Squeak version.	This is for people who want to experiment!!"	| installed |	installed := map installedReleaseOf: self.	^installed		ifNil: [false]		ifNotNil: [			self releases anySatisfy: [:r |				r newerThan: installed ]]! !!SMPackage methodsFor: 'testing' stamp: 'gh 12/1/2002 19:40' prior: 34830039!isPackage	^true! !!SMPackage methodsFor: 'testing' stamp: 'gk 9/23/2003 21:35' prior: 34830137!isPublished	"Answer if I have public releases."	^releases anySatisfy: [:rel | rel isPublished]! !!SMPackage methodsFor: 'testing' stamp: 'btr 11/20/2003 00:05' prior: 34830318!isReleased	^ releases isEmpty not! !!SMPackage methodsFor: 'testing' stamp: 'gk 7/13/2004 15:37' prior: 34830434!isSafeToInstall	"Answer if I am NOT installed and there also is a	published version for this version of Squeak available."	^self isInstalled not and: [		self lastPublishedReleaseForCurrentSystemVersion notNil]! !!SMPackage methodsFor: 'testing' stamp: 'gk 7/14/2004 16:15' prior: 34830730!isSafelyAvailable	"Answer if I am old or not installed regardless of	if there is installer support for me. The	newer release should be published	and meant for this Squeak version."	^self isSafeToInstall or: [self isSafelyOld]! !!SMPackage methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34831055!isSafelyOld	"Answer if I am installed and there also is a	newer published version for this version of Squeak available."	| installed |	installed := self installedRelease.	^installed ifNil: [false] ifNotNil: [		^(self lastPublishedReleaseForCurrentSystemVersionNewerThan: installed) notNil]! !!SMPackage methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34831445!isSafelyOldAndUpgradeable	"Answer if I am installed and there also is a	newer published version for this version of Squeak available	that can be upgraded to (installer support)."	| installed newRelease |	installed := self installedRelease.	^installed ifNil: [false] ifNotNil: [		newRelease := self lastPublishedReleaseForCurrentSystemVersionNewerThan: installed.		^newRelease ifNil: [false] ifNotNil: [newRelease isUpgradeable]]! !!SMPackage methodsFor: 'services' stamp: 'gk 2/16/2004 20:14' prior: 34831965!lastPublishedRelease	"Return the latest published release."	^releases isEmpty ifTrue: [nil] ifFalse: [		releases reversed detect: [:r | r isPublished] ifNone:[nil]]! !!SMPackage methodsFor: 'services' stamp: 'gk 7/13/2004 13:28' prior: 34832216!lastPublishedReleaseForCurrentSystemVersion	"Return the latest published release marked	as compatible with the current SystemVersion."	^releases isEmpty ifTrue: [nil] ifFalse: [		releases reversed detect: [:r |			r isPublished and: [r isCompatibleWithCurrentSystemVersion]]				ifNone:[nil]]! !!SMPackage methodsFor: 'services' stamp: 'gk 7/14/2004 17:15' prior: 34832596!lastPublishedReleaseForCurrentSystemVersionNewerThan: aRelease	"Return the latest published release marked	as compatible with the current SystemVersion	that is newer than the given release."	^releases isEmpty ifTrue: [nil] ifFalse: [		releases reversed detect: [:r |			(r isPublished and: [r newerThan: aRelease])				and: [r isCompatibleWithCurrentSystemVersion]]				 	ifNone:[nil]]! !!SMPackage methodsFor: 'services' stamp: 'gk 8/4/2003 11:49' prior: 34833069!lastRelease	"Return the latest release."	^releases isEmpty ifTrue: [nil] ifFalse: [releases last]! !!SMPackage methodsFor: 'accessing' stamp: 'gk 1/25/2004 16:23' prior: 34833253!maintainer	"Deprecated"	^self owner! !!SMPackage methodsFor: 'deprecated' stamp: 'btr 11/20/2003 00:38' prior: 34833378!modulePath: p moduleVersion: v moduleTag: t versionComment: vc	"Deprecated. Only kept for migration from SM 1.0x.	Method used when recreating from storeOn: format."	self isReleased ifTrue: [self lastRelease note: vc]! !!SMPackage methodsFor: 'installation' stamp: 'gk 11/18/2003 02:14' prior: 34833686!nameWithVersionLabel	^name, ' (', self versionLabel, ')'! !!SMPackage methodsFor: 'private' stamp: 'gk 12/7/2005 14:15' prior: 34833825!newChildReleaseFrom: aRelease	"Create a new release."	^self addRelease: (map newObject: (SMPackageRelease newFromRelease: aRelease package: self))! !!SMPackage methodsFor: 'private' stamp: 'gk 12/7/2005 14:07' prior: 34834056!newRelease	"Create a new release. Just use the last	chronological release as parent, if this is the first release	that is nil."	^self newChildReleaseFrom: self lastRelease! !!SMPackage methodsFor: 'accessing' stamp: 'gk 7/12/2004 17:15' prior: 34834316!note	^self isPublished ifTrue: [self lastPublishedRelease note]! !!SMPackage methodsFor: 'accessing' stamp: 'gk 11/6/2003 15:24' prior: 34834464!packageInfoName	^packageInfoName! !!SMPackage methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34834593!packageInfoName: aString	packageInfoName := aString! !!SMPackage methodsFor: 'services' stamp: 'gk 5/5/2006 02:07' prior: 34834727!parentReleaseFor: aPackageRelease	"If there is none (the given release is automaticVersion '1'), return nil."	| previousVersion |	previousVersion := aPackageRelease automaticVersion previous.	^releases detect: [:r | r automaticVersion = previousVersion] ifNone: [nil]! !!SMPackage methodsFor: 'services' stamp: 'gh 11/27/2002 12:33' prior: 34835083!previousReleaseFor: aPackageRelease	"If there is none, return nil."		^releases before: aPackageRelease ifAbsent: [nil]! !!SMPackage methodsFor: 'accessing' stamp: 'gk 7/12/2004 17:13' prior: 34835288!publishedVersion	^self isPublished ifTrue: [self lastPublishedRelease version]! !!SMPackage methodsFor: 'services' stamp: 'gk 11/18/2003 17:39' prior: 34835451!releaseWithAutomaticVersion: aVersion	"Look up a specific package release of mine. Return nil if missing.	They are few so we just do a #select:."	^releases detect: [:rel | rel automaticVersion = aVersion ] ifNone: [nil]! !!SMPackage methodsFor: 'services' stamp: 'gk 11/18/2003 17:39' prior: 34835758!releaseWithAutomaticVersionString: aVersionString	"Look up a specific package release of mine. Return nil if missing.	They are few so we just do a #select:."	^self releaseWithAutomaticVersion: aVersionString asVersion! !!SMPackage methodsFor: 'services' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34836074!releaseWithId: anIdString 	"Look up a specific package release of mine. Return nil if missing.	They are few so we just do a #select:."	| anId |	anId := UUID fromString: anIdString.	releases detect: [:rel | rel id = anId ].	^nil! !!SMPackage methodsFor: 'services' stamp: 'gk 11/18/2003 17:41' prior: 34836392!releaseWithVersion: aVersionString	"Look up a specific package release of mine. Return nil if missing.	They are few so we just do a #select:."	^releases detect: [:rel | rel version = aVersionString ] ifNone: [nil]! !!SMPackage methodsFor: 'accessing' stamp: 'gh 12/1/2002 21:21' prior: 34836693!releases	^releases! !!SMPackage methodsFor: 'private' stamp: 'gh 11/28/2002 21:33' prior: 34836795!removeRelease: aRelease	"Remove the release."	releases remove: aRelease! !!SMPackage methodsFor: 'accessing' stamp: 'gk 10/12/2005 23:28' prior: 34836954!repository	^repository! !!SMPackage methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 34837060!repository: aString	repository := aString! !!SMPackage methodsFor: 'services' stamp: 'gk 7/13/2004 14:37' prior: 34837185!smartVersion	"Delegate to last published release for this SystemVersion."	| r |	r := self lastPublishedReleaseForCurrentSystemVersion.	^r ifNotNil: [r smartVersion] ifNil: ['']! !!SMPackage methodsFor: 'printing' stamp: 'gk 11/14/2003 00:12' prior: 34837450!type	^'Package'! !!SMPackage methodsFor: 'installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34837566!upgrade	"Upgrade to the latest newer published version for this version of Squeak."	| installed |	installed := self installedRelease.	installed		ifNil: [self error: 'No release installed, can not upgrade.']		ifNotNil: [^installed upgrade]! !!SMPackage methodsFor: 'installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34837910!upgradeOrInstall	"Upgrade to or install the latest newer published version for this version of Squeak."	| installed |	installed := self installedRelease.	installed		ifNil: [^self install]		ifNotNil: [^installed upgrade]! !!SMPackage methodsFor: 'installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34838235!versionLabel	"Return a label indicating installed and available version as:		'1.0'      = 1.0 is installed and no new published version for this version of Squeak is available		'1.0->1.1' = 1.0 is installed and 1.1 is published for this version of Squeak		'->1.1'    = No version is installed and 1.1 is published for this version of Squeak		'->(1.1)	 = No version is installed and there is only a non published version available for this version of Squeak	The version showed is the one that #smartVersion returns.	If a version name is in parenthesis it is not published."	| installedVersion r r2 |	r := self installedRelease.	r ifNotNil: [		installedVersion := r smartVersion.		r2 := self lastPublishedReleaseForCurrentSystemVersionNewerThan: r]	ifNil: [		installedVersion := ''.		r2 := self lastPublishedReleaseForCurrentSystemVersion ].	^r2 ifNil: [installedVersion ] ifNotNil: [installedVersion, '->', r2 smartVersion].! !!SMPackage methodsFor: 'view' stamp: 'gh 3/15/2003 18:05' prior: 34839255!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject packageViewOn: self! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 5/5/2006 02:07' prior: 34839477!addMaintainer: anAccount	"Add anAccount as a maintainer."	maintainers ifNil: [maintainers := OrderedCollection new].	maintainers add: anAccount.	anAccount addCoObject: self! !!SMMaintainableObject methodsFor: 'deletion' stamp: 'gk 7/27/2004 13:27' prior: 34839748!delete	"Disconnect from maintainers."	super delete.	maintainers ifNotNil: [		maintainers copy do: [:m | self removeMaintainer: m]]! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 10/12/2005 23:25' prior: 34839981!feedbackEmail	^feedbackEmail! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 5/5/2006 02:07' prior: 34840106!feedbackEmail: anEmail	feedbackEmail := anEmail! !!SMMaintainableObject methodsFor: 'testing' stamp: 'gk 7/27/2004 13:26' prior: 34840247!isOwnerOrMaintainer: anAccount	^ owner = anAccount or: [self maintainers includes: anAccount]! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 7/27/2004 13:26' prior: 34840438!maintainers	"Return all maintainers."	^maintainers ifNil: [#()]! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 7/27/2004 13:26' prior: 34840601!removeMaintainer: anAccount	"Remove anAccount as a maintainer."	maintainers ifNil: [^self].	maintainers remove: anAccount.	anAccount removeCoObject: self! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 7/27/2004 13:26' prior: 34840856!rss	^rss! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 5/5/2006 02:07' prior: 34840961!rss: anUrl	rss := anUrl! !!SMPersonalObject methodsFor: 'deletion' stamp: 'gk 10/20/2005 00:12' prior: 34841076!delete	"Disconnect from owner."	super delete.	owner removeObject: self! !!SMPersonalObject methodsFor: 'accessing' stamp: 'gk 8/7/2003 20:56' prior: 34841240!owner	^owner! !!SMPersonalObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34841356!owner: anAccount	owner := anAccount! !!SMResource commentStamp: '<historical>' prior: 34841454!A resource is a document that is NOT a package. Thus, it is used for all the things interesting to register on SM that aren't packages. The are three major differences with resources:- A resource keeps no track of version history like packages do with package releases. It only has a field for the current version.- A resource can be embedded inside the map instead of being a document reached by a URL.- A resource can be associated with another SMObject, the instvar object.However, resources respond to some of the same actions as PackageReleases.!!SMEmbeddedResource commentStamp: '<historical>' prior: 34842078!An embedded resource is a resource that is stored inside the map. No download is needed.This means that embedded resources should be "small" and typically only be used for information thatis needed to be available at all times without downloading. A typical example is meta data for other SMObjects.!!SMEmbeddedResource methodsFor: 'services' stamp: 'gk 3/8/2004 19:58' prior: 34842470!download	"A dummy method to respond as other resources would."	^true! !!SMEmbeddedResource methodsFor: 'services' stamp: 'gk 7/16/2004 11:03' prior: 34842633!ensureInCache	"Makes sure the file is in the cache.	An embedded resource doesn't have a file."	^true! !!SMEmbeddedResource methodsFor: 'testing' stamp: 'gk 8/12/2003 17:10' prior: 34842828!isCached	"Is the file corresponding to me in the local file cache?	Well consider it as true since I am embedded in the map."	^true! !!SMEmbeddedResource methodsFor: 'testing' stamp: 'gk 7/27/2004 14:31' prior: 34843053!isEmbedded	^ true! !!SMGenericEmbeddedResource commentStamp: 'gk 10/12/2005 23:01' prior: 34843155!A generic embedded resource is simply some kind of object, held in instvar #contents, that is stored inside the map. No download is needed.Embedded resources should be "small" and typically only be used for resources thatare needed to be available at all times without downloading. A typical example is meta data for other SMObjects.!!SMGenericEmbeddedResource methodsFor: 'as yet unclassified' stamp: 'gk 10/12/2005 23:00' prior: 34843601!contents	"Answers the contents object."	^contents! !!SMGenericEmbeddedResource methodsFor: 'as yet unclassified' stamp: 'gk 5/5/2006 02:07' prior: 34843762!contents: obj	"Sets the actual contents of this resource.	SM does not know what it is."		contents := obj! !!SMKabunguHint methodsFor: 'as yet unclassified' stamp: 'gk 10/12/2005 20:47' prior: 34843969!account		^ self owner! !!SMKabunguHint methodsFor: 'as yet unclassified' stamp: 'mist 8/22/2005 23:52' prior: 34844092!type	^ type! !!SMKabunguHint methodsFor: 'as yet unclassified' stamp: 'gk 5/5/2006 02:07' prior: 34844202!type: t	type := t! !!SMPackageReleaseConfiguration commentStamp: '<historical>' prior: 34844302!A package release configuration describes the result of testing the specific release with a set of other releases that it depends on.The status instvar holds a symbol which reflects the result. Currently there are two valid values:	#working	#failing	The intention is that users and maintainers post these configurations to the map as "known working combinations of required releases".Each SMPackageRelease can then have multiple of these configurations.!!SMPackageReleaseConfiguration methodsFor: 'dependencies' stamp: 'gk 5/5/2006 02:07' prior: 34844865!addRequiredRelease: aRelease	"Add <aRelease> as a required release. The release added	can not indirectly refer back to this release."		(self isCircular: aRelease) ifTrue: [self error: 'Circular dependencies not allowed.'].	requiredReleases := requiredReleases copyWith: aRelease.	^aRelease! !!SMPackageReleaseConfiguration methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 34845272!initialize	super initialize.	requiredReleases := #().	status := #working! !!SMPackageReleaseConfiguration methodsFor: 'private' stamp: 'gk 9/25/2004 00:22' prior: 34845449!isCircular: aRelease	"Answer if there is a reference that goes back	to the release of this configuration."	"This is the base case"	aRelease == object ifTrue: [^ true].		aRelease configurations do: [:conf |		conf requiredReleases do: [:rel |			(self isCircular: rel) ifTrue: [^ true]]].	^false! !!SMPackageReleaseConfiguration methodsFor: 'testing' stamp: 'gk 7/27/2004 14:29' prior: 34845853!isConfiguration	^true! !!SMPackageReleaseConfiguration methodsFor: 'testing' stamp: 'gk 7/27/2004 18:23' prior: 34845977!isFailing	^status == #failing! !!SMPackageReleaseConfiguration methodsFor: 'testing' stamp: 'gk 7/27/2004 14:56' prior: 34846109!isFulfilled	"Are all my required releases already installed?"		^requiredReleases allSatisfy: [:r | r isInstalled ]! !!SMPackageReleaseConfiguration methodsFor: 'testing' stamp: 'gk 7/27/2004 18:23' prior: 34846328!isWorking	^status == #working! !!SMPackageReleaseConfiguration methodsFor: 'printing' stamp: 'gk 7/28/2004 11:43' prior: 34846461!printOn: aStream	aStream nextPutAll: 'Cfg['.	requiredReleases do: [:r |		aStream nextPutAll: r printString; space].	aStream nextPutAll: ']'! !!SMPackageReleaseConfiguration methodsFor: 'dependencies' stamp: 'gk 5/5/2006 02:07' prior: 34846711!removeRequiredRelease: aRelease	"Remove <aRelease> as a required release."		requiredReleases := requiredReleases copyWithout: aRelease.	^ aRelease! !!SMPackageReleaseConfiguration methodsFor: 'accessing' stamp: 'gk 7/27/2004 14:22' prior: 34846965!requiredReleases	^ requiredReleases! !!SMPackageReleaseConfiguration methodsFor: 'accessing' stamp: 'gk 7/27/2004 14:22' prior: 34847105!status	^ status! !!SMExternalResource commentStamp: 'gk 3/8/2004 20:09' prior: 34847196!An external resource is a downloadable resource.The instance variable downloadUrl holds the URL to the resource and the resource is cacheable in the FileCache for the SqueakMap.An external resource can be used for any kind of document that is to be attached to another SMObject.!!SMExternalResource methodsFor: 'accessing' stamp: 'btr 5/28/2003 04:13' prior: 34847568!cacheDirectory	^ map cache directoryForResource: self! !!SMExternalResource methodsFor: 'accessing' stamp: 'gk 4/19/2006 01:32' prior: 34847715!contents	"Return the contents of a stream from the downloaded resource.	Not yet tested, this resource returns the stream and not its contents."	map cache add: self.	^(self cacheDirectory readOnlyFileNamed: self downloadFileName) binary; yourself! !!SMExternalResource methodsFor: 'services' stamp: 'gk 8/13/2003 15:42' prior: 34848057!download	"Force a download into the cache regardless if it is already there."	^map cache download: self! !!SMExternalResource methodsFor: 'accessing' stamp: 'btr 5/28/2003 04:13' prior: 34848257!downloadFileName	"Cut out the filename from the url."	downloadUrl isEmpty ifTrue: [^nil].	^downloadUrl asUrl path last! !!SMExternalResource methodsFor: 'accessing' stamp: 'btr 5/28/2003 04:14' prior: 34848473!downloadUrl	^ downloadUrl! !!SMExternalResource methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34848604!downloadUrl: anUrl	downloadUrl := anUrl! !!SMExternalResource methodsFor: 'services' stamp: 'gk 8/13/2003 15:54' prior: 34848736!ensureInCache	"Makes sure the file is in the cache."	^map cache add: self! !!SMExternalResource methodsFor: 'testing' stamp: 'gk 8/13/2003 15:32' prior: 34848903!isCached	"Is the file corresponding to me in the local file cache?"	^map cache includes: self! !!SMExternalResource methodsFor: 'accessing' stamp: 'gk 7/16/2004 11:09' prior: 34849092!isDownloadable	"Answer if I can be downloaded.	We simply verify that the download url	ends with a filename."	^self downloadFileName isEmptyOrNil not! !!SMResource class methodsFor: 'instance creation' stamp: 'btr 5/28/2003 04:31' prior: 34849345!forString: aString	^ SMEmbeddedResource new content: aString! !!SMResource class methodsFor: 'instance creation' stamp: 'btr 5/28/2003 04:30' prior: 34849506!forUrl: anUrl	^ SMExternalResource new downloadUrl: anUrl; yourself! !!SMResource methodsFor: 'testing' stamp: 'gk 7/27/2004 14:30' prior: 34849657!isConfiguration	^ false! !!SMResource methodsFor: 'testing' stamp: 'gk 7/27/2004 14:31' prior: 34849764!isEmbedded	^false! !!SMResource methodsFor: 'testing' stamp: 'btr 5/28/2003 04:25' prior: 34849866!isResource	^ true! !!SMResource methodsFor: 'accessing' stamp: 'gk 7/27/2004 13:12' prior: 34849969!object	^object! !!SMResource methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 34850068!object: anSMCategorizableObject	object := anSMCategorizableObject! !!SMResource methodsFor: 'accessing' stamp: 'gk 9/23/2003 21:55' prior: 34850219!version	^ version! !!SMResource methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34850334!version: aVersion	version := aVersion! !!SMCategory commentStamp: 'gk 3/8/2004 19:44' prior: 34850439!An SMCategory is a "tag" that can be attached to SMCategorizableObjects in order to classify them.The SMCategories are arranged in a strict hierarchy and each SMCategory both knows it's parent and it's subcategories.The instvar objects holds all SMObjects belonging to this category.Instvars name and summary are already inherited from SMObject and describe the category.The instvar url can be used to refer to a web page that can explain the category in more detail, typically a page at the Squeak Swiki.SMCategory adds an instance variable called mandatory holding a Set with the classes (SMPackage, SMPackageRelease, SMAccount, SMResource etc) that must belong to at least one subcategory of this SMCategory. Obviously not many categories will be mandatory for each class.The category tree is maintained by a few trusted people so that chaos will not reign. :-)!!SMCategory methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34851405!addCategory: cat	"Add a category as a subcategory to self.	The collection of subcategories is lazily instantiated."	subCategories ifNil: [subCategories := OrderedCollection new].	cat parent ifNotNil: [cat parent removeCategory: cat ].	subCategories add: cat.	cat parent: self.	^cat! !!SMCategory methodsFor: 'private' stamp: 'gk 9/23/2003 21:59' prior: 34851777!addObject: anObject	"Add <anObject> to this category. This should only be called	from SMCategorizableObject>>addCategory: to ensure consistency."		(objects includes: anObject) ifFalse:[objects add: anObject]! !!SMCategory methodsFor: 'services' stamp: 'gk 11/17/2003 10:48' prior: 34852073!allCategoriesDo: aBlock	"Evaluate <aBlock> for all categories below me including me,	bottom up breadth-first."	self allSubCategoriesDo: aBlock.	aBlock value: self! !!SMCategory methodsFor: 'services' stamp: 'gk 7/9/2004 02:59' prior: 34852323!allSubCategoriesDo: aBlock	"Evaluate <aBlock> for all categories below me NOT including me,	bottom up breadth-first."	subCategories ifNil: [^self].	subCategories do: [:sub |		sub allSubCategoriesDo: aBlock.		aBlock value: sub]! !!SMCategory methodsFor: 'services' stamp: 'gh 8/5/2002 17:10' prior: 34852639!categoryBefore	"Return the category listed before me in my parent.	If I am first or I have no parent, return nil."	parent isNil ifTrue:[^nil].	parent subCategories first = self ifTrue:[^nil].	^parent subCategories before: self	! !!SMCategory methodsFor: 'private' stamp: 'gk 11/24/2005 11:37' prior: 34852957!delete	"Delete me. Disconnect me from my objects and my parent.	Then delete my subcategories."	super delete.	self removeFromObjects; removeFromParent.	self subCategories do: [:c | c delete ]! !!SMCategory methodsFor: 'view' stamp: 'gk 10/12/2005 12:24' prior: 34853234!getLink: aBuilder	"Return a link for using on the web.	Always from the top."	^aBuilder getLinkTop: 'category/', id asString text: name! !!SMCategory methodsFor: 'testing' stamp: 'gh 12/1/2002 20:24' prior: 34853455!hasSubCategories	^subCategories isEmptyOrNil not! !!SMCategory methodsFor: 'testing' stamp: 'gk 8/7/2003 22:31' prior: 34853586!includes: anObject	"Answer if <anObject> is in this category."	^objects includes: anObject! !!SMCategory methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34853785!initialize	super initialize.	name := summary := url := ''.	objects := OrderedCollection new! !!SMCategory methodsFor: 'testing' stamp: 'gh 12/1/2002 19:51' prior: 34853962!isCategory	^true! !!SMCategory methodsFor: 'testing' stamp: 'gh 6/27/2002 13:31' prior: 34854062!isTopCategory	^parent isNil! !!SMCategory methodsFor: 'accessing' stamp: 'gk 11/17/2003 13:51' prior: 34854176!mandatory	^mandatory! !!SMCategory methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34854294!mandatory: aSet	mandatory := aSet! !!SMCategory methodsFor: 'accessing' stamp: 'gk 11/17/2003 21:35' prior: 34854414!mandatoryFor: aClass	"Is this category mandatory for instances of <aClass>?"	^mandatory ifNil: [false] ifNotNil: [mandatory includes: aClass]! !!SMCategory methodsFor: 'services' stamp: 'gh 8/5/2002 14:36' prior: 34854641!move: cat toAfter: before	"Move a category to be after the category <before>."	subCategories remove: cat.	before ifNil: [subCategories addFirst: cat] ifNotNil: [subCategories add: cat after: before]! !!SMCategory methodsFor: 'accessing' stamp: 'gh 8/1/2002 16:54' prior: 34854927!objects	"Return all objects in this category."	^objects! !!SMCategory methodsFor: 'accessing' stamp: 'gk 8/7/2003 23:42' prior: 34855069!packages	"Return all packages in this category."	^objects select: [:p | p isPackage]! !!SMCategory methodsFor: 'accessing' stamp: 'gh 6/27/2002 16:01' prior: 34855241!parent	^parent! !!SMCategory methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34855351!parent: aCategory	"Change the parent category.	This method relies on that somebody else	updates the parent's subCategories collection."		parent := aCategory! !!SMCategory methodsFor: 'services' stamp: 'gh 8/1/2002 17:30' prior: 34855595!parentsDo: aBlock	"Run a block for all my parents starting from the top."	parent ifNotNil: [		parent parentsDo: aBlock.		aBlock value: parent]! !!SMCategory methodsFor: 'printing' stamp: 'gk 1/29/2004 00:14' prior: 34855826!path	"Return my name with a full path of my	parent names separated with slashes like:		'Squeak versions/Squeak3.5' "	^String streamContents: [:s |		self parentsDo: [:cat |			s nextPutAll: cat name; nextPutAll: '/'].		s nextPutAll: self name]! !!SMCategory methodsFor: 'printing' stamp: 'gh 8/16/2002 06:04' prior: 34856159!printOn: aStream	aStream nextPutAll: self class name, ': ', name! !!SMCategory methodsFor: 'private' stamp: 'gk 11/24/2005 11:34' prior: 34856309!removeDeepFromObjects	"Remove myself from my objects and then ask	my subCategories to do the same."	self removeFromObjects.	subCategories do: [:cat | cat removeDeepFromObjects]! !!SMCategory methodsFor: 'private' stamp: 'gh 12/1/2002 20:03' prior: 34856573!removeFromObjects	"Remove myself from my objects."	objects copy do: [:obj | obj removeCategory: self]! !!SMCategory methodsFor: 'private' stamp: 'gh 12/1/2002 20:28' prior: 34856760!removeFromParent	"Remove me from my parent."	parent ifNotNil: [parent removeCategory: self]! !!SMCategory methodsFor: 'private' stamp: 'gh 12/1/2002 20:28' prior: 34856937!removeObject: anObject	"Remove <anObject> from this category. This should only be called	from SMCategorizableObject>>removeCategory: to ensure consistency."		^objects remove: anObject! !!SMCategory methodsFor: 'accessing' stamp: 'gh 6/27/2002 12:25' prior: 34857209!subCategories	subCategories ifNil: [^#()].	^subCategories! !!SMCategory methodsFor: 'printing' stamp: 'gk 11/14/2003 00:13' prior: 34857353!type	^'Category'! !!SMCategory methodsFor: 'view' stamp: 'gh 8/1/2002 16:38' prior: 34857450!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject categoryViewOn: self! !!SMObject class methodsFor: 'instance creation' stamp: 'gk 12/7/2005 13:53' prior: 34857674!newIn: aMap	"Create a new object in a given map with an UUID to ensure unique identity."	^(super basicNew) map: aMap id: UUID new! !!SMObject methodsFor: 'comparing' stamp: 'gk 9/22/2004 23:21' prior: 34857889!<= anSMObject	^name <= anSMObject name! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/16/2002 23:12' prior: 34858012!created	^TimeStamp fromSeconds: created! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34858147!created: c	created := c! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/16/2002 23:12' prior: 34858254!createdAsSeconds	^created! !!SMObject methodsFor: 'deletion' stamp: 'gk 8/8/2003 10:10' prior: 34858361!delete	"Delete from map."	map deleteObject: self! !!SMObject methodsFor: 'printing' stamp: 'gk 11/14/2003 14:22' prior: 34858495!describe: string withBoldLabel: label on: stream	"Helper method for doing styled text."	stream withAttribute: (TextEmphasis bold) do: [ stream nextPutAll: label ].	stream nextPutAll: string; cr! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/16/2002 23:12' prior: 34858775!id	^id! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34858877!id: anId	id := anId! !!SMObject methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34859001!initialize	"Initialize the receiver."	updated := created := TimeStamp current asSeconds.	name := summary := url := ''.! !!SMObject methodsFor: 'testing' stamp: 'gk 6/26/2003 16:47' prior: 34859204!isAccount	^false! !!SMObject methodsFor: 'testing' stamp: 'gh 12/1/2002 19:51' prior: 34859302!isCategory	^false! !!SMObject methodsFor: 'testing' stamp: 'gh 12/1/2002 19:40' prior: 34859401!isPackage	^false! !!SMObject methodsFor: 'testing' stamp: 'gh 12/1/2002 19:51' prior: 34859499!isPackageRelease	^false! !!SMObject methodsFor: 'testing' stamp: 'gh 12/1/2002 19:51' prior: 34859604!isResource	^false! !!SMObject methodsFor: 'accessing' stamp: 'gh 8/15/2002 08:50' prior: 34859705!map	^map! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34859809!map: aMap	map := aMap! !!SMObject methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34859935!map: aMap id: anId	"Initialize the receiver."	self initialize.	map := aMap.	id := anId! !!SMObject methodsFor: 'accessing' stamp: 'gh 6/26/2002 15:31' prior: 34860109!name	^name! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34860215!name: aName	name := aName! !!SMObject methodsFor: 'printing' stamp: 'gk 7/10/2004 03:39' prior: 34860323!printName	"Return a String identifying receiver without a context.	Default is name."	^self name! !!SMObject methodsFor: 'printing' stamp: 'gk 8/4/2003 11:56' prior: 34860503!printOn: aStream	aStream nextPutAll: self class name, '[', name, ']'! !!SMObject methodsFor: 'updating' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34860667!stampAsUpdated	"This method should be called whenever the object is modified."	updated := TimeStamp current asSeconds! !!SMObject methodsFor: 'accessing' stamp: 'gh 6/26/2002 15:33' prior: 34860870!summary	^summary! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34860982!summary: aString	summary := aString! !!SMObject methodsFor: 'printing' stamp: 'gk 11/14/2003 00:11' prior: 34861101!type	^'Object'! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:44' prior: 34861200!updated	^TimeStamp fromSeconds: updated! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34861335!updated: c	updated := c! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:45' prior: 34861442!updatedAsSeconds	^updated! !!SMObject methodsFor: 'accessing' stamp: 'gh 6/26/2002 15:36' prior: 34861551!url	^url! !!SMObject methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34861655!url: aString	url := aString! !!SMObject methodsFor: 'accessing' stamp: 'gh 11/27/2002 12:21' prior: 34861767!userInterface	"Return the object that we use for interacting with the user."	^SMUtilities! !!SMObject methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 34861939!withId: aUUIDString in: aCollection	"Return the object with the corresponding id	and nil if not found."	| uuid |	uuid := UUID fromString: aUUIDString.	^aCollection detect: [:o | o id = uuid ] ifNone: [nil]! !!SMSqueakMap commentStamp: '<historical>' prior: 34862213!SqueakMap is a Squeak meta catalog, primarily a catalog of all available Squeak packages.SMSqueakMap is the class for the domain model.One master instance lives on a server on the Internet at map1.squeakfoundation.org (but there are fallback servers too). Then each Squeak connected to the Internet has one instance that is synchronized against the master. This way every user can have an updated catalog of all available Squeak software on the planet locally on their machine. :-)Typically you only need one instance of SMSqueakMap per image and it is held by a singleton class variable reached with "SMSqueakMap default". If it is not there it will then be created together with it's own directory on disk by default the "sm" directory created in your default directory.Synching with the master is the only action that affects the map so you can actually use the same map from multiple images (they will by default use the same snapshot files if the images have the same default directory) and multiple tools (SMLoader, SMBrowser or others).An instance of SMSqueakMap contains instances of SMPackage which which represent Squeak packages and SMCategories which are centrally registered values that can be included as attributes in an SMPackage. An example of such a category would be different kinds of licenses, topic etc. etc.It also contains instances of SMAccount which are registered Squeak developers, the maintainers of the packages.Finally SMSqueakMap also refers to a registry object (SMInstallationRegistry) which records what packages and releases of them have been installed in the image--------------------"Simplest use of SMSqueakMap - this will create a map if you don't have one and open a simple UI""SMLoader openUse these doits to play "hands on" with a SqueakMap."Creating another SqueakMap in directory 'slavemap' instead of default 'sm'"Smalltalk at: #AnotherSqueakMap put: (SMSqueakMap newIn: 'slavemap')"Update the default map by synching it with the master - check Transcript for some numbers."SMSqueakMap default loadUpdates"If the map is broken in some way, reload it from disk"SMSqueakMap default reload"Clear out the contents of the map to save image space, this does not remove the registry."SMSqueakMap default purge!!SMSqueakMap class methodsFor: 'changelog replay' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34864601!askUser	"Ask user about how to handle a replayed installation note	when there is no current SqueakMap in the image."	| choice |	[choice := UIManager default chooseFrom: #('Yes' 'No' 'More info')				title:'There is no SqueakMap in this image,do you wish to create/recreate it? (typical answer is Yes)' .			choice = 3] whileTrue: [self inform:'When packages are installed using SqueakMap a little mark is madein the change log. When an image is reconstructed from the changelogthese marks are intended to keep your map informed about what packagesare installed. You probably already have a map on disk which will automatically bereloaded if you choose ''Yes'', otherwise an new empty map will be created.If you choose ''No'', it will only result in that SqueakMap will not know that this packageis installed in your image.If you are still unsure - answer ''Yes'' since that is probably the best.'].	^choice = 1! !!SMSqueakMap class methodsFor: 'bootstrap upgrade' stamp: 'gk 3/31/2006 01:05' prior: 34865627!bootStrap	"Bootstrap upgrade. Only used when SqueakMap itself is too old to	communicate with the server. This relies on the existence of a package	called SqueakMap that is a .st loadscript. The loadscript needs to do its	own changeset management."	| server url |	server := self findServer.	server ifNotNil: ["Ok, found a SqueakMap server"		url := (('http://', server, '/packagebyname/squeakmap/downloadurl')				asUrl retrieveContents content) asUrl.		(url retrieveContents content unzipped readStream)				fileInAnnouncing: 'Upgrading SqueakMap...']! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34866299!clear	"Clear out the model in the image. This will forget	about what packages are installed and what versions.	The map is itself on disk though and will be reloaded.		If you only want to reload the map and not forget about	installed packages then use 'SMSqueakMap default reload'.	If you want to throw out the map perhaps when shrinking	an image, then use 'SMSqueakMap default purge'."	"SMSqueakMap clear"	DefaultMap := nil! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34866847!default	"Return the default map, create one if missing."	"SMSqueakMap default"	^DefaultMap ifNil: [DefaultMap := self new]! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'gh 10/21/2002 15:05' prior: 34867075!defaultNoCreate	"Return the default map or nil if there is none."	"SMSqueakMap defaultNoCreate"	^DefaultMap! !!SMSqueakMap class methodsFor: 'discarding' stamp: 'gk 7/14/2003 15:04' prior: 34867280!discardSM	"Discard SqueakMapBase. All the map state is kept in	the class var DefaultMap in SMSqueakMap and is thus also removed."	"SMSqueakMap discardSM"	SystemOrganization removeCategoriesMatching: 'SM-domain'.! !!SMSqueakMap class methodsFor: 'server detection' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34867608!findServer	"Go through the list of known master servers, ping 	each one using simple http get on a known 'ping'-url 	until one responds return the server name. 	If some servers are bypassed we write that to Transcript. 	If all servers are down we inform the user and return nil."	| notAnswering deafServers |	Socket initializeNetwork.	notAnswering := OrderedCollection new.	Cursor wait		showWhile: [ServerList				do: [:server | (self pingServer: server)						ifTrue: [notAnswering isEmpty								ifFalse: [deafServers := String												streamContents: [:str | notAnswering														do: [:srvr | str nextPutAll: srvr printString;																 nextPut: Character cr]].									Transcript show: ('These SqueakMap master servers did not respond:\' , deafServers , 'Falling back on ' , server printString , '.') withCRs].							^ server]						ifFalse: [notAnswering add: server]]].	deafServers := String				streamContents: [:str | notAnswering						do: [:srvr | str nextPutAll: srvr printString;								 nextPut: Character cr]].	self error: ('All SqueakMap master servers are down:\' , deafServers , '\ \Can not update SqueakMap...') withCRs.	^ nil! !!SMSqueakMap class methodsFor: 'class initialization' stamp: 'gk 5/5/2006 02:07' prior: 34868889!initialize	"Initialize the list of master servers.	The last one is for debugging/development."	"self initialize"	ServerList := #('map.squeak.org' 'map1.squeakfoundation.org' 'map2.squeakfoundation.org' '127.0.0.1:8080')! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'gh 10/22/2002 17:41' prior: 34869215!new	"Create a new server in a new directory	under the default directory called 'sm'."	^super new initializeOn: 'sm'! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'gh 8/15/2002 07:02' prior: 34869434!newIn: directoryName	"Create a new server in a new directory	under the default directory called <directoryName>."	^super new initializeOn: directoryName! !!SMSqueakMap class methodsFor: 'changelog replay' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34869701!noteInstalledPackage: uuidString version: version	"We are replaying a change that indicates that a package	was just installed. If there is a map we let it record this,	otherwise we ask the user if we should create/recreate the map."	| choice |	DefaultMap		ifNotNil: [DefaultMap noteInstalledPackage: uuidString version: version]		ifNil: [			[choice := UIManager default chooseFrom: #('Yes' 'No' 'More info')				title:'There is no SqueakMap in this image,do you wish to create/recreate it? (typical answer is Yes)' .			choice = 3] whileTrue: [self inform:'When packages are installed using SqueakMap a little mark is madein the change log. When an image is reconstructed from the changelogthese marks are intended to keep your map informed about what packagesare installed. You probably already have a map on disk which will automatically bereloaded if you choose ''Yes'', otherwise an new empty map will be created.If you choose ''No'', it will only result in that SqueakMap will not know that this packageis installed in your image.If you are still unsure - answer ''Yes'' since that is probably the best.'].			choice = 1				ifTrue:[self default noteInstalledPackage: uuidString version: version]]! !!SMSqueakMap class methodsFor: 'changelog replay' stamp: 'gk 7/29/2003 01:01' prior: 34871021!noteInstalledPackage: uuidString version: version atSeconds: sec number: num	"We are replaying a change that indicates that a package	was just installed. If there is a map we let it record this,	otherwise we ask the user if we should create/recreate the map."	DefaultMap		ifNotNil: [DefaultMap noteInstalledPackage: uuidString version: version					atSeconds: sec number: num]		ifNil: [			self askUser				ifTrue:[self default noteInstalledPackage: uuidString version: version							atSeconds: sec number: num]]! !!SMSqueakMap class methodsFor: 'changelog replay' stamp: 'gk 11/17/2003 01:20' prior: 34871641!noteInstalledPackageWithId: uuidString autoVersion: version atSeconds: sec number: num	"We are replaying a change that indicates that a package release	was just installed using SM2. If there is a map we let it record this,	otherwise we ask the user if we should create/recreate the map."	DefaultMap		ifNotNil: [DefaultMap noteInstalledPackageWithId: uuidString autoVersion: version					atSeconds: sec number: num]		ifNil: [			self askUser				ifTrue:[self default noteInstalledPackageWithId: uuidString autoVersion: version							atSeconds: sec number: num]]! !!SMSqueakMap class methodsFor: 'changelog replay' stamp: 'gk 11/17/2003 01:18' prior: 34872309!noteInstalledPackageWithId: uuidString version: version atSeconds: sec number: num	"We are replaying a change that indicates that a package release	was just installed using SM2. If there is a map we let it record this,	otherwise we ask the user if we should create/recreate the map."	DefaultMap		ifNotNil: [DefaultMap noteInstalledPackageWithId: uuidString version: version					atSeconds: sec number: num]		ifNil: [			self askUser				ifTrue:[self default noteInstalledPackageWithId: uuidString version: version							atSeconds: sec number: num]]! !!SMSqueakMap class methodsFor: 'server detection' stamp: 'gk 5/5/2006 02:07' prior: 34872963!pingServer: aServerName	"Check if the SqueakMap server is responding.	For an old image we first make sure the name resolves -	the #httpGet: had such a long timeout (and hanging?)	for resolving the name."	| url answer |	"Only test name lookup first if image is before the network rewrite,	after the rewrite it works."	[(SystemVersion current highestUpdate < 5252)		ifTrue: [NetNameResolver addressForName: (aServerName upTo: $:) timeout: 5].	url := 'http://', aServerName, '/ping'.	answer := HTTPSocket httpGet: url]				on: Error do: [:ex | ^false].	^answer isString not and: [answer contents = 'pong']! !!SMSqueakMap class methodsFor: 'migration' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34873682!recreateInstalledPackagesFromChangeLog	"Clear and recreate the Dictionary with information on installed packages.	NOTE: This takes some time to run and will only find packages installed using SM	and since the last changelog condense.	For packages installed prior to SqueakMap 1.07 there is no timestamp nor counter	logged. These packages will be given the time of the replay and a separate count	(from -10000 upwards) maintaining correct order of installation."	"SMSqueakMap recreateInstalledPackagesFromChangeLog"	| changesFile chunk |	SMSqueakMap default clearInstalledPackages.	changesFile := (SourceFiles at: 2) readOnlyCopy.	[changesFile atEnd]		whileFalse: [			chunk := changesFile nextChunk.			((chunk beginsWith: '"Installed') and: [				(chunk indexOfSubCollection: 'SMSqueakMap noteInstalledPackage:'					startingAt: 10) > 0])				ifTrue: [Compiler evaluate: chunk logged: false]].	changesFile close! !!SMSqueakMap class methodsFor: 'constants' stamp: 'gk 4/4/2006 01:13' prior: 34874702!version	"This is the protocol version number used for clients to decide if	they need to update SMSqueakMap before synching with	the master. In short - only increase this if changes have made	the clients incompatible so that they need to be updated.	2.0: Removed Module stuff and added Package releases.	2.1: Various changes/additions and class shape changes.	2.2: Various 3.9 related fixes and bug fix in segment compression etc."	^'2.2'! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 8/4/2003 11:50' prior: 34875232!accountForEmail: email	"Find account given email."	^self accounts detect: [:a | a email = email] ifNone: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34875441!accountForName: name	"Find account given full name. Disregarding case	and allows up to 2 different characters.	Size must match though, someone else can be smarter -	this is just for migrating accounts properly."	| lowerName size aName |	lowerName := name asLowercase.	size := lowerName size.	^self accounts		detect: [:a |			aName := a name asLowercase.			(aName size = size) and: [| errors |				errors := 0.				aName with: lowerName do: [:c1 :c2 |					c1 ~= c2 ifTrue: [errors := errors + 1]].				errors < 3			]]		ifNone: [nil]		! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 7/30/2003 14:11' prior: 34876073!accountForUsername: username	"Find account given username. The username used	is the developer initials of the account."	^self users at: username ifAbsent: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34876333!accountWithId: anIdString 	"Look up an account. Return nil if missing.	Raise error if it is not an account."	| account |	account := self objectWithId: anIdString.	account ifNil: [^nil].	account isAccount ifTrue:[^account].	self error: 'UUID did not map to a account.'! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 2/7/2004 14:55' prior: 34876691!accountWithName: aName	"Look up an account by name. Return nil if missing."	^self accounts values detect: [:a | a name = aName ] ifNone: [nil]! !!SMSqueakMap methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34876934!accounts	"Lazily maintain a cache of all known account objects."	accounts ifNotNil: [^accounts].	accounts := objects select: [:o | o isAccount].	^accounts! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 12/3/2004 12:03' prior: 34877177!accountsByInitials	"Return the accounts sorted by the developer initials."	^self accounts asSortedCollection: [:x :y | x initials caseInsensitiveLessOrEqual: y initials]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 12/3/2004 12:03' prior: 34877433!accountsByName	"Return the accounts sorted by their name."	^self accounts asSortedCollection: [:x :y | x name caseInsensitiveLessOrEqual: y name].! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gk 11/17/2003 10:30' prior: 34877673!addCategory: category inObject: object	"Add a category in an object."	^object addCategory: category! !!SMSqueakMap methodsFor: 'transactions' stamp: 'gk 10/10/2003 11:30' prior: 34877866!addDirty: anSMObject	"Add the SMObject to the dirty list making	sure it gets committed when transaction ends.""In first SM2 version we do nothing""	dirtyList add: anSMObject"! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gk 2/7/2004 14:56' prior: 34878135!addObject: anSMObject 	"Add a new object, only if not already added."	(self object: anSMObject id) ifNil: [		self transaction: [self newObject: anSMObject]]! !!SMSqueakMap methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34878393!adminPassword: aString	"We store the password as a SHA hash so that we can let the slave maps	have it too."	adminPassword := SecureHashAlgorithm new hashMessage: aString! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gk 11/14/2003 12:06' prior: 34878659!allPackages	"Answer all packages."	^self packages! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 12/1/2002 19:53' prior: 34878803!availablePackages	"Answer all packages that are old or not installed."	^self packages select: [:package | package isAvailable]! !!SMSqueakMap methodsFor: 'accessing' stamp: 'btr 5/28/2003 02:16' prior: 34879019!cache	^ fileCache! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 2/13/2009 15:11' prior: 34879123!categories	"Lazily maintain a cache of all known category objects."	categories ifNotNil: [^categories].	objects isNil ifTrue: [ ^ #() ].	categories := objects select: [:o | o isCategory].	^categories! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34879424!categoryWithId: anIdString 	"Look up a category. Return nil if missing.	Raise error if it is not a category."	| cat |	cat := self objectWithId: anIdString.	cat ifNil: [^nil].	cat isCategory ifTrue:[^cat].	self error: 'UUID did not map to a category.'! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34879778!categoryWithNameBeginning: aString	"Look up a category beginning with <aString>. Return nil if missing.	We return the shortest matching one. We also strip out spaces and	ignore case in both <aString> and the names."	| candidates shortest answer searchString |	searchString := (aString asLowercase) copyWithout: Character space.	candidates := self categories select: [:cat |		((cat name asLowercase) copyWithout: Character space)			beginsWith: searchString ].	shortest := 1000.	candidates do: [:ca |		ca name size < shortest ifTrue:[answer := ca. shortest := ca name size]].	^answer	! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 11/28/2002 20:44' prior: 34880464!changeCategoriesTo: newCategories inObject: object	"Remove or add categories in an object such that	it belongs to the categories in <newCategories>.	Logs the changes."	newCategories do: [:cat |		(object hasCategory: cat)			ifFalse:[self addCategory: cat inObject: object]].	object categories do: [:cat |		(newCategories includes: cat)			ifFalse: [self removeCategory: cat inObject: object]]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 5/5/2006 02:07' prior: 34880948!check	"Sanity checks."	"SMSqueakMap default check"		(((self packages inject: 0 into: [:sum :p | sum := sum + p releases size]) +	self accounts size +	self packages size +	self categories size) = SMSqueakMap default objects size)		ifFalse: [self error: 'Count inconsistency in map'].		objects do: [:o |		o map == self			ifFalse: [self error: 'Object with wrong map']].	self packages do: [:p |		(p releases allSatisfy: [:r | r map == self])			ifFalse: [self error: 'Package with release pointing to wrong map']].			self packageReleases do: [:r |		r package map == self ifFalse: [self error: 'Release pointing to package in wrong map']]! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 10/31/2002 11:59' prior: 34881685!checkVersion: string	"Check the content for a SqueakMap version conflict notification.	Return true if no conflict is reported, otherwise ask user if we	should upgrade SqueakMap using the bootstrap method."	(string beginsWith: 'Server version:')		ifTrue:[(self confirm: ('The SqueakMap master server is running another version (', (string last: (string size - 15)), ') than the client (', SMSqueakMap version, ').You need to upgrade the SqueakMap package, would you like to do that now?'))			ifTrue: [self class bootStrap. ^false]			ifFalse: [^false]	].	^true! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 10/21/2003 23:02' prior: 34882341!checkpointNumber	^checkpointNumber! !!SMSqueakMap methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34882473!clearCaches	"Clear the caches."	packages := accounts := users := categories := nil! !!SMSqueakMap methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34882655!clearCachesFor: anObject 	"Clear the valid caches."	anObject isPackage ifTrue:[packages := nil].	anObject isAccount ifTrue:[accounts := users := nil].	anObject isCategory ifTrue:[categories := nil]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 34882953!clearInstalledPackageWithId: aPackageId	"Clear the fact that any release of this package is installed.	Can be used even when the map isn't loaded."	^self registry clearInstalledPackageWithId: aPackageId! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 34883254!clearInstalledPackages	"Simply clear the dictionary with information on installed packages.	Might be good if things get corrupted etc. Also see	SMSqueakMap class>>recreateInstalledPackagesFromChangeLog"	^self registry clearInstalledPackages! !!SMSqueakMap methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34883595!clearUsernames	"Clear the username cache."	users := nil! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 3/31/2006 20:58' prior: 34883741!compressFile: aFileStream	"Shamelessly copied and modified from StandardFileStream>>compressFile."		| zipped buffer |	aFileStream binary.	zipped := StandardFileStream newFileNamed: (self directory fullNameFor: (aFileStream name, 'gz')).	zipped binary; setFileTypeToObject.	"Type and Creator not to be text, so can be enclosed in an email"	zipped := GZipWriteStream on: zipped.	buffer := ByteArray new: 50000.	[[aFileStream atEnd] whileFalse: [		zipped nextPutAll: (aFileStream nextInto: buffer)]]		ensure: [zipped close. aFileStream close].	self directory deleteFileNamed: aFileStream name! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 34884426!copyFrom: aMap	"Copy all relevant info from the other map."	objects := aMap objects.	objects do: [:o | o map: self].	accounts := users := packages := categories := nil.	checkpointNumber := aMap checkpointNumber! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 14:47' prior: 34884731!createCheckpoint	"Export a new checkpoint of me using an ImageSegment."	^self createCheckpointNumber: 		(self nextFileNameForCheckPoint findTokens: '.') second asNumber.! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34885005!createCheckpointNumber: number	"Export me using an ImageSegment.	This is used for checkpointing the map on disk	in a form that can be brought into an independent image.	We do not overwrite older versions, since using ImageSegments	is an intermediate hack anyway we don't care about the disk waste!!	Sidenote: Some refactoring was needed to produce a .gz file directly so	I didn't bother."	| is fname stream oldMutex |	fname := self filename, '.', number asString, '.s'.	(self directory fileExists: fname) ifTrue: [self error: 'Checkpoint already exists!!'].	stream := StandardFileStream newFileNamed: (self directory fullNameFor: fname).	checkpointNumber := number.	oldMutex := mutex.	mutex := nil. self clearCaches.	[is := ImageSegment new.	is copyFromRoots: (Array with: self) sizeHint: 1000000 areUnique: true.	is writeForExportOn: stream.	self compressFile: (StandardFileStream oldFileNamed: (self directory fullNameFor: fname)).	isDirty := false]		ensure: [mutex := oldMutex].	^is! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 8/8/2003 19:10' prior: 34886095!deleteObject: anObject 	"Delete an object, remove it from objects.	This method is called from the #delete method of	anObject so it will take care of the rest of the	cleaning up. Clear the valid caches."	objects removeKey: anObject id.	self clearCachesFor: anObject! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 5/22/2004 21:56' prior: 34886453!directory	"Return the subdirectory that SqueakMap uses."		(FileDirectory default directoryExists: dir)		ifFalse:[FileDirectory default createDirectory: dir].	^FileDirectory default directoryNamed: dir! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 8/4/2003 15:22' prior: 34886741!emailOccupied: aUsername	"Return true if email already taken."	^(self accountForEmail: aUsername) notNil! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 12:07' prior: 34886937!extension	^'sgz'! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 12:07' prior: 34887043!filename	^'map'! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 3/31/2006 09:30' prior: 34887147!getLastCheckpointWithFilename	"Return a readstream on a fresh checkpoint gzipped imagesegment.	First we check if we are dirty and must create a new checkpoint.	The filename is tacked on at the end so that the checkpoint number	can be used on the client side too."	| directory fname |	isDirty ifTrue: [self createCheckpoint].	directory := self directory.	fname := self lastCheckpointFilename.	fname ifNil: [self error: 'No checkpoint available'].	^((StandardFileStream oldFileNamed: (directory fullNameFor: fname))		contentsOfEntireFile), ':', fname! !!SMSqueakMap methodsFor: 'initialize-release' stamp: 'gk 5/5/2006 02:07' prior: 34887801!initializeOn: directoryName	"Create the local directory for SqueakMap."	dir := directoryName.	(FileDirectory default directoryExists: dir)		ifFalse:[FileDirectory default createDirectory: dir].	fileCache := SMFileCache newFor: self.	checkpointNumber := 1! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34888170!installPackage: aPackage	"Install the package.	Note: This method should not be used anymore, better	to specify a specific release."	| rel |	rel := aPackage lastPublishedReleaseForCurrentSystemVersion			ifNil: [self error: 'No published release for this system version found to install.'].	^self installPackageRelease: rel! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34888608!installPackage: aPackage autoVersion: version	"Install the release <version> of <aPackage.	<version> is the automatic version name."	| r |	r := aPackage releaseWithAutomaticVersionString: version.	r ifNil: [self error: 'No package release found with automatic version ', version].	^self installPackageRelease: r! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34889034!installPackageNamed: aString	"Install the last published release	for this Squeak version of the package with a name	beginning with aString (see method comment	of #packageWithNameBeginning:).	Note: This method should not be used anymore.	Better to specify a specific release."	| p |	p := self packageWithNameBeginning: aString.	p ifNil: [self error: 'No package found with name beginning with ', aString].	^self installPackage: p! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34889582!installPackageNamed: aString autoVersion: version	"Install the release <version> of the package with a name	beginning with aString (see method comment	of #packageWithNameBeginning:). <version> is the	automatic version name."	| p r |	p := self packageWithNameBeginning: aString.	p ifNil: [self error: 'No package found with name beginning with ', aString].	r := p releaseWithAutomaticVersionString: version.	r ifNil: [self error: 'No package release found with automatic version ', version].	^self installPackageRelease: r! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 7/14/2004 15:57' prior: 34890210!installPackageRelease: aPackageRelease	"Install the given package release, no checks made."	(SMInstaller forPackageRelease: aPackageRelease) install! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34890469!installPackageReleaseWithId: anUUIDString	"Look up and install the given release."	| r |	r := self packageReleaseWithId: anUUIDString.	r ifNil: [self error: 'No package release available with id: ''', anUUIDString, ''''].	^self installPackageRelease: r! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34890835!installPackageWithId: anUUIDString	"Look up and install the latest release of the given package.		Note: This method should not be used anymore.	Better to specify a specific release."	| package |	package := self packageWithId: anUUIDString.	package ifNil: [self error: 'No package available with id: ''', anUUIDString, ''''].	^self installPackage: package! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34891306!installPackageWithId: anUUIDString autoVersion: version	"Install the release <version> of the package with id <anUUIDString>.	<version> is the automatic version name."	| p |	p := self packageWithId: anUUIDString.	p ifNil: [self error: 'No package available with id: ''', anUUIDString, ''''].	^self installPackage: p autoVersion: version! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 12/1/2002 19:54' prior: 34891741!installableAndNotInstalledPackages	"Answer all installable but not installed packages."	^self packages select: [:package | package isInstallableAndNotInstalled]! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 12/1/2002 19:54' prior: 34891996!installablePackages	"Answer all packages that can be (auto)installed -	we have installers that can install them."	^self packages select: [:package | package isInstallable]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 1/18/2004 15:29' prior: 34892267!installedPackageReleases	"Answer all package releases that we know are installed.	Lazily initialize. The Dictionary contains the installed packages	using their UUIDs as keys and the version string as the value."	^self installedPackages collect: [:p | self installedReleaseOf: p]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 34892645!installedPackages	"Answer all packages that we know are installed."	^self registry installedPackages! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 34892843!installedPackagesDictionary	"Access the dictionary directly. The UUID of the installed package is the key.	The value is an OrderedCollection of Arrays.	The arrays have the smartVersion of the package, the time of the	installation in seconds and the sequence number (installCounter)."	^self registry installedPackagesDictionary! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 34893270!installedPackagesDictionary: aDict	"Set dictionary directly."	^self registry installedPackagesDictionary: aDict! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:23' prior: 34893479!installedReleaseOf: aPackage	"If the package is installed, return the release.	Otherwise return nil. SM2 stores the version as	an Association to be able to distinguish it."	^self registry installedReleaseOf: aPackage! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 34893795!installedVersionOf: aPackage	"If the package is installed, return the version as a String.	If it is a package installed during SM1 it will return the manual version String,	for SM2 it returns the automatic version as a String.	If package is not installed - return nil. If you want it to work without the map loaded you	should instead use #installedVersionOfPackageWithId:."	^self registry installedVersionOf: aPackage! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 34894314!installedVersionOfPackageWithId: anId	"If the package is installed, return the automatic version or version String.	Otherwise return nil. This can be used without the map loaded."	^self registry installedVersionOfPackageWithId: anId! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 15:02' prior: 34894639!isCheckpointAvailable	"Check that there is an 'sm' directory	and that it contains at least one checkpoint."	[^self lastCheckpointFilename notNil] on: Error do: [:ex | ^false]! !!SMSqueakMap methodsFor: 'transactions' stamp: 'gk 11/4/2003 00:19' prior: 34894906!isDirty	"Is the map modified but not yet checkpointed to disk?"	^isDirty! !!SMSqueakMap methodsFor: 'public' stamp: 'gk 2/13/2009 09:12' prior: 34895048!isPurged	"Is this instance purged (empty)?"		^checkpointNumber isZero! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 14:21' prior: 34895209!lastCheckpointFilename	"Return the filename for the newest checkpoint."	^self directory lastNameFor: self filename extension: self extension! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 14:52' prior: 34895441!lastCheckpointNumberOnDisk	"Return the last checkpoint number on disk."	^(self nextFileNameForCheckPoint findTokens: '.') second asNumber - 1! !!SMSqueakMap methodsFor: 'public' stamp: 'gh 10/21/2002 14:08' prior: 34895669!loadFull	"Go through the list of known master servers, ping	each one using simple http get on a known 'ping'-url	until one responds and then load the full map from it." 	self loadUpdatesFull: true! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 5/5/2006 02:07' prior: 34895953!loadFullFrom: aServerName	"Contact the SqueakMap at the url <aSqueakMapUrl>	and load a full map from scratch."	| url  zipped |	url := 'http://', aServerName, '/loadgz?mapversion=', SMSqueakMap version, '&checkpoint=', checkpointNumber asString.	Transcript show: 'Fetch: ', (Time millisecondsToRun: [ zipped := (HTTPSocket httpGet: url) contents]) asString, ' ms';cr.	Transcript show: 'Size: ', zipped size asString, ' bytes';cr.	((self checkVersion: zipped) and: [zipped ~= 'UPTODATE'])		ifTrue:[			Transcript show: 'Save checkpoint to disk: ', (Time millisecondsToRun: [			self saveCheckpoint: zipped]) asString, ' ms';cr.			Transcript show: 'Full reload from checkpoint: ', (Time millisecondsToRun: [			self reload]) asString, ' ms';cr.]! !!SMSqueakMap methodsFor: 'public' stamp: 'gk 11/17/2003 23:16' prior: 34896789!loadUpdates	"Go through the list of known master servers, ping	each one using simple http get on a known 'ping'-url	until one responds and then load updates from it."	"SM2 starts with using full always"	self loadFull! !!SMSqueakMap methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34897108!loadUpdatesFull: full	"Find a server and load updates from it." 	| server |	server := self class findServer.	server ifNotNil: [		self synchWithDisk.		full ifTrue: [self loadFullFrom: server]			ifFalse:[self error: 'Not supported yet!!'."self loadUpdatesFrom: server"]]! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 11/17/2003 22:57' prior: 34897469!mandatoryCategoriesFor: aClass	"Return the categories that are mandatory for instances of <aClass>."	^self categories select: [:c | c mandatoryFor: aClass]! !!SMSqueakMap methodsFor: 'private-installation' stamp: 'gk 8/3/2004 13:24' prior: 34897723!markInstalled: uuid version: version time: time counter: num	"Private. Mark the installation. SM2 uses an Association	to distinguish the automatic version from old versions."	^self registry markInstalled: uuid version: version time: time counter: num! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gk 11/17/2003 14:56' prior: 34898068!moveCategory: category toAfter: categoryBefore inParent: parent	"Move a category to be listed after <categoryBefore> in <parent>."	parent move: category toAfter: categoryBefore.	^category	! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gk 5/22/2004 22:22' prior: 34898352!moveCategory: category toParent: parentCategory	"Move a category into another parent category."	parentCategory		ifNil: [category parent: nil]		ifNotNil: [parentCategory addCategory: category].	^category	! !!SMSqueakMap methodsFor: 'transactions' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34898664!mutex	"Lazily initialize the Semaphore."	^mutex ifNil: [mutex := Semaphore forMutualExclusion]! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 8/3/2003 23:23' prior: 34898844!newAccount	"Create a new account."	^SMAccount newIn: self! !!SMSqueakMap methodsFor: 'public-master' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34899006!newAccount: name username: username email: email	"Create an account. Checking for previous account should already have been done.	To add the account to the map, use SMSqueakMap>>addObject:"	| account |	account := self newAccount					name: name;					initials: username;					email: email.	^account	! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 9/26/2003 00:04' prior: 34899397!newObject: anSMObject 	"Add an SMObject to me. Clear the valid caches."	self addDirty: anSMObject.	self clearCachesFor: anSMObject.	^objects at: anSMObject id put: anSMObject! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 10/10/2003 12:12' prior: 34899665!nextFileNameForCheckPoint	"Return the next available filename for a checkpoint."	^self directory nextNameFor: self filename extension: self extension! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 12/1/2002 19:54' prior: 34899909!notInstalledPackages	"Answer all packages that are not installed."	^self packages reject: [:package | package isInstalled]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 11/18/2003 17:49' prior: 34900131!noteInstalled: aPackageRelease	"The package release was just successfully installed using SM.	This is the method being called by SM upon a successful installation.	We record this in our Dictionary of installed package releases	and log a 'do it' to mark this in the changelog.	The map used is the default map."	^self noteInstalledPackageWithId: aPackageRelease package id asString		autoVersion: aPackageRelease automaticVersion		name: aPackageRelease package name! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 11/18/2003 17:50' prior: 34900700!noteInstalledPackage: aPackage autoVersion: aVersion	"Mark that the package release was just successfully installed.	Can be used to inform SM of an installation not been done using SM."	^self noteInstalledPackageWithId: aPackage id asString		autoVersion: aVersion		name: aPackage name! !!SMSqueakMap methodsFor: 'private-installation' stamp: 'gk 8/3/2004 13:24' prior: 34901087!noteInstalledPackage: uuidString version: version	"Mark a specific version of a package as installed.	This method is called when replaying a logged installation	from before SqueakMap 1.07. Such logged installations lacked	a timestamp and a count. We take the current time and a	count starting from -10000 and upwards. This should keep	the sorting order correct."	^self registry noteInstalledPackage: uuidString version: version! !!SMSqueakMap methodsFor: 'private-installation' stamp: 'gk 8/3/2004 13:24' prior: 34901618!noteInstalledPackage: uuidString version: version atSeconds: time number: num	"Mark a package as installed in the Dictionary.	This method is called when replaying a logged installation.	<time> is the point in time as totalSeconds of the installation.	<num> is the installCount of the installation.	This method is typically called from a doIt in the changelog	in order to try to keep track of packages installed."	^self registry noteInstalledPackage: uuidString version: version atSeconds: time number: num! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34902239!noteInstalledPackageNamed: aString autoVersion: aVersion	"Mark that the package release was just successfully installed.	<aVersion> is the automatic version as a String.	Can be used to inform SM of an installation not been done using SM."	| p |	p := self packageWithNameBeginning: aString.	p ifNil: [self error: 'No package found with name beginning with ', aString].	^self noteInstalledPackage: p autoVersion: aVersion asVersion! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 11/18/2003 11:59' prior: 34902774!noteInstalledPackageWithId: aPackageId autoVersion: aVersion	"The package release was just successfully installed.	Can be used to inform SM of an installation not been	done using SM, even when the map isn't loaded."	^self noteInstalledPackageWithId: aPackageId		autoVersion: aVersion		name: '<unknown name>'! !!SMSqueakMap methodsFor: 'private-installation' stamp: 'gk 8/3/2004 13:24' prior: 34903185!noteInstalledPackageWithId: uuidString autoVersion: version atSeconds: time number: num	"Mark a package as installed in the Dictionary.	This method is called when replaying a logged installation.	<time> is the point in time as totalSeconds of the installation.	<num> is the installCount of the installation.	This method is typically called from a doIt in the changelog	in order to try to keep track of packages installed."	^self registry noteInstalledPackageWithId: uuidString autoVersion: version atSeconds: time number: num! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 8/3/2004 13:24' prior: 34903813!noteInstalledPackageWithId: aPackageId autoVersion: aVersion name: aName	"The package release was just successfully installed.	Can be used to inform SM of an installation not been	done using SM, even when the map isn't loaded.	We record the fact in our Dictionary of installed packages	and log a 'do it' to mark this in the changelog.	The doit helps keeping track of the packages when	recovering changes etc - not a perfect solution but should help.	The map used is the default map.	The id of the package is the key and the value is an OrderedCollection	of Arrays with the release auto version, the point in time and the current installCounter."	^self registry noteInstalledPackageWithId: aPackageId autoVersion: aVersion name: aName! !!SMSqueakMap methodsFor: 'private-installation' stamp: 'gk 1/22/2004 12:01' prior: 34904656!noteUninstalled: aPackageRelease	"The package release was just successfully uninstalled using SM.	This is the method being called by SM upon a successful uninstallation.	We record this in our Dictionary of installed package releases	and log a 'do it' to mark this in the changelog.	The map used is the default map."	^self noteUninstalledPackageWithId: aPackageRelease package id asString		autoVersion: aPackageRelease automaticVersion		name: aPackageRelease package name! !!SMSqueakMap methodsFor: 'private-installation' stamp: 'gk 8/3/2004 13:25' prior: 34905232!noteUninstalledPackageWithId: aPackageId autoVersion: aVersion name: aName	"The package release was just successfully uninstalled.	Can be used to inform SM of an uninstallation not been	done using SM, even when the map isn't loaded.	We record the fact in our Dictionary of installed packages	and log a 'do it' to mark this in the changelog.	The doit helps keeping track of the packages when	recovering changes etc - not a perfect solution but should help.	The map used is the default map.	The id of the package is the key and the value is an OrderedCollection	of Arrays with the release auto version, the point in time and the current installCounter."	^self registry noteUninstalledPackageWithId: aPackageId autoVersion: aVersion name: aName! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 11/18/2003 02:06' prior: 34906071!object: aUUID	"Look up a categorizable object. Return nil if missing."	^objects at: aUUID ifAbsent: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 12/1/2002 19:25' prior: 34906263!objectWithId: anIdString	"Look up a categorizable object. Return nil if missing."	^objects at: (UUID fromString: anIdString) ifAbsent: [nil]! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gh 11/28/2002 22:00' prior: 34906493!objects	^objects! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gk 7/13/2004 15:12' prior: 34906602!oldPackages	"Answer all packages that are installed with a	newer published version for this Squeak version available."	^self installedPackages select: [:package | package isSafelyOld]! !!SMSqueakMap methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34906887!packageCacheDirectory	"Return a FileDirectory for the package cache of the map.	Creates it if it is missing."	| dirName baseDir |	dirName := self packageCacheDirectoryName.	baseDir := self directory.	(baseDir fileOrDirectoryExists: dirName)		ifFalse:[baseDir createDirectory: dirName].	^baseDir directoryNamed: dirName! !!SMSqueakMap methodsFor: 'private' stamp: 'btr 5/28/2003 00:56' prior: 34907299!packageCacheDirectoryName	"What is the name of the cache directory?"	^'cache'! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34907475!packageReleaseWithId: anIdString 	"Look up a package release. Return nil if missing.	Raise error if it is not a package release."	| r |	r := self objectWithId: anIdString.	r ifNil: [^nil].	r isPackageRelease ifTrue:[^r].	self error: 'UUID did not map to a package release.'! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 10/19/2005 23:53' prior: 34907843!packageReleases	"Return subset of objects."	objects ifNil: [^#()].	^objects select: [:o | o isPackageRelease]! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34908052!packageWithId: anIdString 	"Look up a package. Return nil if missing.	Raise error if it is not a package."	| package |	package := self objectWithId: anIdString.	package ifNil: [^nil].	package isPackage ifTrue:[^package].	self error: 'UUID did not map to a package.'! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 12/1/2002 19:54' prior: 34908409!packageWithName: aName	"Look up a package by exact match on name. Return nil if missing."	^self packages detect: [:package | package name = aName ] ifNone: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34908669!packageWithNameBeginning: aString	"Look up a package beginning with <aString>. Return nil if missing.	We return the shortest matching one. We also strip out spaces and	ignore case in both <aString> and the names."	| candidates shortest answer searchString |	searchString := (aString asLowercase) copyWithout: Character space.	candidates := self packages select: [:package |		((package name asLowercase) copyWithout: Character space)			beginsWith: searchString ].	shortest := 1000.	candidates do: [:package |		package name size < shortest ifTrue:[answer := package. shortest := package name size]].	^answer	! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 11/11/2003 18:37' prior: 34909373!packageWithPI: aPIName	"Look up a package by exact match on PackageInfo name. Return nil if missing."	aPIName isEmptyOrNil ifTrue: [^nil].	^self packages detect: [:package | package packageInfoName = aPIName ] ifNone: [nil]! !!SMSqueakMap methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34909698!packages	"Lazily maintain a cache of all known package objects."	packages ifNotNil: [^packages].	objects ifNil: [^#()].	packages := objects select: [:o | o isPackage].	^packages! !!SMSqueakMap methodsFor: 'queries' stamp: 'gk 12/3/2004 12:01' prior: 34909965!packagesByName	"Return the packages sorted by their name."	^self packages asSortedCollection: [:x :y | x name caseInsensitiveLessOrEqual: y name]! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 9/30/2003 17:03' prior: 34910197!pingServer: aServerName	^self class pingServer: aServerName! !!SMSqueakMap methodsFor: 'public' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34910353!purge	"Clear out the map from memory. Use this to reclaim space,	no information is lost because it does not remove information	about what packages are installed, and the map itself is checkpointed	to disk. Use #reload to get it back from the latest checkpoint on disk."	objects := accounts := users := packages := categories := nil.	checkpointNumber := 0.! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 5/5/2006 02:07' prior: 34910800!registry	^registry ifNil: [registry := SMInstallationRegistry map: self]! !!SMSqueakMap methodsFor: 'public' stamp: 'gk 3/31/2006 10:32' prior: 34910956!reload	"Reload the map from the latest checkpoint on disk.	The opposite of #purge."	| fname stream map |	fname := self lastCheckpointFilename.	fname ifNil: [self error: 'No checkpoint available!!'].	"Code below uses good ole StandardFileStream to avoid m17n issues (this is binary data) and	also uses #unzipped since it works in older Squeaks"	stream := (StandardFileStream oldFileNamed: (self directory fullNameFor: fname)) asUnZippedStream.	"stream := (RWBinaryOrTextStream with: contents) reset."	stream ifNil: [self error: 'Couldn''t open stream on checkpoint file!!'].	[map := (stream fileInObjectAndCode) install arrayOfRoots first] ensure: [stream close].	self copyFrom: map! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gk 11/17/2003 10:30' prior: 34911741!removeCategory: category inObject: object	"Remove a category from an object."	^object removeCategory: category! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gk 5/5/2006 02:07' prior: 34911944!repair	"Integrity repairs. This should not be neeed, but	for some reason the map can obviously get messed up,	not sure how."	"SMSqueakMap default repair"		"all objects should point back to me and not at another map"	objects do: [:o | o map: self].		"all releases should point back at the package they are in"	self packages do: [:p | p releases do: [:r | r package: p]].		"all releases in this map should point at a package in this map"	self packageReleases do: [:r | | p |		p := self object: r package id.		p ifNil: [self error: 'Unknown package'].		r package: p]! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 3/31/2006 09:34' prior: 34912612!saveCheckpoint: contentWithFilename	"Save the map checkpoint to disk if it is not there already."	| file directory sz fname content |	directory := self directory.	sz := contentWithFilename size.	fname := contentWithFilename last: sz - (contentWithFilename lastIndexOf: $:).	content := contentWithFilename first: sz - fname size - 1.	(directory fileExists: fname) ifFalse: [		[file := StandardFileStream newFileNamed: (directory fullNameFor: fname).		file nextPutAll: content]			ensure: [file close]]! !!SMSqueakMap methodsFor: 'transactions' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34913223!setDirty	"Set the map modified so that it will get written to disk."	isDirty := true! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 7/13/2004 02:51' prior: 34913396!silent	"Can installations ask questions or should they be silent	and us good defaults?"	^ silent ifNil: [false] ifNotNil: [true]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34913636!silentlyDo: aBlock	"Execute <aBlock> with the Silent flag set.	This is a crude way of avoiding user interaction	during batch operations, like loading updates."	[silent := true.	aBlock value]		ensure: [silent := nil]! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 2/13/2009 09:14' prior: 34913942!synchWithDisk	"Synchronize myself with the checkpoints on disk.	If there is a newer checkpoint than I know of, load it.	If there is no checkpoint or if I have a higher checkpoint number,	create a new checkpoint from me.	The end result is that I am in synch with the disk and we are both as	updated as possible."	| checkpointNumberOnDisk |	 "If there is no checkpoint, save one from me."	(self isCheckpointAvailable) ifFalse: [		"If I am purged - don't checkpoint, no point"		self isPurged ifTrue: [^self].		^self createCheckpointNumber: checkpointNumber].	"If the one on disk is newer, load it"	checkpointNumberOnDisk := self lastCheckpointNumberOnDisk.	(checkpointNumber < checkpointNumberOnDisk)		ifTrue: [^self reload].	"If I am newer, recreate me on disk"	(checkpointNumberOnDisk < checkpointNumber)		ifTrue: [^self createCheckpointNumber: checkpointNumber]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 12/1/2002 20:12' prior: 34914908!topCategories	^self categories select: [:cat | cat isTopCategory]! !!SMSqueakMap methodsFor: 'transactions' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34915075!transaction: aBlock	"Execute aBlock and then make sure any modified SMObjects	are committed to disk. We do this inside a mutex in order to	serialize transactions. Transactions must be initiated from	service methods in this class and not from inside the domain	objects - otherwise they could get nested and a deadlock occurs.""In first version of SM2 we simply set the isDirty flag,when next client asks for updates, or 30 minutes has passed,we checkpoint.""	self mutex critical: ["		aBlock value.		isDirty := true"	]""	self mutex critical: [		dirtyList := OrderedCollection new.		aBlock value.		dirtyList do: [:obj | obj commit].		dirtyList := nil	]"! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 11/17/2003 13:06' prior: 34915843!upgradeOldPackages	"Upgrade all upgradeable old packages without confirmation on each."	^self upgradeOldPackagesConfirmBlock: [:package | true ]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34916098!upgradeOldPackagesConfirmBlock: aBlock	"First we find out which of the installed packages are upgradeable and old.	Then we upgrade them if confirmation block yields true.	The block will be called with each SMPackage to upgrade.	We return a Dictionary with the packages we tried to upgrade as keys	and the value being the result of the upgrade, true or false."	| result |	result := Dictionary new.	self upgradeableAndOldPackages		do: [:package |			(aBlock value: package)				ifTrue:[ result at: package put: package upgrade]].	^result! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 7/14/2004 17:33' prior: 34916741!upgradeOrInstallPackage: aPackage	"Upgrade package (or install) to the latest published release for this Squeak version."	^aPackage upgradeOrInstall! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34917000!upgradeOrInstallPackageWithId: anUUIDString	"Upgrade package (or install) to the latest published release for this Squeak version."	| package |	package := self packageWithId: anUUIDString.	package ifNil: [self error: 'No package available with id: ''', anUUIDString, ''''].	^package upgradeOrInstall! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 5/5/2006 02:07' prior: 34917400!upgradeOrInstallPackageWithId: anUUIDString asOf: aTimeStamp	"Upgrade package (or install) to the latest published release as it was	on <aTimeStamp> for this Squeak version. This ensures that the same	release will be installed (for all Squeak versions) as when it was tested."	| package |	package := self packageWithId: anUUIDString.	package ifNil: [self error: 'No package available with id: ''', anUUIDString, ''''].	^package upgradeOrInstall! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gk 7/14/2004 17:16' prior: 34917948!upgradePackage: aPackage	"Upgrade package to the latest published release for this Squeak version."	^aPackage upgrade! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34918176!upgradePackageWithId: anUUIDString	"Upgrade package to the latest published release for this Squeak version.	Will raise error if there is no release installed, otherwise use	#upgradeOrInstallPackageWithId: "	| package |	package := self packageWithId: anUUIDString.	package ifNil: [self error: 'No package available with id: ''', anUUIDString, ''''].	^package upgrade! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 10/25/2002 11:33' prior: 34918643!upgradeableAndOldOrInstallableAndNotInstalledPackages	"This would give you all packages that are available now	for automatic install or automatic upgrade."	^self upgradeableAndOldPackages union: self installableAndNotInstalledPackages! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gk 7/14/2004 16:17' prior: 34918973!upgradeableAndOldPackages	"Answer all packages that are installed and which have a	newer published release for this Squeak version that also	can be to by an installer."	^self installedPackages select: [:package | package isSafelyOldAndUpgradeable]! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 8/3/2003 23:13' prior: 34919308!usernameOccupied: aUsername	"Return true if name already taken."	^(self accountForUsername: aUsername) notNil! !!SMSqueakMap methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34919518!users	"Lazily maintain a cache of all known account objects	keyed by their developer initials."	users ifNotNil: [^users].	users := Dictionary new.	self accounts do: [:a | users at: a initials put: a].	^users! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 10/21/2003 23:05' prior: 34919817!verifyAdminPassword: aString	"Answer true if it is the correct password."	^adminPassword = (SecureHashAlgorithm new hashMessage: aString)! !!SMSqueakMap methodsFor: 'views' stamp: 'gh 11/28/2002 22:06' prior: 34920040!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis. Used primarily by the web frontend."	^uiObject squeakMapViewOn: self! !!SMUtilities commentStamp: 'gk 11/13/2003 23:39' prior: 34920274!Various loose functions in SM.!!SMUtilities class methodsFor: 'class initialization' stamp: 'gk 5/5/2006 02:07' prior: 34920404!initialize	"Initialize server settings."	"self initialize"	MasterServer := nil.	MailServer := nil! !!SMUtilities class methodsFor: 'server' stamp: 'gk 10/13/2005 00:18' prior: 34920597!isServer	"Is this a running server?"		^MasterServer notNil! !!SMUtilities class methodsFor: 'private' stamp: 'gk 10/12/2005 23:10' prior: 34920749!mail: anAccount subject: sub message: msg	"Send a mail to the holder of <anAccount>."	SMTPClient		deliverMailFrom: 'squeakmap@squeak.org'		to: {anAccount email}		text:('From: SqueakMap <squeakmap@squeak.org>To: ', anAccount email, 'Subject: ', sub,'', msg, (self randomPhrase), ', SqueakMap') squeakToIso usingServer: MailServer! !!SMUtilities class methodsFor: 'server' stamp: 'gk 8/4/2003 16:15' prior: 34921176!mailPassword: randomPass for: anAccount	"Change the password to a random generated one	and mail it to the holder of the account."	self mail: anAccount subject: 'New password at SqueakMap!!' message:'Hi!!An extra random password has been added for the account held by "', anAccount name, '":"', randomPass, '"You can login to SqueakMap at:', MasterServer, '/loginThe regular password still works, so if it was not you who requested this extrarandom password you can safely just delete this email.This extra password will stop working when you change your regular password.'! !!SMUtilities class methodsFor: 'server' stamp: 'gk 8/4/2003 16:15' prior: 34921854!mailPassword: aPassword forNew: anAccount	"Mail the password to the person who just registered the account."	self mail: anAccount subject: 'Your new account at SqueakMap!!' message:'Hi!!You or someone else has registered an account on SqueakMap. You can login to it using this link:',MasterServer, '/autologin?u=', anAccount initials, '&p=', aPassword,'If it was not you who performed this registration you can safely just delete this email.'! !!SMUtilities class methodsFor: 'class initialization' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34922424!mailServer: ipName masterServer: httpUrl	"Initialize server settings."	MailServer := ipName.	MasterServer := httpUrl! !!SMUtilities class methodsFor: 'private' stamp: 'rbb 3/1/2005 11:12' prior: 34922634!mailUserName	"Answer the mail user's name, but deal with some historical mail senders."	| mailSender |	mailSender := (Smalltalk at: #MailSender ifAbsent: [ Smalltalk at: #Celeste ifAbsent: []]).	^mailSender		ifNil: [ UIManager default request: 'What is your email address?' ]		ifNotNil: [ mailSender userName ]! !!SMUtilities class methodsFor: 'server' stamp: 'gk 8/15/2003 12:25' prior: 34923040!masterServer	"Return the master server url."	^MasterServer! !!SMUtilities class methodsFor: 'private' stamp: 'gh 11/27/2002 12:37' prior: 34923192!randomPhrase	"Pick a nice phrase."	^#('Debug safely' 'Happy Squeaking' 'Just do it' 'Yours truly' 'Stay a Squeaker' 'Squeak rocks') atRandom! !!SMUtilities class methodsFor: 'utilities' stamp: 'gk 3/31/2006 09:50' prior: 34923427!sendMail: aString	"Send the given mail message, but check for modern mail senders."	| server |	Smalltalk at: #MailSender ifPresent: [ :mailSender |		^mailSender sendMessage: ((Smalltalk at: #MailMessage) from: aString).	].	Smalltalk at: #MailComposition ifPresent: [ :mailComposition |		^mailComposition new			messageText:  aString;			open	].		Smalltalk at: #Celeste ifPresent: [ :celeste |		celeste isSmtpServerSet ifTrue: [			Smalltalk at: #CelesteComposition ifPresent: [ :celesteComposition |				^celesteComposition					openForCeleste: celeste current 					initialText: aString			]		]	].	Smalltalk at: #AdHocComposition ifPresent: [ :adHocComposition |		server := UIManager default request: 'What is your mail server for outgoing mail?'.		^adHocComposition 			openForCeleste: server			initialText: aString	].	^self inform: 'Sorry, no known way to send the message'.	 	! !!SMUtilities class methodsFor: 'utilities' stamp: 'gk 7/10/2004 03:43' prior: 34924424!sendMailTo: recipient regardingPackageRelease: pr	"Send mail to the given recipient. Try to use the first of:	- MailSender (with its registered composition class)	- Celeste	- AdHocComposition	for compatibility with 3.5 and 3.6 images"	self sendMail: (String streamContents: [:stream |		stream			nextPutAll: 'From: '; nextPutAll: self mailUserName; cr;			nextPutAll: 'To: '; nextPutAll: recipient; cr;			nextPutAll: 'Subject: Regarding '; nextPutAll: pr printName; cr])! !!SMUtilities class methodsFor: 'utilities' stamp: 'gk 3/31/2006 09:52' prior: 34924995!stripEmailFrom: aString	"Picks out the email from:		'Robert Robertson <rob@here.com>' => 'rob@here.com'	Spamblockers 'no_spam', 'no_canned_ham' and 'spam_block'	(case insensitive) will be filtered out."	| lessThan moreThan email pos |	lessThan := aString indexOf: $<.	moreThan := aString indexOf: $>.	(lessThan * moreThan = 0) ifTrue: [^ aString].	email := (aString copyFrom: lessThan + 1 to: moreThan - 1) asLowercase.	#('no_spam' 'no_canned_ham' 'spam_block') do: [:block |		pos := email findString: block.		pos = 0 ifFalse:[email := (email copyFrom: 1 to: pos - 1), (email copyFrom: pos + block size to: email size)]].	^email! !!SMUtilities class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34925741!stripNameFrom: aString	"Picks out the name from:		'Robert Robertson <rob@here.com>' => 'Robert Robertson'	"	| lessThan |	lessThan := aString indexOf: $<.	^(aString copyFrom: 1 to: lessThan - 1) withBlanksTrimmed ! !!ImageSegment methodsFor: '*SMBase-export' stamp: 'stephaneducasse 2/4/2006 20:38' prior: 34926064!writeForExportOn: fileStream	"Write the segment on the disk with all info needed to reconstruct it in a new image.  For export.  Out pointers are encoded as normal objects on the disk."	| temp |	state = #activeCopy ifFalse: [self error: 'wrong state'].	temp := endMarker.	endMarker := nil.	fileStream fileOutClass: nil andObject: self.		"remember extra structures.  Note class names."	endMarker := temp.! !!SystemVersion methodsFor: '*smbase-extension' stamp: 'jcg 11/2/2004 10:03' prior: 34926574!majorMinorVersion	"Return the major/minor version number of the form X.Y, without any 'alpha' or 'beta' or other suffix."	"(SystemVersion new version: 'Squeak3.7alpha') majorMinorVersion" "  -->  'Squeak3.7' "	"SystemVersion current majorMinorVersion"		| char stream |	stream := ReadStream on: version, 'x'.	stream upTo: $..	char := stream next.	char ifNil: [^ version].	"eg: 'Jasmine-rc1' has no $. in it."	[char isDigit]		whileTrue: [char := stream next].	^ version copyFrom: 1 to: stream position - 1! !!UUID class methodsFor: '*smbase-macsafe' stamp: 'dvf 9/10/2004 23:11' prior: 34927182!fromString36: aString	"Decode the UUID from a base 36 string using 0-9 and lowercase a-z.	This is the shortest representation still being able to work as	filenames etc since it does not depend on case nor characters	that might cause problems."	| object num |	object := self nilUUID.	num := Integer readFrom: aString asUppercase readStream base: 36.	16 to: 1 by: -1 do: [:i |		num size < i			ifTrue: [object at: i put: 0]			ifFalse: [object at: i put: (num digitAt: i)]].	^object! !!UUID methodsFor: '*smbase-macsafe' stamp: 'gk 4/18/2006 22:15' prior: 34927758!asString36	"Encode the UUID as a base 36 string using 0-9 and lowercase a-z.	This is the shortest representation still being able to work as	filenames etc since it does not depend on case nor characters	that might cause problems, and it fits into short filenames like on	the old MacOS HFS filesystem. The check for 36r is to make this code	work in versions before Squeak 3.8."	| num candidate |	num := 0.	1 to: self size do: [:i | num := num + ((256 raisedTo: i - 1) * (self at: i))].	candidate := num printStringBase: 36.	^((candidate beginsWith: '36r')			ifTrue: [candidate copyFrom: 4 to: candidate size]			ifFalse: [candidate]) asLowercase! !!SMDependencyTest commentStamp: '<historical>' prior: 34928483!Tests for the dependency engine.!!SMDependencyTest methodsFor: 'as yet unclassified' stamp: 'gk 5/5/2006 02:07' prior: 34928613!setUp	| package trivial1rel installed1rel installed2rel tricky2rel conf1 conf2 tricky3rel1 tricky3rel2 tricky1rel seaside httpview kom1 kom2 |	map := SMSqueakMap new reload.	goranAccount := map newAccount: 'Goran' username: 'Goran' email: 'g@g.com'.		"Add a few packages to test with:		Tricky1 1		Installed1 1		Tricky2 1	Tricky2 1		Installed1 1		TrivialToInstall1 1		Tricky3 1			Installed1 1		TrivialToInstall1 1		Tricky3 2	Tricky3 2		TrivialToInstall1 1		Installed2 1		Seaside		KomHttpServer 1		HttpView		KomHttpServer 2	"	{		{'A'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 3}.		{'B'. {'Squeak3.6'. 'Stable'}. 2}.		{'TrivialToInstall1'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Installed1'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Installed2'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'AlreadyInstallable1'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Tricky1'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Tricky2'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Tricky3'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 2}.		{'Circular1'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Circular2'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Circular3'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'Seaside'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.		{'KomHttpServer'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 2}.		{'HttpView'. {'Squeak3.6'. 'Squeak3.7'. 'Stable'}. 1}.	} do: [:arr |			package := SMPackage newIn: map.			package name: arr first.			arr second do: [:cn | package addCategory: (map categoryWithNameBeginning: cn)].			arr third timesRepeat: [package newRelease ].			goranAccount addObject: package].		trivial1rel := (map packageWithName: 'TrivialToInstall1') lastRelease.	trivial1rel publisher: goranAccount.		installed1rel := (map packageWithName: 'Installed1') lastRelease.	installed1rel publisher: goranAccount; noteInstalled.	installed2rel := (map packageWithName: 'Installed2') lastRelease.	installed2rel publisher: goranAccount; noteInstalled.	((map packageWithName: 'AlreadyInstallable1') lastRelease		publisher: goranAccount;		addConfiguration)				addRequiredRelease: installed1rel.	"Tricky1 has just a single configuration with one installed and one not installed."	tricky1rel := (map packageWithName: 'Tricky1') lastRelease.	tricky2rel := (map packageWithName: 'Tricky2') lastRelease.				(tricky1rel publisher: goranAccount; addConfiguration)				addRequiredRelease: installed1rel; "already installed"				addRequiredRelease: tricky2rel. "not installed"	"Tricky2 has two configurations:		1: an installed, a trivial one and Tricky3 r1.		2: an installed, a trivial one and Tricky3 r2."	conf1 := tricky2rel publisher: goranAccount; addConfiguration.	conf2 := tricky2rel addConfiguration.		tricky3rel1 := (map packageWithName: 'Tricky3') releases first.	tricky3rel2 := (map packageWithName: 'Tricky3') lastRelease.	tricky3rel1 publisher: goranAccount.	tricky3rel2 publisher: goranAccount.	conf1 addRequiredRelease: installed1rel; addRequiredRelease: trivial1rel; addRequiredRelease: tricky3rel1.	conf2 addRequiredRelease: installed1rel; addRequiredRelease: trivial1rel; addRequiredRelease: tricky3rel2.		"Tricky3rel2 has two configurations:		1: trivial1		2: installed2rel"	conf1 := tricky3rel2 publisher: goranAccount; addConfiguration.	conf2 := tricky3rel2 addConfiguration.	conf1 addRequiredRelease: trivial1rel.	conf2 addRequiredRelease: installed2rel.		seaside := (map packageWithName: 'Seaside') lastRelease.	seaside publisher: goranAccount.	httpview := (map packageWithName: 'HttpView') lastRelease.	httpview publisher: goranAccount.	kom1 := (map packageWithName: 'KomHttpServer') firstRelease.	kom1 publisher: goranAccount.	kom2 := (map packageWithName: 'KomHttpServer') lastRelease.	kom2 publisher: goranAccount.		conf1 := seaside addConfiguration.	conf2 := httpview addConfiguration.	conf1 addRequiredRelease: kom1.	conf2 addRequiredRelease: kom2! !!SMDependencyTest methodsFor: 'as yet unclassified' stamp: 'gk 5/5/2006 02:07' prior: 34932688!test2	"Checking construction of model:	- verify test for circular dependencies (not allowed)."	"Circular1rel has a conf to Circular2rel, which in turn has one back."	| circular1rel circular2rel circular3rel |	circular1rel := (map packageWithName: 'Circular1') lastRelease.	circular2rel := (map packageWithName: 'Circular2') lastRelease.	circular3rel := (map packageWithName: 'Circular3') lastRelease.	(circular1rel publisher: goranAccount; addConfiguration)		addRequiredRelease: circular2rel.	(circular2rel publisher: goranAccount; addConfiguration)		addRequiredRelease: circular3rel.		self should: [		(circular3rel publisher: goranAccount; addConfiguration)			addRequiredRelease: circular1rel]		raise: Error! !----End fileIn of a stream----!!SMCategoryWrapper commentStamp: '<historical>' prior: 28762366!This is a wrapper for showing the SqueakMap categories (SMCategory) using the SimpleHierarchicalListMorph in the SMLoader, see SMLoader>>categoryWrapperList.!!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13' prior: 28762608!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMCategoryWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 18:53' prior: 28762760!asString	^ item name , ' (' , self numberOfObjects printString , ')'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'ar 2/9/2004 02:35' prior: 28762866!category	^item! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 21:02' prior: 28762967!contents	^ item subCategories		collect: [:n | self class with: n model: n]! !!SMCategoryWrapper methodsFor: 'model access' stamp: 'btr 11/30/2006 21:02'!getList	^ Array		with: (self class with: self contents model: model)! !!SMCategoryWrapper methodsFor: 'testing' stamp: 'btr 11/30/2006 18:53'!hasContents	^ item hasSubCategories! !!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13' prior: 28763265!hash	^self withoutListWrapper hash! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:56'!help	^ 'The categories are structured in a tree. Packages and package releases belong to several categories. You can add one or more categories as filters and enable them in the menu.'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'BJP 11/22/2002 14:17'!model	^model! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:53'!numberOfObjects"	| total |	total _ 0.	model allCategoriesDo: [:c |		total _ total + c objects size].	^total"	^item objects size! !!SMPackageReleaseWrapper commentStamp: 'gk 6/21/2005 10:54' prior: 28914346!This is a wrapper for showing the SqueakMap package releases (SMPackageRelease) using the SimpleHierarchicalListMorph in the SMLoader, see SMPackageWrapper>>contents.!!SMPackageReleaseWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 21:30' prior: 28914604!asString	"Show installed releases with a trailing asterisk."	| string |	string := item smartVersion.	"Older SMBase versions don't have isInstalled.'"	(item respondsTo: #isInstalled) ifTrue:		[item isInstalled ifTrue: [string := (string , ' *') asText allBold]].	^ string! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 17:14'!contents	^ #()! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49'!label	^ self asString	! !!SMPackageWrapper commentStamp: '<historical>' prior: 28915598!This is a wrapper for showing the SqueakMap packages (SMPackage) using the SimpleHierarchicalListMorph in the SMLoader, see SMLoader>>packageWrapperList.!!SMPackageWrapper methodsFor: 'comparing' stamp: 'dvf 9/21/2003 16:25' prior: 28915837!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMPackageWrapper methodsFor: 'converting' stamp: 'btr 11/22/2006 00:54' prior: 28915989!asString	| string |	string := item name, ' (', item versionLabel, ')'.	item isInstalled ifTrue: [string := string asText allBold].	"(string includesSubString: '->') ifTrue: [string := string asText color: Color green]."	^ string! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'dvf 10/14/2003 18:58' prior: 28916113!contents	^item releases reversed collect: [:e | SMPackageReleaseWrapper with: e]! !!SMPackageWrapper methodsFor: 'testing' stamp: 'dvf 9/21/2003 16:25' prior: 28916281!hash	^self withoutListWrapper hash! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:55'!help	^ 'This shows all packages with their releases that should be displayed according the current filter.'! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49'!label	^ self asString! !!SMPackageWrapper methodsFor: 'printing' stamp: 'dvf 9/21/2003 16:22' prior: 28916403!printOn: aStream	aStream nextPutAll: 'wrapper for: ', item printString! !!SMLoaderPlus commentStamp: 'btr 12/1/2006 15:16' prior: 0!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance). It uses ToolBuilder to construct its window. You can open one with:	SMLoaderPlus openInstance Variables	categoriesToFilterIds:		<OrderedCollection> The set of categories to filter the packages list.	filters:				<OrderedCollection> The set of filters to apply to the packages list.	map:				<SMSqueakMap> The model SqueakMap.	packagesList:		<OrderedCollection> The list of packages from the map.	selectedCategory:	<SMCategory> The current category.	selectedItem:			<SMPackage> The selected package or release.	window:			<PluggableSystemWindow> The window, held only so we can reOpen.!!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06'!initialize	Smalltalk at: #ToolBuilder ifPresent: [:tb |		(TheWorldMenu respondsTo: #registerOpenCommand:)			ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:59'!buildFancyWith: aBuilder	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	window := aBuilder build: (aBuilder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: aBuilder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: aBuilder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: aBuilder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)); yourself);				add: ((self buildNotInstalledPackagesListWith: aBuilder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ (horizDivide / 2)); yourself);				add: ((self buildInstalledPackagesListWith: aBuilder)					frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide); yourself);				add: ((self buildPackagePaneWith: aBuilder)					frame: (0 @ horizDivide corner: 1 @ 1); yourself); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	self setUpdatablePanesFrom: #(#installedPackageList #notInstalledPackageList ).	currentPackageList := #notInstalled.	window extent: 500@500.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:56'!buildInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #installedPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:52'!buildNotInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #notInstalledPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:47'!buildWith: aBuilder	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	window := aBuilder build: (aBuilder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: aBuilder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: aBuilder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: aBuilder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)); yourself);				add: ((self buildPackagesListWith: aBuilder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide); yourself);				add: ((self buildPackagePaneWith: aBuilder)					frame: (0 @ horizDivide corner: 1 @ 1); yourself); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: 500@500.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!currentPackageList	^currentPackageList! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 18:01'!defaultLabel	^ 'Catgorical ' , super defaultLabel! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:34'!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['No removing yet']! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:52'!installedPackageList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02'!installedPackagesListIndex	^ self currentPackageList = #installed		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!installedPackagesListIndex: anObject 	packagesListIndex _ anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!isOn	^false! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:53'!notInstalledPackageList	^self packageList reject: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02'!notInstalledPackagesListIndex	^ self currentPackageList = #notInstalled		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:03'!notInstalledPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategoricalPlus methodsFor: 'private' stamp: 'btr 12/1/2006 17:53'!noteChanged	self changed: #installedPackageList.	self changed: #notInstalledPackageList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:34'!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !!SMLoaderPlus class methodsFor: 'parts bin' stamp: 'btr 11/22/2006 15:02'!descriptionForPartsBin	^self partName: 'Package Loader'		categories: #(Tools)		documentation: 'SqueakMap UI'! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 12/1/2006 15:47'!initialize	"Hook us up in the world menu."		"self initialize"	Smalltalk at: #ToolBuilder ifPresent: [:tb |		self registerInFlapsRegistry.		(Preferences windowColorFor: #SMLoader) = Color white "not set"			ifTrue: [ Preferences setWindowColorFor: #SMLoader to: (Color colorFrom: self windowColorSpecification brightColor) ].		 (TheWorldMenu respondsTo: #registerOpenCommand:)	         ifTrue: [| oldCmds |				oldCmds := TheWorldMenu registry select: [:cmd | cmd first includesSubString: 'Package Loader'].				oldCmds do: [:cmd | TheWorldMenu unregisterOpenCommand: cmd first].			TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16'!initializedInstance	^ (ToolBuilder open: self new) extent: 400@400! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02'!new	"Create a SqueakMap loader on the default map."	^self newOn: SMSqueakMap default! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02'!newOn: aMap	"Create a SqueakMap loader on given map."	^super new on: aMap; yourself! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16'!newStandAlone	^ ToolBuilder open: self new! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:13'!open	"Create and open a SqueakMap Loader."		"SMLoaderPlus open"	^ (Smalltalk at: #ToolBuilder) open: self new! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50'!openMenuString	^ 'SqueakMap Catalog'! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:21'!openOn: aSqueakMap	"Create and open a SqueakMap Loader on a given map."	"self openOn: SqueakMap default"	^ (Smalltalk at: #ToolBuilder) open: (self newOn: aSqueakMap)! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:18'!prototypicalToolWindow	^ ToolBuilder open: self new; applyModelExtent; yourself! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:02'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry."	self environment		at: #Flaps		ifPresent: [:cl | (cl respondsTo: #registerQuad:forFlapNamed:)				ifTrue: [cl registerQuad: #(#SMLoader #prototypicalToolWindow 'Package Loader' 'The SqueakMap Package Loader' ) forFlapNamed: 'Tools']]! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoaderPlus class methodsFor: 'window color' stamp: 'btr 11/22/2006 15:02'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference."	^WindowColorSpec		classSymbol: self name		wording: 'Package Loader'		brightColor: Color yellow muchLighter duller		pastelColor: Color yellow veryMuchLighter duller		helpMessage: 'The SqueakMap Package Loader'! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!addSelectedCategoryAsFilter	"Add a new filter that filters on the currently selected category.	Make it enabled as default."	categoriesToFilterIds add: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 16:11'!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := map isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(map directory directoryEntryFor: map lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:43'!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease				ifNil: [^ nil].	dir := item isPackage				ifTrue: [map cache directoryForPackage: item]				ifFalse: [map cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir.	"withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/23/2006 12:20'!buildButtonBarWith: aBuilder	^ aBuilder pluggablePanelSpec new		model: self;		layout: #horizontal;		children: (self commandSpecs select: [ :spec | spec fourth includes: #all]				thenCollect: [ :spec |					aBuilder pluggableActionButtonSpec new						model: self;						label: spec first;						action: spec second;						help: spec third;						enabled: ((spec fourth includes: #item) ifTrue: [#hasSelectedItem]);						yourself]);			yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02'!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:48'!buildCategoriesListWith: aBuilder 	"Create the hierarchical list holding the category tree."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #categoryList;		 getSelectedPath: #selectedCategoryPath;		 getChildren: #categoryChildren:;		 hasChildren: #categoryHasChildren:;		 setSelected: #selectedCategory:;		 menu: #categoriesMenu:;		 label: #categoryLabel:;		 autoDeselect: true;		 wantsDrop: true;		 yourself"help: #help;"! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:19'!buildPackageButtonBarWith: aBuilder	^ AlignmentMorph newRow beSticky;		color: Color transparent;		clipSubmorphs: true;		yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 19:56'!buildPackagePaneWith: aBuilder	"Create the text area to the right in the loader."	^ aBuilder pluggableTextSpec new model: self; getText: #itemDescription; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:17'!buildPackagesListWith: aBuilder 	"Create the hierarchical list holding the packages and releases."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #packageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself"help: #help;"! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/23/2006 12:44'!buildSearchPaneWith: aBuilder	^ aBuilder pluggableInputFieldSpec new model: self;		selection: #searchSelection;		getText: #searchText; setText: #findPackage:notifying:; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/30/2006 17:43'!buildWith: aBuilder 	"Create the package loader window."	| buttonBarHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	vertDivide := 0.6.	horizDivide := 0.3.	window := aBuilder build: (aBuilder pluggableWindowSpec new model: self;					 label: #label;					 children: (OrderedCollection new add: ((self buildButtonBarWith: aBuilder)							frame: (0 @ 0 corner: 1 @ buttonBarHeight);							 yourself);						 add: ((self buildSearchPaneWith: aBuilder)							frame: (0 @ buttonBarHeight corner: horizDivide @ (buttonBarHeight * 2));							 yourself);						 add: ((self buildPackagesListWith: aBuilder)							frame: (0 @ (buttonBarHeight * 2) corner: horizDivide @ vertDivide);							 yourself);						 add: ((self buildCategoriesListWith: aBuilder)							frame: (0 @ vertDivide corner: horizDivide @ 1);							 yourself);												add: ((self buildPackagePaneWith: aBuilder)								frame: (horizDivide @ buttonBarHeight corner: 1 @ 1));						 yourself);					 yourself).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: 500 @ 400.	^ window! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38'!cachePackageReleaseAndOfferToCopy	"Cache package release, then offer to copy it somewhere.	Answer the chosen file's location after copy,	or the cache location if no directory was chosen."	| release installer newDir newName newFile oldFile oldName |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	installer := SMInstaller forPackageRelease: release.	[UIManager default informUser: 'Caching ' , release asString during: [installer cache]] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs.		^nil ].	installer isCached ifFalse: [self inform: 'Download failed, see transcript for details'. ^nil].	oldName := installer fullFileName.	newDir := FileList2 modalFolderSelector: installer directory.	newDir ifNil: [ ^oldName ].	newDir = installer directory ifTrue: [ ^oldName ].	newName := newDir fullNameFor: installer fileName.	newFile := FileStream newFileNamed: newName.	newFile ifNil: [ ^oldName ].	newFile binary.	oldFile := FileStream readOnlyFileNamed: oldName.	oldFile ifNil: [ ^nil ].	oldFile binary.	[[ newDir copyFile: oldFile toFile: newFile ] ensure: [ oldFile close. newFile close ]] on: Error do: [ :ex | ^oldName ].	^newName! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!categoriesMenu: aMenu 	"Answer the categories-list menu."	self selectedCategory 		ifNotNil: [aMenu addList: self categorySpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:44'!categoryChildren: aCategory	^ aCategory subCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45'!categoryHasChildren: aCategory	^ aCategory hasSubCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:46'!categoryLabel: aCategory	^ aCategory name! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01'!categoryList	"Create the category list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (map categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/22/2006 15:02'!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:01'!commandSpecFor: selector	^ self commandSpecs detect: [:spec | spec second = selector]! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:00'!commandSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.' (item all))		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.' (item all))		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.' (item all))		('Copy from cache' cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' (item))		('Force download into cache' downloadPackageRelease 'Force a download of the selected release into the cache.' (item))		('Update' loadUpdates 'Update the package index from the servers.' (all))		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (conf8irming each).' (all))		('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm '' (item))		('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm '' (item))		('Copy list' listInPasteBuffer 'Puts the list as text into the clipboard.' (all))		('Save filters' saveFiltersAsDefault 'Saves the current filters as default.' (all))		('Help' help 'What is this?' (all)))! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02'!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!defaultLabel	^ 'SqueakMap Package Loader'! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38'!downloadPackageRelease	"Force a download of the selected package release into the cache."	| release |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	[UIManager default informUser: 'Downloading ' , release asString during: [		(SMInstaller forPackageRelease: release) download]	] on: Error do: [:ex |		| msg | 		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filterAdd: anObject	self changeFilters: (self filters copyWith: anObject)! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterAutoInstall	^[:package | package isInstallable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42'!filterAvailable	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterInstalled	^[:package | package isInstalled]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterNotInstalledYet	^[:package | package isInstalled not]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42'!filterNotUptoDate	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterPublished	^[:package | package isPublished]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filterRemove: anObject	self changeFilters: (self filters copyWithout: anObject)! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43'!filterSafelyAvailable	^[:package | package isSafelyAvailable]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/30/2006 21:07'!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically') #('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.') #('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.') #('Installed packages' #filterInstalled 'Display only packages that are installed.') #('Published packages' #filterPublished 'Display only packages that have at least one published release.') ) asOrderedCollection.	categoriesToFilterIds		do: [:catId | specs add: {'Packages in ' , (map object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43'!filterVersion	"Ignore spaces in the version string, they're sometimes spurious.	Not used anymore."	^[:package | package categories anySatisfy:  		[:cat | (cat name, '*') match: (Smalltalk version copyWithout: $ ) ]]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filters	^filters! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/24/2006 13:49'!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or	description. "	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty		ifTrue: [^ self].	descriptions := self packageList collect: [:e | e description].	index + 1		to: list size		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	"wrap around"	1		to: index		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 18:36'!hasSelectedItem	^ self selectedPackageOrRelease notNil! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44'!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by versions: (installed -> latest).If there is no arrow, your installed version of the package is the latest.Bold packages and releases have been installed.The checkbox menu items modify which packages you''ll see.Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.Comment on a package by emailing the author or the squeak list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://wiki.squeak.org/2726' asUrl]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02'!informException: ex msg: msg 	"Tell the user that an error has occurred.	Offer to open debug notifier."	(self confirm: msg, 'Would you like to open a debugger?')		ifTrue: [ex pass]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease ifNil: [^ nil].	item isPackageRelease		ifTrue: [			(item isPublished or: [self confirm: 'Selected release is not published yet, install anyway?'])				ifTrue: [^self installPackageRelease: item]]		ifFalse: [			release := item lastPublishedReleaseForCurrentSystemVersion.			release ifNil: [				(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')					ifTrue: [						release := item lastPublishedRelease.						release ifNil: [							(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')								ifTrue: [release := item lastRelease]]]].			release ifNotNil: [^self installPackageRelease: release]]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:53'!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease installer |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	installer := SMInstaller forPackageRelease: aRelease.	[UIManager default informUser: 'Downloading ' , aRelease asString during:		[installer download].	UIManager default informUser: 'Installing ' , aRelease asString during: [		installer install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02'!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:44'!itemChildren: anItem 	^ anItem isPackage		ifTrue: [anItem releases]		ifFalse: [#()]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 19:56'!itemDescription	^ self selectedPackageOrRelease		ifNil: ['<No package selected>']		ifNotNilDo: [:item | item fullDescription]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45'!itemHasChildren: anItem 	^ anItem isPackage and: [anItem releases notEmpty]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44'!itemLabel: anItem 	| label |	label := anItem isPackage				ifTrue: [anItem name						, (anItem versionLabel								ifEmpty: ['']								ifNotEmptyDo: [:lbl | ' (' , anItem versionLabel , ')'])]				ifFalse: [anItem smartVersion].	^ anItem isInstalled		ifTrue: [label asText allBold]		ifFalse: [label]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/24/2006 17:17'!label	^ self		labelForShown: (packagesList				ifNil: [self packageList])! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!labelForFilter: aFilterSymbol 	^(self filterSpecs detect: [:fs | fs second = aFilterSymbol]) first! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!labelForShown: packagesShown	"Update the label of the window."	^ self defaultLabel , ' (',		(packagesShown size < map packages size ifTrue: [packagesShown size printString,		' shown out of '] ifFalse: ['']) , map packages size printString, ' packages)'! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!listInPasteBuffer	"Useful when talking with people etc.	Uses the map to produce a nice String."	Clipboard clipboardText:		(String streamContents: [:s |			packagesList do: [:p |				s nextPutAll: p nameWithVersionLabel; cr ]]) asText! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:31'!loadUpdates	[UIManager default informUser: 'Loading Updates' during: [		map loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/24/2006 14:05'!noteChanged	filters		ifNil: [^ self reOpen].	map		ifNotNil: [packagesList := nil.			selectedCategory := nil.			self changed: #categoryList.			self changed: #packageList.			self changed: #packagesListIndex.			"update my selection"			self contentsChanged]! !!SMLoaderPlus methodsFor: 'initialization' stamp: 'btr 11/22/2006 16:11'!on: aSqueakMap 	"Initialize instance."	map := aSqueakMap.	map synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!package: aPackage filteredByCategory: aCategory	"Answer true if the package should be shown	if we filter on <aCategory>. It should be shown	if itself or any of its releases has the category."	| releases |	releases := aPackage releases.	^(aPackage hasCategoryOrSubCategoryOf: aCategory) or: [			releases anySatisfy: [:rel |				rel hasCategoryOrSubCategoryOf: aCategory]]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49'!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list |	list := packagesList ifNil: [packagesList := self packageListCalculated].	selectedCategory ifNotNil: [		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^ list! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49'!packageListCalculated	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	^ self packages select: [:p |		filters allSatisfy: [:currFilter |			currFilter isSymbol				ifTrue: [(self perform: currFilter) value: p]				ifFalse: [self package: p filteredByCategory: (map object: currFilter)]]]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!packageNameList	^ self packageList collect: [:e | e name]! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:30'!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [		choices add: (self commandSpecFor: #installPackageRelease)].	(packageOrRelease isDownloadable and: [packageOrRelease isCached]) ifTrue: [		choices add: (self commandSpecFor: #browseCacheDirectory)].	(packageOrRelease isPackageRelease and: [packageOrRelease isDownloadable]) ifTrue: [		choices add: (self commandSpecFor: #cachePackageReleaseAndOfferToCopy).		choices add: (self commandSpecFor: #downloadPackageRelease)].	choices add: (self commandSpecFor: #emailPackageMaintainers).	^ choices! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 16:11'!packages	"We request the packages as sorted by name by default."	^map packagesByName asArray! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01'!packagesListIndex	^ self packageList indexOf: self selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01'!packagesListIndex: anObject 	self		selectedItem: (anObject = 0				ifFalse: [self packageList at: anObject])! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!packagesMenu: aMenu 	"Answer the packages-list menu."	self selectedPackageOrRelease 		ifNotNil: [aMenu addList: self packageSpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:45'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	^ (self respondsTo: selector)		ifTrue: [self perform: selector]		ifFalse: [super perform: selector orSendTo: otherTarget]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/26/2006 23:22'!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	window delete.	(Smalltalk at: self class name) open! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!removeCategoryFilters	"Remove all category filters."	categoriesToFilterIds := OrderedCollection new! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!removeSelectedCategoryAsFilter	"Remove the filter that filters on the currently selected category."	categoriesToFilterIds remove: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!saveFiltersAsDefault	"Save the current filters as default so that they	are selected the next time the loader is opened."	DefaultFilters := filters copy.	DefaultCategoriesToFilterIds := categoriesToFilterIds copy! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35'!searchSelection	"Selects all of the default search text so that a type-in overwrites it."	^ {1. self searchText size}! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35'!searchText	"A dummy default search text so that the field describes its purpose."	^ 'Search packages'! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02'!selectedCategory	"Return selected category."	^ selectedCategory! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:37'!selectedCategory: anSMCategory 	"Change the selected category."	selectedCategory := anSMCategory.	selectedCategory		ifNotNil: [(selectedCategory objects includes: self selectedItem)			ifFalse: [self selectedItem: nil]].	self changed: #selectedCategory.	self changed: #packageList! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:52'!selectedCategoryPath	"Return selected category's path."	| path |	path := #().	selectedCategory		ifNotNil: [selectedCategory parent				ifNotNilDo: [:p | path := path copyWith: p].			path := path copyWith: selectedCategory].	^ path		collect: [:cat | self categoryLabel: cat]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02'!selectedItem	^ selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:27'!selectedItem: anItem	"This == workaround protects us from recursion since ToolBuilder's tree widgets will always tell us that the selection has been updated when we tell it that the selection path has been updated. Cleaner solutions invited."	anItem == selectedItem ifFalse: [		selectedItem := anItem.		self changed: #selectedItemPath.		self changed: #itemDescription.		self changed: #hasSelectedItem]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:16'!selectedItemPath	| path |	path := #().	(selectedItem isKindOf: SMPackageRelease)		ifTrue: [path := path copyWith: selectedItem package].	selectedItem		ifNotNil: [path := path copyWith: selectedItem].	^ path! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:03'!selectedPackageOrRelease	"Return selected package or package release."	^ selectedItem! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!showFilterString: aFilterSymbol 	^(self stateForFilter: aFilterSymbol), (self labelForFilter: aFilterSymbol)! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!stateForFilter: aFilterSymbol 	^(self filters includes: aFilterSymbol) ifTrue: ['<yes>'] ifFalse: ['<no>']! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!toggleFilterState: aFilterSymbol 	^(self filters includes: (aFilterSymbol)) 		ifTrue: [self filterRemove: aFilterSymbol]		ifFalse: [self filterAdd: aFilterSymbol]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!uncheckFilters	"Uncheck all filters."		filters := OrderedCollection new.	self noteChanged! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!updateLabel: packagesShown	"Update the label of the window."	window ifNotNilDo: [:w | w setLabel: (self labelForShown: packagesShown)]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:29'!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during: [				map upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!upgradeInstalledPackagesConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. Confirms on each upgrade."	^ self upgradeInstalledPackagesConfirm: true! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:29'!upgradeInstalledPackagesConfirm: confirmEach 	"Tries to upgrade all installed packages to the latest published release for	this version of Squeak. If confirmEach is true we ask for every	upgrade. "	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty		ifTrue: [^ self inform: 'All ' , installed size printString , ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty		ifTrue: [^ self inform: 'None of the ' , old size printString , ' old packages of the ' , installed size printString , ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size		ifTrue: ['Of the ' , old size printString , ' old packages only ' , toUpgrade size printString , ' can be upgraded.The following packages will not be upgraded:'						, (String								streamContents: [:s | (old removeAll: toUpgrade;										 yourself)										do: [:p | s nextPutAll: p nameWithVersionLabel;												 cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info , 'About to upgrade the following packages:'				, (String						streamContents: [:s | toUpgrade								do: [:p | s nextPutAll: p nameWithVersionLabel;										 cr]]) , 'Proceed?')		ifTrue: [myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during:					[confirmEach						ifTrue: [map								upgradeOldPackagesConfirmBlock: [:p | self confirm: 'Upgrade ' , p installedRelease packageNameWithVersion , ' to ' , (p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName , '?']]						ifFalse: [map upgradeOldPackages].					self inform: toUpgrade size printString , ' packages successfully processed.'.					myRelease = self installedReleaseOfMe						ifTrue: [self noteChanged]						ifFalse: [self reOpen]]]				on: Error				do: [:ex | self informException: ex msg: ('Error occurred when upgrading old packages:\' , ex messageText , '\') withCRs]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!upgradeInstalledPackagesNoConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. No confirmation on each upgrade."	^ self upgradeInstalledPackagesConfirm: false! !!SMLoader commentStamp: 'btr 11/30/2006 18:00' prior: 33620767!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance).You can open one with:	SMLoader open!!SMLoader class methodsFor: 'parts bin' stamp: 'gk 4/5/2005 21:23' prior: 28861640!descriptionForPartsBin	^self partName: 'Package Loader'		categories: #(Tools)		documentation: 'SqueakMap UI'! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 12/1/2006 15:47' prior: 28861837!initialize	"Hook us up in the world menu."	"self initialize"	Smalltalk		at: #ToolBuilder		ifAbsent: [self registerInFlapsRegistry.			(Preferences windowColorFor: #SMLoader) = Color white				ifTrue: ["not set"					Preferences						setWindowColorFor: #SMLoader						to: (Color colorFrom: self windowColorSpecification brightColor)].			(TheWorldMenu respondsTo: #registerOpenCommand:)				ifTrue: [| oldCmds |					oldCmds := TheWorldMenu registry select: [:cmd | cmd first includesSubString: 'Package Loader'].					oldCmds do: [:cmd | TheWorldMenu unregisterOpenCommand: cmd first].					TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoader class methodsFor: 'new-morph participation' stamp: 'gk 4/5/2005 21:21' prior: 28862817!initializedInstance	^self new createWindow extent: 400@400! !!SMLoader class methodsFor: 'instance creation' stamp: 'gk 6/21/2005 10:47' prior: 28860912!new	"Create a SqueakMap loader on the default map."	^self newOn: SMSqueakMap default! !!SMLoader class methodsFor: 'instance creation' stamp: 'gk 6/21/2005 10:47' prior: 28861081!newOn: aMap	"Create a SqueakMap loader on given map."	^super new on: aMap; yourself! !!SMLoader class methodsFor: 'new-morph participation' stamp: 'gk 4/5/2005 21:21' prior: 28862963!newStandAlone	^self new createWindow! !!SMLoader class methodsFor: 'instance creation' stamp: 'gk 6/21/2005 09:28' prior: 28861249!open	"Create and open a SqueakMap Loader."		"SMLoader open"	^self new openAsMorph! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52'!openMenuString	^ 'SqueakMap Catalog'! !!SMLoader class methodsFor: 'instance creation' stamp: 'gk 4/5/2005 21:18' prior: 28861416!openOn: aSqueakMap	"Create and open a SqueakMap Loader on a given map."	"self openOn: SqueakMap default"	^(self newOn: aSqueakMap) openAsMorph! !!SMLoader class methodsFor: 'new-morph participation' stamp: 'gk 6/21/2005 11:06' prior: 28863088!prototypicalToolWindow	^self new createWindow; applyModelExtent; yourself! !!SMLoader class methodsFor: 'new-morph participation' stamp: 'gk 6/21/2005 10:43' prior: 28863250!registerInFlapsRegistry	"Register the receiver in the system's flaps registry."	self environment		at: #Flaps		ifPresent: [:cl | (cl respondsTo: #registerQuad:forFlapNamed:)				ifTrue: [cl registerQuad: #(#SMLoader #prototypicalToolWindow 'Package Loader' 'The SqueakMap Package Loader' ) forFlapNamed: 'Tools']]! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52' prior: 28862509!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoader class methodsFor: 'window color' stamp: 'gk 6/21/2005 09:44' prior: 28863645!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference."	^WindowColorSpec		classSymbol: self name		wording: 'Package Loader'		brightColor: Color yellow muchLighter duller		pastelColor: Color yellow veryMuchLighter duller		helpMessage: 'The SqueakMap Package Loader'! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:08' prior: 28852861!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/12/2004 14:42' prior: 28831998!addSelectedCategoryAsFilter	"Add a new filter that filters on the currently selected category.	Make it enabled as default."	categoriesToFilterIds add: self selectedCategory id! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:14' prior: 33620996!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := model isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(model directory directoryEntryFor: model lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:15' prior: 33621662!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease ifNil: [^ nil].	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:52'!buildButtonBar	| aRow btn |	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	self buttonSpecs do: [:spec |		btn := self buildButtonNamed: spec first helpText: spec third action: spec second.		aRow addMorphBack: btn]		separatedBy: [aRow addTransparentSpacerOfSize: 3@0].	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:27'!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 19:04' prior: 28845640!buildMorphicCategoriesList	"Create the hierarchical list holding the category tree."	| list |	list := (SimpleHierarchicalListMorph				on: self				list: #categoryWrapperList				selected: #selectedCategoryWrapper				changeSelected: #selectedCategoryWrapper:				menu: #categoriesMenu:				keystroke: nil) autoDeselect: true;				 enableDrag: false;				 enableDrop: true;				 yourself.	list setBalloonText: 'The categories are structured in a tree. Packages and package releases belong to several categories.You can add one or more categories as filters and enable them in the menu.'.	"list scroller submorphs do:[:each| list expandAll: each]."	list adjustSubmorphPositions.	^ list! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 00:22' prior: 28846385!buildMorphicPackagesList	"Create the hierarchical list holding the packages and releases."	^(SimpleHierarchicalListMorph 		on: self		list: #packageWrapperList		selected: #selectedItemWrapper		changeSelected: #selectedItemWrapper:		menu: #packagesMenu:		keystroke: nil)		autoDeselect: false;		enableDrag: false;		enableDrop: true;		setBalloonText: 'This shows all packages with their releases that should be displayed according the current filter.';		yourself! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:13'!buildPackageButtonBar	| aRow |	"Somewhat patterned after IRCe's buttonRow method."	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'gk 5/5/2006 02:05' prior: 28846932!buildPackagePane	"Create the text area to the right in the loader."	| ptm |	ptm := PluggableTextMorph 		on: self 		text: #contents		accept: nil		readSelection: nil "#packageSelection "		menu: nil.	ptm setBalloonText: 'This is where the selected package or package release is displayed.'.	ptm lock.	^ptm! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:08' prior: 28847316!buildSearchPane	"Cribbed from MessageNames>>inMorphicWindowWithInitialSearchString:"	| typeInView searchButton typeInPane |	typeInView := PluggableTextMorph				on: self				text: nil				accept: #findPackage:notifying:				readSelection: nil				menu: nil.	typeInView acceptOnCR: true;		 vResizing: #spaceFill;		 hResizing: #spaceFill;		 setTextMorphToSelectAllOnMouseEnter;		 askBeforeDiscardingEdits: false;		 setProperty: #alwaysAccept toValue: true.	(typeInView respondsTo: #hideScrollBarsIndefinitely)		ifTrue: [typeInView hideScrollBarsIndefinitely]		ifFalse: [typeInView hideScrollBarIndefinitely].	searchButton := SimpleButtonMorph new target: typeInView;				 color: Color white;				 label: 'Search';				 actionSelector: #accept;				 arguments: #(); yourself.	typeInPane := AlignmentMorph newRow.	typeInPane vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 listDirection: #leftToRight;		 addMorphFront: searchButton;		 addTransparentSpacerOfSize: 6 @ 0;		 addMorphBack: typeInView;		 setBalloonText: 'Type into the pane, then press Search (or hit RETURN) to visit the next package matching what you typed.'.	^ typeInPane! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:24'!buttonSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.')		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.')		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.')		('Update' loadUpdates 'Update the package index from the servers.')		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (confirming each).')		('Help' help 'What is this?'))! !!SMLoader methodsFor: 'actions' stamp: 'gk 5/5/2006 02:05' prior: 28832899!cachePackageReleaseAndOfferToCopy	"Cache package release, then offer to copy it somewhere.	Answer the chosen file's location after copy,	or the cache location if no directory was chosen."	| release installer newDir newName newFile oldFile oldName |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	installer := SMInstaller forPackageRelease: release.	[Cursor wait showWhile: [installer cache]] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs.		^nil ].	installer isCached ifFalse: [self inform: 'Download failed, see transcript for details'. ^nil].	oldName := installer fullFileName.	newDir := FileList2 modalFolderSelector: installer directory.	newDir ifNil: [ ^oldName ].	newDir = installer directory ifTrue: [ ^oldName ].	newName := newDir fullNameFor: installer fileName.	newFile := FileStream newFileNamed: newName.	newFile ifNil: [ ^oldName ].	newFile binary.	oldFile := FileStream readOnlyFileNamed: oldName.	oldFile ifNil: [ ^nil ].	oldFile binary.	[[ newDir copyFile: oldFile toFile: newFile ] ensure: [ oldFile close. newFile close ]] on: Error do: [ :ex | ^oldName ].	^newName! !!SMLoader methodsFor: 'menus' stamp: 'gk 7/10/2004 03:58' prior: 28853367!categoriesMenu: aMenu 	"Answer the categories-list menu."	self selectedCategory 		ifNotNil: [aMenu addList: self categorySpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:11' prior: 28853658!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoader methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01' prior: 33622152!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (model categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list		collect: [:cat | SMCategoryWrapper with: cat model: self]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:45' prior: 28830445!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoader methodsFor: 'private' stamp: 'gk 5/5/2006 02:05' prior: 28856147!contents	| packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	^packageOrRelease		ifNil: ['<No package selected>']		ifNotNil: [packageOrRelease fullDescription]! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 17:30' prior: 28847830!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.3.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0.0 @ 0.0 corner: 1.0 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0.0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (0.0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0.0 @ horizDivide corner: vertDivide @ 1.0).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1.0 @ 1.0).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self! !!SMLoader methodsFor: 'interface' stamp: 'gk 7/12/2004 11:14' prior: 28848460!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:01'!defaultLabel	^'SqueakMap Package Loader'! !!SMLoader methodsFor: 'actions' stamp: 'gk 5/5/2006 02:05' prior: 28834265!downloadPackageRelease	"Force a download of the selected package release into the cache."	| release |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: release) download]	] on: Error do: [:ex |		| msg | 		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs]! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/22/2006 01:14' prior: 28834809!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:45' prior: 28840709!filterAdd: anObject	self changeFilters: (self filters copyWith: anObject)! !!SMLoader methodsFor: 'filters' stamp: 'dvf 10/25/2002 11:29' prior: 28843476!filterAutoInstall	^[:package | package isInstallable]! !!SMLoader methodsFor: 'filters' stamp: 'gk 7/13/2004 15:28' prior: 28843596!filterAvailable		^[:package | package isAvailable]! !!SMLoader methodsFor: 'filters' stamp: 'dvf 10/25/2002 17:08' prior: 28843716!filterInstalled	^[:package | package isInstalled]! !!SMLoader methodsFor: 'filters' stamp: 'dvf 10/25/2002 17:08' prior: 28843834!filterNotInstalledYet	^[:package | package isInstalled not]! !!SMLoader methodsFor: 'filters' stamp: 'dvf 10/25/2002 17:07' prior: 28843962!filterNotUptoDate		^[:package | package isAvailable]! !!SMLoader methodsFor: 'filters' stamp: 'gk 1/28/2004 23:42' prior: 28844082!filterPublished	^[:package | package isPublished]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:45' prior: 28840860!filterRemove: anObject	self changeFilters: (self filters copyWithout: anObject)! !!SMLoader methodsFor: 'filters' stamp: 'gk 7/13/2004 15:28' prior: 28844198!filterSafelyAvailable		^[:package | package isSafelyAvailable]! !!SMLoader methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 00:14' prior: 33622758!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('Installed packages' #filterInstalled 'Display only packages that are installed.')	#('Published packages' #filterPublished 'Display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'Packages in ', (model object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'filters' stamp: 'gk 7/11/2004 03:02' prior: 28844328!filterVersion	"Ignore spaces in the version string, they're sometimes spurious.	Not used anymore."	^[:package | package categories anySatisfy:  		[:cat | (cat name, '*') match: (Smalltalk version copyWithout: $ ) ]]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:47' prior: 28842150!filters	^filters! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 19:27' prior: 28835442!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or description."	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty ifTrue: [^self].	descriptions _ self packageWrapperList collect: [:e | e withoutListWrapper description].	index + 1 to: list size		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	"wrap around"	1 to: index		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:05' prior: 28854306!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 00:48' prior: 28848693!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by (installed version -> latest version).If there is no arrow, your installed version of the package is the latest.Installed packages and releases are also in bold.The checkbox menu items at the bottom let you modify which packages you''ll see. Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.If you like a package or have comments on it, please contactthe author or the squeak mailing list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://minnow.cc.gatech.edu/squeak/2726' asUrl]! !!SMLoader methodsFor: 'private' stamp: 'gk 7/10/2004 04:04' prior: 28856397!informException: ex msg: msg 	"Tell the user that an error has occurred.	Offer to open debug notifier."	(self confirm: msg, 'Would you like to open a debugger?')		ifTrue: [ex pass]! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/22/2006 01:13' prior: 28836104!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease ifNil: [^ nil].	item isPackageRelease		ifTrue: [			(item isPublished or: [self confirm: 'Selected release is not published yet, install anyway?'])				ifTrue: [^self installPackageRelease: item]]		ifFalse: [			release := item lastPublishedReleaseForCurrentSystemVersion.			release ifNil: [				(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')					ifTrue: [						release := item lastPublishedRelease.						release ifNil: [							(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')								ifTrue: [release := item lastRelease]]]].			release ifNotNil: [^self installPackageRelease: release]]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:41' prior: 33623893!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:25' prior: 33624788!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'filter utilities' stamp: 'dvf 10/25/2002 11:27' prior: 28842244!labelForFilter: aFilterSymbol 	^(self filterSpecs detect: [:fs | fs second = aFilterSymbol]) first! !!SMLoader methodsFor: 'actions' stamp: 'gk 11/18/2003 02:19' prior: 28837020!listInPasteBuffer	"Useful when talking with people etc.	Uses the map to produce a nice String."	Clipboard clipboardText:		(String streamContents: [:s |			packagesList do: [:p |				s nextPutAll: p nameWithVersionLabel; cr ]]) asText! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:12' prior: 33625064!loadUpdates	[Cursor wait showWhile: [		model loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 01:02' prior: 33625350!noteChanged	filters ifNil: [^self reOpen].	model ifNotNil: [		packagesList := nil.		selectedCategoryWrapper := nil.		self changed: #categoryWrapperList.		self changed: #packageWrapperList.		self changed: #packagesListIndex.	"update my selection"		self contentsChanged]! !!SMLoader methodsFor: 'initialization' stamp: 'gk 9/25/2006 23:12' prior: 33625714!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'initialization' stamp: 'gk 4/5/2005 21:17' prior: 28849834!openAsMorph	"Open the loader as a Morphic window."	"SMLoader new openAsMorph"		^self createWindow openInWorld! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/11/2004 22:29' prior: 28842418!package: aPackage filteredByCategory: aCategory	"Answer true if the package should be shown	if we filter on <aCategory>. It should be shown	if itself or any of its releases has the category."	| releases |	releases := aPackage releases.	^(aPackage hasCategoryOrSubCategoryOf: aCategory) or: [			releases anySatisfy: [:rel |				rel hasCategoryOrSubCategoryOf: aCategory]]! !!SMLoader methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45' prior: 33625994!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				(filters ifNil: [#()]) allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNotNil:		[selectedCategory := selectedCategoryWrapper category.		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'lists' stamp: 'dvf 9/21/2003 16:36' prior: 28852215!packageNameList	^self packageWrapperList collect: [:e | e withoutListWrapper name]! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/22/2006 14:30' prior: 28854716!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [		choices add: self buttonSpecs first].	(packageOrRelease isDownloadable and: [packageOrRelease isCached]) ifTrue: [		choices add: self buttonSpecs third].	(packageOrRelease isPackageRelease and: [packageOrRelease isDownloadable]) ifTrue: [		choices add: #('Copy from cache' #cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' ).		choices add: #('Force download into cache' #downloadPackageRelease 'Force a download of the selected release into the cache.' )].	choices add: self buttonSpecs second.	^ choices! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/9/2004 01:36' prior: 28852361!packageWrapperList	"Return the list with each element wrapped so that it	can be used in a SimpleHierarchicalListMorph."	^self packageList collect: [:e | SMPackageWrapper with: e]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/25/2006 23:12' prior: 33626799!packages	"We request the packages as sorted by name by default."	^model packagesByName asArray! !!SMLoader methodsFor: 'accessing' stamp: 'dvf 9/21/2003 16:34' prior: 28830776!packagesListIndex	^self packageWrapperList indexOf: self selectedItemWrapper! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:56' prior: 28830922!packagesListIndex: anObject 	self		selectedItemWrapper: (anObject ifNotNil: [anObject = 0				ifFalse: [self packageWrapperList at: anObject]])! !!SMLoader methodsFor: 'menus' stamp: 'gk 7/9/2004 03:04' prior: 28855851!packagesMenu: aMenu 	"Answer the packages-list menu."	self selectedPackageOrRelease 		ifNotNil: [aMenu addList: self packageSpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoader methodsFor: 'interface' stamp: 'gk 4/5/2005 21:43' prior: 28850134!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!SMLoader methodsFor: 'private' stamp: 'btr 11/26/2006 23:22' prior: 28858237!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	self delete.	(Smalltalk at: self class name) open! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/12/2004 14:42' prior: 28837599!removeCategoryFilters	"Remove all category filters."	categoriesToFilterIds := OrderedCollection new! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/12/2004 14:42' prior: 28837767!removeSelectedCategoryAsFilter	"Remove the filter that filters on the currently selected category."	categoriesToFilterIds remove: self selectedCategory id! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/12/2004 14:42' prior: 28837990!saveFiltersAsDefault	"Save the current filters as default so that they	are selected the next time the loader is opened."	DefaultFilters := filters copy.	DefaultCategoriesToFilterIds := categoriesToFilterIds copy! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 19:17' prior: 28831123!selectedCategory	"Return selected category."	^selectedCategoryWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'accessing' stamp: 'ar 2/9/2004 02:14' prior: 28831336!selectedCategoryWrapper	^selectedCategoryWrapper! !!SMLoader methodsFor: 'accessing' stamp: 'btr 12/1/2006 15:51' prior: 28831452!selectedCategoryWrapper: aWrapper	selectedCategoryWrapper := aWrapper.	(aWrapper notNil and:		[aWrapper withoutListWrapper objects includes: selectedItemWrapper withoutListWrapper])		ifFalse: [self selectedItemWrapper: nil].	self changed: #selectedCategoryWrapper.	self changed: #packageWrapperList.! !!SMLoader methodsFor: 'accessing' stamp: 'dvf 9/21/2003 15:04' prior: 28831701!selectedItemWrapper	^selectedItemWrapper! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/22/2006 19:13' prior: 28831809!selectedItemWrapper: aWrapper	selectedItemWrapper := aWrapper.	self changed: #selectedItemWrapper.	self contentsChanged! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:10' prior: 28858547!selectedPackageOrRelease	"Return selected package or package release."	^self selectedItemWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'filter utilities' stamp: 'dvf 10/25/2002 14:48' prior: 28842873!showFilterString: aFilterSymbol 	^(self stateForFilter: aFilterSymbol), (self labelForFilter: aFilterSymbol)! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:45' prior: 28843057!stateForFilter: aFilterSymbol 	^(self filters includes: aFilterSymbol) ifTrue: ['<yes>'] ifFalse: ['<no>']! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:46' prior: 28843241!toggleFilterState: aFilterSymbol 	^(self filters includes: (aFilterSymbol)) 		ifTrue: [self filterRemove: aFilterSymbol]		ifFalse: [self filterAdd: aFilterSymbol]! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/13/2004 16:05' prior: 28838272!uncheckFilters	"Uncheck all filters."		filters := OrderedCollection new.	self noteChanged! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:02' prior: 33626976!updateLabel: packagesShown	"Update the label of the window."	self setLabel: self defaultLabel , ' (',			(packagesShown size < model packages size ifTrue: [packagesShown size printString,			' shown out of '] ifFalse: ['']) , model packages size printString, ' packages)'! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 21:03' prior: 33627242!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/14/2004 16:29' prior: 28840141!upgradeInstalledPackagesConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. Confirms on each upgrade."	^ self upgradeInstalledPackagesConfirm: true! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:03' prior: 33628966!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/14/2004 16:29' prior: 28840415!upgradeInstalledPackagesNoConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. No confirmation on each upgrade."	^ self upgradeInstalledPackagesConfirm: false! !!SMLoaderCategorical commentStamp: 'btr 12/1/2006 15:16' prior: 0!A variant package loader that uses a more-or-less standard Smalltalk-80 browser perspective of selecting categories in one pane and then selecting items within in the next pane.You can open one with:	SMLoaderCategorical open!!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06'!initialize	Smalltalk at: #ToolBuilder ifAbsent: [	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58'!buildMorphicInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #installedPackageNameList		selected: #installedPackagesListIndex		changeSelected: #installedPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58'!buildMorphicNotInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #notInstalledPackageNameList		selected: #notInstalledPackagesListIndex		changeSelected: #notInstalledPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 20:06'!createFancyWindow	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicNotInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (horizDivide / 2)).	self addMorph: (self buildMorphicInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setUpdatablePanesFrom: #(#installedPackageNameList #notInstalledPackageNameList ).	currentPackageList := #notInstalled.	self setLabel: 'Categorical SqueakMap Package Loader'! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 20:01'!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setLabel: 'Categorical SqueakMap Package Loader'! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 17:27'!currentPackageList	^currentPackageList! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'btr 11/30/2006 17:44'!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 19:14'!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['No removing yet']! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20'!installedPackageNameList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58'!installedPackagesListIndex	self currentPackageList = #installed		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35'!installedPackagesListIndex: anObject 	packagesListIndex _ anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 15:09'!isOn	^false! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20'!notInstalledPackageNameList	^self packageList select: [:e | e isInstalled not]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58'!notInstalledPackagesListIndex	self currentPackageList = #notInstalled		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35'!notInstalledPackagesListIndex: anObject 	packagesListIndex _ anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategorical methodsFor: 'private' stamp: 'btr 11/30/2006 20:21'!noteChanged	self changed: #installedPackageNameList.	self changed: #notInstalledPackageNameList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45'!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !!FileList2 class methodsFor: '*smloader-override' stamp: 'btr 1/30/2004 00:56' prior: 20699099!morphicView	^ self morphicViewOnDirectory: FileDirectory default! !!FileList2 class methodsFor: '*smloader-extension' stamp: 'gk 5/5/2006 02:05' prior: 20698105!morphicViewOnDirectory: aFileDirectory	| aFileList window fileListBottom midLine fileListTopOffset buttonPane |	aFileList := self new directory: aFileDirectory.	window := (SystemWindow labelled: aFileDirectory pathName) model: aFileList.	fileListTopOffset := (TextStyle defaultFont pointSize * 2) + 14.	fileListBottom := 0.4.	midLine := 0.4.	buttonPane := aFileList optionalButtonRow addMorph:		(aFileList morphicPatternPane vResizing: #spaceFill; yourself).	self addFullPanesTo: window from: {		{buttonPane. 0@0 corner: 1@0. 0@0 corner: 0@fileListTopOffset}.		{aFileList morphicDirectoryTreePane. 0@0 corner: midLine@fileListBottom. 					0@fileListTopOffset corner: 0@0}.		{aFileList morphicFileListPane. midLine @ 0 corner: 1@fileListBottom. 					0@fileListTopOffset corner: 0@0}.		{aFileList morphicFileContentsPane. 0@fileListBottom corner: 1@1. nil}.	}.	aFileList postOpen.	^ window ! !----End fileIn of a stream----!!SMCategoryWrapper commentStamp: '<historical>' prior: 35149084!This is a wrapper for showing the SqueakMap categories (SMCategory) using the SimpleHierarchicalListMorph in the SMLoader, see SMLoader>>categoryWrapperList.!!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13' prior: 35149330!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMCategoryWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 18:53' prior: 35149491!asString	^ item name , ' (' , self numberOfObjects printString , ')'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'ar 2/9/2004 02:35' prior: 35149651!category	^item! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 21:02' prior: 35149760!contents	^ item subCategories		collect: [:n | self class with: n model: n]! !!SMCategoryWrapper methodsFor: 'model access' stamp: 'btr 11/30/2006 21:02' prior: 35149917!getList	^ Array		with: (self class with: self contents model: model)! !!SMCategoryWrapper methodsFor: 'testing' stamp: 'btr 11/30/2006 18:53' prior: 35150063!hasContents	^ item hasSubCategories! !!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13' prior: 35150190!hash	^self withoutListWrapper hash! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:56' prior: 35150303!help	^ 'The categories are structured in a tree. Packages and package releases belong to several categories. You can add one or more categories as filters and enable them in the menu.'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'BJP 11/22/2002 14:17' prior: 35150566!model	^model! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:53' prior: 35150657!numberOfObjects"	| total |	total _ 0.	model allCategoriesDo: [:c |		total _ total + c objects size].	^total"	^item objects size! !!SMPackageReleaseWrapper commentStamp: 'gk 6/21/2005 10:54' prior: 35150871!This is a wrapper for showing the SqueakMap package releases (SMPackageRelease) using the SimpleHierarchicalListMorph in the SMLoader, see SMPackageWrapper>>contents.!!SMPackageReleaseWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 21:30' prior: 35151136!asString	"Show installed releases with a trailing asterisk."	| string |	string := item smartVersion.	"Older SMBase versions don't have isInstalled.'"	(item respondsTo: #isInstalled) ifTrue:		[item isInstalled ifTrue: [string := (string , ' *') asText allBold]].	^ string! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 17:14' prior: 35151497!contents	^ #()! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49' prior: 35151596!label	^ self asString	! !!SMPackageWrapper commentStamp: '<historical>' prior: 35151688!This is a wrapper for showing the SqueakMap packages (SMPackage) using the SimpleHierarchicalListMorph in the SMLoader, see SMLoader>>packageWrapperList.!!SMPackageWrapper methodsFor: 'comparing' stamp: 'dvf 9/21/2003 16:25' prior: 35151931!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMPackageWrapper methodsFor: 'converting' stamp: 'btr 11/22/2006 00:54' prior: 35152091!asString	| string |	string := item name, ' (', item versionLabel, ')'.	item isInstalled ifTrue: [string := string asText allBold].	"(string includesSubString: '->') ifTrue: [string := string asText color: Color green]."	^ string! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'dvf 10/14/2003 18:58' prior: 35152417!contents	^item releases reversed collect: [:e | SMPackageReleaseWrapper with: e]! !!SMPackageWrapper methodsFor: 'testing' stamp: 'dvf 9/21/2003 16:25' prior: 35152588!hash	^self withoutListWrapper hash! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:55' prior: 35152700!help	^ 'This shows all packages with their releases that should be displayed according the current filter.'! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49' prior: 35152885!label	^ self asString! !!SMPackageWrapper methodsFor: 'printing' stamp: 'dvf 9/21/2003 16:22' prior: 35152998!printOn: aStream	aStream nextPutAll: 'wrapper for: ', item printString! !!SMLoaderPlus commentStamp: 'btr 12/1/2006 15:16' prior: 35153133!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance). It uses ToolBuilder to construct its window. You can open one with:	SMLoaderPlus openInstance Variables	categoriesToFilterIds:		<OrderedCollection> The set of categories to filter the packages list.	filters:				<OrderedCollection> The set of filters to apply to the packages list.	map:				<SMSqueakMap> The model SqueakMap.	packagesList:		<OrderedCollection> The list of packages from the map.	selectedCategory:	<SMCategory> The current category.	selectedItem:			<SMPackage> The selected package or release.	window:			<PluggableSystemWindow> The window, held only so we can reOpen.!!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06' prior: 35153932!initialize	Smalltalk at: #ToolBuilder ifPresent: [:tb |		(TheWorldMenu respondsTo: #registerOpenCommand:)			ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34' prior: 35154221!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34' prior: 35154358!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34' prior: 35154619!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:59' prior: 35154828!buildFancyWith: aBuilder	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	window := aBuilder build: (aBuilder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: aBuilder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: aBuilder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: aBuilder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)); yourself);				add: ((self buildNotInstalledPackagesListWith: aBuilder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ (horizDivide / 2)); yourself);				add: ((self buildInstalledPackagesListWith: aBuilder)					frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide); yourself);				add: ((self buildPackagePaneWith: aBuilder)					frame: (0 @ horizDivide corner: 1 @ 1); yourself); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	self setUpdatablePanesFrom: #(#installedPackageList #notInstalledPackageList ).	currentPackageList := #notInstalled.	window extent: 500@500.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:56' prior: 35156396!buildInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #installedPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:52' prior: 35156840!buildNotInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #notInstalledPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:47' prior: 35157290!buildWith: aBuilder	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	window := aBuilder build: (aBuilder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: aBuilder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: aBuilder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: aBuilder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)); yourself);				add: ((self buildPackagesListWith: aBuilder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide); yourself);				add: ((self buildPackagePaneWith: aBuilder)					frame: (0 @ horizDivide corner: 1 @ 1); yourself); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: 500@500.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34' prior: 35158466!currentPackageList	^currentPackageList! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34' prior: 35158588!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 18:01' prior: 35158766!defaultLabel	^ 'Catgorical ' , super defaultLabel! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:34' prior: 35158899!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['No removing yet']! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:52' prior: 35159110!installedPackageList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02' prior: 35159261!installedPackagesListIndex	^ self currentPackageList = #installed		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34' prior: 35159460!installedPackagesListIndex: anObject 	packagesListIndex _ anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34' prior: 35159755!isOn	^false! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:53' prior: 35159846!notInstalledPackageList	^self packageList reject: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02' prior: 35160000!notInstalledPackagesListIndex	^ self currentPackageList = #notInstalled		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:03' prior: 35160205!notInstalledPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategoricalPlus methodsFor: 'private' stamp: 'btr 12/1/2006 17:53' prior: 35160589!noteChanged	self changed: #installedPackageList.	self changed: #notInstalledPackageList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:34' prior: 35160909!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !!SMLoaderPlus class methodsFor: 'parts bin' stamp: 'btr 11/22/2006 15:02' prior: 35161214!descriptionForPartsBin	^self partName: 'Package Loader'		categories: #(Tools)		documentation: 'SqueakMap UI'! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 12/1/2006 15:47' prior: 35161415!initialize	"Hook us up in the world menu."		"self initialize"	Smalltalk at: #ToolBuilder ifPresent: [:tb |		self registerInFlapsRegistry.		(Preferences windowColorFor: #SMLoader) = Color white "not set"			ifTrue: [ Preferences setWindowColorFor: #SMLoader to: (Color colorFrom: self windowColorSpecification brightColor) ].		 (TheWorldMenu respondsTo: #registerOpenCommand:)	         ifTrue: [| oldCmds |				oldCmds := TheWorldMenu registry select: [:cmd | cmd first includesSubString: 'Package Loader'].				oldCmds do: [:cmd | TheWorldMenu unregisterOpenCommand: cmd first].			TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16' prior: 35162269!initializedInstance	^ (ToolBuilder open: self new) extent: 400@400! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02' prior: 35162423!new	"Create a SqueakMap loader on the default map."	^self newOn: SMSqueakMap default! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02' prior: 35162597!newOn: aMap	"Create a SqueakMap loader on given map."	^super new on: aMap; yourself! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16' prior: 35162776!newStandAlone	^ ToolBuilder open: self new! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:13' prior: 35162906!open	"Create and open a SqueakMap Loader."		"SMLoaderPlus open"	^ (Smalltalk at: #ToolBuilder) open: self new! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50' prior: 35163110!openMenuString	^ 'SqueakMap Catalog'! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:21' prior: 35163234!openOn: aSqueakMap	"Create and open a SqueakMap Loader on a given map."	"self openOn: SqueakMap default"	^ (Smalltalk at: #ToolBuilder) open: (self newOn: aSqueakMap)! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:18' prior: 35163498!prototypicalToolWindow	^ ToolBuilder open: self new; applyModelExtent; yourself! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:02' prior: 35163671!registerInFlapsRegistry	"Register the receiver in the system's flaps registry."	self environment		at: #Flaps		ifPresent: [:cl | (cl respondsTo: #registerQuad:forFlapNamed:)				ifTrue: [cl registerQuad: #(#SMLoader #prototypicalToolWindow 'Package Loader' 'The SqueakMap Package Loader' ) forFlapNamed: 'Tools']]! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50' prior: 35164078!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoaderPlus class methodsFor: 'window color' stamp: 'btr 11/22/2006 15:02' prior: 35164373!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference."	^WindowColorSpec		classSymbol: self name		wording: 'Package Loader'		brightColor: Color yellow muchLighter duller		pastelColor: Color yellow veryMuchLighter duller		helpMessage: 'The SqueakMap Package Loader'! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02' prior: 35164746!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02' prior: 35165246!addSelectedCategoryAsFilter	"Add a new filter that filters on the currently selected category.	Make it enabled as default."	categoriesToFilterIds add: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 16:11' prior: 35165496!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := map isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(map directory directoryEntryFor: map lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:43' prior: 35166142!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease				ifNil: [^ nil].	dir := item isPackage				ifTrue: [map cache directoryForPackage: item]				ifFalse: [map cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir.	"withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/23/2006 12:20' prior: 35166618!buildButtonBarWith: aBuilder	^ aBuilder pluggablePanelSpec new		model: self;		layout: #horizontal;		children: (self commandSpecs select: [ :spec | spec fourth includes: #all]				thenCollect: [ :spec |					aBuilder pluggableActionButtonSpec new						model: self;						label: spec first;						action: spec second;						help: spec third;						enabled: ((spec fourth includes: #item) ifTrue: [#hasSelectedItem]);						yourself]);			yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02' prior: 35167140!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:48' prior: 35167544!buildCategoriesListWith: aBuilder 	"Create the hierarchical list holding the category tree."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #categoryList;		 getSelectedPath: #selectedCategoryPath;		 getChildren: #categoryChildren:;		 hasChildren: #categoryHasChildren:;		 setSelected: #selectedCategory:;		 menu: #categoriesMenu:;		 label: #categoryLabel:;		 autoDeselect: true;		 wantsDrop: true;		 yourself"help: #help;"! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:19' prior: 35168059!buildPackageButtonBarWith: aBuilder	^ AlignmentMorph newRow beSticky;		color: Color transparent;		clipSubmorphs: true;		yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 19:56' prior: 35168264!buildPackagePaneWith: aBuilder	"Create the text area to the right in the loader."	^ aBuilder pluggableTextSpec new model: self; getText: #itemDescription; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:17' prior: 35168503!buildPackagesListWith: aBuilder 	"Create the hierarchical list holding the packages and releases."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #packageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself"help: #help;"! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/23/2006 12:44' prior: 35169001!buildSearchPaneWith: aBuilder	^ aBuilder pluggableInputFieldSpec new model: self;		selection: #searchSelection;		getText: #searchText; setText: #findPackage:notifying:; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/30/2006 17:43' prior: 35169254!buildWith: aBuilder 	"Create the package loader window."	| buttonBarHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	vertDivide := 0.6.	horizDivide := 0.3.	window := aBuilder build: (aBuilder pluggableWindowSpec new model: self;					 label: #label;					 children: (OrderedCollection new add: ((self buildButtonBarWith: aBuilder)							frame: (0 @ 0 corner: 1 @ buttonBarHeight);							 yourself);						 add: ((self buildSearchPaneWith: aBuilder)							frame: (0 @ buttonBarHeight corner: horizDivide @ (buttonBarHeight * 2));							 yourself);						 add: ((self buildPackagesListWith: aBuilder)							frame: (0 @ (buttonBarHeight * 2) corner: horizDivide @ vertDivide);							 yourself);						 add: ((self buildCategoriesListWith: aBuilder)							frame: (0 @ vertDivide corner: horizDivide @ 1);							 yourself);												add: ((self buildPackagePaneWith: aBuilder)								frame: (horizDivide @ buttonBarHeight corner: 1 @ 1));						 yourself);					 yourself).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: 500 @ 400.	^ window! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38' prior: 35170474!cachePackageReleaseAndOfferToCopy	"Cache package release, then offer to copy it somewhere.	Answer the chosen file's location after copy,	or the cache location if no directory was chosen."	| release installer newDir newName newFile oldFile oldName |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	installer := SMInstaller forPackageRelease: release.	[UIManager default informUser: 'Caching ' , release asString during: [installer cache]] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs.		^nil ].	installer isCached ifFalse: [self inform: 'Download failed, see transcript for details'. ^nil].	oldName := installer fullFileName.	newDir := FileList2 modalFolderSelector: installer directory.	newDir ifNil: [ ^oldName ].	newDir = installer directory ifTrue: [ ^oldName ].	newName := newDir fullNameFor: installer fileName.	newFile := FileStream newFileNamed: newName.	newFile ifNil: [ ^oldName ].	newFile binary.	oldFile := FileStream readOnlyFileNamed: oldName.	oldFile ifNil: [ ^nil ].	oldFile binary.	[[ newDir copyFile: oldFile toFile: newFile ] ensure: [ oldFile close. newFile close ]] on: Error do: [ :ex | ^oldName ].	^newName! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02' prior: 35171889!categoriesMenu: aMenu 	"Answer the categories-list menu."	self selectedCategory 		ifNotNil: [aMenu addList: self categorySpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:44' prior: 35172189!categoryChildren: aCategory	^ aCategory subCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45' prior: 35172316!categoryHasChildren: aCategory	^ aCategory hasSubCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:46' prior: 35172449!categoryLabel: aCategory	^ aCategory name! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01' prior: 35172560!categoryList	"Create the category list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (map categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02' prior: 35173088!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/22/2006 15:02' prior: 35173706!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:01' prior: 35174037!commandSpecFor: selector	^ self commandSpecs detect: [:spec | spec second = selector]! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:00' prior: 35174192!commandSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.' (item all))		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.' (item all))		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.' (item all))		('Copy from cache' cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' (item))		('Force download into cache' downloadPackageRelease 'Force a download of the selected release into the cache.' (item))		('Update' loadUpdates 'Update the package index from the servers.' (all))		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (conf8irming each).' (all))		('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm '' (item))		('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm '' (item))		('Copy list' listInPasteBuffer 'Puts the list as text into the clipboard.' (all))		('Save filters' saveFiltersAsDefault 'Saves the current filters as default.' (all))		('Help' help 'What is this?' (all)))! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02' prior: 35175449!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50' prior: 35175680!defaultLabel	^ 'SqueakMap Package Loader'! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38' prior: 35175792!downloadPackageRelease	"Force a download of the selected package release into the cache."	| release |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	[UIManager default informUser: 'Downloading ' , release asString during: [		(SMInstaller forPackageRelease: release) download]	] on: Error do: [:ex |		| msg | 		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02' prior: 35176391!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02' prior: 35177053!filterAdd: anObject	self changeFilters: (self filters copyWith: anObject)! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02' prior: 35177200!filterAutoInstall	^[:package | package isInstallable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42' prior: 35177324!filterAvailable	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02' prior: 35177445!filterInstalled	^[:package | package isInstalled]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02' prior: 35177566!filterNotInstalledYet	^[:package | package isInstalled not]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42' prior: 35177696!filterNotUptoDate	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02' prior: 35177819!filterPublished	^[:package | package isPublished]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02' prior: 35177949!filterRemove: anObject	self changeFilters: (self filters copyWithout: anObject)! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43' prior: 35178101!filterSafelyAvailable	^[:package | package isSafelyAvailable]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/30/2006 21:07' prior: 35178243!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically') #('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.') #('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.') #('Installed packages' #filterInstalled 'Display only packages that are installed.') #('Published packages' #filterPublished 'Display only packages that have at least one published release.') ) asOrderedCollection.	categoriesToFilterIds		do: [:catId | specs add: {'Packages in ' , (map object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43' prior: 35179280!filterVersion	"Ignore spaces in the version string, they're sometimes spurious.	Not used anymore."	^[:package | package categories anySatisfy:  		[:cat | (cat name, '*') match: (Smalltalk version copyWithout: $ ) ]]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02' prior: 35179579!filters	^filters! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/24/2006 13:49' prior: 35179667!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or	description. "	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty		ifTrue: [^ self].	descriptions := self packageList collect: [:e | e description].	index + 1		to: list size		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	"wrap around"	1		to: index		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02' prior: 35180661!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 18:36' prior: 35181018!hasSelectedItem	^ self selectedPackageOrRelease notNil! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44' prior: 35181145!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by versions: (installed -> latest).If there is no arrow, your installed version of the package is the latest.Bold packages and releases have been installed.The checkbox menu items modify which packages you''ll see.Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.Comment on a package by emailing the author or the squeak list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://wiki.squeak.org/2726' asUrl]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02' prior: 35182255!informException: ex msg: msg 	"Tell the user that an error has occurred.	Offer to open debug notifier."	(self confirm: msg, 'Would you like to open a debugger?')		ifTrue: [ex pass]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02' prior: 35182511!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease ifNil: [^ nil].	item isPackageRelease		ifTrue: [			(item isPublished or: [self confirm: 'Selected release is not published yet, install anyway?'])				ifTrue: [^self installPackageRelease: item]]		ifFalse: [			release := item lastPublishedReleaseForCurrentSystemVersion.			release ifNil: [				(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')					ifTrue: [						release := item lastPublishedRelease.						release ifNil: [							(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')								ifTrue: [release := item lastRelease]]]].			release ifNotNil: [^self installPackageRelease: release]]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:53' prior: 35183445!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease installer |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	installer := SMInstaller forPackageRelease: aRelease.	[UIManager default informUser: 'Downloading ' , aRelease asString during:		[installer download].	UIManager default informUser: 'Installing ' , aRelease asString during: [		installer install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02' prior: 35184510!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:44' prior: 35184778!itemChildren: anItem 	^ anItem isPackage		ifTrue: [anItem releases]		ifFalse: [#()]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 19:56' prior: 35184935!itemDescription	^ self selectedPackageOrRelease		ifNil: ['<No package selected>']		ifNotNilDo: [:item | item fullDescription]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45' prior: 35185136!itemHasChildren: anItem 	^ anItem isPackage and: [anItem releases notEmpty]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44' prior: 35185284!itemLabel: anItem 	| label |	label := anItem isPackage				ifTrue: [anItem name						, (anItem versionLabel								ifEmpty: ['']								ifNotEmptyDo: [:lbl | ' (' , anItem versionLabel , ')'])]				ifFalse: [anItem smartVersion].	^ anItem isInstalled		ifTrue: [label asText allBold]		ifFalse: [label]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/24/2006 17:17' prior: 35185661!label	^ self		labelForShown: (packagesList				ifNil: [self packageList])! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02' prior: 35185816!labelForFilter: aFilterSymbol 	^(self filterSpecs detect: [:fs | fs second = aFilterSymbol]) first! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50' prior: 35185983!labelForShown: packagesShown	"Update the label of the window."	^ self defaultLabel , ' (',		(packagesShown size < map packages size ifTrue: [packagesShown size printString,		' shown out of '] ifFalse: ['']) , map packages size printString, ' packages)'! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02' prior: 35186310!listInPasteBuffer	"Useful when talking with people etc.	Uses the map to produce a nice String."	Clipboard clipboardText:		(String streamContents: [:s |			packagesList do: [:p |				s nextPutAll: p nameWithVersionLabel; cr ]]) asText! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:31' prior: 35186618!loadUpdates	[UIManager default informUser: 'Loading Updates' during: [		map loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/24/2006 14:05' prior: 35186925!noteChanged	filters		ifNil: [^ self reOpen].	map		ifNotNil: [packagesList := nil.			selectedCategory := nil.			self changed: #categoryList.			self changed: #packageList.			self changed: #packagesListIndex.			"update my selection"			self contentsChanged]! !!SMLoaderPlus methodsFor: 'initialization' stamp: 'btr 11/22/2006 16:11' prior: 35187266!on: aSqueakMap 	"Initialize instance."	map := aSqueakMap.	map synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02' prior: 35187543!package: aPackage filteredByCategory: aCategory	"Answer true if the package should be shown	if we filter on <aCategory>. It should be shown	if itself or any of its releases has the category."	| releases |	releases := aPackage releases.	^(aPackage hasCategoryOrSubCategoryOf: aCategory) or: [			releases anySatisfy: [:rel |				rel hasCategoryOrSubCategoryOf: aCategory]]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49' prior: 35187989!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list |	list := packagesList ifNil: [packagesList := self packageListCalculated].	selectedCategory ifNotNil: [		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^ list! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49' prior: 35188459!packageListCalculated	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	^ self packages select: [:p |		filters allSatisfy: [:currFilter |			currFilter isSymbol				ifTrue: [(self perform: currFilter) value: p]				ifFalse: [self package: p filteredByCategory: (map object: currFilter)]]]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50' prior: 35188919!packageNameList	^ self packageList collect: [:e | e name]! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:30' prior: 35189046!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [		choices add: (self commandSpecFor: #installPackageRelease)].	(packageOrRelease isDownloadable and: [packageOrRelease isCached]) ifTrue: [		choices add: (self commandSpecFor: #browseCacheDirectory)].	(packageOrRelease isPackageRelease and: [packageOrRelease isDownloadable]) ifTrue: [		choices add: (self commandSpecFor: #cachePackageReleaseAndOfferToCopy).		choices add: (self commandSpecFor: #downloadPackageRelease)].	choices add: (self commandSpecFor: #emailPackageMaintainers).	^ choices! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 16:11' prior: 35189799!packages	"We request the packages as sorted by name by default."	^map packagesByName asArray! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01' prior: 35189968!packagesListIndex	^ self packageList indexOf: self selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01' prior: 35190105!packagesListIndex: anObject 	self		selectedItem: (anObject = 0				ifFalse: [self packageList at: anObject])! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02' prior: 35190284!packagesMenu: aMenu 	"Answer the packages-list menu."	self selectedPackageOrRelease 		ifNotNil: [aMenu addList: self packageSpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:45' prior: 35190586!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	^ (self respondsTo: selector)		ifTrue: [self perform: selector]		ifFalse: [super perform: selector orSendTo: otherTarget]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/26/2006 23:22' prior: 35191012!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	window delete.	(Smalltalk at: self class name) open! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02' prior: 35191350!removeCategoryFilters	"Remove all category filters."	categoriesToFilterIds := OrderedCollection new! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02' prior: 35191523!removeSelectedCategoryAsFilter	"Remove the filter that filters on the currently selected category."	categoriesToFilterIds remove: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02' prior: 35191751!saveFiltersAsDefault	"Save the current filters as default so that they	are selected the next time the loader is opened."	DefaultFilters := filters copy.	DefaultCategoriesToFilterIds := categoriesToFilterIds copy! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35' prior: 35192040!searchSelection	"Selects all of the default search text so that a type-in overwrites it."	^ {1. self searchText size}! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35' prior: 35192232!searchText	"A dummy default search text so that the field describes its purpose."	^ 'Search packages'! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02' prior: 35192408!selectedCategory	"Return selected category."	^ selectedCategory! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:37' prior: 35192545!selectedCategory: anSMCategory 	"Change the selected category."	selectedCategory := anSMCategory.	selectedCategory		ifNotNil: [(selectedCategory objects includes: self selectedItem)			ifFalse: [self selectedItem: nil]].	self changed: #selectedCategory.	self changed: #packageList! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:52' prior: 35192904!selectedCategoryPath	"Return selected category's path."	| path |	path := #().	selectedCategory		ifNotNil: [selectedCategory parent				ifNotNilDo: [:p | path := path copyWith: p].			path := path copyWith: selectedCategory].	^ path		collect: [:cat | self categoryLabel: cat]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02' prior: 35193258!selectedItem	^ selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:27' prior: 35193358!selectedItem: anItem	"This == workaround protects us from recursion since ToolBuilder's tree widgets will always tell us that the selection has been updated when we tell it that the selection path has been updated. Cleaner solutions invited."	anItem == selectedItem ifFalse: [		selectedItem := anItem.		self changed: #selectedItemPath.		self changed: #itemDescription.		self changed: #hasSelectedItem]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:16' prior: 35193837!selectedItemPath	| path |	path := #().	(selectedItem isKindOf: SMPackageRelease)		ifTrue: [path := path copyWith: selectedItem package].	selectedItem		ifNotNil: [path := path copyWith: selectedItem].	^ path! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:03' prior: 35194123!selectedPackageOrRelease	"Return selected package or package release."	^ selectedItem! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02' prior: 35194290!showFilterString: aFilterSymbol 	^(self stateForFilter: aFilterSymbol), (self labelForFilter: aFilterSymbol)! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02' prior: 35194479!stateForFilter: aFilterSymbol 	^(self filters includes: aFilterSymbol) ifTrue: ['<yes>'] ifFalse: ['<no>']! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02' prior: 35194668!toggleFilterState: aFilterSymbol 	^(self filters includes: (aFilterSymbol)) 		ifTrue: [self filterRemove: aFilterSymbol]		ifFalse: [self filterAdd: aFilterSymbol]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02' prior: 35194905!uncheckFilters	"Uncheck all filters."		filters := OrderedCollection new.	self noteChanged! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50' prior: 35195066!updateLabel: packagesShown	"Update the label of the window."	window ifNotNilDo: [:w | w setLabel: (self labelForShown: packagesShown)]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:29' prior: 35195272!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during: [				map upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02' prior: 35197016!upgradeInstalledPackagesConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. Confirms on each upgrade."	^ self upgradeInstalledPackagesConfirm: true! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:29' prior: 35197294!upgradeInstalledPackagesConfirm: confirmEach 	"Tries to upgrade all installed packages to the latest published release for	this version of Squeak. If confirmEach is true we ask for every	upgrade. "	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty		ifTrue: [^ self inform: 'All ' , installed size printString , ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty		ifTrue: [^ self inform: 'None of the ' , old size printString , ' old packages of the ' , installed size printString , ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size		ifTrue: ['Of the ' , old size printString , ' old packages only ' , toUpgrade size printString , ' can be upgraded.The following packages will not be upgraded:'						, (String								streamContents: [:s | (old removeAll: toUpgrade;										 yourself)										do: [:p | s nextPutAll: p nameWithVersionLabel;												 cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info , 'About to upgrade the following packages:'				, (String						streamContents: [:s | toUpgrade								do: [:p | s nextPutAll: p nameWithVersionLabel;										 cr]]) , 'Proceed?')		ifTrue: [myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during:					[confirmEach						ifTrue: [map								upgradeOldPackagesConfirmBlock: [:p | self confirm: 'Upgrade ' , p installedRelease packageNameWithVersion , ' to ' , (p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName , '?']]						ifFalse: [map upgradeOldPackages].					self inform: toUpgrade size printString , ' packages successfully processed.'.					myRelease = self installedReleaseOfMe						ifTrue: [self noteChanged]						ifFalse: [self reOpen]]]				on: Error				do: [:ex | self informException: ex msg: ('Error occurred when upgrading old packages:\' , ex messageText , '\') withCRs]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02' prior: 35199433!upgradeInstalledPackagesNoConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. No confirmation on each upgrade."	^ self upgradeInstalledPackagesConfirm: false! !!SMLoader commentStamp: 'btr 11/30/2006 18:00' prior: 35199719!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance).You can open one with:	SMLoader open!!SMLoader class methodsFor: 'parts bin' stamp: 'gk 4/5/2005 21:23' prior: 35199955!descriptionForPartsBin	^self partName: 'Package Loader'		categories: #(Tools)		documentation: 'SqueakMap UI'! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 12/1/2006 15:47' prior: 35200168!initialize	"Hook us up in the world menu."	"self initialize"	Smalltalk		at: #ToolBuilder		ifAbsent: [self registerInFlapsRegistry.			(Preferences windowColorFor: #SMLoader) = Color white				ifTrue: ["not set"					Preferences						setWindowColorFor: #SMLoader						to: (Color colorFrom: self windowColorSpecification brightColor)].			(TheWorldMenu respondsTo: #registerOpenCommand:)				ifTrue: [| oldCmds |					oldCmds := TheWorldMenu registry select: [:cmd | cmd first includesSubString: 'Package Loader'].					oldCmds do: [:cmd | TheWorldMenu unregisterOpenCommand: cmd first].					TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoader class methodsFor: 'new-morph participation' stamp: 'gk 4/5/2005 21:21' prior: 35201038!initializedInstance	^self new createWindow extent: 400@400! !!SMLoader class methodsFor: 'instance creation' stamp: 'gk 6/21/2005 10:47' prior: 35201194!new	"Create a SqueakMap loader on the default map."	^self newOn: SMSqueakMap default! !!SMLoader class methodsFor: 'instance creation' stamp: 'gk 6/21/2005 10:47' prior: 35201378!newOn: aMap	"Create a SqueakMap loader on given map."	^super new on: aMap; yourself! !!SMLoader class methodsFor: 'new-morph participation' stamp: 'gk 4/5/2005 21:21' prior: 35201566!newStandAlone	^self new createWindow! !!SMLoader class methodsFor: 'instance creation' stamp: 'gk 6/21/2005 09:28' prior: 35201700!open	"Create and open a SqueakMap Loader."		"SMLoader open"	^self new openAsMorph! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52' prior: 35201872!openMenuString	^ 'SqueakMap Catalog'! !!SMLoader class methodsFor: 'instance creation' stamp: 'gk 4/5/2005 21:18' prior: 35202005!openOn: aSqueakMap	"Create and open a SqueakMap Loader on a given map."	"self openOn: SqueakMap default"	^(self newOn: aSqueakMap) openAsMorph! !!SMLoader class methodsFor: 'new-morph participation' stamp: 'gk 6/21/2005 11:06' prior: 35202255!prototypicalToolWindow	^self new createWindow; applyModelExtent; yourself! !!SMLoader class methodsFor: 'new-morph participation' stamp: 'gk 6/21/2005 10:43' prior: 35202432!registerInFlapsRegistry	"Register the receiver in the system's flaps registry."	self environment		at: #Flaps		ifPresent: [:cl | (cl respondsTo: #registerQuad:forFlapNamed:)				ifTrue: [cl registerQuad: #(#SMLoader #prototypicalToolWindow 'Package Loader' 'The SqueakMap Package Loader' ) forFlapNamed: 'Tools']]! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52' prior: 35202851!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoader class methodsFor: 'window color' stamp: 'gk 6/21/2005 09:44' prior: 35203156!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference."	^WindowColorSpec		classSymbol: self name		wording: 'Package Loader'		brightColor: Color yellow muchLighter duller		pastelColor: Color yellow veryMuchLighter duller		helpMessage: 'The SqueakMap Package Loader'! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:08' prior: 35203541!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/12/2004 14:42' prior: 35204051!addSelectedCategoryAsFilter	"Add a new filter that filters on the currently selected category.	Make it enabled as default."	categoriesToFilterIds add: self selectedCategory id! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:14' prior: 35204311!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := model isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(model directory directoryEntryFor: model lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:15' prior: 35204976!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease ifNil: [^ nil].	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:52' prior: 35205471!buildButtonBar	| aRow btn |	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	self buttonSpecs do: [:spec |		btn := self buildButtonNamed: spec first helpText: spec third action: spec second.		aRow addMorphBack: btn]		separatedBy: [aRow addTransparentSpacerOfSize: 3@0].	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:27' prior: 35205869!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 19:04' prior: 35206285!buildMorphicCategoriesList	"Create the hierarchical list holding the category tree."	| list |	list := (SimpleHierarchicalListMorph				on: self				list: #categoryWrapperList				selected: #selectedCategoryWrapper				changeSelected: #selectedCategoryWrapper:				menu: #categoriesMenu:				keystroke: nil) autoDeselect: true;				 enableDrag: false;				 enableDrop: true;				 yourself.	list setBalloonText: 'The categories are structured in a tree. Packages and package releases belong to several categories.You can add one or more categories as filters and enable them in the menu.'.	"list scroller submorphs do:[:each| list expandAll: each]."	list adjustSubmorphPositions.	^ list! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 00:22' prior: 35207062!buildMorphicPackagesList	"Create the hierarchical list holding the packages and releases."	^(SimpleHierarchicalListMorph 		on: self		list: #packageWrapperList		selected: #selectedItemWrapper		changeSelected: #selectedItemWrapper:		menu: #packagesMenu:		keystroke: nil)		autoDeselect: false;		enableDrag: false;		enableDrop: true;		setBalloonText: 'This shows all packages with their releases that should be displayed according the current filter.';		yourself! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:13' prior: 35207603!buildPackageButtonBar	| aRow |	"Somewhat patterned after IRCe's buttonRow method."	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'gk 5/5/2006 02:05' prior: 35207873!buildPackagePane	"Create the text area to the right in the loader."	| ptm |	ptm := PluggableTextMorph 		on: self 		text: #contents		accept: nil		readSelection: nil "#packageSelection "		menu: nil.	ptm setBalloonText: 'This is where the selected package or package release is displayed.'.	ptm lock.	^ptm! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:08' prior: 35208272!buildSearchPane	"Cribbed from MessageNames>>inMorphicWindowWithInitialSearchString:"	| typeInView searchButton typeInPane |	typeInView := PluggableTextMorph				on: self				text: nil				accept: #findPackage:notifying:				readSelection: nil				menu: nil.	typeInView acceptOnCR: true;		 vResizing: #spaceFill;		 hResizing: #spaceFill;		 setTextMorphToSelectAllOnMouseEnter;		 askBeforeDiscardingEdits: false;		 setProperty: #alwaysAccept toValue: true.	(typeInView respondsTo: #hideScrollBarsIndefinitely)		ifTrue: [typeInView hideScrollBarsIndefinitely]		ifFalse: [typeInView hideScrollBarIndefinitely].	searchButton := SimpleButtonMorph new target: typeInView;				 color: Color white;				 label: 'Search';				 actionSelector: #accept;				 arguments: #(); yourself.	typeInPane := AlignmentMorph newRow.	typeInPane vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 listDirection: #leftToRight;		 addMorphFront: searchButton;		 addTransparentSpacerOfSize: 6 @ 0;		 addMorphBack: typeInView;		 setBalloonText: 'Type into the pane, then press Search (or hit RETURN) to visit the next package matching what you typed.'.	^ typeInPane! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:24' prior: 35209499!buttonSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.')		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.')		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.')		('Update' loadUpdates 'Update the package index from the servers.')		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (confirming each).')		('Help' help 'What is this?'))! !!SMLoader methodsFor: 'actions' stamp: 'gk 5/5/2006 02:05' prior: 35210082!cachePackageReleaseAndOfferToCopy	"Cache package release, then offer to copy it somewhere.	Answer the chosen file's location after copy,	or the cache location if no directory was chosen."	| release installer newDir newName newFile oldFile oldName |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	installer := SMInstaller forPackageRelease: release.	[Cursor wait showWhile: [installer cache]] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs.		^nil ].	installer isCached ifFalse: [self inform: 'Download failed, see transcript for details'. ^nil].	oldName := installer fullFileName.	newDir := FileList2 modalFolderSelector: installer directory.	newDir ifNil: [ ^oldName ].	newDir = installer directory ifTrue: [ ^oldName ].	newName := newDir fullNameFor: installer fileName.	newFile := FileStream newFileNamed: newName.	newFile ifNil: [ ^oldName ].	newFile binary.	oldFile := FileStream readOnlyFileNamed: oldName.	oldFile ifNil: [ ^nil ].	oldFile binary.	[[ newDir copyFile: oldFile toFile: newFile ] ensure: [ oldFile close. newFile close ]] on: Error do: [ :ex | ^oldName ].	^newName! !!SMLoader methodsFor: 'menus' stamp: 'gk 7/10/2004 03:58' prior: 35211462!categoriesMenu: aMenu 	"Answer the categories-list menu."	self selectedCategory 		ifNotNil: [aMenu addList: self categorySpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:11' prior: 35211770!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoader methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01' prior: 35212396!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (model categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list		collect: [:cat | SMCategoryWrapper with: cat model: self]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:45' prior: 35213013!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoader methodsFor: 'private' stamp: 'gk 5/5/2006 02:05' prior: 35213355!contents	| packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	^packageOrRelease		ifNil: ['<No package selected>']		ifNotNil: [packageOrRelease fullDescription]! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 17:30' prior: 35213624!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.3.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0.0 @ 0.0 corner: 1.0 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0.0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (0.0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0.0 @ horizDivide corner: vertDivide @ 1.0).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1.0 @ 1.0).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self! !!SMLoader methodsFor: 'interface' stamp: 'gk 7/12/2004 11:14' prior: 35214583!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:01' prior: 35214814!defaultLabel	^'SqueakMap Package Loader'! !!SMLoader methodsFor: 'actions' stamp: 'gk 5/5/2006 02:05' prior: 35214935!downloadPackageRelease	"Force a download of the selected package release into the cache."	| release |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: release) download]	] on: Error do: [:ex |		| msg | 		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs]! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/22/2006 01:14' prior: 35215497!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:45' prior: 35216169!filterAdd: anObject	self changeFilters: (self filters copyWith: anObject)! !!SMLoader methodsFor: 'filters' stamp: 'dvf 10/25/2002 11:29' prior: 35216328!filterAutoInstall	^[:package | package isInstallable]! !!SMLoader methodsFor: 'filters' stamp: 'gk 7/13/2004 15:28' prior: 35216463!filterAvailable		^[:package | package isAvailable]! !!SMLoader methodsFor: 'filters' stamp: 'dvf 10/25/2002 17:08' prior: 35216598!filterInstalled	^[:package | package isInstalled]! !!SMLoader methodsFor: 'filters' stamp: 'dvf 10/25/2002 17:08' prior: 35216731!filterNotInstalledYet	^[:package | package isInstalled not]! !!SMLoader methodsFor: 'filters' stamp: 'dvf 10/25/2002 17:07' prior: 35216874!filterNotUptoDate		^[:package | package isAvailable]! !!SMLoader methodsFor: 'filters' stamp: 'gk 1/28/2004 23:42' prior: 35217009!filterPublished	^[:package | package isPublished]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:45' prior: 35217149!filterRemove: anObject	self changeFilters: (self filters copyWithout: anObject)! !!SMLoader methodsFor: 'filters' stamp: 'gk 7/13/2004 15:28' prior: 35217312!filterSafelyAvailable		^[:package | package isSafelyAvailable]! !!SMLoader methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 00:14' prior: 35217468!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('Installed packages' #filterInstalled 'Display only packages that are installed.')	#('Published packages' #filterPublished 'Display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'Packages in ', (model object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'filters' stamp: 'gk 7/11/2004 03:02' prior: 35218525!filterVersion	"Ignore spaces in the version string, they're sometimes spurious.	Not used anymore."	^[:package | package categories anySatisfy:  		[:cat | (cat name, '*') match: (Smalltalk version copyWithout: $ ) ]]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:47' prior: 35218836!filters	^filters! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 19:27' prior: 35218936!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or description."	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty ifTrue: [^self].	descriptions _ self packageWrapperList collect: [:e | e withoutListWrapper description].	index + 1 to: list size		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	"wrap around"	1 to: index		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:05' prior: 35219918!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 00:48' prior: 35220289!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by (installed version -> latest version).If there is no arrow, your installed version of the package is the latest.Installed packages and releases are also in bold.The checkbox menu items at the bottom let you modify which packages you''ll see. Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.If you like a package or have comments on it, please contactthe author or the squeak mailing list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://minnow.cc.gatech.edu/squeak/2726' asUrl]! !!SMLoader methodsFor: 'private' stamp: 'gk 7/10/2004 04:04' prior: 35221488!informException: ex msg: msg 	"Tell the user that an error has occurred.	Offer to open debug notifier."	(self confirm: msg, 'Would you like to open a debugger?')		ifTrue: [ex pass]! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/22/2006 01:13' prior: 35221756!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease ifNil: [^ nil].	item isPackageRelease		ifTrue: [			(item isPublished or: [self confirm: 'Selected release is not published yet, install anyway?'])				ifTrue: [^self installPackageRelease: item]]		ifFalse: [			release := item lastPublishedReleaseForCurrentSystemVersion.			release ifNil: [				(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')					ifTrue: [						release := item lastPublishedRelease.						release ifNil: [							(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')								ifTrue: [release := item lastRelease]]]].			release ifNotNil: [^self installPackageRelease: release]]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:41' prior: 35222701!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:25' prior: 35223596!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'filter utilities' stamp: 'dvf 10/25/2002 11:27' prior: 35223883!labelForFilter: aFilterSymbol 	^(self filterSpecs detect: [:fs | fs second = aFilterSymbol]) first! !!SMLoader methodsFor: 'actions' stamp: 'gk 11/18/2003 02:19' prior: 35224064!listInPasteBuffer	"Useful when talking with people etc.	Uses the map to produce a nice String."	Clipboard clipboardText:		(String streamContents: [:s |			packagesList do: [:p |				s nextPutAll: p nameWithVersionLabel; cr ]]) asText! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:12' prior: 35224383!loadUpdates	[Cursor wait showWhile: [		model loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 01:02' prior: 35224669!noteChanged	filters ifNil: [^self reOpen].	model ifNotNil: [		packagesList := nil.		selectedCategoryWrapper := nil.		self changed: #categoryWrapperList.		self changed: #packageWrapperList.		self changed: #packagesListIndex.	"update my selection"		self contentsChanged]! !!SMLoader methodsFor: 'initialization' stamp: 'gk 9/25/2006 23:12' prior: 35225033!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'initialization' stamp: 'gk 4/5/2005 21:17' prior: 35225321!openAsMorph	"Open the loader as a Morphic window."	"SMLoader new openAsMorph"		^self createWindow openInWorld! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/11/2004 22:29' prior: 35225524!package: aPackage filteredByCategory: aCategory	"Answer true if the package should be shown	if we filter on <aCategory>. It should be shown	if itself or any of its releases has the category."	| releases |	releases := aPackage releases.	^(aPackage hasCategoryOrSubCategoryOf: aCategory) or: [			releases anySatisfy: [:rel |				rel hasCategoryOrSubCategoryOf: aCategory]]! !!SMLoader methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45' prior: 35225982!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				(filters ifNil: [#()]) allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNotNil:		[selectedCategory := selectedCategoryWrapper category.		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'lists' stamp: 'dvf 9/21/2003 16:36' prior: 35226776!packageNameList	^self packageWrapperList collect: [:e | e withoutListWrapper name]! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/22/2006 14:30' prior: 35226940!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [		choices add: self buttonSpecs first].	(packageOrRelease isDownloadable and: [packageOrRelease isCached]) ifTrue: [		choices add: self buttonSpecs third].	(packageOrRelease isPackageRelease and: [packageOrRelease isDownloadable]) ifTrue: [		choices add: #('Copy from cache' #cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' ).		choices add: #('Force download into cache' #downloadPackageRelease 'Force a download of the selected release into the cache.' )].	choices add: self buttonSpecs second.	^ choices! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/9/2004 01:36' prior: 35227797!packageWrapperList	"Return the list with each element wrapped so that it	can be used in a SimpleHierarchicalListMorph."	^self packageList collect: [:e | SMPackageWrapper with: e]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/25/2006 23:12' prior: 35228060!packages	"We request the packages as sorted by name by default."	^model packagesByName asArray! !!SMLoader methodsFor: 'accessing' stamp: 'dvf 9/21/2003 16:34' prior: 35228242!packagesListIndex	^self packageWrapperList indexOf: self selectedItemWrapper! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:56' prior: 35228404!packagesListIndex: anObject 	self		selectedItemWrapper: (anObject ifNotNil: [anObject = 0				ifFalse: [self packageWrapperList at: anObject]])! !!SMLoader methodsFor: 'menus' stamp: 'gk 7/9/2004 03:04' prior: 35228627!packagesMenu: aMenu 	"Answer the packages-list menu."	self selectedPackageOrRelease 		ifNotNil: [aMenu addList: self packageSpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoader methodsFor: 'interface' stamp: 'gk 4/5/2005 21:43' prior: 35228939!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!SMLoader methodsFor: 'private' stamp: 'btr 11/26/2006 23:22' prior: 35229379!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	self delete.	(Smalltalk at: self class name) open! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/12/2004 14:42' prior: 35229725!removeCategoryFilters	"Remove all category filters."	categoriesToFilterIds := OrderedCollection new! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/12/2004 14:42' prior: 35229908!removeSelectedCategoryAsFilter	"Remove the filter that filters on the currently selected category."	categoriesToFilterIds remove: self selectedCategory id! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/12/2004 14:42' prior: 35230146!saveFiltersAsDefault	"Save the current filters as default so that they	are selected the next time the loader is opened."	DefaultFilters := filters copy.	DefaultCategoriesToFilterIds := categoriesToFilterIds copy! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 19:17' prior: 35230447!selectedCategory	"Return selected category."	^selectedCategoryWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'accessing' stamp: 'ar 2/9/2004 02:14' prior: 35230640!selectedCategoryWrapper	^selectedCategoryWrapper! !!SMLoader methodsFor: 'accessing' stamp: 'btr 12/1/2006 15:51' prior: 35230773!selectedCategoryWrapper: aWrapper	selectedCategoryWrapper := aWrapper.	(aWrapper notNil and:		[aWrapper withoutListWrapper objects includes: selectedItemWrapper withoutListWrapper])		ifFalse: [self selectedItemWrapper: nil].	self changed: #selectedCategoryWrapper.	self changed: #packageWrapperList.! !!SMLoader methodsFor: 'accessing' stamp: 'dvf 9/21/2003 15:04' prior: 35231162!selectedItemWrapper	^selectedItemWrapper! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/22/2006 19:13' prior: 35231288!selectedItemWrapper: aWrapper	selectedItemWrapper := aWrapper.	self changed: #selectedItemWrapper.	self contentsChanged! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:10' prior: 35231493!selectedPackageOrRelease	"Return selected package or package release."	^self selectedItemWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'filter utilities' stamp: 'dvf 10/25/2002 14:48' prior: 35231724!showFilterString: aFilterSymbol 	^(self stateForFilter: aFilterSymbol), (self labelForFilter: aFilterSymbol)! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:45' prior: 35231923!stateForFilter: aFilterSymbol 	^(self filters includes: aFilterSymbol) ifTrue: ['<yes>'] ifFalse: ['<no>']! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:46' prior: 35232122!toggleFilterState: aFilterSymbol 	^(self filters includes: (aFilterSymbol)) 		ifTrue: [self filterRemove: aFilterSymbol]		ifFalse: [self filterAdd: aFilterSymbol]! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/13/2004 16:05' prior: 35232369!uncheckFilters	"Uncheck all filters."		filters := OrderedCollection new.	self noteChanged! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:02' prior: 35232546!updateLabel: packagesShown	"Update the label of the window."	self setLabel: self defaultLabel , ' (',			(packagesShown size < model packages size ifTrue: [packagesShown size printString,			' shown out of '] ifFalse: ['']) , model packages size printString, ' packages)'! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 21:03' prior: 35232903!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/14/2004 16:29' prior: 35234619!upgradeInstalledPackagesConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. Confirms on each upgrade."	^ self upgradeInstalledPackagesConfirm: true! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:03' prior: 35234910!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/14/2004 16:29' prior: 35236931!upgradeInstalledPackagesNoConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. No confirmation on each upgrade."	^ self upgradeInstalledPackagesConfirm: false! !!SMLoaderCategorical commentStamp: 'btr 12/1/2006 15:16' prior: 35237220!A variant package loader that uses a more-or-less standard Smalltalk-80 browser perspective of selecting categories in one pane and then selecting items within in the next pane.You can open one with:	SMLoaderCategorical open!!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06' prior: 35237538!initialize	Smalltalk at: #ToolBuilder ifAbsent: [	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51' prior: 35237816!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51' prior: 35237950!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51' prior: 35238208!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58' prior: 35238414!buildMorphicInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #installedPackageNameList		selected: #installedPackagesListIndex		changeSelected: #installedPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58' prior: 35238771!buildMorphicNotInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #notInstalledPackageNameList		selected: #notInstalledPackagesListIndex		changeSelected: #notInstalledPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 20:06' prior: 35239140!createFancyWindow	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicNotInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (horizDivide / 2)).	self addMorph: (self buildMorphicInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setUpdatablePanesFrom: #(#installedPackageNameList #notInstalledPackageNameList ).	currentPackageList := #notInstalled.	self setLabel: 'Categorical SqueakMap Package Loader'! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 20:01' prior: 35240535!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setLabel: 'Categorical SqueakMap Package Loader'! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 17:27' prior: 35241550!currentPackageList	^currentPackageList! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'btr 11/30/2006 17:44' prior: 35241669!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 19:14' prior: 35241844!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['No removing yet']! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20' prior: 35242052!installedPackageNameList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58' prior: 35242204!installedPackagesListIndex	self currentPackageList = #installed		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35' prior: 35242402!installedPackagesListIndex: anObject 	packagesListIndex _ anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 15:09' prior: 35242694!isOn	^false! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20' prior: 35242782!notInstalledPackageNameList	^self packageList select: [:e | e isInstalled not]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58' prior: 35242941!notInstalledPackagesListIndex	self currentPackageList = #notInstalled		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35' prior: 35243145!notInstalledPackagesListIndex: anObject 	packagesListIndex _ anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategorical methodsFor: 'private' stamp: 'btr 11/30/2006 20:21' prior: 35243525!noteChanged	self changed: #installedPackageNameList.	self changed: #notInstalledPackageNameList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45' prior: 35243849!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !!FileList2 class methodsFor: '*smloader-override' stamp: 'btr 1/30/2004 00:56' prior: 35244175!morphicView	^ self morphicViewOnDirectory: FileDirectory default! !!FileList2 class methodsFor: '*smloader-extension' stamp: 'gk 5/5/2006 02:05' prior: 35244339!morphicViewOnDirectory: aFileDirectory	| aFileList window fileListBottom midLine fileListTopOffset buttonPane |	aFileList := self new directory: aFileDirectory.	window := (SystemWindow labelled: aFileDirectory pathName) model: aFileList.	fileListTopOffset := (TextStyle defaultFont pointSize * 2) + 14.	fileListBottom := 0.4.	midLine := 0.4.	buttonPane := aFileList optionalButtonRow addMorph:		(aFileList morphicPatternPane vResizing: #spaceFill; yourself).	self addFullPanesTo: window from: {		{buttonPane. 0@0 corner: 1@0. 0@0 corner: 0@fileListTopOffset}.		{aFileList morphicDirectoryTreePane. 0@0 corner: midLine@fileListBottom. 					0@fileListTopOffset corner: 0@0}.		{aFileList morphicFileListPane. midLine @ 0 corner: 1@fileListBottom. 					0@fileListTopOffset corner: 0@0}.		{aFileList morphicFileContentsPane. 0@fileListBottom corner: 1@1. nil}.	}.	aFileList postOpen.	^ window ! !----End fileIn of a stream----!SMDependencyTest removeSelector: #test3!SMDependencyTest removeSelector: #test1!!SMSARInstaller commentStamp: '<historical>' prior: 34992362!I am a SqueakMap installer that knows how to deal with Zip format change-set archives.I recognize them by the file extension ".sar" (Squeak Archive).These have a couple of members with special names:install/preambleinstall/postscriptThese are loaded in order. Either or both can further load other members using fileInMemberNamed:.Inside a postscript or preamble, the pseudo-variable "self" is set to an instance of SARInstaller; you can then get to its ZipArchive using the method "zip". Or you can call its methods for filing in change sets, extracting files, etc.You can test this loading with:(SMSARInstaller new) directory: FileDirectory default; fileName: 'test.sar'; fileIn.See ChangeSet>>fileOutAsZipNamed: for one way to make these files. Here is another way of creating a multi change set archive installable by SqueakMap:"The following doit will create a .sar file with HVs preamble and postscript asseparate entries and the included changesets included as normal.Given a preamble as described below this will autoinstall in SqueakMap."(ChangeSorter changeSetNamed: 'HV')	fileOutAsZipNamed: 'httpview-021023.sar'	including: {		ChangeSorter changeSetNamed: 'HVFixes'.		ChangeSorter changeSetNamed: 'kom412'}Preamble in changeset HV that will install the changesets:"Change Set:		HVDate:			23 October 2002Author:			Göran HultgrenThis is my latest developer code drop of HttpView packaged as a Squeak selfextracting archive (courtesy Ned Konz).""Standard SqueakMap installing code follows:"(self isKindOf: SARInstaller) ifTrue:[	self fileInMemberNamed: 'HVFixes'.	self fileInMemberNamed: 'kom412'.	self fileInMemberNamed: 'HV']!"SMBase"!SMLoader removeSelector: #paneColorOld!SMLoader removeSelector: #addPackagesTo:at:plus:!"SMLoader"!'From Croquet1.0beta of 11 April 2006 [latest update: #2] on 19 January 2009 at 3:07:50 pm'!!MultiByteFileStream methodsFor: 'open/close' stamp: 'kph 2/15/2007 03:18' prior: 25234559!open: fileName forWrite: writeMode 	| result |	result := super open: fileName forWrite: writeMode.	result ifNotNil: [			converter ifNil: [converter := UTF8TextConverter new].			lineEndConvention ifNil: [ self detectLineEndConvention ]	].	^result! !!MultiByteFileStream methodsFor: 'remnant' stamp: 'mtf 1/19/2009 15:06' prior: 25229646!wantsLineEndConversion: aBooleanOrLineEndConvention		wantsLineEndConversion :=  aBooleanOrLineEndConvention ~= false.	aBooleanOrLineEndConvention isSymbol ifTrue: [ lineEndConvention := aBooleanOrLineEndConvention ]						 		  ifFalse: [ self detectLineEndConvention ]. ! !----End fileIn of a stream----!Installer mantis bug: 6086 fix: 'MultiByteFileStream-M6086.2.cs'.!----End fileIn of a stream----!!ProjectLauncher methodsFor: '*installer-launcher' stamp: 'kph 6/6/2008 23:42' prior: 28228354!startUpAfterLogin	| scriptName loader isUrl |	self setupFlaps.	Preferences readDocumentAtStartup ifTrue: [		HTTPClient isRunningInBrowser ifTrue:[			self setupFromParameters.			scriptName := self parameterAt: 'src'.			CodeLoader defaultBaseURL: (self parameterAt: 'Base').		] ifFalse:[			scriptName := (SmalltalkImage current getSystemAttribute: 2) ifNil:[''].			scriptName := [ scriptName convertFromSystemString ] ifError: [ scriptName asString ].			scriptName isEmpty ifFalse:[				"figure out if script name is a URL by itself"				isUrl := (scriptName asLowercase beginsWith:'http://') or:[						(scriptName asLowercase beginsWith:'file://') or:[						(scriptName asLowercase beginsWith:'ftp://')]].				isUrl ifFalse:[					Smalltalk at: scriptName asSymbol					ifPresent: [:launchClass | ^ Launcher newLaunchWith: SmalltalkImage current ].										scriptName := 'file:', (FileDirectory default fullNameFor: scriptName) ]				].		]. ]	ifFalse: [ scriptName := '' ].	scriptName isEmptyOrNil		ifTrue:[^Preferences eToyFriendly ifTrue: [self currentWorld addGlobalFlaps]].	loader := CodeLoader new.	loader loadSourceFiles: (Array with: scriptName).	(scriptName asLowercase endsWith: '.pr') 		ifTrue:[self installProjectFrom: loader]		ifFalse:[loader installSourceFiles].! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'testReporter 3/1/2007 16:09'!initialize 	Smalltalk addToStartUpList: self after: SecurityManager.! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'testReporter 3/1/2007 16:20'!launchFrom: launcher	^self launchWith: launcher getParameters			! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'testReporter 3/1/2007 16:20'!launchHelp"Launcher testLaunch: #('+help')."^'+help,h                  Prints this help text.scripts="<sc.st> <sc2.st>"   Execute smalltalk scripts given by urls.'! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'klc 8/14/2008 14:17'!launchWith: params	params at: 'H' ifPresent: [:v | params at: 'HELP' put: v ].	params at: 'S' ifPresent: [ :v | params at: 'SCRIPTS' put: v ].	params at: 'HELP' ifPresent: [ :v | Script new writeHelp ].	params at: 'SCRIPTS' ifPresent: [:v |		CodeLoader new loadSourceFiles: (Array withAll: (v findTokens: ' ')) ;			installSourceFiles].	^true! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'testReporter 3/1/2007 19:09'!newLaunchWith: arrayOrImage 	^ (self new) 		actionSelector: #launchFrom: ;		image: arrayOrImage;		commandLineClass: self;		begin;		yourself			! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'testReporter 3/1/2007 19:09'!newStartWith: arrayOrImage 	^ (self new) 		actionSelector: #startFrom: ;		image: arrayOrImage;		commandLineClass: self;		begin;		yourself		! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'kph 2/28/2007 01:05'!startFrom: starter	^self startWith: starter getParameters! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:04'!startUp: resuming"we are sent this when starting as an image startup item before autostart"	^ self newStartWith: SmalltalkImage current ! !!Launcher class methodsFor: 'as yet unclassified' stamp: 'kph 9/1/2008 20:22'!startWith: params	params at: 'START' ifPresent: [:v | 		CodeLoader new loadSourceFiles: (Array withAll: (v findTokens: ' ')) ;			installSourceFiles ].	^true! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:05'!actionSelector: aSelector	actionSelector := aSelector! !!Launcher methodsFor: 'public' stamp: 'kph 2/27/2007 18:13'!beFirstTime nextParameterIndex := 3. ! !!Launcher methodsFor: 'as yet unclassified' stamp: 'kph 3/2/2007 16:50'!begin 	nextCommandLineDocument := nil. 		[ self launch: commandLineClass ] 		whileTrue: [ 			commandLineClass := self nextCommandLineClass.			commandLineClass ifNil: [ ^self ] ].		  												! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:05'!classes	^ Smalltalk! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:05'!commandLineClass: aClass	commandLineClass := aClass. 						! !!Launcher methodsFor: 'public' stamp: 'testReporter 3/1/2007 17:28'!getParameters 	"this utility extracts the unprocessed parameters into a dictionary from the typical form:		param1=true param2=''hello world'' +param3 -param4	i.e. items with an = are parameters,	+ gives param3=true	- give param4=false	items without +=- are considered to refer to the next Launch Class or document.	"	| key value parameters item |		parameters := Dictionary new.		parameters at: #document put: commandLineClass. 	[ (item := image getSystemAttribute: nextParameterIndex) isEmptyOrNil] 		whileFalse:[			nextParameterIndex := nextParameterIndex + 1.			item := item readStream.			value := nil.			(item peek = $-) ifTrue: [ value := false. item next  ].			(item peek = $+) ifTrue: [ value := true.  item next  ].			key := item upTo: $=.			value isNil & item atEnd not ifTrue: [ value := item upToEnd ].			value 				ifNotNil: [ parameters at: key asUppercase put: value ] 				ifNil: [ nextCommandLineDocument  := key. 					    ^parameters ].	].		nextCommandLineDocument := nil.	^parameters												! !!Launcher methodsFor: 'public' stamp: 'testReporter 3/1/2007 17:28'!getParametersOldStyle	"this utility extracts the unprocessed parameters into a dictionary from the typical old style form:		KEY value Key2 Value Key3 Value :NextLauncherClass KEY value Key2 value etc.		the ability to specify the next launcher class by beginning a parameter 	with a non letter character has been added.	"	| key value parameters |		parameters := Dictionary new.		parameters at: #document put: commandLineClass. 	[ (key := image getSystemAttribute: nextParameterIndex) isEmptyOrNil] 		whileFalse:[			nextParameterIndex := nextParameterIndex + 1.			key first isLetter ifFalse: [ 				nextCommandLineDocument :=  key copyWithoutFirst. 				^ parameters ].						value := image getSystemAttribute: nextParameterIndex.			nextParameterIndex := nextParameterIndex + 1.						parameters at: key asUppercase put: value. 	].	^parameters												! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:05'!getSystemAttribute: n"this provides the ability for us to be a mock image with startup parameters in our array."	^ mock at: n - 1 ifAbsent: nil! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:06'!image: imageOrMock	image := imageOrMock isCollection  		ifTrue: [ mock := imageOrMock. self ]		ifFalse: [ imageOrMock ] . ! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:06'!initialize	nextParameterIndex := 2! !!Launcher methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:06'!launch: aClass	^ (aClass respondsTo: actionSelector) 		ifTrue: [ aClass perform: actionSelector with: self ]		ifFalse: [ false ]! !!Launcher methodsFor: 'as yet unclassified' stamp: 'kph 2/27/2007 18:47'!nextCommandLineClass				^nextCommandLineDocument ifNotNilDo: [:l | self classes at: l asSymbol ifAbsent: [ nil ] ]	 ! !!Launcher methodsFor: 'reporting' stamp: 'mtf 7/3/2008 15:08'!report: reportSelector for: item on: stream	(item respondsTo: reportSelector) ifFalse: [ ^ stream nextPutAll: 'REPORT UNAVAILABLE'; cr ].	(reportSelector last = $:) ifTrue: [ ^item perform: reportSelector with: stream ].	(item perform: reportSelector) ifNotNilDo: [ :result | 		^result isString			ifTrue: [ stream nextPutAll: result ] 			ifFalse: [ result do: [ :each | stream nextPutAll: each asString; cr ] ] ]! !!Launcher methodsFor: 'reporting' stamp: 'mtf 7/3/2008 15:08'!reportFor: target  	^ self reportFor: target with: self getParameters! !!Launcher methodsFor: 'reporting' stamp: 'mtf 7/3/2008 15:10'!reportFor: target with: params 	| reports dest scriptIO quit |	reports := params at: 'REPORT' ifAbsent: [ ^ self error: 'no report requested' ].	reports := reports findTokens: ' '.	dest := params at: 'TO' ifAbsent: nil.	scriptIO := Script new writeTo: (params at: 'TO' ifAbsent: nil) in: (params at: 'DIR' ifAbsent: '').	reports do: [ : reportSelector |		scriptIO := Script new 			writeTo: (dest ifNotNil: [ dest copyReplaceAll:'*' with: reportSelector]) 			in: (params at: 'DIR' ifAbsent: '').		scriptIO printWith: [ :out | self report: reportSelector asSymbol for: target on: out ] ]. 	quit := params at: 'QUIT' ifAbsent: [ false ].	quit ~= false ifTrue: [ SmalltalkImage current snapshot: false andQuit: true ].	^true! !!Script class methodsFor: 'as yet unclassified' stamp: 'kph 2/27/2007 18:57'!launchFrom: launcher	^self launchWith: launcher getParameters! !!Script class methodsFor: 'as yet unclassified' stamp: 'kph 2/22/2007 16:00'!launchHelp^'eval, e="2+2"            Evaluate code and quit.print, p="2+2"           Evaluate and print result to stdout and quit.-quit                    Remain open after evaluating code'! !!Script class methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:01'!launchWith: params	| script quit |	params at: 'E' ifPresent: [:v | params at: 'EVAL' put: v ].	params at: 'P' ifPresent: [:v | params at: 'PRINT' put: v ].	script := self new.	params at: 'TO' ifPresent: [ :v | script writeTo: v in: (params at: 'DIR' ifAbsent: '')].	params at: 'HELP' ifPresent: [ :v | script writeHelp ].	params at: 'EVAL' ifPresent: [ :v | script evaluate: v ].	params at: 'PRINT' ifPresent: [ :v | script evaluateAndPrint: v ].	quit := params at: 'QUIT' ifAbsent: true.	quit ~= false ifTrue: [ SmalltalkImage current snapshot: false andQuit: true ].	^true! !!Script class methodsFor: 'as yet unclassified' stamp: 'testReporter 3/1/2007 16:23'!startFrom: launcher	^self startWith: launcher getParameters! !!Script class methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:03'!startWith: params	| script |	script := self new.	params at: 'TO' ifPresent: [ :v | script writeTo: v in: (params at: 'DIR' ifAbsent: '')].	params at: 'INIT' ifPresent: [ :v | script evaluate: v ].	params at: 'INITP' ifPresent: [ :v | script evaluateAndPrint: v ].	^true! !!Script methodsFor: 'as yet unclassified' stamp: 'kph 2/15/2007 04:09'!evaluate: code	^Compiler new evaluate: code in: nil to: self.! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 14:49'!evaluateAndPrint: code	self printWith: [ :output | output nextPutAll: (self evaluate: code) asString; cr ]	 ! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 14:50'!initialize	stdout := (MultiByteFileStream new) 		wantsLineEndConversion: #crlf; 		open: '/dev/stdout' forWrite: true.			stderr :=  (MultiByteFileStream new) 		wantsLineEndConversion: #crlf; 		open: '/dev/stderr' forWrite: true. 	 	stdin  := AsyncFile new open: '/dev/stdin' forWrite: false.! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 14:50'!printWith: aBlock	fileout ifNil: [ ^aBlock value: stdout ].	FileStream detectFile: [ dir forceNewFileNamed: fileout ] do: aBlock ! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 14:50'!stderr	^stderr! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 14:51'!stdout	^stdout! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 15:10'!writeHelp	| helps |	helps := SystemNavigation default allImplementorsOf: #launchHelp.	self printWith: [ :output |			helps do: [ :mr | 			output nextPutAll: mr classSymbol; cr; cr.			output nextPutAll: (mr actualClass soleInstance launchHelp); cr; cr ] ]! !!Script methodsFor: 'as yet unclassified' stamp: 'mtf 7/3/2008 14:56'!writeTo: fileName in: directory	fileout := fileName.	dir := FileDirectory on: (FileDirectory default fullNameFor: directory).	dir assureExistence.! !!SmalltalkImage class methodsFor: '*installer-launcher' stamp: 'kph 2/27/2007 18:57'!launchFrom: launcher ^self launchWith: launcher getParameters! !!SmalltalkImage class methodsFor: '*installer-launcher' stamp: 'kph 2/16/2007 10:05'!launchHelp^'+save                    Save imagesave=name.image          Save image with given file name+quit                    Quit squeak'! !!SmalltalkImage class methodsFor: '*installer-launcher' stamp: 'kph 1/18/2008 07:51'!launchWith: params	| saveAs quit resuming |	saveAs := params at: 'SAVE' ifAbsent: false.	quit := params at: 'QUIT' ifAbsent: false.	(saveAs isKindOf: Boolean) 		ifFalse: [				saveAs = 'AUTO' ifTrue: [ saveAs := SystemVersion current version ,'-', Date today yyyymmdd ].							  (saveAs endsWith: FileDirectory imageSuffix) ifFalse: [ saveAs := saveAs, '.', FileDirectory imageSuffix ]. 				  resuming := self current saveAs: saveAs.				  resuming ifTrue: [ ^false ].				  saveAs := false ].		 	resuming := self current snapshot: saveAs andQuit: (quit == true).	 	resuming ifTrue: [ ^false ].	"returning false, stops evaluation of further commandline parameters	 this will be beneficial for image restart"	^ true	! !!SystemNavigation class methodsFor: '*installer-launcher' stamp: 'kph 2/27/2007 19:00'!launchFrom: launcher^launcher reportFor: self default! !!SystemNavigation class methodsFor: '*installer-launcher' stamp: 'kph 2/16/2007 10:01'!launchHelp^'report=method            Execute the query method and print the results to stdout or file.to="*.txt"               Filename or pattern to write report to (default is stdout).'! !!Launcher commentStamp: 'testReporter 3/1/2007 19:06' prior: 0!A Launcher provides squeak with a range of capabilities that are intended to be used from the command line.As a design goal, the startup process can invoke Launcher several times at several points in the startup sequence. In particular 1) below aims to provide a mechanism for getting in to images that are broken in some form, so as to enable a script to be run before morphic has attempted to startup.1) Launcher is registered to handle startup notification after Security managerany class which wishes to provide a service to be usable at this time implements startFrom:2) Launcher is wired in to ProjectLauncher to handle startup notification when squeak is fully initialized. Any class wishing to provide a service to be usable at this time implements launchFrom:#startFrom: and #launchFrom: are called providing a handle to the launcher which may be used to obtain parameters using the desired scheme. a) launcher getParameters . key=value +yes -nob) launcher getParametersOldStyle . key value key2 value2Instance Variables	actionSelector: #startFrom: #launchFrom:	commandLineClass: aClass	image:	the smalltalk image or self if being a mock	mock: the mock array of startup parameters	nextCommandLineDocument: aString	nextParameterIndex:	 anInteger !"Installer-Launcher"!'From Squeak3.10 of 22 July 2007 [latest update: #7159] on 9 June 2008 at 9:29:57 pm'!!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'kph 1/29/2007 00:52' prior: 30260240!saveAs	"Put up the 'saveAs' prompt, obtain a name, and save the image  under that new name."	self saveAs: self getFileNameFromUser! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'kph 2/14/2007 11:06'!saveAs: newName	newName ifNil: [ ^self ].		(SourceFiles at: 2) ifNotNil:		[self closeSourceFiles; "so copying the changes file will always work"			 saveChangesInFileNamed: (self fullNameForChangesNamed: newName)].	^self saveImageInFileNamed: (self fullNameForImageNamed: newName)! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'kph 2/14/2007 11:07' prior: 30262237!saveAsNewVersion	"Save the image/changes using the next available version number."	"SmalltalkImage current saveAsNewVersion"		| newName changesName aName anIndex |	aName := FileDirectory baseNameFor: (FileDirectory default localNameFor: self imageName).	anIndex := aName lastIndexOf: FileDirectory dot asCharacter ifAbsent: [nil].	(anIndex notNil and: [(aName copyFrom: anIndex + 1 to: aName size) isAllDigits])		ifTrue:			[aName := aName copyFrom: 1 to: anIndex - 1].	newName := FileDirectory default nextNameFor: aName extension: FileDirectory imageSuffix.	changesName := self fullNameForChangesNamed: newName.	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"	(FileDirectory default fileOrDirectoryExists: changesName)		ifTrue:			[^ self inform:'There is already .changes file of the desired name,', newName, 'curiously already present, even though there isno corresponding .image file.   Please remedymanually and then repeat your request.'].	^self saveAs: newName! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'mtf 6/9/2008 21:29' prior: 30264102!saveImageInFileNamed: aString	| fullImageName |	fullImageName := (FileDirectory default fullNameFor: aString).	(FileDirectory default directoryNamed:(FileDirectory dirPathFor: fullImageName )) assureExistence.	^self		changeImageNameTo: fullImageName;		closeSourceFiles;		openSourceFiles;  "so SNAPSHOT appears in new changes file"		saveImageSegments;		snapshot: true andQuit: false! !----End fileIn of a stream----!Installer mantis bug: 5851 fix: 'SmalltalkImage-M5851.3.cs'.!----End fileIn of a stream----!Installer new logCR: 'Begin "Operation Level Playing Field"...'.Installer install: 'LPF'.!----End fileIn of a stream----!"self halt." (HTTPSocket httpGet: 'ftp.squeak.org/3.11/bob/LPF.st') readStream fileIn.!"self halt."SystemVersion newVersion: 'Squeak3.9.1-lpf'.SystemVersion current date: '25 February 2009 4:35:49 pm' asTimeStamp.!"self halt." Preferences setPreference: #logTranscriptToFile toValue: false.!----SNAPSHOT----an Array(25 February 2009 4:41:49 pm) 090225-1635_Squeak3.9.1-lpf.image priorSource: 330068!----QUIT/NOSAVE----an Array(25 February 2009 4:41:50 pm) 090225-1635_Squeak3.9.1-lpf.image priorSource: 1810445!