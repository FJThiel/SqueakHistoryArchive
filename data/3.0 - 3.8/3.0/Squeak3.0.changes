'From Squeak3.0 of 4 February 2001 [latest update: #3545] on 18 February 2001 at 1:11:38 am'!!AsynchFilePlugin methodsFor: 'primitives' stamp: 'ar 2/6/2001 14:03'!primitiveAsyncFileOpen: fileName forWrite: writeFlag semaIndex: semaIndex 	| fileNameSize fOop f |	self var: #f declareC: 'AsyncFile *f'.	self primitive: 'primitiveAsyncFileOpen'		parameters: #(String Boolean SmallInteger ).	fileNameSize _ interpreterProxy slotSizeOf: (fileName asOop: String).	(self ioCanOpenAsyncFile: fileName OfSize: fileNameSize Writable: writeFlag)		ifFalse:[^interpreterProxy primitiveFail].	fOop _ interpreterProxy instantiateClass: interpreterProxy classByteArray indexableSize: (self cCode: 'sizeof(AsyncFile)').	f _ self asyncFileValueOf: fOop.	interpreterProxy failed ifFalse: [self cCode: 'asyncFileOpen(f, (int)fileName, fileNameSize, writeFlag, semaIndex)'].	^ fOop! !!AsynchFilePlugin class methodsFor: 'translation' stamp: 'ar 2/6/2001 14:04'!headerFile^'/* Header file for AsynchFile plugin *//* module initialization/shutdown */int asyncFileInit(void);int asyncFileShutdown(void);/*** Experimental Asynchronous File I/O ***/typedef struct {	int			sessionID;	void		*state;} AsyncFile;int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** security traps ***//* following is equivalent ioCanOpenFileOfSize() and should really be handled from there */int ioCanOpenAsyncFileOfSizeWritable(char* fileNameIndex, int fileNameSize, int writeFlag);#ifdef DISABLE_SECURITY#define ioCanOpenAsyncFileOfSizeWritable(index, size, flag) 1#endif'! !!AutoStart class methodsFor: 'class initialization' stamp: 'ar 2/6/2001 17:12'!initialize	"AutoStart initialize"	Smalltalk addToStartUpList: AutoStart after: SecurityManager.! !I am a conversion utility for reading X11 Bitmap Distribution Format fonts.  My code is derived from the multilingual Squeak changeset written by OHSHIMA Yoshiki (ohshima@is.titech.ac.jp), although all support for fonts with more than 256 glyphs has been ripped out.  See http://www.is.titech.ac.jp/~ohshima/squeak/squeak-multilingual-e.html .My class methods contain tools for fetching BDF source files from a well-known archive site, batch conversion to Squeak's .sf2 format, and installation of these fonts as TextStyles.  Also, the legal notices for the standard 75dpi fonts I process this way are included as "x11FontLegalNotices'.!!BDFFontReader methodsFor: 'as yet unclassified' stamp: 'nop 1/18/2000 19:45'!errorFileFormat	self error: 'malformed bdf format'! !!BDFFontReader methodsFor: 'as yet unclassified' stamp: 'nop 1/18/2000 19:46'!errorUnsupported	self error: 'unsupported bdf'! !!BDFFontReader methodsFor: 'as yet unclassified' stamp: 'nop 1/18/2000 19:43'!getLine	^self upTo: Character cr.! !!BDFFontReader methodsFor: 'as yet unclassified' stamp: 'nop 1/18/2000 19:44'!initialize	properties _ Dictionary new.! !!BDFFontReader methodsFor: 'as yet unclassified' stamp: 'nop 1/23/2000 18:58'!read	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx array width blt lastAscii pointSize ret dwidth cell cellBlt |	form _ encoding _ bbx _ nil.	self initialize.	self readAttributes.	height _ Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent _ Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent _ Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	pointSize _ (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.		maxWidth _ 0.	minAscii _ 9999.	strikeWidth _ 0.	maxAscii _ 0.	charsNum _ Integer readFromString: (properties at: #CHARS) first.	chars _ Set new: charsNum.	1 to: charsNum do: [:i |		array _ self readOneCharacter.		form _ array at: 1.		encoding _ array at: 2.		bbx _ array at: 3.		dwidth _ array at: 4.		"form isNil ifFalse: [form morphEdit]."		"self halt."				form ifNotNil: [			dwidth _ dwidth - 1.			width _ dwidth max: (bbx at: 1).			maxWidth _ maxWidth max: width.			minAscii _ minAscii min: encoding.			maxAscii _ maxAscii max: encoding.			strikeWidth _ strikeWidth + width.			chars add: array.		].	].	chars _ chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum _ chars size. "undefined encodings make this different"	xTable _ (Array new: 258) atAllPut: 0.	glyphs _ Form extent: strikeWidth@height.	blt _ BitBlt toForm: glyphs.	lastAscii _ 0.		1 to: charsNum do: [:i | 		| unspliceArray |		unspliceArray _ chars at: i.		form _ unspliceArray at: 1.		encoding _ unspliceArray at: 2.		bbx _ unspliceArray at: 3.		dwidth _ (unspliceArray at: 4).		width _ dwidth max: (bbx at: 1).		lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].		"I should be able to do all of this in one blit, but I'm too confused.  Create		a Form of the proper size for this glyph, render the BDF bitmap into it, then 		stamp it into the StrikeFont glyphs form."		cell _ Form extent: width@height.		cellBlt _ BitBlt toForm: cell.		cellBlt copy: ((bbx at: 3)@((ascent - (bbx at: 2) - (bbx at: 4)))				extent: (bbx at: 1)@(bbx at: 2))			from: 0@0 in: form.		blt copyForm: cell to: (xTable at: encoding+1)@0 rule: Form over.				"blt copy: (( ((xTable at: encoding+1)+(bbx at: 3))@(ascent - (bbx at: 2) - (bbx at: 4)))				extent: (bbx at: 1)@(bbx at: 2))			from: 0@0 in: form."		xTable at: encoding+2 put: (xTable at: encoding+1)+(width).		lastAscii _ encoding.	].	ret _ Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!BDFFontReader methodsFor: 'as yet unclassified' stamp: 'nop 1/18/2000 19:44'!readAttributes	| str a |	"I don't handle double-quotes correctly, but it works"	self reset.	[self atEnd] whileFalse: [		str _ self getLine.		(str beginsWith: 'STARTCHAR') ifTrue: [self skip: (0 - str size - 1). ^self].		a _ str substrings.		properties at: a first asSymbol put: a allButFirst.	].	self error: 'file seems corrupted'.! !!BDFFontReader methodsFor: 'as yet unclassified' stamp: 'nop 1/22/2000 23:33'!readOneCharacter	| str a encoding bbx form bits hi low pos char dwidth |	((str _ self getLine) beginsWith: 'STARTCHAR') ifFalse: [self errorFileFormat].	char _ str substrings second.	((str _ self getLine) beginsWith: 'ENCODING') ifFalse: [self errorFileFormat].	encoding _ Integer readFromString: str substrings second.	(self getLine beginsWith: 'SWIDTH') ifFalse: [self errorFileFormat].	((str _ self getLine) beginsWith: 'DWIDTH') ifFalse: [self errorFileFormat].	dwidth _ Integer readFromString: str substrings second.		((str _ self getLine) beginsWith: 'BBX') ifFalse: [self errorFileFormat].	a _ str substrings.	bbx _ (2 to: 5) collect: [:i | Integer readFromString: (a at: i)].	((str _ self getLine) beginsWith: 'ATTRIBUTES') ifTrue: [str _ self getLine].	(str beginsWith: 'BITMAP') ifFalse: [self errorFileFormat].	form _ Form extent: (bbx at: 1)@(bbx at: 2).	bits _ form bits.	pos _ 0.	1 to: (bbx at: 2) do: [:t |		1 to: (((bbx at: 1) - 1) // 8 + 1) do: [:i |			hi _ (('0123456789ABCDEF' indexOf: (self next asUppercase)) - 1) bitShift: 4.			low _ ('0123456789ABCDEF' indexOf: (self next asUppercase)) - 1.						bits byteAt: (pos+i) put: (hi+low).		].		self next ~= Character cr ifTrue: [self errorFileFormat].		pos _ pos + ((((bbx at: 1) + 31) // 32) * 4).	].	(self getLine beginsWith: 'ENDCHAR') ifFalse: [self errorFileFormat].	encoding < 0 ifTrue: [^{nil. nil. nil. nil}].	^{form. encoding. bbx. dwidth}.! !!BDFFontReader class methodsFor: 'file creation' stamp: 'nop 1/23/2000 19:00'!convertFilesNamed: fileName toFamilyNamed: familyName inDirectoryNamed: dirName		"BDFFontReader convertFilesNamed: 'helvR' toFamilyNamed: 'Helvetica' inDirectoryNamed: '' "	"This utility converts X11 BDF font files to Squeak .sf2 StrikeFont files."	"For this utility to work as is, the BDF files must be named 'familyNN.bdf',	and must reside in the directory named by dirName (use '' for the current directory).	The output StrikeFont files will be named familyNN.sf2, and will be placed in the	current directory."	| f allFontNames sizeChars dir |	"Check for matching file names."	dir _ dirName isEmpty		ifTrue: [FileDirectory default]		ifFalse: [FileDirectory default directoryNamed: dirName].	allFontNames _ dir fileNamesMatching: fileName , '##.bdf'.	allFontNames isEmpty ifTrue: [^ self error: 'No files found like ' , fileName , 'NN.bdf'].		Utilities informUserDuring: [:info |		allFontNames do: [:fname | 			info value: 'Converting ', familyName, ' BDF file ', fname, ' to SF2 format'.			sizeChars _ (fname copyFrom: fileName size + 1 to: fname size) copyUpTo: $. .			f _ StrikeFont new readBDFFromFile: (dir fullNameFor: fname) name: familyName, sizeChars.			f writeAsStrike2named: familyName, sizeChars, '.sf2'.		].	]! !!BDFFontReader class methodsFor: 'resource download' stamp: 'nop 1/23/2000 18:43'!convertX11FontsToStrike2  "BDFFontReader convertX11FontsToStrike2"	"Given a set of standard X11 BDF font files (probably downloaded via BDFFontReader downloadFonts), produce .sf2 format fonts.  The source and destination directory is the current directory."	"Charter currently tickles a bug in the BDF parser.  Skip it for now."	"self convertFilesNamed: 'charR' toFamilyNamed: 'Charter' inDirectoryNamed: ''."	self convertFilesNamed: 'courR' toFamilyNamed: 'Courier' inDirectoryNamed: ''.	self convertFilesNamed: 'helvR' toFamilyNamed: 'Helvetica' inDirectoryNamed: ''.	self convertFilesNamed: 'lubR' toFamilyNamed: 'LucidaBright' inDirectoryNamed: ''.	self convertFilesNamed: 'luRS' toFamilyNamed: 'Lucida' inDirectoryNamed: ''.	self convertFilesNamed: 'lutRS' toFamilyNamed: 'LucidaTypewriter' inDirectoryNamed: ''.	self convertFilesNamed: 'ncenR' toFamilyNamed: 'NewCenturySchoolbook' inDirectoryNamed: ''.	self convertFilesNamed: 'timR' toFamilyNamed: 'TimesRoman' inDirectoryNamed: ''.! !!BDFFontReader class methodsFor: 'resource download' stamp: 'nop 2/11/2001 00:24'!downloadFonts  "BDFFontReader downloadFonts"	"Download a standard set of BDF sources from x.org.  	The combined size of these source files is around 1.2M; after conversion 	to .sf2 format they may be deleted."	| heads tails filenames baseUrl basePath newUrl newPath document f |	heads _ #( 'charR' 'courR' 'helvR' 'lubR' 'luRS' 'lutRS' 'ncenR' 'timR' ).	tails _ #( '08' '10' '12' '14' '18' '24').	filenames _ OrderedCollection new.	heads do: [:head |		filenames addAll: (tails collect: [:tail | head , tail , '.bdf'])	].	baseUrl _ Url absoluteFromText: 'http://ftp.x.org/pub/R6.4/xc/fonts/bdf/75dpi/'.	basePath _ baseUrl path.	filenames do: [:filename |		newUrl _ baseUrl clone.		newPath _ OrderedCollection newFrom: basePath.		newPath addLast: filename.		newUrl path: newPath.		Utilities informUser: 'Fetching ' , filename during: 			[document _ newUrl retrieveContents].		f _ CrLfFileStream newFileNamed: filename.		f nextPutAll: document content.		f close.	].! !!BDFFontReader class methodsFor: 'resource download' stamp: 'nop 1/23/2000 18:44'!installX11Fonts "BDFFontReader installX11Fonts"	"Installs previously-converted .sf2 fonts into the TextConstants dictionary.  This makes them available as TextStyles everywhere in the image."	| families fontArray textStyle |	families _ #( 'Courier' 'Helvetica' 'LucidaBright' 'Lucida' 'LucidaTypewriter' 'NewCenturySchoolbook' 'TimesRoman' ).	families do: [:family |		fontArray _ StrikeFont readStrikeFont2Family: family.		textStyle _ TextStyle fontArray: fontArray.		TextConstants at: family asSymbol put: textStyle.	].! !!BDFFontReader class methodsFor: 'documentation' stamp: 'nop 2/11/2001 00:22'!gettingAndInstallingTheFonts	"Download the 1.3M of BDF font source files from x.org:		BDFFontReader downloadFonts.	Convert them to .sf2 StrikeFont files:		BDFFontReader convertX11FontsToStrike2.	Install them into the system as TextStyles:		BDFFontReader installX11Fonts.	Read the legal notices in 'BDFFontReader x11FontLegalNotices' before	redistributing images containing these fonts."! !!BDFFontReader class methodsFor: 'documentation' stamp: 'nop 1/23/2000 18:30'!x11FontLegalNotices	^ 'The X11 BDF fonts contain copyright and license information as comments in thefont source code.  For the font family files "cour" (Courier), "helv" (Helvetica), "ncen" (New Century Schoolbook), and "tim" (Times Roman) the notice reads:COMMENT  Copyright 1984-1989, 1994 Adobe Systems Incorporated.COMMENT  Copyright 1988, 1994 Digital Equipment Corporation.COMMENTCOMMENT  Adobe is a trademark of Adobe Systems Incorporated which may beCOMMENT  registered in certain jurisdictions.COMMENT  Permission to use these trademarks is hereby granted only inCOMMENT  association with the images described in this file.COMMENTCOMMENT  Permission to use, copy, modify, distribute and sell this softwareCOMMENT  and its documentation for any purpose and without fee is herebyCOMMENT  granted, provided that the above copyright notices appear in allCOMMENT  copies and that both those copyright notices and this permissionCOMMENT  notice appear in supporting documentation, and that the names ofCOMMENT  Adobe Systems and Digital Equipment Corporation not be used inCOMMENT  advertising or publicity pertaining to distribution of the softwareCOMMENT  without specific, written prior permission.  Adobe Systems andCOMMENT  Digital Equipment Corporation make no representations about theCOMMENT  suitability of this software for any purpose.  It is provided "asCOMMENT  is" without express or implied warranty.For the font family files "char" (Charter), the notice reads:COMMENT  Copyright 1988 Bitstream, Inc., Cambridge, Massachusetts, USACOMMENT  Bitstream and Charter are registered trademarks of Bitstream, Inc.COMMENT  COMMENT  The names "Bitstream" and "Charter" are registered trademarks ofCOMMENT  Bitstream, Inc.  Permission to use these trademarks is herebyCOMMENT  granted only in association with the images described in this file.COMMENT  COMMENT  Permission to use, copy, modify, and distribute this software andCOMMENT  its documentation for any purpose and without fee is herebyCOMMENT  granted, provided that the above copyright notice appear in allCOMMENT  copies and that both that copyright notice and this permissionCOMMENT  notice appear in supporting documentation, and that the name ofCOMMENT  Bitstream not be used in advertising or publicity pertaining toCOMMENT  distribution of the software without specific, written priorCOMMENT  permission.  Bitstream makes no representations about theCOMMENT  suitability of this software for any purpose.  It is provided "asCOMMENT  is" without express or implied warranty.COMMENT  COMMENT  BITSTREAM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,COMMENT  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, INCOMMENT  NO EVENT SHALL BITSTREAM BE LIABLE FOR ANY SPECIAL, INDIRECT ORCOMMENT  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSSCOMMENT  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,COMMENT  NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR INCOMMENT  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.For the font family files "lu" (Lucida), "lub" (Lucida Bright), and "lut" (Lucida Typewriter),the notice reads:COMMENT  (c) Copyright Bigelow & Holmes 1986, 1985. Lucida is a registeredCOMMENT  trademark of Bigelow & Holmes. See LEGAL NOTICE file for terms COMMENT  of the license. The LEGAL NOTICE contains:This is the LEGAL NOTICE pertaining to the Lucida fonts from Bigelow & Holmes:	NOTICE TO USER: The source code, including the glyphs or icons 	forming a par of the OPEN LOOK TM Graphic User Interface, on this 	tape and in these files is copyrighted under U.S. and international	laws. Sun Microsystems, Inc. of Mountain View, California owns	the copyright and has design patents pending on many of the icons. 	AT&T is the owner of the OPEN LOOK trademark associated with the	materials on this tape. Users and possessors of this source code 	are hereby granted a nonexclusive, royalty-free copyright and 	design patent license to use this code in individual and 	commercial software. A royalty-free, nonexclusive trademark	license to refer to the code and output as "OPEN LOOK" compatible 	is available from AT&T if, and only if, the appearance of the 	icons or glyphs is not changed in any manner except as absolutely	necessary to accommodate the standard resolution of the screen or	other output device, the code and output is not changed except as 	authorized herein, and the code and output is validated by AT&T. 	Bigelow & Holmes is the owner of the Lucida (R) trademark for the	fonts and bit-mapped images associated with the materials on this 	tape. Users are granted a royalty-free, nonexclusive license to use	the trademark only to identify the fonts and bit-mapped images if, 	and only if, the fonts and bit-mapped images are not modified in any	way by the user. 	Any use of this source code must include, in the user documentation 	and internal comments to the code, notices to the end user as  	follows:	(c) Copyright 1989 Sun Microsystems, Inc. Sun design patents	pending in the U.S. and foreign countries. OPEN LOOK is a 	trademark of AT&T. Used by written permission of the owners. 	(c) Copyright Bigelow & Holmes 1986, 1985. Lucida is a registered 	trademark of Bigelow & Holmes. Permission to use the Lucida 	trademark is hereby granted only in association with the images 	and fonts described in this file.	SUN MICROSYSTEMS, INC., AT&T, AND BIGELOW & HOLMES 	MAKE NO REPRESENTATIONS ABOUT THE SUITABILITY OF 	THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" 	WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND. 	SUN  MICROSYSTEMS, INC., AT&T AND BIGELOW  & HOLMES, 	SEVERALLY AND INDIVIDUALLY, DISCLAIM ALL WARRANTIES 	WITH REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A	PARTICULAR PURPOSE. IN NO EVENT SHALL SUN MICROSYSTEMS,	INC., AT&T OR BIGELOW & HOLMES BE LIABLE FOR ANY	SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,	OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA 		OR PROFITS, WHETHER IN AN ACTION OF  CONTRACT, NEGLIGENCE	OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION	WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.'.! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'ls 2/10/2001 13:26'!mimeEncode	"Convert from data to 6 bit characters."	| phase1 phase2 raw nib lineLength |	phase1 _ phase2 _ false.	lineLength := 0.	[dataStream atEnd] whileFalse: [		lineLength >= 70 ifTrue: [ mimeStream cr.  lineLength := 0. ].		data _ raw _ dataStream next asInteger.		nib _ (data bitAnd: 16rFC) bitShift: -2.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw _ dataStream next) ifNil: [raw _ 0. phase1 _ true].		data _ ((data bitAnd: 3) bitShift: 8) + raw asInteger.		nib _ (data bitAnd: 16r3F0) bitShift: -4.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw _ dataStream next) ifNil: [raw _ 0. phase2 _ true].		data _ ((data bitAnd: 16rF) bitShift: 8) + (raw asInteger).		nib _ (data bitAnd: 16rFC0) bitShift: -6.		mimeStream nextPut: (ToCharTable at: nib+1).		nib _ (data bitAnd: 16r3F).		mimeStream nextPut: (ToCharTable at: nib+1).		lineLength := lineLength + 4.].	phase1 ifTrue: [mimeStream skip: -2; nextPut: $=; nextPut: $=.			^ mimeStream].	phase2 ifTrue: [mimeStream skip: -1; nextPut: $=.			^ mimeStream].! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'hg 2/2/2001 15:23'!partitionedMul: word1 with: word2 nBits: nBits nPartitions: nParts	"Multiply word1 with word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors.	Bug in loop version when non-white background"	| sMask product result dMask |	sMask _ maskTable at: nBits.  "partition mask starts at the right"	dMask _  sMask << nBits.	result _ (((word1 bitAnd: sMask)+1) * ((word2 bitAnd: sMask)+1) - 1 				bitAnd: dMask) >> nBits.	"optimized first step"	product _ (((word1>>nBits bitAnd: sMask)+1) * ((word2>>nBits bitAnd: sMask)+1) - 1 bitAnd: dMask).	result _ result bitOr: (product bitAnd: dMask).	product _ (((word1>>(2*nBits) bitAnd: sMask)+1) * ((word2>>(2*nBits) bitAnd: sMask)+1) - 1 bitAnd: dMask).	result _ result bitOr: (product bitAnd: dMask) << nBits.	^ result"	| sMask product result dMask |	sMask _ maskTable at: nBits.  'partition mask starts at the right'	dMask _  sMask << nBits.	result _ (((word1 bitAnd: sMask)+1) * ((word2 bitAnd: sMask)+1) - 1 				bitAnd: dMask) >> nBits.	'optimized first step'	nBits to: nBits * (nParts-1) by: nBits do: [:ofs |		product _ (((word1>>ofs bitAnd: sMask)+1) * ((word2>>ofs bitAnd: sMask)+1) - 1 bitAnd: dMask).		result _ result bitOr: (product bitAnd: dMask) << (ofs-nBits)].	^ result"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'hg 8/24/2000 14:41'!rgbMul: sourceWord with: destinationWord	self inline: false.	destPixSize < 16 ifTrue:		["Mul each pixel separately"		^ self partitionedMul: sourceWord with: destinationWord						nBits: destPixSize nPartitions: pixPerWord].	destPixSize = 16 ifTrue:		["Mul RGB components of each pixel separately"		^ (self partitionedMul: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMul: sourceWord>>16 with: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Mul RGB components of the pixel separately"		^ self partitionedMul: sourceWord with: destinationWord						nBits: 8 nPartitions: 3]"	| scanner |	Display repaintMorphicDisplay.	scanner _ DisplayScanner quickPrintOn: Display.	MessageTally time: [0 to: 760 by: 4 do:  [:y |scanner drawString: 'qwrepoiuasfd=)(/&()=#!!¡lkjzxv.,mn124+09857907QROIYTOAFDJZXNBNB,M-.,Mqwrepoiuasfd=)(/&()=#!!¡lkjzxv.,mn124+09857907QROIYTOAFDJZXNBNB,M-.,M1234124356785678' at: 0@y]]. "! !!BitBltSimulation methodsFor: 'translation support' stamp: 'hg 1/29/2001 17:03'!initBBOpTable	self cCode: 'opTable[0+1] = (int)clearWordwith'.	self cCode: 'opTable[1+1] = (int)bitAndwith'.	self cCode: 'opTable[2+1] = (int)bitAndInvertwith'.	self cCode: 'opTable[3+1] = (int)sourceWordwith'.	self cCode: 'opTable[4+1] = (int)bitInvertAndwith'.	self cCode: 'opTable[5+1] = (int)destinationWordwith'.	self cCode: 'opTable[6+1] = (int)bitXorwith'.	self cCode: 'opTable[7+1] = (int)bitOrwith'.	self cCode: 'opTable[8+1] = (int)bitInvertAndInvertwith'.	self cCode: 'opTable[9+1] = (int)bitInvertXorwith'.	self cCode: 'opTable[10+1] = (int)bitInvertDestinationwith'.	self cCode: 'opTable[11+1] = (int)bitOrInvertwith'.	self cCode: 'opTable[12+1] = (int)bitInvertSourcewith'.	self cCode: 'opTable[13+1] = (int)bitInvertOrwith'.	self cCode: 'opTable[14+1] = (int)bitInvertOrInvertwith'.	self cCode: 'opTable[15+1] = (int)destinationWordwith'.	self cCode: 'opTable[16+1] = (int)destinationWordwith'.	self cCode: 'opTable[17+1] = (int)destinationWordwith'.	self cCode: 'opTable[18+1] = (int)addWordwith'.	self cCode: 'opTable[19+1] = (int)subWordwith'.	self cCode: 'opTable[20+1] = (int)rgbAddwith'.	self cCode: 'opTable[21+1] = (int)rgbSubwith'.	self cCode: 'opTable[22+1] = (int)OLDrgbDiffwith'.	self cCode: 'opTable[23+1] = (int)OLDtallyIntoMapwith'.	self cCode: 'opTable[24+1] = (int)alphaBlendwith'.	self cCode: 'opTable[25+1] = (int)pixPaintwith'.	self cCode: 'opTable[26+1] = (int)pixMaskwith'.	self cCode: 'opTable[27+1] = (int)rgbMaxwith'.	self cCode: 'opTable[28+1] = (int)rgbMinwith'.	self cCode: 'opTable[29+1] = (int)rgbMinInvertwith'.	self cCode: 'opTable[30+1] = (int)alphaBlendConstwith'.	self cCode: 'opTable[31+1] = (int)alphaPaintConstwith'.	self cCode: 'opTable[32+1] = (int)rgbDiffwith'.	self cCode: 'opTable[33+1] = (int)tallyIntoMapwith'.	self cCode: 'opTable[34+1] = (int)alphaBlendScaledwith'.	self cCode: 'opTable[35+1] = (int)alphaBlendScaledwith'.	self cCode: 'opTable[36+1] = (int)alphaBlendScaledwith'.		self cCode: 'opTable[37+1] = (int)rgbMulwith'.! !!BitBltSimulation methodsFor: 'primitives' stamp: 'yo 2/14/2001 12:43'!primitiveDisplayString	| kernDelta xTable glyphMap stopIndex startIndex sourceString bbObj maxGlyph ascii glyphIndex sourcePtr left |	self export: true.	self var: #sourcePtr type: 'unsigned char *'.	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	kernDelta _ interpreterProxy stackIntegerValue: 0.	xTable _ interpreterProxy stackObjectValue: 1.	glyphMap _ interpreterProxy stackObjectValue: 2.	((interpreterProxy fetchClassOf: xTable) = interpreterProxy classArray and:[		(interpreterProxy fetchClassOf: glyphMap) = interpreterProxy classArray])			ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: glyphMap) = 256 ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy failed ifTrue:[^nil].	maxGlyph _ (interpreterProxy slotSizeOf: xTable) - 2.	stopIndex _ interpreterProxy stackIntegerValue: 3.	startIndex _ interpreterProxy stackIntegerValue: 4.	sourceString _ interpreterProxy stackObjectValue: 5.	(interpreterProxy isBytes: sourceString) ifFalse:[^interpreterProxy primitiveFail].	(startIndex > 0 and:[stopIndex > 0 and:[		stopIndex <= (interpreterProxy byteSizeOf: sourceString)]])			ifFalse:[^interpreterProxy primitiveFail].	bbObj _ interpreterProxy stackObjectValue: 6.	(self loadBitBltFrom: bbObj) ifFalse:[^interpreterProxy primitiveFail].	left _ destX.	sourcePtr _ interpreterProxy firstIndexableField: sourceString.	startIndex to: stopIndex do:[:charIndex|		ascii _ interpreterProxy byteAt: sourcePtr + charIndex - 1.		glyphIndex _ interpreterProxy fetchInteger: ascii ofObject: glyphMap.		(glyphIndex < 0 or:[glyphIndex > maxGlyph]) 			ifTrue:[^interpreterProxy primitiveFail].		sourceX _ interpreterProxy fetchInteger: glyphIndex ofObject: xTable.		width _ (interpreterProxy fetchInteger: glyphIndex+1 ofObject: xTable) - sourceX.		interpreterProxy failed ifTrue:[^nil].		self clipRange.	"Must clip here"		(bbW > 0 and:[bbH > 0]) ifTrue: [self copyBits].		interpreterProxy failed ifTrue:[^nil].		destX _ destX + width + kernDelta.	 ].	affectedL _ left.	self showDisplayBits.	interpreterProxy pop: 6. "pop args, return rcvr"! !!BitBltSimulation class methodsFor: 'initialization' stamp: 'hg 1/29/2001 17:02'!initializeRuleTable	"BitBltSimulation initializeRuleTable"	"**WARNING** You MUST change initBBOpTable if you change this"	OpTable _ #(		"0" clearWord:with:		"1" bitAnd:with:		"2" bitAndInvert:with:		"3" sourceWord:with:		"4" bitInvertAnd:with:		"5" destinationWord:with:		"6" bitXor:with:		"7" bitOr:with:		"8" bitInvertAndInvert:with:		"9" bitInvertXor:with:		"10" bitInvertDestination:with:		"11" bitOrInvert:with:		"12" bitInvertSource:with:		"13" bitInvertOr:with:		"14" bitInvertOrInvert:with:		"15" destinationWord:with:		"16" destinationWord:with: "unused - was old paint"		"17" destinationWord:with: "unused - was old mask"		"18" addWord:with:		"19" subWord:with:		"20" rgbAdd:with:		"21" rgbSub:with:		"22" OLDrgbDiff:with:		"23" OLDtallyIntoMap:with:		"24" alphaBlend:with:		"25" pixPaint:with:		"26" pixMask:with:		"27" rgbMax:with:		"28" rgbMin:with:		"29" rgbMinInvert:with:		"30" alphaBlendConst:with:		"31" alphaPaintConst:with:		"32" rgbDiff:with:		"33" tallyIntoMap:with:		"34" alphaBlendScaled:with:		"35" alphaBlendScaled:with:	"unused here - only used by FXBlt"		"36" alphaBlendScaled:with:	"unused here - only used by FXBlt"		"37" rgbMul:with:	).	OpTableSize _ OpTable size + 1.  "0-origin indexing"! !!BitBltSimulation class methodsFor: 'translation' stamp: 'hg 2/2/2001 14:36'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'opTable'		declareC: 'int opTable[' , OpTableSize printString , ']'.	aCCodeGenerator var: 'maskTable'		declareC:'int maskTable[33] = {0, 1, 3, 0, 15, 31, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 65535,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}'.	aCCodeGenerator var: 'ditherMatrix4x4'		declareC:'const int ditherMatrix4x4[16] = {0,	8,	2,	10,12,	4,	14,	6,3,	11,	1,	9,15,	7,	13,	5}'.	aCCodeGenerator var: 'ditherThresholds16'		declareC:'const int ditherThresholds16[8] = { 0, 2, 4, 6, 8, 12, 14, 16 }'.	aCCodeGenerator var: 'ditherValues16'		declareC:'const int ditherValues16[32] = {0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}'.	aCCodeGenerator var: 'warpBitShiftTable'		declareC:'int warpBitShiftTable[32]'.! !!BitBltSimulator methodsFor: 'as yet unclassified' stamp: 'hg 2/2/2001 14:15'!initBBOpTable	opTable _ OpTable.	maskTable _ Array new: 32.	#(1 2 4 5 8 16 32) do:[:i| maskTable at: i put: (1 << i)-1].	self initializeDitherTables.	warpBitShiftTable _ CArrayAccessor on: (Array new: 32).! !!BlockNode methodsFor: 'tiles' stamp: 'RAA 2/16/2001 09:08'!asMorphicSyntaxIn: parent	^parent 		blockNode: self 		arguments: arguments 		statements: statements! !!Browser methodsFor: 'class list' stamp: 'nk 2/13/2001 13:26'!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className |	classListIndex _ anInteger.	self setClassOrganizer.	messageCategoryListIndex _ 1.	messageListIndex _ 0.	self classCommentIndicated		ifTrue: []		ifFalse: [editSelection _ anInteger = 0					ifTrue: [metaClassIndicated | (systemCategoryListIndex == 0)						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass]].	contents _ nil.	self selectedClass isNil		ifFalse: [className _ self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self contentsChanged! !!Browser methodsFor: 'initialize-release' stamp: 'RAA 2/9/2001 16:36'!buildMorphicClassList	| myClassList |	(myClassList _ PluggableListMorph new) 			setProperty: #highlightSelector toValue: #highlightClassList:with:;			on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu:shifted: keystroke: #classListKey:from:.	myClassList borderWidth: 0.	myClassList enableDragNDrop: Preferences browseWithDragNDrop.	^myClassList! !!Browser methodsFor: 'initialize-release' stamp: 'RAA 2/9/2001 16:37'!buildMorphicMessageCatList	| myMessageCatList |	(myMessageCatList _ PluggableMessageCategoryListMorph new) 			setProperty: #highlightSelector toValue: #highlightMessageCategoryList:with:;			on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu: 			keystroke: #arrowKey:from: getRawListSelector: #rawMessageCategoryList.	myMessageCatList enableDragNDrop: Preferences browseWithDragNDrop.	^myMessageCatList! !!Browser methodsFor: 'initialize-release' stamp: 'RAA 2/9/2001 16:35'!buildMorphicMessageList	| aListMorph |	(aListMorph _ PluggableListMorph new) 			setProperty: #highlightSelector toValue: #highlightMessageList:with:;			on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph enableDragNDrop: Preferences browseWithDragNDrop.	aListMorph menuTitleSelector: #messageListSelectorTitle.	^aListMorph! !!Browser methodsFor: 'initialize-release' stamp: 'RAA 2/9/2001 16:34'!buildMorphicSystemCatList	| dragNDropFlag myCatList |	dragNDropFlag _ Preferences browseWithDragNDrop.	(myCatList _ PluggableListMorph new) 			setProperty: #highlightSelector toValue: #highlightSystemCategoryList:with:;			on: self list: #systemCategoryList			selected: #systemCategoryListIndex changeSelected: #systemCategoryListIndex:			menu: #systemCategoryMenu: keystroke: #systemCatListKey:from:.	myCatList enableDragNDrop: dragNDropFlag.	^myCatList! !!Browser methodsFor: 'initialize-release' stamp: 'nk 2/13/2001 13:25'!labelString	^self selectedClass ifNil: [ self defaultBrowserTitle ]		ifNotNil: [ self defaultBrowserTitle, ': ', self selectedClass printString ].! !!Browser methodsFor: 'initialize-release' stamp: 'sw 2/6/2001 03:34'!optionalButtonPairs	"Answer a tuple (formerly pairs) defining buttons, in the format:			button label			selector to send			help message"	^ #(	('senders' 			browseSendersOfMessages	'browse senders of...')	('implementors'		browseMessages				'browse implementors of...')	('versions'			browseVersions				'browse versions')), 	(Preferences decorateBrowserButtons		ifTrue:			[{#('inheritance'		methodHierarchy 'browse method inheritancegreen: sends to supertan: has override(s)mauve: both of the above' )}]		ifFalse:			[{#('inheritance'		methodHierarchy			'browse method inheritance')}]),	#(	('hierarchy'		classHierarchy				'browse class hierarchy')	('inst vars'			browseInstVarRefs			'inst var refs...')	('class vars'			browseClassVarRefs			'class var refs...'))! !!Browser methodsFor: 'message list' stamp: 'di 2/5/2001 22:04'!validateMessageSource: selector	| sourcesName |	(self selectedClass compilerClass == Object compilerClass 			and: [(contents asString findString: selector keywords first ) ~= 1])		ifTrue: [sourcesName _ FileDirectory localNameFor: Smalltalk sourcesName.			PopUpMenu notify: 'There may be a problem with your sources file!!The source code for every method should start with the methodselector but this is not the case!! You may proceed with caution but it is recommended that you get a new source file.This can happen if you download the "' , sourcesName  , '" file, or the ".changes" file you use, as TEXT. It must be transfered in BINARY mode, even if it looks like a text file, to preserve the CR line ends.Mac users: This may have been caused by Stuffit Expander. To prevent the files above to be converted to Mac line ends when they are expanded, do this: Start the program, then from Preferences... in the File menu, choose the Cross Platform panel, then select "Never" and press OK. Then expand the compressed archive again.'].! !!Browser class methodsFor: 'instance creation' stamp: 'nk 2/13/2001 13:47'!fullOnClass: aClass selector: aSelector	"Open a new full browser set to class."	| brow classToUse |	classToUse _ Preferences browseToolClass.	brow _ classToUse new.	brow setClass: aClass selector: aSelector.	classToUse openBrowserView: (brow openEditString: nil)		label: brow labelString! !!CArrayAccessor methodsFor: 'comparing' stamp: 'yo 2/9/2001 11:23'!< other	^ (object == other object) and: [offset < other offset].! !!CArrayAccessor methodsFor: 'comparing' stamp: 'yo 2/9/2001 11:24'!<= other	^ (object == other object) and: [offset <= other offset].! !!CArrayAccessor methodsFor: 'comparing' stamp: 'yo 2/9/2001 11:24'!> other	^ (object == other object) and: [offset > other offset].! !!CArrayAccessor methodsFor: 'comparing' stamp: 'yo 2/9/2001 11:24'!>= other	^ (object == other object) and: [offset >= other offset].! !!CObjectAccessor methodsFor: 'accessing' stamp: 'yo 2/9/2001 11:23'!object	^ object! !!CObjectAccessor methodsFor: 'accessing' stamp: 'yo 2/9/2001 11:23'!offset	^ offset! !!Celeste methodsFor: 'categories pane' stamp: 'ls 2/10/2001 10:25'!cacheTOC	"Caches a version of the TOC"	| tocStringColumns |	self initializeTocLists.	'Processing ' , currentMessages size printString , ' messages.'		displayProgressAt: Sensor cursorPoint		from: 0		to: currentMessages size		during: [:bar | 1				to: currentMessages size				do: [:i | 					bar value: i.					(self tocLists at: 1)						add: i printString.					"columns from the database are 5"					tocStringColumns _ mailDB								getTOCstringAsColumns: (currentMessages at: i).					(self tocLists at: 2)						add: ((tocStringColumns at: 5)								ifTrue: ['@']								ifFalse: [' ']).					(self tocLists at: 3)						add: (tocStringColumns at: 1).					(self tocLists at: 4)						add: (tocStringColumns at: 2).					(self tocLists at: 5)						add: (tocStringColumns at: 4).					(self tocLists at: 6)						add: (tocStringColumns at: 3)]].	(currentMessages includes: currentMsgID)		ifFalse: [currentMsgID _ nil]! !!Celeste methodsFor: 'categories pane' stamp: 'ls 2/10/2001 10:32'!setCategory: newCategory 	"Change the currently selected category. We must also compute the table  	of contents and message list for the new category."	| messageCount |	currentCategory _ newCategory.	newCategory isNil		ifTrue: [currentMessages _ currentMsgID _ nil.			self class includeStatusPane				ifTrue: [status _ nil]]		ifFalse: [currentMessages _ self filteredMessagesIn: newCategory.			messageCount _ currentMessages size.			messageCount > self maxMessagesToDisplay				ifTrue: [self messages: self maxMessagesToDisplay from: messageCount.				currentMessages _ currentMessages copyLast: self maxMessagesToDisplay]				ifFalse: [self messages: messageCount from: messageCount].			self cacheTOC].	self changed: #category.	self changed: #tocEntryList.	self changed: #tocEntry.	self changed: #messageText.	self changed: #status! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 2/10/2001 14:24'!autoFile	"automatically pick a folder for the current message, and file the current message there"	| folder |	folder := self chooseFilterForCurrentMessage.	folder ifNil: [ ^self].	lastCategory := folder.	mailDB file: currentMsgID inCategory: folder.! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 2/10/2001 14:24'!autoMove	"automatically pick a folder for the current message, and move the message there"	| folder |	folder := self chooseFilterForCurrentMessage.	folder ifNil: [ ^self].	lastCategory := folder.	mailDB file: currentMsgID inCategory: folder.	self removeMessage.! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 2/10/2001 10:31'!nextMessage	"Select the next message."	| index |	(currentCategory isNil | currentMsgID isNil) ifTrue: [^ self].	index _ currentMessages indexOf: currentMsgID.	index < currentMessages size		ifTrue: [self setTOCEntry: ((self tocLists at: 1) at: index + 1)]		ifFalse: [self setTOCEntry: ((self tocLists at: 1) at: 1)].! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 2/10/2001 10:31'!previousMessage	"Select the previous message."	| index |	(currentCategory isNil | currentMsgID isNil) ifTrue: [^ self].	index _ currentMessages indexOf: currentMsgID.	index > 1		ifTrue: [self setTOCEntry: ((self tocLists at: 1)  at: index - 1)]		ifFalse: [self setTOCEntry: ((self tocLists at: 1)  at: currentMessages size)].! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 2/10/2001 10:23'!removeAll	"Remove all messages from the current category."	mailDB removeAll: currentMessages fromCategory: currentCategory.	currentMsgID _ nil.	currentMessages _ #().	self initializeTocLists.	self changed: #tocEntryList.	self changed: #tocEntry.	self changed: #messageText! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 2/10/2001 11:21'!removeMessage	"Remove the current message from the current category."	| currentMessageIndex |	currentMsgID		ifNil: [^ self].	mailDB remove: currentMsgID fromCategory: currentCategory.	"remove the message from the listing"	currentMessageIndex _ currentMessages indexOf: currentMsgID.	currentMessages _ currentMessages copyWithout: currentMsgID.	2		to: self tocLists size		do: [:index | (tocLists at: index) removeAt: currentMessageIndex].	tocLists first removeLast.	"update the message index and message ID"	currentMessages isEmpty		ifTrue: [currentMsgID _ nil]		ifFalse: [currentMsgID _ currentMessages						at: (currentMessageIndex min: currentMessages size)].	self changed: #tocEntryList.	self changed: #tocEntry.	self changed: #messageText! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 2/10/2001 10:26'!setTOCEntry: newTOCentry 	"Change the currently selected message. This is done by finding the  	message ID corresponding to the selected table of contents entry."	| i |	newTOCentry isNil 		ifTrue: [currentMsgID _ nil]		ifFalse: [i _ (self tocLists at: 1)						indexOf: newTOCentry						ifAbsent: [].			i isNil				ifTrue: [currentMsgID _ nil]				ifFalse: [currentMsgID _ currentMessages at: i]].	self changed: #tocEntry.	Cursor read		showWhile: [self changed: #messageText]! !!Celeste methodsFor: 'filtering' stamp: 'ls 2/10/2001 14:26'!chooseFilterForCurrentMessage	"automatically choose a filter to move the selected message.  Returns nil if there isn't a message selected, or if there isn't exactly 1 matching filter"	| matchingFilters |	currentMsgID ifNil: [ ^nil ].	matchingFilters := self filtersFor: currentMsgID from: self filterNames.	matchingFilters size = 1		ifTrue: [ ^matchingFilters anyOne ]		ifFalse: [ ^nil ]! !!Celeste methodsFor: 'filtering' stamp: 'ls 2/10/2001 10:16'!customFilterNamed: filterName 	^CustomFiltersCompiled at: filterName! !!Celeste methodsFor: 'filtering' stamp: 'ls 2/10/2001 14:22'!customFilterOn	"Select or define and activate a custom filter."	| filterName filterMenu |	filterMenu := CustomMenu new.	currentMsgID ifNotNil: [		(self filtersFor: currentMsgID from: self filterNames) do: [ :name |			filterMenu add: name action: name ].		filterMenu addLine.].	filterMenu add: '(none)' action: #none.	filterMenu add: '<define new filter...>' action: #define.	filterMenu add: '<edit exising filter...>' action: #edit.	filterMenu add: '<delete a filter...>' action: #delete.	filterMenu addLine.	self filterNames do: [ :name |		filterMenu add: name action: name ].	filterName _ filterMenu startUpWithCaption: 'Select a filter:'.	filterName ifNil: [ ^self ].	filterName = #none ifTrue: [^self customFilterOff ].	filterName = #delete ifTrue: [ ^self deleteFilter].	filterName = #edit		ifTrue: [filterName _ self editFilter]		ifFalse: [			filterName = #define				ifTrue: [filterName _ self defineFilter] ].	filterName ifNil: [ ^self ].	filterName isEmpty ifTrue: [^self].	customFilterBlock _ CustomFiltersCompiled at: filterName.	self updateTOC.	self changed: #isCustomFilterOn.! !!Celeste methodsFor: 'filtering' stamp: 'ls 2/10/2001 14:22'!deleteFilter	| filterName |	CustomFilters isEmpty ifTrue: [^''].	filterName _ (CustomMenu selections: self filterNames)		startUpWithCaption: 'Filter to delete?'.	filterName = nil ifTrue: [^''].	CustomFilters removeKey: filterName ifAbsent: [].	CustomFiltersCompiled removeKey: filterName ifAbsent: [].! !!Celeste methodsFor: 'filtering' stamp: 'ls 2/10/2001 14:22'!editFilter	| filterName |	CustomFilters isEmpty ifTrue: [^''].	filterName _ (CustomMenu selections: self filterNames)		startUpWithCaption: 'Filter to edit?'.	filterName = nil ifTrue: [^''].	^self editFilterNamed: filterName filterExpr: (CustomFilters at: filterName)! !!Celeste methodsFor: 'filtering' stamp: 'ls 2/10/2001 14:21'!editFilterNamed: filterName filterExpr: oldExpr	| newDefinition |	newDefinition _ FillInTheBlank		request:'Enter a filter definition where "m" is the message being testing. The expression can send"fromHas:", "toHas:", "ccHas:", "subjectHas:", "participantHas:", or "textHas:" to m to test forinclusion of a string--or one of an array of strings--in a field. It can also test m''s timeand/or date and can combine several tests with logical operators. Examples:      m fromHas: ''johnm''                       -- messages from johnm     m participantHas: ''johnm''                -- messages from, to, or cc-ing johnm     m textHas: #(squeak smalltalk java)      -- messages with any of these words     m subjectHas: #(0 1 2 3 4 5 6 7 8 9)       -- numbers in lists treated as strings NOTE: "textHas:" is very slow, since it must read the message from disk.'		initialAnswer: oldExpr.	newDefinition isEmpty ifTrue: [^''].	CustomFilters at: filterName put: newDefinition.	CustomFiltersCompiled at: filterName put: (self class makeFilterFor: newDefinition).	^filterName! !!Celeste methodsFor: 'filtering' stamp: 'ls 2/10/2001 14:18'!filterNames	"return a sorted list of custom filter names"	^CustomFilters keys asSortedArray! !!Celeste class methodsFor: 'filters' stamp: 'ls 2/10/2001 10:16'!compileAllCustomFilters	"recompile all custom filters"	CustomFiltersCompiled := Dictionary new.	CustomFilters keysAndValuesDo: [ :filterName :filter |		CustomFiltersCompiled at: filterName put: (self makeFilterFor: filter) ].! !!Celeste class methodsFor: 'filters' stamp: 'ls 2/10/2001 10:15'!makeFilterFor: filterExpr	"compile a given custom filter"	^Compiler evaluate: '[ :m | ', filterExpr, ']'.! !!CelesteComposition methodsFor: 'private' stamp: 'ls 2/10/2001 13:57'!breakLines: aString  atWidth: width	"break lines in the given string into shorter lines"	| result start end atAttachment |	result _ WriteStream on: (String new: (aString size * 50 // 49)).	atAttachment _ false.	aString asString linesDo: [ :line | 		(line beginsWith: '====') ifTrue: [ atAttachment _ true ].		atAttachment ifTrue: [			"at or after an attachment line; no more wrapping for the rest of the message"			result nextPutAll: line.  result cr ]		ifFalse: [			(line beginsWith: '>') ifTrue: [				"it's quoted text; don't wrap it"				result nextPutAll: line. result cr. ]			ifFalse: [				"regular old line.  Wrap it to multiple lines"				start _ 1.					"output one shorter line each time through this loop"				[ start + width <= line size ] whileTrue: [						"find the end of the line"					end _ start + width - 1.					[end >= start and: [ (line at: (end+1)) isSeparator not ]] whileTrue: [						end _ end - 1 ].					end < start ifTrue: [						"a word spans the entire width!!"						end _ start + width - 1 ].					"copy the line to the output"					result nextPutAll: (line copyFrom: start to: end).					result cr.					"get ready for next iteration"					start _ end+1.					(line at: start) isSeparator ifTrue: [ start _ start + 1 ].				].				"write out the final part of the line"				result nextPutAll: (line copyFrom: start to: line size).				result cr.			].		].	].	^result contents! !!CelesteComposition methodsFor: 'private' stamp: 'ls 2/10/2001 14:08'!breakLinesInMessage: message	"reformat long lines in the specified message into shorter ones"	message body  mainType = 'text' ifTrue: [		"it's a single-part text message.  reformat the text"		| newBodyText |		newBodyText := self breakLines: message bodyText  atWidth: 72.		message body: (MIMEDocument contentType: message body contentType content: newBodyText).		^self ].	message body isMultipart ifTrue: [		"multipart message; process the top-level parts.  HACK: the parts are modified in place"		message parts do: [ :part |			part body mainType = 'text' ifTrue: [				| newBodyText |				newBodyText := self breakLines: part bodyText atWidth: 72.				part body: (MIMEDocument contentType: part body contentType content: newBodyText) ] ].		message regenerateBodyFromParts. ].! !!CelesteComposition methodsFor: 'access' stamp: 'ls 2/10/2001 14:07'!submit	| message |	"submit the message"	textEditor		ifNotNil: [self hasUnacceptedEdits ifTrue: [textEditor accept]].	message := MailMessage from: messageText asString.	self breakLinesInMessage: message.	celeste queueMessageWithText: message text.	morphicWindow ifNotNil: [morphicWindow delete].	mvcWindow ifNotNil: [mvcWindow controller close]! !!CelesteComposition methodsFor: 'interface' stamp: 'ls 2/10/2001 13:29'!addAttachment	| file fileResult fileName |	textEditor		ifNotNil: [self hasUnacceptedEdits ifTrue: [textEditor accept]].	(fileResult _ StandardFileMenu oldFile)		ifNotNil: 			[fileName _ fileResult directory fullNameFor: fileResult name.			file _ FileStream readOnlyFileNamed: fileName.			file ifNotNil: [file binary. self messageText: ((MailMessage from: self messageText asString)						addAttachmentFrom: file withName: fileResult name; text)]] ! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ls 2/10/2001 16:35'!mailOut	"File out the receiver, to a file whose name is a function of the           	change-set name and either of the date & time or chosen to have a	unique numeric tag, depending on the preference	'sequentialChangeSetRevertableFileNames'."	| subjectPrefix slips message compressBuffer compressStream data compressedStream compressTarget |	(Smalltalk includesKey: #Celeste)		ifFalse: [^ self notify: 'no mail reader present'].	subjectPrefix _ self chooseSubjectPrefixForEmail.	self checkForConversionMethods.	Cursor write showWhile: [		"prepare the message"		message := MailMessage empty.		message setField: 'from' toString: Celeste userName.		message setField: 'to' toString: 'squeak@cs.uiuc.edu'.		message setField: 'subject' toString: (subjectPrefix, name). 		message body: (MIMEDocument contentType: 'text/plain' content: (String streamContents: [ :str |			str nextPutAll: 'from preamble:';				cr;				cr.				self fileOutPreambleOn: str ])).		"Prepare the gzipped data"		data _ data _ WriteStream on: String new.		data header.		self fileOutPreambleOn: data.		self fileOutOn: data.		self fileOutPostscriptOn: data.		data trailer.		data _ ReadStream on: data contents.		compressBuffer _ ByteArray new: 1000.		compressStream _ GZipWriteStream on: (compressTarget _ WriteStream on: (ByteArray new: 1000)).		[data atEnd]			whileFalse: [compressStream nextPutAll: (data nextInto: compressBuffer)].		compressStream close.		compressedStream _ ReadStream on: compressTarget contents asString.		message addAttachmentFrom: compressedStream withName: (name, '.cs.gz').		CelesteComposition			openForCeleste: Celeste current 			initialText: message text. ].	Preferences suppressCheckForSlips ifTrue: [^ self].	slips _ self checkForSlips.	(slips size > 0 and: [self confirm: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?'])		ifTrue: [Smalltalk browseMessageList: slips name: 'Possible slips in ' , name]! !!Character methodsFor: 'object fileIn' stamp: 'tk 2/16/2001 14:52'!objectForDataStream: refStrm	"I am being collected for inclusion in a segment.  Do not include Characters!!  Let them be in outPointers."	refStrm insideASegment		ifFalse: ["Normal use" ^ self]		ifTrue: ["recording objects to go into an ImageSegment"						"remove it from references.  Do not trace."			refStrm references removeKey: self ifAbsent: [].			^ nil]! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'hmm 2/2/2001 15:27'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY _ destY +  line lineHeight.				lastCharacter _ nil.				characterPoint _ nextLeftMargin @ destY.				lastIndex _ lastIndex + 1.				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter _ CR.		characterPoint _ destX @ destY.		self lastCharacterExtentSetX: rightMargin - destX.		^true! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'hmm 2/2/2001 14:59'!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| leadingTab currentX |	characterIndex == nil ifFalse: [		"If the last character of the last line is a space,		and it crosses the right margin, then locating		the character block after it is impossible without this hack."		characterIndex > text size ifTrue: [			lastIndex _ characterIndex.			characterPoint _ (nextLeftMargin ifNil: [leftMargin]) @ (destY + line lineHeight).			^true]].	characterPoint x <= (destX + (lastCharacterExtent x // 2))		ifTrue:	[lastCharacter _ (text at: lastIndex).				characterPoint _ destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter _ (text at: line last).				characterPoint _ destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex _ lastIndex + 1.	lastCharacter _ text at: lastIndex.	currentX _ destX + lastCharacterExtent x + kern.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint _ currentX @ destY.	lastCharacter = Space ifFalse: [^ true].	"Yukky if next character is space or tab."	textStyle alignment = Justified ifTrue:		[self lastCharacterExtentSetX:			(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1))).		^ true].	true ifTrue: [^ true].	"NOTE:  I find no value to the following code, and so have defeated it - DI"	"See tabForDisplay for illumination on the following awfulness."	leadingTab _ true.	line first to: lastIndex - 1 do:		[:index | (text at: index) ~= Tab ifTrue: [leadingTab _ false]].	(textStyle alignment ~= Justified or: [leadingTab])		ifTrue:	[self lastCharacterExtentSetX: (textStyle nextTabXFrom: currentX					leftMargin: leftMargin rightMargin: rightMargin) -						currentX]		ifFalse:	[self lastCharacterExtentSetX:  (((currentX + (textStyle tabWidth -						(line justifiedTabDeltaFor: spaceCount))) -							currentX) max: 0)].	^ true! !!CharacterBlockScanner methodsFor: 'private' stamp: 'hmm 2/1/2001 16:20'!buildCharacterBlockIn: para	| lineIndex runLength lineStop done stopCondition |	"handle nullText"	(para numberOfLines = 0 or: [text size = 0])		ifTrue:	[^ CharacterBlock new stringIndex: 1  "like being off end of string"					text: para text					topLeft: (para leftMarginForDisplayForLine: 1)								@ para compositionRectangle top					extent: 0 @ textStyle lineGrid].	"find the line"	lineIndex _ para lineIndexOfTop: characterPoint y.	destY _ para topAtLineIndex: lineIndex.	line _ para lines at: lineIndex.	rightMargin _ para rightMarginForDisplay.	(lineIndex = para numberOfLines and:		[(destY + line lineHeight) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					self characterPointSetX: rightMargin]			ifFalse:	[characterPoint y < (para compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint _ (para compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[self characterPointSetX: rightMargin]].	destX _ (leftMargin _ para leftMarginForDisplayForLine: lineIndex).	nextLeftMargin_ para leftMarginForDisplayForLine: lineIndex+1.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ (text runLengthFor: line first).	characterIndex == nil		ifTrue:	[lineStop _ line last  "characterBlockAtPoint"]		ifFalse:	[lineStop _ characterIndex  "characterBlockForIndex"].	(runStopIndex _ lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex _ lineStop].	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0. done  _ false.	self handleIndentation.	[done]	whileFalse:	[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.	"see setStopConditions for stopping conditions for character block 	operations."	self lastCharacterExtentSetX: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition) ifTrue:		[characterIndex == nil			ifTrue: ["characterBlockAtPoint"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + (font descentKern @ 0)						extent: lastCharacterExtent]			ifFalse: ["characterBlockForIndex"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + ((font descentKern) - kern @ 0)						extent: lastCharacterExtent]]]! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'hmm 2/2/2001 15:07'!indentationLevel: anInteger	super indentationLevel: anInteger.	nextLeftMargin _ leftMargin.	indentationLevel timesRepeat: [		nextLeftMargin _ textStyle nextTabXFrom: nextLeftMargin					leftMargin: leftMargin					rightMargin: rightMargin]! !!CharacterScanner methodsFor: 'scanning' stamp: 'hmm 7/15/2000 22:40'!handleIndentation	self indentationLevel timesRepeat: [		self plainTab]! !!CharacterScanner methodsFor: 'scanning' stamp: 'hmm 7/15/2000 22:41'!plainTab	"This is the basic method of adjusting destX for a tab."	destX _ (textStyle alignment == Justified and: [self leadingTab not])		ifTrue:		"embedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin]! !!CharacterScanner methodsFor: 'scanning' stamp: 'hmm 7/14/2000 16:07'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable, indexed by map. 	If dextX would exceed rightX, then return stops at: 258. 	Advance destX by the width of the character. If stopIndex has been	reached, then return stops at: 257. Optional. 	See Object documentation whatIsAPrimitive."	| ascii nextDestX char |	<primitive: 103>	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[char _ (sourceString at: lastIndex).			ascii _ char asciiValue + 1.			(stops at: ascii) == nil ifFalse: [^stops at: ascii].			"Note: The following is querying the font about the width			since the primitive may have failed due to a non-trivial			mapping of characters to glyphs or a non-existing xTable."			nextDestX _ destX + (font widthOf: char).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			destX _ nextDestX + kernDelta.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!ChineseCheckers methodsFor: 'drag and drop' stamp: 'ajh 2/15/2001 21:11'!acceptDroppingMorph: aPiece event: evt	| dropLoc |	dropLoc _ self boardLocAt: evt cursorPoint.	dropLoc = aPiece boardLoc ifTrue:  "Null move"		[^ aPiece rejectDropMorphEvent: evt].	(plannedMove _ (self allMovesFrom: aPiece boardLoc)				detect: [:move | move last = dropLoc]				ifNone: [nil])		ifNil: [^ aPiece rejectDropMorphEvent: evt.   "Not a valid move"].	super acceptDroppingMorph: aPiece event: evt.	movePhase _ 1.  "Start the animation if any."! !!CipherPanel methodsFor: 'initialization' stamp: 'nk 2/16/2001 13:54'!encodedQuote: aString	"World addMorph: CipherPanel new"	| morph prev |	aString isEmpty ifTrue: [ ^self ].	(letterMorphs == nil or: [self isClean]) ifFalse:		[(self confirm: 'Are you sure you want to discard all typing?')			ifFalse: [^ self]].	haveTypedHere _ false.	quote _ aString asUppercase.	prev _ nil.	originalMorphs _ quote asArray collectWithIndex:		[:c :i | WordGameLetterMorph new plain indexInQuote: i id1: nil;						setLetter: (quote at: i)].	letterMorphs _ OrderedCollection new.	decodingMorphs _ quote asArray collectWithIndex:		[:c :i | (quote at: i) isLetter		ifTrue:			[morph _ WordGameLetterMorph new underlined indexInQuote: i id1: nil.			morph on: #mouseDown send: #mouseDownEvent:letterMorph: to: self.			morph on: #keyStroke send: #keyStrokeEvent:letterMorph: to: self.			letterMorphs addLast: morph.			morph predecessor: prev.			prev ifNotNil: [prev successor: morph].			prev _ morph]		ifFalse:			[WordGameLetterMorph new plain indexInQuote: i id1: nil; setLetter: (quote at: i)]].	self color: originalMorphs first color.	self extent: 500@500! !!CipherPanel methodsFor: 'initialization' stamp: 'di 2/14/2001 13:50'!extent: newExtent 	"Lay out with word wrap, alternating bewteen decoded and encoded lines."	"Currently not tolerant of narrow (less than a word) margins"	| w h relLoc topLeft thisWord i m corner row firstWord |	self removeAllMorphs.	w _ originalMorphs first width - 1.  h _ originalMorphs first height * 2 + 10.	topLeft _ self position + self borderWidth + (0@10).	thisWord _ OrderedCollection new.	i _ 1.  firstWord _ true.  relLoc _ 0@0.  corner _ topLeft.	[i <= originalMorphs size] whileTrue:		[m _ originalMorphs at: i.		thisWord addLast: ((decodingMorphs at: i) position: topLeft + relLoc).		thisWord addLast: (m position: topLeft + relLoc + (0@m height)).		(m letter = Character space or: [i = originalMorphs size])			ifTrue: [self addAllMorphs: thisWord.					corner _ corner max: thisWord last bounds bottomRight.					thisWord reset.  firstWord _ false].		relLoc _ relLoc + (w@0).		(relLoc x + w) > newExtent x			ifTrue: [firstWord						ifTrue: ["No spaces -- force a line break"								thisWord removeLast; removeLast.								self addAllMorphs: thisWord.								corner _ corner max: thisWord last bounds bottomRight]						ifFalse: [i _ i - (thisWord size//2) + 1].					thisWord reset.  firstWord _ true.					relLoc _ 0@(relLoc y + h)]			ifFalse: [i _ i + 1]].	row _ self buttonRow. row fullBounds.	self addMorph: row.	super extent: (corner - topLeft) + (self borderWidth * 2) + (0@row height+10).	row align: row bounds bottomCenter with: self bounds bottomCenter - (0@2).! !!CipherPanel methodsFor: 'menu' stamp: 'di 10/4/2000 10:55'!addMenuItemsTo: aMenu hand: aHandMorph	aMenu add: 'show cipher help' target: self action: #showHelpWindow.	aMenu add: 'show cipher hints' target: self action: #showHintsWindow.	aMenu add: 'clear cipher typing' target: self action: #clearTyping.	aMenu add: 'enter a new cipher' target: self action: #enterANewCipher.	aMenu add: 'quote from Squeak' target: self action: #squeakCipher.! !!CipherPanel methodsFor: 'menu' stamp: 'di 10/4/2000 10:54'!buttonRow	| row aButton |	row _ AlignmentMorph newRow		color: self color;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	aButton _ SimpleButtonMorph new target: self.	aButton color: Color transparent; borderWidth: 1; borderColor: Color black.	#('show help' 'show hints' 'clear typing' 'enter a new cipher' 'quote from Squeak')	with: 	#(showHelpWindow showHintsWindow clearTyping enterANewCipher squeakCipher)	do: [:label :selector |		aButton _ aButton fullCopy.		aButton actionSelector: selector.		aButton label: label.		row addMorphBack: aButton.		row addTransparentSpacerOfSize: (3 @ 0)].	^ row! !!CipherPanel methodsFor: 'menu' stamp: 'di 10/4/2000 11:00'!enterANewCipher	self clearTyping; encodedQuote:		(FillInTheBlank request: 'Type a cipher text to work on here below...')! !!CipherPanel methodsFor: 'menu' stamp: 'di 10/4/2000 10:48'!squeakCipher	self encodedQuote: (CipherPanel encode: (CipherPanel randomComment))! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 10/4/2000 10:42'!encode: aString	"CipherPanel encode: 'Now is the time for all good men to come to the aid of their country.'"	| dict repeat |	dict _ Dictionary new.	repeat _ true.	[repeat] whileTrue:		[repeat _ false.		($A to: $Z) with: ($A to: $Z) shuffled do:			[:a :b | a = b ifTrue: [repeat _ true].			dict at: a put: b]].	^ aString asUppercase collect: [:a | dict at: a ifAbsent: [a]]! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 10/4/2000 10:43'!randomComment   "CipherPanel randomComment"	"Generate cryptic puzzles from method comments in the system"	| c s | s _ 'none'.	[s = 'none'] whileTrue:		[s _ ((c _ Smalltalk allClasses atRandom) selectors					collect: [:sel | (c firstCommentAt: sel) asString])		 			detect: [:str | str size between: 100 and: 200] ifNone: ['none']].	^ s! !!CipherPanel class methodsFor: 'as yet unclassified' stamp: 'di 10/4/2000 10:45'!tedsHack  	"Generate cryptic puzzles from method comments in the system"	(self newFromQuote: (self encode: (self randomComment))) openInWorld"CipherPanel tedsHack"! !!ClassBuilder methodsFor: 'private' stamp: 'di 2/12/2001 22:06'!fixGlobalReferences 	"Fix all the references to globals which are now outdated.	Care must be taken that we do not accidentally 'fix' dangerous stuff."	| oldClasses newClasses condition any |	classMap == nil ifTrue:[^self].	(self retryWithGC: [condition _ classMap anySatisfy: [:any0 | any _ any0. any0 _ nil. any notNil and:[anyisObsolete]]. any_nil. condition]		until:[:obsRef| obsRef = false])		ifFalse:[^self]. "GC cleaned up the remaining refs"	"Collect the old and the new refs"	oldClasses _ OrderedCollection new.	newClasses _ OrderedCollection new.	classMap keysAndValuesDo:[:new :old|		old == nil ifFalse:[			newClasses add: new.			oldClasses add: old]].	oldClasses isEmpty ifTrue:[^self]. "GC cleaned up the rest"	"Now fix all the known dangerous pointers to old classes by creating	copies of those still needed. Dangerous pointers should come only	from obsolete subclasses (where the superclass must be preserved)."	self fixObsoleteReferencesTo: oldClasses.	"After this has been done fix the remaining references"	progress == nil ifFalse:[progress value: 'Fixing references toglobals'].	"Forward all old refs to the new ones"	(oldClasses asArray) elementsForwardIdentityTo: (newClasses asArray).	"Done"! !!ClassDescription methodsFor: 'initialize-release' stamp: 'di 2/12/2001 22:06'!updateInstancesFrom: oldClass	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary."	"ar 7/15/1999: The updating below is possibly dangerous. If there are any	contexts having an old instance as receiver it might crash the system if	the new receiver in which the context is executed has a different layout.	See bottom below for a simple example:"	| oldInstances |	Smalltalk garbageCollect.	"ensure that allInstances is correct"	oldInstances _ oldClass allInstances asArray.	self updateInstances: oldInstances from: oldClass isMeta: self isMeta.	"Now fix up instances in segments that are out on the disk."	ImageSegment allSubInstancesDo: [:seg |		seg segUpdateInstancesOf: oldClass toBe: self isMeta: self isMeta].	oldInstances _ nil.	Smalltalk garbageCollect.	"ensure that old instances are gone""	| crashingBlock class |	class _ Object subclass: #CrashTestDummy		instanceVariableNames: 'instVar'		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	class compile:'instVar: value instVar _ value'.	class compile:'crashingBlock ^[instVar]'.	crashingBlock _ (class new) instVar: 42; crashingBlock.	Object subclass: #CrashTestDummy		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	crashingBlock.	crashingBlock value.	"! !!ClassOrganizer methodsFor: 'accessing' stamp: 'JW 2/15/2001 07:40'!classComment	globalComment		ifNil: [^ ''].	^ globalComment text ifNil: ['']! !!Clipboard methodsFor: 'accessing' stamp: 'RAA 2/6/2001 11:18'!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."	| s |	s _ self primitiveClipboardText.	(s isEmpty or: [s = contents asString])		ifTrue: [^ contents]		ifFalse: [^ s asText]! !!Clipboard methodsFor: 'accessing' stamp: 'RAA 2/6/2001 11:21'!clipboardText: text	"Set text currently on the clipboard.  Also export to OS"	contents _ text.	self noteRecentClipping: text asText.	self primitiveClipboardText: text asString! !!CodeLoader methodsFor: 'installing' stamp: 'ar 2/6/2001 19:11'!installSegment: reqEntry	"Install the previously loaded segment"	| contentStream contents trusted |	contentStream _ reqEntry value contentStream.	contentStream ifNil:[^self error:'No content to install: ', reqEntry key printString].	trusted _ SecurityManager default positionToSecureContentsOf: contentStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) ifFalse:[		(contentStream respondsTo: #close) ifTrue:[contentStream close].		^self error:'Insecure content encountered: ', reqEntry key printString]].	contents _ contentStream upToEnd unzipped.	(contentStream respondsTo: #close) ifTrue:[contentStream close].	^(RWBinaryOrTextStream with: contents) reset fileInObjectAndCode install.! !!CodeLoader methodsFor: 'installing' stamp: 'ar 2/6/2001 19:13'!installSourceFile: aStream	"Install the previously loaded source file"	| contents trusted |	aStream ifNil:[^self error:'No content to install'].	trusted _ SecurityManager default positionToSecureContentsOf: aStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) ifFalse:[		(aStream respondsTo: #close) ifTrue:[aStream close].			^self error:'Insecure content encountered']].	contents _ aStream upToEnd unzipped.	(aStream respondsTo: #close) ifTrue:[aStream close].	^(RWBinaryOrTextStream with: contents) reset fileIn! !!CodeLoader class methodsFor: 'utilities' stamp: 'ar 2/6/2001 19:22'!signFile: fileName renameAs: destFile key: privateKey dsa: dsa	"Sign the given file using the private key."	| in out |	in _ FileStream readOnlyFileNamed: fileName.	in binary.	out _ FileStream newFileNamed: destFile.			out binary.	[in atEnd] whileFalse:[out nextPutAll: (in next: 4096)].	in close.	out close.	FileDirectory splitName: destFile to:[:path :file|		SecurityManager default signFile: file directory: (FileDirectory on: path).	].! !!CodeLoader class methodsFor: 'utilities' stamp: 'ar 2/6/2001 19:17'!verifySignedFileNamed: aFileName	"CodeLoader verifySignedFileNamed: 'signed\dummy1.dsq' "	| secured signedFileStream |	signedFileStream _ FileStream fileNamed: aFileName.	secured _ SecurityManager default positionToSecureContentsOf: signedFileStream.	signedFileStream close.	Transcript show: aFileName , ' verified: '; show: secured printString; cr.! !!CompositionScanner methodsFor: 'scanning' stamp: 'hmm 2/9/2001 11:55'!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	"Set up margins"	leftMargin _ lineRectangle left.	leftSide ifTrue: [leftMargin _ leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	destX _ spaceX _ leftMargin.	rightMargin _ lineRectangle right.	rightSide ifTrue: [rightMargin _ rightMargin - textStyle rightIndent].	lastIndex _ startIndex.	"scanning sets last index"	destY _ lineRectangle top.	lineHeight _ baseline _ 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font"	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	spaceCount _ 0.	self handleIndentation.	leftMargin _ destX.	line leftMargin: leftMargin.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^ line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!CompositionScanner methodsFor: 'scanning' stamp: 'hmm 7/20/2000 18:24'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	destX _ spaceX _ leftMargin _ aParagraph leftMarginForCompositionForLine: lineIndex.	destY _ 0.	rightMargin _ aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex _ startIndex.	"scanning sets last index"	lineHeight _ textStyle lineGrid.  "may be increased by setFont:..."	baseline _ textStyle baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:59'!tab	"Advance destination x according to tab settings in the paragraph's 	textStyle. Answer whether the character has crossed the right edge of 	the composition rectangle of the paragraph."	destX _ textStyle				nextTabXFrom: destX leftMargin: leftMargin rightMargin: rightMargin.	destX > rightMargin ifTrue:	[^self crossedX].	lastIndex _ lastIndex + 1.	^false! !!CompoundTileMorph methodsFor: 'miscellaneous' stamp: 'ar 2/6/2001 22:07'!recompileScript	"Pertains only when the test is outside a script?!!"! !!CompoundTileMorph methodsFor: 'testing' stamp: 'ar 2/7/2001 17:57'!isTileEditor	"Yes I am"	^true! !!Debugger methodsFor: 'context stack menu' stamp: 'nk 2/6/2001 19:34'!where	"Select the expression whose evaluation was interrupted."	selectingPC _ true.	self contextStackIndex: contextStackIndex oldContextWas: self selectedContext! !!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'ar 2/1/2001 20:18'!initRandomFromString: aString	"Ask the user to type a long random string and use the result to seed the secure random number generator."	| s k srcIndex |	s _ aString.	k _ LargePositiveInteger new: (s size min: 64).	srcIndex _ 0.	k digitLength to: 1 by: -1 do: [:i |		k digitAt: i put: (s at: (srcIndex _ srcIndex + 1)) asciiValue].	k _ k + (Random new next * 16r7FFFFFFF) asInteger.  "a few additional bits randomness"	k highBit > 512 ifTrue: [k _ k bitShift: k highBit - 512].	self initRandom: k.! !!DisplayMedium methodsFor: 'displaying' stamp: 'hmm 9/16/2000 21:27'!deferUpdatesIn: aRectangle while: aBlock	"DisplayScreen overrides with something more involved..."	^aBlock value! !!DisplayScanner methodsFor: 'scanning' stamp: 'hmm 9/20/2000 12:54'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun startIndex string lastPos |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	leftInRun _ 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges _ false.	paragraph _ aParagraph.	foregroundColor _ paragraphColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt _ nil]		ifFalse: [fillBlt _ bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	bitBlt destForm deferUpdatesIn: visibleRectangle while: [		linesInterval do: 			[:lineIndex | 			leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.			destX _ (runX _ leftMargin).			line _ aParagraph lines at: lineIndex.			lineHeight _ line lineHeight.			fillBlt == nil ifFalse:				[fillBlt destX: visibleRectangle left destY: lineY					width: visibleRectangle width height: lineHeight; copyBits].			lastIndex _ line first.			leftInRun <= 0				ifTrue: [self setStopConditions.  "also sets the font"						leftInRun _ text runLengthFor: line first].			destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"			runLength _ leftInRun.			runStopIndex _ lastIndex + (runLength - 1) min: line last.			leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).			spaceCount _ 0.			done _ false.			string _ text string.			self handleIndentation.			[done] whileFalse:[				startIndex _ lastIndex.				lastPos _ destX@destY.				stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex							in: string rightX: rightMargin stopConditions: stopConditions							kern: kern.				lastIndex >= startIndex ifTrue:[					font displayString: string on: bitBlt 						from: startIndex to: lastIndex at: lastPos kern: kern].				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].			fillBlt == nil ifFalse:				[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].			lineY _ lineY + lineHeight]]! !!DisplayScanner methodsFor: 'private' stamp: 'hmm 9/16/2000 21:29'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	super initializeFromParagraph: aParagraph clippedBy: clippingRectangle.	bitBlt _ BitBlt current toForm: aParagraph destinationForm.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt combinationRule: Form paint.	bitBlt colorMap:		(Bitmap with: 0      "Assumes 1-bit deep fonts"				with: (aParagraph foregroundColor pixelValueForDepth: bitBlt destForm depth)).	bitBlt clipRect: clippingRectangle.! !!DisplayScanner methodsFor: 'private' stamp: 'hmm 9/16/2000 21:29'!setPort: aBitBlt	"Install the BitBlt to use"	bitBlt _ aBitBlt.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt sourceForm: nil. "Make sure font installation won't be confused"! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'hmm 7/16/2000 08:23'!plainTab	| oldX |	oldX _ destX.	super plainTab.	fillBlt == nil ifFalse:		[fillBlt destX: oldX destY: destY width: destX - oldX height: font height; copyBits]! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'hmm 7/16/2000 08:23'!tab	self plainTab.	lastIndex _ lastIndex + 1.	^ false! !!DisplayScanner methodsFor: 'quick print' stamp: 'hmm 9/20/2000 11:44'!drawString: aString at: aPoint	"Draw the given string."	destX _ aPoint x asInteger.	destY _ aPoint y asInteger.	lastIndex _ 1.	self scanCharactersFrom: 1 to: aString size in: aString		rightX: bitBlt clipX + bitBlt clipWidth + font maxWidth		stopConditions: stopConditions kern: kern.	font displayString: aString on: bitBlt from: 1 to: lastIndex at: aPoint kern: kern.! !!DisplayScanner methodsFor: 'quick print' stamp: 'hmm 2/1/2001 16:24'!stringWidth: aString	"Answer the width of the given string."	destX _ destY _ 0.	aString ifNil: [^ 0].	lastIndex _ 1.		"else the prim will fail"	self scanCharactersFrom: 1 to: aString size in: aString		rightX: 99999	"virtual infinity"		stopConditions: stopConditions		kern: kern.	^ destX"	(1 to: 10) collect: [:i | QuickPrint new stringWidth: (String new: i withAll: $A)]"! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 6/18/2000 19:16'!deferUpdates: aBoolean	| wasDeferred |	"Set the deferUpdates flag in the virtual machine. When this flag is true, BitBlt operations on the Display are not automatically propagated to the screen. If this underlying platform does not support deferred updates, this primitive will fail. Answer whether updates were deferred before if the primitive succeeds, nil if it fails."	wasDeferred _ DeferringUpdates == true.	DeferringUpdates _ aBoolean.	^(self primitiveDeferUpdates: aBoolean) ifNotNil: [wasDeferred]! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 2/2/2001 10:14'!deferUpdatesIn: aRectangle while: aBlock	| result |	(self deferUpdates: true) ifTrue: [^aBlock value].	result _ aBlock value.	self deferUpdates: false.	self forceToScreen: aRectangle.	^result! !!DisplayScreen methodsFor: 'other' stamp: 'ar 2/14/2001 00:01'!getCurrentMorphicWorld        ^RequestCurrentWorldNotification signal ifNil: [                (self morphicWorldAt: Sensor peekPosition) ifNil: [                        self getOuterMorphicWorld                ].        ]! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 6/18/2000 19:14'!primitiveDeferUpdates: aBoolean	"Set the deferUpdates flag in the virtual machine. When this flag is true, BitBlt operations on the Display are not automatically propagated to the screen. If this underlying platform does not support deferred updates, this primitive will fail. Answer the receiver if the primitive succeeds, nil if it fails."	<primitive: 126>	^ nil  "answer nil if primitive fails"! !!DisplayScreen class methodsFor: 'snapshots' stamp: 'ar 2/5/2001 17:24'!actualScreenDepth	<primitive: 'primitiveScreenDepth'>	^ Display depth! !This class defines the necessary primitives for dropping files from the OS onto Squeak.Implementation notes:The drop support is really a two phase process. The first thing the OS code needs to do is to signal an event of type EventTypeDragDropFiles to Squeak. This event needs to include the following information (see sq.h for the definition of sqDragDropFilesEvent):* dragType:		DragEnter - dragging mouse entered Squeak window		DragMove - dragging mouse moved within Squeak window		DragLeave - dragging mouse left Squeak window		DragDrop - dropped files onto Squeak window* numFiles:		The number of files in the drop operation.* x, y, modifiers:		Associated mouse state.When these events are received, the primitives implemented by this plugin come into play. The two primitives can be used to either receive a list of file names or to receive a list of (read-only) file handles. Because drag and drop operations are intended to work in a restricted (plugin) environment, certain security precautions need to be taken:* Access to the contents of the files (e.g., the file streams) must only be granted after a drop occured. Simply dragging the file over the Squeak window is not enough to grant access.* Access to the contents of the files after a drop is allowed to bypass the file sandbox and create a read-only file stream directly.* Access to the names of files can be granted even if the files are only dragged over Squeak (but not dropped). This is so that appropriate user feedback can be given.If somehow possible, the support code should track the location of the drag-and-drop operation and generate appropriate DragMove type events. While not important right now, it will allow us to integrate OS DnD operations with Morphic DnD operation in a seemless manner.!!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/6/2001 14:10'!genericTextFieldNamed: aString	| newField |	newField _ ShowEmptyTextMorph new		beAllFont: self myFont;		extent: 300@20;		contentsWrapped: ''.	namedFields at: aString put: newField.	^newField! !!EToyVocabulary methodsFor: 'initialization' stamp: 'jla 2/4/2001 19:24'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	|   classes aMethodCategory selector selectors categorySymbols |	super initialize.	self vocabularyName: #eToy.	self documentation: '"EToy" is a vocabulary that provides the equivalent of the 1997-2000 etoy prototype'.	categorySymbols _ Set new.	classes _ Smalltalk allImplementorsOf: #additionsToViewerCategories.	classes do:		[:anItem |		MessageSet parse: anItem toClassAndSelector:			[:aClass :aSelector |		categorySymbols addAll: aClass soleInstance basicNew categoriesForViewer]].	categorySymbols asOrderedCollection do:		[:aCategorySymbol |			aMethodCategory _ ElementCategory new categoryName: aCategorySymbol..				classes _ (Smalltalk allImplementorsOf: #additionsToViewerCategories) collect:					[:anItem | MessageSet parse: anItem toClassAndSelector: [:aMetaClass :aSelector | aMetaClass soleInstance]].			selectors _ Set new.			classes do:				[:aClass |					 (aClass additionsToViewerCategory: aCategorySymbol) do:						[:anElement |							anElement first == #command								ifTrue:									[selectors add: (selector _ anElement second).									(methodInterfaces includesKey: selector) ifFalse:										[methodInterfaces at: selector put: (MethodInterface new initializeFromEToyCommandSpec:  anElement category: aCategorySymbol)]]								ifFalse:  "#slot format"									[selectors add: (selector _ anElement seventh).  "the getter"									selectors add: (anElement at: 9) "the setter".									(methodInterfaces includesKey: selector) ifFalse:										[self addGetterAndSetterInterfacesFromOldSlotSpec: anElement]]]].			(selectors copyWithout: #unused) asSortedArray do:				[:aSelector |					aMethodCategory elementAt: aSelector put: (methodInterfaces at: aSelector)].				 			self addCategory: aMethodCategory].	#(scripts 'instance variables') do: [:sym | self addCategoryNamed: sym].	self setCategoryDocumentationStrings! !!Encoder methodsFor: 'encoding' stamp: 'RAA 2/5/2001 10:44'!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode _ scopeTable at: name			ifAbsent: 				[(self lookupInPools: name 					ifFound: [:assoc | varNode _ self global: assoc name: name])					ifTrue: [varNode]					ifFalse: [action value]].	range ifNotNil: [		name first isUppercase ifTrue:			[globalSourceRanges addLast: { name. range. false }]. ].	(varNode isTemp and: [varNode scope < 0]) ifTrue: [		OutOfScopeNotification signal ifFalse: [ ^self notify: 'out of scope'].	].	^ varNode! !!EventSensor methodsFor: 'accessing' stamp: 'ar 2/7/2001 17:13'!flushEvents	eventQueue ifNotNil:[eventQueue flush].! !!EventSensor methodsFor: 'accessing' stamp: 'RAA 2/10/2001 23:16'!nextEventFromQueue	"Return the next event from the receiver."	eventQueue isEmpty ifTrue:[inputSemaphore signal].	EventPollFrequency _ 500.	"since Squeak is taking the event, reset to normal delay"	eventQueue isEmpty		ifTrue:[^nil]		ifFalse:[^eventQueue next]! !!EventSensor methodsFor: 'accessing' stamp: 'ar 2/14/2001 00:03'!peekButtons	inputSemaphore signal.	^mouseButtons! !!EventSensor methodsFor: 'accessing' stamp: 'ar 2/8/2001 21:45'!peekMousePt	^mousePosition! !!EventSensor methodsFor: 'accessing' stamp: 'ar 2/14/2001 00:01'!peekPosition	inputSemaphore signal. "get latest state"	^mousePosition! !!EventSensor methodsFor: 'private-I/O' stamp: 'RAA 2/10/2001 23:16'!ioProcess	"Run the i/o process"	| eventBuffer type |	eventBuffer _ Array new: 8.	[true] whileTrue:[		[self primGetNextEvent: eventBuffer.		type _ eventBuffer at: 1.		type = EventTypeNone] whileFalse:[self processEvent: eventBuffer].		inputSemaphore waitTimeoutMSecs: EventPollFrequency.	].! !!EventSensor methodsFor: 'private' stamp: 'ar 12/5/2000 13:49'!primKbdNext	inputSemaphore signal.	eventQueue ifNotNil:[eventQueue flush].	keyboardBuffer isEmpty		ifTrue:[^nil]		ifFalse:[^keyboardBuffer next]! !!EventSensor methodsFor: 'private' stamp: 'ar 12/5/2000 13:50'!primKbdPeek	inputSemaphore signal.	eventQueue ifNotNil:[eventQueue flush].	^keyboardBuffer peek! !!EventSensor methodsFor: 'private' stamp: 'ar 12/5/2000 13:50'!primMouseButtons	inputSemaphore signal.	eventQueue ifNotNil:[eventQueue flush].	^mouseButtons! !!EventSensor methodsFor: 'private' stamp: 'ar 12/5/2000 13:50'!primMousePt	inputSemaphore signal.	eventQueue ifNotNil:[eventQueue flush].	^mousePosition! !!EventSensor methodsFor: 'NOTES' stamp: 'RAA 2/10/2001 23:16'!higherPerformanceNotes"This is mostly a Mac issue, but may have some effect on other platforms. These changes do not take effect until you set the preference #higherPerformance to true. The impact of setting this pref to true may be higher performance for this Squeak image, but lower performance for other applications/processes that may be running concurrently. Experiment with your particular configuration/desires and decide for yourself.-- 10 Feb 2001 -- removed item #1 since other changes in event handling made it moot --1. In order to reduce the amount of time lost (perhaps 20 to 30% in some cases) to background applications on the Mac, change the strategy used to poll for UI events. Every time we poll the OS for UI events, increase the delay until the next check. Every time Squeak actually requests an event from EventSensor, reset the delay to its normal value (20 ms). This means that a long-running evaluation started in the UI process will receive less competition from background apps (and less overhead even if it is the only app), but normal UI-intensive operations will happen as they do now. What is lost by this change is some sensitivity to mouse events that occur while Squeak is busy over long periods. My thought is that if Squeak is so occupied for a period of seconds, these events are much less useful and perhaps even harmful.2. Reduce the minimum morphic cycle time (MinCycleLapse) so that the frame rate (and, hence, running of #step methods) can proceed at greater than 50 frames per second. This can be quite beneficial to things like simulations that are run via #step."! !!EventSensor class methodsFor: 'class initialization' stamp: 'RAA 2/10/2001 23:15'!initialize	"EventSensor initialize"	self initializeEventSensorConstants.	EventPollFrequency _ 500.	"Note: The above is important. Most systems will not	notify the VM about the occurance of events asynchronously.	Therefore, we have to go check for ourselves every now and then."! !!FFIPlugin class methodsFor: 'C support code' stamp: 'JMM 2/6/2001 10:55'!sqMacFFIPPCFile^'/*****************************************************************************   PROJECT: Squeak foreign function interface*   FILE:    sqMacFFIPPC.c*   CONTENT: Mac/PPC specific support for the foreign function interface**   AUTHOR:  Andreas Raab (ar)*   ADDRESS: Walt Disney Imagineering, Glendale, CA*   EMAIL:   Andreas.Raab@disney.com*   RCSID:   $Id$**   NOTES:******************************************************************************/#include "sq.h"#include "sqFFI.h"/* note: LONGLONG is usually declared by universal headers */#ifndef LONGLONG#define LONGLONG long long#endifextern struct VirtualMachine *interpreterProxy;#define primitiveFail() interpreterProxy->primitiveFail();#define GP_MAX_REGS 8#define FP_MAX_REGS 13/* Values passed in GPR3-GPR10 */static int GPRegs[8];/* Nr of GPRegs used so far */static int gpRegCount = 0;/* Values passed in FPR1-FPR13 */static double FPRegs[13];/* Nr of FPRegs used so far */static int fpRegCount = 0;/* Max stack size */#define FFI_MAX_STACK 512/* The stack used to assemble the arguments for a call */static int   ffiStack[FFI_MAX_STACK];/* The stack pointer while filling the stack */static int   ffiStackIndex = 0;/* The area for temporarily allocated strings */static char *ffiTempStrings[FFI_MAX_STACK];/* The number of temporarily allocated strings */static int   ffiTempStringCount = 0;/* The return values for calls */static int      intReturnValue;static LONGLONG longReturnValue;static double   floatReturnValue;static int *structReturnValue = NULL;/**************************************************************/#define ARG_CHECK() if(gpRegCount >= GP_MAX_REGS && ffiStackIndex >= FFI_MAX_STACK) return primitiveFail();#define ARG_PUSH(value) { \	ARG_CHECK(); \	if(gpRegCount < GP_MAX_REGS) GPRegs[gpRegCount++] = value; \	ffiStack[ffiStackIndex++] = value; \}/*****************************************************************************//*****************************************************************************//*  ffiInitialize:	Announce that the VM is about to do an external function call. */int ffiInitialize(void){	ffiStackIndex = 0;	gpRegCount = 0;	fpRegCount = 0;	floatReturnValue = 0.0;	return 1;}/*  ffiSupportsCallingConvention:	Return true if the support code supports the given calling convention. */int ffiSupportsCallingConvention(int callType){	if(callType == FFICallTypeCDecl) return 1;	if(callType == FFICallTypeApi) return 1;	return 0;}int ffiAlloc(int byteSize){	return (int) malloc(byteSize);}int ffiFree(int ptr){	if(ptr) free((void*)ptr);	return 1;}/*****************************************************************************//*****************************************************************************/int ffiPushSignedChar(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedChar(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedByte(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedByte(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedShort(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedShort(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedInt(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedInt(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedLongLong(int low, int high){	ARG_PUSH(high);	ARG_PUSH(low);	return 1;}int ffiPushUnsignedLongLong(int low, int high) { 	ARG_PUSH(high); 	ARG_PUSH(low); 	return 1; }int ffiPushSingleFloat(double value){	float floatValue = (float) value;	if(fpRegCount < FP_MAX_REGS) {		/* Still space in FPRegs - so we use the more accurate double value */		FPRegs[fpRegCount++] = value;	}	/* Note: Even for args that are passed in FPRegs 	   we pass the actual 32bit value in either GPRegs	   or stack frame for varargs calls. */	ARG_PUSH(*(int*)(&floatValue));	return 1;}int ffiPushDoubleFloat(double value){	if(fpRegCount < FP_MAX_REGS) {		/* Still space in FPRegs */		FPRegs[fpRegCount++] = value;	}	/* Note: Even for args that are passed in FPRegs 	   we pass the actual 64bit value in either GPRegs	   or stack frame for varargs calls. */	ARG_PUSH(((int*)(&value))[1]);	ARG_PUSH(((int*)(&value))[0]);	return 1;}int ffiPushStructureOfLength(int pointer, int *structSpec, int specSize){	int i, typeSpec;	int *data = (int*) pointer;	for(i = 0; i<specSize; i++) {		typeSpec = structSpec[i];		if(typeSpec & FFIFlagPointer) {			ARG_PUSH(*data);			data++;		} else if(typeSpec & FFIFlagStructure) {			/* embedded structure */		} else {			/* atomic type */			int atomicType = (typeSpec & FFIAtomicTypeMask) >> FFIAtomicTypeShift;			switch(atomicType) {				case FFITypeUnsignedChar:				case FFITypeUnsignedByte:					ffiPushUnsignedByte(*(unsigned char*)data);					break;				case FFITypeSignedChar:				case FFITypeSignedByte:					ffiPushSignedByte(*(signed char*)data);					break;				case FFITypeUnsignedShort:					ffiPushUnsignedShort(*(unsigned short*)data);					break;				case FFITypeSignedShort:					ffiPushSignedShort(*(signed short*)data);					break;				case FFITypeUnsignedInt:					ffiPushUnsignedInt(*(unsigned int*)data);					break;				case FFITypeSignedInt:					ffiPushSignedInt(*(signed int*)data);					break;				case FFITypeUnsignedLongLong:					ffiPushUnsignedLongLong( ((unsigned int*)data)[1], ((unsigned int*)data)[0]);					break;				case FFITypeSignedLongLong:					ffiPushSignedLongLong( ((signed int*)data)[1], ((signed int*)data)[0]);					break;				case FFITypeSingleFloat:					ffiPushSingleFloat( *(float*)data);					break;				case FFITypeDoubleFloat:					{ double fArg;					  ((int*)&fArg)[0] = ((int*)data)[0];					  ((int*)&fArg)[1] = ((int*)data)[1];					  ffiPushDoubleFloat(fArg);					}					break;				default:					return primitiveFail();			}			data = (int*) ((int)data + (typeSpec & FFIStructSizeMask));		}	}	return 1;}int ffiPushPointer(int pointer){	ARG_PUSH(pointer);	return 1;}int ffiPushStringOfLength(int srcIndex, int length){	char *ptr;	ARG_CHECK(); /* fail before allocating */	ptr = (char*) malloc(length+1);	if(!!ptr) return primitiveFail();	memcpy(ptr, (void*)srcIndex, length);	ptr[length] = 0;	ffiTempStrings[ffiTempStringCount++] = ptr;	ARG_PUSH((int)ptr);	return 1;}/*****************************************************************************//*****************************************************************************//*  ffiCanReturn:	Return true if the support code can return the given type. */int ffiCanReturn(int *structSpec, int specSize){	int header = *structSpec;	if(header & FFIFlagPointer) return 1;	if(header & FFIFlagStructure) {		/* structs are always returned as pointers to hidden structures */		int structSize = header & FFIStructSizeMask;		structReturnValue = malloc(structSize);		if(!!structReturnValue) return 0;		ARG_PUSH((int)structReturnValue);	}	return 1;}/*  ffiReturnFloatValue:	Return the value from a previous ffi call with float return type. */double ffiReturnFloatValue(void){	return floatReturnValue;}/*  ffiLongLongResultLow:	Return the low 32bit from the 64bit result of a call to an external function */int ffiLongLongResultLow(void){	return ((int*) &longReturnValue)[1];}/*  ffiLongLongResultHigh:	Return the high 32bit from the 64bit result of a call to an external function */int ffiLongLongResultHigh(void){	return ((int*) &longReturnValue)[0];}/*  ffiStoreStructure:	Store the structure result of a previous ffi call into the given address. */int ffiStoreStructure(int address, int structSize){	if(structReturnValue) {		memcpy((void*)address, (void*)structReturnValue, structSize);	} else {		memcpy((void*)address, (void*)&intReturnValue, structSize);  	}  	return 1;}/*  ffiCleanup:	Cleanup after a foreign function call has completed.	The generic support code only frees the temporarily	allocated strings. */int ffiCleanup(void){	int i;	for(i=0; i<ffiTempStringCount; i++)		free(ffiTempStrings[i]);	ffiTempStringCount = 0;	if(structReturnValue) {		free(structReturnValue);		structReturnValue = NULL;	}	return 1;}/*****************************************************************************//*****************************************************************************/asm int ffiCallAddressOf(int);#if TARGET_CPU_PPCasm int ffiCallAddressOf(int addr) {	/* Save link register */	mflr r0	stw r0, 8(SP)	/* get stack index and preserve it for copying stuff later */	lwz r4, ffiStackIndex(RTOC)	/* compute frame size */	rlwinm r5, r4, 2, 0, 29  /* ffiStackIndex words to bytes (e.g., "slwi r5, r4, 2") */	addi r5, r5, 24 /* linkage area */	neg  r5, r5     /* stack goes down */	/* adjust stack frame */	stwux SP, SP, r5	/* load the stack frame area */	/* note: r4 == ffiStackIndex */	addi r5, SP, 24         /* dst = SP + linkage area */	lwz r6, ffiStack(RTOC)  /* src = ffiStack */	li r7, 0                /* i = 0 */	b nextItemcopyItem:	rlwinm r8, r7, 2, 0, 29 /* r8 = i << 2 (e.g., "slwi r8, r7, 2") */	lwzx r0, r6, r8         /* r0 = ffiStack[r8] */	addi r7, r7, 1          /* i = i + 1 */	stwx r0, r5, r8         /* dst[r8] = r0 */nextItem:	cmpw r7, r4             /* i < ffiStackIndex ? */	blt copyItem	/* Keep addr in GPR0 so we can load all regs beforehand */	mr r0, r3	/* load all the floating point registers */	lwz r3, fpRegCount	lwz r12, FPRegs(RTOC)	cmpwi r3, 0     /* skip all fpregs if no FP values used */	blt _0_fpregs	cmpwi r3, 8	blt _7_fpregs   /* skip last N fpregs if unused */_all_fpregs:	lfd  fp8, 56(r12)	lfd  fp9, 64(r12)	lfd fp10, 72(r12)	lfd fp11, 80(r12)	lfd fp12, 88(r12)	lfd fp13, 96(r12)_7_fpregs:	lfd  fp1,  0(r12)	lfd  fp2,  8(r12)	lfd  fp3, 16(r12)	lfd  fp4, 24(r12)	lfd  fp5, 32(r12)	lfd  fp6, 40(r12)	lfd  fp7, 48(r12)_0_fpregs:	/* load all the general purpose registers */	lwz  r3, gpRegCount	lwz  r12, GPRegs(RTOC)	cmpwi r3, 4	blt _4_gpregs    /* skip last four gpregs if unused */_all_gpregs:	lwz  r7, 16(r12)	lwz  r8, 20(r12)	lwz  r9, 24(r12)	lwz r10, 28(r12)_4_gpregs:	lwz  r3,  0(r12)	lwz  r4,  4(r12)	lwz  r5,  8(r12)	lwz  r6, 12(r12)_0_gpregs:	/* go calling out */	mr r12, r0      /* tvector into GPR12 */	/* Note: The code below is nearly identical to to what''s described in		"MacOS Runtime Architectures"		Chapter 2, Listing 2-2, pp. 2-11	*/	lwz r0, 0(r12)  /* get entry point */	stw r2, 20(SP)  /* save GPR2 */	mtctr r0        /* move entry point into count register */	lwz r2, 4(r12)  /* new base pointer */	bctrl           /* jump through count register and link */	lwz r2, 20(SP)  /* restore GPR2 */	lwz SP, 0(SP)   /* restore frame */	/* store the result of the call */	stw r3, intReturnValue(RTOC)	lwz r12, longReturnValue(RTOC)	stw r3, 0(r12)	stw r4, 4(r12)	stfd fp1, floatReturnValue(RTOC)	/* and get out of here */	lwz r0, 8(SP)	mtlr r0	blr}#elseasm int ffiCallAddressOf(int addr) {}#endifint ffiCallAddressOfWithPointerReturn(int fn, int callType){	return ffiCallAddressOf(fn);}int ffiCallAddressOfWithStructReturn(int fn, int callType, int* structSpec, int specSize){	return ffiCallAddressOf(fn);}int ffiCallAddressOfWithReturnType(int fn, int callType, int typeSpec){	return ffiCallAddressOf(fn);}/*****************************************************************************//*****************************************************************************//*****************************************************************************//************ Test functions for the foreign function interface **************//*****************************************************************************//*****************************************************************************//*****************************************************************************/#ifndef NO_FFI_TESTtypedef struct ffiTestPoint2 {	int x;	int y;} ffiTestPoint2;typedef struct ffiTestPoint4 {	int x;	int y;	int z;	int w;} ffiTestPoint4;#pragma export onEXPORT(char) ffiTestChars(char c1, char c2, char c3, char c4);EXPORT(short) ffiTestShorts(short c1, short c2, short c3, short c4);EXPORT(int) ffiTestInts(int c1, int c2, int c3, int c4);EXPORT(float) ffiTestFloats(float f1, float f2);EXPORT(double) ffiTestDoubles(double d1, double d2);EXPORT(char *) ffiPrintString(char *string);EXPORT(ffiTestPoint2) ffiTestStruct64(ffiTestPoint2 pt1, ffiTestPoint2 pt2);EXPORT(ffiTestPoint4) ffiTestStructBig(ffiTestPoint4 pt1, ffiTestPoint4 pt2);EXPORT(ffiTestPoint4*) ffiTestPointers(ffiTestPoint4 *pt1, ffiTestPoint4 *pt2);EXPORT(LONGLONG) ffiTestLongLong(LONGLONG i1, LONGLONG i2);#pragma export off/* test passing characters */EXPORT(char) ffiTestChars(char c1, char c2, char c3, char c4) {	printf("4 characters came in as\nc1 = %c (%x)\nc2 = %c (%x)\nc3 = %c (%x)\nc4 = %c (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return ''C'';}/* test passing shorts */EXPORT(short) ffiTestShorts(short c1, short c2, short c3, short c4) {	printf("4 shorts came in as\ns1 = %d (%x)\ns2 = %d (%x)\ns3 = %d (%x)\ns4 = %d (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return -42;}/* test passing ints */EXPORT(int) ffiTestInts(int c1, int c2, int c3, int c4) {	printf("4 ints came in as\ni1 = %d (%x)\ni2 = %d (%x)\ni3 = %d (%x)\ni4 = %d (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return 42;}/* test passing and returning floats */EXPORT(float) ffiTestFloats(float f1, float f2) {	printf("The two floats are %f and %f\n", f1, f2);	return (float) (f1 + f2);}/* test passing and returning doubles */EXPORT(double) ffiTestDoubles(double d1, double d2) {	printf("The two floats are %f and %f\n", (float)d1, (float)d2);	return d1+d2;}/* test passing and returning strings */EXPORT(char*) ffiPrintString(char *string) {	printf("%s\n", string);	return string;}/* test passing and returning 64bit structures */EXPORT(ffiTestPoint2) ffiTestStruct64(ffiTestPoint2 pt1, ffiTestPoint2 pt2) {	ffiTestPoint2 result;	printf("pt1.x = %d\npt1.y = %d\npt2.x = %d\npt2.y = %d\n",			pt1.x, pt1.y, pt2.x, pt2.y);	result.x = pt1.x + pt2.x;	result.y = pt1.y + pt2.y;	return result;}/* test passing and returning large structures */EXPORT(ffiTestPoint4) ffiTestStructBig(ffiTestPoint4 pt1, ffiTestPoint4 pt2) {	ffiTestPoint4 result;	printf("pt1.x = %d\npt1.y = %d\npt1.z = %d\npt1.w = %d\n",			pt1.x, pt1.y, pt1.z, pt1.w);	printf("pt2.x = %d\npt2.y = %d\npt2.z = %d\npt2.w = %d\n",			pt2.x, pt2.y, pt2.z, pt2.w);	result.x = pt1.x + pt2.x;	result.y = pt1.y + pt2.y;	result.z = pt1.z + pt2.z;	result.w = pt1.w + pt2.w;	return result;}/* test passing and returning pointers */EXPORT(ffiTestPoint4*) ffiTestPointers(ffiTestPoint4 *pt1, ffiTestPoint4 *pt2) {	ffiTestPoint4 *result;	printf("pt1.x = %d\npt1.y = %d\npt1.z = %d\npt1.w = %d\n",			pt1->x, pt1->y, pt1->z, pt1->w);	printf("pt2.x = %d\npt2.y = %d\npt2.z = %d\npt2.w = %d\n",			pt2->x, pt2->y, pt2->z, pt2->w);	result = (ffiTestPoint4*) malloc(sizeof(ffiTestPoint4));	result->x = pt1->x + pt2->x;	result->y = pt1->y + pt2->y;	result->z = pt1->z + pt2->z;	result->w = pt1->w + pt2->w;	return result;}/* test passing and returning longlongs */EXPORT(LONGLONG) ffiTestLongLong(LONGLONG i1, LONGLONG i2) {	return i1 + i2;}#endif /* NO_FFI_TEST */'! !!FXBltSimulation methodsFor: 'inner loop' stamp: 'ar 2/10/2001 00:21'!copyLoopPixels	"This version of the inner loop maps source pixels and dest pixels one at a time. This is the most general (and slowest) version which must also keep track of source and dest paint mode by itself."	| nPix srcShift dstShift destWord srcIndex dstIndex nLines sourceWord lastSrcPix sourcePix srcMask dstMask srcMapped lastDstPix destPix dstMapped resultMapped resultPix srcPaint dstPaint paintMode mergeFn |	self inline: false.	mergeFn _ opTable at: combinationRule+1.	srcPaint _ srcKeyMode.	dstPaint _ dstKeyMode.	paintMode _ srcPaint | dstPaint.	"Additional inits"	srcMask _ maskTable at: sourceDepth.	dstMask _ maskTable at: destDepth.	sourceIndex _ srcIndex _ sourceBits + (sy * sourcePitch) + ((sx // sourcePPW) *4).	dstIndex _ destIndex.	"Precomputed shifts for pickSourcePixels"	srcShift _ ((sx bitAnd: sourcePPW - 1) * sourceDepth).	dstShift _ ((dx bitAnd: destPPW - 1) * destDepth).	sourceMSB ifTrue:[srcShift _ 32 - sourceDepth - srcShift].	destMSB ifTrue:[dstShift _ 32 - destDepth - dstShift].	srcBitShift _ srcShift.	dstBitShift _ dstShift.	noSourceMap 		ifTrue:[pixelDepth _ sourceDepth]		ifFalse:[pixelDepth _ 32].	destMask _ -1.	nLines _ bbH.	["this is the vertical loop"		sourceWord _ self srcLongAt: srcIndex.		destWord _ self dstLongAt: dstIndex.		"Prefetch first source pixel"		lastSrcPix _ sourcePix _ sourceWord >> srcShift bitAnd: srcMask.		srcMapped _ self mapSourcePixel: sourcePix.		"Prefetch first dest pixel"		lastDstPix _ destPix _ destWord >> dstShift bitAnd: dstMask.		dstMapped _ self mapDestPixel: destPix.		nPix _ bbW.		["this is the horizontal loop"			(paintMode) ifTrue:[				((srcPaint and:[sourcePix = sourceAlphaKey])					or:[dstPaint and:[destPix ~= destAlphaKey]])						ifTrue:[resultMapped _ dstMapped]						ifFalse:[	resultMapped _ self merge: srcMapped with: dstMapped function: mergeFn].			] ifFalse:[				resultMapped _ self merge: srcMapped with: dstMapped function: mergeFn.			].			(noColorMap and:[resultMapped = dstMapped]) ifFalse:[				resultPix _ self mapPixel: resultMapped.				destWord _ destWord bitAnd: (dstMask << dstShift) bitInvert32.				destWord _ destWord bitOr: (resultPix bitAnd: dstMask) << dstShift.			].			sourceMSB ifTrue:[				"Adjust source if at pixel boundary"				(srcShift _ srcShift - sourceDepth) < 0 ifTrue:					[srcShift _ srcShift + 32.					sourceWord _ self srcLongAt: (srcIndex _ srcIndex + 4)].			] ifFalse:[				"Adjust source if at pixel boundary"				(srcShift _ srcShift + sourceDepth) > 31 ifTrue:					[srcShift _ srcShift - 32.					sourceWord _ self srcLongAt: (srcIndex _ srcIndex + 4)].			].			destMSB ifTrue:[				"Adjust dest if at pixel boundary"				(dstShift _ dstShift - destDepth) < 0 ifTrue:					[dstShift _ dstShift + 32.					self dstLongAt: dstIndex put: destWord.					destWord _ self dstLongAt: (dstIndex _ dstIndex + 4)].			] ifFalse:[				"Adjust dest if at pixel boundary"				(dstShift _ dstShift + destDepth) > 31 ifTrue:					[dstShift _ dstShift - 32.					self dstLongAt: dstIndex put: destWord.					destWord _ self dstLongAt: (dstIndex _ dstIndex + 4)].			].		(nPix _ nPix - 1) = 0] whileFalse:[			"Fetch next source/dest pixel"			sourcePix _ sourceWord >> srcShift bitAnd: srcMask.			lastSrcPix = sourcePix ifFalse:[				srcMapped _ self mapSourcePixel: sourcePix.				lastSrcPix _ sourcePix].			destPix _ destWord >> dstShift bitAnd: dstMask.			lastDstPix = destPix ifFalse:[				dstMapped _ self mapDestPixel: destPix.				lastDstPix _ destPix]		].	(nLines _ nLines - 1) = 0] whileFalse:[		"Store last destWord"		self dstLongAt: dstIndex put: destWord.		"Advance sourceIndex, destIndex"		srcIndex _ sourceIndex _ sourceIndex + sourcePitch.		dstIndex _ destIndex _ destIndex + destPitch.		srcShift _ srcBitShift.		dstShift _ dstBitShift.	].	dstIndex <= (destIndex + destPitch + 4) ifTrue:[		"Store final destWord but not beyound range"		self dstLongAt: dstIndex put: destWord.	].! !!FXBltSimulation class methodsFor: 'translation' stamp: 'hg 2/2/2001 14:36'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator		var: 'colorMap' declareC:'int *colorMap';		var: 'cmShiftTable' declareC:'int *cmShiftTable';		var: 'cmMaskTable' declareC:'int *cmMaskTable';		var: 'sourceMap' declareC:'int *sourceMap';		var: 'smShiftTable' declareC:'int *smShiftTable';		var: 'smMaskTable' declareC:'int *smMaskTable';		var: 'destMap' declareC:'int *destMap';		var: 'dmShiftTable' declareC:'int *dmShiftTable';		var: 'dmMaskTable' declareC:'int *dmMaskTable';		var: 'warpQuad' declareC:'int warpQuad[8]';		var: 'tallyMap' declareC:'int *tallyMap'.	aCCodeGenerator var: 'opTable'		declareC: 'int opTable[' , OpTableSize printString , ']'.	aCCodeGenerator var: 'maskTable'		declareC:'int maskTable[33] = {0, 1, 3, 0, 15, 31, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 65535,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}'.	aCCodeGenerator var: 'ditherMatrix4x4'		declareC:'const int ditherMatrix4x4[16] = {0,	8,	2,	10,12,	4,	14,	6,3,	11,	1,	9,15,	7,	13,	5}'.	aCCodeGenerator var: 'ditherThresholds16'		declareC:'const int ditherThresholds16[8] = { 0, 2, 4, 6, 8, 12, 14, 16 }'.	aCCodeGenerator var: 'ditherValues16'		declareC:'const int ditherValues16[32] = {0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}'.	aCCodeGenerator var: 'warpBitShiftTable'		declareC:'int warpBitShiftTable[32]'.! !!FXBltSimulator methodsFor: 'as yet unclassified' stamp: 'hg 2/2/2001 15:55'!initBBOpTable	opTable _ OpTable.	maskTable _ Array new: 32.	#(1 2 4 5 8 16 32) do:[:i| maskTable at: i put: (1 << i)-1].	self initializeDitherTables.	warpBitShiftTable _ CArrayAccessor on: (Array new: 32).	cmCache _ CArrayAccessor on: (Array new: ColorCacheSize*2).	warpQuad _ CArrayAccessor on: (Array new: 8).! !!FileDirectory methodsFor: 'enumeration' stamp: 'ar 2/6/2001 15:48'!localName	"Return the local name of this directory."	^FileDirectory localNameFor: pathName! !!FileDirectory methodsFor: 'file directory' stamp: 'ar 2/6/2001 15:48'!assureExistance	"Make sure the current directory exists. If necessary, create all parts inbetween"	^self containingDirectory assureExistanceOfPath: self localName! !!FileDirectory methodsFor: 'file directory' stamp: 'ar 2/6/2001 15:50'!assureExistanceOfPath: localPath	"Make sure the local directory exists. If necessary, create all parts inbetween"	(self directoryNames includes: localPath) ifTrue:[^self]. "exists"	"otherwise check parent first and then create local dir"	self containingDirectory assureExistanceOfPath: self localName.	self createDirectory: localPath.! !!FileDirectory class methodsFor: 'name utilities' stamp: 'ar 2/12/2001 15:45'!startUp	"Establish the platform-specific FileDirectory subclass. Do any platform-specific startup."	self setDefaultDirectoryFrom: Smalltalk imageName.	Preferences startInUntrustedDirectory 		ifTrue:[	self setDefaultDirectory: SecurityManager default untrustedUserDirectory.				"Make sure we have a place to go to"				DefaultDirectory assureExistance].	Smalltalk openSourceFiles.! !!FileDirectory class methodsFor: 'system start up' stamp: 'ar 2/12/2001 15:30'!openChanges: changesName forImage: imageName	"Initialize the default directory to the image directory and open the  	sources and changes files, if possible. Look for the changes file in  	image directory. Look for the system sources (or an alias to it) first in  	the VM directory, then in the image directory. Open the changes and  	sources files and install them in SourceFiles."	| changes fd |	"look for the changes file or an alias to it in the image directory"	fd _ FileDirectory on: (FileDirectory dirPathFor: imageName).	(fd fileExists: changesName)		ifTrue: [changes _ fd oldFileNamed: changesName].	changes ifNotNil:[^changes].	"look for the changes in the current directory"	fd _ DefaultDirectory.	(fd fileExists: changesName)		ifTrue: [changes _ fd oldFileNamed: changesName].	changes ifNotNil:[^changes].	"look for read-only changes in the image directory"	fd _ FileDirectory on: (FileDirectory dirPathFor: imageName).	(fd fileExists: changesName)		ifTrue: [changes _ fd readOnlyFileNamed: changesName].	changes ifNotNil:[^changes].	"look for read-only changes in the current directory"	fd _ DefaultDirectory.	(fd fileExists: changesName)		ifTrue: [changes _ fd readOnlyFileNamed: changesName].	^changes! !!FileDirectory class methodsFor: 'system start up' stamp: 'ar 2/12/2001 15:23'!openSources: sourcesName andChanges: changesName forImage: imageName 	"Initialize the default directory to the image directory and open the  	sources and changes files, if possible. Look for the changes file in  	image directory. Look for the system sources (or an alias to it) first in  	the VM directory, then in the image directory. Open the changes and  	sources files and install them in SourceFiles."	"Note: SourcesName and imageName are full paths; changesName is a  	local name."	| sources changes msg wmsg |	msg _ 'Squeak cannot locate &fileRef.Please check that the file is named properly and is in thesame directory as this image.  Further explanation can foundin the startup window, ''How Squeak Finds Source Code''.'.	wmsg _ 'Squeak cannot write to &fileRef.Please check that you have write permission for this file.You won''t be able to save this image correctly until you fix this.'.	sources _ self openSources: sourcesName forImage: imageName.	changes _ self openChanges: changesName forImage: imageName.	((sources == nil or: [sources atEnd])		and: [Preferences valueOfFlag: #warnIfNoSourcesFile])		ifTrue: 			[PopUpMenu notify: (msg copyReplaceAll: '&fileRef' with: 'the sources file named ' , sourcesName).			Smalltalk platformName = 'Mac OS'				ifTrue: [PopUpMenu notify: 'Make sure the sources file is not an Alias.']].	(changes == nil and: [Preferences valueOfFlag: #warnIfNoChangesFile])		ifTrue: [PopUpMenu notify: (msg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName)].	(Preferences valueOfFlag: #warnIfNoChangesFile) ifTrue: [		changes isReadOnly ifTrue:[			PopUpMenu notify: 				(wmsg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName)].		((changes next: 200) includesSubString: String crlf) ifTrue: [			PopUpMenu notify: 'The changes file named ' , changesName, 'has been injured by an unpacking utility.  Crs were changed to CrLfs.Please set the preferences in your decompressing program to "do not convert text files" and unpack the system again.']].	SourceFiles _ Array with: sources with: changes! !!FileDirectory class methodsFor: 'system start up' stamp: 'ar 2/12/2001 15:19'!openSources: fullSourcesName forImage: imageName 	"Initialize the default directory to the image directory and open the  	sources and changes files, if possible. Look for the changes file in  	image directory. Look for the system sources (or an alias to it) first in  	the VM directory, then in the image directory. Open the changes and  	sources files and install them in SourceFiles."	| sources fd sourcesName |	sourcesName _ FileDirectory localNameFor: fullSourcesName.	"look for the sources file or an alias to it in the VM's directory"	fd _ FileDirectory on: Smalltalk vmPath.	(fd fileExists: sourcesName)		ifTrue: [sources _ fd readOnlyFileNamed: sourcesName].	sources ifNotNil:[^sources].	"look for the sources file or an alias to it in the image directory"	fd _ FileDirectory on: (FileDirectory dirPathFor: imageName).	(fd fileExists: sourcesName)		ifTrue: [sources _ fd readOnlyFileNamed: sourcesName].	sources ifNotNil:[^sources].	"look for the sources in the current directory"	fd _ DefaultDirectory.	(fd fileExists: sourcesName)		ifTrue: [sources _ fd readOnlyFileNamed: sourcesName].	^sources! !!FileDirectory class methodsFor: 'system start up' stamp: 'ar 2/12/2001 15:39'!setDefaultDirectory: directoryName	"Initialize the default directory to the directory supplied. This method is called when the image starts up."	| dirName |	DirectoryClass _ self activeDirectoryClass.	dirName _ directoryName.	[dirName endsWith: self slash] whileTrue:[		dirName _ dirName copyFrom: 1 to: dirName size - self slash size.	].	DefaultDirectory _ self on: dirName.! !!FileDirectoryWrapper methodsFor: 'as yet unclassified' stamp: 'ar 2/12/2001 16:20'!contents	^((model directoryNamesFor: item) sortBy: [ :a :b | a caseInsensitiveLessOrEqual: b]) collect: [ :n | 		FileDirectoryWrapper with: (item directoryNamed: n) name: n model: self	]! !!FileDirectoryWrapper methodsFor: 'as yet unclassified' stamp: 'ar 2/12/2001 16:22'!directoryNamesFor: anItem	^model directoryNamesFor: anItem! !!FileList methodsFor: 'file list menu' stamp: 'sw 2/16/2001 16:22'!fileSelectedMenu: aMenu	"Fill the menu with items appropriate for the selected file type, or for all file types if the shift key is down"	| firstItems secondItems thirdItems n1 n2 n3 |	firstItems _ self itemsForFileEnding:		(Sensor leftShiftDown			ifFalse:				[self fileNameSuffix asLowercase]			ifTrue:				['*']).	secondItems _ self itemsForAnyFile.	thirdItems _ self itemsForNoFile.	n1 _ firstItems first size.	n2 _ n1 + secondItems first size.	n3 _ n2 + thirdItems first size.	^ aMenu		labels: firstItems first , secondItems first , thirdItems first , #('more...')		lines: firstItems second				, (Array with: n1 with: n2)				, (thirdItems second collect: [:n | n + n2])				, (Array with: n3)		selections: firstItems third , secondItems third , thirdItems third , #(offerAllFileOptions)! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'ar 2/12/2001 16:20'!directoryNamesFor: item	"item may be file directory or server directory"	| entries |	entries _ item directoryNames.	dirSelectionBlock ifNotNil:[entries _ entries select: dirSelectionBlock].	^entries! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'ar 2/12/2001 16:12'!initialDirectoryList	| dir nameToShow dirList |	dirList _ (FileDirectory on: '') directoryNames collect: [ :each |		FileDirectoryWrapper with: (FileDirectory on: each) name: each model: self].	dirList isEmpty ifTrue:[		dirList _ Array with: (FileDirectoryWrapper 			with: FileDirectory default 			name: FileDirectory default localName 			model: self)].	dirList _ dirList,(		ServerDirectory serverNames collect: [ :n | 			dir _ ServerDirectory serverNamed: n.			nameToShow _ n.			(dir directoryWrapperClass with: dir name: nameToShow model: self)				balloonText: dir realUrl		]	).	^dirList! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 2/17/2001 12:25'!limitedSuperSwikiDirectoryList	| dir nameToShow dirList |	dirList _ OrderedCollection new.	ServerDirectory serverNames do: [ :n | 		dir _ ServerDirectory serverNamed: n.		(dir isKindOf: SuperSwikiServer) ifTrue: [			nameToShow _ n.			dirList add: ((dir directoryWrapperClass with: dir name: nameToShow model: self)				balloonText: dir realUrl)		].	].	{Project current squeakletDirectory} do: [ :each |		dirList add: (FileDirectoryWrapper with: each name: each localName model: self)	].	^dirList! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 2/17/2001 12:48'!limitedSuperSwikiPublishDirectoryList	| dir nameToShow dirList |	dirList _ OrderedCollection new.	ServerDirectory serverNames do: [ :n | 		dir _ ServerDirectory serverNamed: n.		(dir isKindOf: SuperSwikiServer) ifTrue: [			nameToShow _ n.			dirList add: ((dir directoryWrapperClass with: dir name: nameToShow model: self)				balloonText: dir realUrl)		].	].	^dirList! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 2/17/2001 12:18'!morphicDirectoryTreePane	^self morphicDirectoryTreePaneFiltered: #initialDirectoryList! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 2/17/2001 12:17'!morphicDirectoryTreePaneFiltered: aSymbol	^(SimpleHierarchicalListMorph 		on: self		list: aSymbol		selected: #getSelectedDirectory		changeSelected: #setSelectedDirectoryTo:		menu: nil		keystroke: nil) autoDeselect: false		! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 2/17/2001 12:26'!morphicViewProjectLoader2InWorld: aWorld reallyLoad: aBoolean dirFilterType: aSymbol	| window aFileList buttons treePane textColor1 fileListPane pane2a pane2b |	window _ AlignmentMorphBob1 newColumn.	window hResizing: #shrinkWrap; vResizing: #shrinkWrap.	textColor1 _ Color r: 0.742 g: 0.839 b: 1.0.	aFileList _ self new directory: FileDirectory default.	aFileList 		optionalButtonSpecs: self specsForProjectLoader;		fileSelectionBlock: self projectOnlySelectionBlock;		"dirSelectionBlock: self hideSqueakletDirectoryBlock;"		modalView: window.	window		setProperty: #FileList toValue: aFileList;		wrapCentering: #center; cellPositioning: #topCenter;		borderWidth: 4;		borderColor: (Color r: 0.355 g: 0.516 b: 1.0);		useRoundedCorners.	buttons _ #('OK' 'Cancel') collect: [ :each |		self blueButtonText: each textColor: textColor1 inWindow: window	].	(treePane _ aFileList morphicDirectoryTreePaneFiltered: aSymbol)		extent: 250@300; 		retractable: false;		borderWidth: 0.	fileListPane _ aFileList morphicFileListPane 		extent: 350@300; 		retractable: false;		borderWidth: 0.	window		addARow: {			window fancyText: 'Load A Project' ofSize: 21 color: textColor1		};		addARowCentered: {			buttons first. 			(Morph new extent: 30@5) color: Color transparent. 			buttons second		};		addARow: {			window fancyText: 'Please select a project' ofSize: 21 color: Color blue		};		addARow: {			(window inAColumn: {(pane2a _ window inARow: {window inAColumn: {treePane}}) 				useRoundedCorners; layoutInset: 6}) layoutInset: 10.			(window inAColumn: {(pane2b _ window inARow: {window inAColumn: {fileListPane}}) 				useRoundedCorners; layoutInset: 6}) layoutInset: 10.		}.	window fullBounds.	window fillWithRamp: self blueRamp1 oriented: 0.65.	pane2a fillWithRamp: self blueRamp3 oriented: (0.7 @ 0.35).	pane2b fillWithRamp: self blueRamp3 oriented: (0.7 @ 0.35).	buttons do: [ :each |		each fillWithRamp: self blueRamp2 oriented: (0.75 @ 0).	].	buttons first 		on: #mouseUp 		send: (aBoolean ifTrue: [#okHitForProjectLoader] ifFalse: [#okHit])		to: aFileList.	buttons second on: #mouseUp send: #cancelHit to: aFileList.	aFileList postOpen.	window position: aWorld topLeft + (aWorld extent - window extent // 2).	^ window openInWorld: aWorld.! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 2/17/2001 13:03'!morphicViewProjectSaverFor: aProject"(FileList2 morphicViewProjectSaverFor: Project current) openInWorld"	| window aFileList buttons treePane pane2 textColor1 option |	textColor1 _ Color r: 0.742 g: 0.839 b: 1.0.	aFileList _ self new directory: FileDirectory default.	aFileList dirSelectionBlock: self hideSqueakletDirectoryBlock.	window _ AlignmentMorphBob1 newColumn.	window hResizing: #shrinkWrap; vResizing: #shrinkWrap.	aFileList modalView: window.	window		setProperty: #FileList toValue: aFileList;		wrapCentering: #center; cellPositioning: #topCenter;		borderWidth: 4;		borderColor: (Color r: 0.355 g: 0.516 b: 1.0);		useRoundedCorners.	buttons _ #( ('OK' okHit) ('Cancel' cancelHit) ) collect: [ :each |		(self blueButtonText: each first textColor: textColor1 inWindow: window)			on: #mouseUp send: each second to: aFileList	].	option _ aProject world 		valueOfProperty: #SuperSwikiPublishOptions 		ifAbsent: [#initialDirectoryList].	aProject world removeProperty: #SuperSwikiPublishOptions.	(treePane _ aFileList morphicDirectoryTreePaneFiltered: option) 		extent: 350@300; 		retractable: false;		borderWidth: 0.	window		addARowCentered: {			window fancyText: 'Publish This Project' ofSize: 21 color: textColor1		};		addARowCentered: {			buttons first. 			(Morph new extent: 30@5) color: Color transparent. 			buttons second		};		addARowCentered: { (window inAColumn: {(ProjectViewMorph on: aProject) lock}) layoutInset: 4};		addARowCentered: {			window fancyText: 'Please select a folder' ofSize: 21 color: Color blue		};		addARow: {			(				window inAColumn: {					(pane2 _ window inARow: {window inAColumn: {treePane}}) 						useRoundedCorners; layoutInset: 6				}			) layoutInset: 10		}.	window fullBounds.	window fillWithRamp: self blueRamp1 oriented: 0.65.	pane2 fillWithRamp: self blueRamp3 oriented: (0.7 @ 0.35).	buttons do: [ :each |		each fillWithRamp: self blueRamp2 oriented: (0.75 @ 0).	].	window setProperty: #morphicLayerNumber toValue: 11.	aFileList postOpen.	^ window ! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 2/5/2001 18:09'!primitiveFileDelete	| namePointer nameIndex nameSize |	self var: 'nameIndex' type: 'char *'.	self export: true.	namePointer _ interpreterProxy stackValue: 0.	(interpreterProxy isBytes: namePointer) 		ifFalse:[^interpreterProxy primitiveFail].	nameIndex _ interpreterProxy firstIndexableField: namePointer.	nameSize _ interpreterProxy byteSizeOf: namePointer.	(self ioCanDeleteFile: nameIndex OfSize: nameSize)		ifFalse:[^interpreterProxy primitiveFail].	self sqFileDeleteName: (self cCoerce: nameIndex to: 'int') Size: nameSize.	interpreterProxy failed 		ifFalse:[interpreterProxy pop: 1. "pop name, leave rcvr on stack" ].! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 2/6/2001 17:53'!primitiveFileFlush	| file |	self var: 'file' declareC: 'SQFile *file'.	self export: true.	file _ self fileValueOf: (interpreterProxy stackValue: 0).	interpreterProxy failed ifFalse:[self sqFileFlush: file].	interpreterProxy failed ifFalse: [interpreterProxy pop: 1].! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 2/5/2001 18:09'!primitiveFileOpen	| writeFlag namePointer filePointer file nameIndex nameSize |	self var: 'file' declareC: 'SQFile *file'.	self var: 'nameIndex' type:'char *'.	self export: true.	writeFlag _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).	namePointer _ interpreterProxy stackValue: 1.	(interpreterProxy isBytes: namePointer) 		ifFalse:[^interpreterProxy primitiveFail].	filePointer _ interpreterProxy 					instantiateClass: (interpreterProxy classByteArray)					indexableSize: self fileRecordSize.	file _ self fileValueOf: filePointer.	nameIndex _ interpreterProxy firstIndexableField: namePointer.	nameSize _ interpreterProxy byteSizeOf: namePointer.	(self ioCanOpenFile: nameIndex OfSize: nameSize Writable: writeFlag)		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self cCode: 'sqFileOpen(file, (int)nameIndex, nameSize, writeFlag)'.	].	interpreterProxy failed ifFalse:[		interpreterProxy pop: 3.  "rcvr, name, writeFlag"		interpreterProxy push: filePointer.	].! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 2/5/2001 18:10'!primitiveFileRename	| oldNamePointer newNamePointer oldNameIndex oldNameSize newNameIndex newNameSize |	self var: 'oldNameIndex' type: 'char *'.	self var: 'newNameIndex' type: 'char *'.	self export: true.	newNamePointer _ interpreterProxy stackValue: 0.	oldNamePointer _ interpreterProxy stackValue: 1.	((interpreterProxy isBytes: newNamePointer) and:[		(interpreterProxy isBytes: oldNamePointer)])			ifFalse:[^interpreterProxy primitiveFail].	newNameIndex _ interpreterProxy firstIndexableField: newNamePointer.	newNameSize _ interpreterProxy byteSizeOf: newNamePointer.	oldNameIndex _ interpreterProxy firstIndexableField: oldNamePointer.	oldNameSize _ interpreterProxy byteSizeOf: oldNamePointer.	(self ioCanRenameFile: oldNameIndex OfSize: oldNameSize)		ifFalse:[^interpreterProxy primitiveFail].	self sqFileRenameOld: (self cCoerce: oldNameIndex to: 'int') Size: oldNameSize New: (self cCoerce: newNameIndex to: 'int') Size: newNameSize.	interpreterProxy failed ifFalse:[		interpreterProxy pop: 2.  "pop new and old names, leave rcvr on stack"	].! !!FilePlugin methodsFor: 'directory primitives' stamp: 'ar 2/6/2001 12:55'!primitiveDirectoryCreate	| dirName dirNameIndex dirNameSize |	self var: #dirNameIndex type: 'char *'.	self export: true.	dirName _ interpreterProxy stackValue: 0.	(interpreterProxy isBytes: dirName) ifFalse:[^interpreterProxy primitiveFail].	dirNameIndex _ interpreterProxy firstIndexableField: dirName.	dirNameSize _ interpreterProxy byteSizeOf: dirName.	(self ioCanCreatePath: dirNameIndex OfSize: dirNameSize)		ifFalse:[^interpreterProxy primitiveFail].	(self cCode: 'dir_Create((char *) dirNameIndex, dirNameSize)'		inSmalltalk:[false])		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.  "pop dirName; leave rcvr on stack"! !!FilePlugin methodsFor: 'directory primitives' stamp: 'ar 2/5/2001 18:04'!primitiveDirectoryDelete	| dirName dirNameIndex dirNameSize |	self var: #dirNameIndex type: 'char *'.	self export: true.	dirName _ interpreterProxy stackValue: 0.	(interpreterProxy isBytes: dirName) ifFalse:[^interpreterProxy primitiveFail].	dirNameIndex _ interpreterProxy firstIndexableField: dirName.	dirNameSize _ interpreterProxy byteSizeOf: dirName.	(self ioCanDeletePath: dirNameIndex OfSize: dirNameSize)		ifFalse:[^interpreterProxy primitiveFail].	(self cCode: 'dir_Delete((char *) dirNameIndex, dirNameSize)'		inSmalltalk:[false])		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.  "pop dirName; leave rcvr on stack"! !!FilePlugin methodsFor: 'directory primitives' stamp: 'ar 2/5/2001 18:14'!primitiveDirectoryGetMacTypeAndCreator	| creatorString typeString fileName creatorStringIndex typeStringIndex fileNameIndex fileNameSize |	self var: 'creatorStringIndex' type: 'char *'.	self var: 'typeStringIndex' type: 'char *'.	self var: 'fileNameIndex' type: 'char *'.	self export: true.	creatorString _ interpreterProxy stackValue: 0.	typeString _ interpreterProxy stackValue: 1.	fileName _ interpreterProxy stackValue: 2.	((interpreterProxy isBytes: creatorString) and: [(interpreterProxy byteSizeOf: creatorString) = 4]) ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isBytes: typeString) and: [(interpreterProxy byteSizeOf: typeString) = 4]) ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isBytes: fileName) ifFalse:[^interpreterProxy primitiveFail].	creatorStringIndex _ interpreterProxy firstIndexableField: creatorString.	typeStringIndex _ interpreterProxy firstIndexableField: typeString.	fileNameIndex _ interpreterProxy firstIndexableField: fileName.	fileNameSize _ interpreterProxy byteSizeOf: fileName.	(self ioCanGetFileType: fileNameIndex OfSize: fileNameSize)		ifFalse:[^interpreterProxy primitiveFail].	(self cCode: 'dir_GetMacFileTypeAndCreator(			(char *) fileNameIndex, fileNameSize,			(char *) typeStringIndex, (char *) creatorStringIndex)'		inSmalltalk:[true]) ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 3.  "pop filename, type, creator; leave rcvr on stack"! !!FilePlugin methodsFor: 'directory primitives' stamp: 'ar 2/5/2001 18:07'!primitiveDirectoryLookup	| index pathName pathNameIndex pathNameSize status entryName entryNameSize createDate modifiedDate dirFlag fileSize |	self var: 'entryName' declareC: 'char entryName[256]'.	self var: 'pathNameIndex' type: 'char *'.	self export: true.	index _ interpreterProxy stackIntegerValue: 0.	pathName _ interpreterProxy stackValue: 1.	(interpreterProxy isBytes: pathName) ifFalse:[^interpreterProxy primitiveFail].	pathNameIndex _ interpreterProxy firstIndexableField: pathName.	pathNameSize _ interpreterProxy byteSizeOf: pathName.	(self ioCanListPath: pathNameIndex OfSize: pathNameSize) ifTrue:[		status _ self cCode:			'dir_Lookup(				(char *) pathNameIndex, pathNameSize, index,				entryName, &entryNameSize, &createDate, &modifiedDate,				&dirFlag, &fileSize)'.	] ifFalse:[		status _ DirNoMoreEntries.	].	interpreterProxy failed ifTrue:[^nil].	status = DirNoMoreEntries ifTrue: [		"no more entries; return nil"		interpreterProxy pop: 3.  "pop pathName, index, rcvr"		interpreterProxy push: interpreterProxy nilObject.		^ nil	].	status = DirBadPath ifTrue: [ ^ interpreterProxy primitiveFail ].  "bad path"	interpreterProxy pop: 3.  "pop pathName, index, rcvr"	interpreterProxy push:			(self makeDirEntryName: entryName size: entryNameSize				createDate: createDate modDate: modifiedDate				isDir: dirFlag fileSize: fileSize).! !!FilePlugin methodsFor: 'directory primitives' stamp: 'ar 2/5/2001 18:08'!primitiveDirectorySetMacTypeAndCreator	| creatorString typeString fileName creatorStringIndex typeStringIndex fileNameIndex fileNameSize |	self var: 'creatorStringIndex' type: 'char *'.	self var: 'typeStringIndex' type: 'char *'.	self var: 'fileNameIndex' type: 'char *'.	self export: true.	creatorString _ interpreterProxy stackValue: 0.	typeString _ interpreterProxy stackValue: 1.	fileName _ interpreterProxy stackValue: 2.	((interpreterProxy isBytes: creatorString) and: [(interpreterProxy byteSizeOf: creatorString) = 4]) ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isBytes: typeString) and: [(interpreterProxy byteSizeOf: typeString) = 4]) ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isBytes: fileName) ifFalse:[^interpreterProxy primitiveFail].	creatorStringIndex _ interpreterProxy firstIndexableField: creatorString.	typeStringIndex _ interpreterProxy firstIndexableField: typeString.	fileNameIndex _ interpreterProxy firstIndexableField: fileName.	fileNameSize _ interpreterProxy byteSizeOf: fileName.	(self ioCanSetFileType: fileNameIndex OfSize: fileNameSize)		ifFalse:[^interpreterProxy primitiveFail].	(self cCode: 'dir_SetMacFileTypeAndCreator(			(char *) fileNameIndex, fileNameSize,			(char *) typeStringIndex, (char *) creatorStringIndex)'		inSmalltalk:[true]) ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 3.  "pop filename, type, creator; leave rcvr on stack"! !!FilePlugin methodsFor: 'security primitives' stamp: 'ar 2/6/2001 14:00'!primitiveDisableFileAccess	self export: true.	self ioDisableFileAccess.	interpreterProxy failed ifFalse:[interpreterProxy pop: 1].! !!FilePlugin methodsFor: 'security primitives' stamp: 'ar 2/6/2001 14:01'!primitiveHasFileAccess	self export: true.	interpreterProxy pop: 1.	interpreterProxy pushBool: self ioHasFileAccess.! !!FilePlugin class methodsFor: 'translation' stamp: 'ar 2/6/2001 17:54'!headerFile^'/* File support definitions *//* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileShutdown(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileFlush(SQFile *f);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delete(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);int dir_GetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/*** security traps ***//* directory access */int ioCanCreatePathOfSize(char* dirNameIndex, int dirNameSize);int ioCanListPathOfSize(char* dirNameIndex, int dirNameSize);int ioCanDeletePathOfSize(char* dirNameIndex, int dirNameSize);/* file access */int ioCanOpenFileOfSizeWritable(char* fileNameIndex, int fileNameSize, int writeFlag);int ioCanDeleteFileOfSize(char* fileNameIndex, int fileNameSize);int ioCanRenameFileOfSize(char* fileNameIndex, int fileNameSize);int ioCanGetFileTypeOfSize(char* fileNameIndex, int fileNameSize);int ioCanSetFileTypeOfSize(char* fileNameIndex, int fileNameSize);/* top level functions */int ioDisableFileAccess(void);int ioHasFileAccess(void);#ifdef DISABLE_SECURITY#define ioCanCreatePathOfSize(name, size) 1#define ioCanListPathOfSize(name, size) 1#define ioCanDeletePathOfSize(name, size) 1#define ioCanOpenFileOfSizeWritable(name, size, writeFlag) 1#define ioCanDeleteFileOfSize(name, size) 1#define ioCanRenameFileOfSize(name, size) 1#define ioCanGetFileTypeOfSize(name, size) 1#define ioCanSetFileTypeOfSize(name, size) 1#define ioDisableFileAccess() 1#define ioHasFileAccess() 1#endif /* DISABLE_SECURITY */'.! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 2/6/2001 17:54'!sqFileFlush: file	^interpreterProxy sqFileFlush: file! !!FilePluginSimulator methodsFor: 'file security' stamp: 'ar 2/5/2001 19:23'!ioCanCreatePath: dirNameIndex OfSize: dirNameSize	"Return true if we're allowed to create a directory with the given name"	^true! !!FilePluginSimulator methodsFor: 'file security' stamp: 'ar 2/5/2001 18:16'!ioCanDeleteFile: nameIndex OfSize: nameSize	"Return true if we're allowed to delete the file with the given name"	^true! !!FilePluginSimulator methodsFor: 'file security' stamp: 'ar 2/5/2001 18:16'!ioCanDeletePath: dirNameIndex OfSize: dirNameSize	"Return true if we're allowed to delete the directory with the given name"	^true! !!FilePluginSimulator methodsFor: 'file security' stamp: 'ar 2/5/2001 18:16'!ioCanGetFileType: fileNameIndex OfSize: fileNameSize	"Return true if we're allowed to retrieve the (mac) file type of the given file."	^true! !!FilePluginSimulator methodsFor: 'file security' stamp: 'ar 2/5/2001 18:17'!ioCanListPath: pathNameIndex OfSize: pathNameSize	"Return true if we're allowed to list the contents of the given directory"	^true! !!FilePluginSimulator methodsFor: 'file security' stamp: 'ar 2/5/2001 18:17'!ioCanOpenFile: nameIndex OfSize: nameSize Writable: writeFlag	"Return true if we're allowed to open the given file (possibly in write mode)"	^true! !!FilePluginSimulator methodsFor: 'file security' stamp: 'ar 2/5/2001 18:17'!ioCanRenameFile: oldNameIndex OfSize: oldNameSize	"Return true if we're allowed to rename the given file"	^true! !!FilePluginSimulator methodsFor: 'file security' stamp: 'ar 2/5/2001 18:18'!ioCanSetFileType: fileNameIndex OfSize: fileNameSize	"Return true if we're allowed to set the (mac) file type and creator on the given file"	^true! !!FlapTab methodsFor: 'show & hide' stamp: 'sw 2/12/2001 16:49'!lastReferentThickness: anInteger	"Set the last remembered referent thickness to the given integer"	lastReferentThickness _ anInteger! !!FlapTab methodsFor: 'show & hide' stamp: 'sw 2/12/2001 16:59'!openFully	"Make an educated guess at how wide or tall we are to be, and open to that thickness"	| thickness amt |	thickness _ referent boundingBoxOfSubmorphs extent max: (100 @ 100).	self applyThickness: (amt _ self orientation == #horizontal			ifTrue:				[thickness y]			ifFalse:				[thickness x]).	self lastReferentThickness: amt.	self showFlap! !!FlapTab methodsFor: 'show & hide' stamp: 'sw 2/12/2001 17:04'!tabSelected	"The user clicked on the tab.  Show or hide the flap.  Try to be a little smart about a click on a tab whose flap is open but only just barely."	dragged == true ifTrue:		[^ dragged _ false].	self flapShowing		ifTrue:			[self referentThickness < 23  "an attractive number"				ifTrue:					[self openFully]				ifFalse:					[self hideFlap]]		ifFalse:			[self showFlap]! !!Form class methodsFor: 'mode constants' stamp: 'hg 1/29/2001 17:28'!rgbMul	"Answer the integer denoting 'Multiply each color component, 	 their values regarded as fractions of 1' rule."	^ 37! !!Form class methodsFor: 'BMP file reading' stamp: 'ar 2/5/2001 00:02'!bmpColorsFrom: aBinaryStream count: colorCount depth: depth	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."	| maxLevel colors b g r |	depth = 16 ifTrue:[^nil].	colorCount = 0 ifTrue: [  "this BMP file does not have a color map"		"default monochrome color map"		depth = 1 ifTrue: [^ Array with: Color white with: Color black].		"default gray-scale color map"		maxLevel _ (2 raisedTo: depth) - 1.		^ (0 to: maxLevel) collect: [:level | Color gray: (level asFloat / maxLevel)]].	colors _ Array new: colorCount.	1 to: colorCount do: [:i |		b _ aBinaryStream next.		g _ aBinaryStream next.		r _ aBinaryStream next.		aBinaryStream skip: 1.		colors at: i put: (Color r: r g: g b: b range: 255)].	^ colors! !!Form class methodsFor: 'BMP file reading' stamp: 'ar 2/5/2001 00:15'!bmpPixelDataFrom: aBinaryStream width: w height: h depth: d colors: colors	"Read uncompressed pixel data of depth d from the given BMP stream, where d is 1, 4, 8, or 16"	| form bytesPerRow pixelData pixelLine startIndex cm word formBits |	(colors == nil) ifTrue:[		form _ Form extent: w@h depth: d.	] ifFalse:[		form _ ColorForm extent: w@h depth: d.		form colors: colors.	].	bytesPerRow _ (((d* w) + 31) // 32) * 4.	pixelData _ ByteArray new: bytesPerRow * h.	h to: 1 by: -1 do: [:y |		pixelLine _ aBinaryStream next: bytesPerRow.		startIndex _ ((y - 1) * bytesPerRow) + 1.		pixelData			replaceFrom: startIndex			to: startIndex + bytesPerRow - 1			with: pixelLine			startingAt: 1].	form bits copyFromByteArray: pixelData.	d = 16 ifTrue:[		"swap red and blue components"		cm _ Bitmap new: (1 << 15).		word _ 0.		0 to: 31 do:[:r| 0 to: 31 do:[:g| 0 to: 31 do:[:b|			cm at: (word _ word + 1) put: (b bitShift: 10) + (g bitShift: 5) + r]]].		cm at: 1 put: 1.		formBits _ form bits.		1 to: formBits size do:[:i|			word _ formBits at: i.			word _ (cm at: (word bitAnd: 16r7FFF) + 1) + ((cm at: ((word bitShift: -16) bitAnd: 16r7FFF) +1) bitShift: 16).			formBits at: i put: word.		].	].	^ form! !!Form class methodsFor: 'BMP file reading' stamp: 'ar 2/4/2001 21:54'!fromBMPFile: aBinaryStream	"Read a BMP format image from the given binary stream."	"Form fromBMPFile:		(HTTPSocket			httpGet: 'http://anHTTPServer/squeak/squeakers.bmp'			accept: 'image/bmp')"	| fType fSize reserved pixDataStart hdrSize w h planes d      compressed colorCount colors colorForm |	(aBinaryStream isMemberOf: String) ifTrue: [^ nil].  "a network error message"	aBinaryStream binary.	fType _ aBinaryStream nextLittleEndianNumber: 2.	fSize _ aBinaryStream nextLittleEndianNumber: 4.	reserved _ aBinaryStream nextLittleEndianNumber: 4.	pixDataStart _ aBinaryStream nextLittleEndianNumber: 4.	hdrSize _ aBinaryStream nextLittleEndianNumber: 4.	w _ aBinaryStream nextLittleEndianNumber: 4.	h _ aBinaryStream nextLittleEndianNumber: 4.	planes _ aBinaryStream nextLittleEndianNumber: 2.	d _ aBinaryStream nextLittleEndianNumber: 2.	compressed _ aBinaryStream nextLittleEndianNumber: 4.	aBinaryStream nextLittleEndianNumber: 4.  "biSizeImage"	aBinaryStream nextLittleEndianNumber: 4.  "biXPelsPerMeter"	aBinaryStream nextLittleEndianNumber: 4.  "biYPelsPerMeter"	colorCount _ aBinaryStream nextLittleEndianNumber: 4.	aBinaryStream nextLittleEndianNumber: 4.  "biClrImportant"	((fType = 19778) & (reserved = 0) & (planes = 1) &	 (hdrSize = 40) & (fSize <= aBinaryStream size))		ifFalse: [self error: 'Bad BMP file header'].	compressed = 0		ifFalse: [self error: 'Can only read uncompressed BMP files'].	d = 24 ifTrue: [		aBinaryStream position: pixDataStart.		^ self bmp24BitPixelDataFrom: aBinaryStream width: w height: h].	"read the color map"	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"	colorCount _ (pixDataStart - 54) // 4.	colors _ self bmpColorsFrom: aBinaryStream count: colorCount depth: d.	"read the pixel data"	aBinaryStream position: pixDataStart.	colorForm _ self bmpPixelDataFrom: aBinaryStream width: w height: h depth: d colors: colors.	^ colorForm! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'RAA 2/6/2001 14:00'!infiniteFillRectangle: aRectangle fillStyle: aFillStyle	| additionalOffset rInPortTerms clippedPort targetTopLeft clipOffset ex |	"this is a bit of a kludge to get the form to be aligned where I *think* it should be.	something better is needed, but not now"	additionalOffset _ 0@0.	ex _ aFillStyle form extent.	rInPortTerms _ aRectangle translateBy: origin.	clippedPort _ port clippedBy: rInPortTerms.	targetTopLeft _ clippedPort clipRect topLeft truncateTo: ex.	clipOffset _ rInPortTerms topLeft - targetTopLeft.	additionalOffset _ (clipOffset \\ ex) - ex.	^aFillStyle		displayOnPort: clippedPort		offsetBy: additionalOffset! !!FormCanvas methodsFor: 'drawing-general' stamp: 'di 2/6/2001 14:03'!roundCornersOf: aMorph during: aBlock	aMorph wantsRoundedCorners ifFalse:[^aBlock value].	(self seesNothingOutside: (CornerRounder rectWithinCornersOf: aMorph bounds))		ifTrue: ["Don't bother with corner logic if the region is inside them"				^ aBlock value].	CornerRounder roundCornersOf: aMorph on: self		displayBlock: aBlock		borderWidth: aMorph borderWidthForRounding		corners: aMorph roundedCorners! !!HTTPSocket class methodsFor: 'get the page' stamp: 'RAA 2/16/2001 18:26'!httpPostToSuperSwiki: url args: argsDict accept: mimeType request: requestString	| serverName serverAddr s header length bare page list firstData aStream port specifiedServer type mimeBorder contentsData |	Socket initializeNetwork.	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ self defaultPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/ ifAbsent: [^'error']) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxyServer ifNotNil: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxyServer.		port _ HTTPProxyPort].	mimeBorder _ '---------SuperSwiki',Time millisecondClockValue printString,'-----'.	contentsData _ String streamContents: [ :strm |		strm nextPutAll: mimeBorder, CrLf.		argsDict associationsDo: [:assoc |			assoc value do: [ :value |				strm					nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"';					nextPutAll: CrLf;					nextPutAll: CrLf;					nextPutAll: value;					nextPutAll: CrLf;					nextPutAll: CrLf;					nextPutAll: mimeBorder;					nextPutAll: CrLf.			]		].	].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	s sendCommand: 'POST ', page, ' HTTP/1.1', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 2.9', CrLf,		'Content-type: multipart/form-data; boundary=', mimeBorder, CrLf,		'Content-length: ', contentsData size printString, CrLf,		'Host: ', specifiedServer, CrLf.  "blank line automatically added"	s sendCommand: contentsData.	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	firstData _ list at: 3.	header isEmpty ifTrue: [		s destroy.		^'no response'	].	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	aStream _ s getRestOfBuffer: firstData totalLength: length.	s responseCode = '401' ifTrue: [^ header, aStream contents].	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!HaloMorph methodsFor: 'private' stamp: 'di 2/15/2001 22:09'!doGrow: evt with: growHandle	"Called while the mouse is down in the grow handle"	| newExtent extentToUse |	evt hand obtainHalo: self.	newExtent _ (target pointFromWorld: (target griddedPoint: evt cursorPoint - positionOffset))								- target topLeft.	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].	target renderedMorph extent: (extentToUse _ newExtent).	growHandle position: evt cursorPoint - (growHandle extent // 2).	self layoutChanged.	(self valueOfProperty: #commandInProgress) doIfNotNil:  		[:cmd | "Update the final extent"		cmd redoTarget: target selector: #extent: argument: extentToUse]! !!HandMorph methodsFor: 'drawing' stamp: 'ar 2/11/2001 16:34'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching subBnds roundCorners rounded |	self visible ifFalse:[^self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue:		[cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	self updateCacheCanvas: aCanvas.	(cacheCanvas == nil or: [cachedCanvasHasHoles and: [cacheCanvas depth = 1]])		ifTrue:		["could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"--> begin rounded corners hack <---"	roundCorners _ (cachedCanvasHasHoles == false) and:[		submorphs size = 1 and:[submorphs first wantsRoundedCorners]].	roundCorners ifTrue:[		rounded _ submorphs first.			aCanvas asShadowDrawingCanvas				translateBy: self shadowOffset during:[:shadowCanvas|			shadowCanvas roundCornersOf: rounded during:[				(subBnds areasOutside: (rounded boundsWithinCorners translateBy: self shadowOffset negated)) do:					[:r | shadowCanvas fillRectangle: r color: Color black]]].		aCanvas roundCornersOf: rounded during:[			aCanvas drawImage: cacheCanvas form at: subBnds origin					sourceRect: cacheCanvas form boundingBox].		^self drawOn: aCanvas.  "draw the hand itself in front of morphs"].	"--> end rounded corners hack <---"	"draw the shadow"	aCanvas asShadowDrawingCanvas		translateBy: self shadowOffset during:[:shadowCanvas|		cachedCanvasHasHoles			ifTrue: ["Have to draw the real shadow of the form"					shadowCanvas paintImage: cacheCanvas form at: subBnds origin]			ifFalse: ["Much faster if only have to shade the edge of a solid rectangle"					(subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) do:						[:r | shadowCanvas fillRectangle: r color: Color black]]].	"draw morphs in front of the shadow using the cached Form"	cachedCanvasHasHoles		ifTrue: [aCanvas paintImage: cacheCanvas form at: subBnds origin]		ifFalse: [aCanvas drawImage: cacheCanvas form at: subBnds origin					sourceRect: cacheCanvas form boundingBox].	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'ar 2/11/2001 16:35'!updateCacheCanvas: aCanvas	"Update the cached image of the morphs being held by this hand."	| subBnds rectList nPix |	"Note: The following is an attempt to quickly get out if there's no change"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: subBnds extent).	(rectList isEmpty and:[cacheCanvas notNil and:[cacheCanvas extent = subBnds extent]])		ifTrue:[^self].	"Always check for real translucency -- can't be cached in a form"	self allMorphsDo: [:m |		m hasTranslucentColor ifTrue: [			cacheCanvas _ nil.			cachedCanvasHasHoles _ true.			^ self]].	(cacheCanvas == nil or: [cacheCanvas extent ~= subBnds extent]) ifTrue: [		cacheCanvas _ (aCanvas allocateForm: subBnds extent) getCanvas.		cacheCanvas translateBy: subBnds origin negated			during:[:tempCanvas| self drawSubmorphsOn: tempCanvas].		self submorphsDo:			[:m | (m areasRemainingToFill: subBnds) isEmpty				ifTrue: [^ cachedCanvasHasHoles _ false]].		nPix _ cacheCanvas form tallyPixelValues at: 1.		"--> begin rounded corners hack <---"		(nPix = 48 and:[submorphs size = 1 and:[submorphs first wantsRoundedCorners]])			ifTrue:[cachedCanvasHasHoles _ false]			ifFalse:[cachedCanvasHasHoles _ nPix > 0].		"--> end rounded corners hack <---"		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: subBnds extent).	damageRecorder reset.	rectList do: [:r |		cacheCanvas translateTo: subBnds origin negated clippingTo: r during:[:c|			c fillColor: Color transparent.  "clear to transparent"			self drawSubmorphsOn: c]].! !!HandMorph methodsFor: 'event handling' stamp: 'ar 2/9/2001 14:03'!processEvents	"Process user input events from the local input devices."	| evt evtBuf type hadAny |	hadAny _ false.	[(evtBuf _ Sensor nextEvent) == nil] whileFalse:[		evt _ nil. "for unknown event types"		type _ evtBuf at: 1.		(type = EventTypeMouse)			ifTrue:[evt _ self generateMouseEvent: evtBuf].		(type = EventTypeKeyboard) 			ifTrue:[evt _ self generateKeyboardEvent: evtBuf].		(type = EventTypeDragDropFiles)			ifTrue:[evt _ self generateDropFilesEvent: evtBuf].		"All other events are ignored"		evt == nil ifFalse:[			"Finally, handle it"			self handleEvent: evt.			hadAny _ true.			"For better user feedback, return immediately after a mouse event has been processed."			evt isMouse ifTrue:[^self].		].	].	"note: if we come here we didn't have any mouse events"	(mouseClickState notNil) ifTrue:[		"No mouse events during this cycle. Make sure click states time out accordingly"		mouseClickState handleEvent: lastMouseEvent asMouseMove from: self].	hadAny ifFalse:[		"No pending events. Make sure z-order is up to date"		self mouseOverHandler processMouseOver: lastMouseEvent.	].! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 2/6/2001 22:15'!grabMorph: aMorph from: formerOwner	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| grabbed offset targetPoint grabTransform fullTransform |	self releaseMouseFocus. "Break focus"	grabbed _ aMorph.	"Compute the transform to apply to the grabbed morph"	grabTransform _ formerOwner 			ifNil:		[IdentityTransform new] 			ifNotNil:	[formerOwner grabTransform].	"Compute the full transform for the grabbed morph"	fullTransform _ formerOwner 			ifNil:		[IdentityTransform new] 			ifNotNil:	[formerOwner transformFrom: owner].	"targetPoint is point in aMorphs reference frame"	targetPoint _ fullTransform globalPointToLocal: self position.	"but current position will be determined by grabTransform, so compute offset"	offset _ targetPoint - (grabTransform globalPointToLocal: self position).	"apply the transform that should be used after grabbing"	grabbed _ grabbed transformedBy: grabTransform.	grabbed == aMorph 		ifFalse:	[grabbed setProperty: #addedFlexAtGrab toValue: true].	"offset target to compensate for differences in transforms"	grabbed position: grabbed position - offset asIntegerPoint.	"And compute distance from hand's position"	targetOffset _ grabbed position - self position.	self addMorphBack: grabbed.	grabbed justGrabbedFrom: formerOwner.! !!HandMorph methodsFor: 'halo handling' stamp: 'RAA 2/13/2001 17:24'!removeHaloFromClick: anEvent on: aMorph	| halo |	halo _ self halo ifNil:[^self].	(halo target hasOwner: self) ifTrue:[^self].	(halo staysUpWhenMouseIsDownIn: aMorph) ifFalse:[		halo delete.		self removeProperty: #halo.	].! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 2/13/2001 21:10'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  An object in the segment is the wrong size for the modern version of the class.  Construct a fake class that is the old size.  Replace the modern class with the old one in outPointers.  Load the segment.  Traverse the instances, making new instances by copying fields, and running conversion messages.  Keep the new instances.  Bulk forward become the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.  Globalize new classes.  Caller may want to do some special install on certain objects in arrayOfRoots. 	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal ccFixups receiverClasses rootsToUnhiberhate myProject |	self flag: #bobconv.		RecentlyRenamedClasses _ nil.		"in case old data hanging around"	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.  Substitute them in outPointers."	ccFixups _ self remapCompactClasses: mapFakeClassesToReal 				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is not compatible'].	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		self reshapeClasses: mapFakeClassesToReal refStream: smartRefStream	].	receiverClasses _ self restoreEndianness.		"rehash sets"	smartRefStream checkFatalReshape: receiverClasses.	"Classes in this segment."	arrayOfRoots do: [:importedObject | 		importedObject class class == Metaclass ifTrue: [self declare: importedObject]].	arrayOfRoots do: [:importedObject | 		(importedObject isKindOf: Project) ifTrue: [			myProject _ importedObject.			importedObject ensureChangeSetNameUnique.			Project addingProject: importedObject.			importedObject restoreReferences.			ScriptEditorMorph writingUniversalTiles: 				(importedObject world valueOfProperty: #universalTiles)]].		rootsToUnhiberhate _ arrayOfRoots select: [:importedObject | 		importedObject respondsTo: #unhibernate	"ScriptEditors and ViewerFlapTabs"	].	myProject ifNotNil: [		myProject world setProperty: #thingsToUnhibernate toValue: rootsToUnhiberhate	].	mapFakeClassesToReal isEmpty ifFalse: [		mapFakeClassesToReal keys do: [:aFake | 			aFake indexIfCompact > 0 ifTrue: [aFake becomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!InfiniteForm methodsFor: 'displaying' stamp: 'RAA 2/6/2001 14:02'!displayOnPort: aPort at: offset	| targetBox patternBox savedMap top left |	self flag: #bob.	"this *may* not get called at the moment. I have been trying to figure out the right way for this to work and am using #displayOnPort:offsetBy: as my current offering - Bob"	(patternForm isKindOf: Form) ifFalse: [		"patternForm is a Pattern or Color; just use it as a mask for BitBlt"		^ aPort fill: aPort clipRect fillColor: patternForm rule: Form over].	"do it iteratively"	targetBox _ aPort clipRect.	patternBox _ patternForm boundingBox.	savedMap _ aPort colorMap.	aPort sourceForm: patternForm;		fillColor: nil;		combinationRule: Form paint;		sourceRect: (0@0 extent: patternBox extent);		colorMap: (patternForm colormapIfNeededForDepth: aPort destForm depth).	top _ (targetBox top truncateTo: patternBox height) "- (offset y \\ patternBox height)".	left _  (targetBox left truncateTo: patternBox width) "- (offset x \\ patternBox width)".	left to: (targetBox right - 1) by: patternBox width do:		[:x | top to: (targetBox bottom - 1) by: patternBox height do:			[:y | aPort destOrigin: x@y; copyBits]].	aPort colorMap: savedMap.! !!InfiniteForm methodsFor: 'displaying' stamp: 'RAA 2/6/2001 14:03'!displayOnPort: aPort offsetBy: offset	| targetBox patternBox savedMap top left |	"this version tries to get the form aligned where the user wants it and not just aligned with the cliprect"	(patternForm isKindOf: Form) ifFalse: [		"patternForm is a Pattern or Color; just use it as a mask for BitBlt"		^ aPort fill: aPort clipRect fillColor: patternForm rule: Form over].	"do it iteratively"	targetBox _ aPort clipRect.	patternBox _ patternForm boundingBox.	savedMap _ aPort colorMap.	aPort sourceForm: patternForm;		fillColor: nil;		combinationRule: Form paint;		sourceRect: (0@0 extent: patternBox extent);		colorMap: (patternForm colormapIfNeededForDepth: aPort destForm depth).	top _ (targetBox top truncateTo: patternBox height) + offset y.	left _  (targetBox left truncateTo: patternBox width) + offset x.	left to: (targetBox right - 1) by: patternBox width do:		[:x | top to: (targetBox bottom - 1) by: patternBox height do:			[:y | aPort destOrigin: x@y; copyBits]].	aPort colorMap: savedMap.! !!InputSensor methodsFor: 'mouse' stamp: 'ar 2/14/2001 00:02'!peekButtons	^self primMouseButtons! !!InputSensor methodsFor: 'mouse' stamp: 'ar 2/8/2001 21:45'!peekMousePt	^self primMousePt! !!InputSensor methodsFor: 'cursor' stamp: 'ar 2/14/2001 00:00'!peekPosition	^self cursorPoint! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 16:12'!acceptSortedContentsFrom: aHolder	"Update my page list from the given page sorter."	| nameOfThisProject cachedData proj |	threadName isEmpty ifTrue: [threadName _ 'I need a name'].	threadName _ FillInTheBlank 		request: 'Name this thread.' 		initialAnswer: threadName.	threadName isEmptyOrNil ifTrue: [^self].	listOfPages _ OrderedCollection new.	aHolder submorphs doWithIndex: [:m :i |		(nameOfThisProject _ m valueOfProperty: #nameOfThisProject) ifNotNil: [			cachedData _ {nameOfThisProject}.			proj _ Project named: nameOfThisProject.			(proj isNil or: [proj thumbnail isNil]) ifFalse: [				cachedData _ cachedData, {proj thumbnail scaledToSize: self myThumbnailSize}.			].			listOfPages add: cachedData.		].	].	self class know: listOfPages as: threadName.	self removeAllMorphs; addButtons.	self world ifNil: [		self openInWorld; positionAppropriately.	].! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 16:08'!addButtons	| marginPt i sz data images pageNumber f m b1 b2 dot arrowWidth arrowCenter vertices arrowHeight nameMorph |	self changeNoLayout.	self hResizing: #rigid.	self vResizing: #rigid.	marginPt _ 4@4.	i _ self currentIndex.	sz _ self myThumbnailSize.	arrowWidth _ 14.	arrowHeight _ 17.	data _ {		{i - 1. 'Previous:'. #previousPage. #rightCenter. arrowWidth negated. 'Prev'}.		{i + 1. 'Next:'. #nextPage. #leftCenter. arrowWidth. 'Next'}	}.	images _ data collect: [ :tuple |		pageNumber _ tuple first.		(pageNumber between: 1 and: listOfPages size) ifTrue: [			f _ self 				makeThumbnailForPageNumber: pageNumber 				scaledToSize: sz 				default: tuple sixth.			f _ f deepCopy.		"we're going to mess it up"			arrowCenter _ f boundingBox perform: tuple fourth.			vertices _ {				arrowCenter - (0@arrowHeight).				arrowCenter + (0@arrowHeight).				arrowCenter + (tuple fifth @ 0).			}.			f getCanvas				drawPolygon: vertices 				color: Color orange 				borderWidth: 0 				borderColor: Color transparent.			m _ ImageMorph new image: f.			m setBalloonText: tuple second,' ',(listOfPages at: pageNumber) first.			m addMouseUpActionWith: (				MessageSend receiver: self selector: tuple third			).		] ifFalse: [			f _ (Form extent: sz depth: 16) fillColor: Color lightGray.			m _ ImageMorph new image: f.		].		m	].	b1 _ images first.	b2 _ images second.	dot _ EllipseMorph new extent: 16@16; color: Color orange lighter; borderWidth: 0.	self addMorph: (b1 position: self position + marginPt).	self addMorph: (b2 position: b1 topRight + (marginPt x @ 0)).	self extent: (b1 bottomRight max: b2 bottomRight) - self position + marginPt.	self addMorph: dot.	dot align: dot center with: b1 bounds rightCenter + ((marginPt x @ 0) // 2).	dot setBalloonText: threadName,'more commands'.	dot on: #mouseDown send: #moreCommands to: self.	self fullBounds.	self addMorph: (nameMorph _ SquishedNameMorph new).	nameMorph		target: self getSelector: #threadName setSelector: nil;		color: Color transparent;		width: self width;		height: 15;		align: nameMorph bottomLeft with: self bottomLeft.! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 11:41'!editThisThread	| sorter |	sorter _ ProjectSorterMorph new.	sorter navigator: self listOfPages: listOfPages.	self currentWorld addMorphFront: sorter.	sorter align: sorter center with: self currentWorld center.	self delete.! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 09:57'!insertNewProject	| newProj me |	[newProj _ Project newMorphicOn: nil.]		on: ProjectViewOpenNotification		do: [ :ex | ex resume: false].		EToyProjectDetailsMorph 		getFullInfoFor: newProj		ifValid: [			me _ CurrentProjectRefactoring currentProjectName.			listOfPages withIndexDo: [ :each :index |				each first = me ifTrue: [					listOfPages add: {newProj name} afterIndex: index.					^self switchToThread: threadName				].			].			listOfPages add: {newProj name} afterIndex: listOfPages size.			^self switchToThread: threadName		]		expandedFormat: false.! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 09:38'!makeThumbnailForPageNumber: pageNumber scaledToSize: sz default: aString	| cachedData proj tn label |	cachedData _ listOfPages at: pageNumber.	proj _ Project named: cachedData first.	(proj isNil or: [proj thumbnail isNil]) ifTrue: [		cachedData size >= 2 ifTrue: [^cachedData second].		tn _ Form extent: sz depth: 8.		tn fillColor: Color veryLightGray.		label _ (StringMorph contents: aString) imageForm.		label displayOn: tn at: tn center - (label extent // 2) rule: Form paint.		^tn	].	tn _ proj thumbnail  scaledToSize: sz.	cachedData size < 2 ifTrue: [		cachedData _ cachedData,#(0).		listOfPages at: pageNumber put: cachedData.	].	cachedData at: 2 put: tn.	^tn! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 16:16'!myThumbnailSize	^52@39! !!Interpreter methodsFor: 'float primitives' stamp: 'yo 2/1/2001 23:49'!primitiveExponent	"Exponent part of this float."	| rcvr frac pwr |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	rcvr _ self popFloat.	successFlag		ifTrue: [  "rcvr = frac * 2^pwr, where frac is in [0.5..1.0)"			self cCode: 'frac = frexp(rcvr, &pwr)'					inSmalltalk: [pwr _ rcvr exponent].			self pushInteger: pwr - 1]		ifFalse: [self unPop: 1].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'ar 2/5/2001 17:24'!primitiveScreenDepth	"Return a SmallInteger indicating the current depth of the OS screen"	| depth |	self export: true.	depth _ self ioScreenDepth.	(self failed or:[depth <= 0]) ifTrue:[^self primitiveFail].	self pop: 1.	self pushInteger: depth.! !!Interpreter methodsFor: 'other primitives' stamp: 'ar 2/5/2001 18:31'!primitiveImageName	"When called with a single string argument, record the string as the current image file name. When called with zero arguments, return a string containing the current image file name."	| s sz |	argumentCount = 1 ifTrue: [		self ioCanRenameImage ifFalse:[^self primitiveFail].		s _ self stackTop.		self assertClassOf: s is: (self splObj: ClassString).		successFlag ifTrue: [			sz _ self stSizeOf: s.			self imageNamePut: (s + BaseHeaderSize) Length: sz.			self pop: 1.  "pop s, leave rcvr on stack"		].	] ifFalse: [		sz _ self imageNameSize.		s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.		self imageNameGet: (s + BaseHeaderSize) Length: sz.		self pop: 1.  "rcvr"		self push: s.	].! !!Interpreter methodsFor: 'other primitives' stamp: 'yo 2/7/2001 10:49'!primitiveObsoleteIndexedPrimitive	"Primitive. Invoke an obsolete indexed primitive."	| pluginName functionName functionAddress |	self var: #pluginName declareC:'char *pluginName'.	self var: #functionName declareC:'char *functionName'.	functionAddress _ 		self cCoerce: ((obsoleteIndexedPrimitiveTable at: primitiveIndex) at: 2) to: 'int'.	functionAddress = nil 		ifFalse:[^self cCode: '((int (*) (void))functionAddress)()'					inSmalltalk:[self callExternalPrimitive: functionAddress]].	pluginName _ (obsoleteIndexedPrimitiveTable at: primitiveIndex) at: 0.	functionName _ (obsoleteIndexedPrimitiveTable at: primitiveIndex) at: 1.	(pluginName = nil and:[functionName = nil]) 		ifTrue:[^self primitiveFail].	functionAddress _ self ioLoadFunction: functionName From: pluginName.	functionAddress = 0 ifFalse:["Cache for future use"		(obsoleteIndexedPrimitiveTable at: primitiveIndex) at: 2 put: 			(self cCoerce: functionAddress to: 'char*').		^self cCode: '((int (*) (void))functionAddress)()'				inSmalltalk:[self callExternalPrimitive: functionAddress]].	^self primitiveFail! !!Interpreter methodsFor: 'other primitives' stamp: 'yo 2/1/2001 23:50'!primitiveVMParameter	"Behaviour depends on argument count:		0 args:	return an Array of VM parameter values;		1 arg:	return the indicated VM parameter;		2 args:	set the VM indicated parameter.	VM parameters are numbered as follows:		1	end of old-space (0-based, read-only)		2	end of young-space (read-only)		3	end of memory (read-only)		4	allocationCount (read-only)		5	allocations between GCs (read-write)		6	survivor count tenuring threshold (read-write)		7	full GCs since startup (read-only)		8	total milliseconds in full GCs since startup (read-only)		9	incremental GCs since startup (read-only)		10	total milliseconds in incremental GCs since startup (read-only)		11	tenures of surving objects since startup (read-only)		12-20 specific to the translating VM		21	root table size (read-only)		22	root table overflows since startup (read-only)		23	bytes of extra memory to reserve for VM buffers, plugins, etc.	Note: Thanks to Ian Piumarta for this primitive."	| mem paramsArraySize result arg index |	mem _ self cCoerce: memory to: 'int'.	self cCode: '' inSmalltalk: [mem _ 0].	argumentCount = 0 ifTrue: [		paramsArraySize _ 23.		result _ self instantiateClass: (self splObj: ClassArray) indexableSize: paramsArraySize.		0 to: paramsArraySize - 1 do:			[:i | self storeWord: i ofObject: result withValue: (self integerObjectOf: 0)].		self storeWord: 0	ofObject: result withValue: (self integerObjectOf: youngStart - mem).		self storeWord: 1		ofObject: result withValue: (self integerObjectOf: freeBlock - mem).		self storeWord: 2	ofObject: result withValue: (self integerObjectOf: endOfMemory - mem).		self storeWord: 3	ofObject: result withValue: (self integerObjectOf: allocationCount).		self storeWord: 4	ofObject: result withValue: (self integerObjectOf: allocationsBetweenGCs).		self storeWord: 5	ofObject: result withValue: (self integerObjectOf: tenuringThreshold).		self storeWord: 6	ofObject: result withValue: (self integerObjectOf: statFullGCs).		self storeWord: 7	ofObject: result withValue: (self integerObjectOf: statFullGCMSecs).		self storeWord: 8	ofObject: result withValue: (self integerObjectOf: statIncrGCs).		self storeWord: 9	ofObject: result withValue: (self integerObjectOf: statIncrGCMSecs).		self storeWord: 10	ofObject: result withValue: (self integerObjectOf: statTenures).		self storeWord: 20	ofObject: result withValue: (self integerObjectOf: rootTableCount).		self storeWord: 21	ofObject: result withValue: (self integerObjectOf: statRootTableOverflows).		self storeWord: 22	ofObject: result withValue: (self integerObjectOf: extraVMMemory).		self pop: 1 thenPush: result.		^nil].	arg _ self stackTop.	(self isIntegerObject: arg) ifFalse: [^self primitiveFail].	arg _ self integerValueOf: arg.	argumentCount = 1 ifTrue: [	 "read VM parameter"		(arg < 1 or: [arg > 23]) ifTrue: [^self primitiveFail].		arg = 1		ifTrue: [result _ youngStart - mem].		arg = 2		ifTrue: [result _ freeBlock - mem].		arg = 3		ifTrue: [result _ endOfMemory - mem].		arg = 4		ifTrue: [result _ allocationCount].		arg = 5		ifTrue: [result _ allocationsBetweenGCs].		arg = 6		ifTrue: [result _ tenuringThreshold].		arg = 7		ifTrue: [result _ statFullGCs].		arg = 8		ifTrue: [result _ statFullGCMSecs].		arg = 9		ifTrue: [result _ statIncrGCs].		arg = 10		ifTrue: [result _ statIncrGCMSecs].		arg = 11		ifTrue: [result _ statTenures].		((arg >= 12) and: [arg <= 20]) ifTrue: [result _ 0].		arg = 21		ifTrue: [result _ rootTableCount].		arg = 22		ifTrue: [result _ statRootTableOverflows].		arg = 23		ifTrue: [result _ extraVMMemory].		self pop: 2 thenPush: (self integerObjectOf: result).		^nil].	"write a VM parameter"	argumentCount = 2 ifFalse: [^self primitiveFail].	index _ self stackValue: 1.	(self isIntegerObject: index) ifFalse: [^self primitiveFail].	index _ self integerValueOf: index.	index <= 0 ifTrue: [^self primitiveFail].	successFlag _ false.	index = 5 ifTrue: [		result _ allocationsBetweenGCs.		allocationsBetweenGCs _ arg.		successFlag _ true].	index = 6 ifTrue: [		result _ tenuringThreshold.		tenuringThreshold _ arg.		successFlag _ true].	index = 23 ifTrue: [		result _ extraVMMemory.		extraVMMemory _ arg.		successFlag _ true].	successFlag ifTrue: [		self pop: 3 thenPush: (self integerObjectOf: result).  "return old value"		^ nil].	self primitiveFail.  "attempting to write a read-only parameter"! !!Interpreter methodsFor: 'debug support' stamp: 'di 2/15/2001 22:33'!okayFields: oop	"If this is a pointers object, check that its fields are all okay oops."	| i fieldOop c |	(oop = nil or: [oop = 0]) ifTrue: [ ^true ].	(self isIntegerObject: oop) ifTrue: [ ^true ].	self okayOop: oop.	self oopHasOkayClass: oop.	(self isPointers: oop) ifFalse: [ ^true ].	c _ self fetchClassOf: oop.	(c = (self splObj: ClassMethodContext)		or: [c = (self splObj: ClassBlockContext)])		ifTrue: [i _ CtxtTempFrameStart + (self fetchStackPointerOf: oop) - 1]		ifFalse: [i _ (self lengthOf: oop) - 1].	[i >= 0] whileTrue: [		fieldOop _ self fetchPointer: i ofObject: oop.		(self isIntegerObject: fieldOop) ifFalse: [			self okayOop: fieldOop.			self oopHasOkayClass: fieldOop.		].		i _ i - 1.	].! !!Interpreter methodsFor: 'image save/restore' stamp: 'ar 2/5/2001 19:21'!writeImageFileIO: imageBytes	| headerStart headerSize f bytesWritten |	self var: #f declareC: 'sqImageFile f'.	self ioCanWriteImage ifFalse:[^self primitiveFail].	"local constants"	headerStart _ 0.  	headerSize _ 64.  "header size in bytes; do not change!!"	f _ self cCode: 'sqImageFileOpen(imageName, "wb")'.	f = nil ifTrue: [		"could not open the image file for writing"		self success: false.		^ nil].	headerStart _ self cCode: 'sqImageFileStartLocation(f,imageName,headerSize+imageBytes)'.	self cCode: '/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */'.	"position file to start of header"	self sqImageFile: f Seek: headerStart.	self putLong: (self imageFormatVersion) toFile: f.	self putLong: headerSize toFile: f.	self putLong: imageBytes toFile: f.	self putLong: (self startOfMemory) toFile: f.	self putLong: specialObjectsOop toFile: f.	self putLong: lastHash toFile: f.	self putLong: (self ioScreenSize) toFile: f.	self putLong: fullScreenFlag toFile: f.	self putLong: extraVMMemory toFile: f.	1 to: 7 do: [:i | self putLong: 0 toFile: f].  "fill remaining header words with zeros"	successFlag ifFalse: [		"file write or seek failure"		self cCode: 'sqImageFileClose(f)'.		^ nil].	"position file after the header"	self sqImageFile: f Seek: headerStart + headerSize.	"write the image data"	bytesWritten _ self cCode: 'sqImageFileWrite(memory, sizeof(unsigned char), imageBytes, f)'.	self success: bytesWritten = imageBytes.	self cCode: 'sqImageFileClose(f)'.! !!Interpreter class methodsFor: 'translation' stamp: 'ar 2/5/2001 22:18'!translate: fileName doInlining: inlineFlag forBrowserPlugin: pluginFlag	"Note: The pluginFlag is meaningless on Windows and Unix. On these platforms Squeak runs as it's own process and doesn't need any special attention from the VMs point of view. Meaning that NONE of the required additional functions will be supported. In other words, the pluginFlag is not needed and not supported."	"Translate the Smalltalk description of the virtual machine into C. If inlineFlag is true,small method bodies are inlined to reduce procedure call overhead. On the PPC, this results in a factor of three speedup with only 30% increase in code size. If pluginFlag is true, generate code for an interpreter that runs as a browser plugin (Netscape or IE)."	| doInlining cg exports |	doInlining _ inlineFlag.	pluginFlag ifTrue: [doInlining _ true].  "must inline when generating browser plugin"	Interpreter initialize.	ObjectMemory initialize.	GenerateBrowserPlugin _ pluginFlag.	cg _ CCodeGenerator new initialize.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	"Get all the named prims from the VM.	Note: the format of exports is:		pluginName -> Array of: primitiveName.	so we can generate a nice table from it."	exports _ Array with: '' -> cg exportedPrimitiveNames asArray.	cg storeCodeOnFile: fileName doInlining: doInlining.	"Add our plugins"	{		"Graphics"			"Note: BitBltSimulation should go first, 			because three of it's entries might be 			looked up quite often (due to refs from 			InterpreterProxy). This will go away at			some point but for now it's a good idea			to have those entries early in the table."		BitBltSimulation.			BalloonEnginePlugin. 		SurfacePlugin. "To support OS surfaces through FXBlt"		"I/O subsystems"		FilePlugin.		SocketPlugin.		MIDIPlugin. 		SerialPlugin. 		JoystickTabletPlugin. 		AsynchFilePlugin. 		"Sound"		SoundPlugin. 		SoundGenerationPlugin.		ADPCMCodecPlugin.		KlattSynthesizerPlugin.		SoundCodecPlugin.	 	"Numerics"		LargeIntegersPlugin.		FFTPlugin. 		FloatArrayPlugin. 		Matrix2x3Plugin. 		"Compression"		DeflatePlugin.		"Others"		B3DEnginePlugin.		DSAPlugin.		DropPlugin. 		MiscPrimitivePlugin.		SecurityPlugin.		"Note: Optionally, you can translate the following as builtins.		As of Squeak 2.7 they are not builtins by default:			FFIPlugin.		"	} do:[:plugin|		cg _ plugin translate: plugin moduleName, '.c'					doInlining: doInlining					locally: true.		exports _ exports copyWith: 			(plugin moduleName -> cg exportedPrimitiveNames asArray).	].	self storeExports: exports on: 'sqNamedPrims.h'.! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'yo 2/7/2001 10:47'!initialize	"Initialize the InterpreterSimulator when running the interpreter inside	Smalltalk. The primary responsibility of this method is to allocate	Smalltalk Arrays for variables that will be declared as statically-allocated	global arrays in the translated code."	"initialize class variables"	ObjectMemory initialize.	Interpreter initialize.	methodCache _ Array new: MethodCacheSize.	atCache _ Array new: AtCacheTotalSize.	rootTable _ Array new: RootTableSize.	remapBuffer _ Array new: RemapBufferSize.	semaphoresUseBufferA _ true.	semaphoresToSignalA _ Array new: SemaphoresToSignalSize.	semaphoresToSignalB _ Array new: SemaphoresToSignalSize.	externalPrimitiveTable _ CArrayAccessor on: (Array new: MaxExternalPrimitiveTableSize).	obsoleteNamedPrimitiveTable _ 		CArrayAccessor on: self class obsoleteNamedPrimitiveTable.	obsoleteIndexedPrimitiveTable _ CArrayAccessor on: 		(self class obsoleteIndexedPrimitiveTable collect:[:spec| 			CArrayAccessor on:				(spec ifNil:[Array new: 3] 					  ifNotNil:[Array with: spec first with: spec second with: nil])]).	pluginList _ #().	mappedPluginEntries _ #().	"initialize InterpreterSimulator variables used for debugging"	byteCount _ 0.	sendCount _ 0.	traceOn _ true.	myBitBlt _ BitBltSimulator new setInterpreter: self.	displayForm _ nil.  "displayForm is created in response to primitiveBeDisplay"	filesOpen _ OrderedCollection new.! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'yo 2/7/2001 10:53'!openOn: fileName extraMemory: extraBytes	"InterpreterSimulator new openOn: 'clone.im' extraMemory: 100000"	| f version headerSize count oldBaseAddr bytesToShift swapBytes |	"open image file and read the header"	f _ FileStream readOnlyFileNamed: fileName.	imageName _ f fullName.	f binary.	version _ self nextLongFrom: f.  "current version: 16r1966 (=6502)"	(self readableFormat: version)		ifTrue: [swapBytes _ false]		ifFalse: [(version _ self byteSwapped: version) = self imageFormatVersion					ifTrue: [swapBytes _ true]					ifFalse: [self error: 'incomaptible image format']].	headerSize _ self nextLongFrom: f swap: swapBytes.	endOfMemory _ self nextLongFrom: f swap: swapBytes.  "first unused location in heap"	oldBaseAddr _ self nextLongFrom: f swap: swapBytes.  "object memory base address of image"	specialObjectsOop _ self nextLongFrom: f swap: swapBytes.	lastHash _ self nextLongFrom: f swap: swapBytes.  "Should be loaded from, and saved to the image header"	savedWindowSize _ self nextLongFrom: f swap: swapBytes.	lastHash = 0 ifTrue: [lastHash _ 999].	savedWindowSize	_ self nextLongFrom: f swap: swapBytes.	fullScreenFlag		_ self nextLongFrom: f swap: swapBytes.	extraVMMemory		_ self nextLongFrom: f swap: swapBytes.	"allocate interpreter memory"	memoryLimit _ endOfMemory + extraBytes.	"read in the image in bulk, then swap the bytes if necessary"	f position: headerSize.	memory _ Bitmap new: memoryLimit // 4.	count _ f readInto: memory startingAt: 1 count: endOfMemory // 4.	count ~= (endOfMemory // 4) ifTrue: [self halt].	f close.	swapBytes ifTrue: [Utilities informUser: 'Swapping bytes of foreign image...'								during: [self reverseBytesInImage]].	self initialize.	bytesToShift _ 0 - oldBaseAddr.  "adjust pointers for zero base address"	endOfMemory _ endOfMemory.	Utilities informUser: 'Relocating object pointers...'				during: [self initializeInterpreter: bytesToShift].! !!InterpreterSimulator methodsFor: 'I/O primitives' stamp: 'yo 2/14/2001 14:17'!ioGetNextEvent: evtBuf	self primitiveFail.! !!InterpreterSimulator methodsFor: 'I/O primitives' stamp: 'ar 2/5/2001 17:24'!ioScreenDepth	^DisplayScreen actualScreenDepth.! !!InterpreterSimulator methodsFor: 'I/O primitives' stamp: 'yo 2/14/2001 14:17'!ioSetInputSemaphore: index	self primitiveFail! !!InterpreterSimulator methodsFor: 'file primitives' stamp: 'yo 2/14/2001 12:04'!primitiveFileOpen	| namePointer writeFlag fileName f |	writeFlag _ self booleanValueOf: self stackTop.	namePointer _ self stackValue: 1.	self success: (self isBytes: namePointer).	successFlag ifTrue:		[fileName _ self stringOf: namePointer.		filesOpen addLast: (writeFlag			ifTrue: [f _ FileStream fileNamed: fileName.					f ifNil: [^ self primitiveFail] ifNotNil: [f binary]]			ifFalse: [(StandardFileStream isAFileNamed: fileName)				ifTrue: [f _ (FileStream readOnlyFileNamed: fileName).						f ifNil:[^self primitiveFail] ifNotNil:[f binary]]				ifFalse: [^ self primitiveFail]]).		self pop: 3.  "rcvr, name, write"		self pushInteger: filesOpen size]! !!InterpreterSimulator methodsFor: 'file primitives' stamp: 'ar 2/6/2001 17:54'!sqFileFlush: file	^ file flush! !!InterpreterSimulator methodsFor: 'plugin support' stamp: 'yo 2/14/2001 11:15'!classNameOf: aClass Is: className	"Check if aClass' name is className"	| name |	(self lengthOf: aClass) <= 6 ifTrue:[^false]. "Not a class but maybe behavior" 	name _ self fetchPointer: 6 ofObject: aClass.	(self isBytes: name) ifFalse:[^false].	^ className = (self stringOf: name).! !!InterpreterSimulator methodsFor: 'security' stamp: 'ar 2/5/2001 18:33'!ioCanRenameImage	^true! !!InterpreterSimulator methodsFor: 'security' stamp: 'ar 2/5/2001 20:42'!ioCanWriteImage	^true! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'JMM 2/12/2001 16:28'!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Tosh:Desktop Folder:Squeak VM Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode macArchiveBinaryFile asByteArray		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'platform.exports') contentsOfEntireFile =	InterpreterSupportCode squeakPlatformExportsFile		ifFalse: [self inform: 'File platform.exports differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqPlatformSpecific.h') contentsOfEntireFile =	InterpreterSupportCode squeakPlatSpecFile		ifFalse: [self inform: 'File sqPlatformSpecific.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacAsyncFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode macAsyncFilePrimsFile		ifFalse: [self inform: 'File sqMacAsyncFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNSPlugin.c') contentsOfEntireFile =	InterpreterSupportCode macBrowserPluginFile		ifFalse: [self inform: 'File sqMacNSPlugin.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDragDrop.c') contentsOfEntireFile =	InterpreterSupportCode macDragDropFile		ifFalse: [self inform: 'File sqMacDragDrop.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystickAndTablet.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickAndTabletFile		ifFalse: [self inform: 'File sqMacJoystickAndTablet.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacMinimal.c') contentsOfEntireFile =	InterpreterSupportCode macMinimal		ifFalse: [self inform: 'File sqMacMinimal.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSerialAndMIDIPort.c') contentsOfEntireFile =	InterpreterSupportCode macSerialAndMIDIPortFile		ifFalse: [self inform: 'File sqMacSerialAndMIDIPort.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSecurity.c') contentsOfEntireFile =	InterpreterSupportCode macSecurityFile		ifFalse: [self inform: 'File sqMacSecurity.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqNamedPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakNamedPrimsFile		ifFalse: [self inform: 'File sqNamedPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqVirtualMachine.h') contentsOfEntireFile =	InterpreterSupportCode squeakVirtualMachineHeaderFile		ifFalse: [self inform: 'File sqVirtualMachine.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqVirtualMachine.c') contentsOfEntireFile =	InterpreterSupportCode squeakVirtualMachineFile		ifFalse: [self inform: 'File sqVirtualMachine.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'JMM 2/12/2001 16:27'!writeMacSourceFiles	"Store into this image's folder the C sources files required to support the interpreter on the Macintosh. It also generates the code for the sound synthesis primitives. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate the interpreter code, use the method 'translate:doInlining:' in Interpreter class."	"InterpreterSupportCode writeMacSourceFiles"	self writeSupportFiles.	FFIPlugin writeSupportFiles.	self storeString: self macAsyncFilePrimsFile	onFileNamed: 'sqMacAsyncFilePrims.c'.	self storeString: self macBrowserPluginFile	onFileNamed: 'sqMacNSPlugin.c'.	self storeString: self macDirectoryFile	onFileNamed: 'sqMacDirectory.c'.	self storeString: self macJoystickAndTabletFile  onFileNamed: 'sqMacJoystickAndTablet.c'.	self storeString: self macMinimal		onFileNamed: 'sqMacMinimal.c'.	self storeString: self macNetworkFile		onFileNamed: 'sqMacNetwork.c'.	self storeString: self macDragDropFile	onFileNamed: 'sqMacDragDrop.c'.	self storeString: self macSecurityFile		onFileNamed: 'sqMacSecurity.c'.	self storeString: self macSerialAndMIDIPortFile	onFileNamed: 'sqMacSerialAndMIDIPort.c'.	self storeString: self macSoundFile		onFileNamed: 'sqMacSound.c'.	self storeString: self macWindowFile		onFileNamed: 'sqMacWindow.c'.	self storeString: self macTCPFile			onFileNamed: 'MacTCP.h'.	self storeString: self macAddressXlationFile		onFileNamed: 'AddressXlation.h'.	self storeString: self macDNRFile					onFileNamed: 'dnr.c'.	self storeStuffitArchive: self	 macArchiveBinaryFile		onFileNamed: 'projectArchive.sit'.! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'ar 2/6/2001 14:07'!writeSupportFiles	"Store into this image's folder the C sources files required to support the interpreter on all platforms. This method also generates the code for the sound synthesis and other primitives translated from Smalltalk to C. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate that code, use the method 'translate:doInlining:' in Interpreter class."	"InterpreterSupportCode writeSupportFiles"	self storeString: self readmeFile			onFileNamed: 'readme'.	self storeString: self squeakHeaderFile	onFileNamed: 'sq.h'.	self storeString: self squeakConfigFile	onFileNamed: 'sqConfig.h'.	self storeString: self squeakPlatformExportsFile	onFileNamed: 'platform.exports'.	self storeString: self squeakPlatSpecFile	onFileNamed: 'sqPlatformSpecific.h'.	self storeString: self squeakVirtualMachineHeaderFile	onFileNamed: 'sqVirtualMachine.h'.	self storeString: self squeakVirtualMachineFile	onFileNamed: 'sqVirtualMachine.c'.	self storeString: self squeakNamedPrimsFile onFileNamed:'sqNamedPrims.c'.	self storeString: self squeakFilePrimsFile	onFileNamed:  'sqFilePrims.c'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/16/2001 22:04'!macArchiveBinaryFile	"Answer the binary contents of a StuffIt archive file containing the CodeWarrier project files for the virtual machine. You will need to use a StuffIt unpacking utility such as StuffIt Expander to unpack the file. The result will be a folder containing the project files."	"To create the text for this method evaulate:		| in out |		in _ (FileStream oldFileNamed: 'projectArchive.sit') binary.		out _ WriteStream on: (String new: 100000).		out nextPutAll: '#('.		[in atEnd] whileFalse: [out nextPutAll: in next printString; space].		out skip: -1.		out nextPutAll: ')'.		in close.		Clipboard clipboardText: out contents asText	  and then do paste into this method."	^ #(83 116 117 102 102 73 116 32 40 99 41 49 57 57 55 45 49 57 57 56 32 65 108 97 100 100 105 110 32 83 121 115 116 101 109 115 44 32 73 110 99 46 44 32 104 116 116 112 58 47 47 119 119 119 46 97 108 97 100 100 105 110 115 121 115 46 99 111 109 47 83 116 117 102 102 73 116 47 13 10 26 0 5 16 0 0 109 144 0 0 0 114 0 10 0 0 0 114 220 92 0 43 0 5 1 96 1 255 0 0 0 0 0 0 165 165 165 165 1 0 0 62 0 16 181 144 51 21 182 158 25 127 0 0 0 0 0 0 11 3 0 0 0 0 0 14 47 50 0 0 37 20 0 0 9 183 0 0 0 0 15 0 109 121 77 97 99 72 101 97 100 101 114 115 46 99 0 1 249 212 84 69 88 84 67 87 73 69 1 0 1 128 1 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 106 0 0 0 0 15 0 66 193 212 138 116 88 41 37 231 118 79 249 86 183 220 130 201 119 237 194 11 107 95 101 129 233 78 237 233 41 2 10 134 65 190 14 57 147 88 117 246 30 129 230 100 86 124 160 181 213 228 113 176 242 110 15 116 236 78 49 113 111 82 137 215 100 243 164 56 26 150 173 165 69 200 187 255 179 112 28 55 170 135 33 198 200 235 206 99 142 62 109 255 116 149 57 0 236 41 186 92 188 174 38 174 192 66 193 212 132 70 70 86 227 229 250 240 216 108 46 2 127 7 118 93 193 98 100 220 19 200 129 89 135 89 82 22 238 49 159 133 108 171 14 212 223 34 215 77 208 114 160 164 237 185 214 129 65 199 201 45 211 163 103 203 58 2 85 140 45 151 178 152 115 9 199 215 95 96 151 105 218 21 183 124 139 66 246 165 122 233 239 249 49 33 230 241 98 152 155 66 5 97 56 210 80 40 74 50 161 38 49 191 246 13 248 37 22 30 82 47 247 193 20 8 253 47 112 160 72 112 53 215 204 3 97 248 96 8 243 221 18 149 108 14 129 125 171 25 125 64 92 146 29 121 208 175 185 114 183 252 116 88 47 20 203 91 54 195 197 212 254 215 49 246 175 214 179 20 62 218 106 240 184 65 250 38 189 140 67 51 74 95 30 3 237 219 189 131 26 139 234 59 182 38 237 228 223 81 228 70 109 151 93 182 102 227 203 12 157 152 107 15 98 148 171 41 204 102 172 62 195 233 155 129 52 241 31 197 124 118 99 45 58 83 248 22 215 210 251 42 253 224 32 223 130 124 29 99 117 213 224 39 13 123 115 248 26 221 26 239 139 238 20 111 20 56 127 75 111 87 227 74 59 31 173 85 118 51 26 21 56 145 199 107 6 134 163 54 13 38 143 9 8 177 101 138 176 126 236 42 83 222 165 174 137 128 18 108 62 172 104 206 82 31 153 2 182 57 73 14 84 208 156 251 177 59 232 160 12 252 203 218 179 103 69 40 108 127 129 76 239 43 241 84 12 202 12 118 247 134 247 28 5 26 17 8 152 197 86 37 168 231 169 178 114 72 86 108 222 32 244 59 133 232 143 193 13 133 147 126 127 149 24 121 2 38 68 52 152 209 111 150 184 27 137 253 238 123 197 0 118 134 239 237 36 138 92 9 194 243 159 213 60 212 20 229 59 28 20 233 18 161 31 106 165 1 110 83 216 106 180 249 207 9 174 17 94 185 168 244 3 4 168 140 63 65 99 190 250 119 64 70 17 171 160 166 169 104 159 33 175 236 14 164 90 174 65 175 124 152 30 15 87 146 118 109 236 131 130 220 219 214 112 125 170 137 231 54 250 21 145 43 231 188 66 60 145 144 78 191 182 237 122 40 55 70 174 38 200 113 225 103 84 13 29 121 130 211 114 223 222 52 197 13 242 137 125 59 249 152 208 14 117 204 232 95 173 10 254 158 64 113 32 71 211 118 10 37 152 22 6 193 1 255 147 16 255 96 95 2 197 244 163 41 80 165 64 231 82 177 26 111 196 195 16 244 124 241 119 42 72 98 152 240 138 13 187 140 50 8 203 25 228 139 176 231 43 188 185 2 244 190 171 127 194 95 139 23 204 75 146 60 62 27 80 38 93 38 145 109 19 117 6 190 225 110 85 211 48 214 67 194 48 118 230 103 121 110 231 193 135 164 195 102 232 253 49 148 47 128 195 236 125 10 219 186 74 154 99 167 196 60 86 195 220 106 181 140 85 69 75 218 24 134 11 31 42 184 151 115 226 63 107 52 127 87 90 27 209 125 49 244 52 72 106 47 168 194 221 133 102 80 172 93 30 180 148 98 219 250 1 131 80 231 16 175 251 155 120 51 58 133 74 44 194 98 69 220 203 116 191 232 6 60 149 104 160 232 101 60 176 56 85 193 184 154 196 187 176 181 220 6 241 108 26 22 183 125 180 240 179 101 192 98 125 237 3 89 114 235 91 209 164 113 1 58 129 69 227 29 19 29 199 223 52 106 86 210 28 98 88 130 229 148 120 16 129 14 17 4 222 44 49 251 34 155 53 1 122 248 192 61 173 28 105 15 199 20 82 30 53 37 81 146 117 100 246 78 108 152 234 93 106 164 44 100 57 126 9 134 155 27 184 21 148 185 94 106 50 113 228 79 94 34 151 21 160 54 33 4 249 230 134 176 70 241 249 85 152 252 212 193 251 181 238 242 57 219 252 62 154 74 65 219 88 115 39 77 236 5 188 230 126 109 127 233 91 10 224 186 224 60 237 252 238 150 54 161 201 94 8 244 145 47 44 217 137 239 234 201 42 8 178 49 89 199 176 56 165 31 101 19 109 234 101 137 162 10 229 183 144 68 242 150 52 133 117 88 173 140 84 230 109 53 133 118 31 127 28 54 7 230 85 169 251 254 192 6 169 172 189 140 22 174 91 19 91 125 223 162 84 237 230 213 183 153 250 131 177 111 6 84 183 247 13 76 39 186 31 198 85 4 65 32 19 1 99 145 201 225 227 243 17 214 185 26 33 101 205 44 160 34 195 147 137 18 207 88 193 239 159 19 49 180 186 110 34 91 81 126 47 101 10 118 12 117 42 111 147 156 94 195 157 204 248 229 229 155 103 232 66 107 220 242 138 252 243 151 217 136 131 173 212 193 219 166 253 173 88 80 220 63 46 109 88 232 90 249 96 67 199 255 136 27 154 43 84 216 241 187 178 227 175 65 114 73 13 15 98 255 39 134 162 119 232 163 16 23 93 129 62 166 157 15 154 27 26 22 115 8 168 226 84 233 64 121 6 75 60 59 127 229 225 29 214 193 226 73 79 102 74 60 56 130 137 229 133 2 50 59 52 230 115 36 203 162 101 18 167 216 183 101 153 45 171 24 125 246 212 22 150 51 149 179 153 191 89 161 218 135 97 19 194 50 34 223 113 101 103 136 83 76 55 48 36 80 56 226 27 48 120 156 42 19 32 20 17 57 39 33 219 123 249 192 127 10 182 75 171 92 189 220 14 220 60 159 227 228 14 241 235 112 90 20 251 157 160 3 36 236 95 173 58 230 127 69 243 123 75 97 113 205 83 246 125 11 125 96 36 176 106 177 61 42 181 20 175 94 167 143 126 251 254 160 166 65 77 62 9 249 97 143 85 228 244 116 212 36 139 27 39 2 205 126 120 142 16 221 171 238 9 71 136 127 183 207 62 15 86 53 15 2 102 101 179 61 141 49 213 40 141 163 67 190 184 255 243 129 31 131 167 254 204 179 48 58 103 182 95 167 251 52 47 18 107 18 137 227 164 93 85 188 234 111 109 2 84 181 250 201 87 56 179 139 122 116 9 72 150 26 201 3 16 131 116 158 40 94 162 107 116 254 167 70 163 135 76 238 186 199 185 34 229 206 216 82 176 11 88 86 57 139 30 2 208 123 57 141 221 171 211 186 142 118 126 139 154 109 57 79 1 35 167 40 44 39 213 242 211 220 168 159 200 169 179 212 88 68 78 200 147 37 40 78 169 30 98 229 242 15 101 5 179 4 239 182 164 66 15 21 205 242 169 118 60 166 24 139 110 88 102 100 95 76 164 156 185 94 78 122 188 84 74 244 3 153 155 54 89 214 52 181 186 49 248 74 61 63 130 1 251 48 92 241 131 25 214 90 146 245 111 208 0 200 130 56 240 165 169 148 206 222 128 170 66 144 165 235 199 35 41 172 79 16 73 84 79 60 126 86 20 84 57 189 173 108 83 108 81 41 110 196 34 198 64 130 167 53 95 252 127 145 160 17 25 107 30 200 4 122 235 171 27 245 83 163 114 251 243 83 92 90 202 225 71 136 233 48 236 166 227 153 9 44 86 152 46 157 33 106 211 38 217 131 189 158 77 118 186 137 83 106 231 38 183 90 52 35 137 96 149 252 106 81 140 59 206 123 111 194 70 128 243 110 236 189 248 13 44 218 175 155 189 61 117 24 11 169 190 120 244 49 97 84 33 238 113 123 121 234 200 117 143 213 164 67 118 136 81 156 181 97 170 195 15 90 84 197 162 128 180 123 146 157 140 166 23 62 191 219 207 52 11 47 102 15 132 239 222 55 33 195 105 219 7 235 139 152 116 60 25 96 195 178 61 14 158 181 173 197 130 3 51 243 102 76 103 143 10 245 92 220 236 141 223 116 227 66 7 57 153 114 238 10 230 232 176 12 175 132 255 205 252 18 152 205 169 191 124 59 188 115 70 80 37 198 61 238 169 19 8 73 36 110 103 133 105 74 11 15 219 222 225 80 37 208 46 80 225 212 115 148 86 235 203 83 7 141 117 136 142 4 23 62 124 10 94 45 49 81 53 68 172 40 141 44 61 248 53 189 171 93 232 151 125 187 242 44 48 78 122 14 155 71 149 26 249 110 4 137 252 232 107 95 133 111 248 39 32 216 250 139 71 199 65 188 109 185 222 173 38 154 41 26 203 164 65 78 224 92 171 208 90 72 55 177 173 76 81 231 243 216 204 118 128 229 102 224 120 76 223 0 232 167 190 139 96 143 251 23 60 117 73 185 52 25 41 30 92 16 109 65 55 254 254 173 95 201 191 193 56 212 8 23 212 173 150 167 92 25 22 96 99 170 165 164 40 36 195 183 62 219 4 67 46 22 63 222 5 189 85 231 135 117 193 81 183 28 185 150 204 45 138 16 29 249 195 34 17 152 49 55 161 150 67 67 238 114 100 72 91 0 22 231 161 15 143 49 222 113 6 12 169 143 119 228 135 153 170 60 177 165 119 120 180 81 178 118 192 182 42 171 188 123 62 224 76 89 178 221 232 21 1 32 55 48 174 83 32 204 196 152 115 160 94 162 76 36 234 130 46 208 158 156 130 16 2 200 63 214 12 68 238 216 11 69 230 210 144 197 49 0 137 72 242 7 201 79 14 15 92 223 226 57 137 113 156 96 94 22 62 239 156 25 246 159 72 150 236 47 148 93 81 82 160 65 193 218 226 5 173 68 149 131 185 38 21 54 28 45 163 133 100 249 71 53 193 81 236 219 46 36 117 122 241 67 70 160 158 137 200 28 140 228 117 216 92 197 139 107 45 76 132 225 120 25 241 135 183 155 93 124 61 178 162 153 124 169 222 88 143 122 87 102 247 47 37 141 255 232 110 183 43 235 205 24 115 77 112 204 130 226 183 244 107 237 88 133 215 112 156 91 244 40 149 126 211 18 61 248 243 242 234 1 67 155 205 165 46 241 183 45 57 192 220 209 108 240 103 75 84 225 56 241 98 50 22 74 38 110 229 178 174 113 149 105 219 99 204 9 187 142 57 11 80 19 222 31 78 163 164 81 225 238 93 139 39 45 77 116 191 122 147 93 63 47 1 43 54 59 33 120 183 197 115 221 125 55 140 107 197 207 252 168 189 93 204 160 15 6 92 87 21 69 13 171 60 68 240 229 169 136 185 10 16 114 157 62 4 62 98 10 25 57 208 210 238 206 221 244 23 46 24 203 6 182 53 192 196 161 244 15 113 51 114 84 111 207 79 49 240 83 61 153 132 114 177 48 194 95 237 67 44 187 237 135 159 159 33 223 31 214 108 74 197 120 50 91 204 64 45 244 193 54 170 53 199 41 10 70 220 145 68 218 10 32 158 205 48 186 18 120 100 158 47 3 157 62 91 7 54 31 217 83 233 226 95 125 28 51 6 123 194 39 147 63 52 100 201 220 96 226 242 131 85 96 214 22 71 194 69 5 99 37 88 48 22 245 153 70 245 85 38 116 133 224 61 191 197 143 169 70 94 167 89 162 114 248 119 73 40 186 97 52 83 229 239 50 37 67 25 0 165 165 165 165 1 0 0 64 0 16 181 144 51 13 182 158 25 127 0 0 0 114 0 0 13 78 0 0 0 0 0 16 118 69 0 0 3 20 0 0 1 114 0 0 0 0 15 0 109 121 77 97 99 72 101 97 100 101 114 115 46 112 99 104 0 1 88 136 84 69 88 84 67 87 73 69 1 0 0 192 2 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 103 0 0 0 0 15 0 66 193 212 165 47 158 101 143 90 111 232 62 137 252 56 69 246 56 222 197 11 110 186 70 46 68 245 227 157 58 176 118 108 255 85 62 40 178 85 18 69 169 203 40 18 219 49 207 252 15 57 78 136 238 192 137 69 135 101 84 46 156 13 5 175 9 5 162 245 172 207 165 169 206 88 73 211 171 164 174 112 63 71 184 31 221 37 166 79 5 131 15 114 244 238 207 216 239 17 227 177 67 160 66 193 212 154 175 240 32 110 231 176 220 75 122 67 45 140 218 152 26 188 19 16 70 46 100 12 102 162 171 207 147 232 46 129 230 224 142 44 70 162 102 82 16 65 169 232 58 197 1 226 230 247 241 20 175 215 67 32 203 217 208 134 187 150 162 63 110 169 185 56 142 225 246 180 33 114 124 5 37 84 212 128 30 164 229 208 216 224 187 2 126 209 51 142 7 56 139 220 232 168 56 210 119 197 236 95 113 121 147 62 5 16 6 102 148 120 76 237 88 4 46 152 207 227 190 58 105 25 63 228 30 242 145 30 205 193 119 28 65 161 6 85 113 254 35 25 218 241 155 57 46 34 101 87 219 177 175 90 37 23 192 16 110 135 14 201 90 113 155 204 60 215 16 232 111 135 218 123 36 119 224 93 163 67 233 232 62 127 241 177 118 93 131 253 225 94 147 211 226 106 223 56 140 40 243 210 212 240 205 25 69 158 223 23 7 45 121 161 103 21 93 76 191 131 11 37 220 95 159 108 53 71 237 228 38 192 96 36 234 168 14 101 68 218 187 125 239 67 136 208 224 145 202 41 73 44 92 125 93 164 127 252 148 199 42 76 2 0 50 102 61 155 95 144 49 242 226 212 139 39 169 250 165 133 244 188 11 198 113 244 133 255 208 95 234 165 90 112 27 52 250 90 78 166 0 202 127 35 59 223 131 14 154 81 218 181 53 29 254 103 48 33 191 225 6 186 233 121 161 97 169 147 218 120 247 111 39 193 212 57 27 102 129 167 141 48 58 146 236 83 180 135 36 193 196 77 181 97 218 24 94 119 88 225 88 61 107 38 42 0 165 165 165 165 1 0 0 70 0 16 181 144 51 13 182 158 25 125 0 0 11 3 0 0 15 252 0 0 0 0 0 22 20 235 0 0 3 180 0 0 1 205 0 0 0 0 15 0 109 121 77 97 99 72 101 97 100 101 114 115 67 97 114 98 111 110 46 112 99 104 0 1 219 219 84 69 88 84 67 87 73 69 1 0 0 16 0 16 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 105 0 0 0 0 15 0 66 193 212 165 47 158 104 163 81 45 121 217 33 168 151 12 136 51 216 133 159 78 214 216 43 6 93 88 173 49 224 16 210 176 244 190 46 112 249 208 12 31 155 208 114 175 160 237 166 80 129 149 37 165 111 12 49 64 250 168 169 159 82 99 244 238 46 66 203 196 69 63 252 89 175 97 38 187 103 169 162 122 93 198 238 248 174 171 90 231 91 24 116 109 194 102 235 220 101 188 198 239 167 48 0 66 193 212 247 142 41 244 252 170 32 131 125 120 226 219 34 155 40 95 65 156 245 152 111 218 35 102 116 216 131 145 17 84 107 97 158 240 249 195 150 60 120 140 104 228 134 193 204 31 57 215 166 99 44 206 176 32 16 144 208 6 248 187 61 109 226 227 51 211 25 218 191 40 12 114 22 28 230 0 112 11 172 202 32 219 160 175 46 72 139 187 24 169 29 138 113 109 138 194 65 131 26 203 70 229 19 88 5 218 129 23 174 244 179 27 110 213 99 88 249 52 149 107 131 128 11 191 219 77 60 140 147 221 41 5 154 71 244 111 11 122 216 102 224 199 124 224 181 243 197 90 177 66 36 17 3 41 236 155 135 117 157 197 125 86 112 49 216 189 27 139 184 235 236 11 77 248 224 96 79 164 194 90 103 41 162 119 82 173 71 116 83 120 63 237 133 59 95 243 179 182 38 66 89 112 120 57 175 247 2 86 164 221 215 242 66 72 241 206 94 82 185 213 183 84 158 243 111 184 131 123 154 113 69 129 63 216 193 18 183 237 229 86 226 139 223 239 210 173 153 53 67 49 7 198 215 211 213 85 237 110 87 144 203 47 169 210 32 17 124 119 167 84 218 32 64 80 64 213 139 46 73 67 237 85 242 129 68 80 18 116 121 38 21 132 110 38 88 152 155 85 234 152 132 14 186 223 127 213 177 161 118 126 164 93 140 86 9 39 140 158 128 15 121 128 22 82 198 32 125 160 105 176 229 213 67 60 105 93 166 53 20 133 196 110 63 239 200 252 182 252 210 104 194 171 61 38 193 140 109 223 92 105 43 228 169 222 61 252 104 255 66 238 34 62 131 239 211 193 88 118 48 247 65 45 181 8 92 165 55 106 219 2 60 38 114 62 64 145 43 151 179 227 59 232 214 164 43 226 209 187 193 230 212 51 34 107 155 72 0 26 242 4 241 9 64 80 182 179 217 254 181 123 67 245 13 80 221 209 230 9 60 229 105 10 138 253 27 231 68 155 196 137 233 97 229 82 175 213 222 96 165 165 165 165 1 0 0 61 0 0 172 94 103 33 181 100 42 6 0 0 13 78 0 0 28 169 0 0 0 0 0 13 171 241 0 0 7 218 0 0 2 139 0 0 0 0 15 0 77 121 80 108 117 103 105 110 46 112 114 111 106 0 1 46 58 77 77 80 82 67 87 73 69 1 0 3 64 1 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 43 27 0 0 9 179 0 0 0 0 15 0 66 193 212 194 19 180 140 109 220 205 78 57 63 90 66 84 57 156 71 10 240 179 194 234 180 76 49 136 61 86 193 33 87 165 51 39 174 141 114 32 57 229 43 22 87 128 72 84 38 117 129 4 182 215 234 186 97 240 130 6 7 168 37 149 122 3 125 3 195 87 185 151 254 22 251 249 238 210 167 130 219 121 155 186 134 229 95 75 152 58 93 250 123 38 106 43 222 218 75 149 20 150 219 56 44 81 228 23 54 251 165 214 237 251 0 192 205 43 113 64 228 181 201 133 51 84 209 66 37 59 176 144 234 4 186 142 81 128 228 2 55 216 158 134 41 177 194 7 95 252 212 255 73 83 237 231 200 33 245 234 99 190 79 33 76 97 115 253 35 55 46 42 13 118 116 73 161 215 249 23 162 74 26 161 34 208 52 177 148 31 2 225 128 147 212 218 175 235 77 215 179 45 41 42 83 138 73 222 20 4 247 49 227 152 237 224 96 210 249 218 162 93 24 168 187 8 67 87 106 36 240 23 14 253 32 32 233 250 182 103 110 104 23 208 218 230 121 74 225 57 124 53 128 60 111 91 170 168 211 245 68 13 214 181 216 230 12 119 31 218 154 171 103 239 30 230 22 188 226 29 238 162 224 59 253 70 31 56 103 224 36 245 159 238 139 104 201 201 132 39 227 128 0 62 234 60 136 63 255 195 11 172 202 17 37 216 84 146 63 219 54 56 151 166 38 241 106 221 197 103 27 237 182 165 6 183 114 101 218 141 240 64 148 45 222 37 21 103 254 127 46 56 173 37 215 210 155 156 143 214 184 249 118 238 209 196 193 63 132 149 152 85 92 181 13 27 221 176 225 145 152 79 7 62 97 181 120 39 91 165 74 115 184 46 199 3 192 153 218 145 229 140 225 48 115 235 24 105 61 157 168 6 39 4 200 157 182 175 112 130 106 48 11 175 17 0 192 51 97 61 92 231 192 128 4 202 158 82 84 178 6 244 58 194 143 198 197 84 245 194 178 69 38 193 153 99 228 73 197 137 51 95 234 74 220 141 111 161 135 191 121 33 201 254 51 7 28 164 179 195 57 17 73 210 193 161 123 149 11 73 41 75 25 196 86 100 212 137 148 255 191 61 249 212 167 243 124 178 252 243 230 210 105 103 137 88 244 8 170 166 127 33 239 33 76 177 46 165 94 119 60 57 69 82 53 93 97 113 18 211 180 59 221 195 107 202 4 125 117 172 218 169 252 32 46 1 54 41 228 135 201 89 109 105 202 112 20 196 166 41 173 208 173 27 148 202 143 245 25 142 72 111 18 240 135 44 9 113 199 4 252 36 142 207 253 43 184 119 116 86 138 249 177 138 141 63 33 191 93 190 139 209 129 212 216 83 151 194 200 24 252 41 196 242 80 71 41 30 226 43 28 209 35 219 218 177 65 128 188 55 183 237 64 231 242 161 168 189 135 114 61 217 9 64 19 4 196 99 134 88 34 235 184 97 44 234 25 195 176 83 127 209 207 190 234 196 243 14 19 177 134 74 190 120 202 207 65 100 1 59 62 46 48 80 135 3 9 73 242 18 57 109 183 245 222 178 216 183 84 76 56 208 27 8 158 248 66 214 155 165 188 137 94 194 111 156 211 2 200 53 127 166 203 170 79 164 98 8 33 169 242 184 152 189 171 140 226 112 193 38 34 179 149 178 39 37 88 11 56 158 240 172 153 69 71 107 203 187 140 154 176 235 8 151 194 172 241 194 59 173 162 204 166 181 114 97 224 92 71 116 144 235 121 221 159 124 218 189 170 239 83 135 28 243 178 223 131 227 17 146 169 220 93 31 64 246 60 114 194 162 48 94 192 255 37 210 128 223 90 148 255 167 134 204 96 230 126 180 73 114 139 161 17 171 76 130 56 199 160 130 180 229 165 79 185 10 128 134 241 79 80 147 118 89 165 116 61 94 67 177 61 154 226 10 230 26 219 235 251 35 12 194 40 38 35 252 251 191 11 198 3 254 127 229 204 232 61 105 255 53 135 108 128 24 78 193 229 23 109 141 167 141 113 72 6 184 7 83 149 143 141 161 13 193 130 105 121 159 72 83 255 218 246 207 168 2 188 251 220 106 202 121 24 137 85 236 151 184 191 38 29 12 123 142 42 244 196 40 124 66 26 203 78 220 166 73 142 150 63 166 17 119 99 243 166 176 210 220 215 118 253 59 143 35 122 222 50 58 29 51 211 19 174 220 236 227 198 71 227 70 156 97 25 76 78 210 252 109 98 200 134 0 148 114 221 154 66 23 196 248 37 253 225 184 18 33 116 236 252 67 236 135 114 205 157 120 160 155 132 133 60 83 40 206 205 65 122 27 3 244 137 119 158 91 42 59 189 57 230 202 3 71 214 181 17 91 237 71 219 25 87 69 187 54 79 222 40 229 9 229 71 160 174 72 187 107 25 142 156 159 128 201 103 230 130 228 230 37 21 220 76 245 164 173 70 236 120 248 32 0 235 8 226 156 150 195 159 49 115 251 27 199 242 115 185 77 140 190 205 244 7 223 191 94 162 200 1 170 101 82 196 36 62 145 104 149 184 123 177 153 15 220 14 50 253 40 5 192 198 227 129 195 234 3 23 1 199 104 182 67 51 17 31 177 252 147 96 76 24 221 202 12 236 136 115 123 75 165 115 55 2 242 194 9 252 13 250 160 95 132 217 253 162 222 168 205 117 26 224 163 41 136 164 32 42 40 60 7 24 87 230 249 31 58 236 150 135 184 249 22 205 31 97 180 112 137 182 250 89 4 221 38 113 74 247 168 206 215 112 54 174 17 124 134 22 229 141 40 117 220 60 36 142 159 28 196 12 79 250 234 136 200 220 192 151 253 59 63 143 176 44 197 118 7 251 9 88 225 69 165 197 229 146 92 13 230 142 60 188 7 204 81 241 42 116 68 128 100 171 169 163 137 188 9 17 212 4 231 195 226 170 216 196 24 94 172 65 211 52 75 97 206 167 143 24 61 168 230 229 31 239 42 70 74 67 179 96 52 199 96 80 117 42 122 92 36 146 138 21 213 65 96 75 175 232 31 107 43 33 91 231 154 123 5 24 28 139 122 138 127 91 147 185 79 21 150 196 39 242 145 196 148 195 22 235 187 30 46 175 109 249 30 33 44 231 138 19 255 207 171 119 184 201 171 190 52 6 187 143 13 176 206 38 141 52 54 14 234 19 13 72 228 115 134 239 231 78 161 68 240 39 189 238 92 137 134 220 92 228 98 165 0 223 127 16 233 228 150 150 183 157 213 170 18 108 187 193 244 40 94 214 27 214 103 133 11 23 106 140 153 150 249 216 192 173 245 226 15 71 223 152 10 15 241 34 209 142 177 116 19 237 153 115 235 149 33 51 8 136 185 42 26 124 13 143 64 6 191 151 249 2 34 136 141 198 23 227 78 45 51 175 180 143 131 177 93 122 47 116 190 243 99 42 32 159 106 87 251 223 159 179 37 63 143 200 173 119 171 27 79 79 149 2 209 224 156 255 224 213 5 208 114 14 166 128 135 141 222 107 146 148 60 212 87 95 249 62 108 29 151 193 171 48 111 202 218 27 135 180 253 254 184 223 129 63 91 60 123 221 98 165 199 70 36 4 155 209 197 95 213 90 27 172 67 75 182 52 134 225 138 50 128 100 245 153 1 73 95 228 92 254 186 19 225 208 85 38 151 24 215 131 149 191 230 74 57 107 248 227 229 111 209 108 16 211 152 104 163 251 128 215 147 85 150 15 43 134 83 159 42 239 54 28 40 73 52 207 84 129 239 98 214 179 21 102 137 178 110 247 152 202 120 33 245 91 121 128 234 177 58 4 101 109 183 205 222 157 164 79 7 109 210 19 253 233 66 110 212 180 156 55 124 37 83 157 36 52 71 108 27 185 118 84 11 222 1 186 180 176 54 75 2 134 10 200 41 247 243 115 198 166 236 142 190 189 239 126 125 106 88 219 213 89 86 112 164 28 237 40 73 163 214 41 167 51 226 144 185 109 128 31 24 46 11 81 151 124 82 134 29 127 35 25 190 38 212 98 223 126 203 32 60 74 103 251 72 156 19 78 206 72 239 13 5 249 184 234 54 28 128 245 0 249 90 69 3 123 98 160 210 186 41 73 17 3 28 112 129 216 217 199 108 97 59 3 225 73 152 69 217 146 229 62 27 45 119 23 226 20 9 145 94 46 115 121 134 233 179 133 155 94 199 108 100 28 131 175 206 140 90 173 14 18 76 19 202 83 159 22 214 223 144 183 119 149 129 120 70 181 99 68 133 35 149 192 17 182 40 216 129 186 185 222 109 72 135 219 119 115 196 249 44 150 83 58 212 26 210 154 53 109 49 36 39 146 188 84 202 107 117 165 30 161 103 160 138 30 154 85 67 10 214 221 117 225 102 176 143 120 211 187 176 196 245 60 28 179 165 154 167 22 55 97 242 45 252 235 170 218 20 43 72 243 201 54 123 101 20 33 48 168 180 233 60 232 203 7 66 56 124 146 214 112 254 140 37 96 243 38 179 116 69 25 227 129 70 166 160 195 95 119 149 251 212 214 138 62 183 247 149 85 11 116 61 189 17 187 149 100 21 248 121 103 245 72 14 36 248 191 128 103 91 132 118 39 131 121 52 247 206 93 47 82 113 11 31 148 91 121 169 110 211 31 34 248 177 165 90 108 123 99 171 35 104 32 238 176 63 65 30 99 58 169 225 58 211 237 4 229 142 123 59 108 223 136 197 220 218 91 179 0 121 93 76 67 65 204 151 161 33 65 74 212 79 82 70 71 34 30 120 110 193 0 36 170 193 44 45 143 228 131 205 150 244 160 150 106 22 65 152 121 20 125 25 104 52 133 104 165 184 88 121 83 121 93 99 250 114 15 118 56 143 178 96 88 189 162 5 211 244 73 153 40 207 205 71 138 167 60 186 201 213 118 68 181 199 75 78 195 34 132 17 127 183 98 72 65 22 255 140 196 232 205 157 2 110 42 175 37 4 30 101 25 242 48 107 25 105 159 30 213 210 157 118 121 51 157 187 180 131 3 44 5 185 15 215 79 162 2 26 65 168 188 175 126 122 46 117 97 63 225 223 18 22 211 203 44 218 82 158 29 119 110 57 91 14 143 66 109 2 240 56 94 247 35 47 101 146 49 98 29 193 204 226 150 16 203 189 11 251 203 208 29 186 250 218 53 107 74 41 140 45 140 4 31 27 113 69 36 188 128 46 81 132 34 77 101 50 169 28 156 133 164 129 253 215 241 194 174 172 194 42 220 190 205 227 223 125 42 185 109 222 61 100 144 193 147 66 193 232 72 220 164 225 179 24 189 206 106 11 94 84 43 63 244 25 229 114 152 79 232 252 147 54 43 138 6 104 248 81 78 162 136 226 36 206 113 106 248 66 115 193 28 216 164 130 112 222 54 251 213 143 169 214 127 195 37 79 48 191 31 239 222 47 54 197 188 194 74 4 90 50 70 38 100 59 49 223 218 178 37 231 49 12 152 217 227 91 99 20 154 159 152 122 106 149 86 103 187 70 156 1 251 186 172 207 166 67 51 147 24 159 0 66 193 212 209 173 202 54 121 186 247 106 241 139 248 136 144 151 199 247 80 188 144 101 75 21 223 57 158 220 219 236 232 23 100 202 212 173 34 206 147 90 245 218 205 94 143 37 178 123 245 10 207 222 177 255 205 243 59 2 92 205 14 246 210 227 42 114 60 115 43 247 225 110 54 179 180 171 8 226 94 227 206 84 12 108 245 165 220 186 62 202 190 198 31 48 221 104 253 145 8 22 239 235 157 224 89 115 154 66 225 233 26 132 65 101 103 113 198 133 195 218 235 163 15 66 48 130 138 254 104 191 21 132 73 188 3 18 49 233 212 33 173 203 85 255 167 237 129 60 173 232 204 54 14 112 18 11 20 121 253 133 205 30 128 169 42 1 114 138 184 35 247 111 197 232 255 8 125 197 39 27 123 188 217 183 113 101 115 55 200 76 41 136 182 194 36 115 226 46 180 223 15 180 184 199 127 207 175 183 18 108 253 224 68 225 189 230 145 197 113 58 99 64 169 236 231 55 89 138 194 172 139 126 15 235 114 7 190 146 185 206 38 26 160 116 201 4 85 157 75 151 138 219 4 150 5 192 67 120 123 231 151 29 125 34 237 37 125 175 14 219 63 40 148 37 198 227 142 220 5 165 190 80 20 226 226 188 106 110 189 68 213 83 144 111 161 33 212 140 77 52 244 117 247 254 247 134 221 112 95 223 125 162 95 247 113 127 148 138 20 251 103 234 125 73 19 94 81 44 249 114 11 173 196 15 63 229 13 115 251 195 11 98 206 183 202 33 193 89 219 11 110 155 116 53 252 253 48 32 153 170 120 19 185 239 38 248 134 53 99 79 234 178 251 112 68 87 151 119 91 159 228 132 234 207 90 233 251 86 23 140 87 198 204 228 239 33 97 205 23 105 57 191 169 94 234 175 182 54 157 209 165 39 1 23 153 99 4 83 250 118 150 110 225 141 205 108 23 85 157 117 151 134 213 237 178 162 80 51 220 165 2 220 8 167 35 52 225 141 195 156 254 21 76 95 231 237 249 231 199 223 249 56 16 105 49 246 179 86 86 199 222 103 162 50 165 41 77 133 132 4 246 90 221 161 237 175 20 1 224 5 208 134 151 85 245 81 241 166 113 128 176 170 18 208 148 167 107 165 84 201 247 77 110 178 243 212 76 28 185 151 25 3 254 91 135 233 7 181 194 191 189 100 178 100 20 92 126 239 85 113 127 203 20 251 252 161 1 63 35 197 97 30 51 62 136 236 104 162 216 84 86 49 130 181 92 215 169 183 20 181 106 88 75 233 118 139 43 234 2 58 27 15 194 152 140 103 217 39 100 170 4 96 201 205 75 153 189 203 211 117 177 25 176 204 93 16 68 7 53 84 183 210 189 91 68 187 188 136 34 168 145 152 249 26 42 26 225 31 239 15 249 137 120 247 29 172 107 103 137 180 207 217 121 27 149 32 90 137 141 176 165 165 165 165 1 0 0 64 0 0 172 94 103 33 181 100 23 240 0 0 15 252 0 0 40 248 0 0 0 0 0 16 180 253 0 0 7 90 0 0 2 148 0 0 0 0 15 0 77 121 80 108 117 103 105 110 54 56 75 46 112 114 111 106 0 1 162 139 77 77 80 82 67 87 73 69 1 0 3 128 0 129 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 37 135 0 0 9 73 0 0 0 0 15 0 66 193 212 169 9 210 149 55 104 18 166 123 198 254 115 231 189 56 26 63 233 107 89 215 26 41 64 39 168 254 239 247 106 245 213 179 37 162 85 150 47 25 75 142 73 147 42 103 39 18 89 87 185 158 183 144 191 121 197 58 247 237 47 168 4 250 221 80 196 140 250 2 153 82 24 7 101 152 165 56 154 236 133 124 32 161 65 134 202 240 234 38 74 220 207 29 183 187 78 143 128 78 228 25 224 83 50 226 241 200 15 193 111 178 15 246 78 206 228 147 246 197 203 10 10 242 105 41 4 66 205 9 1 225 252 22 138 140 209 6 181 240 179 154 27 24 6 94 118 33 215 71 251 65 6 46 194 156 224 245 152 248 245 163 117 106 184 81 55 44 43 63 12 15 131 173 177 63 58 108 90 116 237 57 130 18 45 207 39 168 184 124 14 234 151 77 158 24 238 174 149 45 154 30 127 131 200 231 47 199 96 208 217 78 147 104 4 219 175 174 33 142 236 210 130 219 100 211 116 254 15 231 119 8 95 0 178 98 122 210 142 229 104 67 70 12 175 141 92 58 110 110 125 213 36 115 84 117 144 245 75 148 181 55 130 172 219 99 192 169 188 102 174 245 3 98 201 249 187 198 155 60 173 205 234 41 227 58 211 109 39 124 98 234 206 156 15 73 86 25 233 109 125 254 184 178 214 178 133 136 246 117 48 173 55 248 26 8 190 78 97 200 67 23 26 223 148 9 135 229 250 93 43 221 207 238 48 11 146 126 167 202 57 129 122 208 16 68 11 171 85 193 55 197 75 206 6 101 225 159 104 37 53 24 149 113 98 108 118 35 180 159 124 25 241 188 82 51 147 186 228 19 144 214 103 241 33 199 95 1 89 148 121 49 217 177 30 75 206 83 68 131 49 235 210 72 87 124 132 117 54 28 248 36 131 82 144 238 147 41 18 75 146 21 97 35 176 24 27 156 45 171 65 232 213 217 183 86 97 199 127 122 105 229 192 146 21 171 163 104 83 164 85 85 159 97 16 133 250 117 123 35 109 109 221 183 95 120 25 237 167 23 213 43 6 178 186 44 154 201 162 86 26 136 87 11 90 163 230 224 102 104 162 19 246 228 233 218 91 12 199 141 183 74 205 224 12 153 150 177 85 0 41 202 28 63 57 160 34 129 152 15 10 240 140 213 45 91 151 230 63 252 32 81 62 58 251 113 147 52 74 212 214 30 114 32 135 185 204 7 224 181 26 172 91 169 81 65 140 201 52 185 195 170 193 233 103 214 112 109 65 219 94 83 253 182 167 152 47 211 90 104 203 34 241 216 55 162 73 128 24 254 18 243 43 51 199 224 93 181 216 4 195 100 21 1 142 111 89 99 181 120 228 69 89 150 166 67 160 133 83 74 25 120 228 202 151 213 197 238 169 7 25 75 215 132 139 13 128 148 42 185 174 244 128 76 188 161 166 164 16 51 147 115 251 235 205 105 232 86 142 76 237 244 167 29 43 177 248 156 194 246 97 15 7 255 213 141 41 156 105 175 207 13 3 192 68 119 2 85 97 230 126 53 40 79 97 45 221 168 205 66 34 36 28 180 173 22 22 180 51 194 56 193 255 243 75 101 57 141 155 154 6 150 42 8 180 204 128 177 95 60 122 220 131 125 225 225 49 227 224 60 187 72 148 80 225 109 173 250 161 103 80 190 248 119 106 225 182 172 156 189 14 39 39 172 51 134 119 87 74 119 174 13 184 80 179 206 211 203 197 4 98 108 88 244 9 167 90 0 179 111 74 175 93 37 151 71 255 226 242 57 3 70 223 10 238 143 109 72 108 218 5 38 140 97 70 133 196 185 229 124 137 190 203 76 81 53 60 4 82 244 201 125 216 66 13 237 218 214 208 120 143 242 251 23 135 220 72 32 82 237 68 189 70 62 224 254 70 62 224 229 134 119 188 130 31 152 255 212 226 149 189 221 60 223 148 73 202 157 18 249 54 56 126 101 207 255 58 91 68 133 67 118 98 230 235 242 45 38 75 183 17 235 204 212 204 222 45 249 140 101 163 86 59 125 195 111 43 228 127 205 120 199 85 241 203 115 36 38 114 138 200 134 12 65 52 23 170 58 186 89 15 23 144 208 141 125 252 131 154 213 103 133 164 20 24 181 20 212 220 255 114 55 158 205 47 147 146 107 120 61 236 170 84 104 212 61 32 201 252 208 92 120 214 182 30 6 28 5 1 22 67 109 244 114 222 27 168 58 178 108 199 187 12 57 225 72 255 253 245 130 250 31 222 250 246 10 101 46 52 182 55 251 253 245 81 49 245 105 93 45 82 221 74 249 125 1 22 82 12 24 109 64 86 153 199 117 92 85 16 118 131 199 159 35 198 115 25 194 53 204 76 60 91 61 99 94 137 235 45 223 47 205 83 53 161 9 165 132 157 86 145 51 163 200 190 148 205 153 118 167 140 3 86 133 127 81 179 26 56 173 105 221 157 174 25 29 252 191 134 231 205 247 66 63 40 168 20 174 40 253 99 88 50 93 57 46 77 42 38 230 44 152 237 96 246 158 174 127 80 223 21 171 208 218 64 83 60 6 39 178 161 246 16 149 28 35 238 182 210 44 48 166 87 16 17 60 128 20 135 242 84 199 79 197 192 216 159 45 88 172 97 28 155 254 95 247 229 19 84 119 64 208 127 23 119 239 50 27 133 55 86 37 222 63 40 63 237 92 219 43 139 185 171 144 78 174 41 45 134 33 179 81 222 241 244 47 230 107 206 53 93 206 223 25 220 198 187 145 188 22 208 189 21 158 201 29 156 207 162 236 106 151 65 58 250 220 39 200 228 244 143 101 56 32 72 194 32 92 161 170 95 226 91 247 74 68 91 243 111 13 53 30 159 155 43 194 142 72 76 100 240 231 155 202 2 170 87 103 101 137 13 158 138 204 152 21 128 163 227 158 239 113 74 203 205 138 28 253 172 176 47 237 128 246 167 129 252 181 12 189 44 9 25 249 55 100 198 20 247 11 221 58 43 244 154 235 66 177 195 182 215 227 81 34 233 12 208 171 215 60 228 237 247 68 237 254 101 72 11 189 214 132 0 237 192 83 247 146 44 29 115 128 161 61 99 89 134 224 142 199 58 193 76 75 167 233 190 242 240 211 62 140 149 132 19 231 30 187 11 119 216 16 130 123 220 109 76 105 8 8 51 177 93 127 176 168 236 224 185 239 147 241 252 89 235 117 89 232 240 134 105 5 97 209 251 211 122 163 130 146 101 27 0 163 26 227 99 143 189 100 252 184 92 204 15 249 41 66 137 162 186 236 108 107 110 37 6 27 122 43 43 183 9 177 188 52 107 174 190 52 142 8 234 72 246 140 207 86 16 62 58 111 246 174 164 206 167 225 25 226 156 194 36 44 43 216 74 52 246 175 115 93 50 77 141 193 52 62 121 123 202 32 231 159 172 154 127 94 71 139 59 99 60 95 93 5 219 230 131 152 119 71 166 108 172 186 159 236 122 151 241 89 190 225 248 70 6 59 222 41 63 1 165 51 242 86 140 13 190 182 4 62 76 202 29 142 235 136 247 213 221 89 87 129 198 64 125 243 139 125 99 248 77 77 161 154 149 206 132 228 19 219 21 20 117 100 106 17 25 129 82 47 223 238 149 91 209 180 62 152 199 225 74 120 88 182 193 105 50 55 18 249 249 177 21 79 110 42 239 129 88 200 29 133 34 98 15 45 175 191 221 140 248 216 149 245 89 166 178 80 182 78 190 69 50 222 205 239 161 190 224 7 58 209 212 252 3 217 253 195 183 64 52 49 155 161 91 219 253 14 98 134 170 152 67 190 151 34 0 244 30 29 40 140 166 74 48 227 156 179 126 37 235 250 104 255 27 136 65 183 130 244 43 240 35 123 226 134 15 235 124 3 209 133 214 35 208 2 203 15 238 71 79 163 249 77 38 232 160 127 174 99 90 151 104 248 47 21 102 40 10 75 7 38 213 12 191 187 208 175 51 104 120 67 247 117 94 241 128 200 6 166 210 115 55 169 169 217 14 21 75 98 182 140 181 241 103 66 242 210 58 92 215 100 223 168 223 224 23 185 68 213 123 36 81 24 49 168 209 69 245 79 245 26 172 28 132 233 201 18 122 188 2 206 212 185 33 163 205 123 122 253 31 107 244 225 171 154 126 238 192 76 97 3 130 6 136 89 106 53 55 117 226 25 20 196 35 147 112 210 205 162 106 50 158 32 159 46 222 213 182 51 197 240 80 51 244 161 110 150 205 10 210 29 211 191 134 8 62 165 173 11 212 161 149 21 59 192 148 10 206 136 162 153 70 254 239 231 184 38 59 63 15 77 159 36 158 37 220 110 219 185 101 189 130 102 113 59 89 8 251 111 16 111 199 206 9 183 37 71 67 15 254 146 122 128 22 246 172 83 255 83 89 0 246 254 92 199 238 49 177 50 56 60 7 47 70 50 98 209 93 12 210 64 75 186 162 82 59 16 42 28 252 150 217 13 179 131 109 44 168 155 109 124 107 172 34 39 56 93 136 156 226 51 195 139 240 86 22 205 163 244 246 122 13 115 134 172 202 203 8 83 178 251 160 6 219 89 67 181 18 209 214 63 231 59 24 227 158 23 7 240 58 71 177 7 113 158 183 64 244 85 7 107 227 60 68 82 254 89 181 121 244 154 127 239 164 100 253 201 24 40 247 95 2 117 74 39 105 8 93 65 60 200 39 164 174 113 104 28 234 29 2 248 240 139 89 240 62 145 199 95 144 239 95 112 133 161 248 7 69 77 160 179 10 214 118 130 47 36 196 113 185 107 12 184 128 166 184 156 240 64 39 22 137 148 42 166 209 186 106 148 29 222 181 182 12 140 98 107 232 202 192 126 214 67 12 90 3 7 248 95 36 76 59 188 66 63 98 47 55 72 103 196 189 55 155 89 36 43 7 171 26 228 14 129 26 180 143 57 83 243 131 55 10 86 141 23 182 84 53 42 118 71 72 221 140 17 103 43 14 243 168 38 236 161 104 222 196 131 99 100 2 95 182 238 89 158 129 168 152 135 33 197 190 201 123 56 211 17 219 71 63 164 17 28 210 229 135 70 215 21 37 111 40 118 238 71 231 185 92 225 238 138 15 196 191 125 76 175 41 229 73 155 45 56 91 234 166 249 104 4 179 127 38 179 30 101 157 148 54 199 109 249 21 239 65 56 118 173 182 77 172 225 67 185 168 180 146 85 179 50 125 131 216 129 42 197 47 124 221 171 199 98 155 4 245 181 64 165 225 148 159 88 65 126 225 27 188 72 65 126 66 80 88 14 250 23 35 36 212 224 92 173 32 66 193 212 120 244 150 156 45 75 143 253 186 160 103 148 110 138 210 209 163 125 11 126 208 172 225 255 129 97 133 7 117 173 34 14 198 74 241 119 114 179 69 78 241 172 212 89 124 91 120 8 205 235 82 98 142 194 32 245 179 201 44 162 110 214 68 254 158 4 147 19 254 191 118 156 232 12 254 184 209 40 217 121 173 182 158 0 168 203 19 227 183 248 42 166 119 134 20 184 72 174 2 197 58 133 29 213 233 74 101 1 85 71 25 150 55 32 225 207 234 168 1 132 48 188 104 84 53 145 212 222 88 12 164 128 218 29 207 78 77 249 16 88 28 232 164 142 192 159 5 8 135 38 217 75 132 1 169 131 180 254 194 85 160 186 146 180 24 82 91 133 163 169 12 134 152 70 138 133 74 186 173 245 88 137 116 233 235 3 118 28 107 126 133 54 54 53 235 170 9 149 65 194 190 72 136 43 247 87 106 245 14 28 216 174 131 61 75 2 32 48 18 90 42 185 42 139 107 94 143 236 239 204 214 131 5 194 198 84 239 253 129 60 182 156 134 15 194 224 152 87 64 148 238 6 49 222 188 124 178 199 34 127 212 174 139 147 19 174 19 177 25 35 173 239 20 162 133 142 35 21 226 49 117 215 117 82 150 137 206 32 224 106 132 88 229 130 225 121 252 199 118 93 193 14 161 171 76 13 36 30 78 89 226 51 243 117 178 220 71 194 253 155 147 117 169 112 214 170 151 80 176 47 113 137 200 71 128 223 66 205 149 141 14 174 254 215 224 212 209 129 71 42 114 80 117 179 6 107 207 86 126 92 5 186 201 125 182 1 242 50 66 210 232 200 192 245 137 242 31 142 235 147 161 97 3 161 124 80 122 86 211 86 19 222 78 188 48 94 226 5 28 139 115 71 189 71 214 76 63 3 208 118 242 103 42 218 166 31 193 172 90 1 221 207 45 41 132 69 109 253 53 20 18 46 39 129 112 108 97 15 218 100 16 0 87 235 39 246 68 156 112 218 135 240 49 235 29 171 113 255 41 197 77 237 159 181 64 19 122 215 56 164 218 187 2 68 137 251 240 202 132 181 223 81 212 100 47 233 101 78 16 141 85 48 151 108 6 121 86 47 13 210 187 225 178 157 228 22 177 139 131 77 189 136 67 214 106 21 35 156 24 206 241 20 160 172 42 105 163 82 42 95 198 28 128 214 182 183 18 226 9 84 238 73 67 7 6 79 149 143 81 6 165 26 204 217 230 127 245 25 64 156 2 31 40 230 31 152 83 16 27 19 48 88 183 13 234 44 214 230 142 115 130 245 184 253 244 91 188 169 175 129 42 172 27 94 36 204 250 103 164 187 225 237 171 117 127 191 201 200 10 17 53 9 251 134 12 155 134 192 93 150 96 13 18 25 200 160 243 9 207 137 253 198 235 76 86 159 204 94 141 69 7 244 119 142 65 54 80 199 204 199 217 168 184 53 128 33 0 165 165 165 165 1 0 0 59 0 16 181 174 127 194 181 175 1 132 0 0 28 169 0 0 43 74 0 0 0 0 0 11 142 68 0 0 2 170 0 0 1 124 0 0 0 0 15 0 83 113 117 101 97 107 65 112 112 46 114 0 1 36 38 84 69 88 84 67 87 73 69 1 0 3 192 0 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 105 0 0 0 0 15 0 66 193 212 165 47 158 101 198 187 5 232 62 137 252 56 69 246 56 206 7 115 110 186 70 46 70 112 68 98 27 12 96 93 177 126 138 205 129 15 225 200 70 141 184 144 238 51 187 21 2 100 253 33 237 17 99 201 74 232 168 36 57 93 93 223 103 146 181 14 19 20 203 255 77 196 6 172 46 213 244 253 180 118 156 135 21 216 169 140 101 119 170 86 133 3 176 82 146 129 56 164 43 198 114 16 66 193 212 157 170 210 35 52 27 93 136 197 106 52 54 31 166 122 205 231 32 32 112 160 40 138 126 3 77 99 4 251 242 199 125 87 169 103 99 226 123 60 70 128 113 18 28 85 6 189 121 109 31 26 249 161 83 169 157 62 74 239 8 51 45 186 94 58 49 252 46 209 169 153 202 106 248 205 178 15 4 139 59 160 209 168 125 168 73 48 103 120 110 199 109 171 159 179 239 33 94 118 136 247 133 234 179 177 46 218 151 77 116 44 159 93 94 44 99 70 93 125 137 53 84 131 32 59 239 13 28 34 65 92 91 104 119 79 119 174 134 219 228 67 30 37 182 200 207 220 0 237 187 20 146 233 200 152 182 39 167 14 242 53 180 240 195 154 154 94 91 182 52 134 249 136 119 67 194 147 228 97 60 211 48 22 65 190 202 99 103 114 208 10 131 161 3 87 31 64 250 4 254 133 169 217 77 183 225 106 142 240 240 180 146 248 39 192 170 88 102 69 95 13 89 148 174 206 78 162 131 133 161 167 150 32 158 248 178 173 101 227 217 102 143 206 171 62 75 41 237 239 9 58 126 14 226 107 122 250 208 40 209 10 252 105 101 26 155 10 18 126 136 104 210 186 8 64 134 82 245 212 110 151 241 61 69 16 181 128 165 251 123 137 63 121 161 161 183 56 176 164 4 136 161 23 48 88 225 129 48 129 37 151 67 233 215 152 90 89 82 27 227 240 224 102 238 138 80 14 201 181 17 19 136 193 127 207 108 171 212 101 238 237 175 10 248 251 8 248 107 203 87 203 119 235 140 103 161 208 168 170 55 199 88 185 214 52 170 233 214 179 94 170 196 230 181 174 40 0 165 165 165 165 1 0 0 68 0 0 181 174 119 219 181 183 37 82 0 0 40 248 0 0 43 246 0 0 0 0 0 20 128 249 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 67 97 114 98 111 110 65 112 112 46 114 115 114 99 0 1 224 122 114 115 114 99 82 83 69 68 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 56 0 0 0 54 0 0 0 0 15 0 66 193 212 120 70 64 63 99 16 59 255 97 202 132 145 70 204 255 242 147 131 117 178 216 188 111 47 148 73 157 252 231 185 213 153 225 248 22 106 46 220 74 229 99 130 75 44 98 229 175 219 67 79 64 165 165 165 165 1 0 0 62 0 0 181 174 119 219 182 174 202 51 0 0 43 74 0 0 57 141 0 0 0 0 0 14 248 37 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 65 112 112 46 114 115 114 99 0 1 174 60 114 115 114 99 82 83 69 68 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 40 111 0 0 13 39 0 0 0 0 15 0 66 193 213 19 32 207 221 161 198 69 165 49 49 163 44 68 182 220 208 98 3 104 90 104 50 121 149 179 221 229 227 218 24 177 155 55 76 59 170 223 31 186 42 107 230 227 232 78 210 112 78 144 78 101 153 20 100 21 113 34 86 121 4 82 215 232 227 236 158 8 177 190 230 223 83 84 237 148 7 170 219 251 49 107 209 121 95 19 142 221 245 229 208 93 102 171 66 93 51 91 15 192 115 41 146 47 38 44 128 149 206 19 73 214 243 63 134 185 162 63 190 209 118 46 232 38 160 233 103 92 179 67 170 147 238 96 5 178 108 31 198 142 27 71 0 252 18 157 84 217 115 240 55 138 8 134 100 181 201 91 154 43 221 56 198 203 54 203 223 246 78 211 75 62 202 147 101 108 145 98 255 87 81 19 116 84 105 20 53 35 186 106 250 114 137 91 30 167 101 76 166 46 241 174 167 210 92 15 66 47 106 89 111 95 216 169 157 97 204 203 175 67 131 100 228 115 101 202 102 201 85 197 128 102 224 152 248 208 22 182 13 65 185 43 236 146 8 103 164 68 199 167 90 161 44 115 100 75 148 212 133 205 185 240 91 254 62 54 53 239 150 84 98 211 70 114 120 183 103 103 115 93 178 126 224 111 251 255 187 2 190 193 166 28 139 27 108 150 55 252 38 95 40 204 61 107 86 49 0 195 169 32 120 204 107 253 57 197 232 114 108 33 166 115 221 202 25 154 147 237 211 246 212 49 74 55 186 91 190 105 219 116 226 226 36 175 193 108 174 164 118 229 107 74 31 1 243 123 184 154 227 118 219 112 165 164 185 116 70 7 186 27 160 3 238 43 56 239 52 158 217 130 219 45 109 54 78 222 17 74 25 52 114 1 227 42 217 72 253 223 216 56 77 220 203 181 240 246 160 86 241 58 137 154 1 231 100 197 96 17 176 142 199 47 194 252 250 110 162 91 79 145 135 5 163 208 132 42 60 79 75 147 68 55 152 119 214 213 47 14 150 27 193 38 43 165 127 127 75 132 242 209 231 232 89 126 66 156 28 75 227 86 88 207 237 205 174 175 87 163 66 170 84 73 46 254 137 242 54 115 196 174 218 202 97 38 219 195 93 60 181 174 167 59 231 121 249 72 52 73 75 49 207 153 183 36 92 152 67 144 242 41 95 120 53 6 194 187 37 81 183 108 61 251 97 133 131 117 112 185 189 62 47 242 76 213 173 190 134 5 232 230 42 251 141 208 92 172 43 245 73 101 64 52 209 174 19 130 208 81 142 251 177 162 137 173 180 116 194 47 225 254 183 79 149 232 26 99 207 157 241 164 100 3 186 7 25 232 127 100 208 251 155 101 111 175 18 151 221 250 195 184 196 181 223 15 54 248 124 35 187 40 151 41 162 220 124 117 110 240 242 156 16 128 130 181 96 83 246 199 168 56 206 43 80 29 245 175 249 35 121 248 210 115 72 76 23 244 205 19 44 64 136 208 49 43 150 23 231 121 254 6 231 177 35 162 187 223 239 42 173 134 19 0 89 208 123 54 205 224 15 205 97 164 189 131 196 241 126 185 8 93 180 37 22 54 115 85 228 67 22 121 189 141 18 110 1 205 209 142 54 99 120 183 30 64 50 129 77 78 2 108 20 222 78 4 196 116 123 27 208 185 42 199 162 209 56 42 240 245 155 178 100 14 196 7 90 223 49 48 79 61 11 90 253 199 86 80 19 205 111 23 176 155 168 173 95 195 147 132 14 44 241 9 253 193 84 44 17 35 235 138 211 59 120 166 225 221 214 151 115 215 190 143 100 85 97 131 201 229 20 29 6 177 48 253 73 42 243 168 86 179 189 136 135 245 28 120 11 125 43 166 135 159 177 12 91 121 192 204 111 227 246 110 126 20 113 118 230 21 222 213 193 151 95 119 19 64 195 190 11 255 236 12 53 217 217 164 245 66 15 169 197 234 18 160 163 213 203 198 254 2 168 126 135 240 211 150 94 17 120 8 230 236 30 214 12 54 138 83 68 206 177 106 247 90 231 78 229 141 54 66 178 53 181 39 13 67 163 90 118 85 238 106 13 34 247 121 208 97 216 135 178 131 164 60 128 39 207 5 45 30 199 202 211 97 254 73 193 243 155 54 76 45 121 160 182 126 140 113 2 65 248 17 85 31 25 236 44 38 214 132 73 75 83 62 179 21 33 158 252 11 206 36 230 207 236 81 224 140 196 197 246 50 241 165 35 75 106 207 58 3 172 187 78 242 229 110 193 138 71 36 103 230 54 218 187 141 183 95 200 100 78 202 203 196 63 162 46 134 184 71 157 59 151 181 120 241 241 166 173 125 218 222 67 3 56 86 180 135 209 65 46 217 36 118 162 15 131 233 0 150 122 247 228 219 147 251 75 116 57 114 145 32 221 14 127 211 8 89 128 49 218 182 44 125 14 162 144 101 36 100 103 27 61 93 100 118 151 153 231 153 236 104 245 153 21 173 185 70 90 220 219 66 109 96 242 235 80 212 196 109 167 151 243 83 221 180 155 122 218 166 191 107 15 36 201 123 1 212 157 98 164 105 93 73 241 244 43 2 239 247 167 159 236 223 105 79 67 147 194 117 75 219 109 243 197 157 128 58 253 11 160 194 232 136 9 127 62 58 185 146 230 71 38 161 142 235 225 251 51 18 206 250 66 163 161 34 160 147 109 207 14 170 252 222 162 124 132 139 20 28 97 180 112 0 144 62 117 118 177 199 231 5 68 201 122 252 235 77 175 203 131 88 117 176 140 114 97 74 4 217 241 184 41 254 39 165 101 134 215 124 16 64 168 145 213 83 212 125 51 229 219 212 246 166 251 105 150 176 97 253 37 98 188 174 169 112 138 151 120 93 98 2 174 18 73 208 121 65 129 7 121 50 168 56 106 226 162 117 246 232 112 26 105 133 169 49 57 78 44 144 238 238 111 70 45 16 245 193 185 20 238 75 242 230 177 89 253 10 160 126 246 119 90 247 154 243 79 125 170 174 45 41 57 237 169 182 17 176 49 32 199 54 145 169 163 119 196 156 170 59 214 179 150 90 80 122 51 110 227 203 250 15 200 0 199 253 135 1 26 210 220 211 224 29 63 201 148 180 149 137 50 192 140 89 93 177 178 201 214 181 181 205 237 185 39 229 87 187 146 107 1 126 57 29 24 15 210 184 50 46 103 7 254 73 65 83 142 2 42 47 26 120 3 2 181 53 121 3 59 73 63 52 118 204 213 14 161 85 127 74 111 85 189 190 136 234 197 105 224 147 43 252 91 63 191 106 169 2 187 219 161 122 210 145 110 155 53 165 245 56 107 201 8 21 24 135 140 117 79 142 157 158 243 229 177 53 129 115 200 64 113 172 165 163 114 39 190 159 181 139 43 151 228 202 167 106 31 232 34 241 141 224 19 110 80 242 75 1 168 216 114 161 72 142 6 210 129 8 253 30 134 0 132 170 150 196 243 94 142 178 77 131 154 74 222 86 171 21 162 224 14 12 92 175 166 8 103 120 231 96 121 159 254 243 8 58 97 47 104 236 245 123 97 69 65 194 201 142 238 214 51 59 133 59 61 216 63 237 71 228 47 18 80 71 180 196 255 202 109 101 6 132 2 230 189 39 1 232 7 243 166 170 151 181 151 24 2 162 123 101 149 5 193 126 159 0 107 235 124 0 81 197 203 251 245 20 197 40 68 26 101 95 142 221 53 148 101 28 69 243 32 1 140 190 24 42 180 77 21 229 116 163 137 38 88 175 194 187 33 232 13 94 61 2 201 2 117 150 35 221 25 251 67 172 42 99 161 98 18 127 255 7 190 23 54 89 71 17 239 126 130 160 92 150 91 176 55 26 96 17 144 211 130 143 205 52 11 39 209 73 102 80 153 211 52 13 113 200 32 246 78 123 245 86 140 157 235 132 215 86 102 46 65 124 127 181 190 237 140 86 34 254 155 226 210 2 243 100 155 74 24 207 95 27 36 135 58 47 42 162 157 222 182 131 228 123 216 96 17 255 148 219 176 53 35 187 216 247 188 0 33 123 213 195 111 164 59 82 31 235 13 165 226 90 82 187 84 149 58 232 84 191 19 65 144 139 42 224 243 159 71 17 95 34 236 46 181 186 19 253 201 220 70 25 183 172 26 251 197 44 205 214 154 55 124 21 185 97 245 216 198 87 6 47 218 209 245 112 46 22 245 12 186 119 158 4 243 85 70 158 250 160 224 122 226 142 185 13 102 82 121 117 93 204 176 110 220 150 206 132 3 157 23 70 8 30 92 39 57 240 92 4 111 228 32 138 158 79 152 204 43 123 75 106 220 126 3 115 197 39 209 250 64 235 65 137 148 74 249 89 39 46 175 81 110 238 228 202 180 65 110 182 49 93 33 150 40 124 133 254 49 191 138 24 5 198 183 93 109 143 40 122 228 245 91 205 152 194 6 147 95 191 104 142 112 178 65 95 153 202 197 164 192 89 199 230 224 120 132 124 188 110 248 47 204 178 204 194 9 247 101 4 5 66 94 228 240 146 166 89 88 104 244 48 112 21 13 170 58 132 254 42 32 253 196 30 160 184 95 32 52 185 66 33 77 25 6 239 225 205 66 151 155 36 157 150 37 145 49 232 172 97 169 19 169 164 180 245 222 209 172 188 53 36 55 136 231 28 35 168 16 17 188 192 249 213 30 192 142 119 8 205 175 189 22 154 38 111 163 181 73 209 31 198 93 97 156 188 48 37 198 24 148 193 126 201 7 36 198 125 11 33 149 91 144 17 228 69 76 157 220 3 156 14 0 81 140 208 78 68 18 32 12 99 193 90 202 197 253 207 50 192 160 206 68 106 31 137 133 68 90 25 230 88 128 244 164 119 94 31 103 19 24 85 110 216 115 58 31 247 91 224 206 251 182 24 41 102 12 75 92 171 164 61 83 4 23 189 228 149 47 222 167 114 166 232 172 235 220 6 90 84 125 43 176 237 139 3 75 250 147 201 21 165 86 185 167 253 83 250 223 76 202 72 129 224 204 105 109 167 141 116 159 178 238 125 174 216 32 103 184 62 30 193 129 200 168 216 77 14 240 25 167 11 135 147 132 253 147 163 230 81 55 101 169 251 167 64 58 0 117 232 124 230 12 231 7 107 170 216 77 154 99 146 141 43 30 208 151 213 160 45 92 104 19 173 47 39 92 50 82 136 211 29 15 239 22 211 186 249 135 31 115 152 126 108 88 190 151 161 55 18 53 125 81 253 44 223 173 192 0 161 218 62 174 8 1 76 122 7 151 154 165 214 33 223 88 7 33 123 159 235 236 159 138 129 144 207 133 34 248 111 102 4 110 51 122 82 23 96 101 68 110 146 19 27 14 13 255 211 145 37 67 180 117 157 162 67 39 122 105 251 112 157 224 127 86 244 92 183 189 72 102 128 9 146 92 28 247 181 210 206 18 96 101 51 198 77 13 123 209 234 106 160 180 174 129 86 19 67 175 25 205 73 234 156 132 12 64 247 135 37 244 29 156 196 123 179 70 126 12 91 137 147 8 212 47 248 167 50 221 101 22 19 186 106 251 100 198 184 253 75 32 232 95 40 75 87 195 21 154 186 68 81 227 234 19 174 173 74 87 146 87 146 167 20 153 127 162 128 26 103 98 127 92 99 61 85 8 194 46 124 93 203 129 50 192 212 66 151 189 180 42 109 122 69 55 81 253 94 8 197 6 43 181 98 26 63 81 4 101 222 255 203 17 13 225 6 247 132 146 242 152 129 95 80 196 251 153 254 93 120 121 9 150 121 197 137 129 252 84 73 36 226 38 31 154 195 62 253 142 128 31 253 105 222 94 26 100 125 88 17 158 18 182 128 179 153 187 113 241 103 236 34 61 210 93 49 62 127 157 3 38 57 17 41 73 11 248 215 197 118 246 204 208 26 11 171 159 111 37 200 49 185 95 185 161 68 75 99 226 61 111 65 42 233 41 158 183 66 138 96 236 114 220 43 148 133 251 182 237 171 168 11 49 5 79 249 112 23 91 102 60 125 106 99 204 44 37 251 17 7 192 7 93 107 42 118 214 101 21 32 193 164 159 26 229 131 76 91 63 40 22 105 215 185 255 34 161 218 14 254 35 221 48 242 64 3 226 102 118 118 64 201 157 91 57 84 246 232 80 55 16 205 103 205 159 182 179 87 5 157 15 136 192 114 165 233 140 132 146 11 153 234 193 51 184 136 16 88 83 252 76 217 58 235 134 122 194 166 165 168 215 65 197 191 135 254 138 183 78 231 196 240 233 207 54 25 190 162 140 8 150 132 57 202 29 63 111 102 103 74 174 155 24 217 142 72 240 189 94 13 159 61 172 54 43 3 223 179 152 173 134 111 198 192 109 213 223 220 102 193 109 211 24 122 68 213 25 79 13 200 136 155 233 162 128 238 61 57 20 112 113 7 142 173 139 113 103 249 158 45 177 157 167 34 251 43 5 14 253 253 14 40 124 119 129 108 173 217 13 17 94 63 81 61 169 191 38 236 189 245 152 155 229 82 196 22 91 154 60 182 2 221 132 185 173 47 252 217 68 111 6 231 238 249 161 177 236 40 200 62 84 129 46 98 132 50 245 133 141 112 75 238 106 53 52 147 89 160 165 64 244 220 112 205 219 46 164 187 123 206 235 74 178 117 194 171 96 25 57 172 128 18 30 200 118 12 16 177 222 25 33 118 181 59 94 92 137 169 244 134 147 26 115 56 6 63 14 191 228 164 68 122 146 143 39 233 122 118 112 96 145 193 81 52 99 156 41 213 247 8 153 220 172 40 201 71 192 251 112 209 233 235 18 255 15 82 62 39 2 26 78 192 101 49 25 172 55 118 64 109 70 212 120 223 248 24 94 27 219 213 93 182 155 230 84 43 224 41 0 31 102 21 23 123 17 252 33 23 247 132 220 28 230 14 155 233 47 45 86 246 11 124 131 80 99 159 89 71 207 251 148 215 47 210 217 154 60 180 91 135 250 99 88 115 227 208 105 5 33 49 213 236 79 165 151 134 179 134 26 16 217 195 205 66 229 185 203 70 244 228 190 152 11 199 48 37 213 248 60 154 85 54 143 241 185 194 134 204 137 238 26 251 152 90 183 37 158 10 135 87 149 245 65 35 70 35 55 7 143 101 77 78 213 183 252 60 22 201 145 52 145 153 78 239 133 242 130 11 145 87 255 239 53 230 244 27 8 91 13 26 226 185 139 28 133 224 164 143 150 11 21 8 202 116 136 76 245 168 103 97 60 147 77 134 216 19 42 152 141 64 86 124 216 48 178 74 70 63 52 66 154 152 156 85 9 21 163 69 168 181 49 135 48 231 133 72 58 120 18 165 11 247 188 9 100 55 67 132 239 127 70 219 37 68 207 107 82 232 193 99 96 112 105 171 125 108 32 236 192 135 160 27 124 232 160 51 188 250 135 114 65 159 8 242 136 1 251 232 176 54 141 59 87 149 232 245 68 214 179 141 138 18 215 255 121 254 123 251 69 16 81 99 46 222 201 38 137 146 58 178 15 112 12 133 20 229 237 184 197 172 220 131 0 165 165 165 165 1 0 0 68 0 0 180 207 51 128 182 174 202 65 0 0 43 246 0 0 59 143 0 0 0 0 0 20 138 201 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 114 115 114 99 0 1 62 107 114 115 114 99 82 83 69 68 1 0 4 0 0 129 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 255 0 0 1 140 0 0 0 0 15 0 66 193 213 15 229 191 253 198 175 177 189 18 34 107 98 168 73 19 2 254 167 237 104 233 24 99 195 182 120 233 103 215 50 61 227 104 183 96 45 151 154 255 135 43 239 227 32 62 31 86 24 157 103 20 248 100 127 150 140 240 49 199 72 82 125 155 224 31 238 35 24 180 90 120 184 187 141 164 53 50 237 118 117 17 212 147 70 168 83 219 190 144 88 100 254 9 225 48 129 169 244 40 52 95 17 148 215 81 199 12 135 215 28 126 152 6 1 207 207 249 186 208 168 221 51 239 139 49 18 207 25 253 249 92 20 247 203 154 204 198 254 253 88 78 39 19 147 55 27 199 55 155 227 106 182 30 201 2 164 102 117 45 118 124 65 142 162 141 91 87 174 234 2 228 70 129 20 35 94 154 191 34 130 12 176 102 10 5 186 154 32 23 235 255 134 203 57 224 128 100 168 90 62 49 3 226 17 127 232 153 35 119 43 136 108 118 253 229 168 181 111 9 154 77 83 72 211 18 25 121 150 57 23 59 118 81 94 96 184 27 87 208 199 188 96 232 171 193 97 214 193 110 2 15 38 131 58 139 155 88 242 234 237 27 45 239 235 135 31 237 132 193 52 7 22 40 194 93 6 131 60 141 99 131 166 162 225 120 10 175 47 169 19 10 182 63 202 189 149 39 89 211 19 9 101 98 231 20 223 200 114 179 35 20 239 87 149 0 153 233 167 247 113 247 111 161 219 14 241 106 70 129 114 208 38 145 194 236 225 233 137 29 117 13 136 118 141 61 113 129 32 72 6 116 28 26 52 27 122 112 83 161 121 163 140 134 91 88 94 229 239 184 131 165 35 0 119 117 59 49 172 168 234 203 40 15 77 132 220 115 217 216 67 240 93 176 165 165 165 165 1 0 0 62 0 16 182 179 83 229 182 179 83 229 0 0 57 141 0 0 0 0 0 0 0 0 0 14 72 205 0 12 209 180 0 0 49 159 0 0 0 0 15 0 83 113 117 101 97 107 80 114 111 53 46 120 109 108 0 0 99 190 84 69 88 84 67 87 73 69 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 66 193 212 227 255 127 127 12 60 103 118 108 165 221 169 237 116 200 1 124 16 229 32 96 32 163 69 255 112 3 193 121 185 58 62 226 6 174 29 169 109 184 180 113 234 154 249 45 113 252 62 214 111 165 117 213 183 210 53 125 163 61 30 29 197 158 16 207 8 94 220 119 42 180 207 30 134 153 180 41 155 97 187 245 178 17 87 25 90 169 43 173 172 242 223 39 160 217 60 217 83 81 212 17 124 100 228 120 101 3 10 213 218 133 100 100 125 24 226 48 138 52 85 56 153 8 147 122 163 59 83 109 145 48 6 142 117 226 219 88 241 204 5 171 75 9 198 2 136 121 63 187 115 96 88 156 217 1 242 173 112 70 112 214 101 254 211 22 224 81 45 20 255 187 132 36 132 133 78 3 3 189 15 138 207 249 57 74 170 168 111 135 58 75 134 99 146 205 24 139 115 208 88 209 172 238 126 111 243 27 119 179 42 74 88 228 140 233 181 239 42 29 123 158 111 95 158 133 184 147 208 181 93 254 213 225 222 199 170 0 111 201 85 86 67 153 76 198 22 226 108 102 134 111 196 88 58 2 43 17 225 206 191 69 104 28 201 21 219 48 70 2 246 161 71 12 70 57 172 160 240 124 188 93 238 65 228 251 37 84 86 24 176 35 107 39 118 16 129 239 45 180 186 87 246 215 94 74 237 108 2 66 74 37 60 12 168 186 28 133 139 43 56 225 47 210 157 231 238 153 160 206 70 71 109 159 51 117 158 189 196 105 12 20 239 215 53 220 114 200 94 7 10 129 46 6 30 169 115 64 116 5 119 1 107 180 123 84 70 103 12 110 231 140 15 248 217 50 68 144 177 126 151 86 165 53 240 128 17 34 120 208 74 247 153 176 71 128 166 213 187 181 174 64 96 96 71 45 175 45 234 228 16 228 33 106 153 208 251 75 79 238 237 118 66 175 198 140 56 60 48 38 101 43 145 181 221 241 51 212 123 236 30 102 168 149 96 200 28 164 57 105 254 240 9 207 125 177 99 69 0 110 132 143 23 149 95 56 52 44 166 36 113 164 13 175 208 100 67 126 42 86 1 11 187 86 146 106 221 3 124 148 202 214 123 112 254 170 153 161 157 251 120 46 79 191 126 30 169 60 220 174 148 64 157 31 188 184 27 166 113 147 147 140 65 2 50 73 40 5 202 126 30 92 250 118 140 204 58 220 208 118 178 220 73 38 102 58 237 192 213 94 218 186 48 66 125 213 19 213 53 12 253 113 243 183 94 242 6 253 238 113 124 108 215 132 85 1 6 125 91 189 26 150 91 26 146 243 77 238 18 39 220 39 0 10 209 62 31 193 196 16 198 112 45 232 223 130 23 241 187 111 118 93 76 100 30 164 60 45 202 213 109 79 77 214 240 192 137 141 252 46 15 121 147 153 205 47 16 209 14 200 154 95 106 164 59 109 61 169 213 83 199 99 241 75 32 120 166 191 118 132 41 30 237 16 29 17 47 36 37 252 202 250 137 110 46 158 102 202 10 137 71 66 178 216 227 39 199 141 196 239 49 51 107 132 60 212 52 202 59 77 218 184 156 99 128 203 213 209 154 184 111 55 168 155 28 251 25 119 130 20 163 22 153 201 234 113 11 210 86 51 80 206 214 195 124 246 42 43 226 109 35 111 156 103 109 110 114 227 15 0 52 169 20 63 28 39 101 102 96 26 81 144 64 111 154 58 221 93 32 79 206 13 189 248 73 41 182 21 237 246 9 105 84 166 250 254 107 57 65 51 104 172 182 36 26 178 25 51 105 16 21 118 181 43 184 114 254 245 250 47 196 116 237 175 192 245 244 122 0 216 169 168 219 157 224 255 36 151 221 189 212 195 142 139 147 66 177 4 171 68 79 207 12 143 30 109 42 44 158 127 90 69 171 104 57 217 148 219 22 222 58 252 64 74 74 54 98 30 172 175 137 13 54 147 195 167 8 180 53 97 235 83 209 224 194 106 7 71 144 34 196 123 253 236 181 168 157 81 65 132 46 134 252 25 32 102 237 141 52 1 46 186 148 70 67 207 245 38 75 248 83 95 29 188 166 33 246 255 70 162 254 228 107 60 174 130 73 202 110 114 148 209 226 105 73 10 207 187 43 109 106 240 46 105 183 81 160 140 39 67 227 191 134 144 76 11 13 68 76 22 250 234 46 47 40 255 127 96 15 80 6 27 45 208 244 148 56 118 156 232 153 129 41 191 149 110 93 112 209 203 49 217 145 183 179 80 186 98 248 196 114 60 140 167 209 216 119 199 205 158 194 43 171 72 179 25 245 11 46 160 65 20 203 143 42 16 144 202 67 200 94 140 207 17 60 116 200 70 46 138 146 134 86 119 132 87 97 87 173 16 156 167 69 243 97 215 101 8 245 113 195 13 195 83 176 27 141 164 17 121 85 159 126 235 184 33 151 245 110 99 154 144 48 19 157 72 245 70 98 98 226 137 47 105 129 199 14 64 83 96 183 40 175 169 102 66 89 246 137 65 193 61 251 223 198 206 221 24 183 245 27 130 63 73 153 80 181 230 66 200 32 43 102 119 101 104 238 155 71 165 33 39 84 27 26 68 149 18 30 228 208 88 191 96 245 11 174 155 124 142 222 181 188 63 229 196 119 196 194 108 219 205 224 90 184 111 26 28 252 185 51 244 74 147 155 109 15 122 36 32 211 228 17 226 21 228 141 197 172 15 54 104 118 74 124 194 157 137 219 157 244 129 69 167 209 206 96 72 160 209 232 42 75 20 238 87 169 148 217 122 193 133 149 199 71 73 159 92 143 16 100 23 192 129 154 190 98 41 49 25 72 101 202 234 49 22 132 189 172 134 7 164 157 249 63 140 28 38 223 110 172 165 174 26 169 160 65 2 102 143 243 222 241 72 63 146 225 235 200 21 122 185 116 101 18 140 228 164 59 44 170 127 211 95 73 231 134 83 222 67 62 132 191 104 250 162 253 16 212 56 150 142 117 34 243 36 192 126 121 174 106 81 240 49 50 53 128 135 250 136 253 126 159 0 214 79 181 186 38 180 68 241 66 76 209 85 143 204 218 183 169 172 183 33 216 21 93 57 154 244 121 215 80 194 107 9 247 89 212 189 25 98 195 31 15 48 182 179 43 186 228 179 148 186 214 184 69 4 120 184 254 133 67 152 201 122 161 188 172 42 201 228 137 141 209 30 75 240 231 186 220 89 21 241 117 130 137 254 61 170 105 150 70 212 57 65 111 222 211 159 208 137 96 17 173 4 99 172 124 37 236 115 199 3 78 38 21 54 118 203 59 37 249 78 138 205 229 168 173 178 27 206 219 68 159 127 39 236 69 174 216 75 35 196 147 41 253 46 149 193 123 163 35 154 153 196 130 115 234 215 194 180 147 129 214 208 196 133 24 120 74 43 145 43 126 65 249 131 179 198 12 14 5 88 184 212 65 0 31 21 134 147 196 206 253 40 227 210 251 83 250 246 158 144 93 84 159 117 228 99 232 78 22 213 33 32 46 55 171 135 6 52 173 81 1 185 107 162 159 48 199 144 206 62 156 87 112 47 22 231 173 115 141 153 5 79 184 130 249 81 22 136 228 194 145 32 155 94 213 147 129 35 194 24 193 68 231 171 162 117 189 11 102 185 79 207 52 112 102 138 9 98 219 93 61 7 185 222 65 117 122 151 128 47 224 209 207 156 38 1 174 54 51 66 158 89 152 6 120 98 212 101 140 246 206 128 154 195 113 29 241 4 192 64 20 191 147 66 218 12 138 95 250 78 231 198 162 194 94 236 69 196 129 9 150 160 38 105 232 159 42 41 237 86 61 62 213 186 228 184 146 52 177 121 165 1 3 78 17 213 156 34 120 188 60 231 126 13 255 243 43 28 242 138 200 76 199 11 80 40 82 213 172 14 181 228 32 144 50 3 146 107 164 60 36 139 29 79 51 150 188 24 23 51 140 216 80 144 145 57 90 30 182 143 61 174 62 160 24 169 234 133 193 232 115 2 200 236 192 114 50 73 150 113 245 166 35 136 117 150 97 219 188 16 226 91 213 227 36 40 191 145 242 241 127 34 176 81 227 13 149 96 255 82 75 27 9 156 112 33 35 155 53 185 85 236 254 24 151 143 122 86 21 252 100 32 11 63 194 202 209 61 108 81 82 74 59 48 237 72 48 176 214 26 201 108 79 142 167 234 94 31 101 205 133 116 156 216 221 181 90 141 157 141 37 186 122 219 148 32 212 107 54 100 243 246 7 6 29 66 122 146 85 96 31 19 168 49 142 123 182 79 170 11 222 56 207 45 10 171 89 137 36 33 151 78 20 100 158 6 102 130 6 65 104 72 13 139 114 8 71 149 224 123 142 119 168 248 99 63 82 228 153 204 216 52 0 41 216 164 9 109 78 109 62 89 47 163 184 96 131 68 209 196 255 36 96 158 141 123 107 11 231 77 110 48 9 123 134 32 137 221 124 43 217 17 200 102 240 40 204 247 223 161 214 100 234 242 140 19 23 19 22 124 106 129 109 137 145 80 163 178 137 75 127 201 118 192 55 41 70 54 170 177 25 58 107 131 227 128 238 73 34 127 212 221 23 20 35 148 112 153 156 195 126 209 148 43 111 154 155 224 104 155 66 127 135 8 117 159 141 76 16 40 11 171 60 164 202 116 6 22 164 54 169 199 138 196 122 92 15 131 41 99 233 119 170 243 55 122 18 29 47 94 11 48 108 209 77 178 179 190 145 238 81 46 243 121 15 243 179 76 119 180 48 54 230 25 203 50 1 120 16 104 205 134 215 9 161 243 72 223 165 120 162 254 159 83 20 72 117 39 208 221 173 253 30 169 133 75 182 10 199 5 208 205 121 60 220 184 17 135 194 137 242 159 134 112 182 70 35 238 63 184 99 85 48 72 57 252 25 74 163 216 239 37 237 179 86 223 64 213 167 231 118 197 64 139 205 145 208 212 50 82 215 145 245 90 115 153 212 145 81 207 34 192 73 209 231 119 135 38 191 12 82 115 77 175 255 29 7 142 209 4 22 13 152 151 203 193 141 209 64 230 186 202 118 167 42 240 46 15 135 30 83 200 74 88 145 216 147 220 115 4 158 168 194 198 12 61 147 27 58 79 197 110 79 143 26 38 46 65 193 157 142 90 47 24 65 99 5 82 220 133 81 219 252 68 116 176 91 175 151 179 168 176 240 78 88 252 135 125 82 83 201 43 157 82 224 146 116 236 94 189 156 164 157 214 77 40 97 99 175 181 36 91 88 57 250 55 190 213 71 148 249 96 74 111 231 99 152 198 121 83 73 131 158 39 49 83 100 221 170 208 197 80 63 160 111 131 182 3 251 24 119 53 99 224 133 62 94 245 14 252 163 59 174 63 192 29 45 88 144 253 103 174 223 245 4 116 213 100 224 219 219 57 197 109 58 12 36 132 122 214 155 120 138 84 24 171 98 18 28 176 156 191 92 146 215 115 229 150 219 145 64 115 208 255 206 193 255 19 111 23 106 169 246 187 59 209 87 101 229 142 167 172 159 198 130 118 25 156 167 96 2 25 144 169 145 121 21 38 209 117 94 207 1 143 91 144 190 62 136 45 255 126 10 153 95 42 149 24 78 121 125 155 156 72 70 252 194 169 87 21 189 14 63 220 3 238 248 103 94 80 203 245 41 117 151 73 46 124 206 25 142 128 184 124 212 107 150 233 147 82 31 102 98 165 75 163 8 187 80 212 59 95 173 162 240 169 203 225 246 82 8 214 248 206 225 141 97 204 96 231 74 127 114 19 250 115 237 199 86 80 85 246 148 142 98 73 90 114 66 236 74 159 204 77 174 62 167 70 45 82 12 70 142 79 130 206 184 79 123 153 83 113 58 147 100 253 122 246 199 55 19 186 59 231 15 6 163 100 6 92 205 71 17 68 16 253 252 192 79 116 122 53 181 7 112 237 6 160 96 157 54 51 173 189 1 142 64 196 96 127 31 109 123 97 248 217 197 158 142 69 63 137 13 57 189 117 58 26 33 53 16 12 146 173 242 235 87 129 176 221 36 171 56 221 237 112 253 150 161 7 118 140 255 240 56 118 9 167 151 129 62 42 236 104 200 123 4 71 34 112 9 66 181 236 244 229 8 34 86 180 240 194 224 239 121 175 176 20 237 203 179 161 188 254 219 52 83 134 136 160 234 157 135 33 6 68 31 0 144 10 128 150 9 0 109 39 229 167 195 27 153 177 227 107 36 11 216 208 216 152 65 133 249 151 179 98 175 10 19 163 115 194 56 208 217 102 110 140 255 240 208 167 44 42 6 19 219 215 205 135 157 12 227 161 118 128 39 191 249 137 213 204 98 96 46 24 24 14 213 253 91 127 139 71 127 216 104 148 112 120 235 247 46 236 104 228 120 120 130 102 143 99 144 163 180 130 112 51 51 219 158 7 170 106 37 162 20 82 197 66 124 161 153 56 140 20 115 182 26 16 81 20 116 34 99 197 235 77 222 106 192 22 170 150 0 35 21 90 71 82 129 190 192 239 211 70 129 223 3 25 114 102 98 129 190 251 221 156 80 21 127 185 167 67 129 64 102 104 137 188 115 38 236 179 128 84 54 220 59 118 114 252 201 99 190 10 190 5 62 250 235 0 91 78 25 179 190 198 241 37 125 248 61 153 35 164 159 36 206 178 41 28 107 77 223 64 74 147 92 174 196 50 104 55 22 225 179 142 77 198 202 44 78 238 236 240 224 12 88 17 106 242 251 67 85 116 96 109 214 54 105 68 77 255 170 203 30 184 232 46 102 69 241 133 80 113 191 163 242 212 147 43 161 6 168 162 185 227 43 84 185 12 115 198 156 205 58 239 97 103 208 250 36 202 52 41 250 117 11 116 193 81 114 138 138 107 86 31 215 118 203 19 171 131 147 41 13 27 114 177 66 169 57 126 11 253 30 44 231 62 217 140 87 39 12 224 117 214 104 177 178 54 190 158 190 99 132 186 175 210 93 131 151 70 4 48 44 146 139 53 154 74 1 112 49 199 227 126 253 172 9 239 210 138 163 98 250 86 38 174 239 0 205 188 145 46 98 216 168 98 211 163 92 153 132 142 54 93 224 140 20 242 67 94 57 145 124 23 143 112 187 97 46 139 61 156 66 95 152 28 80 201 64 219 140 154 243 86 209 181 203 43 249 165 240 112 47 223 6 180 115 69 204 26 109 228 186 221 28 24 141 200 79 221 108 225 180 130 244 86 240 41 69 182 166 163 159 46 200 98 36 178 219 238 217 169 38 89 68 152 44 113 195 160 149 90 59 77 227 215 113 132 65 185 201 229 105 3 89 89 175 195 238 134 109 40 115 231 94 93 4 163 15 140 143 141 89 234 101 32 167 177 218 31 61 57 232 81 82 170 55 105 40 115 109 64 21 223 150 160 16 117 243 52 19 12 23 83 111 195 102 92 38 211 113 188 88 67 53 55 157 209 114 144 231 213 190 237 26 32 120 198 49 150 178 189 86 106 13 134 203 90 93 33 150 221 204 250 203 25 5 128 169 58 214 227 32 70 74 168 200 7 28 90 249 134 47 193 87 250 206 41 171 80 107 129 146 208 61 215 57 250 10 18 81 48 220 113 228 52 38 248 14 156 172 175 206 172 159 63 184 58 221 13 174 225 145 152 138 137 23 124 207 187 62 71 241 66 48 31 2 134 108 126 153 152 150 181 211 89 99 32 182 242 51 129 4 219 96 112 194 89 108 239 25 148 91 51 245 27 93 62 104 201 51 5 183 50 213 238 247 29 69 30 176 175 160 72 100 123 225 29 137 90 209 245 46 192 87 141 240 52 178 164 177 176 121 4 239 135 224 18 94 20 29 40 70 111 69 33 30 52 180 117 45 182 117 149 188 92 71 155 67 95 39 14 200 124 223 171 185 189 12 118 250 161 88 89 175 0 140 196 82 76 23 115 57 221 235 128 153 112 244 209 4 35 72 72 98 56 100 68 147 175 55 178 144 168 16 117 127 155 123 6 113 77 172 44 71 55 99 150 92 214 33 120 232 246 212 83 190 93 111 81 118 118 119 231 147 16 236 150 125 166 70 161 78 241 63 61 53 57 89 253 91 133 154 194 48 11 52 110 144 181 127 11 192 253 196 242 160 100 99 82 17 191 121 160 252 70 78 87 232 109 30 84 95 236 177 41 76 125 233 240 124 24 11 152 15 69 248 102 159 45 23 109 52 233 211 61 141 189 241 227 112 198 133 155 138 93 25 79 49 64 228 16 19 106 211 22 10 219 84 166 253 128 109 99 20 7 67 231 133 50 27 166 123 218 178 244 185 41 127 31 160 208 190 96 127 75 178 14 235 241 191 148 230 191 118 181 205 65 199 184 174 204 17 67 58 170 104 232 30 54 23 184 181 94 106 7 139 26 163 86 243 168 223 124 220 125 23 234 44 143 190 62 111 49 231 173 151 153 203 172 27 22 120 136 165 140 141 34 122 212 227 5 167 219 132 38 39 128 25 218 205 48 32 24 230 157 249 102 203 139 185 54 234 193 224 3 31 109 204 182 249 161 181 190 246 168 103 34 74 253 60 95 60 44 75 249 4 11 191 90 207 210 84 128 30 117 246 144 74 121 63 172 80 58 254 242 19 6 201 252 104 182 111 14 19 119 163 233 23 71 115 133 226 94 221 180 177 198 254 76 61 55 109 119 18 115 156 217 1 135 164 229 186 16 131 53 174 21 83 123 8 183 104 140 89 88 23 234 127 56 45 49 97 109 7 54 97 248 139 156 135 56 176 8 15 235 185 3 109 60 88 190 18 71 110 241 216 247 123 216 170 150 8 94 128 32 143 240 193 146 199 204 9 109 68 17 129 83 9 221 7 126 236 57 200 205 204 231 28 84 48 219 161 200 189 129 164 169 5 113 118 239 200 25 76 198 168 171 59 161 178 140 104 205 230 236 237 254 241 20 22 146 106 21 97 67 146 139 221 114 232 231 179 6 168 110 2 125 57 72 7 223 47 147 181 179 188 63 225 63 89 213 24 115 108 181 160 76 74 226 57 154 175 118 164 169 131 225 228 176 70 200 212 248 150 176 251 39 70 250 144 93 51 185 132 214 191 181 189 202 129 139 29 13 200 140 120 177 18 68 246 153 75 102 144 29 159 208 19 30 83 127 107 74 164 231 98 5 57 71 154 75 82 195 248 191 222 144 244 21 144 154 128 220 204 137 207 176 243 191 198 74 48 75 205 166 205 111 149 223 107 82 181 25 30 135 118 204 56 40 86 54 234 196 65 253 158 181 170 44 161 200 235 253 94 136 159 144 70 190 101 171 14 107 81 175 45 74 27 248 130 1 218 237 139 128 187 96 213 128 109 0 38 25 85 103 142 192 198 26 47 248 111 240 246 245 239 12 60 53 79 156 30 225 18 241 168 96 100 84 208 207 52 59 55 47 34 147 205 87 31 96 109 83 147 185 219 252 248 250 32 192 54 146 172 81 93 80 195 191 211 112 94 226 137 253 17 254 235 63 171 170 170 26 232 68 76 180 35 212 202 191 109 35 205 173 71 223 37 247 235 33 102 68 236 143 99 182 173 164 252 123 4 56 217 162 2 121 252 175 27 144 211 178 29 210 68 120 230 72 132 253 34 227 248 116 118 62 175 168 220 198 175 103 191 210 147 208 11 148 10 241 20 22 230 60 104 137 55 216 69 205 236 81 126 30 6 226 110 199 102 20 74 18 60 169 181 121 210 98 179 112 174 134 54 4 206 191 240 231 73 180 175 42 224 159 99 34 101 99 67 59 190 190 49 69 101 40 3 243 46 48 190 0 58 193 51 26 162 31 193 122 31 233 96 17 190 63 230 38 208 150 250 116 237 200 145 246 232 66 187 254 255 70 252 30 119 70 51 77 210 55 202 246 176 186 180 176 242 183 155 122 116 95 115 153 107 90 246 56 125 128 234 127 159 183 50 18 121 66 111 31 133 130 210 110 250 128 254 43 4 211 55 42 154 94 201 63 175 45 146 142 51 190 177 31 112 213 124 156 140 212 68 87 130 239 200 170 150 12 121 41 18 157 27 246 24 174 19 127 122 23 3 115 83 123 208 214 70 74 74 25 53 184 120 40 3 107 88 244 251 212 167 174 94 217 50 226 81 49 72 31 106 105 41 160 24 38 6 73 155 11 37 217 67 126 46 245 89 85 12 144 69 50 37 206 110 159 229 132 218 27 57 170 124 167 55 221 15 104 4 212 20 86 85 4 81 90 191 19 73 187 93 244 232 90 72 49 137 59 188 208 179 183 207 44 172 227 27 243 194 141 141 166 6 201 207 62 245 215 228 228 188 111 67 35 65 32 67 62 77 38 22 79 25 73 99 36 83 254 89 129 201 203 31 6 235 28 224 80 127 71 131 47 120 70 15 1 178 22 69 243 67 33 27 85 189 13 80 11 159 223 20 134 9 100 218 171 46 41 12 231 27 211 245 129 167 109 62 7 15 229 215 54 241 63 201 193 58 66 230 66 33 150 156 30 214 255 36 33 128 247 125 226 251 162 28 4 251 28 167 34 55 123 245 120 43 167 163 168 211 157 163 241 207 179 246 105 5 65 74 109 38 14 28 206 232 136 71 105 133 2 191 222 67 140 227 161 155 119 210 92 115 252 188 184 248 209 35 54 158 189 197 189 2 241 140 144 167 99 234 139 178 109 89 202 84 80 68 61 96 36 251 51 182 43 16 110 218 102 36 249 230 236 17 186 24 50 234 239 116 233 109 15 90 120 69 70 253 63 160 90 210 74 57 37 245 101 33 85 8 66 244 22 10 223 210 159 193 70 92 235 127 48 254 127 62 64 192 29 149 178 138 89 14 89 57 103 238 130 38 32 252 161 158 6 58 189 88 248 255 89 157 45 208 211 88 168 255 68 74 106 77 113 137 233 136 29 139 102 94 54 73 27 225 227 109 58 192 220 73 85 178 199 149 12 120 78 147 70 140 143 72 88 120 240 47 106 229 4 104 180 96 187 192 1 29 39 35 5 10 15 157 150 242 230 124 229 74 121 240 235 108 6 137 126 152 131 22 119 59 218 8 234 167 96 81 218 191 151 133 142 80 37 123 231 225 49 199 67 37 127 228 212 174 237 40 65 81 238 61 246 204 176 225 153 162 127 67 12 97 121 133 200 6 247 102 25 90 197 203 72 202 41 107 236 52 160 57 147 238 62 62 22 117 216 181 190 174 72 124 21 245 179 42 91 111 238 217 126 207 22 123 144 206 85 228 238 238 158 8 114 42 18 152 136 150 107 158 203 141 200 185 212 128 230 178 189 2 135 234 56 101 250 181 131 42 76 31 144 107 190 125 6 87 177 244 20 154 182 107 230 143 136 19 135 167 150 40 1 77 237 149 230 219 229 60 211 63 4 88 173 204 244 9 30 227 180 232 235 111 109 59 45 216 0 115 251 64 34 252 252 63 149 83 228 226 13 122 24 67 85 162 81 51 204 164 212 181 211 214 250 114 193 160 5 210 87 134 6 165 246 235 30 27 193 234 36 68 43 217 221 148 16 1 192 157 225 177 178 7 225 162 72 139 134 104 94 161 38 222 233 18 186 201 62 0 111 176 104 185 153 251 242 57 9 102 175 64 173 33 201 230 109 229 38 176 142 151 133 139 97 150 173 225 63 110 148 250 200 25 31 160 89 130 200 97 140 63 196 227 244 222 154 53 117 253 187 55 222 255 139 131 166 121 148 243 65 224 75 120 219 26 105 20 182 198 138 151 89 132 234 89 33 154 25 38 42 161 154 97 44 79 46 132 48 101 176 153 233 16 35 78 92 70 247 134 60 133 190 148 16 121 86 175 86 115 240 139 40 98 44 49 7 153 167 113 168 175 24 23 124 5 138 186 13 206 33 54 191 234 204 54 190 141 233 249 66 148 193 76 136 132 104 145 222 211 66 179 55 155 15 44 195 163 242 60 16 2 67 224 67 82 48 125 91 125 203 238 255 53 130 248 214 29 8 235 51 12 213 253 229 19 102 74 119 109 19 31 115 59 56 47 83 196 221 146 5 154 205 31 209 107 71 36 21 253 93 226 205 37 206 119 239 124 107 213 134 192 102 169 225 151 87 16 251 220 44 215 241 203 138 64 21 97 122 237 160 68 81 211 168 81 174 150 148 163 143 181 249 252 124 225 77 200 16 59 168 209 114 107 170 183 87 86 121 29 12 8 11 51 65 89 22 8 153 68 75 59 79 217 250 111 38 126 100 61 51 189 172 168 121 172 209 171 82 208 25 27 83 46 143 215 43 48 152 119 133 27 144 190 4 176 37 11 5 8 126 0 82 227 33 78 45 162 29 23 184 229 56 52 59 39 84 251 5 92 139 40 99 17 149 8 85 140 66 159 219 220 232 29 250 90 117 118 187 32 221 176 243 68 7 13 6 222 9 37 173 29 31 80 172 122 24 247 28 86 196 238 244 86 55 157 202 29 246 213 115 245 190 26 227 239 107 39 27 197 39 46 67 112 213 121 104 252 6 37 76 65 109 244 64 106 200 119 22 13 15 233 252 64 209 43 103 26 124 156 58 161 184 12 209 87 250 253 121 81 208 72 79 108 122 254 218 64 69 206 127 10 115 125 141 162 114 90 65 223 59 9 168 185 33 49 245 78 233 124 15 29 142 236 194 228 35 253 108 84 19 129 114 193 104 110 84 71 242 157 231 242 140 212 85 189 149 208 37 29 175 201 139 220 150 149 7 102 167 173 184 98 106 202 229 228 104 51 40 245 156 129 21 94 140 37 242 122 160 34 147 31 152 198 145 241 69 145 113 138 227 199 182 199 35 4 31 186 52 222 170 15 204 151 88 80 228 33 42 196 39 50 79 148 145 15 35 145 84 22 194 60 31 34 4 40 251 155 64 32 65 175 164 155 24 186 232 164 95 96 106 170 64 79 42 102 17 86 166 27 44 185 248 52 174 3 225 89 7 154 157 238 170 170 79 134 189 12 115 24 199 117 70 132 79 5 183 70 146 178 99 145 164 202 231 108 164 206 138 144 64 182 210 148 51 172 29 170 134 138 114 27 28 53 244 173 13 105 6 230 8 236 56 178 103 103 203 131 243 249 11 189 26 94 125 138 226 223 94 218 72 42 147 186 82 146 159 90 18 238 115 80 239 239 113 214 253 2 124 151 129 0 170 145 60 180 78 113 213 124 63 24 94 215 210 45 3 27 231 120 200 120 67 218 235 111 119 250 28 24 205 84 8 191 23 178 43 137 72 178 96 237 23 30 108 82 163 48 57 55 137 58 120 168 48 114 91 54 63 95 189 16 128 123 72 114 95 72 243 111 26 29 214 220 133 165 38 214 82 117 129 62 119 161 102 128 184 183 214 1 40 93 96 60 128 221 90 53 16 200 137 189 248 27 26 251 16 121 1 135 18 200 94 167 162 226 30 87 207 53 189 157 133 141 156 43 247 123 1 252 201 5 70 46 191 66 222 54 27 241 183 124 140 198 86 198 232 216 5 127 7 164 199 217 112 168 206 159 81 147 149 181 97 128 204 32 146 190 80 58 78 158 150 17 244 30 64 136 56 255 197 138 234 169 18 202 200 190 220 38 165 17 124 202 230 186 98 65 54 33 15 44 59 187 90 205 113 128 22 70 161 224 191 252 202 46 246 183 48 247 177 154 62 107 53 114 168 88 206 19 74 187 137 102 73 247 47 178 195 93 33 89 71 52 120 9 92 178 213 225 116 107 96 135 0 42 223 42 38 68 213 126 34 249 152 156 161 182 101 65 149 111 101 171 151 136 153 184 210 163 150 225 229 163 142 218 105 114 230 76 241 173 14 145 227 238 96 83 127 255 59 82 25 46 70 223 223 6 90 48 6 120 157 217 20 70 92 127 29 8 146 182 237 184 125 200 191 187 196 7 238 189 116 142 194 176 87 152 25 211 11 238 79 0 20 191 225 80 144 72 12 188 184 46 15 75 25 106 155 245 177 178 233 27 202 174 1 246 114 66 188 42 191 64 194 90 38 82 115 36 136 50 227 87 223 251 176 184 140 171 15 152 253 227 121 109 226 105 26 28 40 230 33 115 226 71 160 39 59 122 105 203 106 250 54 130 118 112 35 233 84 77 206 239 75 164 176 93 25 144 33 85 241 151 251 77 27 160 162 239 3 18 49 31 151 75 134 240 66 151 96 189 29 43 164 210 164 175 20 251 137 218 193 33 204 108 39 41 69 36 215 74 251 45 235 106 13 139 46 223 5 40 223 112 59 13 194 40 158 12 71 216 42 70 206 70 120 227 15 201 216 199 243 214 123 215 140 117 90 207 139 32 151 213 233 53 96 224 152 244 11 135 36 24 93 110 22 189 244 170 218 140 212 135 9 251 210 149 177 56 140 157 252 94 54 210 219 252 178 202 178 182 89 221 122 31 207 134 188 177 186 225 219 119 41 38 8 227 151 28 91 27 50 47 193 221 218 74 23 151 34 97 9 82 179 180 173 179 196 226 172 246 162 77 151 173 140 25 15 110 105 248 13 66 192 226 184 227 251 208 58 66 176 136 47 148 131 227 31 247 85 143 124 254 213 175 91 223 157 114 13 49 223 187 241 7 42 193 110 110 64 200 40 81 21 189 172 69 117 43 42 237 25 102 158 206 89 2 200 80 12 168 191 38 102 163 177 180 74 140 67 98 191 250 244 183 71 105 216 140 160 11 138 9 74 24 196 180 187 125 133 15 255 133 222 32 179 143 113 151 243 55 16 218 185 156 15 38 33 206 68 192 222 149 45 179 255 97 68 189 70 79 120 159 33 247 208 214 248 36 212 202 7 161 251 95 78 211 135 79 187 130 0 239 114 162 142 242 106 209 42 169 249 9 209 183 186 180 82 157 7 79 203 254 243 32 255 23 31 96 121 214 173 133 42 209 213 196 109 224 180 178 165 53 28 177 122 205 8 52 213 135 149 3 43 214 160 170 67 97 188 13 230 249 78 151 140 183 240 204 103 129 61 127 97 66 193 92 161 185 149 124 189 65 71 101 117 187 255 111 181 204 243 91 8 77 247 110 57 203 1 202 10 68 41 60 227 255 104 227 175 91 190 107 188 34 233 188 55 225 80 55 77 229 176 200 235 91 185 27 115 229 122 8 131 28 224 85 184 55 32 178 105 208 246 190 165 205 138 0 108 92 45 78 101 229 247 109 183 160 37 254 180 236 54 228 32 19 40 41 219 146 117 15 58 11 2 113 153 0 97 154 173 92 130 75 152 100 185 49 88 180 224 88 117 90 5 72 162 49 31 77 215 122 57 194 207 229 192 29 138 61 123 226 97 184 84 177 243 157 42 66 252 53 36 33 201 106 177 235 123 197 54 224 31 44 74 250 78 36 218 122 45 80 221 215 208 78 184 43 238 202 14 202 195 213 183 118 59 52 115 116 109 9 14 254 227 168 35 105 23 12 82 163 37 212 98 82 72 18 85 234 55 80 150 3 112 79 94 176 41 76 208 235 239 104 244 148 180 190 206 185 14 198 164 245 170 119 43 105 128 242 91 223 35 180 47 16 224 40 121 111 214 79 244 178 38 196 99 189 238 23 46 197 209 43 156 233 137 103 140 159 88 193 113 123 37 162 153 254 2 73 101 113 64 68 37 109 176 125 117 80 230 233 167 191 250 125 96 137 25 1 201 222 167 7 206 1 130 119 239 108 154 216 88 41 3 111 173 156 15 51 2 128 192 161 96 131 95 230 222 248 110 82 127 154 225 19 193 105 208 67 205 75 178 119 106 198 219 183 174 75 55 2 235 211 92 178 142 228 100 161 17 182 164 190 193 179 30 143 255 241 80 117 142 214 196 38 70 242 196 65 220 47 237 165 202 138 152 91 116 93 79 209 129 180 104 219 29 36 184 226 44 73 99 63 144 215 154 157 40 8 136 236 132 209 150 254 3 7 119 228 13 161 171 105 187 101 250 162 75 185 195 189 5 142 254 6 215 145 165 25 28 140 184 10 45 132 27 101 134 217 202 176 170 152 107 122 84 133 143 116 84 152 101 17 229 161 229 230 150 12 40 181 209 8 86 93 3 128 151 224 152 116 73 92 163 126 158 163 107 234 85 142 251 181 118 94 164 51 168 215 204 10 114 180 149 225 198 75 34 187 178 8 128 58 34 19 56 185 97 213 1 197 193 206 254 168 165 242 245 53 183 238 126 90 208 245 61 9 131 219 160 212 3 1 42 125 52 5 194 248 44 91 238 122 172 172 132 131 145 31 182 23 158 47 219 243 141 171 44 223 211 220 103 196 114 136 63 126 234 115 26 184 149 92 92 87 222 215 28 214 224 205 79 161 178 228 252 61 167 1 144 125 190 37 164 249 233 64 122 191 51 30 220 194 31 27 66 228 241 137 166 142 220 102 93 131 205 57 212 90 3 122 70 164 125 147 237 126 54 30 111 23 248 183 49 234 41 39 171 182 5 207 30 123 57 212 241 0 102 123 58 90 143 150 206 96 83 97 143 189 221 122 244 116 123 192 19 202 64 61 144 152 134 94 32 52 120 97 83 173 216 238 50 220 102 38 128 207 248 12 255 10 230 181 12 234 250 170 181 239 62 143 146 53 177 237 75 36 22 121 187 209 247 49 179 101 61 18 169 122 255 124 144 184 206 44 19 124 73 239 14 130 103 209 81 86 243 225 6 174 31 116 165 42 79 198 91 67 0 198 134 55 181 118 85 145 249 12 227 178 228 173 243 148 102 205 39 179 201 27 197 224 52 13 136 28 59 143 157 86 93 188 237 172 112 72 239 73 209 31 132 6 111 161 52 22 116 2 167 85 254 251 236 38 186 248 161 188 222 213 218 178 99 176 52 232 205 249 36 56 220 36 2 126 86 147 166 236 68 236 88 167 42 219 152 195 133 40 83 155 246 173 245 78 20 220 38 177 85 234 178 110 238 47 233 0 2 100 205 39 187 143 126 143 131 213 181 150 8 114 81 91 30 192 56 158 242 168 19 50 185 197 196 117 0 37 142 18 22 232 182 55 238 62 249 30 156 222 77 246 179 146 121 71 175 77 253 205 111 101 171 133 24 151 180 84 198 73 107 151 238 102 182 12 82 235 99 171 7 128 121 190 182 109 134 100 230 193 94 111 3 203 105 15 87 159 218 192 99 80 235 127 250 191 50 40 189 190 108 35 25 51 20 229 65 53 245 50 59 211 26 33 110 213 171 147 51 247 226 245 161 226 125 243 244 229 206 201 85 92 54 44 62 249 7 53 178 172 72 232 133 229 165 228 147 4 44 128 142 202 7 105 63 199 176 129 217 86 198 159 102 78 209 140 98 120 91 79 112 219 163 139 65 215 83 55 16 168 30 116 68 24 22 193 213 91 163 230 18 140 230 26 71 196 35 220 8 187 209 38 82 245 59 221 176 130 210 178 8 28 83 119 218 82 146 85 133 58 244 26 57 90 78 46 218 80 54 244 93 92 215 49 92 116 209 216 104 146 206 81 195 30 55 172 251 104 0 0 132 134 221 47 81 163 131 174 20 106 87 179 129 70 49 211 95 19 143 82 6 251 169 25 110 42 144 213 144 238 206 140 178 22 135 172 45 11 218 82 38 177 12 16 53 14 253 113 226 74 220 126 19 66 248 164 75 24 82 201 20 148 154 187 9 241 181 163 101 76 136 225 55 104 42 110 142 80 151 6 232 237 242 252 76 14 190 70 160 156 247 253 127 241 23 48 90 101 216 244 75 138 49 2 65 119 39 220 234 187 52 124 29 255 85 216 205 252 53 230 100 35 90 162 116 27 145 61 158 16 91 241 209 24 169 187 188 169 188 30 123 111 39 122 1 206 241 200 171 175 156 248 184 135 102 29 32 221 135 25 157 218 203 72 154 242 140 202 130 0 145 228 151 148 1 205 192 241 240 157 97 54 26 72 197 252 194 73 52 165 48 109 22 3 212 65 63 249 6 23 49 201 190 109 80 66 19 55 252 227 160 48 57 228 153 100 153 64 146 110 130 74 190 112 103 64 180 33 212 95 217 112 69 21 24 208 230 178 76 5 136 219 181 50 126 172 150 65 228 107 120 177 27 137 38 227 152 110 58 152 31 221 177 136 141 29 255 159 67 127 143 43 169 92 103 52 163 26 32 148 87 127 240 241 44 123 160 250 192 93 8 145 87 92 23 164 101 15 138 232 223 241 10 42 28 103 23 204 251 156 79 44 101 240 177 59 41 146 40 213 62 165 40 6 37 73 225 90 174 121 93 234 44 168 40 239 176 29 103 208 141 89 127 130 58 254 72 147 9 160 13 101 70 1 88 173 106 5 46 168 151 76 234 18 51 184 121 1 118 247 185 185 245 120 227 115 38 134 194 117 247 80 124 233 159 228 169 37 221 202 136 171 55 167 63 22 84 165 245 231 74 237 40 243 181 11 178 97 29 125 249 95 252 150 224 136 234 92 48 199 209 245 49 199 13 78 43 132 99 106 187 143 131 161 136 151 236 40 176 136 219 58 114 7 57 52 131 18 76 140 91 176 203 76 16 146 137 55 184 5 220 235 128 211 194 174 57 106 22 150 82 37 184 195 19 161 94 109 96 217 239 127 209 204 23 217 118 210 58 170 82 252 68 51 110 12 243 14 211 140 77 55 151 78 111 248 207 59 42 174 175 234 48 3 38 102 49 21 51 45 248 67 118 211 205 144 91 52 206 129 63 194 55 195 167 109 122 6 41 222 247 134 47 215 36 40 212 235 64 167 95 27 113 27 27 162 60 1 227 253 16 45 154 15 191 155 81 131 218 245 46 215 128 38 180 9 218 79 158 175 180 169 67 179 120 69 18 70 206 98 120 160 213 5 131 198 155 73 94 5 128 92 140 137 243 23 32 178 29 208 103 23 13 175 217 225 94 197 53 36 101 33 179 8 101 144 152 173 71 42 99 25 227 53 106 174 215 136 56 4 21 4 152 236 249 255 61 250 6 37 58 116 246 230 116 67 100 206 231 189 254 222 57 193 129 4 5 56 176 88 76 184 105 193 104 255 73 46 183 34 16 36 91 206 2 138 87 236 162 173 134 23 199 124 60 176 84 91 96 88 247 228 85 2 149 184 77 194 164 219 166 240 203 174 105 0 188 183 41 37 131 160 210 39 247 201 54 90 55 221 174 133 74 219 192 208 206 22 185 55 240 10 43 64 40 129 198 47 123 244 10 249 14 101 87 23 119 106 248 156 197 116 161 83 6 195 52 85 232 159 191 116 183 150 42 81 44 60 240 31 217 108 232 26 244 65 242 204 202 176 169 115 165 78 52 174 106 31 110 73 133 216 51 209 66 83 81 189 202 197 210 77 219 174 117 243 176 239 90 78 159 219 210 64 190 121 31 172 218 113 92 195 51 4 80 39 51 143 38 61 37 19 184 194 255 60 224 176 68 97 220 139 153 110 12 109 95 192 240 179 49 147 32 152 217 104 136 10 24 119 160 189 25 93 254 45 90 56 232 207 121 213 72 128 187 195 128 224 239 185 98 83 251 164 32 84 218 102 146 92 58 92 83 203 66 1 143 130 5 89 187 178 149 92 208 184 228 27 103 186 100 71 59 16 146 72 28 251 28 230 144 112 46 249 95 86 134 192 59 6 144 228 58 194 237 221 234 168 254 156 111 224 44 242 81 219 57 220 234 174 110 48 95 130 149 179 161 62 55 141 224 91 85 109 81 67 38 138 195 37 185 172 230 133 8 217 90 196 197 59 173 67 27 198 26 250 73 178 128 18 183 101 57 36 224 4 170 67 141 155 136 57 27 59 160 20 212 75 7 65 194 143 139 180 40 212 19 64 246 1 93 66 233 128 56 181 171 163 177 106 177 32 178 45 96 234 158 235 78 250 35 227 160 227 8 218 120 188 200 46 235 79 132 35 80 93 169 29 66 78 104 119 9 183 217 112 211 128 53 38 245 116 226 137 28 165 39 139 38 254 40 229 209 50 116 109 71 18 28 71 207 184 5 125 51 138 110 150 238 45 91 168 85 16 90 135 52 200 174 33 233 126 99 180 178 205 163 24 232 254 152 8 153 138 39 253 49 173 62 60 124 175 74 134 118 82 15 135 108 221 208 64 48 231 47 42 109 79 159 9 131 227 79 142 73 78 23 3 100 86 183 67 100 247 146 25 217 205 36 219 19 229 226 250 175 32 135 118 177 162 95 114 99 26 0 160 228 154 183 247 21 178 231 71 228 179 251 153 85 82 176 240 129 97 221 154 192 230 225 160 196 186 84 101 141 47 38 17 217 250 166 74 225 32 219 37 203 74 155 129 47 232 189 205 150 27 23 108 62 169 194 118 32 199 130 141 123 197 123 136 185 223 63 50 77 58 205 255 5 70 118 23 207 165 228 111 31 198 18 69 197 40 7 214 159 126 235 189 172 125 65 62 133 33 127 199 166 105 89 102 58 114 154 141 167 239 11 236 67 174 47 195 160 253 180 233 7 255 13 18 26 8 161 6 109 220 169 182 121 45 77 7 109 101 44 229 236 103 55 82 151 244 175 219 110 89 116 55 163 9 223 251 251 158 205 48 208 109 143 245 101 51 125 150 27 55 113 86 102 112 85 135 255 90 193 232 227 118 167 118 186 161 133 190 87 5 130 9 58 184 211 21 43 174 3 211 119 132 251 184 75 245 225 201 140 49 217 54 129 5 128 215 38 66 158 96 1 68 45 137 61 43 34 194 161 63 112 207 11 8 154 45 195 118 138 217 0 188 163 7 244 233 27 197 160 161 162 13 47 145 99 213 35 242 49 198 2 25 218 102 215 119 18 233 46 159 210 172 240 173 210 14 242 138 114 141 63 102 227 74 0 110 207 238 2 107 176 32 164 169 240 245 193 166 77 156 30 3 220 121 165 213 149 5 200 129 34 185 167 1 13 124 72 57 12 216 113 186 147 212 24 27 254 56 220 52 201 39 58 201 83 194 72 198 173 192 95 173 245 167 178 182 33 224 105 11 238 2 122 242 210 237 69 217 70 73 151 28 102 213 143 237 169 170 172 29 13 66 183 220 1 157 251 179 14 35 186 212 37 238 161 49 34 235 175 235 24 10 230 150 187 33 92 250 182 255 14 246 214 117 189 167 135 172 107 181 189 217 190 112 130 221 162 199 195 1 12 210 7 159 224 167 182 88 195 187 94 130 80 246 67 133 65 199 28 214 60 98 107 178 233 8 116 93 227 25 212 53 38 10 215 70 250 195 33 208 101 128 124 183 4 194 241 24 10 173 100 162 37 100 96 217 145 88 20 153 31 132 103 187 91 10 7 94 220 51 180 86 130 128 20 17 193 28 172 35 29 81 207 113 128 75 70 117 215 199 192 62 49 143 189 108 52 244 164 188 54 66 150 240 186 66 53 50 108 103 109 182 153 9 187 173 101 204 101 147 107 245 125 54 63 50 65 77 225 222 79 240 54 34 100 41 146 25 85 165 33 39 89 47 231 51 28 218 36 65 70 183 155 219 113 113 17 160 109 94 36 237 112 22 103 170 80 83 80 176 148 125 122 175 237 221 90 114 140 10 243 130 232 43 165 38 69 96 122 209 223 52 144 47 80 135 176 125 124 253 236 194 144 184 143 1 226 162 201 233 43 166 96 24 237 107 129 232 86 63 69 164 86 206 109 247 107 156 74 140 93 7 63 74 219 90 60 88 246 33 96 42 182 185 211 104 167 227 219 53 35 225 13 7 88 1 218 53 106 44 232 49 216 215 43 192 111 59 156 165 34 127 41 21 207 172 127 54 139 111 22 4 132 192 65 87 45 63 223 217 46 64 89 22 242 117 231 219 93 185 67 200 227 90 243 94 15 121 199 128 246 173 71 96 164 198 100 238 34 29 155 186 70 24 139 3 107 162 114 11 158 46 188 182 50 245 203 78 87 26 97 95 240 64 53 28 177 40 223 13 132 174 67 220 139 218 108 186 153 54 15 124 73 169 89 233 171 103 95 243 185 234 89 16 75 93 37 140 112 183 210 31 155 145 102 4 192 7 62 44 188 25 125 44 130 3 177 193 139 210 205 119 138 105 141 183 215 42 79 232 19 253 219 168 145 93 25 151 63 161 62 185 250 37 242 246 131 214 123 74 73 93 92 6 103 160 182 23 194 230 139 215 176 142 231 1 34 54 221 62 217 61 99 10 151 224 131 228 52 167 30 10 40 126 124 252 10 133 198 141 128 139 221 240 88 167 183 105 114 217 21 27 104 117 87 63 111 205 118 174 53 132 241 19 5 71 245 40 237 71 42 96 85 72 213 47 76 233 83 84 39 229 73 158 253 63 105 96 35 119 101 26 8 164 59 162 154 45 230 158 170 203 98 158 243 172 89 218 237 6 207 135 205 216 48 25 248 163 163 187 221 170 202 116 19 50 151 229 124 89 82 143 119 30 161 3 222 127 44 66 140 236 141 12 79 77 191 9 56 50 27 253 115 197 57 99 231 238 16 135 243 15 146 33 15 144 171 72 228 10 128 9 75 212 81 201 227 70 43 248 208 26 188 67 90 29 197 84 14 237 101 3 87 231 140 152 83 74 30 184 61 197 188 63 185 34 103 113 109 169 112 51 179 16 182 176 127 216 44 118 214 128 78 176 4 133 105 55 57 17 72 134 112 220 146 241 221 156 152 244 163 6 218 113 66 179 73 69 86 38 221 53 199 161 155 130 188 8 109 37 122 5 61 251 122 115 64 244 245 8 212 177 67 235 123 3 86 20 94 156 66 22 127 86 25 131 199 125 226 117 61 46 234 123 46 110 212 123 68 55 205 14 14 253 247 49 127 226 102 2 0 145 50 210 242 176 33 243 113 185 240 235 140 252 231 116 84 198 99 118 121 117 108 26 223 133 196 186 81 234 230 0 58 137 80 199 136 128 136 231 251 215 209 144 55 181 136 88 114 115 188 81 57 10 112 69 89 173 159 78 12 31 31 117 184 50 181 37 147 130 23 233 138 84 77 42 153 13 82 106 232 68 181 136 26 131 206 13 77 126 92 29 43 96 131 39 104 44 112 100 111 165 55 61 104 198 92 205 147 73 106 62 133 122 18 155 79 153 39 207 116 126 170 138 9 120 25 167 233 114 18 180 237 8 238 215 233 18 203 78 133 38 9 213 215 254 29 15 193 65 182 58 209 205 61 82 191 47 117 119 44 8 160 143 14 71 43 213 76 26 17 3 58 15 59 106 28 78 68 90 158 105 218 214 244 204 96 94 10 191 56 138 171 236 8 183 248 222 67 33 249 132 156 92 252 134 51 192 45 105 157 183 130 104 159 55 184 117 171 212 65 83 42 207 41 92 173 109 98 80 57 54 93 132 61 25 40 104 247 170 223 97 182 182 26 125 125 238 144 181 26 59 60 139 147 64 165 38 83 17 75 177 158 217 124 56 178 198 223 21 183 86 237 13 190 16 209 177 224 6 59 230 121 141 146 81 104 175 235 49 11 32 235 54 25 117 104 187 231 30 129 21 45 140 9 30 170 7 188 49 21 182 237 36 67 72 197 184 188 25 104 24 84 155 250 39 240 2 46 14 32 193 62 75 217 37 131 203 164 61 34 193 20 104 181 112 103 153 248 32 241 82 120 101 89 234 171 39 70 211 75 193 28 11 7 155 229 255 133 39 171 50 35 65 232 65 137 147 61 179 179 33 150 209 123 224 69 120 206 130 160 17 75 131 115 52 68 18 197 188 68 133 239 248 143 136 186 176 101 196 6 2 28 122 199 29 220 70 91 168 136 46 103 148 127 103 172 89 16 239 219 173 139 41 145 95 129 43 166 162 194 43 206 170 82 45 154 42 203 106 119 150 112 239 182 21 181 254 73 222 122 96 187 239 58 33 14 22 107 149 46 16 5 94 56 227 104 52 132 109 182 251 173 186 206 229 187 73 16 221 15 139 77 0 147 145 243 52 243 11 207 245 195 139 63 238 154 138 205 86 19 128 176 136 202 102 179 195 58 6 204 227 242 219 102 82 146 230 39 138 157 100 154 190 82 195 117 108 33 206 132 245 184 244 189 242 56 225 162 133 44 184 179 49 80 53 70 113 125 198 119 75 128 105 207 175 198 9 86 123 197 210 200 87 189 152 228 135 13 49 1 253 28 26 79 28 189 123 159 2 11 130 217 134 38 216 210 196 0 128 159 37 32 108 54 56 198 192 240 42 124 59 206 42 9 98 151 42 69 189 242 21 251 89 159 122 214 76 154 218 204 27 81 115 216 208 65 188 103 178 243 23 230 44 166 7 2 134 233 46 205 195 202 121 12 106 173 125 209 137 6 248 171 216 210 142 77 47 231 61 228 52 213 17 238 235 158 125 55 10 184 168 251 87 33 93 147 41 58 20 218 44 214 155 108 20 226 240 171 31 123 201 230 140 175 170 135 176 112 175 188 11 144 53 84 29 188 235 206 24 114 102 177 33 115 154 238 104 21 79 99 223 171 51 202 35 4 190 151 156 195 158 26 224 13 165 194 124 81 171 97 103 15 111 94 43 218 205 150 238 54 205 213 73 140 245 91 83 222 9 214 45 15 154 115 106 234 157 139 145 76 250 155 146 27 200 141 252 96 54 187 198 27 41 198 126 130 154 100 127 23 12 217 180 57 218 131 68 95 252 87 2 210 217 138 198 168 167 178 9 229 129 103 213 93 184 79 223 77 214 6 104 188 187 106 64 215 16 200 156 63 141 217 52 173 229 110 160 118 220 164 198 56 245 36 33 187 122 62 92 8 107 244 11 193 99 117 2 74 195 253 159 245 199 18 78 19 1 126 156 53 233 58 250 80 212 243 154 78 139 236 72 230 0 218 50 218 23 79 136 55 6 112 161 42 236 73 178 238 108 62 145 104 240 2 4 211 43 232 210 122 43 65 111 34 67 143 206 48 222 144 232 129 60 243 204 103 98 252 2 115 242 107 80 34 2 91 116 166 21 119 96 165 76 208 252 105 186 10 122 68 158 148 118 162 65 57 142 140 212 36 74 185 157 155 0 80 21 252 174 222 212 247 42 156 212 32 230 248 173 212 74 74 27 199 158 188 215 177 174 46 107 15 174 166 242 136 165 100 157 60 120 251 175 204 57 229 138 25 190 147 121 164 6 220 32 112 60 68 177 206 21 47 7 115 246 79 212 176 171 90 135 220 5 41 147 32 135 113 255 41 18 197 183 16 2 16 81 185 136 83 192 235 247 216 1 173 31 8 22 163 221 156 37 227 87 24 28 77 69 215 117 132 158 74 214 141 28 135 167 205 124 102 4 137 48 65 126 119 120 126 222 31 89 146 75 51 193 106 231 30 196 146 206 195 6 58 164 141 58 168 202 42 8 230 238 64 245 132 11 30 62 239 41 60 106 198 233 217 109 208 119 179 54 82 1 191 52 254 211 188 158 198 10 48 246 47 217 37 75 183 96 142 243 198 228 180 147 3 137 189 183 120 254 144 193 225 114 239 139 169 227 89 195 58 49 98 151 136 186 181 227 105 113 108 83 35 40 9 199 157 19 107 112 32 190 158 22 142 107 234 230 29 213 249 37 86 56 196 182 153 241 34 209 145 73 37 228 139 66 154 194 56 9 175 158 68 226 60 85 227 27 227 147 189 247 91 109 144 97 45 18 118 192 251 67 25 95 201 181 101 0 194 168 125 6 190 235 127 125 5 137 151 56 29 222 29 238 110 220 76 24 169 234 191 218 215 160 236 220 38 58 241 79 103 201 248 206 105 170 177 30 113 197 36 148 246 36 221 134 110 189 203 211 68 43 17 158 176 52 67 243 15 130 255 101 178 61 138 200 46 119 135 139 115 59 10 216 96 145 177 171 154 243 47 218 51 12 237 6 227 225 94 174 182 48 170 70 44 80 166 206 239 164 128 67 245 71 52 96 164 194 222 249 56 28 15 163 34 158 235 128 58 253 12 213 100 214 161 171 69 160 214 142 85 19 90 56 121 86 93 0 148 149 132 166 65 113 130 96 244 0 103 6 20 36 54 250 147 145 239 40 158 131 252 148 83 165 87 30 33 30 127 231 206 72 233 63 241 81 227 58 122 169 111 206 147 62 35 26 149 45 178 40 18 182 4 113 69 202 45 42 9 202 181 138 230 220 25 151 15 35 20 171 213 242 49 32 248 94 32 47 206 122 126 78 92 189 108 10 255 237 251 4 105 17 158 89 110 182 205 202 111 51 105 89 233 3 126 117 8 39 143 43 251 190 136 14 61 86 11 104 218 30 108 60 55 248 69 184 133 204 28 16 241 11 11 24 79 179 170 61 123 143 168 172 172 112 68 221 18 198 3 137 42 37 30 84 187 58 152 236 213 198 142 150 53 234 95 45 57 175 22 143 215 76 138 179 108 61 98 19 243 119 171 228 111 17 80 148 65 126 54 126 43 1 9 181 66 211 108 4 175 231 200 112 231 216 192 146 82 172 103 106 219 97 127 53 175 5 154 236 151 121 220 125 54 10 157 212 178 47 183 61 234 54 105 49 0 180 27 91 213 189 9 222 69 53 167 116 43 124 247 71 85 25 226 55 128 34 26 154 54 106 218 24 204 221 109 27 140 102 29 102 244 112 113 134 137 110 249 17 53 240 161 196 10 150 226 27 218 152 246 117 69 253 142 44 163 168 69 199 248 155 24 1 168 41 176 107 145 83 181 79 208 106 129 147 187 134 254 11 84 175 165 37 86 81 118 75 213 227 116 90 44 149 222 29 237 80 230 130 195 14 220 213 214 11 88 73 183 70 188 74 131 254 226 161 142 85 92 121 246 83 225 3 95 248 154 179 190 212 44 64 226 16 208 33 52 20 133 247 61 72 217 59 32 69 201 37 237 81 185 123 209 254 252 196 98 169 14 229 78 37 95 153 241 153 135 173 69 211 235 135 18 6 176 57 140 131 223 231 30 107 33 202 179 132 224 155 208 17 52 94 120 2 50 45 21 197 142 194 176 177 67 248 162 133 181 64 141 79 81 191 105 182 181 7 123 5 44 69 129 201 41 164 228 172 60 158 126 123 189 176 115 149 193 48 23 38 102 37 98 11 155 176 127 48 37 110 21 90 113 10 137 251 237 45 158 167 166 252 165 248 96 170 131 132 126 148 30 208 211 4 77 114 219 255 171 54 83 234 7 76 85 117 233 182 159 35 215 80 80 184 91 237 103 139 37 157 14 78 77 78 25 136 105 239 253 209 26 152 25 22 145 97 118 177 242 75 32 32 110 134 187 203 222 65 219 212 134 203 126 37 224 13 241 124 92 223 148 230 57 89 251 141 223 20 36 59 18 158 123 85 148 11 14 245 146 11 24 206 51 253 240 56 151 213 145 51 249 125 227 149 242 151 84 96 25 9 249 27 86 227 39 240 185 179 63 54 169 147 242 239 131 63 7 35 122 158 56 41 92 49 28 194 169 173 133 63 190 223 165 152 141 66 111 112 251 170 166 84 160 115 246 54 217 103 39 194 122 150 1 218 57 39 17 156 181 127 16 219 45 72 55 51 175 206 98 232 232 6 129 100 168 2 78 72 5 44 127 58 73 2 115 89 77 234 18 52 70 78 172 101 92 243 146 154 98 228 230 25 77 66 187 192 23 228 52 37 207 63 69 121 95 241 212 131 125 124 251 114 160 61 10 169 228 83 133 158 54 116 166 127 50 164 115 176 37 116 50 37 207 114 177 244 158 221 175 129 8 189 2 164 131 112 214 119 6 208 253 145 141 222 158 53 56 88 107 99 180 255 251 163 45 189 73 83 10 229 68 101 87 38 153 5 109 70 130 97 239 98 175 74 140 249 117 0 224 13 87 162 170 32 92 250 198 41 12 64 4 177 8 87 164 211 196 255 244 46 145 30 232 84 195 128 24 227 163 240 204 215 135 209 165 150 65 94 184 203 234 7 151 4 223 70 104 87 109 163 91 238 79 87 218 178 112 13 231 242 173 110 62 6 47 238 67 251 239 205 86 40 68 58 198 18 183 222 119 90 214 68 221 32 61 212 57 175 90 202 104 141 110 93 22 159 167 78 224 218 98 140 91 70 157 43 12 167 253 165 86 237 167 51 0 193 93 34 3 143 249 141 217 190 145 88 29 83 92 163 215 82 124 225 13 45 32 139 119 102 58 137 5 176 246 123 212 182 13 36 64 129 140 46 205 219 210 181 27 21 5 73 158 166 139 236 158 252 192 77 56 187 57 72 6 194 243 215 152 211 235 158 150 15 12 212 44 176 179 139 18 229 88 246 38 186 192 201 158 219 49 96 14 227 252 44 113 114 120 215 240 139 46 155 14 148 191 209 165 157 226 9 147 88 175 255 50 226 232 252 221 107 160 94 207 39 92 151 173 121 167 30 165 33 174 135 40 86 80 1 171 182 218 165 101 186 131 172 209 1 196 109 22 125 2 50 85 153 100 237 177 128 135 188 43 29 64 117 134 255 149 142 233 118 249 23 64 182 75 18 41 51 97 212 118 220 55 152 98 53 31 180 212 126 236 236 245 58 187 169 113 12 10 110 67 45 36 58 107 66 155 63 81 152 187 124 111 19 127 0)! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/12/2001 21:59'!macAsyncFilePrimsFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "AsynchFilePlugin.h"#include <devices.h>#if !!TARGET_API_MAC_CARBON#define DisposeIOCompletionUPP(userUPP) DisposeRoutineDescriptor(userUPP)#endif/* initialize/shutdown */int asyncFileInit() { return true; }int asyncFileShutdown() {} /* End of adjustments for pluginized VM *//*  Experimental support for asynchronous file reading and writing.  When a read or write operation is initiated, control is returned to Squeak  immediately. A semaphore is signaled when the operation completes, at which  time the client can find out how many bytes were actually read or written  and copy the results of the read operation from the file buffer into a Squeak  buffer. Only one operation may be in progress on a given file at a given time,  but operations on different files may be done in parallel.  The semaphore is signalled once for each transfer operation that is successfully  started, even if that operation later fails. Write operations always write  their entire buffer if they succeed, but read operations may transfer less than  their buffer size if they are started less than a buffer''s size from the end  of the file.    The state of a file is kept in the following structure, which is stored directly  in a Squeak ByteArray object:    typedef struct {	  int				sessionID;	  AsyncFileState	*state;    } AsyncFile;  The session ID is used to detect stale files--files that were open  when the image was saved. The state pointer of such files is meaningless.  Async file handles use the same session ID as ordinary file handles.  Note: These primitives are experimental!! They need not be implemented on  every platform, and they may be withdrawn or replaced in a future release.*/#include <Errors.h>#include <Files.h>#include <Strings.h>/* Async file handle (defined in header file):*/typedef struct {	ParamBlockRec pb;  /* must be first */	long	refNum;	int		writable;	int		semaIndex;	int		status;	int		bytesTransferred;	int		bufferSize;	char 	*bufferPtr;} AsyncFileState;/*** Status Values ***/#define IDLE			0#define LAST_OP_FAILED	1#define BUSY			2/*** Imported Variables ***/extern int successFlag;extern int thisSession;/*** Local Vaiables ***/IOCompletionUPP asyncFileCompletionProc = nil;/*** Exported Functions ***/int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** Local Functions ***/int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount);pascal void asyncFileCompletionRoutine(AsyncFileState *state);int asyncFileInitPB(AsyncFileState *state, int fPosition);int asyncFileValid(AsyncFile *f);int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount) {  /* Allocate a new buffer of the given size if necessary. If the current buffer	 is already allocated and of the desired size, do nothing. */	if ((state->bufferPtr !!= nil) && (state->bufferSize == byteCount)) {		return;  /* buffer is already allocated and of the desired size */	}	/* free old buffer, if any */	if (state->bufferPtr !!= nil) {		DisposePtr(state->bufferPtr);		state->bufferSize = 0;		state->bufferPtr = nil;	}	/* allocate new buffer */	state->bufferPtr = NewPtr(byteCount);	if (state->bufferPtr == nil) {		state->bufferSize = 0;		return success(false);  /* could not allocate a buffer of size count */	}	state->bufferSize = byteCount;}pascal void asyncFileCompletionRoutine(AsyncFileState *state) {  /* Called when an I/O request completes. Decides what to do based on the given state.	 Note that the first part of the state record is the I/O parameter block. */	OSErr err;	err = state->pb.ioParam.ioResult;	if ((err !!= noErr) && (err !!= eofErr)) {		/* Note: eofErr indicates that fewer than the count bytes were transfered when		   reading because the end-of-file was encountered first; it isn''t a real error. */		state->status = LAST_OP_FAILED;		state->bytesTransferred = 0;		signalSemaphoreWithIndex(state->semaIndex);		return;	}	state->bytesTransferred = state->pb.ioParam.ioActCount;	state->status = IDLE;	signalSemaphoreWithIndex(state->semaIndex);}int asyncFileInitPB(AsyncFileState *state, int fPosition) {	memset(&state->pb, 0, sizeof(ParamBlockRec));	state->pb.ioParam.ioCompletion = asyncFileCompletionProc;	state->pb.ioParam.ioRefNum = state->refNum;	state->pb.ioParam.ioBuffer = state->bufferPtr;	state->pb.ioParam.ioReqCount = state->bufferSize;	state->pb.ioParam.ioPosMode = fsFromStart;	state->pb.ioParam.ioPosOffset = (fPosition < 0) ? 0 : fPosition;	state->status = BUSY;	state->bytesTransferred = 0;}int asyncFileValid(AsyncFile *f) {	return (		(f !!= NULL) &&		(f->sessionID == thisSession) &&		(f->state !!= NULL) &&		(((AsyncFileState *) f->state)->refNum !!= 0));}/*** Exported Functions ***/int asyncFileClose(AsyncFile *f) {  /* Close the given asynchronous file. */	AsyncFileState *state;	short int volRefNum;	OSErr err;	if (!!asyncFileValid(f)) return;  /* already closed */	state = f->state;	err = GetVRefNum(state->refNum, &volRefNum);	success(err == noErr);	err = FSClose(state->refNum);	success(err == noErr);	if (successFlag) err = FlushVol(NULL, volRefNum);	success(err == noErr);    if (asyncFileCompletionProc !!= nil)        DisposeIOCompletionUPP(asyncFileCompletionProc);  	asyncFileCompletionProc = nil;	if (state->bufferPtr !!= nil) DisposePtr(state->bufferPtr);	DisposePtr((void *) f->state);	f->state = nil;	f->sessionID = 0;}int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex) {  /* Opens the given file using the supplied AsyncFile structure to record	 its state. Fails with no side effects if f is already open. Files are	 always opened in binary mode. */	int i;	Str255 cFileName;	short int fileRefNum;	AsyncFileState *state;	OSErr err;	/* don''t open an already open file */	if (asyncFileValid(f)) return success(false);	/* build complete routine descriptor, if necessary */	if (asyncFileCompletionProc == nil) {#if TARGET_API_MAC_CARBON		asyncFileCompletionProc = NewIOCompletionUPP((pascal void (*) (union ParamBlockRec *) )asyncFileCompletionRoutine);#else		asyncFileCompletionProc = NewIOCompletionProc((pascal void (*) (union ParamBlockRec *) )asyncFileCompletionRoutine);#endif	}	/* copy the file name into a null-terminated C string */	if (fileNameSize > 255) return success(false);		sqFilenameFromString(cFileName, fileNamePtr, fileNameSize);	CopyCStringToPascal((const char *)cFileName,cFileName);	f->sessionID = 0;	if (writeFlag) {		/* first try to open an existing file read/write: */		err = HOpenDF(0,0,cFileName, fsRdWrPerm, &fileRefNum); 		if (err !!= noErr) {			/* file does not exist; must create it. */			err = HCreate(0, 0, cFileName,''R*ch'',''TEXT''); 			if (err !!= noErr) return success(false);			err = HOpenDF(0,0,cFileName,fsRdWrPerm, &fileRefNum);			if (err !!= noErr) return success(false);		}	} else {		/* open the file read-only  */		err = HOpenDF(0,0,cFileName, fsRdPerm, &fileRefNum); 		if (err !!= noErr) return success(false);	}	f->state = (AsyncFileState *) NewPtr(sizeof(AsyncFileState));	/* allocate state record */	if (f->state == nil) {		FSClose(fileRefNum);		return success(false);	}	f->sessionID = thisSession;	state = (AsyncFileState *) f->state;	state->refNum = fileRefNum;	state->writable = writeFlag;	state->semaIndex = semaIndex;	state->status = IDLE;	state->bytesTransferred = 0;	state->bufferSize = 0;	state->bufferPtr = nil;}int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize) {  /* Copy up to bufferSize bytes from the buffer of the last read operation	 into the given Squeak buffer, and return the number of bytes copied.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed	Note that a read operation may read fewer bytes than requested if, for	example, there are fewer than the requested number of bytes between the	starting file position of the read operation and the end-of-file. */	AsyncFileState *state;	int bytesRead;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	/* copy the file buffer into the squeak buffer */	bytesRead = (bufferSize < state->bytesTransferred) ? bufferSize : state->bytesTransferred;	memcpy((char *) bufferPtr, state->bufferPtr, bytesRead);	return bytesRead;}int asyncFileReadStart(AsyncFile *f, int fPosition, int count) {  /* Start an asynchronous operation to read count bytes from the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileReadResult() to	 find out if the operation succeeded and to get the data that was read. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, count);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	asyncFileInitPB(state, fPosition);	err = PBReadAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}int asyncFileRecordSize() {	return sizeof(AsyncFile);}int asyncFileWriteResult(AsyncFile *f) {  /* Return the number of bytes copied by the last write operation.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed */	AsyncFileState *state;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	return state->bytesTransferred;}int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize) {  /* Start an asynchronous operation to write bufferSize bytes to the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileWriteResult() to	 find out if the operation succeeded and how many bytes were actually written. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	if (!!state->writable) return success(false);	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, bufferSize);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	/* copy the squeak buffer into the file buffer */	memcpy(state->bufferPtr, (char *) bufferPtr, bufferSize);	asyncFileInitPB(state, fPosition);	err = PBWriteAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/16/2001 21:47'!macBrowserPluginFile	^ '/********** Notes on Browser Plugin VM ************How it Works:The browser plugin VM allows Squeak to be run as a plug-in underversion 4.0 and later of either Netscape Navigator or Internet Explorer.To use it, you must translate a version of interp.c with the browser pluginhooks. Note for fullscreen support NPP_HandleEvent does not return control, it consumes events from waitnextevent. When fullscreen mode is turn off then control is returned to the browser.Relationship of this file to sqMacWindow.c:One can think of this file as specializing and extending sqMacWindow.cfor running within a browser. Certain methods in  sqMacWindow.c arereplaced by functions defined here. The originals are removed fromsqMacWindow.c by defining the PLUGIN flag in that file when compiling.Here is a list of the functions overridden:	ioExit()	ioScreenSize()	ioSetFullScreen()	sqAllocateMemory()In addition, ioProcessEvents() becomes a noop and main() is completelyomitted when sqMacWindow.c is compiled for use in the browser plugin VM. Thing busted 2000 July 26th squeak quit restart has issues with change file open June/July 2000 johnmci@smalltalkconsulting.com Reviewed code readded comments, added FullScreen Support				fixed issues with Carbon, general code cleaning.Sept 27th 2000 johnmci@smalltalkconsulting.com added logic to have more flexibility in memory size.				Fix issue with volume ID, don''t use 0				Fix issue were IE lies about the frame size as it figures out the frame size in real time durning rendering				Added check for file: in URL logic to disallow				Fixed problem in NPP_URLNotify, must call notify complete logic				Ensure NP_memFree is called for plugin arguments				Add logic for URLPostingFeb 8th 2001    johnmci@smalltalkconsulting.com Rewrote to use Apple multithreaded library and ported Squeak VM 3.0**********/#include "sq.h"#include "FilePlugin.h"#include "npapi.h"#include <Events.h>#include <Files.h>#include <Gestalt.h>#include <Notification.h>#include <Strings.h>#include <MacWindows.h>#include <Movies.h>#include <Folders.h>#include <string.h>#include <ctype.h>#include <Threads.h>#if TARGET_API_MAC_CARBON    #define EnableMenuItemCarbon(m1,v1)  EnableMenuItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableMenuItem(m1,v1);#else    #define EnableMenuItemCarbon(m1,v1)  EnableItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableItem(m1,v1);        inline Rect *GetPortBounds(CGrafPtr w,Rect *r) { *r = w->portRect; return &w->portRect;}          inline Rect *GetRegionBounds(RgnHandle region, Rect * bounds) { *bounds = (*region)->rgnBBox; return &(*region)->rgnBBox;}        inline RgnHandle GetPortClipRegion(CGrafPtr port,RgnHandle clipRgn) {MacCopyRgn (port->clipRgn,clipRgn); return clipRgn;}          inline BitMap *GetQDGlobalsScreenBits(BitMap *bm){*bm = qd.screenBits; return &qd.screenBits; }        inline BitMap * GetPortBitMapForCopyBits (CGrafPtr w) { return &((GrafPtr)w)->portBits;}        inline pascal long InvalWindowRect(WindowRef  window,  const Rect * bounds) {InvalRect (bounds);}#endif/********** Compilation Options:**	ENABLE_URL_FETCH*	  Define this to compile primitives to fetch URL''s via the browser.**	  Warning: Fetching file URL''s through the URL fetch mechanism allows*	  potentially untrusted code to read files outside of the Squeak*	  file system "sandbox", a serious breach of privacy. *	  There are few uses for use for the browser URL fetch*	  mechanism, since you can always fetch URL''s from remote servers*	  using Squeak''s own HTTPSocket.***********/#define ENABLE_URL_FETCH  #define IMAGE_NAME "SqueakPlugin.image"#define VMPATH_SIZE 300/*** Exported Primitives ***/#ifdef ENABLE_URL_FETCH#pragma export onint primitivePluginBrowserReady(void);int primitivePluginDestroyRequest(void);int primitivePluginRequestFileHandle(void);int primitivePluginRequestState(void);int primitivePluginRequestURL(void);int primitivePluginRequestURLStream(void);int primitivePluginPostURL(void);#pragma export off#endif/* Constants */#define MAX_STRING_LENGTH 255#define MAX_ARG_STRING_LENGTH 100#define STATUS_BAD_HANDLE -1#define STATUS_IDLE 0#define STATUS_IN_PROGRESS 1#define STATUS_FAILED 2#define STATUS_SUCCEEDED 3#define STARTINGsqueakHeapMBytes 20*1024*1024/*** Imported Variables ***/extern int interruptKeycode;extern unsigned char *memory;extern WindowPtr stWindow;extern int fullScreenFlag;extern int successFlag;extern char documentName[];  /* full path to document file */extern char imageName[];  /* full path to image file */extern char shortImageName[];  /* just the image file name */extern char vmPath[];  /* full path to interpreter''s directory */extern struct VirtualMachine *interpreterProxy;extern int thisSession;  /* from sqFilePrims.c: *//*** Local Variables ***/int			exitRequested	= false;Rect    	gSavePortPortRect;RgnHandle   gSavePortClipRgn;CGrafPtr	gOldPort		= nil;int			needsUpdate		= false;NPWindow* 	netscapeWindow	= nil;Str255		notificationMsg = "";NMRec		notifyRec;int			pluginArgCount	= 0;char		*pluginArgName[MAX_ARG_STRING_LENGTH];char		*pluginArgValue[MAX_ARG_STRING_LENGTH];Boolean     ignoreFirstEvent=false;int			squeakHeapMBytes = STARTINGsqueakHeapMBytes;  /* default heap size, override via the "memory" EMBED tag */char		squeakPluginImageName[] = IMAGE_NAME;NPP			thisInstance	= nil;WindowPtr gAFullscreenWindow = nil;char        rememberMemoryString[128]="";extern Boolean         gAllowAccessToFilePlease;#define URL_REQUEST_COUNT 100typedef struct {	int id;  /* used to associate a request with its outcome */	int status;	int semaIndex;	char fileName[MAX_STRING_LENGTH + 1];	char *buffer;} URLRequestRecord;URLRequestRecord urlRequests[URL_REQUEST_COUNT];int nextRequestID = 1;/*** Functions Imported from sqMacWindow ***/int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);void ioSetFullScreenRestore();int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID);extern int dropInit(void);/*** From VM ***/int checkImageVersionFromstartingAt(sqImageFile f, int imageOffset);int getLongFromFileswap(sqImageFile f, int swapFlag);extern int inputSemaphoreIndex;int recordMouseEvent(EventRecord *theEvent, int theButtonState);int MouseModifierState(EventRecord *theEvent);typedef int (*eventMessageHook)(EventRecord* event);extern eventMessageHook postMessageHook;int recordKeyboardEvent(EventRecord *theEvent, int keyType);extern Boolean  gThreadManager;OSErr   createNewThread();extern PixMapHandle	stPixMap;extern ThreadID  gSqueakThread;GDHandle getDominateDevice( WindowPtr theWindow,Rect *windRect);int ioInitSecurity(void);/*** Local Functions ***/int  CaseInsensitiveMatch(char *s1, char *s2);void EndDraw(void);void ExitCleanup(void);int  FindIdleURLRequest(void);int  InitFilePaths(void);void InitURLRequestTable(void);int  IsPrefixedBy(char *s, char *prefix);void OpenFileReadOnly(SQFile *f, char *fileName);void ReadSqueakImage(void);void StartDraw(void);int  StringToInteger(char *s);void URLRequestCompleted(int notifyData, const char* fileName);int  URLRequestCreate(char *url, char *target, int semaIndex);void URLRequestDestroy(int requestHandle);void URLRequestFailed(int notifyData, int reason);char * URLRequestFileName(int requestHandle);int  URLRequestStatus(int requestHandle);int parseMemorySize(int baseSize, char *src);int AbortIfFileURL(char *url);int URLPostCreate(char *url, char *buffer, char * window,int semaIndex);/*** Initialize/Shutdown ***//*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_Initialize: * Provides global initialization for a plug-in, and returns an error value.  * * This function is called once when a plug-in is loaded, before the first instance * is created. Allocate any memory or resources shared by all * instances of your plug-in at this time. After the last instance has been deleted, * NPP_Shutdown will be called, where you can release any memory or * resources allocated by NPP_Initialize.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_Initialize(void) {	exitRequested = false;	needsUpdate = false;	netscapeWindow = nil;	pluginArgCount = 0;	thisInstance = nil;	InitURLRequestTable();	return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_GetJavaClass: * New in Netscape Navigator 3.0.  * * NPP_GetJavaClass is called during initialization to ask your plugin * what its associated Java class is. If you don''t have one, just return * NULL.  +++++++++++++++++++++++++++++++++++++++++++++++++*/jrefNPP_GetJavaClass(void){	return (jref) NULL;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_Shutdown: * Provides global deinitialization for a plug-in.  *  * This function is called once after the last instance of your plug-in is destroyed. * Use this function to release any memory or resources shared across all * instances of your plug-in.  +++++++++++++++++++++++++++++++++++++++++++++++++*/void NPP_Shutdown(void) {	ExitCleanup();}/*** Instance Create/Destroy ***//*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_New: * Creates a new instance of a plug-in and returns an error value.  *  * NPP_New creates a new instance of your plug-in with MIME type specified * by pluginType. The parameter mode is NP_EMBED if the instance was created * by an EMBED tag, or NP_FULL if the instance was created by a separate file. * You can allocate any instance-specific private data in instance->pdata at this * time. The NPP pointer is valid until the instance is destroyed.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_New(NPMIMEType pluginType, NPP instance, uint16 mode,  int16 argc, char* argn[], char* argv[], NPSavedData* saved) {	int i;    long threadGestaltInfo;    OSErr   err;	/* only one Squeak instance can be active at a time */	if (thisInstance !!= nil) return NPERR_GENERIC_ERROR;	for (i = 0; i < MAX_ARG_STRING_LENGTH; i++) {		pluginArgName[i] = pluginArgValue[i] = "";	}	/* record plugin arguments */	pluginArgCount = argc;	for (i = 0; (i < argc) && (i < MAX_ARG_STRING_LENGTH); i++) {		pluginArgName[i] = (char *) NPN_MemAlloc(strlen(argn[i]) + 1);		strcpy(pluginArgName[i], argn[i]);		pluginArgValue[i] = (char *) NPN_MemAlloc(strlen(argv[i]) + 1);		strcpy(pluginArgValue[i], argv[i]);		if (CaseInsensitiveMatch(pluginArgName[i], "memory")) {			strcpy(rememberMemoryString,pluginArgValue[i]);		}	}	memory = nil;	ReadSqueakImage();	if (!!memory) return NPERR_GENERIC_ERROR;	thisInstance = instance;	gSavePortClipRgn = NewRgn();		if ((Gestalt( gestaltThreadMgrAttr, &threadGestaltInfo) == noErr) &&        threadGestaltInfo & (1<<gestaltThreadMgrPresent) &&        ((Ptr) NewThread !!= (Ptr)kUnresolvedCFragSymbolAddress)) {        gThreadManager = true;        err = createNewThread();        if (err !!= noErr)              gThreadManager = false;    }		return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_Destroy: * Deletes a specific instance of a plug-in and returns an error value.  * NPP_Destroy is called when a plug-in instance is deleted, typically because the * user has left the page containing the instance, closed the window, or quit the * application. You should delete any private instance-specific information stored * in instance->pdata. If the instance being deleted is the last instance created * by your plug-in, NPP_Shutdown will subsequently be called, where you can * delete any data allocated in NPP_Initialize to be shared by all your plug-in''s * instances. Note that you should not perform any graphics operations in * NPP_Destroy as the instance''s window is no longer guaranteed to be valid.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_Destroy(NPP instance, NPSavedData** save) {	long i;		ExitCleanup();	if (pluginArgCount !!= 0) {		for(i=0;i<pluginArgCount;i++) {			NPN_MemFree(pluginArgName[i]);			NPN_MemFree(pluginArgValue[i]);		}		pluginArgCount = 0;	}	return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_SetWindow: * Sets the window in which a plug-in draws, and returns an error value.  *  * NPP_SetWindow informs the plug-in instance specified by instance of the * the window denoted by window in which the instance draws. This NPWindow * pointer is valid for the life of the instance, or until NPP_SetWindow is called * again with a different value. Subsequent calls to NPP_SetWindow for a given * instance typically indicate that the window has been resized. If either window * or window->window are NULL, the plug-in must not perform any additional * graphics operations on the window and should free any resources associated * with the window.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_SetWindow(NPP instance, NPWindow* window) {	NP_Port* port;	if (window == NULL) return NPERR_NO_ERROR;	if (window->window == NULL) return NPERR_NO_ERROR;		netscapeWindow = window;	port = (NP_Port *) netscapeWindow->window;	stWindow = (WindowPtr) port->port;	needsUpdate	= true;	dropInit();	return NPERR_NO_ERROR;}/*** Streaming ***//*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_NewStream: * Notifies an instance of a new data stream and returns an error value.  *  * NPP_NewStream notifies the instance denoted by instance of the creation of * a new stream specifed by stream. The NPStream* pointer is valid until the * stream is destroyed. The MIME type of the stream is provided by the * parameter type.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_NewStream(  NPP instance, NPMIMEType type,  NPStream *stream, NPBool seekable, uint16 *stype) {  /* Call to load the initial URL and to handle explicit URL fetch requests. */	*stype = NP_ASFILEONLY;  /* ask Netscape to cache file and call NPP_StreamAsFile */	return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_DestroyStream: * Indicates the closure and deletion of a stream, and returns an error value.  *  * The NPP_DestroyStream function is called when the stream identified by * stream for the plug-in instance denoted by instance will be destroyed. You * should delete any private data allocated in stream->pdata at this time.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_DestroyStream(NPP instance, NPStream *stream, NPError reason) {	return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_StreamAsFile: * Provides a local file name for the data from a stream.  *  * NPP_StreamAsFile provides the instance with a full path to a local file, * identified by fname, for the stream specified by stream. NPP_StreamAsFile is * called as a result of the plug-in requesting mode NP_ASFILEONLY or * NP_ASFILE in a previous call to NPP_NewStream. If an error occurs while * retrieving the data or writing the file, fname may be NULL.  +++++++++++++++++++++++++++++++++++++++++++++++++*/void NPP_StreamAsFile(NPP instance, NPStream *stream, const char* fname) {	if (fname !!= null) 		URLRequestCompleted((int) stream->notifyData, fname);	 else 		URLRequestFailed((int) stream->notifyData, 1);}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_WriteReady: * Returns the maximum number of bytes that an instance is prepared to accept * from the stream.  *  * NPP_WriteReady determines the maximum number of bytes that the * instance will consume from the stream in a subsequent call NPP_Write. This * function allows Netscape to only send as much data to the instance as the * instance is capable of handling at a time, allowing more efficient use of * resources within both Netscape and the plug-in.  +++++++++++++++++++++++++++++++++++++++++++++++++*/int32 NPP_WriteReady(NPP instance, NPStream *stream) {  /* not used, because we use ASFILEONLY mode */	return 100000;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_Write: * Delivers data from a stream and returns the number of bytes written.  *  * NPP_Write is called after a call to NPP_NewStream in which the plug-in * requested a normal-mode stream, in which the data in the stream is delivered * progressively over a series of calls to NPP_WriteReady and NPP_Write. The * function delivers a buffer buf of len bytes of data from the stream identified * by stream to the instance. The parameter offset is the logical position of * buf from the beginning of the data in the stream.  *  * The function returns the number of bytes written (consumed by the instance). * A negative return value causes an error on the stream, which will * subsequently be destroyed via a call to NPP_DestroyStream.  *  * Note that a plug-in must consume at least as many bytes as it indicated in the * preceeding NPP_WriteReady call. All data consumed must be either processed * immediately or copied to memory allocated by the plug-in: the buf parameter * is not persistent.  +++++++++++++++++++++++++++++++++++++++++++++++++*/int32 NPP_Write(NPP instance, NPStream *stream, int32 offset, int32 len, void *buffer) {  /* not used, because we use ASFILEONLY mode */	return len;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_URLNotify: * Notifies the instance of the completion of a URL request.  *  * NPP_URLNotify is called when Netscape completes a NPN_GetURLNotify or * NPN_PostURLNotify request, to inform the plug-in that the request, * identified by url, has completed for the reason specified by reason. The most * common reason code is NPRES_DONE, indicating simply that the request * completed normally. Other possible reason codes are NPRES_USER_BREAK, * indicating that the request was halted due to a user action (for example, * clicking the "Stop" button), and NPRES_NETWORK_ERR, indicating that the * request could not be completed (for example, because the URL could not be * found). The complete list of reason codes is found in npapi.h.  *  * The parameter notifyData is the same plug-in-private value passed as an * argument to the corresponding NPN_GetURLNotify or NPN_PostURLNotify * call, and can be used by your plug-in to uniquely identify the request.  +++++++++++++++++++++++++++++++++++++++++++++++++*/void NPP_URLNotify(NPP instance, const char* url, NPReason reason, void* notifyData) {	if (reason !!= NPRES_DONE) 		URLRequestFailed((int) notifyData, reason);	else		URLRequestCompleted((int) notifyData, null);}/*** Printing ***/void NPP_Print(NPP instance, NPPrint* printInfo) {	/* printing is not supported */}/*** Event Handling ***//*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_HandleEvent: * Mac-only, but stub must be present for Windows * Delivers a platform-specific event to the instance.  *  * On the Macintosh, event is a pointer to a standard Macintosh EventRecord. * All standard event types are passed to the instance as appropriate. In general, * return TRUE if you handle the event and FALSE if you ignore the event.  * Note special logic for full screen support +++++++++++++++++++++++++++++++++++++++++++++++++*/int16 NPP_HandleEvent(NPP instance, void *rawEvent) {	EventRecord *eventPtr = (EventRecord*) rawEvent;	EventRecord	theEvent;	int				ok;    Boolean windowActive=true;    static EventRecord oldEvent;    GrafPtr         rememberFrontWindow=null;    Boolean     rememberWindowOnce=true;        if (rememberWindowOnce) { //Remember who the front window is        rememberWindowOnce = false;        rememberFrontWindow = FrontWindow();    }YieldToAnyThread(); //Give some time up, needed for Netscape 	do {		    if (rememberFrontWindow == FrontWindow())			windowActive = true;		else 			windowActive = false;    	if (exitRequested) {    		exitRequested = false;    		ExitCleanup();    		return false;    	}    	if ((thisInstance == nil) || (eventPtr == NULL)) {    		/* no instance or no event; do nothing */    		return false;    	}    	switch (eventPtr->what) {    		case mouseDown:				if (!!windowActive) 				    break;				    				if(inputSemaphoreIndex) {		    		StartDraw();					recordMouseEvent(eventPtr,MouseModifierState(eventPtr));					EndDraw();					break;				}				recordMouseDown(eventPtr);    		break;			case mouseUp:				if (!!windowActive) 				    break;				if(inputSemaphoreIndex) {		    		StartDraw();					recordMouseEvent(eventPtr,MouseModifierState(eventPtr));		    		EndDraw();					break;				}				recordModifierButtons(eventPtr);			break;    		case keyDown:    		case autoKey:  				if(inputSemaphoreIndex) {					recordKeyboardEvent(eventPtr,EventKeyDown);					break;				}				recordModifierButtons(eventPtr);  			    recordKeystroke(eventPtr);    		break;			case keyUp:				if(inputSemaphoreIndex) {					recordKeyboardEvent(eventPtr,EventKeyUp);				}			break;    		case updateEvt:    			needsUpdate = true;    		break;    					case activateEvt:				if (theEvent.modifiers & activeFlag) 					windowActive = true;				else 					windowActive = false;							break;    		case nullEvent:				    		        				if(inputSemaphoreIndex && windowActive && 				    !!((oldEvent.what == eventPtr->what) && 		 		    (oldEvent.message == eventPtr->message) &&		 		    ((oldEvent.where.v == eventPtr->where.v) && (eventPtr->where.h == eventPtr->where.h)) &&		 		    (oldEvent.modifiers == eventPtr->modifiers))) {		    		oldEvent = *eventPtr; 		    		StartDraw(); 					recordMouseEvent(eventPtr,MouseModifierState(eventPtr)); 					EndDraw();		 		}		 		else				 oldEvent = *eventPtr;    		break;    		    	}    	if (needsUpdate && (netscapeWindow !!= nil) && (memory)) {    		if (fullScreenFlag) {    		    BeginUpdate((WindowPtr) eventPtr->message);     		}            fullDisplayUpdate();  /* ask VM to call ioShowDisplay */    		if (fullScreenFlag) {    		    EndUpdate((WindowPtr) eventPtr->message);   			}    		needsUpdate = false;    	}    	if (ignoreFirstEvent  &&  fullScreenFlag) {    	    ignoreFirstEvent = false;    	    return true;    	}    	if (fullScreenFlag) {     	    ok = WaitNextEvent(everyEvent, &theEvent,0,null);            eventPtr = &theEvent;    		YieldToAnyThread();    	}	} while (fullScreenFlag);	return true;}/*** Drawing ***/void EndDraw(void) {	SetOrigin(gSavePortPortRect.left, gSavePortPortRect.top);	SetClip(gSavePortClipRgn);	SetPort((GrafPtr) gOldPort);}void StartDraw(void) {	NP_Port* port;	Rect clipRect;		port = (NP_Port *) netscapeWindow->window;	/* save old graphics port and switch to ours */	GetPort((GrafPtr *) &gOldPort);	SetPort((GrafPtr) port->port);	stWindow = (WindowPtr) port->port;	/* save old drawing environment */	GetPortBounds(port->port,&gSavePortPortRect);	GetClip(gSavePortClipRgn);	/* setup our drawing environment */	SetOrigin(port->portx, port->porty);	clipRect.top    = netscapeWindow->clipRect.top    + port->porty;	clipRect.left   = netscapeWindow->clipRect.left   + port->portx;	clipRect.bottom = netscapeWindow->clipRect.bottom + port->porty;	clipRect.right  = netscapeWindow->clipRect.right  + port->portx;	if (clipRect.top == 0 && clipRect.left ==0 && clipRect.bottom==0 && clipRect.right==0) {		// Not sure what to do IE is lying... this gets the full screen, not a table cell GetPortBounds(GetWindowPort(stWindow),&clipRect);	}	ClipRect(&clipRect);	BackColor(whiteColor);  /* needed to avoid funny colors */}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;    Boolean     restorePort=false;    	if (stWindow == nil) {		return;	}	restorePort = true;	StartDraw();   /*if (((NP_Port *) netscapeWindow->window)->port !!= (struct CGrafPort *) stWindow) {        StartDraw();        restorePort = true;    }*/    	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;    if (depth<=8) { /*Duane Maxwell <dmaxwell@exobox.com> fix cmpSize Sept 18,2000 */    	(*stPixMap)->cmpSize = depth;    	(*stPixMap)->cmpCount = 1;    } else if (depth==16) {    	(*stPixMap)->cmpSize = 5;    	(*stPixMap)->cmpCount = 3;    } else if (depth==32) {    	(*stPixMap)->cmpSize = 8;    	(*stPixMap)->cmpCount = 3;    }	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPortWindowPort(stWindow);	CopyBits((BitMap *) *stPixMap, GetPortBitMapForCopyBits(GetWindowPort(stWindow)), &srcRect, &dstRect, srcCopy, maskRect);#if TARGET_API_MAC_CARBON	QDFlushPortBuffer (GetWindowPort(stWindow), maskRect);#endif	DisposeRgn(maskRect);		if (restorePort) 	    EndDraw();}/*** Image File Reading ***/void ReadSqueakImage(void) {	sqImageFile f;	char msg[500];    int swapBytes;    int dataSize;    int headerStart;    int headerSize;    int heapSize;    	plugInInit(squeakPluginImageName);	InitFilePaths();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		strcpy(msg, "Could not open Squeak image file \"");		strcat(msg, imageName);		strcat(msg, "\"");		plugInNotifyUser(msg);		return;	}		ioInitSecurity();		//Cheat and peek ahead to get the image size so we can calculate the memory required 		swapBytes = checkImageVersionFromstartingAt(f, 0);	headerStart = (sqImageFilePosition(f)) - 4;	headerSize = getLongFromFileswap(f, swapBytes);	dataSize = getLongFromFileswap(f, swapBytes);		//Close then reopen to reset file position		sqImageFileClose(f);  	f = sqImageFileOpen(imageName, "rb");	squeakHeapMBytes = parseMemorySize(dataSize, rememberMemoryString);	if (squeakHeapMBytes == 0) 	    squeakHeapMBytes = STARTINGsqueakHeapMBytes;	    	readImageFromFileHeapSizeStartingAt(f, squeakHeapMBytes, 0);	sqImageFileClose(f);	interruptKeycode = 515;  /* ctrl-C, since Netscape blocks cmd-. */	fullScreenFlag=false; //Note image can be saved with true}/*** URL Requests ***/int URLRequestCreate(char *url, char *target, int semaIndex) {  /* Start a URL request and return its index. Return -1 if there were     no idle request handles. */	int handle, notifyData;	long junk;	handle = FindIdleURLRequest();	if (handle < 0) return handle;	urlRequests[handle].id = nextRequestID++;	urlRequests[handle].status = STATUS_IN_PROGRESS;	urlRequests[handle].semaIndex = semaIndex;	urlRequests[handle].buffer = null;	/* temporarily return the grafPort to Netscape so it can display feedback: */	EndDraw();	notifyData = (urlRequests[handle].id << 8) + handle;	NPN_GetURLNotify(thisInstance, url, target, (void *) notifyData);	Delay(120, (unsigned long *) &junk);  /* workaround for a bug in Mac Netscape 4.7--						  back-to-back requests to a server sometimes fail						  when the server was heavily loaded Question is this value too long!!*/	StartDraw();	return handle;}int URLPostCreate(char *url, char *buffer, char * window,int semaIndex) {  /* Start a URL request and return its index. Return -1 if there were     no idle request handles. */	int handle, notifyData;	long junk;	NPError error;		handle = FindIdleURLRequest();	if (handle < 0) return handle;	urlRequests[handle].id = nextRequestID++;	urlRequests[handle].status = STATUS_IN_PROGRESS;	urlRequests[handle].semaIndex = semaIndex;	urlRequests[handle].buffer = buffer;	/* temporarily return the grafPort to Netscape so it can display feedback: */	EndDraw();	notifyData = (urlRequests[handle].id << 8) + handle;	error = NPN_PostURLNotify(thisInstance, url, window, strlen(buffer)+1, buffer, false, (void *) notifyData);	if (error !!= NPERR_NO_ERROR) {		StartDraw();		return -1;	}		Delay(120, (unsigned long *) &junk);  /* workaround for a bug in Mac Netscape 4.7--						  back-to-back requests to a server sometimes fail						  when the server was heavily loaded Question is this value too long!!*/	StartDraw();	if (window[0] == 0x00) {		//Bug? unsure, but if window is null, then no notification give so trigger semaphore		URLRequestCompleted(notifyData,null);	}		return handle;}void URLRequestDestroy(int requestHandle) {  /* Clear the url request with the given handle. */	if ((requestHandle < 0) || (requestHandle >= URL_REQUEST_COUNT)) {		return;	}	urlRequests[requestHandle].id = 0;	urlRequests[requestHandle].status = STATUS_IDLE;	urlRequests[requestHandle].semaIndex = 0;	urlRequests[requestHandle].fileName[0] = 0;	urlRequests[requestHandle].buffer = null;}char * URLRequestFileName(int requestHandle) {  /* Return the filename associated with the url request with the given     handle. Return null if the request status is not STATUS_SUCCEEDED. */	if ((requestHandle < 0) ||		(requestHandle >= URL_REQUEST_COUNT) ||		(urlRequests[requestHandle].status !!= STATUS_SUCCEEDED)) {			return null;	}	return urlRequests[requestHandle].fileName;}int URLRequestStatus(int requestHandle) {  /* Return the status of the url request with the given handle. */	if ((requestHandle < 0) ||		(requestHandle >= URL_REQUEST_COUNT) ||		(urlRequests[requestHandle].status < STATUS_IN_PROGRESS)) {			return STATUS_BAD_HANDLE;	}	return urlRequests[requestHandle].status;}int FindIdleURLRequest(void) {  /* Return the index of an idle request or -1 if there are none. */	int i;	for (i = 0; i < URL_REQUEST_COUNT; i++) {		if (urlRequests[i].status == STATUS_IDLE) {			return i;		}	}	return -1;}void URLRequestCompleted(int notifyData, const char* fileName) {  /* Record that the given request has completed, caching the result in     the given file name. */	int handle = notifyData & 0xFF;	if ((handle < 0) || (handle >= URL_REQUEST_COUNT)) {		return;	}	if (urlRequests[handle].id == (notifyData >> 8)) {		if (fileName !!= null) 		    strncpy(urlRequests[handle].fileName, fileName, MAX_STRING_LENGTH);		if (urlRequests[handle].buffer !!= null) {			NPN_MemFree(urlRequests[handle].buffer);			urlRequests[handle].buffer = null;		}		urlRequests[handle].status = STATUS_SUCCEEDED;		signalSemaphoreWithIndex(urlRequests[handle].semaIndex);	}}void URLRequestFailed(int notifyData, int reason) {  /* Record that the given URL request failed. */	int handle = notifyData & 0xFF;	if ((handle < 0) || (handle >= URL_REQUEST_COUNT)) {		return;	}	if (urlRequests[handle].id == (notifyData >> 8)) {		if (urlRequests[handle].buffer !!= null) {			NPN_MemFree(urlRequests[handle].buffer);			urlRequests[handle].buffer = null;		}		/* Note: For local files, we''re informed that there was a network		   error (but only after NPP_StreamAsFile has reported success).		   We could allow local files to be read through the URL request		   mechanism but NOT failing here if the status has already been		   set to success. But we don''t want to allow the URL mechanism		   to be used as a loophole to read files outside the sandbox, so		   we let this fail. */		if (urlRequests[handle].status !!= STATUS_SUCCEEDED) {			urlRequests[handle].status = STATUS_FAILED;			signalSemaphoreWithIndex(urlRequests[handle].semaIndex);		}	}}void InitURLRequestTable(void) {  /* Initialize the table of URL requests. */	int i;	for (i = 0; i < URL_REQUEST_COUNT; i++) {		URLRequestDestroy(i);	}	nextRequestID = 1;}/*** Squeak I/O Support and Memory Allocation ***/int ioExit(void) {  /* Request that we stop running plugin. */	ioSetFullScreenRestore();	exitRequested = true;}int ioScreenSize(void) {	int w = 0, h = 0;	Rect bounds;		if (netscapeWindow !!= nil) {		w = netscapeWindow->clipRect.right - netscapeWindow->clipRect.left;		h = netscapeWindow->clipRect.bottom - netscapeWindow->clipRect.top;	}	    	if (w == 0 && h == 0) { 	    GetPortBounds(GetWindowPort(stWindow),&bounds);		w = bounds.right - bounds.left;		h = bounds.bottom - bounds.top;	}		return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}/* Full Screen logic */Ptr gRestorableStateForScreen = nil;NP_Port	  gFullScreenNPPort;NPWindow  *oldNetscapeWindow,gFullScreenNPWindow;WindowPtr oldStWindow;int ioSetFullScreen(int fullScreen) {	short desiredWidth,desiredHeight;	Rect  windRect;		if (fullScreen) {	    if (fullScreenFlag) return;		desiredWidth = 0;		desiredHeight = 0;		oldNetscapeWindow = netscapeWindow;		oldStWindow = stWindow;		BeginFullScreen	(&gRestorableStateForScreen,getDominateDevice(stWindow,&windRect),								 &desiredWidth,								 &desiredHeight,								 &gAFullscreenWindow,								 nil,								 fullScreenAllowEvents);		fullScreenFlag = true;		stWindow = gAFullscreenWindow;		gFullScreenNPPort.port = (CGrafPort *) gAFullscreenWindow;		gFullScreenNPPort.portx = 0;		gFullScreenNPPort.porty = 0;		gFullScreenNPWindow.window =  &gFullScreenNPPort;		gFullScreenNPWindow.x = 0;		gFullScreenNPWindow.y = 0;		gFullScreenNPWindow.width = desiredWidth;		gFullScreenNPWindow.height = desiredHeight;		gFullScreenNPWindow.clipRect.top = 0;		gFullScreenNPWindow.clipRect.left = 0;		gFullScreenNPWindow.clipRect.bottom = desiredHeight;		gFullScreenNPWindow.clipRect.right = desiredWidth;    	    	netscapeWindow = &gFullScreenNPWindow;    	ignoreFirstEvent = true; 	} else {	    if (!!fullScreenFlag) return;		fullScreenFlag = false;        ioSetFullScreenRestore();	}}void ioSetFullScreenRestore(){	if (gRestorableStateForScreen !!= nil) {		EndFullScreen(gRestorableStateForScreen,nil);	    if (gAFullscreenWindow == nil) 		    return;	    gRestorableStateForScreen = nil;	    netscapeWindow = oldNetscapeWindow;	    stWindow = oldStWindow;	}}void * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {  /* Allocate the Squeak object heap memory from the system heap. */#if TARGET_API_MAC_CARBON	return NewPtr(desiredHeapSize);#else	return NewPtrSys(desiredHeapSize);#endif}/*** File and Access Paths ***/int InitFilePaths(void) {	short vRefNum;	char imageInPreferenceFolder[256];	long dirID;	OSErr err;	FSSpec fileSpec;		/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	strcpy(shortImageName, squeakPluginImageName);	/* get the path to the sytem folder preference area*/	err = FindFolder(kOnSystemDisk, kPreferencesFolderType, kDontCreateFolder, &vRefNum, &dirID);	if (err !!= noErr) {		strcpy(imageName,"Problems finding the System Preference folder");		return err;	}		// Look for folder, if not found abort */	strcpy(imageInPreferenceFolder,":Squeak:Internet:");	strcat(imageInPreferenceFolder,shortImageName);	CopyCStringToPascal(imageInPreferenceFolder,(unsigned char *) imageInPreferenceFolder);	err = FSMakeFSSpec(vRefNum, dirID,(unsigned char *) imageInPreferenceFolder , &fileSpec);	if (err !!= noErr) {		strcpy(imageName,"Problems finding the Internet folder in the Squeak Preference folder or the SqueakPlugin.image");		return err;	}		/* set the vmPath */	PathToWorkingDir(vmPath,VMPATH_SIZE, fileSpec.vRefNum,fileSpec.parID);	strcpy(imageName, vmPath);	strcat(imageName, shortImageName);}int IsPrefixedBy(char *s, char *prefix) {  /* Return true if the given string begins with or equals the given prefix. */	int i;	for (i = 0; prefix[i] !!= 0; i++) {		if (s[i] !!= prefix[i]) 			return false;	}	return true;}/*** Optional URL Fetch Primitives ***/#ifdef ENABLE_URL_FETCHint primitivePluginBrowserReady(void) {	/* Args: none.	   Always return true on Macintosh. */	interpreterProxy->pop(1);	interpreterProxy->pushBool(1);}int primitivePluginDestroyRequest(void) {	/* Args: handle.	   Destroy the given request. */	int handle;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	URLRequestDestroy(handle);	interpreterProxy->pop(1);}int primitivePluginRequestFileHandle(void) {	/* Args: handle.	   Return a file handle for the completed request. Fail if	   the request handle is not valid or hasn''t successfully completed. */	int handle, fileObj;	char *fileName;	SQFile *filePtr;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	fileName = URLRequestFileName(handle);	if (fileName == null) {		interpreterProxy->success(false);		return null;	}	fileObj = interpreterProxy->instantiateClassindexableSize(		interpreterProxy->classByteArray(), sizeof(SQFile));	filePtr = (SQFile *) (fileObj + 4);	/* Note: OpenFileReadOnly() allows any file on the disk to be read via a file URL.	   However, we are using it for now because we are not sure where the Netscape cache	   folder will be--it''s folder might even be user-name dependent. sqFileOpen() will	   only allow opening files within the sandbox, which would be better. Here''s the	   sandbox-safe alternative:		  sqFileOpen(filePtr, (int) fileName, strlen(fileName), false);	*/	OpenFileReadOnly(filePtr, fileName);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(2);	interpreterProxy->push(fileObj);}int primitivePluginRequestState(void) {	/* Args: handle.	   Return true if the request succeeded, false if it failed, and nil if	   it is still in progress. Fail if the request handle is not valid. */	int handle;	int status;	int resultObj;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	status = URLRequestStatus(handle);	if (status == STATUS_BAD_HANDLE) {		interpreterProxy->success(false);		return null;	}	/* default return object: (nil means "in progress") */	resultObj = interpreterProxy->nilObject();	if (status == STATUS_FAILED) {		resultObj = interpreterProxy->falseObject();	}	if (status == STATUS_SUCCEEDED) {		resultObj = interpreterProxy->trueObject();	}	interpreterProxy->pop(2);	interpreterProxy->push(resultObj);}int primitivePluginRequestURL(void) {	/* Args: url, target, semaphoreIndex.	   Start a URL request to fetch the given URL to the given target.	   (See the Netscape Plugin programmer''s manual for possible targets.)	   Return a handle that can be used to identify this request. Fail if	   there are already too many outstanding requests. */	char *urlPtr;	char *targetPtr;	int semaIndex;	int urlObj, urlSize;	int targetObj, targetSize;	char url[MAX_STRING_LENGTH + 1];	char target[MAX_STRING_LENGTH + 1];	int i;	int handle;	semaIndex = interpreterProxy->stackIntegerValue(0);	targetObj = interpreterProxy->stackObjectValue(1);	urlObj = interpreterProxy->stackObjectValue(2);	interpreterProxy->success(interpreterProxy->isBytes(targetObj));	interpreterProxy->success(interpreterProxy->isBytes(urlObj));	if (interpreterProxy->failed()) {		return null;	}	urlSize = interpreterProxy->stSizeOf(urlObj);	urlPtr = interpreterProxy->firstIndexableField(urlObj);	targetSize = interpreterProxy->stSizeOf(targetObj);	targetPtr = interpreterProxy->firstIndexableField(targetObj);	/* copy url into a C string */	if (urlSize > MAX_STRING_LENGTH) urlSize = MAX_STRING_LENGTH;	for (i = 0; i < urlSize; i++) {		url[i] = urlPtr[i];	}	url[urlSize] = 0;	interpreterProxy->success(AbortIfFileURL(url));	if (interpreterProxy->failed()) {		return null;	}		/* copy target into a C string */	if (targetSize > MAX_STRING_LENGTH) targetSize = MAX_STRING_LENGTH;	for (i = 0; i < targetSize; i++) {		target[i] = targetPtr[i];	}	target[targetSize] = 0;	handle = URLRequestCreate(url, target, semaIndex);	interpreterProxy->success(handle >= 0);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(4);	interpreterProxy->pushInteger(handle);}int primitivePluginPostURL(void) {	/* Args: url, target, semaphoreIndex.	   Start a URL request to post the given URL to the given target.	   (See the Netscape Plugin programmer''s manual for possible targets.)	   Return a handle that can be used to identify this request. Fail if	   there are already too many outstanding requests. */	char *urlPtr;	char *targetPtr;	char *bufferPtr,*buffer;	int semaIndex;	int urlObj, urlSize;	int targetObj, targetSize;	int bufferObj, bufferSize;	char url[MAX_STRING_LENGTH + 1];	char target[MAX_STRING_LENGTH + 1];	int i;	int handle;	semaIndex = interpreterProxy->stackIntegerValue(0);	bufferObj = interpreterProxy->stackObjectValue(1);	targetObj = interpreterProxy->stackObjectValue(2);	urlObj = interpreterProxy->stackObjectValue(3);		interpreterProxy->success(interpreterProxy->isBytes(targetObj));	interpreterProxy->success(interpreterProxy->isBytes(urlObj));	interpreterProxy->success(interpreterProxy->isBytes(bufferObj));	if (interpreterProxy->failed()) {		return null;	}	urlSize = interpreterProxy->stSizeOf(urlObj);	urlPtr = interpreterProxy->firstIndexableField(urlObj);	targetSize = interpreterProxy->stSizeOf(targetObj);	targetPtr = interpreterProxy->firstIndexableField(targetObj);	bufferSize = interpreterProxy->stSizeOf(bufferObj);	bufferPtr = interpreterProxy->firstIndexableField(bufferObj);	/* copy url into a C string */	if (urlSize > MAX_STRING_LENGTH) urlSize = MAX_STRING_LENGTH;	for (i = 0; i < urlSize; i++) {		url[i] = urlPtr[i];	}	url[urlSize] = 0;	interpreterProxy->success(AbortIfFileURL(url));	if (interpreterProxy->failed()) {		return null;	}		/* copy target into a C string */	if (targetSize > MAX_STRING_LENGTH) targetSize = MAX_STRING_LENGTH;	for (i = 0; i < targetSize; i++) {		target[i] = targetPtr[i];	}	target[targetSize] = 0;	/* copy over the post buffer which might be large*/		buffer = (char *) NPN_MemAlloc(bufferSize+1);	for (i = 0; i < bufferSize; i++) {		buffer[i] = bufferPtr[i];	}	buffer[bufferSize] = 0;	handle = URLPostCreate(url, buffer,target,semaIndex) ;	interpreterProxy->success(handle >= 0);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(5);	interpreterProxy->pushInteger(handle);}int primitivePluginRequestURLStream(void) {	/* Args: url, semaphoreIndex.	   Start a URL request to fetch the given URL. Return a handle that	   can be used to identify this request. Fail if there are already	   too many outstanding requests. */	int urlObj, urlSize, semaIndex;	char *urlPtr;	char url[MAX_STRING_LENGTH + 1];	int handle, i;	semaIndex = interpreterProxy->stackIntegerValue(0);	urlObj = interpreterProxy->stackObjectValue(1);	interpreterProxy->success(interpreterProxy->isBytes(urlObj));	if (interpreterProxy->failed()) {		return null;	}	urlSize = interpreterProxy->stSizeOf(urlObj);	urlPtr = interpreterProxy->firstIndexableField(urlObj);	/* copy url into a C string */	if (urlSize > MAX_STRING_LENGTH) urlSize = MAX_STRING_LENGTH;	for (i = 0; i < urlSize; i++) {		url[i] = urlPtr[i];	}	url[urlSize] = 0;	interpreterProxy->success(AbortIfFileURL(url));	if (interpreterProxy->failed()) {		return null;	}	handle = URLRequestCreate(url, null, semaIndex);	interpreterProxy->success(handle >= 0);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(3);	interpreterProxy->pushInteger(handle);}void OpenFileReadOnly(SQFile *f, char *fileName) {	/* Opens the given file for reading using the supplied sqFile	   structure. This is a simplified version of sqFileOpen() that	   avoids the "sandbox" access check, since the browser''s	   cache folder is outside the Squeak sandbox. That is why	   we only allow reading of this file. Sets the primitive	   failure flag if not successful. */	f->file = fopen(fileName, "rb");	f->writable = false;	if (f->file == NULL) {		f->sessionID = 0;		f->fileSize = 0;		interpreterProxy->success(false);		return;	} else {		f->sessionID = thisSession;		/* compute and cache file size */		fseek(f->file, 0, SEEK_END);		f->fileSize = ftell(f->file);		fseek(f->file, 0, SEEK_SET);	}	f->lastOp = 0;}#endif/*** Other ***/int CaseInsensitiveMatch(char *s1, char *s2) {  /* Return true if the two strings are the same, not considering case. */	int len, i, c1, c2;	len = strlen(s1);	if (strlen(s2) !!= len) return false;	for (i = 0; i < len; i++) {		c1 = s1[i];		c2 = s2[i];		if ((c1 >= ''a'') && (c1 <= ''z'')) {			c1 = c1 - (''a'' - ''A'');		}		if ((c2 >= ''a'') && (c2 <= ''z'')) {			c2 = c2 - (''a'' - ''A'');		}		if (c1 !!= c2) return false;	}	return true;}int StringToInteger(char *s) {  /* Answer the integer resulting from converting the given     string, assumed to be decimal integer. */	int sign, n, i, ch;	sign = 1;	n = 0;	i = 0;	while ((ch = s[i++]) !!= 0) {		if ((ch == ''-'') && (i == 1)) {			sign = -1;		} else {			if ((ch >= ''0'') && (ch <= ''9'')) {				n = (10 * n) + (ch - ''0'');			} else {				return sign * n;			}		}	}	return sign * n;}void ExitCleanup(void) {  /* Clean up and stop running plugin. */	if (thisInstance == nil) return;	thisInstance = nil;	exitRequested = true;	while(gSqueakThread !!= kNoThreadID && YieldToThread(gSqueakThread) == noErr){};		plugInShutdown();	ioSetFullScreenRestore();	NPP_Initialize();  /* reset local variables */}/*** Interpreter Hooks ***/int plugInNotifyUser(char *msg) {  /* Notify the user that there was a problem starting Squeak. */	CopyCStringToPascal(msg,notificationMsg); /* copy message, since notification is asynchronous */	notifyRec.qType = nmType;	notifyRec.nmMark = false;			/* no mark in applications menu */	notifyRec.nmIcon = nil;				/* no menu bar icon */	notifyRec.nmSound = (Handle) -1;	/* -1 means system beep */	notifyRec.nmStr = notificationMsg;	notifyRec.nmResp = (NMUPP) -1;		/* -1 means remove notification when user confirms */	/* add to notification queue */	NMInstall(&notifyRec);}void plugInSetStartTime(void) {}int plugInTimeToReturn(void) {    if (exitRequested)        return true;    return false;}int parseMemorySize(int baseSize, char *src){	char buf[50], *tmp;	int imageSize = 0, requestedSize;	while(*src) {		switch(*src) {			case '' '': /* white spaces; ignore */			case ''"'':				src++; break;			case ''*'': /* multiple of image size */				tmp = buf; src++;				while(*src && isdigit(*src)) *(tmp++) = *(src++); /* integer part */				if(*src == ''.'') { /* fraction part */					*(tmp++) = *(src++);					while(*src && isdigit(*src)) *(tmp++) = *(src++);				}				*(tmp++) = 0;				imageSize += (int) (baseSize * atof(buf));				break;			case ''+'': /* additional space in bytes */				tmp = buf; src++;				while(*src && isdigit(*src)) *(tmp++) = *(src++);				*(tmp++) = 0;				if (imageSize == 0) 					imageSize = baseSize;				requestedSize = atoi(buf);				imageSize += (requestedSize <= 1000) ? requestedSize*1024*1024 : requestedSize;				break;			default: /* absolute size */				tmp = buf;				*(tmp++) = *(src++);				while(*src && isdigit(*src)) *(tmp++) = *(src++);				*(tmp++) = 0;				requestedSize = atoi(buf);				imageSize = (requestedSize <= 1000) ? requestedSize*1024*1024 : requestedSize;		}	}	return imageSize;}int AbortIfFileURL(char *url){   char lookFor[6];	int i=0,placement=0;		lookFor[5] = 0x00;	while (true) {		if (*url == 0x00) break;		if (*url == '' '') {			url++;		} else {		  lookFor[placement++] = *url++;		  if (placement == 5) break;		}	}	return !!CaseInsensitiveMatch(lookFor,"file:");}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/16/2001 21:48'!macDirectoryFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism.  Feb 2nd 2001, JMM rewrote, using more current file manager logic. */#include "sq.h"#include "FilePlugin.h"/* End of adjustments for pluginized VM */#include <Files.h>#include <Strings.h>#ifndef __MPW__#include <path2fss.h>#else#include <Aliases.h>#include <StandardFile.h>#include <Gestalt.h>#endif#include <Navigation.h>/***	The interface to the directory primitive is path based.	That is, the client supplies a Squeak string describing	the path to the directory on every call. To avoid traversing	this path on every call, a cache is maintained of the last	path seen, along with the Mac volume and folder reference	numbers corresponding to that path.***//*** Constants ***/#define ENTRY_FOUND     0#define NO_MORE_ENTRIES 1#define BAD_PATH        2#define DELIMITOR '':''#define MAX_PATH 2000/*** Variables ***/char lastPath[MAX_PATH + 1];int  lastPathValid = false;FSSpec lastSpec;/*** Functions ***/int convertToSqueakTime(int macTime);int equalsLastPath(char *pathString, int pathStringLength);int lookupPath(char *pathString, int pathStringLength, FSSpec *spec,Boolean noDrillDown);int recordPath(char *pathString, int pathStringLength, FSSpec *spec);void makePascalStringFromSqName(char *pathString, int pathStringLength,unsigned char *name);OSErr makeFSSpec(char *pathString, int pathStringLength,FSSpec *spec);OSErr getSpecAndFInfo(char *filename, int filenameSize,FSSpec *spec,FInfo *finderInfo);int fetchFileInfo(CInfoPBRec *pb,int dirIndex,FSSpec *spec,unsigned char *name, Boolean doAlias, Boolean *isFolder);int doItTheHardWay(unsigned char *pathString,FSSpec *spec,CInfoPBRec *pb,Boolean noDrillDown);pascal	OSErr	FSMakeFSSpecCompat(short vRefNum,								   long dirID,								   ConstStr255Param fileName,								   FSSpec *spec);OSErr FSpLocationFromFullPath(short fullPathLength,									 const void *fullPath,									 FSSpec *spec);									 pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath);pascal	OSErr	FSpGetFullPath(const FSSpec *spec,							   short *fullPathLength,							   Handle *fullPath);							   OSErr squeakFindImage(const FSSpecPtr defaultLocationfssPtr,FSSpecPtr documentfsSpec);pascal void findImageEventProc(NavEventCallbackMessage callBackSelector,                         NavCBRecPtr callBackParms,                         NavCallBackUserData callBackUD);pascal Boolean findImageFilterProc(AEDesc* theItem, void* info,                             NavCallBackUserData callBackUD,                            NavFilterModes filterMode);                        						pascal short DialogHook(short item, DialogPtr theDialog, 	void *userData);	OSErr __path2fss(const char * pathName, FSSpecPtr spec){    return lookupPath((char *) pathName, strlen(pathName),spec,true);}									 								 int convertToSqueakTime(int macTime) {	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than Mac one */	return macTime + (3 * 365 * 24 * 60 * 60);}void makePascalStringFromSqName(char *pathString, int pathStringLength,unsigned char *name){	/* copy file name into a Pascal string */		name[0] = pathStringLength;	strncpy((char *)name+1,pathString,pathStringLength);} OSErr makeFSSpec(char *pathString, int pathStringLength,FSSpec *spec){		char name[256];		if (pathStringLength > 255 ) 	    return -1;       strncpy((char *) name,pathString,pathStringLength);    name[pathStringLength] = 0x00;    return __path2fss((char *) name, spec);}int dir_Create(char *pathString, int pathStringLength) {	/* Create a new directory with the given path. By default, this	   directory is created in the current directory. Use	   a full path name such as "MyDisk:Working:New Folder" to	   create folders elsewhere. */    //JMM tests create file in Vm directory, other place, other volume        FSSpec spec;    OSErr  err;    long  createdDirID;        if ((err = makeFSSpec(pathString, pathStringLength,&spec)) == -1)        return false;           	return FSpDirCreate(&spec,smSystemScript,&createdDirID) == noErr;}int dir_Delete(char *pathString, int pathStringLength) {	/* Delete the existing directory with the given path. */    FSSpec spec;    OSErr  err;    if ((err = makeFSSpec(pathString, pathStringLength,&spec)) == -1)        return false;           	return FSpDelete(&spec) == noErr;}int dir_Delimitor(void) {	return DELIMITOR;}int dir_Lookup(char *pathString, int pathStringLength, int index,  /* outputs: */  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile) {	/* Lookup the index-th entry of the directory with the given path, starting	   at the root of the file system. Set the name, name length, creation date,	   creation time, directory flag, and file size (if the entry is a file).	   Return:	0 	if a entry is found at the given index	   			1	if the directory has fewer than index entries	   			2	if the given path has bad syntax or does not reach a directory	*/	int okay;	HVolumeParam volumeParams;	CInfoPBRec dirParams;    FSSpec      spec;    Boolean     isFolder;    OSErr       err;    	/* default return values */	*name             = 0;	*nameLength       = 0;	*creationDate     = 0;	*modificationDate = 0;	*isDirectory      = false;	*sizeIfFile       = 0;	if ((pathStringLength == 0)) {		/* get volume info */		volumeParams.ioNamePtr = (unsigned char *) name;		volumeParams.ioVRefNum = 0;		volumeParams.ioVolIndex = index;		okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;		if (okay) {			CopyPascalStringToC((ConstStr255Param) name,name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(volumeParams.ioVCrDate);			*modificationDate = convertToSqueakTime(volumeParams.ioVLsMod);			*isDirectory      = true;			*sizeIfFile       = 0;			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	} else {		/* get file or directory info */		if (!!equalsLastPath(pathString, pathStringLength)) {			/* lookup and cache the refNum for this path */			err = lookupPath(pathString, pathStringLength, &spec,false);			if (err == noErr) 				recordPath(pathString, pathStringLength, &spec);			else 				return BAD_PATH;		}	    spec = lastSpec;		okay = fetchFileInfo(&dirParams,index,&spec,(unsigned char *) name,true,&isFolder);		if (okay) {			CopyPascalStringToC((ConstStr255Param) name,name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(dirParams.hFileInfo.ioFlCrDat);			*modificationDate = convertToSqueakTime(dirParams.hFileInfo.ioFlMdDat);			if (((dirParams.hFileInfo.ioFlAttrib & kioFlAttribDirMask) !!= 0) || isFolder) {				*isDirectory  = true;				*sizeIfFile   = 0;			} else {				*isDirectory  = false;				*sizeIfFile   = dirParams.hFileInfo.ioFlLgLen;			}			return ENTRY_FOUND;		} else			return NO_MORE_ENTRIES;	}}OSErr getSpecAndFInfo(char *filename, int filenameSize,FSSpec *spec,FInfo *finderInfo) {    OSErr err;        if ((err = makeFSSpec(filename, filenameSize,spec)) !!= noErr)        return err;            if ((err= FSpGetFInfo(spec,finderInfo)) !!= noErr)         return err;            return noErr;}dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Set the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */    FSSpec spec;    FInfo   finderInfo;        if (getSpecAndFInfo(filename,filenameSize,&spec,&finderInfo) !!= noErr)        return false;       	finderInfo.fdType = *((int *) fType);	finderInfo.fdCreator = *((int *) fCreator);	    return FSpSetFInfo(&spec,&finderInfo) == noErr;}dir_GetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Get the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */    FSSpec spec;    FInfo   finderInfo;        if (getSpecAndFInfo(filename,filenameSize,&spec,&finderInfo) !!= noErr)        return false;       	*((int *) fType) = finderInfo.fdType;	*((int *) fCreator) = finderInfo.fdCreator;	return true;}int equalsLastPath(char *pathString, int pathStringLength) {	/* Return true if the lastPath cache is valid and the	   given Squeak string equals it. */	int i, ch;	if (!!lastPathValid ||		(pathStringLength > MAX_PATH)) {			return false;	}	for (i = 0; i < pathStringLength; i++) {		ch = lastPath[i];		if ((ch == 0) || (ch !!= pathString[i])) return false;	}	return lastPath[i] == 0;}/*JMM 2001/02/02 rewrote */int lookupPath(char *pathString, int pathStringLength, FSSpec *spec,Boolean noDrillDown) {	/* Resolve the given path and return the resulting folder or volume	   reference number in *refNumPtr. Return error if the path is bad. */	CInfoPBRec      pb;	Str255          tempName; 	OSErr		    err;    Boolean         ignore;     /* First locate by farily normal methods, with perhaps an alias lookup */    strncpy((char*)tempName,pathString,pathStringLength);    tempName[0] = pathStringLength;    err = FSMakeFSSpecCompat(0,0,tempName,spec);    if (err == noErr) {        if (noDrillDown == false) {            fetchFileInfo(&pb,0,spec,spec->name,true,&ignore);        }        return noErr;    }                      /* Than failed, we might have an alias chain, or other issue so     first setup for directory or file then do it the hard way */        strncpy((char *)tempName,pathString,pathStringLength);    if (noDrillDown) {        tempName[pathStringLength] = 0x00;    }    else {        tempName[pathStringLength] = '':'';        tempName[pathStringLength+1] = 0x00;    }    err = doItTheHardWay(tempName,spec,&pb,noDrillDown);    return err;}/* This method is used to lookup paths, chunk by chunk. It builds specs for each chuck and fetchs the file information, Note the special case when noDrilldown */int doItTheHardWay(unsigned char *pathString,FSSpec *spec,CInfoPBRec *pb,Boolean noDrillDown) {    char *token;    Str255 lookup;    Boolean ignore,firstTime=true;    OSErr   err;        token = strtok((char*) pathString,":");    if (token == 0) return -1;    while (token)     {        if (firstTime) {            strncpy((char*) lookup+1,(char*) token,63);            lookup[0] = strlen(token)+1;            lookup[lookup[0]] = '':'';            firstTime = false;        } else {            strncpy((char*) lookup+2,(char*) token,63);            lookup[0] = strlen(token)+1;            lookup[1] = '':'';        }        if ((err = FSMakeFSSpecCompat(spec->vRefNum,spec->parID, lookup, spec)) !!= noErr)             return err;                fetchFileInfo(pb,0,spec,spec->name,true,&ignore);        token = strtok(NULL,":");     }   if (noDrillDown)        spec->parID = pb->dirInfo.ioDrParID;     return noErr;}/*Get the file ID that unique IDs this file or directory, also resolve any alias if required */int fetchFileInfo(CInfoPBRec *pb,int dirIndex,FSSpec *spec,unsigned char *name,Boolean doAlias,Boolean *isFolder) {    int i;    long    aliasGestaltInfo;         *isFolder = false;    pb->hFileInfo.ioNamePtr = name;	pb->hFileInfo.ioFVersNum = 0;	pb->hFileInfo.ioFDirIndex = dirIndex;	pb->hFileInfo.ioVRefNum = spec->vRefNum;	pb->hFileInfo.ioDirID = spec->parID;	if (PBGetCatInfoSync(pb) == noErr) {		if ((pb->hFileInfo.ioFlFndrInfo.fdFlags & kIsAlias) && doAlias) {		    FSSpec spec2;		    Boolean isAlias;		    OSErr   err;		    		   		   err = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, name,&spec2);#if TARGET_CPU_PPC           if ((Gestalt(gestaltAliasMgrAttr, &aliasGestaltInfo) == noErr) &&                aliasGestaltInfo & (1<<gestaltAliasMgrResolveAliasFileWithMountOptions)  &&                ((Ptr) ResolveAliasFileWithMountFlags !!= (Ptr)kUnresolvedCFragSymbolAddress)) {                err = ResolveAliasFileWithMountFlags(&spec2,false,isFolder,&isAlias,kResolveAliasFileNoUI);            }             else #endif    			err = ResolveAliasFile(&spec2,false,isFolder,&isAlias);    		    			            if (err == noErr) {            	if (dirIndex == 0) {            	    fetchFileInfo(pb,dirIndex,&spec2,spec2.name,false,isFolder);            	    *spec = spec2;            	}        		return true;			}		}        spec->parID = pb->hFileInfo.ioDirID;		return true;	}	return false;}int recordPath(char *pathString, int pathStringLength, FSSpec *spec) {	/* Copy the given Squeak string into the lastPath cache. */	if (pathStringLength > MAX_PATH) {		lastPath[0] = 0; /* set to empty string */		lastPathValid = false;		lastSpec = *spec;		return;	}	strncpy(lastPath,pathString,pathStringLength);	lastPath[pathStringLength] = 0; /* string terminator */	lastPathValid = true;	lastSpec = *spec;}pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath){	OSErr		result;	FSSpec		spec;		*fullPathLength = 0;	*fullPath = NULL;		result = FSMakeFSSpecCompat(vRefNum, dirID, name, &spec);	if ( (result == noErr) || (result == fnfErr) )	{		result = FSpGetFullPath(&spec, fullPathLength, fullPath);	}		return ( result );}pascal	OSErr	FSpGetFullPath(const FSSpec *spec,							   short *fullPathLength,							   Handle *fullPath){	OSErr		result;	OSErr		realResult;	FSSpec		tempSpec;	CInfoPBRec	pb;		*fullPathLength = 0;	*fullPath = NULL;			/* Default to noErr */	realResult = result = noErr;	#if 0//The following code doesn''t seem to work in OS X, the BlockMoveData crashes the// machine, the the FSMakeFSSpecCompat works, so go figure...  KG 4/1/01	/* work around Nav Services "bug" (it returns invalid FSSpecs with empty names) */	if ( spec->name[0] == 0 )	{		result = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, spec->name, &tempSpec);	}	else	{		/* Make a copy of the input FSSpec that can be modified */		BlockMoveData(spec, &tempSpec, sizeof(FSSpec));	}#endif 0	result = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, spec->name, &tempSpec);	if ( result == noErr )	{		if ( tempSpec.parID == fsRtParID )		{			/* The object is a volume */						/* Add a colon to make it a full pathname */			++tempSpec.name[0];			tempSpec.name[tempSpec.name[0]] = '':'';						/* We''re done */			result = PtrToHand(&tempSpec.name[1], fullPath, tempSpec.name[0]);			*fullPathLength = tempSpec.name[0];		}		else		{			/* The object isn''t a volume */						/* Is the object a file or a directory? */			pb.dirInfo.ioNamePtr = tempSpec.name;			pb.dirInfo.ioVRefNum = tempSpec.vRefNum;			pb.dirInfo.ioDrDirID = tempSpec.parID;			pb.dirInfo.ioFDirIndex = 0;			result = PBGetCatInfoSync(&pb);			// Allow file/directory name at end of path to not exist.			realResult = result;			if ( (result == noErr) || (result == fnfErr) )			{				/* if the object is a directory, append a colon so full pathname ends with colon */				if ( (result == noErr) && (pb.hFileInfo.ioFlAttrib & kioFlAttribDirMask) !!= 0 )				{					++tempSpec.name[0];					tempSpec.name[tempSpec.name[0]] = '':'';				}								/* Put the object name in first */				result = PtrToHand(&tempSpec.name[1], fullPath, tempSpec.name[0]);				*fullPathLength = tempSpec.name[0];				if ( result == noErr )				{					/* Get the ancestor directory names */					pb.dirInfo.ioNamePtr = tempSpec.name;					pb.dirInfo.ioVRefNum = tempSpec.vRefNum;					pb.dirInfo.ioDrParID = tempSpec.parID;					do	/* loop until we have an error or find the root directory */					{						pb.dirInfo.ioFDirIndex = -1;						pb.dirInfo.ioDrDirID = pb.dirInfo.ioDrParID;						result = PBGetCatInfoSync(&pb);						if ( result == noErr )						{							/* Append colon to directory name */							++tempSpec.name[0];							tempSpec.name[tempSpec.name[0]] = '':'';														/* Add directory name to beginning of fullPath */							(void) Munger(*fullPath, 0, NULL, 0, &tempSpec.name[1], tempSpec.name[0]);							*fullPathLength += tempSpec.name[0];							result = MemError();						}					} while ( (result == noErr) && (pb.dirInfo.ioDrDirID !!= fsRtDirID) );				}			}		}	}		if ( result == noErr )	{		/* Return the length *////		*fullPathLength = GetHandleSize(*fullPath);		result = realResult;	// return realResult in case it was fnfErr	}	else	{		/* Dispose of the handle and return NULL and zero length */		if ( *fullPath !!= NULL )		{			DisposeHandle(*fullPath);		}		*fullPath = NULL;		*fullPathLength = 0;	}		return ( result );}pascal	OSErr	FSMakeFSSpecCompat(short vRefNum,								   long dirID,								   ConstStr255Param fileName,								   FSSpec *spec){	OSErr	result;		/* Let the file system create the FSSpec if it can since it does the job */	/* much more efficiently than I can. */	result = FSMakeFSSpec(vRefNum, dirID, fileName, spec);	/* Fix a bug in Macintosh PC Exchange''s MakeFSSpec code where 0 is */	/* returned in the parID field when making an FSSpec to the volume''s */	/* root directory by passing a full pathname in MakeFSSpec''s */	/* fileName parameter. Fixed in Mac OS 8.1 */	if ( (result == noErr) && (spec->parID == 0) )		spec->parID = fsRtParID;	return ( result );}OSErr FSpLocationFromFullPath(short fullPathLength,									 const void *fullPath,									 FSSpec *spec){	AliasHandle	alias;	OSErr		result;	Boolean		wasChanged;	Str32		nullString;		/* Create a minimal alias from the full pathname */	nullString[0] = 0;	/* null string to indicate no zone or server name */	result = NewAliasMinimalFromFullPath(fullPathLength, fullPath, nullString, nullString, &alias);	if ( result == noErr )	{		/* Let the Alias Manager resolve the alias. */		result = ResolveAlias(NULL, alias, spec, &wasChanged);				/* work around Alias Mgr sloppy volume matching bug */		if ( spec->vRefNum == 0 )		{			/* invalidate wrong FSSpec */			spec->parID = 0;			spec->name[0] =  0;			result = nsvErr;		}		DisposeHandle((Handle)alias);	/* Free up memory used */	}	return ( result );}typedef struct {	StandardFileReply *theSFR;	FSSpec *itemSpec;} HookRecord, *HookRecordPtr;OSErr squeakFindImage(const FSSpecPtr defaultLocationfssPtr,FSSpecPtr documentFSSpec){    NavDialogOptions    dialogOptions;    AEDesc              defaultLocation;    NavEventUPP         eventProc = NewNavEventUPP(findImageEventProc);    NavObjectFilterUPP  filterProc =  NewNavObjectFilterUPP(findImageFilterProc);    OSErr               anErr = noErr;    #if !!TARGET_API_MAC_CARBON    if ((Ptr) NavGetDefaultDialogOptions==(Ptr)kUnresolvedCFragSymbolAddress ) {      	//System pre 8.5 or system 7.x    	// point my hook data record at the reply record and at		// the file spec for the system file		     	StandardFileReply mySFR;    	HookRecord hookRec;	    DlgHookYDUPP	myDlgHookUPP;    	SFTypeList mySFTypeList;	    Point dialogPt;	    		hookRec.itemSpec = defaultLocationfssPtr;		hookRec.theSFR = &mySFR;		SetPt(&dialogPt, -1, -1);		// Set up the universal proc pointer to your hook routine with this 		// macro defined in StandardFile.h.  **NOTE** This is different		// from the macro used for System 6 dialog hooks, and you should get		// a compiler error if you try to use the wrong UPP with the wrong call.		myDlgHookUPP = NewDlgHookYDProc(DialogHook);				// call Std File		CustomGetFile(nil, -1, mySFTypeList, &mySFR, 0, dialogPt, myDlgHookUPP,			nil, nil, nil, &hookRec);					// Dispose of the routine descriptor, since they do allocate memory..		DisposeRoutineDescriptor(myDlgHookUPP);		*documentFSSpec = mySFR.sfFile; 		return noErr;	}#endif    //  Specify default options for dialog box    anErr = NavGetDefaultDialogOptions(&dialogOptions);    if (anErr == noErr)    {        //  Adjust the options to fit our needs        //  Set default location option        dialogOptions.dialogOptionFlags |= kNavSelectDefaultLocation;        dialogOptions.dialogOptionFlags |= kNavNoTypePopup;        //  Clear preview option        dialogOptions.dialogOptionFlags ^= kNavAllowPreviews;                // make descriptor for default location        anErr = AECreateDesc(typeFSS, defaultLocationfssPtr,                             sizeof(*defaultLocationfssPtr),                             &defaultLocation );        if (anErr == noErr)        {            // Get ''open'' resource. A nil handle being returned is OK,            // this simply means no automatic file filtering.            NavTypeListHandle typeList = (NavTypeListHandle)GetResource(                                        ''open'', 128);            NavReplyRecord reply;                        // Call NavGetFile() with specified options and            // declare our app-defined functions and type list            anErr = NavGetFile (&defaultLocation, &reply, &dialogOptions,                                eventProc, nil, filterProc,                                typeList, nil);            if (anErr == noErr && reply.validRecord)            {                //  Deal with multiple file selection                long    count;                                anErr = AECountItems(&(reply.selection), &count);                // Set up index for file list                if (anErr == noErr)                {                    long index;                                        for (index = 1; index <= 1; index++)                    {                        AEKeyword   theKeyword;                        DescType    actualType;                        Size        actualSize;                                                // Get a pointer to selected file                        anErr = AEGetNthPtr(&(reply.selection), index,                                            typeFSS, &theKeyword,                                            &actualType,documentFSSpec,                                            sizeof(FSSpec),                                            &actualSize);                     }                }                //  Dispose of NavReplyRecord, resources, descriptors                anErr = NavDisposeReply(&reply);            }            if (typeList !!= NULL)            {                ReleaseResource( (Handle)typeList);            }            (void) AEDisposeDesc(&defaultLocation);        }    }    DisposeNavEventUPP(eventProc);    DisposeNavObjectFilterUPP(filterProc);    return anErr;}pascal void findImageEventProc(NavEventCallbackMessage callBackSelector,                         NavCBRecPtr callBackParms,                         NavCallBackUserData callBackUD){   // WindowPtr window =    //                 (WindowPtr)callBackParms->eventData.event->message;    switch (callBackSelector)    {        case kNavCBEvent:            switch (((callBackParms->eventData)                    .eventDataParms).event->what)            {                case updateEvt:                   // MyHandleUpdateEvent(window,                     //    (EventRecord*)callBackParms->eventData.event);                    break;            }            break;    }}pascal Boolean findImageFilterProc(AEDesc* theItem, void* info,                             NavCallBackUserData callBackUD,                            NavFilterModes filterMode){    OSErr theErr = noErr;    Boolean display = true;    NavFileOrFolderInfo* theInfo = (NavFileOrFolderInfo*)info;        if (theItem->descriptorType == typeFSS)        if (!!theInfo->isFolder)            if (theInfo->fileAndFolder.fileInfo.finderInfo.fdType                 !!= ''STim'')                display = false;    return display;}#if !!TARGET_API_MAC_CARBON// this dialog hook for System 7 std file selects// the file specified by the hookRecord supplied as userDatapascal short DialogHook(short item, DialogPtr theDialog, 	void *userData){	HookRecordPtr hookRecPtr;		hookRecPtr = (HookRecordPtr) userData;		// hookRecPtr->itemSpec points to the FSSpec of the item to be selected	// hookRecPtr->theSFR points to the standard file reply record	// make sure we''re dealing with the proper dialog	if (GetWRefCon(theDialog) == sfMainDialogRefCon) {			// just when opening the dialog...		if (item == sfHookFirstCall) {				// make the reply record hold the spec of the specified item			hookRecPtr->theSFR->sfFile = *hookRecPtr->itemSpec;						// ThereÕs a gotcha in Standard File when using sfHookChangeSelection. 			// Even though New Inside Macintosh: Files has a sample that doesn''t set			// the sfScript field, it should be set, or the last object in the			// selected directory  will always be selected.			hookRecPtr->theSFR->sfScript = smSystemScript;			// tell std file to change the selection to that item			item = sfHookChangeSelection;		}	}						return item;}#endif#ifndef __MPW__#include <ansi_files.h>#include <buffer_io.h>int fflush(FILE * file){	fpos_t	position;                    /* mm 970708 */	ParamBlockRec pb;    OSErr error;		if (!!file)		return(__flush_all());		if (file->state.error || file->mode.file_kind == __closed_file)		return(EOF);		if (file->mode.io_mode == __read)		/* mm 980430 */		return 0;							/* mm 980430 */		if (file->state.io_state >= __rereading)		file->state.io_state = __reading;		if (file->state.io_state == __reading)		file->buffer_len = 0;		if (file->state.io_state !!= __writing)	{		file->state.io_state = __neutral;  /* mm 970905 */		return(0);	}	#ifndef _No_Disk_File_OS_Support	if (file->mode.file_kind !!= __disk_file || (position = ftell(file)) < 0)		position = 0;#else	position = 0;#endif		if (__flush_buffer(file, NULL))	{		set_error(file);		return(EOF);	}		file->state.io_state = __neutral;	file->position       = position;	file->buffer_len     = 0;		pb.ioParam.ioRefNum = file->handle;    error = PBFlushFileSync(&pb); 	return(0);}#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/12/2001 16:23'!macDragDropFile	^ '/*  Jan 24th 2001	Drag and drop support for Squeak 	John M McIntosh of Corporate Smalltalk Consulting Ltd	johnmci@smalltalkconsulting.com 	http://www.smalltalkconsulting.com 	In Jan of 2001 under contract to Disney		Dragging is only for objects into Squeak, not from Squeak outwards.		    V1.0 Jan 24th 2001, JMMSome of this code comes from	Author:		John Montbriand				Some techniques borrowed from Pete Gontier''s original FinderDragPro.	Copyright: 	Copyright: © 1999 by Apple Computer, Inc.				all rights reserved.		Disclaimer:	You may incorporate this sample code into your applications without				restriction, though the sample code has been provided "AS IS" and the				responsibility for its operation is 100% yours.  However, what you are				not permitted to do is to redistribute the source as "DSC Sample Code"				after having made changes. If you''re going to re-distribute the source,				we require that you make it clear in the source that the code was				descended from Apple Sample Code, but that you''ve made changes.		Change History (most recent first):	9/9/99 by John Montbriand	*//*    need get filetype/creator    need DropPlugin_shutdownModule & dropShutdown    */#include "sq.h"#include <drag.h>#include <macwindows.h>#include <gestalt.h>#include <quickdraw.h>#include "sqVirtualMachine.h"#include "FilePlugin.h"#include "DropPlugin.h"#if TARGET_API_MAC_CARBON#else    inline Rect *GetPortBounds(CGrafPtr w,Rect *r) { *r = w->portRect; return &w->portRect;}  #endif	/* promise flavor types */	enum {	kPromisedFlavor = ''fssP'',		/* default promise */	kPromisedFlavorFindFile = ''rWm1'' /* Find File promise -- special case */}; Boolean gHasDragManager = false;                    /* true if the Drag Manager is installed */ Boolean gCanTranslucentDrag = false;                /* true if translucent dragging is available */ DragReceiveHandlerUPP gMainReceiveHandler = NULL;   /* receive handler for the main dialog */ DragTrackingHandlerUPP gMainTrackingHandler = NULL; /* tracking handler for the main dialog */ WindowPtr   gWindowPtr; extern Boolean         gAllowAccessToFilePlease;  UInt16 gNumDropFiles=0; HFSFlavor *dropFiles;#define DOCUMENT_NAME_SIZE 300char tempName[DOCUMENT_NAME_SIZE + 1];  	/* these routines are used both in the receive handler and inside of the		tracking handler.  The following variables are shared between MyDragTrackingHandler		and MyDragReceiveHandler.  */		 Boolean gApprovedDrag = false;   /* set to true if the drag is approved */ Boolean gInIconBox = false;      /* set true if the drag is inside our drop box */extern struct VirtualMachine *interpreterProxy;extern WindowPtr getSTWindow(void); pascal OSErr MyDragTrackingHandler(DragTrackingMessage message, WindowPtr theWindow, void *refCon, DragReference theDragRef); pascal OSErr MyDragReceiveHandler(WindowPtr theWindow, void *refcon, DragReference theDragRef);extern int (*instantiateClassindexableSize)(int classPointer, int size);extern int classByteArray(void);extern int fileRecordSize(void);extern int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);extern SQFile * fileValueOf(int objectPointer);extern int recordDragDropEvent(EventRecord *theEvent, int theButtonState, int numberOfItems, int dragType);extern int MouseModifierState(EventRecord *theEvent);extern void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short VolumeNumber,long directoryID);// Startup logicint dropInit(void){    long response;    long fn;    Boolean  installedReceiver=false, installedTracker=false;    OSErr err;        /* check for the drag manager & translucent feature??? */    	if (gMainReceiveHandler !!= NULL) return 1;		if (Gestalt(gestaltDragMgrAttr, &response) !!= noErr) return 0;		gHasDragManager = (((1 << gestaltDragMgrPresent)) !!= 0);	gCanTranslucentDrag = (((1 << gestaltDragMgrHasImageSupport)) !!= 0);    if (!!(gHasDragManager && gCanTranslucentDrag)) return 0;		if ((Ptr)InstallTrackingHandler==(Ptr)kUnresolvedCFragSymbolAddress) return 0;		gWindowPtr = getSTWindow();	gMainTrackingHandler = NewDragTrackingHandlerUPP(MyDragTrackingHandler);	if (gMainTrackingHandler == NULL) return 0;	gMainReceiveHandler = NewDragReceiveHandlerUPP(MyDragReceiveHandler);	if (gMainReceiveHandler == NULL) return 0;		/* install the drag handlers, don''t forget to dispose of them later */			err = InstallTrackingHandler(gMainTrackingHandler, gWindowPtr, NULL);	if (err !!= noErr) { 	    err = memFullErr; 	    goto bail;     }	installedTracker = true;	err = InstallReceiveHandler(gMainReceiveHandler, gWindowPtr, NULL);		if (err !!= noErr) { 	    err = memFullErr; 	    goto bail; 	}	installedReceiver = true;	return 1;	bail:     if (installedReceiver)		RemoveReceiveHandler(gMainReceiveHandler, gWindowPtr);	if (installedTracker)		RemoveTrackingHandler(gMainTrackingHandler, gWindowPtr);		gMainTrackingHandler = NULL;     gMainReceiveHandler = NULL;    	return 0;}	// Shutdown logicint dropShutdown() {    if (gMainReceiveHandler !!= NULL)		RemoveReceiveHandler(gMainReceiveHandler, gWindowPtr);	if (gMainTrackingHandler !!= NULL)		RemoveTrackingHandler(gMainTrackingHandler, gWindowPtr);	if (gNumDropFiles !!= 0 ) {	    DisposePtr((char *) dropFiles);	    gNumDropFiles = 0;	}		gMainTrackingHandler = NULL;     gMainReceiveHandler = NULL;}//Primitive to get file namechar *dropRequestFileName(int dropIndex) {    char	shortName[256];      if(dropIndex < 1 || dropIndex > gNumDropFiles)         return NULL;    CopyPascalStringToC(dropFiles[dropIndex-1].fileSpec.name,shortName);    StoreFullPathForLocalNameInto(shortName,         tempName,         DOCUMENT_NAME_SIZE,        dropFiles[dropIndex-1].fileSpec.vRefNum,        dropFiles[dropIndex-1].fileSpec.parID);  return tempName;}//Primitive to get file stream handle.int dropRequestFileHandle(int dropIndex) {    int fileHandle;    int   size,classPointer;    char *dropName = dropRequestFileName(dropIndex);        if(!!dropName)        return interpreterProxy->nilObject();    size = fileRecordSize();    classPointer = interpreterProxy->classByteArray();    fileHandle = interpreterProxy->instantiateClassindexableSize(classPointer, size);    gAllowAccessToFilePlease = true;    sqFileOpen(fileValueOf(fileHandle),(int)dropName, strlen(dropName), 0);    gAllowAccessToFilePlease = false;      return fileHandle;}/* RECEIVING DRAGS ------------------------------------------------ *//* ApproveDragReference is called by the drag tracking handler to determine	if the contents of the drag can be handled by our receive handler.	Note that if a flavor can''t be found, it''s not really an	error; it only means the flavor wasn''t there and we should	not accept the drag. Therefore, we translate ''badDragFlavorErr''	into a ''false'' value for ''*approved''. */	static pascal OSErr ApproveDragReference(DragReference theDragRef, Boolean *approved) {	OSErr err;	DragAttributes dragAttrs;	FlavorFlags flavorFlags;	ItemReference theItem;				/* we cannot drag to our own window */	if ((err = GetDragAttributes(theDragRef, &dragAttrs)) !!= noErr) 	    goto bail;	    	if ((dragAttrs & kDragInsideSenderWindow) !!= 0) { 	    err = userCanceledErr; 	    goto bail;     }			/* gather information about the drag & a reference to item one. */	if ((err = GetDragItemReferenceNumber(theDragRef, 1, &theItem)) !!= noErr) 	    goto bail;				/* check for flavorTypeHFS */	err = GetFlavorFlags(theDragRef, theItem, flavorTypeHFS, &flavorFlags);	if (err == noErr) {		*approved = true;		return noErr;	} else if (err !!= badDragFlavorErr)		goto bail;				/* check for flavorTypePromiseHFS */	err = GetFlavorFlags(theDragRef, theItem, flavorTypePromiseHFS, &flavorFlags);	if (err == noErr) {		*approved = true;		return noErr;	} else if (err !!= badDragFlavorErr)		goto bail;				/* none of our flavors were found */	*approved = false;	return noErr;	bail:		/* an error occured, clean up.  set result to false. */	*approved = false;	return err;}/* MyDragTrackingHandler is called for tracking the mouse while a drag is passing over our	window.  if the drag is approved, then the drop box will be hilitied appropriately	as the mouse passes over it.  */	static pascal OSErr MyDragTrackingHandler(DragTrackingMessage message, WindowPtr theWindow, void *refCon, DragReference theDragRef) {		/* we''re drawing into the image well if we hilite... */    Rect  bounds;	EventRecord		theEvent;	switch (message) {			case kDragTrackingEnterWindow:			{					Point mouse;								gApprovedDrag = false;				if (theWindow == gWindowPtr) {					if (ApproveDragReference(theDragRef, &gApprovedDrag) !!= noErr) break;					if ( !! gApprovedDrag ) break;					SetPortWindowPort(theWindow);					GetMouse(&mouse);					GetPortBounds(GetWindowPort(gWindowPtr),&bounds);					if (PtInRect(mouse, &bounds)) {  // if we''re in the box, hilite... 						gInIconBox = true;					                    	    /* queue up an event */                        WaitNextEvent(0, &theEvent,0,null);                    	recordDragDropEvent(&theEvent, MouseModifierState(&theEvent),gNumDropFiles,DragEnter);					} 				}			}			break;		case kDragTrackingInWindow:			if (gApprovedDrag) {                WaitNextEvent(0, &theEvent,0,null);            	recordDragDropEvent(&theEvent, MouseModifierState(&theEvent),gNumDropFiles,DragMove);			}			break;		case kDragTrackingLeaveWindow:			if (gApprovedDrag && gInIconBox) {            	    /* queue up an event */                WaitNextEvent(0, &theEvent,0,null);            	recordDragDropEvent(&theEvent, MouseModifierState(&theEvent),gNumDropFiles,DragLeave);			}			gApprovedDrag = gInIconBox = false;			break;	}	return noErr; // there''s no point in confusing Drag Manager or its caller}/* MyDragReceiveHandler is the receive handler for the main window.  It is called	when a file or folder (or a promised file or folder) is dropped into the drop	box in the main window.  Here, if the drag reference has been approved in the	track drag call, we handle three different cases:		1. standard hfs flavors,		2. promised flavors provided by find file, mmmm This may be a pre sherlock issue		3. promised flavors provided by other applications.	     */     static pascal OSErr MyDragReceiveHandler(WindowPtr theWindow, void *refcon, DragReference theDragRef) {	ItemReference   theItem;	PromiseHFSFlavor targetPromise;	Size            theSize;	OSErr           err;	EventRecord		theEvent;	long            i,countActualItems;	FInfo 			finderInfo;	HFSFlavor		targetHFSFlavor;			/* validate the drag.  Recall the receive handler will only be called after		the tracking handler has received a kDragTrackingInWindow event.  As a result,		the gApprovedDrag and gInIconBox will be defined when we arrive here.  Hence,		there is no need to spend extra time validating the drag at this point. */			if ( !! (gApprovedDrag && gInIconBox) )  	    return userCanceledErr; 	if (gNumDropFiles !!=0 ) 	    DisposePtr((char *) dropFiles);	    	if ((err = CountDragItems(theDragRef, &gNumDropFiles)) !!= noErr) 	    return paramErr;		dropFiles = (HFSFlavor *) NewPtr(sizeof(HFSFlavor)*gNumDropFiles);		if (dropFiles == null) 	    return userCanceledErr;	    WaitNextEvent(0, &theEvent,0,null);    countActualItems = 0;    		    for(i=1;i<=gNumDropFiles;i++) {		/* get the first item reference */    	if ((err = GetDragItemReferenceNumber(theDragRef, i, &theItem)) !!= noErr)     	    continue;    		/* try to get a  HFSFlavor*/    	theSize = sizeof(HFSFlavor);    	err = GetFlavorData(theDragRef, theItem, flavorTypeHFS, &targetHFSFlavor, &theSize, 0);    	if (err == noErr) {    		if (dropFiles[countActualItems].fileCreator == ''MACS'' && (    				dropFiles[countActualItems].fileType == ''fold'' ||    				dropFiles[countActualItems].fileType == ''disk''))     				continue;    		dropFiles[countActualItems] = targetHFSFlavor;    		countActualItems++;    		continue;    	} else if (err !!= badDragFlavorErr)     	        continue;     	    		/* try to get a  promised HFSFlavor*/    	theSize = sizeof(PromiseHFSFlavor);    	err = GetFlavorData(theDragRef, theItem, flavorTypePromiseHFS, &targetPromise, &theSize, 0);    	if (err !!= noErr)     		continue;    	    		/* check for a drop from find file */    	if (targetPromise.promisedFlavor == kPromisedFlavorFindFile) {    	    			/* from find file, no need to set the file location... */    		theSize = sizeof(FSSpec);    		err = GetFlavorData(theDragRef, theItem, targetPromise.promisedFlavor, &dropFiles[countActualItems].fileSpec, &theSize, 0);    		if (err !!= noErr)     			continue;    		HGetFInfo(dropFiles[countActualItems].fileSpec.vRefNum,dropFiles[countActualItems].fileSpec.parID,dropFiles[countActualItems].fileSpec.name,  &finderInfo);	    		/* queue up an event */	        dropFiles[countActualItems].fileType = finderInfo.fdType;	        dropFiles[countActualItems].fileCreator = finderInfo.fdCreator;	        dropFiles[countActualItems].fdFlags =  finderInfo.fdFlags;    		countActualItems++;    	} else {    		err = badDragFlavorErr;    		return err;    	}    }    	gNumDropFiles = countActualItems;    if (gNumDropFiles == 0) {    	DisposePtr((char *) dropFiles);    	return noErr;    }		    /* queue up an event */	recordDragDropEvent(&theEvent, MouseModifierState(&theEvent),gNumDropFiles,DragDrop);	return noErr;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/16/2001 21:47'!macSecurityFile	^ '//JMM 2/13/01 create docs folder if non-existant#include "sq.h"#define fromSqueak(string,length) stringchar * GetAttributeString(int id);void fixPath(char *path);int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID);static char secureUserDirectory[256];static char untrustedUserDirectory[256];/***************************************************************************//***************************************************************************//***************************************************************************//***************************************************************************//* file security */static int allowFileAccess = 1;  /* full access to files */static int isAccessiblePathName(char *pathName) {  int i;  /* Check if the path/file name is subdirectory of the image path */  for(i=0; i<strlen(untrustedUserDirectory)-1; i++)    if(untrustedUserDirectory[i] !!= pathName[i]) return 0;  /* special check for the trusted directory */  if(pathName[i] == 0) return 1; /* allow access to trusted directory */  /* check last character in image path (e.g., backslash) */  if(untrustedUserDirectory[i] !!= pathName[i]) return 0;  /* check if somebody wants to trick us into using relative     paths ala Foo:My Squeak:allowed::" */  while(pathName[i]) {    if(pathName[i] == '':'') {      if(pathName[i+1] == '':'')	return 0; /* Gotcha!! */    }    i++;  }  return 1;}static int isAccessibleFileName(char *fileName) {  int i;  /* Check if the path/file name is subdirectory of the image path */  for(i=0; i<strlen(untrustedUserDirectory); i++)    if(untrustedUserDirectory[i] !!= fileName[i]) return 0;  /* check if somebody wants to trick us into using relative     paths ala Foo:My Squeak:allowed::" */  while(fileName[i]) {    if(fileName[i] == '':'') {      if(fileName[i+1] == '':'')	return 0; /* Gotcha!! */    }    i++;  }  return 1;}/* directory access */int ioCanCreatePathOfSize(char* pathString, int pathStringLength) {  if(allowFileAccess) return 1;  return isAccessiblePathName(fromSqueak(pathString, pathStringLength));}int ioCanListPathOfSize(char* pathString, int pathStringLength) {  if(allowFileAccess) return 1;  return isAccessiblePathName(fromSqueak(pathString, pathStringLength));}int ioCanDeletePathOfSize(char* pathString, int pathStringLength) {  if(allowFileAccess) return 1;  return isAccessiblePathName(fromSqueak(pathString, pathStringLength));}/* file access */int ioCanOpenFileOfSizeWritable(char* pathString, int pathStringLength, int writeFlag) {  if(allowFileAccess) return 1;  return isAccessibleFileName(fromSqueak(pathString, pathStringLength));}int ioCanOpenAsyncFileOfSizeWritable(char* pathString, int pathStringLength, int writeFlag) {  return ioCanOpenFileOfSizeWritable(pathString,pathStringLength,writeFlag);}int ioCanDeleteFileOfSize(char* pathString, int pathStringLength) {  if(allowFileAccess) return 1;  return isAccessibleFileName(fromSqueak(pathString, pathStringLength));}int ioCanRenameFileOfSize(char* pathString, int pathStringLength) {  if(allowFileAccess) return 1;  return isAccessibleFileName(fromSqueak(pathString, pathStringLength));}int ioCanGetFileTypeOfSize(char* pathString, int pathStringLength) {  return 1; /* of no importance here */}int ioCanSetFileTypeOfSize(char* pathString, int pathStringLength) {  return 1; /* of no importance here */}/* disabling/querying */int ioDisableFileAccess(void) {  allowFileAccess = 0;}int ioHasFileAccess(void) {  return allowFileAccess;}/***************************************************************************//***************************************************************************//***************************************************************************//***************************************************************************//* image security */static int allowImageWrite = 1;  /* allow writing the image */int ioCanRenameImage(void) {  return allowImageWrite; /* only when we''re allowed to save the image */}int ioCanWriteImage() {  return allowImageWrite;}int ioDisableImageWrite() {  allowImageWrite = 0;}/***************************************************************************//***************************************************************************//***************************************************************************//***************************************************************************//* socket security - for now it''s all or nothing */static int allowSocketAccess = 1; /* allow access to sockets */int ioCanCreateSocketOfType(int netType, int socketType) {  return allowSocketAccess;}int ioCanConnectToPort(int netAddr, int port) {  return allowSocketAccess;}int ioCanListenOnPort(void* s, int port) {  return allowSocketAccess;}int ioDisableSocketAccess() {  allowSocketAccess = 0;}int ioHasSocketAccess() {  return allowSocketAccess;}/***************************************************************************//***************************************************************************//***************************************************************************//***************************************************************************//* SecurityPlugin primitive support */char *ioGetSecureUserDirectory(void) {  return  secureUserDirectory;}char *ioGetUntrustedUserDirectory(void) {  return untrustedUserDirectory;}/* note: following is called from VM directly, not from plugin */int ioInitSecurity(void) {  short vRefNum;  long  dirID;  OSErr err;  /* establish the secure user directory */  strcpy(secureUserDirectory, GetAttributeString(1));  fixPath(secureUserDirectory);    /* establish untrusted user directory */	/* get the path to the sytem folder preference area*/	err = FindFolder(kOnAppropriateDisk, kDocumentsFolderType, kCreateFolder, &vRefNum, &dirID);	if (err !!= noErr) {      strcpy(untrustedUserDirectory, GetAttributeString(1));      fixPath(untrustedUserDirectory);      return 1;	}	PathToWorkingDir(untrustedUserDirectory,255,vRefNum,dirID);    fixPath(untrustedUserDirectory);  return 1;}/***************************************************************************//***************************************************************************//***************************************************************************//***************************************************************************//* private entries for restoring rights */int _ioSetImageWrite(int enable) {  if(enable == allowImageWrite) return 1;  allowImageWrite = enable;  return 1;}int _ioSetFileAccess(int enable) {  if(enable == allowFileAccess) return 1;  allowFileAccess = enable;  return 1;}int _ioSetSocketAccess(int enable) {  if(enable == allowSocketAccess) return 1;  allowSocketAccess = enable;  return 1;}void fixPath(char *path) {    long i;    for(i=strlen(path);i>0;i--)         if(path[i-1]=='':'') {            path[i-1]=0x00;            return;        }}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/16/2001 21:46'!macSoundFile	^ '/*Carbon porting notes:	Carbon doesn''t support the SndPlayDoubleBuffer system routine.	This is a command you put in the sound channel which repeatedly	calls a callback routine.		Technote 1198 describes the situation, a work-around and provides	example code.  I merely added this code to the end of this file	and plugged it into the existing Squeak code.Karl Goiser 14/01/01*///johnmci@smalltalkconsulting.com Nov 6th 2000. Added sound volume logic/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */ #include "sq.h"#include "SoundPlugin.h"/* initialize/shutdown */int soundInit() { return true; }int soundShutdown() { snd_Stop(); }/* End of adjustments for pluginized VM */#include <Sound.h>#include <SoundInput.h>/******  Mac Sound Output Notes:	The Squeak sound code produces 16-bit, stereo sound buffers. The was	arrived at after experimentation on a PPC 601 at 110 MHz on which I	found that:	  a. using 16-bit sound only slightly increased the background CPU burden and	  b. 16-bit sound yielded vastly superior sound quality.	My understanding is that SoundManager 3.0 or later supports the 16-bit	sound interface an all Macs, even if the hardware only supports 8-bits.	If this is not true, however, change BYTES_PER_SAMPLE to 1. Then, either	the Squeak code will need to be changed to use 8-bit sound buffers,	or (preferrably) snd_PlaySamplesFromAtLength will need to do the conversion	from 16 to 8 bits. I plan to cross that bridge if and when we need to.	The code as currently written was to support Squeak code that generated	8-bit sound buffers.	In earlier versions, I experimented with other sound buffer formats. Here	are all the sound buffer formats that were used at one point or another:		1. mono,    8-bits -- packed array of bytes (not currently used)		2. stereo,  8-bits -- as above, with L and R channels in alternate bytes (not currently used)		3. stereo, 16-bits -- array of 32-bit words; with L and R channels in high and low half-words	Note:  8-bit samples are encoded with 0x80 as the center (zero) value	Note: 16-bit samples are encoded as standard, signed integers (i.e., 2''s-complement)	Note: When the sound drive is operating in "mono", the two stereo channels are mixed	      together. This feature was added in January, 1998.	-- John Maloney, July 28, 1996	-- edited: John Maloney, January 5, 1998  Mac Sound Input Notes:	Squeak sound input is currently defined to provide a single (mono) stream	of signed 16-bit samples for all platforms. Platforms that only support	8-bit sound input should convert samples to signed 16 bit values, leaving	the low order bits zero. Since the available sampling rates differ from	platform to platform, the client may not get the requested sampling rate;	however, the call snd_GetRecordingSampleRate returns the sampling rate.	On many platforms, simultaneous record and playback is permitted only if	the input and output sampling rates are the same.	-- John Maloney, Aug 22, 1997******/#define BYTES_PER_SAMPLE 2/*** double-buffer state record ***/typedef struct {	int open;	int stereo;	int frameCount;	int sampleRate;	int lastFlipTime;	int playSemaIndex;	int bufSizeInBytes;	int bufState0;	int bufState1;	int done;} PlayStateRec;/*** possible buffer states ***/#define BUF_EMPTY	0#define BUF_FULL	1#define BUF_PLAYING	2/*** record buffer state record ***//* Note: RECORD_BUFFER_SIZE should be a multiple of 4096 bytes to avoid clicking.   (The clicking was observed on a Mac 8100; the behavior of other Macs could differ.)   Note: G3 Series Powerbook requires minimum of 4 * 4096 buffer size for stereo.*/#define RECORD_BUFFER_SIZE (4096 * 2)typedef struct {	SPB paramBlock;	int stereo;	int bytesPerSample;	int recordSemaIndex;	int readIndex;  /* index of the next sample to read */	char samples[RECORD_BUFFER_SIZE];} RecordBufferRec, *RecordBuffer;/*** sound output variables ***/SndChannelPtr chan;PlayStateRec bufState = {false, false, 0, 0, 0, 0, 0, 0, 0, true};SndDoubleBufferHeader dblBufHeader;/*** sound input variables ***/RecordBufferRec recordBuffer1, recordBuffer2;int recordingInProgress;long soundInputRefNum;/*** local functions ***/pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf);int FillBufferWithSilence(SndDoubleBufferPtr buf);pascal void FlipRecordBuffers(SPBPtr pb);int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex);OSErr CarbonSndPlayDoubleBuffer (SndChannelPtr chan, SndDoubleBufferHeaderPtr theParams);pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf) {  /* Switch buffers (at interrupt time). The given buffer just finished playing. */	PlayStateRec *state;	chan;  /* reference argument to avoid compiler warnings */	state = (PlayStateRec *) buf->dbUserInfo[0];	if (buf->dbUserInfo[1] == 0) {		state->bufState0 = BUF_EMPTY;		state->bufState1 = BUF_PLAYING;	} else {		state->bufState0 = BUF_PLAYING;		state->bufState1 = BUF_EMPTY;	}	buf->dbNumFrames = state->frameCount;	buf->dbFlags = buf->dbFlags | dbBufferReady;	if (state->done) {		buf->dbFlags = buf->dbFlags | dbLastBuffer;	} else {		signalSemaphoreWithIndex(state->playSemaIndex);	}	state->lastFlipTime = ioMicroMSecs();	FillBufferWithSilence(buf);  /* avoids ugly stutter if not filled in time */}int FillBufferWithSilence(SndDoubleBufferPtr buf) {	unsigned int *sample, *lastSample;	sample		= (unsigned int *) &buf->dbSoundData[0];	lastSample	= (unsigned int *) &buf->dbSoundData[bufState.bufSizeInBytes];	/* word-fill buffer with silence */	if (BYTES_PER_SAMPLE == 1) {		while (sample < lastSample) {			*sample++ = 0x80808080;  /* Note: 0x80 is zero value for 8-bit samples */		}	} else {		while (sample < lastSample) {			*sample++ = 0;		}	}}pascal void FlipRecordBuffers(SPBPtr pb) {	/* called at interrupt time to exchange the active and inactive record buffers */	RecordBuffer thisBuffer = (RecordBuffer) pb;	RecordBuffer nextBuffer = (RecordBuffer) pb->userLong;	if (pb->error == 0) {		/* restart recording using the other buffer */		SPBRecord(&nextBuffer->paramBlock, true);		/* reset the read pointer for the buffer that has just been filled */		thisBuffer->readIndex = 0;		signalSemaphoreWithIndex(nextBuffer->recordSemaIndex);	}}/*** exported sound output functions ***/int snd_AvailableSpace(void) {	if (!!bufState.open) return -1;	if ((bufState.bufState0 == BUF_EMPTY) ||		(bufState.bufState1 == BUF_EMPTY)) {			return bufState.bufSizeInBytes;	}	return 0;}int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex) {	SndDoubleBufferPtr buf;	int framesWritten;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		buf = dblBufHeader.dbhBufferPtr[0];		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			buf = dblBufHeader.dbhBufferPtr[1];			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	if (bufState.frameCount < frameCount) {		framesWritten = bufState.frameCount;	} else {		framesWritten = frameCount;	}	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) (arrayIndex + startIndex);		end = (unsigned char *) src + (framesWritten * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) &buf->dbSoundData[0];		while (src < end) {			*dst++ = *src++;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (arrayIndex + (startIndex * 4));		end = (short int *) (arrayIndex + ((startIndex + framesWritten) * 4));		dst = (short int *) &buf->dbSoundData[0];		if (bufState.stereo) {  /* stereo */			while (src < end) {				*dst++ = *src++;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			while (src < end) {				*dst++ = (*src++ + *src++) / 2;			}		}	}	return framesWritten;}int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex) {	int sample;	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) srcBufPtr + srcStartIndex;		end = (unsigned char *) srcBufPtr + (count * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) dstBufPtr + dstStartIndex;		while (src < end) {			sample = *dst + (*src++ - 128);			if (sample > 255) sample = 255;			if (sample < 0) sample = 0;			*dst++ = sample;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (srcBufPtr + (srcStartIndex * 4));		end = (short int *) (srcBufPtr + ((srcStartIndex + count) * 4));		if (bufState.stereo) {  /* stereo */			dst = (short int *) (dstBufPtr + (dstStartIndex * 4));			while (src < end) {				sample = *dst + *src++;				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			dst = (short int *) (dstBufPtr + (dstStartIndex * 2));			while (src < end) {				sample = *dst + ((*src++ + *src++) / 2);				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		}	}}int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime) {	SndDoubleBufferPtr bufPlaying, otherBuf;	int samplesInserted, startSample, count;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_PLAYING) {		bufPlaying = dblBufHeader.dbhBufferPtr[0];		otherBuf = dblBufHeader.dbhBufferPtr[1];	} else {		bufPlaying = dblBufHeader.dbhBufferPtr[1];		otherBuf = dblBufHeader.dbhBufferPtr[0];	}	samplesInserted = 0;	/* mix as many samples as can fit into the remainder of the currently playing buffer */	startSample =		((bufState.sampleRate * (ioMicroMSecs() - bufState.lastFlipTime)) / 1000) + samplesOfLeadTime;	if (startSample < bufState.frameCount) {		count = bufState.frameCount - startSample;		if (count > frameCount) count = frameCount;		MixInSamples(count, (char *) srcBufPtr, 0, (char *) &bufPlaying->dbSoundData[0], startSample);		samplesInserted = count;	}	/* mix remaining samples into the inactive buffer */	count = bufState.frameCount;	if (count > (frameCount - samplesInserted)) {		count = frameCount - samplesInserted;	}	MixInSamples(count, (char *) srcBufPtr, samplesInserted, (char *) &otherBuf->dbSoundData[0], 0);	return samplesInserted + count;}int snd_PlaySilence(void) {	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		FillBufferWithSilence(dblBufHeader.dbhBufferPtr[0]);		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			FillBufferWithSilence(dblBufHeader.dbhBufferPtr[1]);			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	return bufState.bufSizeInBytes;}int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex) {	OSErr				err;	SndDoubleBufferPtr	buffer;	int					bytesPerFrame, bufferBytes, i;	bytesPerFrame			= stereo ? 2 * BYTES_PER_SAMPLE : BYTES_PER_SAMPLE;	bufferBytes				= ((frameCount * bytesPerFrame) / 8) * 8;		/* Note: Must round bufferBytes down to an 8-byte boundary to avoid clicking!!!!!! */	if (bufState.open) {		/* still open from last time; clean up before continuing */		snd_Stop();	}	bufState.open			= false;  /* set to true if successful */	bufState.stereo			= stereo;	bufState.frameCount		= bufferBytes / bytesPerFrame;	bufState.sampleRate		= samplesPerSec;	bufState.lastFlipTime	= ioMicroMSecs();	bufState.playSemaIndex	= semaIndex;	bufState.bufSizeInBytes	= bufferBytes;	bufState.bufState0		= BUF_EMPTY;	bufState.bufState1		= BUF_EMPTY;	bufState.done			= false;	dblBufHeader.dbhNumChannels		= stereo ? 2 : 1;	dblBufHeader.dbhSampleSize		= BYTES_PER_SAMPLE * 8;	dblBufHeader.dbhCompressionID	= 0;	dblBufHeader.dbhPacketSize		= 0;	dblBufHeader.dbhSampleRate		= samplesPerSec << 16; /* convert to fixed point */#if TARGET_API_MAC_CARBON	dblBufHeader.dbhDoubleBack		= nil;#else	dblBufHeader.dbhDoubleBack		= NewSndDoubleBackProc(DoubleBack);#endif	chan = NULL;	err = SndNewChannel(&chan, sampledSynth, 0, NULL);	if (err !!= noErr) return false; /* could not open sound channel */	for (i = 0; i < 2; i++) {		buffer = (SndDoubleBufferPtr) NewPtrClear(sizeof(SndDoubleBuffer) + bufState.bufSizeInBytes);		if (buffer == NULL) {   /* could not allocate memory for a buffer; clean up and abort */			SndDisposeChannel(chan, true);#if !!TARGET_API_MAC_CARBON			DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);#endif			if (i == 1) {  /* free the first buffer */				DisposePtr((char *) dblBufHeader.dbhBufferPtr[1]);				dblBufHeader.dbhBufferPtr[1] = NULL;			}			return false;		}		buffer->dbNumFrames		= bufState.frameCount;		buffer->dbFlags			= dbBufferReady;		buffer->dbUserInfo[0]	= (long) &bufState;		buffer->dbUserInfo[1]	= i;		FillBufferWithSilence(buffer);		dblBufHeader.dbhBufferPtr[i] = buffer;	}#if TARGET_API_MAC_CARBON	err = CarbonSndPlayDoubleBuffer(chan, &dblBufHeader);#else	err = SndPlayDoubleBuffer(chan, &dblBufHeader);#endif	if (err !!= noErr) return false; /* could not play double buffer */	bufState.open = true;	return true;}int snd_Stop(void) {	OSErr				err;	SndDoubleBufferPtr	buffer;	SCStatus			status;	long				i, junk;	if (!!bufState.open) return;	bufState.open = false;	bufState.done = true;	while (true) {		err = SndChannelStatus(chan, sizeof(status), &status);		if (err !!= noErr) break; /* could not get channel status */		if (!!status.scChannelBusy) break;		Delay(1, (void *) &junk);	}	SndDisposeChannel(chan, true);#if !!TARGET_API_MAC_CARBON	DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);#endif	for (i = 0; i < 2; i++) {		buffer = dblBufHeader.dbhBufferPtr[i];		if (buffer !!= NULL) {			DisposePtr((char *) buffer);		}		dblBufHeader.dbhBufferPtr[i] = NULL;	}	bufState.open = false;}/*** exported sound input functions ***/int snd_SetRecordLevel(int level) {	/* set the recording level to a value between 0 (minimum gain) and 1000. */	Fixed inputGainArg;	int err;	if (!!recordingInProgress || (level < 0) || (level > 1000)) {		success(false);		return;  /* noop if not recording */	}	inputGainArg = ((500 + level) << 16) / 1000;  /* gain is Fixed between 0.5 and 1.5 */	err = SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	/* don''t fail on error; hardware may not support setting the gain */}int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex) {	/* turn on sound recording, trying to use a sampling rate close to	   the one specified. semaIndex is the index in the exportedObject	   array of a semaphore to be signalled when input data is available. */	Str255 deviceName = "";	short automaticGainControlArg;	Fixed inputGainArg;	long  compressionTypeArg;	short continuousArg;	short sampleSizeArg;	short channelCountArg;	UnsignedFixed sampleRateArg;	int err;	err = SPBOpenDevice(deviceName, siWritePermission, &soundInputRefNum);	if (err !!= noErr) {		success(false);		return;	}	/* try to initialize some optional parameters, but don''t fail if we can''t */	automaticGainControlArg = false;	SPBSetDeviceInfo(soundInputRefNum, siAGCOnOff, &automaticGainControlArg);	inputGainArg = 1 << 16;  /* 1.0 in Fixed */	SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	compressionTypeArg = ''NONE'';	SPBSetDeviceInfo(soundInputRefNum, siCompressionType, &compressionTypeArg);	continuousArg = true;	err = SPBSetDeviceInfo(soundInputRefNum, siContinuous, &continuousArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	sampleSizeArg = 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);	if (err !!= noErr) {		/* use 8-bit samples */		sampleSizeArg = 8;		err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);		if (err !!= noErr) {			success(false);			SPBCloseDevice(soundInputRefNum);			return;		}	}	channelCountArg = stereo ? 2 : 1;	err = SPBSetDeviceInfo(soundInputRefNum, siNumberChannels, &channelCountArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	/* try to set the client''s desired sample rate */	sampleRateArg = desiredSamplesPerSec << 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		/* if client''s rate fails, try the nearest common sampling rates in {11025, 22050, 44100} */		if (desiredSamplesPerSec <= 16538) {			sampleRateArg = 11025 << 16;		} else {			if (desiredSamplesPerSec <= 33075) {				sampleRateArg = 22050 << 16;			} else {				sampleRateArg = 44100 << 16;			}		}		/* even if following fails, recording can go on at the default sample rate */		SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	}	recordBuffer1.paramBlock.inRefNum = soundInputRefNum;	recordBuffer1.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.milliseconds = 0;	recordBuffer1.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.bufferPtr = recordBuffer1.samples;#if TARGET_API_MAC_CARBON	recordBuffer1.paramBlock.completionRoutine = NewSICompletionUPP(FlipRecordBuffers);#else	recordBuffer1.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);#endif	recordBuffer1.paramBlock.interruptRoutine = nil;	recordBuffer1.paramBlock.userLong = (long) &recordBuffer2;  /* pointer to other buffer */	recordBuffer1.paramBlock.error = noErr;	recordBuffer1.paramBlock.unused1 = 0;	recordBuffer1.stereo = stereo;	recordBuffer1.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer1.recordSemaIndex = semaIndex;	recordBuffer1.readIndex = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.inRefNum = soundInputRefNum;	recordBuffer2.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.milliseconds = 0;	recordBuffer2.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.bufferPtr = recordBuffer2.samples;#if TARGET_API_MAC_CARBON	recordBuffer2.paramBlock.completionRoutine = NewSICompletionUPP(FlipRecordBuffers);#else	recordBuffer2.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);#endif	recordBuffer2.paramBlock.interruptRoutine = nil;	recordBuffer2.paramBlock.userLong = (long) &recordBuffer1;  /* pointer to other buffer */	recordBuffer2.paramBlock.error = noErr;	recordBuffer2.paramBlock.unused1 = 0;	recordBuffer2.stereo = stereo;	recordBuffer2.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer2.recordSemaIndex = semaIndex;	recordBuffer2.readIndex = RECORD_BUFFER_SIZE;	err = SPBRecord(&recordBuffer1.paramBlock, true);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	recordingInProgress = true;}int snd_StopRecording(void) {	/* turn off sound recording */	int err;	if (!!recordingInProgress) return;  /* noop if not recording */	err = SPBStopRecording(soundInputRefNum);	if (err !!= noErr) success(false);	SPBCloseDevice(soundInputRefNum);#if TARGET_API_MAC_CARBON	DisposeSICompletionUPP(recordBuffer1.paramBlock.completionRoutine);#else	DisposeRoutineDescriptor(recordBuffer1.paramBlock.completionRoutine);#endif	recordBuffer1.paramBlock.completionRoutine = nil;#if TARGET_API_MAC_CARBON	DisposeSICompletionUPP(recordBuffer2.paramBlock.completionRoutine);#else	DisposeRoutineDescriptor(recordBuffer2.paramBlock.completionRoutine);#endif	recordBuffer2.paramBlock.completionRoutine = nil;	recordBuffer1.recordSemaIndex = 0;	recordBuffer2.recordSemaIndex = 0;	recordingInProgress = false;}double snd_GetRecordingSampleRate(void) {	/* return the actual recording rate; fail if not currently recording */	UnsignedFixed sampleRateArg;	int err;	if (!!recordingInProgress) {		success(false);		return 0.0;	}	err = SPBGetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		success(false);		return 0.0;	}	return  (double) ((sampleRateArg >> 16) & 0xFFFF) +			((double) (sampleRateArg & 0xFFFF) / 65536.0);}int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes) {	/* if data is available, copy as many sample slices as possible into the	   given buffer starting at the given slice index. do not write past the	   end of the buffer, which is buf + bufferSizeInBytes. return the number	   of slices (not bytes) copied. a slice is one 16-bit sample in mono	   or two 16-bit samples in stereo. */	int bytesPerSlice = (recordBuffer1.stereo ? 4 : 2);	char *nextBuf = (char *) buf + (startSliceIndex * bytesPerSlice);	char *bufEnd = (char *) buf + bufferSizeInBytes;	char *src, *srcEnd;	RecordBuffer recBuf = nil;	int bytesCopied;	if (!!recordingInProgress) {		success(false);		return 0;	}	/* select the buffer with unread samples, if any */	recBuf = nil;	if (recordBuffer1.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer1;	if (recordBuffer2.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer2;	if (recBuf == nil) return 0;  /* no samples available */	/* copy samples into the client''s buffer */	src = &recBuf->samples[0] + recBuf->readIndex;	srcEnd = &recBuf->samples[RECORD_BUFFER_SIZE];	if (recBuf->bytesPerSample == 1) {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			/* convert 8-bit sample to 16-bit sample */			*nextBuf++ = (*src++) - 128;  /* convert from [0-255] to [-128-127] */			*nextBuf++ = 0;  /* low-order byte is zero */		}	} else {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			*nextBuf++ = *src++;		}	}	recBuf->readIndex = src - &recBuf->samples[0];  /* update read index */	/* return the number of slices copied */	bytesCopied = (int) nextBuf - (buf + (startSliceIndex * bytesPerSlice));	return bytesCopied / bytesPerSlice;}//Nov 6th 2000void snd_Volume(double *left, double *right) {	double temp;	SndCommand cmd;    long   results;	OSErr  err;		*left = 1.0;	*right = 1.0;	cmd.cmd = getVolumeCmd;	cmd.param1 = 0;	cmd.param2 = (long) &results;	err = -1;	if (chan !!= null)	    err = SndDoImmediate(chan,&cmd);	    	if (err !!= noErr) {	   err = GetDefaultOutputVolume(&results);	}	if (err !!= noErr) 	    return;	temp  = (results & 0xFFFF);	*left = temp/256.0;		temp = (results >> 16);	*right = temp/256.0;}void snd_SetVolume(double left, double right) {	unsigned long tempLeft,tempRight;	SndCommand cmd;	OSErr  err;		tempLeft = left*256.0 + 0.5;	tempLeft = tempLeft & 0xFFFF;	tempRight = right*256.0 + 0.5;	tempRight= tempRight & 0xFFFF;	cmd.cmd = volumeCmd;	cmd.param1 = 0;	cmd.param2 = (tempRight << 16) | tempLeft;	err = -1;	if (chan !!= null)	    err= SndDoImmediate(chan,&cmd);	if (err !!= noErr) {	   err = SetDefaultOutputVolume(cmd.param2);	}}/*	File:		CarbonSndPlayDB.c		Description:Routines demonstrating how to create a function that works				much like the original SndPlayDoubleBuffer but is Carbon compatible				(which SndPlayDoubleBuffer isn''t).	Author:		MC	Copyright: 	© Copyright 1999-2000 Apple Computer, Inc. All rights reserved.		Disclaimer:	IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.				("Apple") in consideration of your agreement to the following terms, and your				use, installation, modification or redistribution of this Apple software				constitutes acceptance of these terms.  If you do not agree with these terms,				please do not use, install, modify or redistribute this Apple software.				In consideration of your agreement to abide by the following terms, and subject				to these terms, Apple grants you a personal, non-exclusive license, under AppleÕs				copyrights in this original Apple software (the "Apple Software"), to use,				reproduce, modify and redistribute the Apple Software, with or without				modifications, in source and/or binary forms; provided that if you redistribute				the Apple Software in its entirety and without modifications, you must retain				this notice and the following text and disclaimers in all such redistributions of				the Apple Software.  Neither the name, trademarks, service marks or logos of				Apple Computer, Inc. may be used to endorse or promote products derived from the				Apple Software without specific prior written permission from Apple.  Except as				expressly stated in this notice, no other rights or licenses, express or implied,				are granted by Apple herein, including but not limited to any patent rights that				may be infringed by your derivative works or by other works in which the Apple				Software may be incorporated.				The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO				WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED				WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR				PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN				COMBINATION WITH YOUR PRODUCTS.				IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR				CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE				GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)				ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION				OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT				(INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN				ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.					Change History (most recent first):*//* Requirements for using this shim code:	1) The sound channel''s queue must be empty before you call CarbonSndPlayDoubleBuffer	2) You cannot call MySndDoImmediate until CarbonSndPlayDoubleBuffer returns.  Be	   careful about calling MySndDoImmediate at interrupt time with a quietCmd.*//*Some code is commented out becuase knowing who calls it and how allows shortcutsKarl Goiser 14/01/01*/#if TARGET_API_MAC_CARBON#undef UNNECESSARY_FOR_SQUEAK#if UNNECESSARY_FOR_SQUEAKstatic	pascal	void	CarbonSndPlayDoubleBufferCleanUpProc (SndChannelPtr theChannel, SndCommand * theCallBackCmd);#endifstatic  pascal  void	CarbonSndPlayDoubleBufferCallBackProc (SndChannelPtr theChannel, SndCommand * theCallBackCmd);static			void	InsertSndDoCommand (SndChannelPtr chan, SndCommand * theCmd);static	pascal	void	NMResponseProc (NMRecPtr nmReqPtr);#define kBufSize					2048// Structsstruct PerChanInfo {	QElemPtr 						qLink;						/* next queue entry */	short 							qType;						/* queue type = 0 */	short							stopping;	#if DEBUG		OSType						magic;	#endif	SndCallBackUPP 					usersCallBack;	SndDoubleBufferHeaderPtr		theParams;	CmpSoundHeader					soundHeader;};typedef struct PerChanInfo			PerChanInfo;typedef struct PerChanInfo *		PerChanInfoPtr;// Globals	Boolean							gNMRecBusy;	NMRecPtr						gNMRecPtr;	QHdrPtr							gFreeList;	Ptr								gSilenceTwos;	Ptr								gSilenceOnes;static SndCallBackUPP				gCarbonSndPlayDoubleBufferCallBackUPP = nil;static SndCallBackUPP				gCarbonSndPlayDoubleBufferCleanUpUPP = nil;#if UNNECESSARY_FOR_SQUEAK// Remember this routine could be called at interrupt time, so don''t allocate or deallocate memory.OSErr	MySndDoImmediate (SndChannelPtr chan, SndCommand * cmd) {	PerChanInfoPtr					perChanInfoPtr;	// Is this being called on one of the sound channels we are manipulating?	// If so, we need to pull our callback out of the way so that the user''s commands run	if (gCarbonSndPlayDoubleBufferCallBackUPP == chan->callBack) {		if (quietCmd == cmd->cmd || flushCmd == cmd->cmd) {			// We know that our callBackCmd is the first item in the queue if this is our channel			perChanInfoPtr = (PerChanInfoPtr)(chan->queue[chan->qHead].param2);			#if DEBUG				if (perChanInfoPtr->magic !!= ''SANE'') DebugStr("\pBAD in MySndDoImmediate");			#endif			perChanInfoPtr->stopping = true;			Enqueue ((QElemPtr)perChanInfoPtr, gFreeList);			if (!! OTAtomicSetBit (&gNMRecBusy, 0)) {				NMInstall (gNMRecPtr);			}			chan->callBack = perChanInfoPtr->usersCallBack;		}	}	return (SndDoImmediate (chan, cmd));}#endif UNNECESSARY_FOR_SQUEAK// This must be called at task time.OSErr	CarbonSndPlayDoubleBuffer (SndChannelPtr chan, SndDoubleBufferHeaderPtr theParams) {	OSErr							err;	CompressionInfo					compInfo;	PerChanInfoPtr					perChanInfoPtr;	SndCommand						playCmd;	SndCommand						callBack;	if (nil == chan)		return badChannel;	if (nil == theParams)	return paramErr;	if (nil == gFreeList) {		// This can''t ever be disposed since we don''t know when we might need to use it (at interrupt time)		gFreeList = (QHdrPtr)NewPtrClear (sizeof (QHdr));		err = MemError ();		if (noErr !!= err) goto exit;	}	if (nil == gSilenceOnes) {		short		i;		// This can''t ever be disposed since we don''t know when we might need to use it (at interrupt time)		gSilenceOnes = NewPtr (kBufSize);		err = MemError ();		if (noErr !!= err) goto exit;		for (i = 0; i < kBufSize; i++)			*gSilenceOnes++ = (char)0x80;	}	if (nil == gSilenceTwos) {		// This can''t ever be disposed since we don''t know when we might need to use it (at interrupt time)		gSilenceTwos = NewPtrClear (kBufSize);		err = MemError ();		if (noErr !!= err) goto exit;	}	if (nil == gNMRecPtr) {		// This can''t ever be disposed since we don''t know when we might need to use it (at interrupt time)		gNMRecPtr = (NMRecPtr)NewPtr (sizeof (NMRec));		err = MemError ();		if (noErr !!= err) goto exit;		// Set up our NMProc info that will dispose of most (but not all) of our memory		gNMRecPtr->qLink = nil;		gNMRecPtr->qType = 8;		gNMRecPtr->nmFlags = 0;		gNMRecPtr->nmPrivate = 0;		gNMRecPtr->nmReserved = 0;		gNMRecPtr->nmMark = nil;		gNMRecPtr->nmIcon = nil;		gNMRecPtr->nmSound = nil;		gNMRecPtr->nmStr = nil;		gNMRecPtr->nmResp = NewNMUPP (NMResponseProc);		gNMRecPtr->nmRefCon = 0;	}	perChanInfoPtr = (PerChanInfoPtr)NewPtr (sizeof (PerChanInfo));	err = MemError ();	if (noErr !!= err) goto exit;	// Init basic per channel information	perChanInfoPtr->qLink = nil;	perChanInfoPtr->qType = 0;				// not used	perChanInfoPtr->stopping = 0;	#if DEBUG		perChanInfoPtr->magic = ''SANE'';	#endif		perChanInfoPtr->theParams = theParams;	// Have to remember the user''s callback function from the sound because	// we are going to overwrite it with our own callback function.	perChanInfoPtr->usersCallBack = chan->callBack;	// Set up the sound header for the bufferCmd that will be used to play	// the buffers passed in by the SndPlayDoubleBuffer call.	perChanInfoPtr->soundHeader.samplePtr = (Ptr)(theParams->dbhBufferPtr[0]->dbSoundData);	perChanInfoPtr->soundHeader.numChannels = theParams->dbhNumChannels;	perChanInfoPtr->soundHeader.sampleRate = theParams->dbhSampleRate;	perChanInfoPtr->soundHeader.loopStart = 0;	perChanInfoPtr->soundHeader.loopEnd = 0;	perChanInfoPtr->soundHeader.encode = cmpSH;	perChanInfoPtr->soundHeader.baseFrequency = kMiddleC;	perChanInfoPtr->soundHeader.numFrames = (unsigned long)theParams->dbhBufferPtr[0]->dbNumFrames;	//	perChanInfoPtr->soundHeader.AIFFSampleRate = 0;				// unused	perChanInfoPtr->soundHeader.markerChunk = nil;	perChanInfoPtr->soundHeader.futureUse2 = nil;	perChanInfoPtr->soundHeader.stateVars = nil;	perChanInfoPtr->soundHeader.leftOverSamples = nil;	perChanInfoPtr->soundHeader.compressionID = theParams->dbhCompressionID;	perChanInfoPtr->soundHeader.packetSize = (unsigned short)theParams->dbhPacketSize;	perChanInfoPtr->soundHeader.snthID = 0;	perChanInfoPtr->soundHeader.sampleSize = (unsigned short)theParams->dbhSampleSize;	perChanInfoPtr->soundHeader.sampleArea[0] = 0;	// Is the sound compressed?  If so, we need to treat theParams as a SndDoubleBufferHeader2Ptr.	if (0 !!= theParams->dbhCompressionID) {		// Sound is compressed		err = GetCompressionInfo (theParams->dbhCompressionID,								((SndDoubleBufferHeader2Ptr)theParams)->dbhFormat,								theParams->dbhNumChannels,								theParams->dbhSampleSize,								&compInfo);		if (noErr !!= err) goto exitDispose;		perChanInfoPtr->soundHeader.format = compInfo.format;	} else {		// Sound is not compressed		perChanInfoPtr->soundHeader.format = kSoundNotCompressed;	}	playCmd.cmd = bufferCmd;	playCmd.param1 = 0;							// unused	playCmd.param2 = (long)&perChanInfoPtr->soundHeader;	callBack.cmd = callBackCmd;	callBack.param1 = 0;						// which buffer to fill, 0 buffer, 1, 0, ...	callBack.param2 = (long)perChanInfoPtr;	// Install our callback function pointer straight into the sound channel structure	if (nil == gCarbonSndPlayDoubleBufferCallBackUPP) {		gCarbonSndPlayDoubleBufferCallBackUPP = NewSndCallBackUPP(CarbonSndPlayDoubleBufferCallBackProc);	}	chan->callBack = gCarbonSndPlayDoubleBufferCallBackUPP;#if UNNECESSARY_FOR_SQUEAK	if (gCarbonSndPlayDoubleBufferCleanUpUPP == nil) {			gCarbonSndPlayDoubleBufferCleanUpUPP = NewSndCallBackProc (CarbonSndPlayDoubleBufferCleanUpProc);	}#endif	err = SndDoCommand (chan, &playCmd, true);	if (noErr !!= err) goto exitDispose;	err = SndDoCommand (chan, &callBack, true);	if (noErr !!= err) goto exitDispose;exit:	return err;exitDispose:	if (nil !!= perChanInfoPtr)		DisposePtr ((Ptr)perChanInfoPtr);	goto exit;}#if UNNECESSARY_FOR_SQUEAKstatic pascal void	CarbonSndPlayDoubleBufferCleanUpProc(								SndChannelPtr theChannel, SndCommand * theCallBackCmd){	PerChanInfoPtr	perChanInfoPtr;	perChanInfoPtr = (PerChanInfoPtr)(theCallBackCmd->param2);	#if DEBUG		if (perChanInfoPtr->magic !!= ''SANE'') DebugStr("\pBAD in CarbonSndPlayDoubleBufferCleanUpProc");	#endif	// Put our per channel data on the free queue so we can clean up later	Enqueue ((QElemPtr)perChanInfoPtr, gFreeList);	// Have to install our Notification Manager routine so that we can clean up the gFreeList	if (!! OTAtomicSetBit (&gNMRecBusy, 0)) {		NMInstall (gNMRecPtr);	}	// Have to put the user''s callback proc back so they get called when the next buffer finishes	theChannel->callBack = perChanInfoPtr->usersCallBack;}#endifstatic pascal void	CarbonSndPlayDoubleBufferCallBackProc (SndChannelPtr theChannel, SndCommand * theCallBackCmd) {	SndDoubleBufferHeaderPtr		theParams;	SndDoubleBufferPtr				emptyBuf;	SndDoubleBufferPtr				nextBuf;	PerChanInfoPtr					perChanInfoPtr;	SndCommand						playCmd;	perChanInfoPtr = (PerChanInfoPtr)(theCallBackCmd->param2);	#if DEBUG		if (perChanInfoPtr->magic !!= ''SANE'') DebugStr("\pBAD in CarbonSndPlayDoubleBufferCallBackProc");	#endif	if (true == perChanInfoPtr->stopping) goto exit;	theParams = perChanInfoPtr->theParams;	// The buffer that just played and needs to be filled	emptyBuf = theParams->dbhBufferPtr[theCallBackCmd->param1];	// Clear the ready flag	emptyBuf->dbFlags ^= dbBufferReady;	// This is the buffer to play now	nextBuf = theParams->dbhBufferPtr[!!theCallBackCmd->param1];	// Check to see if it is ready, or if we have to wait a bit	if (nextBuf->dbFlags & dbBufferReady) {		perChanInfoPtr->soundHeader.numFrames = (unsigned long)nextBuf->dbNumFrames;		perChanInfoPtr->soundHeader.samplePtr = (Ptr)(nextBuf->dbSoundData);		// Flip the bit telling us which buffer is next		theCallBackCmd->param1 = !!theCallBackCmd->param1;		// If this isn''t the last buffer, call the user''s fill routine		if (!!(nextBuf->dbFlags & dbLastBuffer)) {				// Declare a function pointer to the user''s double back proc				void (*doubleBackProc)(SndChannel*, SndDoubleBuffer*);				// Call user''s double back proc				doubleBackProc = (void*)DoubleBack;				(*doubleBackProc) (theChannel, emptyBuf);		} else {			// Call our clean up proc when the last buffer finishes			theChannel->callBack = gCarbonSndPlayDoubleBufferCleanUpUPP;		}	} else {		// We have to wait for the buffer to become ready.		// The real SndPlayDoubleBuffer would play a short bit of silence waiting for		// the user to read the audio from disk, so that''s what we do here.		#if DEBUG			DebugStr ("\p buffer is not ready!!");		#endif		// Play a short section of silence so that we can check the ready flag again		if (theParams->dbhSampleSize == 8) {			perChanInfoPtr->soundHeader.numFrames = (UInt32)(kBufSize / theParams->dbhNumChannels);			perChanInfoPtr->soundHeader.samplePtr = gSilenceOnes;		} else {			perChanInfoPtr->soundHeader.numFrames = (UInt32)(kBufSize / (theParams->dbhNumChannels * (theParams->dbhSampleSize / 8)));			perChanInfoPtr->soundHeader.samplePtr = gSilenceTwos;		}	}	// Insert our callback command	InsertSndDoCommand (theChannel, theCallBackCmd);	// Play the next buffer	playCmd.cmd = bufferCmd;	playCmd.param1 = 0;	playCmd.param2 = (long)&(perChanInfoPtr->soundHeader);	InsertSndDoCommand (theChannel, &playCmd);exit:	return;}static void	InsertSndDoCommand (SndChannelPtr chan, SndCommand * newCmd) {	if (-1 == chan->qHead) {		chan->qHead = chan->qTail;	}	if (1 <= chan->qHead) {		chan->qHead--;	} else {		chan->qHead = chan->qTail;	}	chan->queue[chan->qHead] = *newCmd;}static pascal void NMResponseProc (NMRecPtr nmReqPtr) {	PerChanInfoPtr					perChanInfoPtr;	OSErr							err;	NMRemove (nmReqPtr);	gNMRecBusy = false;	do {		perChanInfoPtr = (PerChanInfoPtr)gFreeList->qHead;		if (nil !!= perChanInfoPtr) {			err = Dequeue ((QElemPtr)perChanInfoPtr, gFreeList);			if (noErr == err) {				DisposePtr ((Ptr)perChanInfoPtr);			}		}	} while (nil !!= perChanInfoPtr && noErr == err);}#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/16/2001 21:46'!macWindowFile	^ '#include "sq.h"#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#ifndef __MPW__#include <profiler.h>#endif#include <sound.h>#include <Math64.h>#ifndef __MPW__#include <cstddef>#endif#include <processes.h>#include <OpenTransport.h>#include <Threads.h>#include <DriverServices.h>#include <stddef.h>/*** Compilation Options:**	define PLUGIN		to compile code for Netscape or IE Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE//#define IHAVENOHEAD//Aug 7th 2000,JMM Added logic for interrupt driven dispatching//Sept 1st 2000, JMM fix problem with modifier information being passed back incorrectly.//Sept 1st 2000, JMM use floating point for time versus 64bit math (faster!!)//Sept 1st 2000, JMM watch mouse movement foreground only, ignore when squeak in background.//Sept 18th 2000, JMM fix to cmpSize //Sept 19th 2000, JMM Sept 1st fix to keyboard modifier info broke cmd shift//Sept 27 2000, JMM fix to documentPath//Nov 13 2000, JMM logic to read/write image from VM. //Nov 22 2000, JMM Bob Arning found a bug with the duplicate mouse event logic (we were altering the event then recording the altered value)//Nov 30 2000, JMM Use Open Transport clock versus upTime, solves some issues for jitter and it''s faster//Dec 5th 2000, JMM poll 60 times a second... do event polling via checkForInterrupts and drive semaphore//Dec 6th 2000, JMM added logic to interface with power manger (1997 was there but dropped..., back again for ibooks)//Jan 14th 2001, KG Did some carbon porting.//Feb 2nd 2001, JMM V3.0 added zoom window support, full path support//Feb 2nd 2001, JMM V3.04 do an open window dialog at startup time if no image file//Feb 14th 2001, JMM V3.06 don''t cache image read/writes#if TARGET_API_MAC_CARBON    #define EnableMenuItemCarbon(m1,v1)  EnableMenuItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableMenuItem(m1,v1);#else    #ifndef NewAEEventHandlerUPP    	#define NewAEEventHandlerUPP NewAEEventHandlerProc     #endif    #define EnableMenuItemCarbon(m1,v1)  EnableItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableItem(m1,v1);        inline Rect *GetPortBounds(CGrafPtr w,Rect *r) { *r = w->portRect; return &w->portRect;}          inline Rect *GetRegionBounds(RgnHandle region, Rect * bounds) { *bounds = (*region)->rgnBBox; return &(*region)->rgnBBox;}        inline BitMap *GetQDGlobalsScreenBits(BitMap *bm){*bm = qd.screenBits; return &qd.screenBits; }        inline BitMap * GetPortBitMapForCopyBits (CGrafPtr w) { return &((GrafPtr)w)->portBits;}        inline pascal long InvalWindowRect(WindowRef  window,  const Rect * bounds) {InvalRect (bounds);}#endif/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/* The following prototype is missing from the CW11 header files: */pascal void ExitToShell(void);/*** Variables -- Imported from Browser Plugin Module ***/#ifdef PLUGINextern int pluginArgCount;extern char *pluginArgName[100];extern char *pluginArgValue[100];#endif/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image file */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document file */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;OTTimeStamp     timeStart;Boolean         gTapPowerManager=false;Boolean         gDisablePowerManager=false;const long      gDisableIdleTickCount=60*10;long            gDisableIdleTickLimit=0;Boolean         gThreadManager=false;ThreadID        gSqueakThread = kNoThreadID;ThreadEntryUPP  gSqueakThreadUPP;Boolean         gAllowAccessToFilePlease=false;#ifdef __MPW__QDGlobals 		qd;#endif/*** Variables -- Event Recording ***/#define MAX_EVENT_BUFFER 1024int inputSemaphoreIndex = 0;/* if non-zero the event semaphore index */sqInputEvent eventBuffer[MAX_EVENT_BUFFER];int eventBufferGet = 0;int eventBufferPut = 0;/* declaration of the event message hook */typedef int (*eventMessageHook)(EventRecord* event);eventMessageHook messageHook = NULL;eventMessageHook postMessageHook = NULL;#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */int cachedButtonState = 0;	/* buffered mouse button and modifier state for							   last mouse click even if button has since gone up;							   this cache is kept until the next time ioGetButtonState()							   is called to avoid missing short clicks */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath);void MenuBarHide(void);void MenuBarRestore(void);int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID);int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short VolumeNumber,long directoryID);void SqueakTerminate();void ExitCleanup();int calculateStartLocationForImage();extern int dropInit(void);Boolean RunningOnCarbonX(void);void DoZoomWindow (EventRecord* theEvent, WindowPtr theWindow, short zoomDir, short hMax, short vMax);GDHandle getDominateDevice(WindowPtr theWindow,Rect *windRect);void getDominateGDeviceRect(GDHandle dominantGDevice,Rect *dGDRect,Boolean forgetMenuBar);int fetchFileInfo(CInfoPBRec *pb,int dirIndex,FSSpec *spec,unsigned char *name,Boolean doAlias,Boolean *isFolder);OSStatus GetApplicationDirectory(short *vRefNum, long *dirID);extern pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath);OSErr FSpLocationFromFullPath(short fullPathLength,									 const void *fullPath,									 FSSpec *spec);OSErr squeakFindImage(const FSSpecPtr defaultLocationfssPtr,FSSpecPtr documentFSSpec);int ioInitSecurity(void);/* event capture */sqInputEvent *nextEventPut(void);int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);int recordMouseEvent(EventRecord *theEvent, int theButtonState);int recordDragDropEvent(EventRecord *theEvent, int theButtonState, int numberOfItems, int dragType);int recordKeyboardEvent(EventRecord *theEvent, int keyType);int MouseModifierState(EventRecord *theEvent);WindowPtr getSTWindow(void);int setMessageHook(eventMessageHook theHook);int setPostMessageHook(eventMessageHook theHook);void PowerMgrCheck(void);static pascal void* squeakThread(void *threadParm);OSErr   createNewThread(); /*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);static pascal OSErr HandleOpenDocEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);static pascal OSErr HandlePrintDocEvent(const AEDescList *aevt, AEDescList *reply, long refCon);static pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerUPP(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerUPP(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerUPP(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */    int                 checkValueForEmbeddedImage;    OSErr               err;	Str32                name; 	/* record path to VM''s home folder */	short vRefNum;	long dirID;	// Get the Volume ref and Directory id of the Application''s directory.    err = GetApplicationDirectory(&vRefNum, &dirID);    if (err !!= noErr) return err;	// Convert that to a full path string.	PathToWorkingDir(vmPath, VMPATH_SIZE, vRefNum, dirID);	checkValueForEmbeddedImage = calculateStartLocationForImage();	if (checkValueForEmbeddedImage == 0) {	    /* use default image name in same directory as the VM */	    strcpy(shortImageName, "squeak.image");	    return noErr;	}	if (err !!= noErr) {		strcpy(shortImageName, "squeak.image");	    return noErr;	}		CopyPascalStringToC(name,shortImageName);	StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);    return noErr;}pascal OSErr HandleOpenDocEvent(const AEDescList *aevt, AEDescList *reply, long refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	FInfo		finderInformation;	char 		tempShortName[SHORTIMAGE_NAME_SIZE + 1];		short vRefNum;	long dirID;		reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */    err = GetApplicationDirectory(&vRefNum, &dirID);    if (err !!= noErr) return err;    	PathToWorkingDir(vmPath, VMPATH_SIZE, vRefNum, dirID);		/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) return errAEEventNotHandled;;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;		if (shortImageName[0] !!= 0) {#ifdef IHAVENOHEAD		/* get image name */		err = AEGetNthPtr(&fileList, 1, typeFSS,						  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);		if (err) goto done;				err = FSpGetFInfo(&fileSpec,&finderInformation);		if (err) goto done;					CopyPascalStringToC(fileSpec.name,tempShortName);		if (finderInformation.fdType == ''SOBJ'') {			StoreFullPathForLocalNameInto(tempShortName, documentName, DOCUMENT_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);		}#endif		goto done;	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;		err = FSpGetFInfo(&fileSpec,&finderInformation);	if (err) goto done;			CopyPascalStringToC(fileSpec.name,shortImageName);	if (!!(IsImageName(shortImageName) || finderInformation.fdType == ''STim'') || finderInformation.fdType == ''STch'') {		/* record the document name, but run the default image in VM directory */		if (finderInformation.fdType == ''SOBJ'')			StoreFullPathForLocalNameInto(shortImageName, documentName, DOCUMENT_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);	} else {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return noErr;  //Note under Carbon it sends us a Quit event, but we don''t process because image might not get saved?}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowRef		wp;	int				isDeskAccessory;	wp = FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = GetWindowKind(wp) < 0;	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableMenuItemCarbon(editMenu, 1);		EnableMenuItemCarbon(editMenu, 3);		EnableMenuItemCarbon(editMenu, 4);		EnableMenuItemCarbon(editMenu, 5);		EnableMenuItemCarbon(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableMenuItemCarbon(editMenu, 1);		DisableMenuItemCarbon(editMenu, 3);		DisableMenuItemCarbon(editMenu, 4);		DisableMenuItemCarbon(editMenu, 5);		DisableMenuItemCarbon(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	static EventRecord oldEvent;	int				ok;	Rect    bounds;	ok = WaitNextEvent(everyEvent, &theEvent,0,null);	if((messageHook) && (messageHook(&theEvent))) {        return ok;    }	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				if(postMessageHook) postMessageHook(&theEvent);				return false;			break;			case mouseUp:				if(inputSemaphoreIndex) {					recordMouseEvent(&theEvent,MouseModifierState(&theEvent));    				if(postMessageHook) postMessageHook(&theEvent);					return false;				}				recordModifierButtons(&theEvent);				if(postMessageHook) postMessageHook(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyDown);					break;				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;						case keyUp:				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyUp);				}			break;#ifndef IHAVENOHEAD			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				GetPortBounds(GetWindowPort(stWindow),&bounds);				InvalWindowRect(stWindow,&bounds);			break;#endif			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;						case osEvt: 				if (((theEvent.message>>24)& 0xFF) == suspendResumeMessage) {									//JMM July 4th 2000					//Fix for menu bar tabbing, thanks to Javier Diaz-Reinoso for pointing this out					//					if (fullScreenFlag) {						if ((theEvent.message & resumeFlag) == 0) {							MenuBarRestore();						}						else {							MenuBarHide();						}					}				}				break;		}	}	else {		if(inputSemaphoreIndex && windowActive && 		    !!((oldEvent.what == theEvent.what) &&  		    (oldEvent.message == theEvent.message) && 		    ((oldEvent.where.v == theEvent.where.v) && (oldEvent.where.h == theEvent.where.h)) && 		    (oldEvent.modifiers == theEvent.modifiers))) {    		oldEvent = theEvent; //JMM Nov 11th 2000 bug fix 			recordMouseEvent(&theEvent,MouseModifierState(&theEvent)); 		} 		else		 oldEvent = theEvent;	}	if(postMessageHook) postMessageHook(&theEvent); 	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);#if !!TARGET_API_MAC_CARBON			OpenDeskAcc(name);#endif 			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:#if !!TARGET_API_MAC_CARBON			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}#endif		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	static Rect		growLimits = { 20, 20, 10000, 10000 };	Rect        dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:#if !!TARGET_API_MAC_CARBON			SystemClick(theEvent, theWindow);#endif		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;#ifndef IHAVENOHEAD		case inDrag:			GetRegionBounds(GetGrayRgn(), &dragBounds);			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inZoomIn:		case inZoomOut:			if (theWindow == stWindow) {					DoZoomWindow(theEvent,stWindow, windowCode,10000, 10000);				}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				if(inputSemaphoreIndex) {					recordMouseEvent(theEvent,MouseModifierState(theEvent));					break;				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;#endif	}}#if TARGET_API_MAC_CARBONvoid InitMacintosh(void) {	FlushEvents(everyEvent, 0);	InitCursor();}void MenuBarHide(void) { 	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */    menuBarRegion = (RgnHandle) 1;    HideMenuBar();}void MenuBarRestore(void) {	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */    ShowMenuBar();    menuBarRegion = nil;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {}void FreeClipboard(void) {}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;       	clipSize = clipboardSize(); 	charsToMove = (count < clipSize) ? count : clipSize;    err = GetScrapFlavorData(scrap,kScrapFlavorTypeText,(long *) &charsToMove,(char *) byteArrayIndex + startIndex);    if (err !!= noErr) {         FreeClipboard();        return 0;           }	return charsToMove;}int clipboardSize(void) {	long count;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;           err = GetScrapFlavorSize (scrap, kScrapFlavorTypeText, &count); 	if (err !!= noErr) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ScrapRef scrap;	OSErr err;	err = ClearCurrentScrap();    err = GetCurrentScrap (&scrap);	err = PutScrapFlavor ( scrap, kScrapFlavorTypeText, kScrapFlavorMaskNone , count,  (const void *) (byteArrayIndex + startIndex));}#else void InitMacintosh(void) {#if TARGET_CPU_68K    long currentLimit;    currentLimit = (long) GetApplLimit();    SetApplLimit((char *) currentLimit-32*1024);#endif	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */  	WindowPtr win; 		if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	LMSetMBarHeight(menuBarHeight);		win = FrontWindow();	if (win) {		CalcVis(win);		CalcVisBehind(win,menuBarRegion);	}	HiliteMenu(0);	DisposeRgn(menuBarRegion);		menuBarRegion = nil;	DrawMenuBar();}/*** Clipboard Support (text only for now) ***/Handle			clipboardBuffer = nil;void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;    //JMM locking    HLock(clipboardBuffer); 	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}    HUnlock(clipboardBuffer); 	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}#endifvoid SetUpMenus(void) {	long decideOnQuitMenu;		InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();#if TARGET_API_MAC_CARBON    Gestalt( gestaltMenuMgrAttr, &decideOnQuitMenu);    if (!!(decideOnQuitMenu & gestaltMenuMgrAquaLayoutMask) || true)	        AppendMenu(fileMenu, "\pQuit");#else	AppendResMenu(appleMenu, ''DRVR'');    AppendMenu(fileMenu, "\pQuit");#endif 	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};#ifndef IHAVENOHEAD	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, zoomDocProc, (WindowPtr) -1L, false, 0);#endif}void SetWindowTitle(char *title) {    Str255 tempTitle;	CopyCStringToPascal(title,tempTitle);#ifndef IHAVENOHEAD	SetWTitle(stWindow, tempTitle);#endif}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int asciiChar, modifierBits, keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = modifierMap[(theEvent->modifiers >> 8) & 0x1F];	if ((modifierBits & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	keystate = (modifierBits << 8) | asciiChar;	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState = MouseModifierState(theEvent);	cachedButtonState = cachedButtonState | buttonState;}int MouseModifierState(EventRecord *theEvent) {	int stButtons;	stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {  /* is false if button is down */		stButtons = 4;		/* red button by default */		if ((theEvent->modifiers & optionKey) !!= 0) {			stButtons = 2;	/* yellow button if option down */		}		if ((theEvent->modifiers & cmdKey) !!= 0) {			stButtons = 1;	/* blue button if command down */		}	} 	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	return ((modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7));}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordMouseEvent(EventRecord *theEvent, int theButtonState) {	sqMouseEvent *evt;		evt = (sqMouseEvent*) nextEventPut();	/* first the basics */	evt->type = EventTypeMouse;	evt->timeStamp = ioMSecs(); 	GlobalToLocal((Point *) &theEvent->where);	evt->x = theEvent->where.h;	evt->y = theEvent->where.v;	/* then the buttons */	evt->buttons = theButtonState & 0x07;	/* then the modifiers */	evt->modifiers = theButtonState >> 3;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}int recordDragDropEvent(EventRecord *theEvent, int theButtonState, int numberOfItems, int dragType) {	sqDragDropFilesEvent *evt;		evt = (sqDragDropFilesEvent*) nextEventPut();	/* first the basics */	evt->type = EventTypeDragDropFiles;	evt->timeStamp = ioMSecs(); 	GlobalToLocal((Point *) &theEvent->where);	evt->x = theEvent->where.h;	evt->y = theEvent->where.v;	evt->numFiles = numberOfItems;	evt->dragType = dragType;		/* then the modifiers */	evt->modifiers = theButtonState >> 3;	/* clean up reserved */	evt->reserved1 = 0;//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}int recordKeyboardEvent(EventRecord *theEvent, int keyType) {	int stButtons = 0;	int asciiChar, modifierBits;	sqKeyboardEvent *evt, *extra;	evt = (sqKeyboardEvent*) nextEventPut();	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = MouseModifierState(theEvent); //Capture mouse/option states	if (((modifierBits >> 3) & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	/* first the basics */	evt->type = EventTypeKeyboard;	evt->timeStamp = ioMSecs();	/* now the key code */	/* press code must differentiate */	evt->charCode = (theEvent->message & keyCodeMask) >> 8;	evt->pressCode = keyType;	evt->modifiers = modifierBits >> 3;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;	/* generate extra character event */	if (keyType == EventKeyDown) {		extra = (sqKeyboardEvent*)nextEventPut();		*extra = *evt;		extra->charCode = asciiChar;		extra->pressCode = EventKeyChar;	}//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}static sqInputEvent *nextEventPut(void) {	sqInputEvent *evt;	evt = eventBuffer + eventBufferPut;	eventBufferPut = (eventBufferPut + 1) % MAX_EVENT_BUFFER;	if (eventBufferGet == eventBufferPut) {		/* buffer overflow; drop the last event */		eventBufferGet = (eventBufferGet + 1) % MAX_EVENT_BUFFER;	}	return evt;}int ioSetInputSemaphore(int semaIndex) {	inputSemaphoreIndex = semaIndex;	return 1;}int ioGetNextEvent(sqInputEvent *evt) {	if (eventBufferGet == eventBufferPut) {		if (gThreadManager)    		YieldToAnyThread();		else		    ioProcessEvents();	}	if (eventBufferGet == eventBufferPut) 		return false;	*evt = eventBuffer[eventBufferGet];	eventBufferGet = (eventBufferGet+1) % MAX_EVENT_BUFFER;	return true;}/*** Mac Specific External Primitive Support ***//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName) {	char pluginDirPath[1000];	CFragConnectionID libHandle;	Ptr mainAddr;	Str255 errorMsg,tempPluginName;	OSErr err;        	/* first, look in the "<Squeak VM directory>Plugins" directory for the library */	strcpy(pluginDirPath, vmPath);	#ifdef PLUGIN	strcat(pluginDirPath, ":Plugins");#else	strcat(pluginDirPath, "Plugins");#endif 	        libHandle = LoadLibViaPath(pluginName, pluginDirPath);	if (libHandle !!= nil) return (int) libHandle;#ifndef PLUGIN	/* second, look directly in Squeak VM directory for the library */	libHandle = LoadLibViaPath(pluginName, vmPath);	if (libHandle !!= nil) return (int) libHandle;        /* Lastly look for it as a shared import library */        CopyCStringToPascal(pluginName,tempPluginName);    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kLoadCFrag, &libHandle, &mainAddr, errorMsg);	if (err == noErr) 	    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kFindCFrag, &libHandle, &mainAddr, errorMsg);	if (libHandle !!= nil) return (int) libHandle;#endif    	return nil;}/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle) {	CFragSymbolClass ignored;	Ptr functionPtr = 0;	OSErr err;    Str255 tempLookupName;    	if (!!moduleHandle) return 0;	/* get the address of the desired primitive function */	CopyCStringToPascal(lookupName,tempLookupName);	err = FindSymbol(		(CFragConnectionID) moduleHandle, (unsigned char *) tempLookupName,		&functionPtr, &ignored);	if (err) return 0;	return (int) functionPtr;}/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle) {	CFragConnectionID libHandle;	OSErr err;	if (!!moduleHandle) return 0;	libHandle = (CFragConnectionID) moduleHandle;	err = CloseConnection(&libHandle);	return 0;}CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath) {	short 				vRefNum;	long				ignore;	CInfoPBRec 			pb;	FSSpec				fileSpec;	Str255				problemLibName,fileSpecName,tempPlugindirPath;    Ptr					junk;	CFragConnectionID	libHandle = 0;	OSErr				err = noErr;	/* get the default volume */	HGetVol( nil, &vRefNum, &ignore);	/* get the directory ID for the given path */	CopyCStringToPascal(pluginDirPath,tempPlugindirPath);	pb.hFileInfo.ioNamePtr = tempPlugindirPath;	pb.hFileInfo.ioVRefNum = 0;  /* use the default volume */	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	err = PBGetCatInfoSync(&pb);	if (err) return nil; /* bad plugin directory path */	/* make a file spec for the given file name in the plugin directory */	CopyCStringToPascal(libName,fileSpecName);	FSMakeFSSpec(vRefNum,pb.hFileInfo.ioDirID,fileSpecName,&fileSpec);	err = GetDiskFragment(		&fileSpec, 0, kCFragGoesToEOF, nil, kLoadCFrag, &libHandle, &junk, problemLibName);	if (err) return nil;	return libHandle;}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}#ifndef PLUGINint ioExit(void) {	ioShutdownAllModules();	MenuBarRestore();	ExitToShell();}#endifint ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();	if ((cachedButtonState & 0x7) !!= 0) {		int result = cachedButtonState;		cachedButtonState = 0;  /* clear cached button state */		return result;	}	cachedButtonState = 0;  /* clear cached button state */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioHasDisplayDepth(int depth) {	/* Return true if this platform supports the given color display depth. */	switch (depth) {	case 1:	case 2:	case 4:	case 8:	case 16:	case 32:		return true;	}	return false;}int ioMicroMSecsExpensive(void);int ioMicroMSecsExpensive(void) {	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}#if TARGET_CPU_PPC#if TARGET_API_MAC_CARBONint ioMicroMSecs(void) { //Some versions of mac os/x return 0 when using OTElapsedMilliseconds	Nanoseconds elapsedNanoseconds;   // an UnsignedWide integer	if((Ptr)UpTime!!=(Ptr)kUnresolvedCFragSymbolAddress){		elapsedNanoseconds=AbsoluteToNanoseconds(UpTime());		// NOTE: 4294967296.0 == (double)0x10000*0x10000		return (4294967296.0*elapsedNanoseconds.hi+elapsedNanoseconds.lo)*1e-6;	}else {	    return ioMicroMSecsExpensive();	}}#elseint ioMicroMSecs(void) {	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. */		register long check;		if((Ptr)OTElapsedMilliseconds!!=(Ptr)kUnresolvedCFragSymbolAddress){    	check = OTElapsedMilliseconds(&timeStart);    	if (check !!= -1)     	    return check;    	OTGetTimeStamp(&timeStart);	    return ioMicroMSecs();	}else {	    return ioMicroMSecsExpensive();	}}#endif#elseint ioMicroMSecs(void) {    return ioMicroMSecsExpensive();}#endifint ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	return ioMicroMSecs();}int ioMousePoint(void) {	Point p;	if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	const int nextPollOffsetCheck = CLOCKS_PER_SEC/60, nextPowerCheckOffset=CLOCKS_PER_SEC/2; 	static clock_t nextPollTick = 0, nextPowerCheck=0;	long    clockTime;#ifndef PLUGIN	if (clock() >= nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		        clockTime = clock();                if (gDisablePowerManager && gTapPowerManager) {            if (clockTime > gDisableIdleTickLimit)                gDisableIdleTickLimit = IdleUpdate() + gDisableIdleTickCount;                #if TARGET_CPU_PPC            if (clockTime > nextPowerCheck) {                 UpdateSystemActivity(UsrActivity);                 nextPowerCheck = clockTime + nextPowerCheckOffset;            }#endif        }        		/* wait a while before trying again */		nextPollTick = clockTime + nextPollOffsetCheck;	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. 	 */       microSeconds;    if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();}int ioScreenDepth(void) {    Rect ignore;        GDHandle mainDevice = getDominateDevice(stWindow,&ignore);    if (mainDevice == null)         return 8;        return (*(*mainDevice)->gdPMap)->pixelSize;}#ifndef PLUGINint ioScreenSize(void) {	int w = 10, h = 10;    Rect portRect;    #ifndef IHAVENOHEAD	if (stWindow !!= nil) {        GetPortBounds(GetWindowPort(stWindow),&portRect);		w =  portRect.right -  portRect.left;		h =  portRect.bottom - portRect.top;	}#endif	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}#endifint ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag) {	/* Set the window to the given width, height, and color depth. Put the window	   into the full screen mode specified by fullscreenFlag. */	/* Note: Changing display depth is not yet, and may never be, implemented	   on the Macintosh, where (a) it is considered inappropriate and (b) it may	   not even be a well-defined operation if the Squeak window spans several	   displays (which display''s depth should be changed?). */	depth;#ifndef IHAVENOHEAD	ioSetFullScreen(fullscreenFlag);	if (!!fullscreenFlag) {		SizeWindow(stWindow, width, height, true);	}#endif}#ifndef PLUGINint ioSetFullScreen(int fullScreen) {	Rect                screen,portRect,windRect;	int                 width, height, maxWidth, maxHeight;	int                 oldWidth, oldHeight;    static Rect		    rememberOldLocation = {44,8,0,0};		    GDHandle            	dominantGDevice;    dominantGDevice = getDominateDevice(stWindow,&windRect);    getDominateGDeviceRect(dominantGDevice,&screen,true);    	if (fullScreen) {		rememberOldLocation = windRect;		if (dominantGDevice == GetMainDevice()) {		    rememberOldLocation.top += GetMBarHeight();		    rememberOldLocation.bottom += GetMBarHeight();		}		MenuBarHide();		GetPortBounds(GetWindowPort(stWindow),&portRect);		oldWidth =  portRect.right -  portRect.left;		oldHeight =  portRect.bottom -  portRect.top;		width  = screen.right - screen.left; 		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, screen.left, screen.top, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, rememberOldLocation.left, rememberOldLocation.top, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;    if (depth<=8) { /*Duane Maxwell <dmaxwell@exobox.com> fix cmpSize Sept 18,2000 */    	(*stPixMap)->cmpSize = depth;    	(*stPixMap)->cmpCount = 1;    } else if (depth==16) {    	(*stPixMap)->cmpSize = 5;    	(*stPixMap)->cmpCount = 3;    } else if (depth==32) {    	(*stPixMap)->cmpSize = 8;    	(*stPixMap)->cmpCount = 3;    }	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPortWindowPort(stWindow);	CopyBits((BitMap *) *stPixMap, GetPortBitMapForCopyBits(GetWindowPort(stWindow)), &srcRect, &dstRect, srcCopy, maskRect);#if TARGET_API_MAC_CARBON	QDFlushPortBuffer (GetWindowPort(stWindow), maskRect);#endif	DisposeRgn(maskRect);}#endif/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short volumeNumber,long directoryID) {	int offset, sz, i;	offset = PathToWorkingDir(fullName, length, volumeNumber, directoryID);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*****************************************************************************************GetApplicationDirectoryGet the volume reference number and directory id of this application.Code taken from Apple:	Technical Q&As: FL 14 - Finding your application''s directory (19-June-2000)Karl Goiser 14/01/01*****************************************************************************************/        /* GetApplicationDirectory returns the volume reference number        and directory ID for the current application''s directory. */    OSStatus GetApplicationDirectory(short *vRefNum, long *dirID) {        ProcessSerialNumber PSN;        ProcessInfoRec pinfo;        FSSpec pspec;        OSStatus err;            /* valid parameters */        if (vRefNum == NULL || dirID == NULL) return paramErr;            /* set up process serial number */        PSN.highLongOfPSN = 0;        PSN.lowLongOfPSN = kCurrentProcess;            /* set up info block */        pinfo.processInfoLength = sizeof(pinfo);        pinfo.processName = NULL;        pinfo.processAppSpec = &pspec;            /* grab the vrefnum and directory */        err = GetProcessInformation(&PSN, &pinfo);        if (err == noErr) {            *vRefNum = pspec.vRefNum;            *dirID = pspec.parID;        }        return err;    }/*** Initializing the path to Working Dir ***/int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID) {	/* Fill in the given string with the full path from a root volume to	   to current working directory. (At startup time, the working directory	   is set to the application''s directory. Fails if the given string is not	   long enough to hold the entire path. (Use at least 1000 characters to	   be safe.)	*/	short	fullPathLength;	Handle	fullPathHandle;	if (GetFullPath(volumeNumber, directoryID, nil, &fullPathLength, &fullPathHandle) !!= noErr) {		//Some sort of random guff for failure:		pathName[0] = 1;		pathName[1] = (char)":";		return 1;	}	strncpy((char *) pathName, (char *) *fullPathHandle, fullPathLength);	DisposeHandle(fullPathHandle);	return fullPathLength;}/*****************************************************************************/int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {	/* Insert the given prefix C string plus a delimitor character at the	   beginning of the given C string. Return the new pathName size. Fails	   if pathName is does not have sufficient space for the result.	   Assume: pathName is null terminated.	*/	int offset, i;	offset = strlen(prefix) + 1;	if ((pathNameSize + offset) > pathNameMax) {		return pathNameSize;	}	for (i = pathNameSize; i >= 0; i--) {		/* make room in pathName for prefix (moving string terminator, too) */		pathName[i + offset] = pathName[i];	}	for (i = 0; i < offset; i++) {		/* make room in pathName for prefix */		pathName[i] = prefix[i];	}	pathName[offset - 1] = '':'';  /* insert delimitor */	return pathNameSize + offset;}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	fullImagePath;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;#if TARGET_CPU_PPC	if((Ptr)OTGetTimeStamp!!=(Ptr)kUnresolvedCFragSymbolAddress) 	    OTGetTimeStamp(&timeStart);#endif	PowerMgrCheck();	SetUpClipboard();	SetUpPixmap();}int plugInShutdown(void) {	ioShutdownAllModules();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {	    DisposeThread(gSqueakThread,null,true);		DisposePtr((void *) memory);		memory = nil;	}}/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	/* Note: 1.3x images will try to read the image as a document because they	   expect attribute #1 to be the document name. A 1.3x image can be patched	   using a VM of 2.6 or earlier. */	if (id == 1) return imageName;	if (id == 2) return documentName;#ifdef PLUGIN	/* When running in browser, return the EMBED tag info */	if ((id > 2) && (id <= (2 + (2 * pluginArgCount)))) {		int i = id - 3;		if ((i & 1) == 0) {  /* i is even */			return pluginArgName[i/2];		} else {			return pluginArgValue[i/2];		}	}#endif	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	Str255 tempPascalFileName;     FInfo fileInfo;	CopyCStringToPascal(fileName,tempPascalFileName);	if (strchr(mode, ''w'') !!= null) 	    err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);	 else	    err = HOpenDF(0,0,tempPascalFileName,fsRdPerm, &fRefNum);	    	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = HCreate(0,0,tempPascalFileName,  ''FAST'', ''STim'');		if (err2 == 0) {			err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);		}	}	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {        err = HGetFInfo(0,0,tempPascalFileName,&fileInfo);        if (err !!= noErr) return 0; //This should not happen                //On the mac we start at location 0 if this isn''t an VM            	if (!!(fileInfo.fdType == ''APPL'' && fileInfo.fdCreator == ''FAST'')){    		/* truncate non-VM file if opening in write mode */    		err = SetEOF(fRefNum, 0);    		if (err !!= 0) {    			FSClose(fRefNum);    			return null;    		}	    }	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	ParamBlockRec pb;    OSErr error;	pb.ioParam.ioRefNum = f;    pb.ioParam.ioCompletion = NULL;    pb.ioParam.ioBuffer = (Ptr)ptr;    pb.ioParam.ioReqCount = byteCount;    pb.ioParam.ioPosMode = fsAtMark + noCacheMask;    pb.ioParam.ioPosOffset = 0;    error = PBReadSync(&pb);    byteCount = pb.ioParam.ioActCount;           	if (error !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	ParamBlockRec pb;    OSErr error;    pb.ioParam.ioRefNum = f;    pb.ioParam.ioCompletion = NULL;    pb.ioParam.ioBuffer = (Ptr)ptr;    pb.ioParam.ioReqCount = byteCount;    pb.ioParam.ioPosMode = fsAtMark + noCacheMask;    pb.ioParam.ioPosOffset = 0;    error = PBWriteSync(&pb);    byteCount = pb.ioParam.ioActCount;           	if (error !!= 0) 	    return 0;	return byteCount / elementSize;}int calculateStartLocationForImage() { 	Handle cfrgResource;  	long	memberCount,i;	CFragResourceMember *target;		cfrgResource = GetResource(kCFragResourceType,0); 	if (cfrgResource == nil || ResError() !!= noErr) { return 0;};  		memberCount = ((CFragResource *)(*cfrgResource))->memberCount;	if (memberCount <= 1) {        ReleaseResource(cfrgResource);	    return 0; //Need FAT to get counters right	}		target = &((CFragResource *)(*cfrgResource))->firstMember;	for(i=0;i<memberCount;i++) {		if (target->architecture == ''FAST'') {					    ReleaseResource(cfrgResource);		    return target->offset;		}		target = NextCFragResourceMemberPtr(target); 	}    ReleaseResource(cfrgResource);	return 0;}int sqImageFileStartLocation(int fileRef, char *filename, int imageSize){    FInfo fileInfo;	Str255 tempPascalFileName;	OSErr   err;     int     resFileRef;	Handle  cfrgResource,newcfrgResource;  	UInt32	maxOffset=0,maxOffsetLength,targetOffset;	long    memberCount,i;	CFragResourceMember *target;      	CopyCStringToPascal(filename,tempPascalFileName);    err = HGetFInfo(0,0,tempPascalFileName,&fileInfo);    if (err !!= noErr) return 0; //This should not happen        //On the mac we start at location 0 if this isn''t an VM    	if (!!(fileInfo.fdType == ''APPL'' && fileInfo.fdCreator == ''FAST'')) return 0;        //Ok we have an application file, open the resource part and attempt to find the crfg        resFileRef = HOpenResFile(0,0,tempPascalFileName,fsWrPerm);    if (resFileRef == -1) return 0;    	cfrgResource = GetResource(kCFragResourceType,0);	if (cfrgResource == nil || ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};  		memberCount = ((CFragResource *)(*cfrgResource))->memberCount;	if (memberCount <= 1) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;};  //Need FAT to get counters right		target = &((CFragResource *)(*cfrgResource))->firstMember;	for(i=0;i<memberCount;i++) {		if (target->architecture == ''FAST'') {		    targetOffset = target->offset;		    target->length = imageSize;		    ChangedResource(cfrgResource);        	if (ResError() !!= noErr) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 		    UpdateResFile(resFileRef);        	if (ResError() !!= noErr) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;};             ReleaseResource(cfrgResource); 		    CloseResFile(resFileRef);			return targetOffset;		}		if (target->offset > maxOffset) {			maxOffset = target->offset;			maxOffsetLength = target->length;		}		target = NextCFragResourceMemberPtr(target);	}		//Ok at this point we need to alter the crfg to add the new tag for the image part		newcfrgResource = cfrgResource;	err = HandToHand(&newcfrgResource);	if (err !!= noErr || MemError() !!= noErr)  {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 	SetHandleSize(newcfrgResource,GetHandleSize(cfrgResource)+AlignToFour(kBaseCFragResourceMemberSize + 1));	if (MemError() !!= noErr)  {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 		target = &((CFragResource *)(*newcfrgResource))->firstMember; 	for(i=0;i<memberCount;i++) {		target = NextCFragResourceMemberPtr(target); 	}    target->architecture = ''FAST'';    target->reservedA = 0;                  /* !! Must be zero!!*/    target->reservedB = 0;                  /* !! Must be zero!!*/    target->updateLevel = 0;    target->currentVersion = 0;    target->oldDefVersion = 0;    target->uUsage1.appStackSize = 0;    target->uUsage2.appSubdirID = 0;    target->uUsage2.libFlags = 0;    target->usage = kApplicationCFrag;    target->where = kDataForkCFragLocator;    target->offset = maxOffset + maxOffsetLength;    targetOffset = target->offset;    target->length = imageSize;    target->uWhere1.spaceID = 0;    target->extensionCount = 0;             /* The number of extensions beyond the name.*/    target->memberSize = AlignToFour(kBaseCFragResourceMemberSize + 1);   /* Size in bytes, includes all extensions.*/    target->name[0] = 0x00;	((CFragResource *)(*newcfrgResource))->memberCount = memberCount+1;	RemoveResource(cfrgResource);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};  	AddResource(newcfrgResource,kCFragResourceType,0,nil);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};     UpdateResFile(resFileRef);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};     CloseResFile(resFileRef);    	return targetOffset;}#ifndef PLUGINvoid * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {	/* Application allocates Squeak object heap memory from its own heap. */		minHeapSize;	return NewPtr(desiredHeapSize);;}#endifvoid PowerMgrCheck(void) {	long pmgrAttributes;		gTapPowerManager = false;	gDisablePowerManager = false;	if (!! Gestalt(gestaltPowerMgrAttr, &pmgrAttributes))		if ((pmgrAttributes & (1<<gestaltPMgrExists)) 		    && (pmgrAttributes & (1<<gestaltPMgrDispatchExists))		    && (PMSelectorCount() >= 0x24)) {		    gTapPowerManager = true;			gDisableIdleTickLimit = clock();		}}int ioDisablePowerManager(int disableIfNonZero) {    gDisablePowerManager = disableIfNonZero;}Boolean RunningOnCarbonX(void){    UInt32 response;        return (Gestalt(gestaltSystemVersion,                     (SInt32 *) &response) == noErr)                && (response >= 0x01000);}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	short vRefNum;	long dirID;	OSErr err;    long threadGestaltInfo;    	InitMacintosh();	PowerMgrCheck();		SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	dropInit();	SetEventMask(everyEvent); // also get key up events	#if TARGET_CPU_PPC	if((Ptr)OTGetTimeStamp!!=(Ptr)kUnresolvedCFragSymbolAddress) 	    OTGetTimeStamp(&timeStart);#endif 	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		err = GetApplicationDirectory(&vRefNum, &dirID);		if (err !!= noErr) error("Could not obtain default directory");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */#ifdef JITTER	reservedMemory = 1000000;#else	reservedMemory = 500000;#endif	if (RunningOnCarbonX())	    availableMemory = 100*1024*1024 - reservedMemory;	else     	availableMemory = MaxBlock() - reservedMemory;		/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeak to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 50K to that.)	    	    JMM Note changed to 500k for Open Transport support on 68K machines	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	while (f == NULL) {	    //Failure attempt to ask the user to find the image file	    	    FSSpec vmfsSpec,imageFsSpec;	    WDPBRec wdPB;	    	    err =  FSpLocationFromFullPath(vmPathSize(),vmPath,&vmfsSpec);	    if (err) 	        ioExit();		err = squeakFindImage(&vmfsSpec,&imageFsSpec);	    if (err) 	        ioExit();	    CopyPascalStringToC(imageFsSpec.name,shortImageName);        StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, imageFsSpec.vRefNum, imageFsSpec.parID);			/* make the image or document directory the working directory */    	wdPB.ioNamePtr = NULL;    	wdPB.ioVRefNum = imageFsSpec.vRefNum;    	wdPB.ioWDDirID = imageFsSpec.parID;    	PBHSetVolSync(&wdPB);    	f = sqImageFileOpen(imageName, "rb"); 	}		readImageFromFileHeapSizeStartingAt(f, availableMemory, calculateStartLocationForImage());	sqImageFileClose(f);    ioInitSecurity();    #ifndef IHAVENOHEAD	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);#endif#if (!!(defined JITTER) && defined(__MPW__))	atexit(SqueakTerminate);#endif#if TARGET_CPU_PPC    if( Gestalt( gestaltThreadMgrAttr, &threadGestaltInfo) == noErr &&        threadGestaltInfo & (1<<gestaltThreadMgrPresent) &&        ((Ptr) NewThread !!= (Ptr)kUnresolvedCFragSymbolAddress)) {        gThreadManager = true;        err = createNewThread();        if (err == noErr) {            while(true)  {                ioProcessEvents();        		YieldToAnyThread();            }            return;        }    }        #endif    gThreadManager = false;    /* run Squeak */    squeakThread(0);}#endifOSErr createNewThread() {#if TARGET_CPU_PPC    gSqueakThreadUPP = NewThreadEntryUPP(squeakThread); //We should dispose of someday#else    gSqueakThreadUPP = (ThreadEntryProcPtr) NewRoutineDescriptor((ProcPtr)(squeakThread), uppThreadEntryProcInfo, GetCurrentArchitecture()); #endif	return NewThread( kCooperativeThread, gSqueakThreadUPP, nil, 80*1024, kCreateIfNeeded, 0L, &gSqueakThread);}static pascal void* squeakThread(void *threadParm) {	/* run Squeak */#	ifdef JITTER	j_interpret();#	else	interpret();#	endif}void SqueakTerminate() {#ifdef PLUGIN	ExitCleanup();#else	ioShutdownAllModules();#endif}WindowPtr getSTWindow(void) {    return stWindow;}int setMessageHook(eventMessageHook theHook) {    messageHook = theHook;}int setPostMessageHook(eventMessageHook theHook) {    postMessageHook = theHook;}#if !!TARGET_API_MAC_CARBON////	CopyPascalStringToC converts the source pascal string to a destination//	C string as it copies. //void CopyPascalStringToC(ConstStr255Param src, char* dst){	if ( src !!= NULL )	{		short   length  = *src++;			while ( length > 0 ) 		{			*dst++ = *(char*)src++;			--length;		}	}	*dst = ''\0'';}////	CopyCStringToPascal converts the source C string to a destination//	pascal string as it copies. The dest string will//	be truncated to fit into an Str255 if necessary.//  If the C String pointer is NULL, the pascal string''s length is set to zero//void CopyCStringToPascal(const char* src, Str255 dst){	short 	length  = 0;		// handle case of overlapping strings	if ( (void*)src == (void*)dst )	{		unsigned char*		curdst = &dst[1];		unsigned char		thisChar;						thisChar = *(const unsigned char*)src++;		while ( thisChar !!= ''\0'' ) 		{			unsigned char	nextChar;						// use nextChar so we don''t overwrite what we are about to read			nextChar = *(const unsigned char*)src++;			*curdst++ = thisChar;			thisChar = nextChar;						if ( ++length >= 255 )				break;		}	}	else if ( src !!= NULL )	{		unsigned char*		curdst = &dst[1];		short 				overflow = 255;		// count down so test it loop is faster		register char		temp;			// Can''t do the K&R C thing of Òwhile (*s++ = *t++)Ó because it will copy trailing zero		// which might overrun pascal buffer.  Instead we use a temp variable.		while ( (temp = *src++) !!= 0 ) 		{			*(char*)curdst++ = temp;							if ( --overflow <= 0 )				break;		}		length = 255 - overflow;	}	dst[0] = length;}#endif#define rectWidth(aRect) ((aRect).right - (aRect).left)#define rectHeight(aRect) ((aRect).bottom - (aRect).top)#define MinWindowWidth(foo) 72*3#define MinWindowHeight(foo) 72*3#define max(X, Y) ( ((X)>(Y)) ? (X) : (Y) )#define min(X, Y) (  ((X)>(Y)) ? (Y) : (X) )#define pin(VALUE, MIN, MAX) ( ((VALUE) < (MIN)) ? (MIN) : ( ((VALUE) > (MAX)) ? (MAX) : (VALUE) ) )void DoZoomWindow (EventRecord* theEvent, WindowPtr theWindow, short zoomDir, short hMax, short vMax){	Rect				zoomRect,windRect,globalPortRect, dGDRect;	GDHandle			dominantGDevice;   	if (TrackBox(theWindow, theEvent->where, zoomDir)) {		SetPortWindowPort(theWindow);		GetPortBounds(GetWindowPort(stWindow),&windRect);		EraseRect(&windRect);	// recommended for cosmetic reasons		if (zoomDir == inZoomOut) {			/*			 *	ZoomWindow() is a good basic tool, but it doesn''t do everything necessary to			 *	implement a good human interface when zooming. In fact it''s not even close for			 *	more high-end hardware configurations. We must help it along by calculating an			 *	appropriate window size and location any time a window zooms out.			 */            dominantGDevice = getDominateDevice(theWindow,&windRect);			/*			 *	At this point, we know the dimensions of the window we''re zooming, and we know			 *	what screen we''re going to put it on. To be more specific, however, we need a			 *	rectangle which defines the maximum dimensions of the resized window''s contents.			 *	This rectangle accounts for the thickness of the window frame, the menu bar, and			 *	one or two pixels around the edges for cosmetic compatibility with ZoomWindow().			 */            getDominateGDeviceRect(dominantGDevice,&dGDRect,false);            			GetPortBounds(GetWindowPort(theWindow),&globalPortRect);			LocalToGlobal(&(((Point *) &(globalPortRect))[0]));		// calculate the window''s portRect			LocalToGlobal(&(((Point *) &(globalPortRect))[1]));		// in global coordinates			// account for the window frame and inset it a few pixels			dGDRect.left	+= 2 + globalPortRect.left - windRect.left;			dGDRect.top		+= 2 + globalPortRect.top - windRect.top;			dGDRect.right	-= 1 + windRect.right - globalPortRect.right;			dGDRect.bottom	-= 1 + windRect.bottom - globalPortRect.bottom;			/*			 *	Now we know exactly what our limits are, and since there are input parameters			 *	specifying the dimensions we''d like to see, we can move and resize the zoom			 *	state rectangle for the best possible results. We have three goals in this:			 *	1. Display the window entirely visible on a single device.			 *	2. Resize the window to best represent the dimensions of the document itself.			 *	3. Move the window as short a distance as possible to achieve #1 and #2.			 */			GetWindowStandardState(theWindow, &zoomRect);			/*			 *	Initially set the zoom rectangle to the size requested by the input parameters,			 *	although not smaller than a minimum size. We do this without moving the origin.			 */			zoomRect.right = (zoomRect.left = globalPortRect.left) +									max(hMax, MinWindowWidth(theWindow));			zoomRect.bottom = (zoomRect.top = globalPortRect.top) +									max(vMax, MinWindowHeight(theWindow));			// Shift the entire rectangle if necessary to bring its origin inside dGDRect.			OffsetRect(&zoomRect,						max(dGDRect.left - zoomRect.left, 0),						max(dGDRect.top - zoomRect.top, 0));			/*			 *	Shift the rectangle up and/or to the left if necessary to accomodate the view,			 *	and if it is possible to do so. The rectangle may not be moved such that its			 *	origin would fall outside of dGDRect.			 */			OffsetRect(&zoomRect,						-pin(zoomRect.right - dGDRect.right, 0, zoomRect.left - dGDRect.left),						-pin(zoomRect.bottom - dGDRect.bottom, 0, zoomRect.top - dGDRect.top));			// Clip expansion to dGDRect, in case view is larger than dGDRect.			zoomRect.right = min(zoomRect.right, dGDRect.right);			zoomRect.bottom = min(zoomRect.bottom, dGDRect.bottom);			SetWindowStandardState(theWindow, &zoomRect);		}		ZoomWindow(theWindow, zoomDir, false);		// all it needed was a brain transplant	}}GDHandle getDominateDevice( WindowPtr theWindow,Rect *windRect) {	GDHandle			nthDevice, dominantGDevice;	long				sectArea, greatestArea;    long                quickDrawAttributes;	Rect				theSect;    RgnHandle           windowRegion;    #if TARGET_API_MAC_CARBON			windowRegion = NewRgn();			GetWindowRegion(theWindow,kWindowStructureRgn,windowRegion);			GetRegionBounds(windowRegion,windRect);#else			*windRect = (**((WindowPeek) theWindow)->strucRgn).rgnBBox;#endif			dominantGDevice = nil;    	    if (!! Gestalt(gestaltQuickdrawFeatures, &quickDrawAttributes) &&     	        (quickDrawAttributes & (1<<gestaltHasColor))) {				/*				 *	Color QuickDraw implies the possibility of multiple monitors. This is where				 *	zooming becomes more interesting. One should zoom onto the monitor containing				 *	the greatest portion of the window. This requires walking the gDevice list.				 */				nthDevice = GetDeviceList();				greatestArea = 0;				while (nthDevice !!= nil) {					if (TestDeviceAttribute(nthDevice, screenDevice)) {						if (TestDeviceAttribute(nthDevice, screenActive)) {							SectRect(windRect, &(**nthDevice).gdRect, &theSect);							sectArea = (long) rectWidth(theSect) * (long) rectHeight(theSect);							if (sectArea > greatestArea) {								greatestArea = sectArea;		// save the greatest intersection								dominantGDevice = nthDevice;	// and which device it belongs to							}						}					}					nthDevice = GetNextDevice(nthDevice);				}			}    return dominantGDevice;}void getDominateGDeviceRect(GDHandle dominantGDevice,Rect *dGDRect,Boolean forgetMenuBar) {    BitMap              bmap;	if (dominantGDevice !!= nil) {			*dGDRect = (**dominantGDevice).gdRect;			if (dominantGDevice == GetMainDevice())		// account for menu bar on main device				if (!!forgetMenuBar) 				        dGDRect->top += GetMBarHeight();		}		else {			GetQDGlobalsScreenBits(&bmap);			*dGDRect = bmap.bounds;				// if no gDevice, use default monitor			if (!!forgetMenuBar)			    dGDRect->top += GetMBarHeight();		}}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/12/2001 16:20'!readmeFile	^ 'Building the Squeak Virtual MachineThe Macintosh virtual machine is built using the following source files:	sqMacAsyncFilePrims.c		-- Mac asynchronous file I/O	sqMacDirectory.c			-- Mac directory enumerations	sqMacDragDrop.c				-- Mac drag and drop	sqMacJoystickAndTablet.c 	-- Mac support for Wacom tablets and GravisMouseStickII joystick	sqMacNetwork.c				-- Mac networking primitives	sqMacSerialAndMIDIPort.c 	-- Mac serial and MIDI port primitives	sqMacSound.c				-- Mac audio output primitives	sqMacWindow.c				-- Mac window and event handling; main programIn addition to these files, a number of .h and .c files are generated when Squeakgenerates a new interpreter and when you dump the support files.The exact set of files depends on which sets of primitives and plugins are included.Don''t worry--the linker will tell you if you forget something.The platform specific files are sqMacXXX.c, totaling about  more than 2000 lines of codewhen this document was originally written. All other code is written to standardANSI libraries and should port easily to other C environments.The file sqMacMinimal.c can be used a porting guide. This ~1100 line file stubsout all non-essential support functions and, together with sqFilePrims.c, allowsone to build a functioning virtual machine that only lacks non-essential I/Ofunctions (including support for file directory enumeration, which is not reallyessential!!). The small size of this file demonstrates how little code is reallyneeded to get Squeak running on a new platform.Thanks to Ian Piumarta, the C header files are identical across all the majorSqueak platforms.The code assumes that C ints and pointers are 4 bytes and double floats are 8bytes; these assumptions are checked at start up time. Float objects in the imageare stored in the IEEE standard byte ordering for double-precision floats on allplatforms; macros in sq.h can be defined to swap bytes into and out of theplatform native float format if necessary. (To ensure proper word alignment, onetypically has to copy a Squeak Float object into a C "double" variable beforeoperating on it; byte swapping can be done while doing this copy for little or noadditional cost.)The files interp.c, sqSoundPrims.c, sqMiscPrims.c, and others are generatedautomatically, so changes to these files will be lost when they are nextgenerated. It is fine to make ephemeral changes to these file for the purpose ofdebugging or statistics gathering. To generate the interpreter, see the"translation" category in Interpreter class. For the other support files see InterpreterSupportCode class>>writeMacSourceFilesThe current VM was compiled with Metrowerks CodeWarrior Pro 5.3. Earlier versions of Squeak usedthe Symantec Think C 6.0, but there were a few bugs in their libraries having to dowith 8-byte versus 4-byte integers. These bugs have probably been fixed by now.This code has also been compiled under the MPW "Mr. C" Macintosh compiler byHans-Martin Mosner (hmm@heeg.de) with only one minor change: you will need tocreate an empty "MacHeaders.h" file. You may get some harmless compiler warningsand, for peak performance, the method that patches the dispatch loop must also bechanged. Hans-Martin says: "The whole VM seems to be marginally slower than thedelivered VM, but it is significantly smaller."Note that Jitter 3 (Squeak V3.x) has migrated to Gnu GCC, and MPW. As of late fall 2000there is no 68K version, but the macintosh specific source is the same with additional filesfor Jitter 3.To build using CW we have provided an XML exported CW project that should match the current one being used to build the production VM. The virtual machine uses the following libraries:	Libraries for 68K Project:		MathLibCFM68K (4i_F_8d).Lib		MSL MWCFM68KRuntime.Lib		MWCFM68KRuntime.Lib		InterfaceLib		QuickTimeLib		DragLib		NavigationLib		ThreadsLib				//Optional only to build OT version of 68K do not include in regularbuild		OpenTpt68kATalkLib		OpenTpt68kClientLib		OpenTpt68kInetLib		OpenTpt68kUtilLib	Libraries for PowerPC Project:		InterfaceLib		QuickTimeLib		DragLib		NavigationLib		ThreadsLib		MathLib		PowerMgrLib		MSL RuntimePPC.Lib		OpenTptInetPPC.o		OpenTptInternetLib		OpenTransportExtnPPC.o		OpenTransportLibThe 68K Mac networking code also requires three files from Apple''s MacTCPdeveloper''s kit:	MacTCP.h	AddressXlation.h	dnr.cFor convenience, these files are included.The shipping 68K version of Squeak uses the older MacTCP interface. You can alterthe sqMacNetwork.c file and compile your own 68K verion of Squeak that uses thenew Open Transport version, but the availability of the 68K version of OpenTransport V1.3 is limited to 68040 machines that run system 8.1. You can run thisconfiguration on a 68030 using system 7.5.x but Apple does not support thatconfiguration.To get an additional speedup, the object code for the bytecode dispatch loop ofthe PPC version can be patched using the method "patchInterp:" in Interpreterclass.Note: In order to support dynamically loaded primitives, we have switched tousing Code Fragement Manager model for the 68K VM. This has severalramifications:  1. You now need to use the CFM versions of the library files. The 68K projectfile has been updated accordingly.  2. You cannot run the 68K VM under the emulator on the PowerPC (Apple doesn''tsupport CFM apps under the 68K emulator).  3. You need to be sure that version 4.0 or later of "CFM-68K Runtime Enabler"is in the Extensions folder of the system folder on your 68K Mac. *** Warning:Older versions of "CFM-68K Runtime Enabler" had bugs that will probably preventSqueak from even starting!! ***.CarbonWe do not include a Carbon ready project at this time. Much of the work to make aCarbon application is done, however we are still missing a serialMidi plugin  andtablet support which is Carbon compliant. Building Named Primitive PluginsI''ve included a pair of sample projects for building Squeak primitive plugins. Pluginized VMSqueak 2.8 and higher introduces the "pluginized VM". To reduce complexity most of the plugins are linked iternally into the VM. That is because many of themstill access a few VM functions and variables directly, rather than callingthrough the interpreter proxy, which they must in order to run in an externalplugin. One can still override these builtin primitives with an external pluginand, of course, newly built plugins can be created as external or internalplugins.Building Squeak as a Browser PluginThe plugin works with versions 4.0 or later of either browser. However,the primitives that can be used to ask the browser to fetch a URL do not work inversions of IE earlier than 5.0. To build this, you will need a copy of the Netscape Plugin SDK, available forfree at Netscapes web site. The required support files are:	jri.h	jritypes.h	jri_md.h	npapi.h	npmac.cpp	npupp.hThe installation and use of Squeak as a browser plugin is somewhat beyond thescope of this readme file. The basic idea is that the Squeak image started by thebrowser lives in a pre-defined directory ("SystemFolder:Preferences:Squeak:Internet" by default) with predefined name (e.g.,"squeakPlugin.image"). The browser plugin can only read and write files within theInternet directory and directories contained within it. This is called Squeakfile system "sand box". The browser captures most of the command key combination,so you have to use the menus rather than your favorite Squeak command keyshortcuts. {Note that using the full screen option allows you to again use thecommand key combinations and has better performance characteristics.} The browseralso captures cmd-., so the interrupt key when running under the browser iscontrol-C. The most flexible way to invoke Squeak is through the HTML "EMBED"command. This allows arbitrary arguments to be made available to Squeak. The"memory" EMBED tag can be used to tell Squeak how much memory is required by agiven Squeaklet.To build a browser plugin VM, do the following:  1. translate a browser plugin version of the interpreter (usingInterpreter>translateForBrowserPlugin:).  2. edit the file sqMacWindow.c and uncomment the #define of "PLUGIN"  3. edit the file platform.exports and uncomment the #define of "PLUGIN"  4. build the plugin using the supplied browser plugin projectIf you build your own project file, note that IE requires that the main entrypoint be "main" rather than CW''s usual "__start". (Netscape doesn''t care, so ittook me a long time to figure out why it wasn''t working under IE!!) The suppliedproject produces a PPC-only plugin.	-- John Maloney, May 25, 2000,	-- Changes John M McIntosh Aug 2, 2000, Dec 1,2000, Feb 10th 2001'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 2/10/2001 00:27'!squeakConfigFile	^ '/* sqConfig.h -- platform identification and configuration */#if defined(__MWERKS__) && !!defined(macintosh)  && !!defined(BEOS_SQUEAK)  /* CodeWarrior 8 neglects to define "macintosh" */# define macintosh#endif#if defined(WIN32) || defined(_WIN32) || defined(Win32)  /* Some compilers use different win32 definitions.     Define WIN32 so we have only to check for one symbol. */# if !!defined(WIN32)#  define WIN32# endif#endif#if defined(macintosh)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define SQ_CONFIG_DONE#endif#if defined(ACORN)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define SQ_CONFIG_DONE#endif#if defined(WIN32)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# if defined(_M_IX86) || defined(X86)  /* x86 systems */#  define DOUBLE_WORD_ALIGNMENT#  define DOUBLE_WORD_ORDER  /* Note: We include a generic sqWin32.h to override some settings */#  include "sqWin32.h"#  define SQ_CONFIG_DONE# elif defined(_WIN32_WCE)#  include "sqWin32.h"#  define SQ_CONFIG_DONE# else#  error unsupported win32 processor type (alpha?!!)# endif#endif#if defined(BEOS_SQUEAK)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# include <ByteOrder.h># if B_HOST_IS_LENDIAN /* Intel, etc. */#  define JUMP_ALIGN_BYTE#  define DOUBLE_WORD_ALIGNMENT#  define DOUBLE_WORD_ORDER#  define HAS_LSB_FIRST#  define SQ_CONFIG_DONE# else  /* PPC, etc. */#  define HAS_MSB_FIRST#  define SQ_CONFIG_DONE# endif#endif/* This file has been superseded by autoconf for Unix variants. */#if defined(HAVE_CONFIG_H)# include "sqUnixConfig.h"# define SQ_CONFIG_DONE#endif#if !!defined(SQ_CONFIG_DONE)# error test for, and describe, your architecture here.#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/12/2001 21:59'!squeakFilePrimsFile	^ '#include "sq.h"#ifndef NO_STD_FILE_SUPPORT#include "FilePlugin.h"/***	The state of a file is kept in the following structure,	which is stored directly in a Squeak bytes object.	NOTE: The Squeak side is responsible for creating an	object with enough room to store sizeof(SQFile) bytes.	The session ID is used to detect stale file objects--	files that were still open when an image was written.	The file pointer of such files is meaningless.	Files are always opened in binary mode; Smalltalk code	does (or someday will do) line-end conversion if needed.	Writeable files are opened read/write. The stdio spec	requires that a positioning operation be done when	switching between reading and writing of a read/write	filestream. The lastOp field records whether the last	operation was a read or write operation, allowing this	positioning operation to be done automatically if needed.	typedef struct {		File	*file;		int		sessionID;		int		writable;		int		fileSize;		int		lastOp;  // 0 = uncommitted, 1 = read, 2 = write //	} SQFile;***//*** Constants ***/#define UNCOMMITTED	0#define READ_OP		1#define WRITE_OP	2#ifndef SEEK_SET#define SEEK_SET	0#define SEEK_CUR	1#define SEEK_END	2#endif/*** Variables ***/int thisSession = 0;extern struct VirtualMachine * interpreterProxy;int sqFileAtEnd(SQFile *f) {	/* Return true if the file''s read/write head is at the end of the file. */	if (!!sqFileValid(f)) return interpreterProxy->success(false);	return ftell(f->file) == f->fileSize;}int sqFileClose(SQFile *f) {	/* Close the given file. */	if (!!sqFileValid(f)) return interpreterProxy->success(false);	fclose(f->file);	f->file = NULL;	f->sessionID = 0;	f->writable = false;	f->fileSize = 0;	f->lastOp = UNCOMMITTED;}int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize) {	char cFileName[1000];	int i, err;	if (sqFileNameSize >= 1000) {		return interpreterProxy->success(false);	}	/* copy the file name into a null-terminated C string */	sqFilenameFromString(cFileName, sqFileNameIndex, sqFileNameSize);	err = remove(cFileName);	if (err) {		return interpreterProxy->success(false);	}}int sqFileGetPosition(SQFile *f) {	/* Return the current position of the file''s read/write head. */	int position;	if (!!sqFileValid(f)) return interpreterProxy->success(false);	position = ftell(f->file);	if (position < 0) return interpreterProxy->success(false);	return position;}int sqFileInit(void) {	/* Create a session ID that is unlikely to be repeated.	   Zero is never used for a valid session number.	   Should be called once at startup time.	*/	thisSession = clock() + time(NULL);	if (thisSession == 0) thisSession = 1;	/* don''t use 0 */	return 1;}int sqFileShutdown(void) {	return 1;}int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag) {	/* Opens the given file using the supplied sqFile structure	   to record its state. Fails with no side effects if f is	   already open. Files are always opened in binary mode;	   Squeak must take care of any line-end character mapping.	*/	char cFileName[1001];	int i;	/* don''t open an already open file */	if (sqFileValid(f)) return interpreterProxy->success(false);	/* copy the file name into a null-terminated C string */	if (sqFileNameSize > 1000) {		return interpreterProxy->success(false);	}	sqFilenameFromString(cFileName, sqFileNameIndex, sqFileNameSize);	if (writeFlag) {		/* First try to open an existing file read/write: */		f->file = fopen(cFileName, "r+b");		if (f->file == NULL) {			/* Previous call fails if file does not exist. In that case,			   try opening it in write mode to create a new, empty file.			*/			f->file = fopen(cFileName, "w+b");			if (f->file !!= NULL) {				/* set the type and creator of newly created Mac files */				dir_SetMacFileTypeAndCreator((char *)sqFileNameIndex, sqFileNameSize, "TEXT", "R*ch");				}		}		f->writable = true;	} else {		f->file = fopen(cFileName, "rb");		f->writable = false;	}	if (f->file == NULL) {		f->sessionID = 0;		f->fileSize = 0;		return interpreterProxy->success(false);	} else {		f->sessionID = thisSession;		/* compute and cache file size */		fseek(f->file, 0, SEEK_END);		f->fileSize = ftell(f->file);		fseek(f->file, 0, SEEK_SET);	}	f->lastOp = UNCOMMITTED;}int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Read count bytes from the given file into byteArray starting at	   startIndex. byteArray is the address of the first byte of a	   Squeak bytes object (e.g. String or ByteArray). startIndex	   is a zero-based index; that is a startIndex of 0 starts writing	   at the first byte of byteArray.	*/	char *dst;	int bytesRead;	if (!!sqFileValid(f)) return interpreterProxy->success(false);	if (f->writable && (f->lastOp == WRITE_OP)) fseek(f->file, 0, SEEK_CUR);  /* seek between writing and reading */	dst = (char *) (byteArrayIndex + startIndex);	bytesRead = fread(dst, 1, count, f->file);	f->lastOp = READ_OP;	return bytesRead;}int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize) {	char cOldName[1000], cNewName[1000];	int i, err;	if ((oldNameSize >= 1000) || (newNameSize >= 1000)) {		return interpreterProxy->success(false);	}	/* copy the file names into null-terminated C strings */	sqFilenameFromString(cOldName, oldNameIndex, oldNameSize);	sqFilenameFromString(cNewName, newNameIndex, newNameSize);	err = rename(cOldName, cNewName);	if (err) {		return interpreterProxy->success(false);	}}int sqFileSetPosition(SQFile *f, int position) {	/* Set the file''s read/write head to the given position. */	if (!!sqFileValid(f)) return interpreterProxy->success(false);	fseek(f->file, position, SEEK_SET);	f->lastOp = UNCOMMITTED;}int sqFileSize(SQFile *f) {	/* Return the length of the given file. */	if (!!sqFileValid(f)) return interpreterProxy->success(false);	return f->fileSize;}int sqFileFlush(SQFile *f) {	/* Return the length of the given file. */	if (!!sqFileValid(f)) return interpreterProxy->success(false);	fflush(f->file);	return 1;}int sqFileValid(SQFile *f) {	return (		(f !!= NULL) &&		(f->file !!= NULL) &&		(f->sessionID == thisSession));}int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Write count bytes to the given writable file starting at startIndex	   in the given byteArray. (See comment in sqFileReadIntoAt for interpretation	   of byteArray and startIndex).	*/	char *src;	int bytesWritten, position;	if (!!(sqFileValid(f) && f->writable)) return interpreterProxy->success(false);	if (f->lastOp == READ_OP) fseek(f->file, 0, SEEK_CUR);  /* seek between reading and writing */	src = (char *) (byteArrayIndex + startIndex);	bytesWritten = fwrite(src, 1, count, f->file);	position = ftell(f->file);	if (position > f->fileSize) {		f->fileSize = position;  /* update file size */	}	if (bytesWritten !!= count) {		interpreterProxy->success(false);	}	f->lastOp = WRITE_OP;	return bytesWritten;}#endif /* NO_STD_FILE_SUPPORT */'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/12/2001 21:58'!squeakHeaderFile	^'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#include "sqVirtualMachine.h"#define true 1#define false 0#define null 0  /* using "null" because nil is predefined in Think C *//* pluggable primitives macros *//* Note: All pluggable primitives are defined as	EXPORT(int) somePrimitive(void)   If the platform requires special declaration modifiers   the EXPORT macro can be redefined*/#define EXPORT(returnType) returnType/* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqImageFileStartLocation(fileRef, fileName, size)  0#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* platform-dependent memory size adjustment macro *//* Note: This macro can be redefined to allows platforms with a   fixed application memory partition (notably, the Macintosh)   to reserve extra C heap memory for special applications that need   it (e.g., for a 3D graphics library). Since most platforms can   extend their application memory partition at run time if needed,   this macro is defined as a noop here and redefined if necessary   in sqPlatformSpecific.h.*/#define reserveExtraCHeapBytes(origHeapSize, bytesToReserve) origHeapSize/* platform-dependent millisecond clock macros *//* Note: The Squeak VM uses three different clocks functions for   timing. The primary one, ioMSecs(), is used to implement Delay   and Time millisecondClockValue. The resolution of this clock   determines the resolution of these basic timing functions. For   doing real-time control of music and MIDI, a clock with resolution   down to one millisecond is preferred, but a coarser clock (say,   1/60th second) can be used in a pinch. The VM calls a different   clock function, ioLowResMSecs(), in order to detect long-running   primitives. This function must be inexpensive to call because when   a Delay is active it is polled twice per primitive call. On several   platforms (Mac, Win32), the high-resolution system clock used in   ioMSecs() would incur enough overhead in this case to slow down the   the VM significantly. Thus, a cheaper clock with low resolution is   used to implement ioLowResMSecs() on these platforms. Finally, the   function ioMicroMSecs() is used only to collect timing statistics   for the garbage collector and other VM facilities. (The function   name is meant to suggest that the function is based on a clock   with microsecond accuracy, even though the times it returns are   in units of milliseconds.) This clock must have enough precision to   provide accurate timings, and normally isn''t called frequently   enough to slow down the VM. Thus, it can use a more expensive clock   that ioMSecs(). By default, all three clock functions are defined   here as macros based on the standard C library function clock().   Any of these macros can be overridden in sqPlatformSpecific.h.*/int ioMSecs(void);int ioLowResMSecs(void);int ioMicroMSecs(void);#define ioMSecs()		((1000 * clock()) / CLOCKS_PER_SEC)#define ioLowResMSecs()	((1000 * clock()) / CLOCKS_PER_SEC)#define ioMicroMSecs()	((1000 * clock()) / CLOCKS_PER_SEC)/* filename copy/transform macro. An opportunity to transform the filenames for   platforms with strange needs, anda simple encapsulation for everyone else*/#define sqFilenameFromString(dst, src, num) \if (1) { \	int i; \	for (i = 0; i < num; i++) { \		dst[i] = *((char *) (src + i)); \	} \	dst[num] = 0;\}/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioScreenDepth(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);int ioHasDisplayDepth(int depth);int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag);/* Power Management */int ioDisablePowerManager(int disableIfNonZero);/* User input recording I:   In general, either set of input function can be supported,   depending on the platform. This (first) set is state based   and should be supported even on platforms that make use   of the newer event driven API to support older images    without event support.*/int ioGetButtonState(void);int ioGetKeystroke(void);int ioMousePoint(void);int ioPeekKeystroke(void);/* Note: In an event driven architecture, ioProcessEvents is obsolete.   It can be implemented as a no-op since the image will check for   events in regular intervals. */int ioProcessEvents(void);/* User input recording II:   The following functions and definition can be used on   platform supporting events directly.*//* types of events */#define EventTypeNone 0#define EventTypeMouse 1#define EventTypeKeyboard 2#define EventTypeDragDropFiles 3/* keypress state for keyboard events */#define EventKeyChar 0#define EventKeyDown 1#define EventKeyUp 2/* button definitions */#define RedButtonBit 4#define BlueButtonBit 2#define YellowButtonBit 1/* modifier definitions */#define ShiftKeyBit 1#define CtrlKeyBit 2#define OptionKeyBit 4#define CommandKeyBit 8/* generic input event definition */typedef struct sqInputEvent {	int type; /* type of event; either one of EventTypeXXX */	unsigned int timeStamp; /* time stamp */     /* the interpretation of the following fields depend on the type of the event */	int unused1;	int unused2;	int unused3;	int unused4;	int unused5;	int unused6;} sqInputEvent;/* mouse input event definition */typedef struct sqMouseEvent {	int type; /* EventTypeMouse */	unsigned int timeStamp; /* time stamp */	int x; /* mouse position x */	int y; /* mouse position y */	int buttons; /* combination of xxxButtonBit */	int modifiers; /* combination of xxxKeyBit */	int reserved1; /* reserved for future use */	int reserved2; /* reserved for future use */} sqMouseEvent;/* keyboard input event definition */typedef struct sqKeyboardEvent {	int type; /* EventTypeKeyboard */	unsigned int timeStamp; /* time stamp */	int charCode; /* character code in Mac Roman encoding */	int pressCode; /* press code; any of EventKeyXXX */	int modifiers; /* combination of xxxKeyBit */	int reserved1; /* reserved for future use */	int reserved2; /* reserved for future use */	int reserved3; /* reserved for future use */} sqKeyboardEvent;/* drop files event definition:   DragEnter - drag operation from OS entered Squeak window   DragMove  - drag operation from OS moved within Squeak window   DragLeave - drag operation from OS left Squeak window   DragDrop  - drag operation dropped contents onto Squeak.*/#define DragEnter 1#define DragMove  2#define DragLeave 3#define DragDrop  4typedef struct sqDragDropFilesEvent {	int type; /* EventTypeDropFiles */	unsigned int timeStamp; /* time stamp */	int dragType; /* one of the DragXXX constants */	int x; /* mouse position x */	int y; /* mouse position y */	int modifiers; /* combination of xxxKeyBit */	int numFiles; /* number of files in transaction */	int reserved1; /* reserved for future use */} sqDragDropFilesEvent;/* set an asynchronous input semaphore index for events */int ioSetInputSemaphore(int semaIndex);/* retrieve the next input event from the OS */int ioGetNextEvent(sqInputEvent *evt);/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* image security traps */int ioCanRenameImage(void);int ioCanWriteImage(void);int ioDisableImageWrite(void);#ifdef DISABLE_SECURITY# define ioCanRenameImage() 1# define ioCanWriteImage() 1# define ioDisableImageWrite() 1#endif/* save/restore *//* Read the image from the given file starting at the given image offset */int readImageFromFileHeapSizeStartingAt(sqImageFile f, int desiredHeapSize, int imageOffset);/* NOTE: The following is obsolete - it is only provided for compatibility */#define readImageFromFileHeapSize(f, s) readImageFromFileHeapSizeStartingAt(f,s,0)/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* browser plug-in support */void plugInForceTimeToReturn(void);int plugInInit(char *imageName);int plugInNotifyUser(char *msg);void plugInSetStartTime(void);int plugInShutdown(void);int plugInTimeToReturn(void);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/*** pluggable primitive support ***//* NOTE: The following functions are those implemented by sqNamedPrims.c */int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength,  int moduleNameIndex, int moduleNameLength);int ioUnloadModuleOfLength(int moduleNameIndex, int moduleNameLength);int ioLoadFunctionFrom(char *functionName, char *pluginName);int ioShutdownAllModules(void);int ioUnloadModule(char *);int ioUnloadModuleOfLength(int moduleNameIndex, int moduleNameLength);char *ioListBuiltinModule(int moduleIndex);char *ioListLoadedModule(int moduleIndex);/* The next two are FFI entries!! (implemented in sqNamedPrims.c as well) */int ioLoadModuleOfLength(int moduleNameIndex, int moduleNameLength);int ioLoadSymbolOfLengthFromModule(int functionNameIndex, int functionNameLength, int moduleHandle);/* The next three functions must be implemented by sqXYZExternalPrims.c *//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName);/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle);/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle);/* The Squeak version this interpreter was generated from */extern const char *interpreterVersion;'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 2/10/2001 00:28'!squeakPlatSpecFile	^ '/* sqPlatformSpecific.h -- Platform-specific prototypes and definitions *//* How to use this file:   This file is for general platform-specific macros and declarations.   Function prototypes that are unlikely to introduce name conflicts on   other platforms can be added directly. Macro re-definitions or conflicting   function prototypes can be wrapped in a #ifdefs. Alternatively, a customized   version of this file can be used on that platform. The goal is to keep all   the other header files generic across platforms. To override a definition or   macro from sq.h, you must first #undef it, then provide the new definition.*/#ifdef UNIX/* unix-specific prototypes and definitions */void aioPollForIO(int microSeconds, int extraFd);#define SQ_FORM_FILENAME	"squeak-form.ppm"/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs#undef ioLowResMSecs#endif /* UNIX */#ifdef macintosh// CARBON/*#ifdef TARGET_API_MAC_CARBON      #undef TARGET_API_MAC_CARBON    #define TARGET_API_MAC_CARBON 1#else    #define TARGET_API_MAC_CARBON 1#endif *//* replace the image file manipulation macros with functions */#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#undef sqImageFileStartLocation#undef sqAllocateMemorytypedef int sqImageFile;void        sqImageFileClose(sqImageFile f);sqImageFile sqImageFileOpen(char *fileName, char *mode);int         sqImageFilePosition(sqImageFile f);int         sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f);void        sqImageFileSeek(sqImageFile f, int pos);int         sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f);int         sqImageFileStartLocation(int fileRef, char *filename, int imageSize);void *						sqAllocateMemory(int minHeapSize, int desiredHeapSize);/* override reserveExtraCHeapBytes() macro to reduce Squeak object heap size on Mac */#undef reserveExtraCHeapBytes#define reserveExtraCHeapBytes(origHeapSize, bytesToReserve) (origHeapSize - bytesToReserve)/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs/* macro to return from interpret() loop in browser plugin VM */#define ReturnFromInterpret() return/* prototypes missing from CW11 headers */#include <textutils.h>void CopyPascalStringToC(ConstStr255Param src, char* dst);void CopyCStringToPascal(const char* src, Str255 dst);#endif /* macintosh */#ifdef ACORN/* acorn memory allocation */#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) platAllocateMemory(desiredHeapSize)#undef sqFilenameFromString#define sqFilenameFromString(dst, src, num) sqFilenameFromString(dst, src, num)/* string copying macro to compensate for bug in Acorn library code */#define copyNCharsFromTo(num, src, dst)\if(1) {int sqfni;\	char cc;\	for (sqfni = 0; sqfni < num; sqfni++) {\		dst[sqfni] = cc = *((char *) (src + sqfni));\		if ( cc == 0) break;\	}\	dst[num] = 0;\}/* undefine clock macros that are implemented as functions */#undef ioMicroMSecs#undef ioMSecs#define ioMSecs() (10* (int)os_read_monotonic_time())#undef ioLowResMSecs#define ioLowResMSecs() (ioMSecs())#endif /* ACORN */#ifdef WIN32/* Override necessary definitions */#undef putchar#include "sqWin32Alloc.h"#ifdef WIN32_FILE_SUPPORT#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#define sqImageFile unsigned longint sqImageFileClose(sqImageFile h);sqImageFile sqImageFileOpen(char *fileName, char *mode);int sqImageFilePosition(sqImageFile h);int sqImageFileRead(void *ptr, int sz, int count, sqImageFile h);int sqImageFileSeek(sqImageFile h, int pos);int sqImageFileWrite(void *ptr, int sz, int count, sqImageFile h);#endif /* WIN32_FILE_SUPPORT *//* pluggable primitive support */#if defined(_MSC_VER) || defined(__MINGW32__)#  undef EXPORT#  define EXPORT(returnType) __declspec( dllexport ) returnType#endif /* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioLowResMSecs#undef ioMicroMSecs/* Declare GetTickCount() in case <windows.h> is not included */#if !!defined(_WINDOWS_) && !!defined(_WIN32_WCE) && !!defined(_WINDOWS_H)__declspec(dllimport) unsigned long __stdcall GetTickCount(void);#endif#define ioLowResMSecs() GetTickCount()#endif /* WIN32 */#if defined(BEOS_SQUEAK) // BeOS supportvoid AsyncSignalSemaphoreWithIndex(int semaIndex); // external SYNCHRONIZED signaling of semaphoresvoid SignalSqSemaphores(); // signal semaphores signalled with/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs/* pluggable primitive support */# undef EXPORT# define EXPORT(returnType) __declspec( dllexport ) returnType#endif /* BeOS */    '! !!LargeIntegersPlugin methodsFor: 'C core util' stamp: 'yo 2/14/2001 11:56'!cBytesCopyFrom: pFrom to: pTo len: len 	""	| limit |	self returnTypeC: 'int'.	self var: #pFrom declareC: 'unsigned char * pFrom'.	self var: #pTo declareC: 'unsigned char * pTo'.	self var: #len declareC: 'int len'.	self var: #limit declareC: 'int limit'.	self cCode: '' inSmalltalk: [		(interpreterProxy isKindOf: InterpreterSimulator) ifTrue: [			"called from InterpreterSimulator"				limit _ len - 1.				0 to: limit do: [:i |					interpreterProxy byteAt: pTo + i						put: (interpreterProxy byteAt: pFrom + i)				].			^ 0		].	].		limit _ len - 1.	0 to: limit do: [:i | pTo at: i put: (pFrom at: i)].	^ 0! !!MIMEHeaderValue methodsFor: 'printing' stamp: 'ls 2/10/2001 12:37'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ': '.	aStream nextPutAll: self asHeaderValue! !!MIMEHeaderValue methodsFor: 'accessing' stamp: 'ls 2/10/2001 13:06'!parameterAt: aParameter put: value	parameters at: aParameter put: value! !!MIMEHeaderValue class methodsFor: 'instance creation' stamp: 'ls 2/10/2001 12:25'!fromString: aString 	| parts newValue parms separatorPos parmName parmValue |	parts _ ReadStream on: (aString findTokens: ';').	newValue _ self new mainValue: parts next.	parms _ Dictionary new.	parts do: 		[:e | 		separatorPos _ e findAnySubStr: '=' startingAt: 1. 		separatorPos <= e size			ifTrue: 				[parmName _ (e copyFrom: 1 to: separatorPos - 1) withBlanksTrimmed asLowercase.				parmValue _ (e copyFrom: separatorPos + 1 to: e size) withBlanksTrimmed withoutQuoting.				parms at: parmName put: parmValue]].	newValue parameters: parms.	^ newValue! !Not currently in use.  This once held a part of a miltipart MailMessage, but now those parts are themselves full MailMessages.!!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'mas 2/8/2001 11:36'!nextComment	| start nestLevel paren |	start _ pos.	pos _ pos + 1.	nestLevel _ 1.	[ nestLevel > 0 ] whileTrue: [		pos _ text indexOfAnyOf: CSParens startingAt: pos  ifAbsent: [ 0 ].		pos = 0 ifTrue: [ 			self error: 'unterminated comment.  ie, more (''s than )''s' ].		paren _ self nextChar.		paren = $( ifTrue: [ nestLevel _ nestLevel + 1 ] ifFalse: [ nestLevel _ nestLevel - 1 ]].	^ MailAddressToken type: #Comment		text: (text copyFrom: start to: pos - 1)! !I represent an Internet mail or news message.	text - the raw text of my message	body - the body of my message, as a MIMEDocument	fields - a dictionary mapping lowercased field names into MIMEHeaderValue's	parts - if I am a multipart message, then this is a cache of my parts!!MailMessage methodsFor: 'initialize-release' stamp: 'ls 2/10/2001 12:48'!body: newBody	"change the body"	body := newBody.	text := nil.! !!MailMessage methodsFor: 'initialize-release' stamp: 'ls 2/10/2001 13:18'!from: aString 	"Parse aString to initialize myself."	| parseStream contentType bodyText contentTransferEncoding |	text _ aString withoutTrailingBlanks, String cr.	parseStream _ ReadStream on: text.	contentType _ 'text/plain'.	contentTransferEncoding _ nil.	fields := Dictionary new.	self fieldsFrom: parseStream do: 		[:fName :fValue | 		(fName asLowercase) = 'content-type' ifTrue: [contentType _ (fValue copyUpTo: $;) asLowercase].		(fName asLowercase) = 'content-transfer-encoding' ifTrue: [contentTransferEncoding _ fValue asLowercase].		fields at: (fName asLowercase) put: (MIMEHeaderValue fromString: fValue)].	bodyText _ parseStream upToEnd.	contentTransferEncoding = 'base64'		ifTrue: 			[bodyText _ Base64MimeConverter mimeDecodeToChars: (ReadStream on: bodyText).			bodyText _ bodyText contents].	contentTransferEncoding = 'quoted-printable' ifTrue: [bodyText _ bodyText decodeQuotedPrintable].	body _ MIMEDocument contentType: contentType content: bodyText! !!MailMessage methodsFor: 'initialize-release' stamp: 'ls 2/10/2001 12:15'!initialize	"initialize as an empty message"	text _ String cr.	fields := Dictionary new.	body _ MIMEDocument contentType: 'text/plain' content: String cr! !!MailMessage methodsFor: 'initialize-release' stamp: 'ls 2/10/2001 13:35'!setField: fieldName to: aFieldValue	fields at: fieldName asLowercase put: aFieldValue.	text := nil.! !!MailMessage methodsFor: 'initialize-release' stamp: 'ls 2/10/2001 13:10'!setField: fieldName toString: fieldValue	^self setField: fieldName to: (MIMEHeaderValue fromString: fieldValue)! !!MailMessage methodsFor: 'access' stamp: 'ls 2/10/2001 15:49'!cc	^(fields at: 'cc' ifAbsent: [ ^'' ])  mainValue! !!MailMessage methodsFor: 'access' stamp: 'ls 2/10/2001 12:19'!date	"Answer a date string for this message."	^(Date fromSeconds: self time + (Date newDay: 1 year: 1980) asSeconds) 		printFormat: #(2 1 3 47 1 2)! !!MailMessage methodsFor: 'access' stamp: 'ls 2/10/2001 14:02'!from		^(fields at: 'from' ifAbsent: [ ^'' ]) mainValue! !!MailMessage methodsFor: 'access' stamp: 'ls 2/10/2001 14:03'!subject		^(fields at: 'subject' ifAbsent: [ ^'' ])  mainValue! !!MailMessage methodsFor: 'access' stamp: 'ls 2/10/2001 12:49'!text	"the full, unprocessed text of the message"	text ifNil: [ self regenerateText ].	^text! !!MailMessage methodsFor: 'access' stamp: 'ls 2/10/2001 14:02'!time	| dateField |	dateField := (fields at: 'date' ifAbsent: [ ^0 ]) mainValue.	^self timeFrom: dateField! !!MailMessage methodsFor: 'access' stamp: 'ls 2/10/2001 14:02'!to	^(fields at: 'to' ifAbsent: [ ^'' ])  mainValue! !!MailMessage methodsFor: 'parsing' stamp: 'mdr 2/11/2001 17:58'!reportField: aString to: aBlock	"Evaluate the given block with the field name a value in the given field. Do nothing if the field is malformed."	| s fieldName fieldValue |	(aString includes: $:) ifFalse: [^self].	s _ ReadStream on: aString.	fieldName _ (s upTo: $:) asLowercase.	"fieldname must be lowercase"	fieldValue _ s upToEnd withBlanksTrimmed.	fieldValue isEmpty ifFalse: [aBlock value: fieldName value: fieldValue].! !!MailMessage methodsFor: 'printing/formatting' stamp: 'RAA 2/16/2001 07:40'!fieldsAsMimeHeader	"return the entire header in proper MIME format"	self halt.		"This no longer appears to be used and since, as a result of recent changes, it references an undeclared variable <subject>, I have commented out the code to clean up the inspection of undeclared vars""---	| strm |	strm _ WriteStream on: (String new: 100).	self fields associationsDo: [:e | strm nextPutAll: e key;		 nextPutAll: ': ';		 nextPutAll: (e key = 'subject' ifTrue: [subject] ifFalse: [e value asHeaderValue]);		 cr]. 	^ strm contents---"! !!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 2/10/2001 13:54'!regenerateBodyFromParts	"regenerate the message body from the multiple parts"	| bodyText |	bodyText := String streamContents: [ :str |		str cr.		parts do: [ :part |			str				nextPutAll: '--';				nextPutAll: self attachmentSeparator;				cr;				nextPutAll: part text ].			str			cr;			nextPutAll: '--';			nextPutAll: self attachmentSeparator;			nextPutAll: '--';			cr ].	body := MIMEDocument contentType: 'multipart/mixed' content: bodyText.	text := nil.  "text needs to be reformatted"! !!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 2/10/2001 13:20'!regenerateText	"regenerate the full text from the body and headers"	| encodedBodyText |	text := String streamContents: [ :str |		"first put the header"		fields keysAndValuesDo: [ :fieldName :fieldValue |			str				nextPutAll: fieldName capitalized ;				nextPutAll: ': ';				nextPutAll: fieldValue asHeaderValue;				cr ].			"skip a line between header and body"		str cr.		"put the body, being sure to encode it according to the header"		encodedBodyText := body content.		self decoderClass ifNotNil: [			encodedBodyText := (self decoderClass mimeEncode: (ReadStream on: encodedBodyText)) upToEnd ].		str nextPutAll: encodedBodyText ].! !!MailMessage methodsFor: 'multipart' stamp: 'ls 2/10/2001 13:24'!addAttachmentFrom: aStream withName: aName	"add an attachment, encoding with base64.  aName is the option filename to encode"	| newPart |	self makeMultipart.	self parts.  "make sure parts have been parsed"	"create the attachment as a MailMessage"	newPart := MailMessage empty.	newPart setField: 'content-type' toString: 'application/octet-stream'.	newPart setField: 'content-transfer-encoding' toString: 'base64'.	aName ifNotNil: [		| dispositionField |		dispositionField := MIMEHeaderValue fromString: 'attachment'.		dispositionField parameterAt: 'filename' put: aName.		newPart setField: 'content-disposition' to: dispositionField ].	newPart body: (MIMEDocument contentType: 'application/octet-stream' content: aStream upToEnd).	"regenerate our text"	parts := parts copyWith: newPart.	self regenerateBodyFromParts.	text := nil.! !!MailMessage methodsFor: 'multipart' stamp: 'ls 2/10/2001 13:07'!attachmentSeparator	^(self fields at: 'content-type') parameters at: 'boundary' ! !!MailMessage methodsFor: 'multipart' stamp: 'ls 2/10/2001 13:07'!makeMultipart	"if I am not multipart already, then become a multipart message with one part"	| part multipartHeader |	body isMultipart ifTrue: [ ^self ].	"set up the new message part"	part := MailMessage empty.	part body: body.	fields at: 'content-type' ifPresent: [ :contentTypeField |		parts setField: 'content-type' to: contentTypeField ].	parts := Array with: part.	"fix up our header"	multipartHeader := MIMEHeaderValue fromString: 'multipart/mixed'.	multipartHeader parameterAt: 'boundary' put: self class generateSeparator .	fields at: 'content-type' put: multipartHeader.	fields at: 'mime-version' put: (MIMEHeaderValue fromString: '1.0').	fields removeKey: 'content-transfer-encoding' ifAbsent: [].	"regenerate everything"	self regenerateBodyFromParts.	text := nil.! !!MailMessage methodsFor: 'multipart' stamp: 'ls 2/10/2001 13:43'!parseParts	"private -- parse the parts of the message and put them in the parts ivar.  If this is not a multipart message, put #() into the ivar"	| parseStream currLine msgStream messages separator |	self body isMultipart ifFalse: [^ parts _ #()].	separator := '--', self attachmentSeparator.	parseStream _ ReadStream on: self bodyText.	currLine _ ''.	[currLine = separator]		whileFalse: [currLine _ parseStream nextLine].	separator _ currLine copy.	msgStream _ LimitingLineStreamWrapper on: parseStream delimiter: separator.	messages _ OrderedCollection new.	[parseStream atEnd]		whileFalse: 			[messages add: msgStream upToEnd.			msgStream skipThisLine].	parts _ messages collect: [:e | MailMessage from: e]! !!MailMessage methodsFor: 'multipart' stamp: 'ls 2/10/2001 16:36'!save	"save the part to a file"	| fileName file |	fileName _ self name				ifNil: ['attachment' , Utilities dateTimeSuffix].	(fileName includes: $.) ifFalse: [		self body isJpeg			ifTrue: [fileName _ fileName , '.jpg'].		self body isGif ifTrue: [fileName _ fileName, '.gif']. ].	fileName _ FillInTheBlank request: 'File name for save?' initialAnswer: fileName.	fileName isEmpty		ifTrue: [^ nil].	file _ FileStream newFileNamed: fileName.	file nextPutAll: self bodyText.	file close! !!MailMessage methodsFor: 'fields' stamp: 'ls 2/10/2001 13:47'!rewriteFields: aBlock append: appendBlock	"Rewrite header fields. The body is not modified.	Each field's key and value is reported to aBlock. The block's return value is the replacement for the entire header line. Nil means don't change the line, empty means delete it. After all fields are processed, evaluate appendBlock and append the result to the header."	| old new result appendString |	self halt: 'this method is out of date.  it needs to update body, at the very least.  do we really need this now that we have setField:to: and setField:toString: ?!!'.	old _ ReadStream on: text.	new _ WriteStream on: (String new: text size).	self fieldsFrom: old do: [ :fName :fValue |		result _ aBlock value: fName value: fValue.		result ifNil: [new nextPutAll: fName, ': ', fValue; cr]			ifNotNil: [result isEmpty				ifFalse: [new nextPutAll: result.					result last = Character cr ifFalse: [new cr]]]].	appendString _ appendBlock value.	appendString isEmptyOrNil ifFalse:		[new nextPutAll: appendString.		appendString last = Character cr ifFalse: [new cr]].	new cr. "End of header"	text _ new contents, old upToEnd.! !!MailMessage class methodsFor: 'instance creation' stamp: 'ls 2/10/2001 12:30'!empty	"return a message with no text and no header"	^super new initialize! !!MenuItemMorph methodsFor: 'events' stamp: 'sw 2/7/2001 00:03'!doButtonAction	"Called programattically, this should trigger the action for which the receiver is programmed"	self invokeWithEvent: nil! !!MenuItemMorph class methodsFor: 'class initialization' stamp: 'sw 2/7/2001 00:04'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #((button (			(command fire 'trigger any and all of this object''s button actions'))))! !!MenuMorph methodsFor: 'private' stamp: 'ar 2/10/2001 00:37'!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^self valueOfProperty: #morphicLayerNumber  ifAbsent: [		stayUp ifTrue:[100] ifFalse:[10]	]! !!MessageNode methodsFor: 'printing' stamp: 'RAA 2/15/2001 19:25'!macroPrinter	special > 0 ifTrue: [^MacroPrinters at: special].	^nil! !!MessageNode methodsFor: 'printing' stamp: 'RAA 2/16/2001 15:12'!printIfOn: aStream indent: level	aStream dialect = #SQ00 ifTrue:		["Convert to if-then-else"		(arguments last isJust: NodeNil) ifTrue:			[aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Test '].			self printParenReceiver: receiver on: aStream indent: level + 1.			^ self printKeywords: #Yes: arguments: (Array with: arguments first)						on: aStream indent: level prefix: true].		(arguments last isJust: NodeFalse) ifTrue:			[self printReceiver: receiver on: aStream indent: level.			^ self printKeywords: #and: arguments: (Array with: arguments first)						on: aStream indent: level].		(arguments first isJust: NodeNil) ifTrue:			[aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Test '].			self printParenReceiver: receiver on: aStream indent: level + 1.			^ self printKeywords: #No: arguments: (Array with: arguments last)						on: aStream indent: level prefix: true].		(arguments first isJust: NodeTrue) ifTrue:			[self printReceiver: receiver on: aStream indent: level.			^ self printKeywords: #or: arguments: (Array with: arguments last)						on: aStream indent: level].		aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Test '].		self printParenReceiver: receiver on: aStream indent: level + 1.		^ self printKeywords: #Yes:No: arguments: arguments						on: aStream indent: level prefix: true].	receiver ifNotNil: [		receiver printOn: aStream indent: level + 1 precedence: precedence.	].	(arguments last isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifTrue: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments last isJust: NodeFalse) ifTrue:		[^ self printKeywords: #and: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments first isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifFalse: arguments: (Array with: arguments last)					on: aStream indent: level].	(arguments first isJust: NodeTrue) ifTrue:		[^ self printKeywords: #or: arguments: (Array with: arguments last)					on: aStream indent: level].	self printKeywords: #ifTrue:ifFalse: arguments: arguments					on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'RAA 2/16/2001 15:12'!printOn: aStream indent: level	| leadingKeyword |"may not need this check anymore - may be fixed by the #receiver: change"	special ifNil: [^aStream nextPutAll: '** MessageNode with nil special **'].	(special > 0)		ifTrue: [self perform: self macroPrinter with: aStream with: level]		ifFalse: [selector key first = $:				ifTrue: [leadingKeyword _ selector key keywords first.						aStream nextPutAll: leadingKeyword; space.						self printReceiver: receiver on: aStream indent: level.						self printKeywords: (selector key allButFirst: leadingKeyword size + 1) arguments: arguments							on: aStream indent: level]				ifFalse: [(aStream dialect = #SQ00 and: [selector key == #do:])						ifTrue: ["Add prefix keyword"								aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Repeat '].								self printParenReceiver: receiver on: aStream indent: level + 1.								self printKeywords: selector key arguments: arguments									on: aStream indent: level prefix: true]						ifFalse: [self printReceiver: receiver on: aStream indent: level.								self printKeywords: selector key arguments: arguments									on: aStream indent: level]]]! !!MessageNode methodsFor: 'equation translation' stamp: 'RAA 2/14/2001 14:07'!receiver: val	"14 feb 2001 - removed return arrow"	receiver _ val! !!MessageNode methodsFor: 'tiles' stamp: 'RAA 2/15/2001 19:34'!asMorphicSyntaxIn: parent	^parent 		vanillaMessageNode: self 		receiver: receiver 		selector: selector 		arguments: arguments! !!MessageNode methodsFor: 'tiles' stamp: 'RAA 2/14/2001 22:26'!morphFromKeywords: key arguments: args on: parent indent: ignored	^parent		messageNode: self 		receiver: receiver 		selector: selector 		keywords: key 		arguments: args! !!MethodFinder methodsFor: 'find a constant' stamp: 'jla 2/4/2001 18:30'!constEquiv	| const subTest got jj |	"See if (data1 = C) or (data1 ~= C) is the answer"	"quick test"	((answers at: 1) class superclass == Boolean) ifFalse: [^ false].	2 to: answers size do: [:ii | 		((answers at: ii) class superclass == Boolean) ifFalse: [^ false]]..	const _ (thisData at: 1) at: 1.	got _ (subTest _ MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: ["try other polarity for ~~ "		(jj _ answers indexOf: (answers at: 1) not) > 0 ifTrue: [		const _ (thisData at: jj) at: 1.		got _ (subTest _ MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not]]. 	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!MethodNode methodsFor: 'tiles' stamp: 'RAA 2/16/2001 15:44'!asMorphicSyntaxIn: parent		^parent		methodNodeInner: self 		selectorOrFalse: selectorOrFalse 		precedence: precedence 		arguments: arguments 		temporaries: temporaries 		primitive: primitive 		block: block! !!MethodNode methodsFor: 'tiles' stamp: 'RAA 2/16/2001 15:39'!asMorphicSyntaxUsing: aClass		^aClass methodNodeOuter: self		! !!Model methodsFor: 'dependents' stamp: 'sw 2/6/2001 04:13'!containingWindow	"Answer the window that holds the receiver.  The dependents technique is odious and may not be airtight, if multiple windows have the same model."	^ self dependents detect:		[:d | ((d isKindOf: SystemWindow orOf: StandardSystemView) or: [d isKindOf: MVCWiWPasteUpMorph]) and: [d model == self]] ifNone: [nil]! !!Morph methodsFor: 'accessing' stamp: 'di 2/6/2001 14:02'!borderWidthForRounding	^ self borderWidth! !!Morph methodsFor: 'accessing' stamp: 'tk 2/15/2001 15:55'!color	^ color 	"has already been set to ((self valueOfProperty: #fillStyle) asColor)"! !!Morph methodsFor: 'accessing' stamp: 'tk 2/15/2001 15:55'!color: aColor	color = aColor ifFalse: [		self removeProperty: #fillStyle.		color _ aColor.		self changed].! !!Morph methodsFor: 'copying' stamp: 'tk 2/3/2001 14:29'!veryDeepFixupWith: deepCopier	"If some fields were weakly copied, fix new copy here."	"super veryDeepFixupWith: deepCopier.	Object has no fixups, so don't call it"	"If my owner is being duplicated too, then store his duplicate.	 If I am owned outside the duplicated tree, then I am no longer owned!!"	owner _ deepCopier references at: owner ifAbsent: [nil].! !!Morph methodsFor: 'copying' stamp: 'tk 2/3/2001 14:30'!veryDeepInner: deepCopier	"The inner loop, so it can be overridden when a field should not be traced."	"super veryDeepInner: deepCopier.	know Object has no inst vars"	bounds _ bounds clone.	"Points are shared with original"	"owner _ owner.	special, see veryDeepFixupWith:"	submorphs _ submorphs veryDeepCopyWith: deepCopier.		"each submorph's fixup will install me as the owner"	"fullBounds _ fullBounds.	fullBounds is shared with original!!"	color _ color veryDeepCopyWith: deepCopier.		"color, if simple, will return self. may be complex"	extension _ extension veryDeepCopyWith: deepCopier.		"extension is treated like any generic inst var"! !!Morph methodsFor: 'drawing' stamp: 'di 2/15/2001 14:51'!boundsWithinCorners	^ CornerRounder rectWithinCornersOf: self bounds! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 2/6/2001 22:12'!justGrabbedFrom: formerOwner	"The receiver was just grabbed from its former owner and is now attached to the hand. By default, we pass this message on if we're a renderer."	(self isRenderer and:[self hasSubmorphs]) 		ifTrue:[self firstSubmorph justGrabbedFrom: formerOwner].! !!Morph methodsFor: 'event handling' stamp: 'RAA 2/12/2001 15:26'!firstClickTimedOut: evt	"Useful for double-click candidates who want to know whether or not the click is a single or double. In this case, ignore the #click: and wait for either this or #doubleClick:"! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 2/12/2001 17:04'!step	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message.  The generic version dispatches control to the player, if any.  The nasty circumlocation about owner's transformation is necessitated by the flexing problem that the player remains in the properties dictionary both of the flex and the real morph.  In the current architecture, only the top renderer's pointer to the player should actually be honored for the purpose of firing."! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 2/12/2001 18:05'!stepAt: millisecondClockValue	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message.	The millisecondClockValue parameter gives the value of the millisecond clock at the moment of dispatch.	Default is to dispatch to the parameterless step method for the morph, but this protocol makes it possible for some morphs to do differing things depending on the clock value"	self player ifNotNilDo:[:p| p stepAt: millisecondClockValue].	self step! !!Morph methodsFor: 'e-toy support' stamp: 'sw 2/6/2001 04:21'!containingWindow	"Answer a window or window-with-mvc that contains the receiver"	^ self ownerThatIsA: SystemWindow orA: MVCWiWPasteUpMorph! !!Morph methodsFor: 'e-toy support' stamp: 'ar 2/7/2001 18:00'!enclosingEditor	"Return the next editor around the receiver"	| tested |	tested _ owner.	[tested == nil] whileFalse:[		tested isTileEditor ifTrue:[^tested].		tested _ tested owner].	^nil! !!Morph methodsFor: 'e-toy support' stamp: 'ar 2/7/2001 17:58'!isTileEditor	"No, I'm not"	^false! !!Morph methodsFor: 'e-toy support' stamp: 'ar 2/7/2001 17:59'!topEditor	"Return the top-most editor around the receiver"	| found tested |	tested _ self.	[tested == nil] whileFalse:[		tested isTileEditor ifTrue:[found _ tested].		tested _ tested owner].	^found! !!Morph methodsFor: 'e-toy support' stamp: 'RAA 2/5/2001 15:35'!wrappedInWindowWithTitle: aTitle	| aWindow w2 |	aWindow _ (SystemWindow labelled: aTitle) model: Model new.	aWindow addMorph: self frame: (0@0 extent: 1@1).	w2 _ aWindow borderWidth * 2.	w2 _ 3.		"oh, well"	aWindow extent: self fullBounds extent + (0 @ aWindow labelHeight) + (w2 @ w2).	^ aWindow! !!Morph methodsFor: 'button' stamp: 'sw 2/6/2001 23:09'!doButtonAction	"If the receiver has a button-action defined, do it now.  The default button action of any morph is, well, to do nothing.  Note that there are several ways -- too many ways -- for morphs to have button-like actions.  This one refers not to the #mouseUpCodeToRun feature, nor does it refer to the Player-scripting mechanism.  Instead it is intended for morph classes whose very nature is to be buttons -- this method provides glue so that arbitrary buttons on the UI can be 'fired' programatticaly from user scripts"! !!Morph methodsFor: 'button' stamp: 'sw 2/6/2001 23:22'!fire	"If the receiver has any kind of button-action defined, fire that action now.   Any morph can have special, personal mouseUpCodeToRun, and that will be triggered by this.  Additionally, some morphs have specific buttonness, and these get sent the #doButtonAction message to carry out their firing.  Finally, some morphs have mouse behaviors associated with one or more Player scripts.	For the present, we'll try out doing *all* the firings this object can do. "	self firedMouseUpCode.   	"This will run the mouseUpCodeToRun, if any"	self player ifNotNil:				[self player fireOnce].  "Run mouseDown and mouseUp scripts"	self doButtonAction			"Do my native button action, if any"! !!Morph methodsFor: 'button' stamp: 'sw 2/6/2001 22:41'!firedMouseUpCode	"If the user has special mouseUpCodeToRun, then fire it once right now and return true, else return false"	| evt |	(self world == nil or: [self mouseUpCodeOrNil == nil]) ifTrue: [^ false].	evt _ MouseEvent new setType: nil position: self center buttons: 0 hand: self world activeHand.	self programmedMouseUp: evt for: self.	^ true	! !!Morph methodsFor: 'debug and other' stamp: 'sw 2/6/2001 22:35'!mouseUpCodeOrNil	"If the receiver has a mouseUpCodeToRun, return it, else return nil"	^ self valueOfProperty: #mouseUpCodeToRun ifAbsent: [nil]! !!Morph methodsFor: 'WiW support' stamp: 'RAA 2/16/2001 13:57'!addMorphInFrontOfLayer: aMorph	| targetLayer layerHere |	targetLayer _ aMorph morphicLayerNumberWithin: self.	submorphs do: [ :each |		each == aMorph ifTrue: [^self].		layerHere _ each morphicLayerNumberWithin: self.		"the <= is the difference - it insures we go to the front of our layer"		targetLayer <= layerHere ifTrue: [			^self addMorph: aMorph inFrontOf: each		].	].	self addMorphBack: aMorph.! !!Morph methodsFor: 'WiW support' stamp: 'RAA 2/16/2001 13:54'!morphicLayerNumberWithin: anOwner	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^(owner isNil or: [owner isWorldMorph or: [anOwner == owner]]) ifTrue: [		self valueOfProperty: #morphicLayerNumber ifAbsent: [100]	] ifFalse: [		owner morphicLayerNumber	].	"leave lots of room for special things"! !!Morph class methodsFor: 'scripting' stamp: 'ar 2/17/2001 15:45'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #(		(#basic (			(slot x 'The x coordinate' number readWrite player getX player setX:)			(slot y  	'The y coordinate' number readWrite	player 	getY player setY:)			(slot heading  'Which direction the object is facing.  0 is straight up' number readWrite player getHeading player setHeading:)			(command forward: 'Moves the object forward in the direction it is heading' number)			(command turn: 'Change the heading of the object by the specified amount' number)			(command beep: 'Make the specified sound' sound)))		"note: if you change the thing below you also need to change #tileScriptCommands."		(#scripts (			(command emptyScript 'an empty script'))		)		(#'color & border' (			(slot color 'The color of the object' color readWrite player getColor  player  setColor:)			(slot colorUnder 'The color under the center of the object' color readOnly player getColorUnder unused  unused )			(slot luminanceUnder 'The luminance under the center of the object' number readOnly player getLuminanceUnder unused unused)			(slot saturationUnder 'The saturation under the center of the object' number readOnly player getSaturationUnder unused unused)			(slot brightnessUnder 'The brightness under the center of the object' number readOnly player getBrightnessUnder unused unused)			(slot borderColor 'The color of the object''s border' color readWrite player getBorderColor player  setBorderColor:)			(slot borderWidth 'The width of the object''s border' number readWrite player getBorderWidth player setBorderWidth:)			(slot roundedCorners 'Whether corners should be rounded' boolean readWrite player getRoundedCorners player setRoundedCorners:)))		(geometry (			(slot  scaleFactor 'The factor by which the object is magnified' number readWrite player getScaleFactor player setScaleFactor:)			(slot  left   'The left edge' number readWrite player getLeft  player  setLeft:)			(slot right  'The right edge' number readWrite player getRight  player  setRight:)			(slot  top  'The top edge' number readWrite player getTop  player  setTop:) 			(slot  bottom  'The bottom edge' number readWrite player getBottom  player  setBottom:) 			(slot  width  'The width' number readWrite player getWidth  player  setWidth:)			(slot  height  'The height' number readWrite player getHeight  player  setHeight:) 			(slot x   'The x coordinate' number readWrite player  getX   player setX:)			(slot y   'The y coordinate' number readWrite player  getY  player setY:)			(slot heading  'Which direction the object is facing.  0 is straight up' number readWrite player getHeading  player setHeading:)))		(miscellaneous (			(command doMenuItem: 'do the menu item' menu)			(command show 'make the object visible')			(command hide 'make the objhect invisible')			(command wearCostumeOf: 'wear the costume of...' player)			(command startScript: 'start the given script ticking' string)			(command stopScript: 'make the given script be "normal"' string)			(command pauseScript: 'make the given script be "paused"' string)			(command tellAllSiblings: 'send a message to all siblings' string)			(command fire 'trigger any and all of this object''s button actions')			(slot copy 'returns a copy of this object' player readOnly player getNewClone	 unused unused)			(slot elementNumber 'my index in my container' number readWrite player getIndexInOwner player setIndexInOwner:)))		(motion (			(slot x 'The x coordinate' number readWrite player getX player setX:)			(slot y  	'The y coordinate' number readWrite	player 	getY player setY:)			(slot heading  'Which direction the object is facing.  0 is straight up' number readWrite player getHeading player setHeading:)			(command forward: 'Moves the object forward in the direction it is heading' number)			(slot obtrudes 'whether the object sticks out over its container''s edge' boolean readOnly player getObtrudes unused unused) 			(command moveToward: 'move toward the given object' player) 			(command turn: 'Change the heading of the object by the specified amount' number)			(command bounce: 'bounce off the edge if hit' sound) 			(command wrap 'wrap off the edge if appropriate') 			(command followPath 'follow the yellow brick road') 			(command goToRightOf: 'place this object to the right of another' player)))		(#'pen use' (			(slot penColor 'the color of ink used by the pen' color readWrite player getPenColor player setPenColor:) 			(slot penSize 'the width of the pen' number readWrite player getPenSize player setPenSize:) 			(slot penDown 'whether the pen is currently down' boolean readWrite player getPenDown player setPenDown:)			(command clearPenTrails 'clear all pen trails in the current playfield')))		(#tests (			(slot isOverColor 'whether any part of the object is over the given color' boolean	readOnly player seesColor: unused unused) 			(slot isUnderMouse 'whether the object is under the current mouse position' boolean readOnly	player getIsUnderMouse unused unused)			(slot colorSees	'whether the given color sees the given color' boolean readOnly	player color:sees:	unused	unused)			(slot touchesA	'whether I touch something that looks like...' boolean readOnly player touchesA:	unused	unused)			(slot obtrudes 'whether the object sticks out over its container''s edge' boolean readOnly player getObtrudes unused unused))))! !!Morph class methodsFor: 'scripting' stamp: 'ar 2/17/2001 15:46'!helpContributions	"Answer a list of pairs of the form (<symbol> <help message> ) to contribute to the system help dictionary"	"NB: Many of the items here are not needed any more since they're specified as part of command definitions now.  Someone needs to take the time to go through the list and remove items no longer needed.  But who's got that kind of time?"	^ #(		(acceptScript:for:			'submit the contents of the given script editor as the code defining the given selector')		(actorState			'return the ActorState object for the receiver, creating it if necessary')		(addInstanceVariable			'start the interaction for adding a new instance variable to the receiver')		(addPlayerMenuItemsTo:hand:			'add player-specific menu items to the given menu, on behalf of the given hand.  At present, these are only commands relating to the turtle')		(addYesNoToHand			'Press here to tear off a  TEST/YES/NO unit which you can drop into your script')		(allScriptEditors			'answer a list off the extant ScriptEditors for the receiver')		(amount			'The amount of displacement')		(angle				'The angular displacement')		(anonymousScriptEditorFor:			'answer a new ScriptEditor object to serve as the place for scripting an anonymous (unnamed, unsaved) script for the receiver')		(append:			'add an object to this container')		(assignDecrGetter:setter:amt:			'evaluate the decrement variant of assignment')		(assignGetter:setter:amt:			'evaluate the vanilla variant of assignment')		(assignIncrGetter:setter:amt:			'evalute the increment version of assignment')		(assignMultGetter:setter:amt:			'evaluate the multiplicative version of assignment')		(assureEventHandlerRepresentsStatus			'make certain that the event handler associated with my current costume is set up to conform to my current script-status')		(assureExternalName			'If I do not currently have an external name assigned, get one now')		(assureUniClass			'make certain that I am a member a uniclass (i.e. a unique subclass); if I am not, create one now and become me into an instance of it')		(availableCostumeNames			'answer a list of strings representing the names of all costumes currently available for me')		(availableCostumesForArrows			'answer a list of actual, instantiated costumes for me, which can be cycled through as the user hits a next-costume or previous-costume button in a viewer')		(beep:			'make the specified sound')		(borderColor			'The color of the object''s border')		(borderWidth			'The width of the object''s border')		(bottom			'My bottom edge, measured downward from the top edge of the world')		(bounce:			'If object strayed beyond the boundaries of its container, make it reflect back into it, making the specified noise while doing so.')		(bounce			'If object strayed beyond the boundaries of its container, make it reflect back into it')		(chooseTrigger'When this script should run."normal" means "only when called"')		(clearTurtleTrails			'Clear all the pen trails in the interior.')		(color				'The object''s interior color')		(colorSees			'Whether a given color in the object is over another given color')		(colorUnder			'The color under the center of the object')		(copy			'Return a new object that is very much like this one')		(cursor				'The index of the chosen element')		(deleteCard			'Delete the current card.')		(dismiss			'Click here to dismiss me')		(doMenuItem:			'Do a menu item, the same way as if it were chosen manually')		(elementNumber			'My element number as seen by my owner')		(fire			'Run any and all button-firing scripts of this object')		(firstPage			'Go to first page of book')		(followPath				'Retrace the path the object has memorized, if any.')		(forward:			'Moves the object forward in the direction it is heading') 		(goto:			'Go to the specfied book page')		(goToNextCardInStack			'Go to the next card')		(goToPreviousCardInStack			'Go to the previous card.')		(goToRightOf:			'Align the object just to the right of any specified object.')		(heading			'Which direction the object is facing.  0 is straight up') 		(height				'The distance between the top and bottom edges of the object')		(hide			'Make the object so that it does not display and cannot handle input')		(initiatePainting				'Initiate painting of a new object in the standard playfield.')		(initiatePaintingIn:			'Initiate painting of a new object in the given place.')		(isOverColor			'Whether any part of this object is directly over the specified color')		(isUnderMouse			'Whether any part of this object is beneath the current mouse-cursor position')		(lastPage			'Go to the last page of the book.')		(left			'My left edge, measured from the left edge of the World')		(leftRight			'The horizontal displacement')		(liftAllPens			'Lift the pens on all the objects in my interior.')		(lowerAllPens			'Lower the pens on all the objects in my interior.')		(mouseX			'The x coordinate of the mouse pointer')		(mouseY			'The y coordinate of the mouse pointer')		(moveToward:			'Move in the direction of another object.')		(insertCard			'Create a new card.')		(nextPage			'Go to next page.')		(numberAtCursor			'The number held by the object at the chosen element')		(objectNameInHalo			'Object''s name -- To change: click here, edit, hit ENTER')		(obtrudes			'Whether any part of the object sticks out beyond its container''s borders')		(offerScriptorMenu			'Scriptee and script name.Press to get a menu')		(pauseScript:			'Make a running script become paused.')		(penDown			'Whether the object''s pen is down (true) or up (false)')		(penColor			'The color of the object''s pen')		(penSize				'The size of the object''s pen')		(clearPenTrails			'Clear all pen trails in the current playfield')		(playerSeeingColorPhrase			'The player who "sees" a given color')		(previousPage			'Go to previous page')		(show			'If object was hidden, make it show itself again.')		(startScript:			'Make a script start running.')		(stopScript:			'Make a script stop running.')		(top			'My top edge, measured downward from the top edge of the world')		(right			'My right edge, measured from the left edge of the world')		(roundUpStrays			'Bring all out-of-container subparts back into view.')		(scaleFactor			'The amount by which the object is scaled')		(stopScript:			'make the specified script stop running')		(tellAllSiblings:			'send a message to all of my sibling instances')		(try			'Run this command once.')		(tryMe			'Click here to run this script once; hold button down to run repeatedly')		(turn:							'Change the heading of the object by the specified amount')		(unhideHiddenObjects			'Unhide all hidden objects.')		(upDown			'The vertical displacement')		(userScript			'This is a script defined by you.')		(userSlot			'This is an instance variable defined by you.  Click here to change its type')		(valueAtCursor			'The chosen element')		(wearCostumeOf:			'Wear the same kind of costume as the other object')		(width				'The distance between the left and right edges of the object')		(wrap			'If object has strayed beond the boundaries of its container, make it reappear from the opposite edge.')		(x			'The x coordinate, measured from the left of the container')		(y			'The y-coordinate, measured upward from the bottom of the container')		)! !!MouseClickState methodsFor: 'initialize' stamp: 'RAA 2/12/2001 18:55'!handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| localEvt timedOut isDrag |	timedOut _ (evt timeStamp - firstClickTime) > dblClickTime.	localEvt _ evt transformedBy: (clickClient transformedFrom: aHand owner).	isDrag _ (localEvt cursorPoint - firstClickDown cursorPoint) r > dragThreshold.	clickState == #firstClickDown ifTrue: [		"Careful here - if we had a slow cycle we may have a timedOut mouseUp event"		(timedOut and:[localEvt isMouseUp not]) ifTrue:[			"timeout before #mouseUp -> keep waiting for drag if requested"			clickState _ #firstClickTimedOut.			dragSelector ifNil:[				clickClient firstClickTimedOut: firstClickDown.	"***"				aHand resetClickState.				clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown]].			^true].		localEvt isMouseUp ifTrue:[			(timedOut or:[dblClickSelector isNil]) ifTrue:[				clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].				aHand resetClickState.				^true].			"Otherwise transfer to #firstClickUp"			firstClickUp _ evt copy.			clickState _ #firstClickUp.			"If timedOut or the client's not interested in dbl clicks get outta here"			clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickUp].			aHand handleEvent: firstClickUp.			^false].		isDrag ifTrue:["drag start"			clickClient firstClickTimedOut: firstClickDown.	"***"			aHand resetClickState.			dragSelector == nil "If no drag selector send #click instead"				ifTrue:[clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown]]				ifFalse:[clickClient perform: dragSelector with: localEvt].			^true].		^false].	clickState == #firstClickTimedOut ifTrue:[		localEvt isMouseUp ifTrue:["neither drag nor double click"			clickClient firstClickTimedOut: firstClickDown.	"***"			aHand resetClickState.			clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].			^true].		isDrag ifTrue:["drag start"			clickClient firstClickTimedOut: firstClickDown.	"***"			aHand resetClickState.			dragSelector ifNotNil:[clickClient perform: dragSelector with: localEvt].			^true].		^false].	clickState = #firstClickUp ifTrue:[		(timedOut) ifTrue:[			"timed out after mouseUp - send #click: and mouseUp"			clickClient firstClickTimedOut: firstClickDown.	"***"			aHand resetClickState.			^true].		localEvt isMouseDown ifTrue:["double click"			aHand resetClickState.			dblClickSelector ifNotNil:[clickClient perform: dblClickSelector with: firstClickDown].			^false]].	^true! !!MovingEyeMorph methodsFor: 'as yet unclassified' stamp: 'yo 2/15/2001 15:59'!extent: aPoint	super extent: aPoint.	inner extent: (self extent * ((1.0@1.0)-IrisSize)) asIntegerPoint.	iris extent: (self extent * IrisSize) asIntegerPoint.	inner position: (self center - (inner extent // 2)) asIntegerPoint.! !!MovingEyeMorph methodsFor: 'as yet unclassified' stamp: 'yo 2/15/2001 15:58'!initialize	super initialize.	self color: Color black.	inner _ EllipseMorph new.	inner color: self color.	inner extent: (self extent * ((1.0@1.0)-IrisSize)) asIntegerPoint.	inner borderColor: self color.	inner borderWidth: 0.	iris _ EllipseMorph new.	iris color: Color white.	iris extent: (self extent * IrisSize) asIntegerPoint.	self addMorphCentered: inner.	inner addMorphCentered: iris.	self extent: 26@33.! !!MovingEyeMorph methodsFor: 'as yet unclassified' stamp: 'yo 2/15/2001 15:24'!irisPos: cp	| a b theta x y |	theta _ (cp - self center) theta.	a _ inner width // 2.	b _ inner height // 2.	x _ a * (theta cos).	y _ b * (theta sin).	iris position: ((x@y) asIntegerPoint) + self center - (iris extent // 2).! !!MovingEyeMorph methodsFor: 'as yet unclassified' stamp: 'di 2/18/2001 00:10'!step	| cp |	cp _ self globalPointToLocal: World primaryHand position.	(inner containsPoint: cp)		ifTrue: [iris position: (cp - (iris extent // 2))]		ifFalse: [self irisPos: cp].	self changed "cover up gribblies if embedded in Flash"! !!MovingEyeMorph methodsFor: 'as yet unclassified' stamp: 'yo 2/15/2001 15:38'!stepTime	^ 100.! !!MovingEyeMorph class methodsFor: 'as yet unclassified' stamp: 'yo 2/15/2001 16:04'!initialize"	MovingEyeMorph initialize"	IrisSize _ (0.42@0.50).! !A Paragraph represents text that has been laid out, or composed, in some container.	text 		A Text with encoded per-character emphasis.	textStyle	A TextStyle with font set, line height and horizontal alignment.	firstCharacterIndex    The starting index in text for this paragraph, allowing				composition of a long text into a number of containers.	container	A Rectangle or TextContainer that determines where text can go.	lines		An Array of TextLines comprising the final layout of the text				after it has been composed within its container.	positionWhenComposed   As its name implies.  Allows display at new locations				without the need to recompose the text.Lines are ordered vertically.  However, for a given y, there may be several lines in left to right order.  Lines must never be empty, even if text is empty.Notes on yet another hack - 5 Feb 2001We really need to clean up #composeLinesFrom:to:delta:into:priorLines:atY:!!!!!!I added one more habdful of code to correct:This is an annoying bug that's been around for a couple of years, but I finally figured out how to duplicate the problem, so I figured I'd just report it now.  (It doesn't necessarily have to be fixed for 3.0 if it looks messy, but if it's a simple fix, it would be worth it.)In Morphic, if you have the following text in a workspace:This is line 1This is line 2**and** you have a return character after line 2, you will normally be able to click the mouse two times below line 2 in order to select all the text.  If you edit line 2 (e.g. so that it reads "line number 2"), you can still select all the text by clicking below the second line.  However, if you edit line 1, you will not be able to select all the text from the bottom in the same way.  Things get messed up such that the last return character seems to be gone.  In this state, if you position the cursor immediately after the 2, and press the right arrow, the cursor jumps to the beginning of line 2... oof. (report by Doug Way)While I don't have a very deep understanding of the above mentioned method, I was able to determine that text ending in a CR worked better in the editor when the last entry in <lines> had a start of text size + 1 and a stop of text size. I have accordingly added code near the end to ensure this. It seems to have fixed the problem, but we do need to clean this baby up some day. - Bob!]style[(830 38 127 1000 388)f1,f2cblue;,f1,f1cred;,f1!!NewParagraph methodsFor: 'composition' stamp: 'RAA 2/5/2001 17:01'!composeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines	atY: startingY	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| charIndex lineY lineHeight scanner line row firstLine lineHeightGuess saveCharIndex hitCR maybeSlide sliding bottom priorIndex priorLine oldLastLine |	charIndex _ start.	lines _ lineColl.	lineY _ startingY.	lineHeightGuess _ textStyle lineGrid.	maxRightX _ container left.	maybeSlide _ stop < text size and: [container isMemberOf: Rectangle].	sliding _ false.	priorIndex _ 1.	bottom _ container bottom.	scanner _ CompositionScanner new text: text textStyle: textStyle.	firstLine _ true.	[charIndex <= text size and: [(lineY + lineHeightGuess) <= bottom]]		whileTrue:		[sliding			ifTrue:			["Having detected the end of rippling recoposition, we are only sliding old lines"			priorIndex < priorLines size				ifTrue: ["Adjust and re-use previously composed line"						priorIndex _ priorIndex + 1.						priorLine _ (priorLines at: priorIndex)									slideIndexBy: delta andMoveTopTo: lineY.						lineColl addLast: priorLine.						lineY _ priorLine bottom.						charIndex _ priorLine last + 1]				ifFalse: ["There are no more priorLines to slide."						sliding _ maybeSlide _ false]]			ifFalse:			[lineHeight _ lineHeightGuess.			saveCharIndex _ charIndex.			hitCR _ false.			row _ container rectanglesAt: lineY height: lineHeight.			1 to: row size do:				[:i | (charIndex <= text size and: [hitCR not]) ifTrue:						[line _ scanner composeFrom: charIndex inRectangle: (row at: i)								firstLine: firstLine leftSide: i=1 rightSide: i=row size.					lines addLast: line.					(text at: line last) = Character cr ifTrue: [hitCR _ true].					lineHeight _ lineHeight max: line lineHeight.  "includes font changes"					charIndex _ line last + 1]].			row size >= 1 ifTrue:			[lineY _ lineY + lineHeight.			lineY > bottom				ifTrue: ["Oops -- the line is really too high to fit -- back out"						charIndex _ saveCharIndex.						row do: [:r | lines removeLast]]				ifFalse: ["It's OK -- the line still fits."						maxRightX _ maxRightX max: scanner rightX.						1 to: row size - 1 do:  "Adjust heights across row if necess"							[:i | (lines at: lines size - row size + i)									lineHeight: lines last lineHeight									baseline: lines last baseline].						charIndex > text size ifTrue:							["end of text"							hitCR ifTrue:								["If text ends with CR, add a null line at the end"								((lineY + lineHeightGuess) <= container bottom) ifTrue:									[row _ container rectanglesAt: lineY height: lineHeightGuess.									row size > 0 ifTrue:										[line _ (TextLine start: charIndex stop: charIndex-1											internalSpaces: 0 paddingWidth: 0)										rectangle: row first;										lineHeight: lineHeightGuess baseline: textStyle baseline.										lines addLast: line]]].							lines _ lines asArray.							^ maxRightX].						firstLine _ false]]				ifFalse:				[lineY _ lineY + lineHeight].			(maybeSlide and: [charIndex > stop]) ifTrue:				["Check whether we are now in sync with previously composed lines"				 [priorIndex < priorLines size					and: [(priorLines at: priorIndex) first < (charIndex - delta)]]						whileTrue: [priorIndex _ priorIndex + 1].				(priorLines at: priorIndex) first = (charIndex - delta)					ifTrue: ["Yes -- next line will have same start as prior line."							priorIndex _ priorIndex - 1.							maybeSlide _ false.							sliding _ true]					ifFalse: [priorIndex = priorLines size ifTrue:								["Weve reached the end of priorLines,								so no use to keep looking for lines to slide."								maybeSlide _ false]]]]].	firstLine ifTrue: ["No space in container or empty text"		line _ (TextLine start: start stop: start-1						internalSpaces: 0 paddingWidth: 0)				rectangle: (container topLeft extent: 0@lineHeightGuess);				lineHeight: lineHeightGuess baseline: textStyle baseline.		lines _ Array with: line	] ifFalse: [		(text size > 1 and: [text last = Character cr]) ifTrue: [			oldLastLine _ lines last.			oldLastLine last - oldLastLine first >= 0 ifTrue: [				line _ (TextLine start: text size+1 stop: text size internalSpaces: 0 paddingWidth: 0)				rectangle: (oldLastLine left @ oldLastLine bottom 							extent: 0@(oldLastLine bottom - oldLastLine top));				lineHeight: lineHeightGuess baseline: textStyle baseline.				lines _ lines, (Array with: line).			].		].	].	"end of container"	lines _ lines asArray.	^ maxRightX! !!NewParagraph methodsFor: 'editing' stamp: 'hmm 7/17/2000 10:55'!clickAt: clickPoint for: model controller: editor	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action target |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex forStyle: textStyle) 		do: [:att | att mayActOnClick ifTrue:				[	"			range _ text rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box _ boxes detect: [:each | each containsPoint: clickPoint].					*This doesn't work in morphic*				Need to replace by a highlighting morph that waits for moueUp.				Utilities awaitMouseUpIn: (editor transform invertRect: box)						repeating: []						ifSucceed: [(att actOnClickFor: model) ifTrue: [action _ true]].	"				(target _ model) ifNil: [target _ editor morph].				(att actOnClickFor: target)					ifTrue: [Sensor waitNoButton.  "FIX THIS"							action _ true]]].	^ action! !!Object methodsFor: 'scripting' stamp: 'RAA 2/16/2001 19:37'!selfWrittenAsIll	^self! !!Object methodsFor: 'scripting' stamp: 'RAA 2/16/2001 19:38'!selfWrittenAsIm	^self! !!Object methodsFor: 'scripting' stamp: 'RAA 2/16/2001 19:37'!selfWrittenAsMe	^self! !!Object methodsFor: 'scripting' stamp: 'RAA 2/16/2001 19:37'!selfWrittenAsMy	^self! !!Object methodsFor: 'scripting' stamp: 'RAA 2/16/2001 19:38'!selfWrittenAsThis	^self! !!OutOfScopeNotification methodsFor: 'as yet unclassified' stamp: 'RAA 2/5/2001 10:41'!defaultAction	self resume: false! !!PackagePaneBrowser methodsFor: 'initialize-release' stamp: 'stp 2/4/2001 07:29'!defaultBackgroundColor	"PackagePaneBrowser openBrowser"	"^yellow"	^ Color		r: 1.0		g: 1.0		b: 0.6! !!PackagePaneBrowser methodsFor: 'initialize-release' stamp: 'RAA 2/6/2001 12:50'!openAsMorphEditing: editString 	"Create a pluggable version of all the views for a Browser, including 	views and controllers."	"PackagePaneBrowser openBrowser"	| listHeight window |	listHeight _ 0.4.	(window _ SystemWindow labelled: 'later') model: self.	window		addMorph: (PluggableListMorph				on: self				list: #packageList				selected: #packageListIndex				changeSelected: #packageListIndex:				menu: #packageMenu:				keystroke: #packageListKey:from:)		frame: (0 @ 0 extent: 0.15 @ listHeight).	window		addMorph: self buildMorphicSystemCatList		frame: (0.15 @ 0 extent: 0.2 @ listHeight).	self		addClassAndSwitchesTo: window		at: (0.35 @ 0 extent: 0.25 @ listHeight)		plus: 0.	window		addMorph: self buildMorphicMessageCatList		frame: (0.6 @ 0 extent: 0.15 @ listHeight).	window		addMorph: self buildMorphicMessageList		frame: (0.75 @ 0 extent: 0.25 @ listHeight).	self		addLowerPanesTo: window		at: (0 @ listHeight corner: 1 @ 1)		with: editString.	window setUpdatablePanesFrom: #(#packageList #systemCategoryList #classList #messageCategoryList #messageList ).	^ window! !!Paragraph methodsFor: 'selecting' stamp: 'hmm 7/17/2000 10:55'!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range box boxes |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex forStyle: textStyle) 		do: [:att | att mayActOnClick ifTrue:				[range _ text rangeOf: att startingAt: startBlock stringIndex forStyle: textStyle.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box _ boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: box repeating: []					ifSucceed: [aController terminateAndInitializeAround:								[(att actOnClickFor: model) ifTrue: [action _ true]]]]].	^ action! !!Paragraph methodsFor: 'scrolling' stamp: 'hmm 9/16/2000 21:30'!scrollBy: heightToMove withSelectionFrom: startBlock to: stopBlock 	"Translate the composition rectangle up (dy<0) by heightToMove.	Repainting text as necessary, and selection if blocks not nil.	Return true unless scrolling limits have been reached."	| max min amount |	max _ 0 max: "cant scroll up more than dist to (top of) bottom line"		compositionRectangle bottom - textStyle lineGrid - clippingRectangle top.	min _ 0 min: "cant scroll down more than top is above clipRect"		compositionRectangle top - clippingRectangle top.	amount _ ((heightToMove truncateTo: textStyle lineGrid) min: max) max: min.	amount ~= 0		ifTrue: [destinationForm deferUpdatesIn: clippingRectangle while: [					self scrollUncheckedBy: amount						withSelectionFrom: startBlock to: stopBlock].				^ true]		ifFalse: [^ false]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'RAA 2/5/2001 10:43'!evaluateSelection	"Treat the current selection as an expression; evaluate it and return the result"	| result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ ''].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr _ model doItReceiver.				ctxt _ model doItContext]		ifFalse: [rcvr _ ctxt _ nil].	result _ [		rcvr class evaluatorClass new 			evaluate: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	Smalltalk logChange: self selection string.	^ result! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 2/4/2001 00:54'!dropEnabled	"Get this morph's ability to add and remove morphs via drag-n-drop."	^ (self valueOfProperty: #dropEnabled) ~~ false! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 2/9/2001 17:40'!morphToDropFrom: aMorph	"Given a morph being carried by the hand, which the hand is about to drop, answer the actual morph to be deposited.  Normally this would be just the morph itself, but several unusual cases arise, which this method is designed to service."	| aNail representee handy posBlock tempPos |	handy _ self primaryHand.	posBlock _ [:z | 			tempPos _ handy position - (handy targetOffset - aMorph formerPosition * (z extent / aMorph extent)) rounded.			self pointFromWorld: tempPos].	self alwaysShowThumbnail		ifTrue: [aNail _ aMorph						representativeNoTallerThan: self maxHeightToAvoidThumbnailing						norWiderThan: self maximumThumbnailWidth						thumbnailHeight: self heightForThumbnails.			aNail == aMorph				ifFalse: [aMorph formerPosition: aMorph position.						aNail position: (posBlock value: aNail)].			^ aNail].	((aMorph isKindOf: MorphThumbnail)			and: [(representee _ aMorph morphRepresented) owner == nil])		ifTrue: [representee				position: (posBlock value: representee).			^ representee].	self showingListView ifTrue:		[^ aMorph listViewLineForFieldList: (self valueOfProperty: #fieldListSelectors)].	(aMorph hasProperty: #newPermanentScript)		ifTrue: [^ aMorph asEmptyPermanentScriptor].	self automaticPhraseExpansion		ifFalse: [^ aMorph].	((aMorph isKindOf: PhraseTileMorph) or: [aMorph isKindOf: SyntaxMorph])		ifFalse: [^ aMorph].	^ aMorph morphToDropInPasteUp: self! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 2/5/2001 16:59'!replaceTallSubmorphsByThumbnails	"Any submorphs that seem to tall get replaced by thumbnails; their balloon text is copied over to the thumbnail"	|  itsThumbnail heightForThumbnails maxHeightToAvoidThumbnailing maxWidthForThumbnails existingHelp |	heightForThumbnails _ self heightForThumbnails.	maxHeightToAvoidThumbnailing _ self maxHeightToAvoidThumbnailing.	maxWidthForThumbnails _ self maximumThumbnailWidth.	self submorphs do:		[:aMorph |			itsThumbnail _ aMorph representativeNoTallerThan: maxHeightToAvoidThumbnailing norWiderThan: maxWidthForThumbnails thumbnailHeight: heightForThumbnails.			(aMorph == itsThumbnail)				ifFalse:					[existingHelp _ aMorph balloonText.					self replaceSubmorph: aMorph by: itsThumbnail.					existingHelp ifNotNil:						[itsThumbnail setBalloonText: existingHelp]]]! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 2/12/2001 18:57'!install	owner _ nil.	"since we may have been inside another world previously"	submorphs do: [:ss | ss owner == nil ifTrue: [ss privateOwner: self]].		"Transcript that was in outPointers and then got deleted."	self viewBox: Display boundingBox.	Sensor eventQueue: SharedQueue new.	worldState handsDo: [:h | h initForEvents].	self installFlaps.	self borderWidth: 0. "default"	(Preferences showSecurityStatus and:[SecurityManager default isInRestrictedMode])		ifTrue:[self borderWidth: 2; borderColor: Color red].	self presenter allExtantPlayers do:[:player| player prepareToBeRunning].	SystemWindow noteTopWindowIn: self.	self displayWorldSafely.! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 2/7/2001 14:48'!findAPreferencesPanel: evt	"Locate a Preferences Panel, open it, and bring it to the front.  Create one if necessary"	| aWindow |	submorphs do:		[:aMorph | (((aWindow _ aMorph renderedMorph) isKindOf: SystemWindow) and:			[aWindow model isKindOf: PreferencesPanel])				ifTrue:					[aWindow isCollapsed ifTrue: [aWindow expand].					aWindow activateAndForceLabelToShow.					^ self]].	"None found, so create one"	Preferences openFactoredPanelWithWidth: 370! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 2/7/2001 14:55'!keystrokeInWorld: evt	"A keystroke was hit when no keyboard focus was in set, so it is sent here to the world instead.  This current implementation is regrettably hard-coded; until someone cleans this up, you may be tempted to edit this method to suit your personal taste in interpreting cmd-keys issued to the desktop."	|  aChar isCmd |	aChar _ evt keyCharacter.	isCmd _ evt commandKeyPressed and: [Preferences cmdKeysInText].	isCmd ifTrue:		[(aChar == $z) ifTrue: [^ self commandHistory undoOrRedoCommand].		(aChar == $w) ifTrue: [^ SystemWindow closeTopWindow].		(aChar == $\) ifTrue: [^ SystemWindow sendTopWindowToBack].		(aChar == $t) ifTrue: [^ self findATranscript: evt].		(aChar == $b) ifTrue: [^ Browser openBrowser].		(aChar == $k) ifTrue: [^ Workspace open].		(aChar == $m) ifTrue: [^ TheWorldMenu new adaptToWorld: World; newMorph].		(aChar == $C) ifTrue: [^ self findAChangeSorter: evt].		(aChar == $R) ifTrue: [^ self openRecentSubmissionsBrowser: evt].		(aChar == $P) ifTrue: [^ self findAPreferencesPanel: evt].		(aChar == $r) ifTrue: [^ Display restoreMorphicDisplay].		(aChar == $W) ifTrue: [^ self invokeWorldMenu: evt]]			"This last item is a weirdo feature requested by the Open School in Fall of 2000 as a keyhole to the world menu in systems that normally do not offer a world menu"! !!PasteUpMorph methodsFor: 'world menu' stamp: 'RAA 2/7/2001 15:19'!makeNewDrawing: evt	| w newSketch newPlayer sketchEditor aPaintBox aPalette tfx whereToPresent rect ownerBeforeHack |	w _ self world.	w assureNotPaintingElse: [^ self].	"so the flaps don't cover the painting -- Alan"	w flapTabs do: [:aTab | aTab hideFlap].	rect _ self paintingBoundsAround: evt position.	aPalette _ self standardPalette.	aPalette ifNotNil: [aPalette showNoPalette; layoutChanged].	w stopRunningAll; abandonAllHalos.	newSketch _ self drawingClass new player: (newPlayer _ UnscriptedPlayer newUserInstance).	newPlayer costume: newSketch.	newSketch form: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor _ SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: self.	sketchEditor		afterNewPicDo: [:aForm :aRect |			whereToPresent _ self presenter.			newSketch form: aForm.			tfx _ self transformFrom: w.			newSketch position: (tfx globalPointToLocal: aRect origin).			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch forwardDirection: sketchEditor forwardDirection.			ownerBeforeHack _ newSketch owner.	"about to break the invariant!!!!"			newSketch privateOwner: self. "temp for halo access"			newPlayer setHeading: sketchEditor forwardDirection.			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			newSketch privateOwner: ownerBeforeHack. "probably nil, but let's be certain"			self addMorphFront: newPlayer costume.			w startSteppingSubmorphsOf: newSketch.			whereToPresent drawingJustCompleted: newSketch]		 ifNoBits:			[(aPaintBox _ w paintBox) ifNotNil:				[aPaintBox delete].			aPalette ifNotNil: [aPalette showNoPalette].]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 2/7/2001 20:10'!openScrapsBook: evt	"Open up the Scraps book in the center of the screen"	evt hand world addMorphCentered: Utilities scrapsBook! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'sw 2/9/2001 00:15'!justDroppedInto: newOwner event: evt	"Phrase tiles only auto-expand if they originate from viewers.  Any phrase tile, once dropped, loses its auto-phrase-expansion thing"	justGrabbedFromViewer _ false.	super justDroppedInto: newOwner event: evt! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'ar 2/9/2001 17:06'!morphToDropInPasteUp: aPasteUp	"Answer the morph to drop in aPasteUp, given that the receiver is the putative droppee"	| actualObject itsSelector aScriptor pos |	self isCommand ifFalse: [^ self].	(actualObject _ self actualObject) ifNil: [^ self].	self justGrabbedFromViewer ifFalse: [^ self].	actualObject assureUniClass.	itsSelector _ self userScriptSelector.	pos _ self position.	aScriptor _ itsSelector isEmptyOrNil		ifFalse:			[actualObject scriptEditorFor: itsSelector]		ifTrue:			["It's a system-defined selector; construct an anonymous scriptor around it"			actualObject newScriptorAround: self].	aScriptor ifNil:[^self].	(self hasOwner: aScriptor) ifTrue:[		aScriptor fullBounds. "force layout"		aScriptor position: pos - self position.	] ifFalse:[		aScriptor position: self position.	].	^ aScriptor! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'ar 2/14/2001 16:17'!mouseDown: evt 	"Pretend we picked up the tile and then put it down for a trial  	positioning."	"The essence of ScriptEditor mouseEnter:"	| ed ss guyToTake dup |	self isPartsDonor ifTrue:[		dup _ self duplicate.		evt hand attachMorph: dup.		dup position: evt position.		^self].	submorphs isEmpty		ifTrue: [^ self].	(ed _ self enclosingEditor) ifNil: [^evt hand grabMorph: self].	guyToTake _ self.	owner class == TilePadMorph		ifTrue: ["picking me out of another phrase"			(ss _ submorphs first) class == TilePadMorph				ifTrue: [ss _ ss submorphs first].			guyToTake _  ss fullCopy].	evt hand grabMorph: guyToTake.	ed startStepping.	ed mouseEnterDragging: evt.	ed setProperty: #justPickedUpPhrase toValue: true.! !!Player methodsFor: 'costume' stamp: 'ar 2/17/2001 15:48'!clearPenTrails	self costume referencePlayfield clearTurtleTrails! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 2/5/2001 14:04'!editDescriptionForSelector:  aSelector	"Allow the user to edit the balloon-help description for the given selector"	(self class userScriptForPlayer: self selector: aSelector) editDescription.	self updateAllViewers! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 2/5/2001 14:06'!infoFor: anElement inViewer: aViewer	"The user made a gesture asking for info/menu relating"	| aMenu elementType aSelector |	elementType _ self elementTypeFor: anElement.	((elementType = #systemSlot) | (elementType == #userSlot))		ifTrue:	[^ self slotInfoButtonHitFor: anElement inViewer: aViewer].		aMenu _ MenuMorph new defaultTarget: self.	aMenu defaultTarget: self.	aSelector _ anElement asSymbol.	(elementType == #userScript)		ifTrue:			[aMenu add: 'destroy "', anElement, '"' selector: #removeScriptWithSelector: argument: aSelector.			aMenu add: 'rename  "', anElement, '"' selector: #renameScript: argument: aSelector.			aMenu add: 'textual scripting pane'  selector: #makeIsolatedCodePaneForSelector: argument: aSelector.			aMenu add: 'button to fire this script' selector: #tearOffButtonToFireScriptForSelector: argument: aSelector.			aMenu add: 'edit balloon help' selector: #editDescriptionForSelector: argument: aSelector.			"aMenu add: 'pacify this script' selector: #pacifyScript: argument: aSelector"].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: anElement asString, ' (', elementType, ')'.	aMenu popUpInWorld: aViewer world! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 2/5/2001 14:03'!makeIsolatedCodePaneForSelector: aSelector	"make an isolated code pane for the given selector"	MethodHolder makeIsolatedCodePaneForClass: self class selector: aSelector! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 2/5/2001 14:01'!removeScriptWithSelector: aSelector	"Remove the given script, and get the display right"	self removeScript: aSelector fromWorld:  self currentWorld! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 2/5/2001 14:10'!tearOffButtonToFireScriptForSelector: aSelector	"Tear off a button to fire the script for the given selector"	| aButton |	aButton _ ScriptActivationButton new target: self.	aButton actionSelector: #runScript:.	aButton arguments: (Array with: aSelector).	aButton establishLabelWording.	self currentHand attachMorph: aButton! !!Player methodsFor: 'scripts-execution' stamp: 'sw 2/6/2001 23:21'!fireOnce	"If the receiver has any script armed to be triggered on mouse down and/or mouse-up, run those scripts now -- first the mouseDown ones, then the mouseUp ones."	self instantiatedUserScriptsDo:		[:aScriptInst |			aScriptInst status == #mouseDown ifTrue: [aScriptInst fireOnce]].	self instantiatedUserScriptsDo:		[:aScriptInst |			aScriptInst status == #mouseUp ifTrue: [aScriptInst fireOnce]].! !!Player methodsFor: 'scripts-execution' stamp: 'ar 2/12/2001 18:57'!prepareToBeRunning	self instantiatedUserScriptsDo:		[:aScriptInstantiation | aScriptInstantiation prepareToBeRunning].! !!Player methodsFor: 'scripts-execution' stamp: 'ar 2/12/2001 18:04'!runAllTickingScripts: nowTick	self instantiatedUserScriptsDo: [:aScriptInstantiation | aScriptInstantiation runIfTicking: nowTick]! !!Player methodsFor: 'scripts-execution' stamp: 'ar 2/12/2001 18:50'!step	"obsolete"	^self stepAt: Time millisecondClockValue.! !!Player methodsFor: 'scripts-execution' stamp: 'ar 2/12/2001 18:04'!stepAt: nowTick	self runAllTickingScripts: nowTick! !!Player methodsFor: 'scripts-standard' stamp: 'sw 2/5/2001 11:25'!doButtonAction	"Do the button action of my costume"	self costume renderedMorph doButtonAction! !!Player methodsFor: 'scripts-standard' stamp: 'sw 2/6/2001 21:13'!fire	"Do the button action of my costume"	self costume renderedMorph fire! !!Player methodsFor: 'scripts-standard' stamp: 'RAA 2/11/2001 22:04'!tellAllSiblings: aMessageSelector	"Send the given message selector to all my sibling instances, but not to myself"	self belongsToUniClass ifTrue:		[(self class allSubInstances copyWithout: self) do:			[:anInstance | anInstance perform: aMessageSelector asSymbol]]! !!Player methodsFor: 'misc' stamp: 'RAA 2/11/2001 22:02'!erase	self costume delete! !!Player7 class methodsFor: 'as yet unclassified' stamp: 'di 6/22/97 09:14'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!PlayingCardMorph methodsFor: 'events' stamp: 'RAA 2/12/2001 19:22'!click: evt		"since we really want to know about double-clicks before making our move, ignore this and wait until #firstClickTimedOut: arrives"! !!PlayingCardMorph methodsFor: 'events' stamp: 'RAA 2/12/2001 19:16'!firstClickTimedOut: evt	| root popUp |	root _ owner rootForGrabOf: self.	root == nil		ifTrue: ["Display hidden card in front"				popUp _ self copy.				self board owner owner addMorphFront: popUp.				self world displayWorld.				(Delay forMilliseconds: 750) wait.				popUp delete]		ifFalse: [evt hand grabMorph: root]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'di 2/6/2001 14:02'!roundCornersOf: aMorph during: aBlock	aMorph wantsRoundedCorners ifFalse:[^aBlock value].	(self seesNothingOutside: (CornerRounder rectWithinCornersOf: aMorph bounds))		ifTrue: ["Don't bother with corner logic if the region is inside them"				^ aBlock value].	CornerRounder roundCornersOf: aMorph on: self		displayBlock: aBlock		borderWidth: aMorph borderWidthForRounding		corners: aMorph roundedCorners! !!PluggableCodeGenerator methodsFor: 'C code generator' stamp: 'ar 2/5/2001 21:20'!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/* Default EXPORT macro that does nothing (see comment in sq.h): */#define EXPORT(returnType) returnType/* Do not include the entire sq.h file but just those parts needed. *//*  The virtual machine proxy definition */#include "sqVirtualMachine.h"/* Configuration options */#include "sqConfig.h"/* Platform specific definitions */#include "sqPlatformSpecific.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C */'; cr; cr.	"Additional header files"	headerFiles do:[:hdr|		aStream nextPutAll:'#include '; nextPutAll: hdr; cr].	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Proxy Functions ***/#define stackValue(i) (interpreterProxy->stackValue(i))#define stackIntegerValue(i) (interpreterProxy->stackIntegerValue(i))#define successFlag (!!interpreterProxy->failed())#define success(bool) (interpreterProxy->success(bool))#define arrayValueOf(oop) (interpreterProxy->arrayValueOf(oop))#define checkedIntegerValueOf(oop) (interpreterProxy->checkedIntegerValueOf(oop))#define fetchArrayofObject(idx,oop) (interpreterProxy->fetchArrayofObject(idx,oop))#define fetchFloatofObject(idx,oop) (interpreterProxy->fetchFloatofObject(idx,oop))#define fetchIntegerofObject(idx,oop) (interpreterProxy->fetchIntegerofObject(idx,oop))#define floatValueOf(oop) (interpreterProxy->floatValueOf(oop))#define pop(n) (interpreterProxy->pop(n))#define pushInteger(n) (interpreterProxy->pushInteger(n))#define sizeOfSTArrayFromCPrimitive(cPtr) (interpreterProxy->sizeOfSTArrayFromCPrimitive(cPtr))#define storeIntegerofObjectwithValue(idx,oop,value) (interpreterProxy->storeIntegerofObjectwithValue(idx,oop,value))#define primitiveFail() interpreterProxy->primitiveFail()/* allows accessing Strings in both C and Smalltalk */#define asciiValue(c) c'.	aStream cr.! !!PluggableFileList methodsFor: 'file list menu' stamp: 'sw 2/16/2001 16:20'!fileSelectedMenu: aMenu	"Fill the menu with items appropriate for the selected file type, or for all file types if the shift key is down"	| firstItems secondItems thirdItems n1 n2 n3 |	firstItems _ self itemsForFileEnding:		(Sensor leftShiftDown			ifFalse:				[self fileNameSuffix asLowercase]			ifTrue:				['*']).	secondItems _ self itemsForAnyFile.	thirdItems _ self itemsForNoFile.	n1 _ firstItems first size.	n2 _ n1 + secondItems first size.	n3 _ n2 + thirdItems first size.	^ aMenu		labels: firstItems first , secondItems first , thirdItems first		lines: firstItems second				, (Array with: n1 with: n2)				, (thirdItems second collect: [:n | n + n2])				, (Array with: n3)		selections: firstItems third , secondItems third , thirdItems third! !!PluggableTextMorph methodsFor: 'model access' stamp: 'sw 2/6/2001 01:24'!setTextColor: aColor	"Set the color of my text to the given color"	textMorph color: aColor! !A general mechanism to store preference choices.  The default setup treats any symbol as a potential boolean flag; flags unknown to the preference dictionary are always returned as false.  	To open the control panel:		Preferences openFactoredPanelAll messages are on the class side.To query a a preference:	Preferences logDebuggerStackToFileor some people prefer the more verbose	Preferences valueOfFlag: #logDebuggerStackToFileYou can make up a new preference any time.  Do not define a new message in Preferences class. Accessor methods are compiled automatically when you add a preference as illustrated below:To add a preference (e.g. in the Postscript of a fileout):	Preferences addPreference: #samplePreference categories: #(general browsing)		default: true balloonHelp:  'This is an example of a preference added by a do-it'.To change a preference programatically:	Preferences disable: #logDebuggerStackToFile.Or to turn it on,	Preferences enable: #logDebuggerStackToFile.!!Preferences class methodsFor: 'initialization' stamp: 'sw 2/6/2001 03:54'!allPreferenceInitializationSpecs	"Answer a list of all the preference initialization specs found in the 'initial values' category; overlay any initial values found there if requested to be #defaultOverridesForCertainPreferences "	| aList additions overrides entryToAdd anOverride |	overrides _ self defaultOverridesForCertainPreferences.	aList _ OrderedCollection new.	(self class organization listAtCategoryNamed: 'initial values' asSymbol) do:		[:aSelector | aSelector numArgs = 0 ifTrue:			[additions _ self perform: aSelector.			(additions isKindOf: Collection) ifFalse: [self error: 'method in "initial values" categories must return collections'].			additions do:				[:anAddition | (aList detect: [:elem | elem first == anAddition first] ifNone: [nil])					ifNil:						[entryToAdd _ (anOverride _ overrides detect: [:ov | ov first == anAddition first] ifNone: [nil])							ifNil:								[anAddition]							ifNotNil:								[{anAddition first. anOverride second}, (anAddition copyFrom: 3 to: anAddition size)].						aList add: entryToAdd]]]].	^ aList	"Preferences allPreferenceInitializationSpecs size"! !!Preferences class methodsFor: 'initialization' stamp: 'sw 2/6/2001 04:08'!chooseInitialSettings	"Restore the default choices for all of the standard Preferences."	self allPreferenceInitializationSpecs do:		[:aSpec |			aSpec second == #true				ifTrue:					[self enable: aSpec first]				ifFalse:					[self disable: aSpec first]].	self resetCategoryInfo	"Preferences chooseInitialSettings"! !!Preferences class methodsFor: 'initialization' stamp: 'sw 2/6/2001 04:22'!constructMonolithicPreferencesInitializer	"For transition to 3.0:  Take a survey of all the preference initializers in the system; gather them in, then remove all the numerous initializer methods, and spit out a huge, monolithic initializer that characerizes the names, categories, and default values for all the Preferences as of the beginning of Squeak 3.0.  This one-time do-it obtains the help messages currently in the image for the existing preferences, and factors them into the method thus exuded.  The old mechanism of having help messages separately stored in a 'help' category is abandoned; the help-message initializers in the 'initial values' category now also include balloon-help info.  Note that the default-value overrides specified in #defaultOverridesForCertainPreferences are honored here"	"Preferences constructMonolithicPreferencesInitializer"	| initializationArray stringToCompile |	initializationArray _ self allPreferenceInitializationSpecs collect:		[:triplet |			Array				with:	triplet first					"preference symbol"				with: 	triplet second asSymbol  	"default value, as symbol #false or #true"				with:	triplet third					"category list"				with:	(HelpDictionary at: triplet first ifAbsent: [''])].			"help msg"	initializationArray _ (initializationArray asSortedCollection:		[:a :b | a first <= b first]) asArray.  "Sort by preference name for easy access in the source code"	self class removeCategory: 'help'.	self class removeCategory: 'initial values'.	stringToCompile _ String streamContents:		[:aStream |			aStream nextPutAll: 'initialValuesThreePointOh'.			aStream cr; tab.			aStream nextPutAll: '^ '.			initializationArray storeOn: aStream].	self class compileProgrammatically: stringToCompile classified: 'initial values'.	self resetCategoryInfo! !!Preferences class methodsFor: 'initialization' stamp: 'sw 2/7/2001 15:20'!defaultOverridesForCertainPreferences	"Answer a list of overrides to the default settings of certain preferences.  The default state of preferences -- i.e. the one you get back to if you hit the 'Restore all System Defaults' button -- is defined by the initializer methods of preferences (look in category 'initial values' in Preferences class), as then subsequently amended and overridden by this table, which will continue to evolve right up to each release, and which users may wish to hand-edit as well for their own private configurations"	^ #((capitalizedReferences			true)		(clickOnLabelToEdit				false)		(decorateBrowserButtons			false)		(fastDragWindowForMorphic		true)		(infiniteUndo					false)		(menuColorFromWorld			true)		(mvcProjectsAllowed				true)		(optionalButtons					false)		(preserveTrash					false)		(roundedWindowCorners			true)		(scrollBarsNarrow				false)		(soundsEnabled					true)		(useGlobalFlaps					true))! !!Preferences class methodsFor: 'initialization' stamp: 'dew 2/17/2001 23:12'!initializeAddedPreferences	"Initialize any preference not yet known to the prefs dictionary as per descriptions in the 'initial values' category, but don't change the setting of any existing preference.	Also, compile accessor methods for retrieving any preference that lacks one"	"Preferences initializeAddedPreferences"	| sym selectors |	selectors _ self class selectors.  "(this can take some time)"	self allPreferenceInitializationSpecs do:		[:triplet |			(selectors includes: (sym _ triplet first))				ifFalse:					[self compileAccessMethodFor: sym].			(FlagDictionary includesKey: sym) ifFalse:				[triplet second == #true					ifTrue:						[self enable: sym]					ifFalse:						[self disable: sym]]].	self resetCategoryInfo! !!Preferences class methodsFor: 'initialization' stamp: 'sw 2/6/2001 16:16'!initializeHelpMessages	"Initialize the preferences help messages from the initialization information found"	"Preferences initializeHelpMessages"  	HelpDictionary _ Dictionary new.	self allPreferenceInitializationSpecs do:		[:quad |			quad size >= 4 ifTrue:				[HelpDictionary at: quad first put: quad fourth]]! !!Preferences class methodsFor: 'initialization' stamp: 'sw 2/7/2001 15:42'!postHocCategoryAdjustments	| aDictionary |	"Provides a table governing post-hoc changes to default categories for certain preferences.  In the table below, each element gives the name a preference and a list of categories it belongs in; the method returns a dictionary whose keys are the pref names and whose values are the ultimate desired list."	aDictionary _ IdentityDictionary new.	#(	(checkForUnsavedProjects			(projects))		(mvcProjectsAllowed					(projects))		(projectViewsInWindows				(projects))		(projectZoom							(projects))		(projectsSendToDisk					(projects))		(signProjectFiles						(projects))) do:		[:pair | aDictionary at: pair first put: pair second].	^ aDictionary! !!Preferences class methodsFor: 'initialization' stamp: 'sw 2/7/2001 14:34'!restorePersonalPreferences	| savedPrefs |	"Restore all the user's saved personal preferences"	savedPrefs _ self parameterAt: #PersonalPreferences ifAbsent: [^ self inform: 'There are no personal preferences saved in this image yet'].	savedPrefs associationsDo:		[:assoc | self setPreference: assoc key toValue: assoc value]! !!Preferences class methodsFor: 'initialization' stamp: 'sw 2/7/2001 14:30'!savePersonalPreferences	"Save the current list of Preference settings as the user's personal choices"	self setParameter: #PersonalPreferences to: FlagDictionary deepCopy! !!Preferences class methodsFor: 'parameters' stamp: 'sw 2/8/2001 14:11'!editAnnotations	"Preferences editAnnotations"	| aPanel ins outs current aMorph aWindow aButton info pair |	Smalltalk isMorphic		ifFalse:			[^ self inform: 'Sorry, you must be in a morphicproject to use this feature.'].	aPanel _ AlignmentMorph newRow extent: 300 @ 100.	ins _ AlignmentMorph newColumn extent: 150 @ 100.	ins enableDrop: true; beSticky.	ins color: Color green muchLighter.	outs _ ins fullCopy.	outs color: Color red muchLighter.	aPanel addMorph: outs; addMorphFront: ins.	outs position: (ins position + (200 @ 0)).	current _ self defaultAnnotationRequests.	info _ self annotationInfo.	current do:		[:sym | pair _ info detect: [:aPair | aPair first == sym].		aMorph _ StringMorph new contents: pair first.		aMorph setBalloonText: pair last.		aMorph enableDrag: true.		aMorph			on: #startDrag			send: #startDrag:with:			to: aMorph.		ins addMorphBack: aMorph].	info do:		[:aPair | 			(current includes: aPair first) 				ifFalse:					[aMorph _ StringMorph new contents: aPair first.					aMorph setBalloonText: aPair last.					aMorph enableDrag: true.					aMorph						on: #startDrag						send: #startDrag:with:						to: aMorph.					outs addMorph: aMorph]].	aPanel layoutChanged.	aWindow _ SystemWindowWithButton new setLabel: 'Annotations'.	aButton _ SimpleButtonMorph new target: Preferences;		actionSelector: #acceptAnnotationsFrom:; arguments: (Array with: aWindow); label: 'apply'; borderWidth: 0; borderColor: Color transparent; color: Color transparent.	aButton submorphs first color: Color blue.	aButton setBalloonText: 'After moving all the annotations you want to the left (green) side, and all the ones you do NOT want to the right (pink) side, hit this "apply" button to have your choices take effect.'.	aWindow buttonInTitle: aButton; adjustExtraButton.	self currentWorld addMorphCentered: (aPanel wrappedInWindow: aWindow).	aWindow activateAndForceLabelToShow! !!Preferences class methodsFor: 'parameters' stamp: 'sw 2/7/2001 14:37'!parameterAt: aKey ifAbsent: aBlock	"Answer the parameter saved at the given key; if there is no such key in the Parameters dictionary, evaluate aBlock"	^ Parameters at: aKey ifAbsent: [aBlock value]! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 2/12/2001 11:46'!noteThatFlag: prefSymbol justChangedTo: aBoolean	"Provides a hook so that a user's toggling of a preference might precipitate some immediate action"	| keep |	prefSymbol == #useGlobalFlaps ifTrue:		[aBoolean			ifFalse:		"Turning off use of flaps"				[keep _ self confirm:'Do you want to preserve the existingglobal flaps for future use?'.				Utilities globalFlapTabsIfAny do:					[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: keep.					aFlapTab isInWorld ifTrue: [self error: 'Flap problem']].				keep ifFalse: [Utilities clobberFlapTabList]]			ifTrue:		"Turning on use of flaps"				[Smalltalk isMorphic ifTrue:					[self currentWorld addGlobalFlaps]]].	prefSymbol == #roundedWindowCorners ifTrue: [Display repaintMorphicDisplay].	prefSymbol == #optionalButtons ifTrue:		[Utilities replacePartSatisfying: [:el | (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented model isKindOf: FileList]]]inGlobalFlapSatisfying: [:f1 | f1 wording = 'Tools'] with:  FileList openAsMorph applyModelExtent].	(prefSymbol == #optionalButtons  or: [prefSymbol == #annotationPanes]) ifTrue:		[Utilities replaceBrowserInToolsFlap].	(prefSymbol == #smartUpdating) ifTrue:		[SystemWindow allSubInstancesDo:			[:aWindow | aWindow amendSteppingStatus]].	(prefSymbol == #eToyFriendly) ifTrue:		[ScriptingSystem customizeForEToyUsers: aBoolean].	((prefSymbol == #infiniteUndo) and: [aBoolean not]) ifTrue:		[CommandHistory resetAllHistory].	(prefSymbol == #showProjectNavigator) ifTrue:		[Project current assureNavigatorPresenceMatchesPreference] ! !!Preferences class methodsFor: 'misc' stamp: 'sw 2/7/2001 16:09'!giveHelpWithPreferences	"Open up a workspace with explanatory info in it about Prefernces"	| aString |	aString _ 'Many aspects of the system are governed by the settings of various "Preferences".  Click on any of brown tabs at the top of the panel to see all the preferences in that category.  Or type in to the box above the Search button, then hit Search, and all Preferences matching whatever you typed in will appear in the "search results" category.To find out more about any particular Preference, hold the mouse over it for a moment and balloon help will appear.If you like all your current Preferences settings, you may wish to hit the "Save Current Settings as my Personal Preferences" button.  Once you have done that, you can at any point in the future hit "Restore my Personal Preferences" and all your saved settings will get restored immediately.'.	(Workspace new contents: aString) openLabel: 'About Preferences'! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 2/6/2001 23:29'!automaticKeyGeneration	^ self valueOfFlag: #automaticKeyGeneration! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 2/6/2001 23:29'!securityChecksEnabled	^ self valueOfFlag: #securityChecksEnabled! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 2/6/2001 23:29'!showSecurityStatus	^ self valueOfFlag: #showSecurityStatus! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 2/6/2001 23:29'!signProjectFiles	^ self valueOfFlag: #signProjectFiles! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 2/12/2001 23:47'!startInUntrustedDirectory	^ self valueOfFlag: #startInUntrustedDirectory! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 2/6/2001 23:29'!warnAboutInsecureContent	^ self valueOfFlag: #warnAboutInsecureContent! !!Preferences class methodsFor: 'window colors' stamp: 'sw 2/8/2001 14:36'!windowSpecificationPanel	"Preferences windowSpecificationPanel"	| aPanel buttonRow aButton aRow aSwatch aColor aWindow aMiniWorld |	aPanel _ AlignmentMorph newColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap;		layoutInset: 0.	aPanel addMorph: (buttonRow _ AlignmentMorph newRow color: (aColor _ Color tan lighter)).		aButton _ SimpleButtonMorph new target: self.	buttonRow addTransparentSpacerOfSize: 2@0.	buttonRow addMorphBack: (SimpleButtonMorph new label: '?'; target: self; actionSelector: #windowColorHelp; setBalloonText: 'Click for an explanation of this panel'; color: Color veryVeryLightGray; yourself).	buttonRow addTransparentSpacerOfSize: 8@0.	#(	('Bright' 	installBrightWindowColors	yellow					'Use standard bright colors for all windows.')		('Pastel'		installPastelWindowColors	paleMagenta					'Use standard pastel colors for all windows.')		('White'	installUniformWindowColors		white					'Use white backgrounds for all standard windows.')) do:		[:quad |			aButton _ aButton fullCopy				label: quad first;				actionSelector: quad second;				color: (Color colorFrom: quad third);				setBalloonText: quad fourth;				yourself.			buttonRow addMorphBack: aButton.			buttonRow addTransparentSpacerOfSize: 10@0].	self windowColorClasses do:		[:aClassName | 			aRow _ AlignmentMorph newRow color: aColor.			aSwatch _ ColorSwatch new				target: self;				getSelector: #windowColorFor:;				putSelector: #setWindowColorFor:to:;				argument: aClassName;				extent: (40 @ 20);				yourself.			aRow addMorphFront: aSwatch.			aRow addTransparentSpacerOfSize: (12 @ 1).			aRow addMorphBack: (StringMorph contents: aClassName font: TextStyle defaultFont).			aPanel addMorphBack: aRow].	 Smalltalk isMorphic                ifTrue:                        [buttonRow _ buttonRow fullCopy removeAllMorphs.					buttonRow addTransparentSpacerOfSize: 25@0.					aButton _ aButton fullCopy color: Color tan muchLighter.					aButton label: 'Update Tools Flap'; target: Utilities; actionSelector: #replaceToolsFlap.					buttonRow addMorphBack: aButton.					aButton setBalloonText: 'Press here to place tools which use the above window-color choices  into the Tools flap.'.					aPanel addMorphBack: buttonRow.					aWindow _ aPanel wrappedInWindowWithTitle: 'Window Colors'.					self currentWorld addMorphCentered: aWindow.					aWindow activateAndForceLabelToShow ]                ifFalse:                        [(aMiniWorld _ MVCWiWPasteUpMorph newWorldForProject: nil)						addMorph: aPanel.                           aMiniWorld startSteppingSubmorphsOf: aPanel.                        MorphWorldView openOn: aMiniWorld                                label: 'Window Colors'                                extent: aMiniWorld fullBounds extent]! !!Preferences class methodsFor: 'factored pref panel' stamp: 'sw 2/6/2001 04:05'!factoredCategories	"Answer the list of categories, each with its corresponding list of elements"	| prefsWithoutInits extraItem |	"CategoryInfo _ nil"	CategoryInfo ifNil:		[CategoryInfo _ self initialCategoryInfo].	((prefsWithoutInits _ self preferencesLackingInitializers) size > 0)		ifTrue:			[extraItem _ (Array with: 'uncategorized' with: prefsWithoutInits asSortedArray)].	^ {{'?'. {}}}, (extraItem		ifNil:			[CategoryInfo]		ifNotNil:			[CategoryInfo, {extraItem}]) copyWith: {'search results'. OrderedCollection new}	"Preferences factoredCategories"! !!Preferences class methodsFor: 'factored pref panel' stamp: 'sw 2/7/2001 15:48'!initialCategoryInfo	"Answer an alphabetized array of pairs, each of which consists of:		the name of a category		a list of preferences belonging to that category	This is done by scanning all the initializer methods found in category 'initial values' in Preferences class."	| categories catList adjustments itsCategories |	categories _ IdentityDictionary new.	adjustments _ self postHocCategoryAdjustments.	self allPreferenceInitializationSpecs do:		[:spec |			itsCategories _ adjustments at: spec first ifAbsent: [spec size > 2 ifTrue:				[spec third] ifFalse: [#()]].			itsCategories do:					[:sym | 						(categories includesKey: sym) ifFalse:							[categories at: sym put: OrderedCollection new].					((catList _ categories at: sym) includes: spec first)						ifFalse:	[catList add: spec first]]].	^ categories keys asSortedArray collect:		[:aKey | Array with: aKey with: (categories at: aKey) asSortedArray]! !!Preferences class methodsFor: 'factored pref panel' stamp: 'sw 2/7/2001 15:02'!openFactoredPanel	"Open up a tabbed Preferences panel.  In mvc, a new one is launched on each request; in Morphic, any existing one is opened, and a new one launched only if no existing one can be found."	Smalltalk isMorphic		ifTrue:  "reuse an existing one if one is found, else create a fresh one"			[self currentWorld findAPreferencesPanel: nil] 		ifFalse:  "in mvc, always opens a new one for now"			[self openNewPreferencesPanel]"Preferences openFactoredPanel"! !!Preferences class methodsFor: 'factored pref panel' stamp: 'sw 2/7/2001 16:13'!openFactoredPanelWithWidth: aWidth 	"Open up a preferences panel of the given width"	"Preferences openFactoredPanelWithWidth: 325"	| tabbedPalette controlPage window playfield aColor aFont maxEntriesPerCategory tabsMorph anExtent aPanel |	aFont _ StrikeFont familyName: 'NewYork' size: 19.	aPanel _ PreferencesPanel new.	aColor _ aPanel defaultBackgroundColor.	tabbedPalette _ TabbedPalette newSticky.	(tabsMorph _ tabbedPalette tabsMorph) color: aColor darker;		 highlightColor: Color red regularColor: Color brown darker darker.	tabbedPalette on: #mouseDown send: #yourself to: #().	maxEntriesPerCategory _ 0.	self factoredCategories		do: 			[:aCat | 			controlPage _ AlignmentMorph newColumn beSticky color: aColor.			controlPage on: #mouseDown send: #yourself to: #().			controlPage borderColor: aColor;				 layoutInset: 4.			aCat second				do: [:aPrefSymbol | controlPage						addMorphBack: (Preferences								buttonRepresenting: aPrefSymbol								wording: aPrefSymbol								color: nil)].			controlPage setNameTo: aCat first asString.			aCat first = #?				ifTrue:	[aPanel addHelpItemsTo: controlPage].			aCat first == #halos				ifTrue: [aPanel addHaloControlsTo: controlPage].			tabbedPalette addTabFor: controlPage font: aFont.			aCat first = 'search results' ifTrue:				[(tabbedPalette tabNamed: aCat first) setBalloonText:					'Use the ? category to find preferences by keyword; the results of your search will show up here'].			maxEntriesPerCategory _ maxEntriesPerCategory max: aCat second size].	tabbedPalette selectTabNamed: '?'.	tabsMorph rowsNoWiderThan: aWidth.	playfield _ Morph newSticky.	playfield on: #mouseDown send: #yourself to: #().	anExtent _ aWidth @ (25 + tabsMorph height + (20 * maxEntriesPerCategory)).	playfield extent: anExtent.	playfield color: aColor.	playfield addMorphBack: tabbedPalette.	self couldOpenInMorphic		ifTrue: [window _ (SystemWindow labelled: 'Preferences')						model: aPanel.			window on: #keyStroke send: #keyStroke: to: aPanel.			window				bounds: (100 @ 100 - (0 @ window labelHeight + window borderWidth) extent: playfield extent + (2 * window borderWidth)).			window				addMorph: playfield				frame: (0 @ 0 extent: 1 @ 1).			window updatePaneColors.			window setProperty: #minimumExtent toValue: anExtent + (2 @ 2).			self currentWorld addMorphFront: window.			window center: self currentWorld center.			window activateAndForceLabelToShow]		ifFalse:			[(window _ MVCWiWPasteUpMorph newWorldForProject: nil) addMorph: playfield.			MorphWorldView				openOn: window				label: 'Preferences'				extent: playfield extent]! !!Preferences class methodsFor: 'factored pref panel' stamp: 'sw 2/7/2001 15:01'!openNewPreferencesPanel	"Create and open a new Preferences Panel"	self openFactoredPanelWithWidth: 370! !!Preferences class methodsFor: 'add preferences' stamp: 'sw 2/5/2001 22:09'!addPreference: prefSymbol categories: categoryList default: defaultValue balloonHelp: helpString 	"Add an item repreesenting the given preference symbol to the system.  This approach was first suggested and implemented by Stephan Rudlof"	| sourceString |	sourceString _ String streamContents:		[:aStream |			aStream nextPutAll: 'initialValuesAddition'.			aStream nextPutAll: categoryList first asString, prefSymbol.  			"conjure up a unique selector"			aStream cr; tab.			aStream nextPutAll: '^ #(('.			prefSymbol printOn: aStream.			aStream space.			defaultValue storeOn: aStream.			aStream space.			categoryList storeOn: aStream.			aStream space.			helpString storeOn: aStream.			aStream nextPutAll: '))'].	self class compileProgrammatically: sourceString classified: 'initial values'.	self absorbAdditions! !!Preferences class methodsFor: 'add preferences' stamp: 'sw 2/5/2001 22:20'!addPreference: prefSymbol category: categorySymbol default: defaultValue balloonHelp: helpString 	"Add the given preference, putting it in the given category, with the given default value, and with the given balloon help"	self addPreference: prefSymbol categories: {categorySymbol} default: defaultValue balloonHelp: helpString ! !!Preferences class methodsFor: 'initial values' stamp: 'programmatic 2/6/2001 23:29'!initialValuesAdditionsecurityautomaticKeyGeneration	^ #((#automaticKeyGeneration false #(#security ) 'When true, a key pair for signing projects is automatically generated on startup (only if no keys file is available).'))! !!Preferences class methodsFor: 'initial values' stamp: 'programmatic 2/6/2001 23:29'!initialValuesAdditionsecuritysecurityChecksEnabled	^ #((#securityChecksEnabled false #(#security ) 'When true, insecure content will make Squeak go into restricted mode. When false, all security mechanisms are turned off.'))! !!Preferences class methodsFor: 'initial values' stamp: 'programmatic 2/6/2001 23:29'!initialValuesAdditionsecurityshowSecurityStatus	^ #((#showSecurityStatus true #(#security ) 'When true, a red border is drawn in the current project indicating that the system is in restricted mode.'))! !!Preferences class methodsFor: 'initial values' stamp: 'programmatic 2/6/2001 23:29'!initialValuesAdditionsecuritysignProjectFiles	^ #((#signProjectFiles true #(#security ) 'When true, projects will be signed before storing them on some server.'))! !!Preferences class methodsFor: 'initial values' stamp: 'programmatic 2/12/2001 23:47'!initialValuesAdditionsecuritystartInUntrustedDirectory	^ #((#startInUntrustedDirectory false #(#security ) 'When true, the default directory is set to the untrusted user directory on startup'))! !!Preferences class methodsFor: 'initial values' stamp: 'programmatic 2/6/2001 23:29'!initialValuesAdditionsecuritywarnAboutInsecureContent	^ #((#warnAboutInsecureContent true #(#security ) 'When true, show a warning when insecure content is encountered'))! !!Preferences class methodsFor: 'initial values' stamp: 'di 2/15/2001 21:34'!initialValuesThreePointOh	^ #(#(#alternativeBrowseIt #false #(#browsing) 'alternativeBrowseIt:		if true, then the "browse it" (cmd-b) feature in the text editor will offer you a list of class names matching the selection, if appropriate') #(#annotationPanes #false #(#browsing) 'annotationPanes:		If true, a thin horizontal annotation pane is used in browsers.') #(#autoAccessors #false #(#general) 'autoAccessors:		If true, an attempt to call a message which is not understood by an object but whose selector is the same as an inst var of the object will result in automatic compilation of an accessor method for that object''s class') #(#automaticPlatformSettings #true #(#general) 'automaticPlatformSettings:		If true, certain preferences are automatically set according to the current platform.') #(#automaticViewerPlacement #true #(#scripting) 'automaticViewerPlacement:		If true, new viewers are automatically positioned near the objects they view; if false, new viewers are attached to the hand, from whence you much choose a destination for them') #(#balloonHelpEnabled #true #(#morphic) 'balloonHelpEnabled:		Whether balloon help should be offered when the cursor lingers over certain objects.') #(#batchPenTrails #false #(#scripting) 'batchPenTrails:		Ignores the detailed movement of pens between display updates.  Thus multiple line segments drawn within a script may not be seen individually.') #(#browseWithDragNDrop #true #(#browsing) 'browseWithDragNDrop:		If true, drag&drop browsing is enabled, new Browser are opened with drag&drop functionality (only in Morphic).') #(#browseWithPrettyPrint #false #(#browsing) 'browseWithPrettyPrint:		If true, browsers will automatically format their contents') #(#browserShowsPackagePane #false #(#browsing) 'browserShowsPackagePane:		If true, then the various ''browse full'' and ''browse it'' commands (usually invoked via cmd-b) will open a Package Browser rather than a System Browser.  The Package Browser includes a package pane which groups system categories into packages based on the initial portion of their category name.') #(#canRecordWhilePlaying #false #(#media) 'canRecordWhilePlaying:		If true, recording and playing sounds concurrently are permitted (platform dependent).') #(#capitalizedReferences #true #(#scripting) 'capitalizedReferences:		if true, then object references in scripts will appear as capitalized names, a scheme which makes scripts look ''right'' but which still requires some engineering') #(#caseSensitiveFinds #false #(#general) 'caseSensitiveFinds:		If true, then the "find" command in text will always make its searches in a case-sensitive fashion') #(#cautionBeforeClosing #false #(#windows) 'cautionBeforeClosing:		If true, Morphic windows seen in an mvc project will put up a warning before allowing themselves to be dismissed') #(#celesteHasStatusPane #false #(#general) 'celesteHasStatusPane:		If true, Celeste (e-mail reader) includes a status pane.') #(#changeSetVersionNumbers #true #(#fileout) 'changeSetVersionNumbers:		If true, version-number extensions will be used when constructing names for change-set fileouts.  If false, timestamp extensions are used.') #(#checkForSlips #true #(#fileout) 'checkForSlips:		If true, then whenever you file out a change set, it is checked for ''slips'' and if any are found, you are so informed and given a chance to open a browser on them') #(#checkForUnsavedProjects #true #(#general) 'checkForUnsavedProjects:		If enabled, then ask before quitting Squeak if there are unsaved projects (the definition of unsaved is fuzzy at the moment and this preference may not be honored everywhere)') #(#clickOnLabelToEdit #false #(#windows) 'clickOnLabelToEdit:		If true, a click on the label of a system window lets you edit it; if false, allow dragging of system windows when clicking on the label') #(#cmdDotEnabled #true #(#debug) 'cmdDotEnabled:		If true, cmd-dot brings up a debugger;if false, the cmd-dot interrupt is disabled') #(#colorWhenPrettyPrinting #false #(#browsing) 'colorWhenPrettyPrinting:		If true, then when browseWithPrettyPrint is in effect, the pretty-printing will be presented in color') #(#compactViewerFlaps #false #(#scripting) 'compactViewerFlaps:		Determines whether a viewer flap should fit tightly around the viewer') #(#compressFlashImages #false #(#media) 'compressFlashImages:		If true, flash images will automatically be reduced to 8-bit color depth upon being read') #(#confirmFirstUseOfStyle #true #(#browsing) 'confirmFirstUseOfStyle:		If true, the first attempt to submit a method with non-standard style will bring up a confirmation dialog') #(#conversionMethodsAtFileOut #false #(#fileout) 'conversionMethodsAtFileOut:		Governs whether at fileout time you should be prompted to define conversion methods where deemed appropriate.') #(#debugHaloHandle #true #(#debug #halos) 'debugHaloHandle:		If true, a special debugging halo handle is displayed at the right of the halo; if false, no such handle is shown.') #(#debugShowDamage #false #(#debug) 'debugShowDamage:		If true, every changed region of the morphic display will be flashed black before updating.') #(#decorateBrowserButtons #false #(#browsing) 'decorateBrowserButtons:		Governs whether certain buttons, such as the Inheritance button, should bear colors that provide user feedback on their applicability') #(#diffsInChangeList #true #(#browsing) 'diffsInChangeList:		If true, changeList browsers and Versions browsers will open up by default showing diffs, i.e. revealing the differences between successive versions or between the in-memory code and the code on disk') #(#diffsWithPrettyPrint #false #(#browsing) 'diffsWithPrettyPrint:		if true, displays of source code differences will be pretty-printed first') #(#dismissAllOnOptionClose #false #(#windows) 'dismissAllOnOptionClose:		Mac-specific: if true, then a click on a morphic SystemWindow''s close-box while the mac option is held down will result in a dismissal of all unchanged windows') #(#dragNDropWithAnimation #false #(#browsing) 'dragNDropWithAnimation:		If true, drag&drop is animated.') #(#eToyFriendly #false #(#scripting) 'eToyFriendly:		If true, then the system is configured in ways suitable for etoy users') #(#extractFlashInHighQuality #true #(#media) 'extractFlashInHighQuality:		Whether flash graphics should be extracted in high quality.') #(#extractFlashInHighestQuality #false #(#media) 'extractFlashInHighestQuality:		Whether flash graphics should be extracted in highest possible quality.') #(#fastDragWindowForMorphic #true #(#windows) 'fastDragWindowForMorphic:		If true, morphic window drag will be done by dragging an outline of the window.') #(#fenceEnabled #true #(#scripting) 'fenceEnabled:		Whether an object obeying motion scripts should stop moving when it reaches the edge of its container.') #(#fullScreenLeavesDeskMargins #true #(#windows) 'fullScreenLeavesDeskMargins:		If true, a Full Screen request to a Window to will leave margins around it. If false, the Window will fill the Screen unless the Global Flaps are showing.') #(#hiddenScrollBars #false #(#scrolling) 'hiddenScrollBars:		If true, then scrollbars will only be shown if a pane''s contents are too large to fit inside the pane.') #(#higherPerformance #false #(#performance) 'higherPerformance:		May offer higer performance at the expense of other applications on your computer. See the comment in EventSensor>>higherPerformanceNotes for more details. NOT advised when running in MVC!!') #(#ignoreStyleIfOnlyBold #true #(#browsing) 'ignoreStyleIfOnlyBold:		If true, then any method submission in which the only style change is for bolding will be treated as a method with no style specifications') #(#inboardScrollbars #false #(#scrolling) 'inboardScrollbars:		If true, then ScrollPane will place scrollbars inside on the right and will not hide them on exit') #(#infiniteUndo #false #(#general) 'infiniteUndo:		if true, then where supported you will be able to roll back to prior states via repeated uses of undo.  Undo history will be purged at save/quit') #(#logDebuggerStackToFile #true #(#debug) 'logDebuggerStackToFile:		If true, whenever you fall into a debugger a summary of its stack will be written to a file named''SqueakDebug.log''') #(#menuColorFromWorld #true #(#menus) 'menuColorFromWorld:		Governs whether the colors used in morphic menus should be derived from the color of the world background.') #(#modalColorPickers #true #(#general) 'modalColorPickers:		If true, color choices in Morphic will be made via color-pickers that take control of the mouse and immediately return the color selected upon mouseup') #(#mvcProjectsAllowed #true #(#general) 'mvcProjectsAllowed:		If true, the open... menu will offer you the chance to open an mvc project.') #(#noviceMode #false #(#general) 'noviceMode:		If true, certain novice-mode accommodations are made.') #(#okToReinitializeFlaps #true #(#morphic) 'okToReinitializeFlaps:		if true, then then code in updates will feel free to reinitialize the global flaps; if false, flaps will never be reinitialized by updates -- thus, set it to false if you have a serious investment in the content of the global flaps in your configuration, strong enough that you don''t want your flaps modernized when advances would otherwise indicate a need to') #(#oneViewerFlapAtATime #true #(#scripting) 'oneViewerFlapAtATime:		If true, opening up one viewer flap will close all other such flaps.') #(#optionalButtons #true #(#general) 'optionalButtons:		If true, then optional buttons will be used in certain standard tools, including browsers, message lists, fileLists, changeLists, and debuggers') #(#personalizedWorldMenu #true #(#menus) 'personalizedWorldMenu:		If true, then a right-click (Mac option-click) on the morphic desktop will bring up the customizable "personalized" menu; if false, then it will bring up the standard world menu.') #(#postscriptStoredAsEPS #false #(#printing) 'postscriptStoredAsEPS:		When printing a morph as PostScript, offers the choice of (true) an EPS file suitable for incorporating in a larger job or (false) a DSC file that is a standalone file') #(#preserveTrash #false #(#morphic) 'preserveTrash:		Whether morphs dismissed via halo or dragged into the Trash should be preserved in the TrashCan for possible future retrieval.  If false, they are not preserved.') #(#printAlternateSyntax #false #(#browsing) 'printAlternateSyntax:		If true, thenprettyPrint using experimental syntax.Otherwise use normal ST-80 syntax.') #(#projectViewsInWindows #true #(#general) 'projectViewsInWindows:		New Project view are created in a system window.') #(#projectZoom #true #(#general) 'projectZoom:		If true, then show a zoom effect when entering or leaving projects.  This can be costly of memory (at least an extra screen buffer) so dont use it in low space situations.  But it is cool.') #(#projectsSentToDisk #false #(#general) 'projectsSentToDisk:		If true, entering a new project swaps it in and swaps out other projects as appropriate. Projects are swapped in and out as ImageSegments, stored as files on disk in an image segment folder associated with the current image.') #(#promptForUpdateServer #true #(#updates) 'promptForUpdateServer:		If false, the prompt for server choice when updating code from the server is suppressed.  Set this to false to leave the server choice unchanged from update to update.') #(#reverseWindowStagger #true #(#windows) 'reverseWindowStagger:		If true, a reverse-stagger strategy  is used for determining where newly launched windows will be placed; if false, a direct- stagger strategy is used.') #(#roundedMenuCorners #true #(#menus) 'roundedMenuCorners:		Whether morphic menus should have rounded corners') #(#roundedWindowCorners #true #(#windows) 'roundedWindowCorners:		Governs whether morphic system windows should have rounded corners') #(#scrollBarsNarrow #true #(#scrolling) 'scrollBarsNarrow:		If true, morphic scrollbars will be narrow.') #(#scrollBarsOnRight #false #(#scrolling) 'scrollBarsOnRight:		If true, morphic scrollbars in subsequently opened windows will appear on the right side of their pane.') #(#scrollBarsWithoutMenuButton #false #(#menus #scrolling) 'scrollBarsWithoutMenuButton:		If true, morphic scrollbars in subsequently opened windows will not include a menu button.') #(#showBoundsInHalo #false #(#halos) 'showBoundsInHalo:		If true, halos will include a fine rectangle around the bounds of the target morph.') #(#showDirectionForSketches #false #(#halos) 'showDirectionForSketches:		If enabled, direction handles are always shown for SketchMorphs.  If disabled, direction handles can be shown by the ''show direction handles'' command in the red menu.') #(#showDirectionHandles #false #(#halos) 'showDirectionHandles:		If enabled, direction handles are always shown with halos.  If disabled, direction handles can be shown by the ''show direction handles'' command in the red menu.') #(#showFlapsWhenPublishing #false #(#publishing) 'showFlapsWhenPublishing:		If true, show global flaps and project navigator -- otherwise suppress both to give the illusion that we are still in the same project') #(#showProjectNavigator #true #(#morphic) 'showProjectNavigator:		If true, then show a nifty project navigator control in the world''s bottom left corner.') #(#simpleMenus #false #(#menus) 'simpleMenus:		If true, simpler menus are presented.') #(#smartUpdating #true #(#browsing) 'smartUpdating:		If true, then morphic tools such as browsers and inspectors will keep their contents up to date automatically, so that if something changes anywhere, the change will be reflected everywhere.') #(#soundQuickStart #false #(#media) 'soundQuickStart:		If true, attempt to start playing sounds using optional "quick start"') #(#soundStopWhenDone #false #(#media) 'soundStopWhenDone:		If true, the sound player is shut down after playing finished.') #(#soundsEnabled #true #(#media) 'soundsEnabled:		If false, all sound playing is disabled') #(#sourceCommentToggleInBrowsers #false #(#browsing) 'sourceCommentToggleInBrowsers:		If true, then optional button panes in code browsers in morphic will exhibit a checkbox labeled "source" which allows the user to toggle between viewing source code and just viewing method comments') #(#systemWindowEmbedOK #false #(#windows) 'systemWindowEmbedOK:		Determines whether, in Morphic, when a SystemWindow or MenuMorph is dropped onto a willing receptor, it should be deposited into that receptor.') #(#thoroughSenders #true #(#general) 'thoroughSenders:		If true, then ''senders'' browsers will dive inside structured literals in their search') #(#timeStampsInMenuTitles #false #(#menus) 'timeStampsInMenuTitles:		If true, then the author''s timestamp is displayed as the menu title of any message list; if false, no author''s timestamps are shown') #(#turnOffPowerManager #false #(#performance) 'turnOffPowerManager:		May offer higer performance at the expense of the life of your Battery (macintosh only in 3.VM)') #(#twentyFourHourFileStamps #true #(#fileout) 'twentyFourHourFileStamps:		If #changeSetVersionNumbers is false, this preference determines whether the date/time suffix used with changeset fileouts is based on a 24-hr clock or a 12-hr clock.') #(#uniqueNamesInHalos #false #(#halos) 'uniqueNamesInHalos:		if true, then when you put up a halo for any morph, it is assigned a unique name (if it doesn''t already have one) which will stick with it.') #(#unlimitedPaintArea #false #(#morphic) 'unlimitedPaintArea:		If true, the painting area for a new drawing will not be limited in size; if false, a reasonablelimit will be applied, in an attempt to hold down memory and time price.') #(#updateSavesFile #false #(#updates) 'updateSavesFile:		If true, then when an update is loaded from the server, a copy of it will automatically be saved on a local file as well.') #(#useGlobalFlaps #true #(#morphic) 'useGlobalFlaps:		If true, then flaps are shown along the edges of Morphic projects.') #(#useUndo #true #(#general) 'useUndo:		if true, then undo will generally be available in morphic') #(#viewersInFlaps #true #(#scripting) 'viewersInFlaps:		If true, viewers are projected into flaps along the right edge of the screen') #(#warnIfNoChangesFile #true #(#general) 'warnIfNoChangesFile:		If true, then you will be warned, whenever you start up, if no changes filecan be found') #(#warnIfNoSourcesFile #true #(#general) 'warnIfNoSourcesFile:		If true, then you will be warned, whenever you start up, if no sources file can be found') )! !!PreferencesPanel methodsFor: 'initialization' stamp: 'sw 2/6/2001 02:13'!addModelItemsToWindowMenu: aMenu	"aMenu is being constructed to be presented to the user in response to the user's pressing on the menu widget in the title bar of a morphic SystemWindow.  Here, the model is given the opportunity to add any model-specific items to the menu, whose default target is the SystemWindow itself."	true ifTrue: [^ self].  	"The below are provisionally disenfranchised, because their function is now directly available in the ? category"	aMenu addLine.	aMenu add: 'find preference... (f)' target: self action: #findPreference:.	aMenu add: 'inspect parameters' target: Preferences action: #inspectParameters! !!PreferencesPanel methodsFor: 'halo pane' stamp: 'sw 2/16/2001 12:00'!addHaloControlsTo: controlPage	"Add special controls relating to halo schemes to the page"	| aButton |	controlPage addTransparentSpacerOfSize: (0 @ 4).	controlPage addMorphBack: self haloThemeRadioButtons.	controlPage addTransparentSpacerOfSize: (0 @ 4).	aButton _ SimpleButtonMorph new target: Preferences; color: Color transparent; actionSelector: #editCustomHalos; label: 'Edit custom halos'.	controlPage addMorphBack: aButton.	aButton setBalloonText: 'Click here to edit the method that defines the custom halos'.			! !!PreferencesPanel methodsFor: 'find' stamp: 'sw 2/17/2001 04:56'!addHelpItemsTo: panelPage	"Add special items to the page"	| aButton aTextMorph aMorph firstTextMorph |	panelPage hResizing: #shrinkWrap; vResizing: #shrinkWrap.	firstTextMorph _  TextMorph new contents: 'Search Preferences for:'.	firstTextMorph beAllFont: ((TextStyle default fontOfSize: 13) emphasized: 1).	panelPage addMorphBack: firstTextMorph lock.	panelPage addTransparentSpacerOfSize: 0@10.	aMorph _ RectangleMorph new clipSubmorphs: true; beTransparent; borderWidth: 2; borderColor: Color black; extent: 250 @ 36.	aMorph vResizing: #rigid; hResizing: #rigid.	aTextMorph _  PluggableTextMorph new				on: self				text: #searchString				accept: #setSearchStringTo:				readSelection: nil				menu: nil."	aTextMorph hResizing: #rigid."	aTextMorph borderWidth: 0.	aTextMorph font: ((TextStyle default fontOfSize: 21) emphasized: 1); setTextColor: Color red.	aMorph addMorphBack: aTextMorph.	aTextMorph acceptOnCR: true.	aMorph clipLayoutCells: true.	aTextMorph width: 250.	panelPage addMorphBack: aMorph.	aTextMorph setBalloonText: 'Type what you want to search for here, then hit the "Search" button'.	panelPage addTransparentSpacerOfSize: 0@10.	aButton _ SimpleButtonMorph new target: self; color: Color transparent; actionSelector: #initiateSearch:; arguments: {aTextMorph}; label: 'Search'.	panelPage addMorphBack: aButton.	aButton setBalloonText: 'Type what you want to search for in the box above, then click here (or hit RETURN or ENTER) to start the search; results will appear in the "search results" category.'.	panelPage addTransparentSpacerOfSize: 0@40.	panelPage addMorphBack: (SimpleButtonMorph new color: Color transparent; label: 'Restore all Default Preference Settings'; target: Preferences; actionSelector: #chooseInitialSettings; setBalloonText: 'Click here to reset all the preferences to their standard default values.'; yourself).	panelPage addTransparentSpacerOfSize: 0@14.	panelPage addMorphBack: (SimpleButtonMorph new color: Color transparent; label: 'Save Current Settings as my Personal Preferences'; 		target: Preferences; actionSelector: #savePersonalPreferences; setBalloonText: 'Click here to save the current constellation of Preferences settings as your personal defaults; you can get them all reinstalled with a single gesture by clicking the "Restore my Personal Preferences".'; yourself).	panelPage addTransparentSpacerOfSize: 0@14.	panelPage addMorphBack: (SimpleButtonMorph new color: Color transparent; label: 'Restore my Personal Preferences'; target: Preferences; actionSelector: #restorePersonalPreferences; setBalloonText: 'Click here to reset all the preferences to their values in your Personal Preferences.'; yourself).	panelPage addTransparentSpacerOfSize: 0@30.	panelPage addMorphBack: (SimpleButtonMorph new color: Color transparent; label: 'Inspect Parameters'; target: Preferences; actionSelector: #inspectParameters; setBalloonText: 'Click here to view all the values stored in the system Parameters dictionary'; yourself).	panelPage addTransparentSpacerOfSize: 0@10.	panelPage addMorphBack: (SimpleButtonMorph new color: Color transparent; label: 'Help!!'; target: Preferences; actionSelector: #giveHelpWithPreferences; setBalloonText: 'Click here to get some hints on use of this Preferences Panel'; yourself).	panelPage wrapCentering: #center.! !!PreferencesPanel methodsFor: 'find' stamp: 'sw 2/4/2001 03:31'!findPreference: evt	"Allow the user to submit a selector fragment; search for that among preference names; put up a list of qualifying preferences; if the user selects one of those, redirect the preferences panel to reveal the chosen preference"	self findPreferencesMatching: (FillInTheBlank request: 'Search for preferences containing:' initialAnswer: 'color')! !!PreferencesPanel methodsFor: 'find' stamp: 'sw 2/6/2001 04:16'!findPreferencesMatching: incomingTextOrString	"find all preferences matching incomingTextOrString"	| result aList aPalette controlPage |	result _ incomingTextOrString asString asLowercase.	result _ result asLowercase copyWithout: $ .	result isEmptyOrNil ifTrue: [^ self].	aList _ Preferences allPreferenceFlagKeys select:		[:aKey | 			aKey includesSubstring: result caseSensitive: false].	aPalette _ self dependents first containingWindow findDeeplyA: TabbedPalette.	aPalette ifNil: [^ self].	aPalette selectTabNamed:  'search results'.	aPalette currentPage ifNil: [^ self].  "bkwd compat"	controlPage _ aPalette currentPage.	controlPage removeAllMorphs.	controlPage addMorph: (StringMorph contents: ('Preferences matching "', self searchString, '"') font: Preferences standardButtonFont).	aList do:		[:aPrefSymbol |			controlPage addMorphBack: (Preferences								buttonRepresenting: aPrefSymbol								wording: aPrefSymbol								color: nil)].	aPalette world startSteppingSubmorphsOf: aPalette."	result _ (SelectionMenu selections: aList) startUpWithCaption: 'Choose which Preference you want to find'.	Preferences factoredCategories do:		[:aCategoryPair |			(aCategoryPair second includes: result)				ifTrue:					[^ self switchToCategoryNamed: aCategoryPair first event: evt]]"! !!PreferencesPanel methodsFor: 'find' stamp: 'sw 2/6/2001 02:01'!findPreferencesMatchingSearchString	"find all preferences matching incomingTextOrString"	self findPreferencesMatching: self searchString! !!PreferencesPanel methodsFor: 'find' stamp: 'sw 2/6/2001 02:03'!initiateSearch: morphHoldingSearchString	"Carry out the action of the Search button in the Preferences panel"	searchString _ morphHoldingSearchString text.	self findPreferencesMatchingSearchString! !!PreferencesPanel methodsFor: 'find' stamp: 'sw 2/6/2001 02:06'!keyStroke: anEvent	"Handle a keystroke event in the panel; we map f (for find) into a switch to the ? category"	(anEvent keyCharacter == $f) ifTrue:		[^ self switchToCategoryNamed: #? event: nil]! !!PreferencesPanel methodsFor: 'find' stamp: 'sw 2/6/2001 02:18'!searchString	"Answer the current searchString, initializing it if need be"	^  searchString ifNil: [searchString _ 'brows']! !!PreferencesPanel methodsFor: 'find' stamp: 'sw 2/6/2001 01:45'!setSearchStringTo: aText	"The user submitted aText as the search string; now search for it"	searchString _ aText asString.	self findPreferencesMatching: searchString.	^ true! !!Presenter methodsFor: 'palette & parts bin' stamp: 'RAA 2/7/2001 06:44'!newStandardPartsBinTitled: aTitle includeControls: includeControls	| aBook aPage aSize |	aSize _ 360 @ 190.	aBook _ BookMorph new color: Color blue veryMuchLighter.	aBook borderWidth: 0.	aBook removeEverything.	aBook disableDragNDrop.	includeControls ifTrue:		[aBook addMorphBack: (aBook makeMinimalControlsWithColor: Color transparent title: aTitle)].	self classNamesForStandardPartsBin do:		[:aList |			aPage _ self newPageForStandardPartsBin.			aList do:				[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].			aPage replaceTallSubmorphsByThumbnails.			aBook insertPage: aPage pageSize: aSize].	self customPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	self tilesPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	aBook goToPage: 1.	aBook currentPage addMorphBack: RectangleMorph roundRectPrototype.	aBook fullBounds.		"be sure we are set"	^ aBook! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 2/12/2001 22:02'!systemQueryPhraseWithActionString: anActionString labelled: aLabel	"Answer a SystemQueryPhrase with the given action string and label"	| aTile aPhrase |		aPhrase _ SystemQueryPhrase new.	aTile _ BooleanTile new.	aTile setExpression: anActionString label: aLabel.	aPhrase addMorph: aTile.	aPhrase enforceTileColorPolicy.	^ aPhrase! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 2/12/2001 21:31'!tilesPagesForPartsBin	"Answer a list of pages holding tiles for the Parts Bin.  At present, there is only one page"	| aPage bools aTile aPhrase |	aPage _ self newPageForStandardPartsBin padding: 30.	aPage cellInset: 10 @ 10; listSpacing: #equal.	bools _ self booleanTiles.	aPage addMorphBack: bools first markAsPartsDonor.	aPage addMorphBack: bools last markAsPartsDonor.	aPage addMorphBack: self arithmeticTiles first markAsPartsDonor.	aPage addMorphBack: RandomNumberTile new markAsPartsDonor.	#(('(Sensor anyButtonPressed)' 'button down?')	('(Sensor noButtonPressed)' 'button up?')	"('(Sensor keyboardPressed)' 'key hit?')   sucker doesn't work for some reason") do:		[:pair |			aPhrase _ SystemQueryPhrase new.			aTile _ BooleanTile new.			aTile setExpression: pair first label: pair second.			aPhrase addMorph: aTile.			aPage addMorphBack: aPhrase].	aPage enforceTileColorPolicy.	aPage replaceTallSubmorphsByThumbnails.	^ OrderedCollection with: aPage  "room to grow"! !!Presenter methodsFor: 'tile support' stamp: 'sw 2/12/2001 21:30'!phraseForReceiver: rcvr op: op arg: arg resultType: resultType	"Answer a PhraseTileMorph affiliated with the given receiver, initialized to hold the given operator, argument, and result type"	| m argTile rcvrTile |	arg == nil		ifTrue:			[m _ PhraseTileMorph new setOperator: op				type: resultType				rcvrType: (self typeForConstant: rcvr)]		ifFalse:			[m _ PhraseTileMorph new setOperator: op				type: resultType				rcvrType: (self typeForConstant: rcvr)				argType: (self typeForConstant: arg).			argTile _ self constantTile: arg.			argTile position: m lastSubmorph position.			m lastSubmorph addMorph: argTile].	rcvrTile _ self constantTile: rcvr."	TilePadMorph makeReceiverColorOfResultType ifTrue: [rcvrTile color: m color]."	rcvrTile position: m firstSubmorph position.	m firstSubmorph addMorph: rcvrTile.	m vResizing: #shrinkWrap.	^ m! !!Presenter methodsFor: 'viewer' stamp: 'tk 2/12/2001 16:37'!cacheSpecs: aMorph	"For SyntaxMorph's type checking, cache the list of all viewer command specifications."	aMorph world ifNil: [^ true].	(aMorph world valueOfProperty: #universalTiles ifAbsent: [false]) ifFalse: [^ true].	Preferences eToyFriendly ifFalse: [^ true].	"not checking"	(Project current projectParameters at: #fullCheck ifAbsent: [false]) 			ifFalse: [^ true].	"not checking"		SyntaxMorph initialize.! !!Presenter methodsFor: 'viewer' stamp: 'tk 2/12/2001 16:38'!viewMorph: aMorph	| aPlayer aViewer aPalette aRect aPoint nominalHeight aFlapTab topItem flapLoc |	Sensor leftShiftDown ifFalse:		[((aPalette _ aMorph standardPalette) ~~ nil and: [aPalette isInWorld])			ifTrue:	[^ aPalette viewMorph: aMorph]].	aPlayer _ (topItem _ aMorph topRendererOrSelf) assuredPlayer.	aViewer _ self nascentPartsViewer.	self cacheSpecs: topItem.		"redo the spec cache once in a while"	"19 sept 2000 - allow flaps in any paste up"	flapLoc _ associatedMorph "world".	Preferences viewersInFlaps ifTrue:		[aViewer setProperty: #noInteriorThumbnail toValue: true.		aViewer initializeFor: aPlayer barHeight: 0.		aViewer enforceTileColorPolicy.		aViewer fullBounds. "force layout"		"associatedMorph addMorph: aViewer."		"why???"		flapLoc hideViewerFlapsOtherThanFor: aPlayer.		aFlapTab _ flapLoc viewerFlapTabFor: topItem.		aFlapTab referent submorphs do: 			[:m | (m isKindOf: Viewer) ifTrue: [m delete]].		aViewer visible: true.		aFlapTab applyThickness: aViewer width + 25.		aFlapTab spanWorld.		aFlapTab showFlap. 		aViewer position: aFlapTab referent position.		aFlapTab referent addMorph: aViewer beSticky.		"moved"		flapLoc startSteppingSubmorphsOf: aFlapTab.		flapLoc startSteppingSubmorphsOf: aViewer.		^ aFlapTab].			aViewer initializeFor: aPlayer barHeight: 6.	aViewer enforceTileColorPolicy.	aViewer fullBounds. "force layout"	Preferences automaticViewerPlacement ifTrue:		[aPoint _ aMorph bounds right @ 			(aMorph center y - ((nominalHeight _ aViewer initialHeightToAllow) // 2)).		aRect _ (aPoint extent: (aViewer width @ nominalHeight)) translatedToBeWithin: flapLoc bounds.		aViewer position: aRect topLeft.		aViewer visible: true.		associatedMorph addMorph: aViewer.		flapLoc startSteppingSubmorphsOf: aViewer.		"it's already in the world, somewhat coincidentally"		^ aViewer].	aMorph primaryHand attachMorph: (aViewer visible: true).	^ aViewer! !!Process methodsFor: 'changing process state' stamp: 'tpr 2/14/2001 10:00'!primitiveResume	"Primitive. Allow the process that the receiver represents to continue. Put 	the receiver in line to become the activeProcess. Fail if the receiver is 	already waiting in a queue (in a Semaphore or ProcessScheduler). 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 87>	self primitiveFailed! !!Process methodsFor: 'changing process state' stamp: 'tpr 2/14/2001 10:03'!resume	"Allow the process that the receiver represents to continue. Put  	the receiver in line to become the activeProcess. Check for a nil 	suspendedContext, which indicates a previously terminated Process that 	would cause a vm crash if the resume attempt were permitted"	suspendedContext ifNil: [^ self primitiveFailed].	^ self primitiveResume! !!ProcessBrowser methodsFor: 'accessing' stamp: 'nk 2/16/2001 13:39'!selectedMethod	^ methodText ifNil: [methodText _ selectedContext						ifNil: ['']						ifNotNil: [| pcRange | 							methodText _ [ selectedContext sourceCode ]								ifError: [ :err :rcvr | 'error getting method text' ].							pcRange _ self pcRange.							methodText asText								addAttribute: TextColor red								from: pcRange first								to: pcRange last;																addAttribute: TextEmphasis bold								from: pcRange first								to: pcRange last]]! !!ProcessBrowser methodsFor: 'process actions' stamp: 'nk 2/16/2001 13:45'!nameAndRulesFor: aProcess 	"Answer a nickname and two flags: allow-stop, and allow-debug"	(aProcess priority = Processor timingPriority			and: [aProcess suspendedContext receiver == Delay])		ifTrue: [^ {'the timer interrupt watcher'. false. false}].	^ [ aProcess caseOf: {		[] -> [{'no process'. false. false}].		[autoUpdateProcess] -> [{'my auto-update process'. true. true}].		[Smalltalk lowSpaceWatcherProcess] -> [{'the low space watcher'. false. false}].		[WeakArray runningFinalizationProcess] -> [{'the WeakArray finalization process'. false. false}].		[Processor activeProcess] -> [{'the UI process'. false. true}].		[Processor backgroundProcess] -> [{'the idle process'. false. false}].		[Sensor inputProcess] -> [{'the I/O process'. false. false}].		[Sensor interruptWatcherProcess] -> [{'the user interrupt watcher'. false. false}].		[Project uiProcess] -> [{'the inactive Morphic UI process'. false. false}].		[SoundPlayer playerProcess] -> [{'the Sound Player'. false. false}].		[ScheduledControllers ifNotNil: [ ScheduledControllers activeControllerProcess ] ] -> [{'the inactive MVC controller process'. false. true}]}		 otherwise: [{aProcess suspendedContext asString. true. true}] ]			ifError: [ :err :rcvr | {aProcess suspendedContext asString. true. true} ]! !!Project methodsFor: 'accessing' stamp: 'RAA 2/12/2001 16:17'!findProjectView: projectDescription	| pName dpName proj |	"In this world, find the morph that holds onto the project described by projectDescription.  projectDescription can be a project, or the name of a project.  The project may be represented by a DiskProxy.  The holder morph may be at any depth in the world.	Need to fix this if Projects have subclasses, or if a class other than ProjectViewMorph can officially hold onto a project.  (Buttons, links, etc)	If parent is an MVC world, return the ProjectController."	self flag: #bob.		"read the comment"	pName _ (projectDescription isKindOf: String) 		ifTrue: [projectDescription]		ifFalse: [projectDescription name].	self isMorphic 		ifTrue: [world allMorphsDo: [:pvm |				pvm class == ProjectViewMorph ifTrue: [					(pvm project class == Project and: 						[pvm project name = pName]) ifTrue: [^ pvm].					pvm project class == DiskProxy ifTrue: [ 						dpName _ pvm project constructorArgs first.						dpName _ (dpName findTokens: '/') last.						dpName _ (Project parseProjectFileName: dpName unescapePercents) first.						dpName = pName ifTrue: [^ pvm]]]]]		ifFalse: [world scheduledControllers do: [:cont |				(cont isKindOf: ProjectController) ifTrue: [					((proj _ cont model) class == Project and: 						[proj name = pName]) ifTrue: [^ cont view].					proj class == DiskProxy ifTrue: [ 						dpName _ proj constructorArgs first.						dpName _ (dpName findTokens: '/') last.						dpName _ (Project parseProjectFileName: dpName unescapePercents) first.						dpName = pName ifTrue: [^ cont view]]]]			].	^ nil! !!Project methodsFor: 'menu messages' stamp: 'sw 2/12/2001 11:46'!assureNavigatorPresenceMatchesPreference	"Make sure that the current project conforms to the presence/absence of the navigator"	| navigator navType wantIt |	Smalltalk isMorphic ifFalse: [^ self].	wantIt _ Preferences showProjectNavigator.	navType _ ProjectNavigationMorph preferredNavigator.	navigator _ world findA: navType.	wantIt		ifFalse:			[navigator ifNotNil: [navigator delete]]		ifTrue:			[navigator isNil ifTrue: 				[(navigator _ navType new)					bottomLeft: world bottomLeft;					openInWorld: world]]! !!Project methodsFor: 'menu messages' stamp: 'RAA 2/6/2001 14:18'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg newProcess |	(world isKindOf: StringMorph) ifTrue: [		self inform: 'This project is not all here. I will try to load a complete version.'.		^self loadFromServer: true	"try to get a fresh copy"	].	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [			CurrentProject finalExitActions.			CurrentProject makeThumbnail.			returningFlag == #specialReturn ifTrue: [				ProjectHistory forget: CurrentProject.		"this guy is irrelevant"				Project forget: CurrentProject.			] ifFalse: [				ProjectHistory remember: CurrentProject.			].		].	(revertFlag | saveForRevert | forceRevert) ifFalse: [		(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [			self storeToMakeRoom]].	Smalltalk isMorphic ifTrue: [Display bestGuessOfCurrentWorld triggerClosingScripts].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 					playerClass allSubInstancesDo: [:player | player pause]]].	returningFlag == #specialReturn ifTrue: [		old removeChangeSetIfPossible.	"keep this stuff from accumulating"		nextProject _ nil	] ifFalse: [		returningFlag			ifTrue: [nextProject _ CurrentProject]			ifFalse: [previousProject _ CurrentProject].	].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil _ Display pauseMorphicEventRecorder].	ProjectHistory remember: CurrentProject.	world isMorph		ifTrue:			[Display changeMorphicWorldTo: world.  "Signifies Morphic"			world install.			world transferRemoteServerFrom: old world.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: world].			world triggerOpeningScripts]		ifFalse:			[Display changeMorphicWorldTo: nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph ifTrue: [		self finalEnterActions.		world repairEmbeddedWorlds.		Project spawnNewProcessAndTerminateOld: true	] ifFalse: [		SystemWindow clearTopWindow.	"break external ref to this project"		newProcess _ [				ScheduledControllers resetActiveController.	"in case of walkback in #restore"			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController		] fixTemps newProcess priority: Processor userSchedulingPriority.		newProcess resume.		"lose the current process and its referenced morphs"		Processor terminateActive.	]! !!Project methodsFor: 'menu messages' stamp: 'RAA 2/13/2001 21:12'!finalEnterActions	| navigator armsLengthCmd navType thingsToUnhibernate |	thingsToUnhibernate _ world valueOfProperty: #thingsToUnhibernate ifAbsent: [#()].	thingsToUnhibernate do: [ :each | each unhibernate].	world removeProperty: #thingsToUnhibernate.	navType _ ProjectNavigationMorph preferredNavigator.	armsLengthCmd _ self parameterAt: #armsLengthCmd ifAbsent: [nil].	navigator _ world findA: navType.	Preferences showProjectNavigator & navigator isNil ifTrue: [		(navigator _ navType new)			bottomLeft: world bottomLeft;			openInWorld: world.	].	navigator notNil & armsLengthCmd notNil ifTrue: [		navigator color: Color lightBlue	].	armsLengthCmd notNil ifTrue: [		Preferences showFlapsWhenPublishing			ifFalse:[self flapsSuppressed: true.					navigator ifNotNil:[navigator visible: false]].		armsLengthCmd openInWorld: world	].! !!Project methodsFor: 'menu messages' stamp: 'RAA 2/6/2001 14:21'!finalExitActions	| navigator |	world isMorph ifTrue: [		navigator _ world findA: ProjectNavigationMorph.		navigator ifNotNil: [navigator retractIfAppropriate].	].! !!Project methodsFor: 'menu messages' stamp: 'RAA 2/14/2001 16:30'!makeThumbnail	"Make a thumbnail image of this project from the Display."	world isMorph ifTrue: [world displayWorldSafely]. "clean pending damage"	viewSize ifNil: [viewSize _ Display extent // 8].	thumbnail _ Form extent: viewSize depth: Display depth.	(WarpBlt current toForm: thumbnail)			sourceForm: Display;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (Display boundingBox) innerCorners			toRect: (0@0 extent: viewSize).	^thumbnail! !!Project methodsFor: 'menu messages' stamp: 'raa 2/8/2001 10:39'!saveState	"Save the current state in me prior to leaving this project"	changeSet _ Smalltalk changes.	thumbnail ifNotNil: [thumbnail hibernate].	Smalltalk isMorphic		ifTrue:			[world _ Display bestGuessOfCurrentWorld.			world sleep]		ifFalse:			[world _ ScheduledControllers.			ScheduledControllers unCacheWindows].	Sensor eventQueue: nil. "Will be reinstalled by World>>install"	transcript _ Transcript.! !!Project methodsFor: 'file in/out' stamp: 'ar 2/6/2001 19:17'!storeOnServerInnards	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	| servers resp newName primaryServerDirectory serverVersionPair localDirectory localVersionPair myVersionNumber warning maxNumber |	self assureIntegerVersion.	"Find out what version"	(servers _ self serverList) ifNil: [		(primaryServerDirectory _ self findAFolderToStoreProjectIn) ifNotNil: [			servers _ Array with: primaryServerDirectory.			self storeNewPrimaryURL: primaryServerDirectory realUrl, '/'.		].	] ifNotNil: [		primaryServerDirectory _ servers first.	].	localDirectory _ self squeakletDirectory.	serverVersionPair _ self class mostRecent: self name onServer: primaryServerDirectory.	localVersionPair _ self class mostRecent: self name onServer: localDirectory.	maxNumber _ myVersionNumber _ self currentVersionNumber.	ProgressNotification signal: '2:versionsDetected'.	warning _ ''.	myVersionNumber < serverVersionPair second ifTrue: [		warning _ warning,'\There are newer version(s) on the server'.		maxNumber _ maxNumber max: serverVersionPair second.	].	myVersionNumber < localVersionPair second ifTrue: [		warning _ warning,'\There are newer version(s) in the local directory'.		maxNumber _ maxNumber max: localVersionPair second.	].	"8 Nov 2000 - only check on the first attempt to publish"	myVersionNumber = 0 ifTrue: [		warning isEmpty ifFalse: [			myVersionNumber = 0 ifTrue: [				warning _ warning,'\THIS PROJECT HAS NEVER BEEN SAVED'			].			warning _ 'WARNING', '\Project: ',self name,warning.			resp _ (PopUpMenu labels: 'Store anyway\Cancel' withCRs) startUpWithCaption: 				(warning, '\Please cancel, rename this project, and see what is there.') withCRs.				resp ~= 1 ifTrue: [^ nil]		].	].	version _ self bumpVersion: maxNumber.	"write locally - now zipped automatically"	newName _ self versionedFileName.	lastSavedAtSeconds _ Time totalSeconds.	self exportSegmentFileName: newName directory: localDirectory.	SecurityManager default signFile: newName directory: localDirectory.	ProgressNotification signal: '4:localSaveComplete'.	"3 is deep in export logic"	primaryServerDirectory ifNotNil: [		self			writeFileNamed: newName 			fromDirectory: localDirectory 			toServer: primaryServerDirectory.	].	ProgressNotification signal: '9999 save complete'.	"Later, store with same name on secondary servers.  Still can be race conditions.  All machines will go through the server list in the same order."	"2 to: servers size do: [:aServer | aServer putFile: local named: newName]."! !!ProjectLoading class methodsFor: 'as yet unclassified' stamp: 'ar 2/6/2001 19:12'!openFromFile: preStream fromDirectory: aDirectoryOrNil withProjectView: existingView	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world." 	| morphOrList proj trusted |	ProgressNotification signal: '2:fileSizeDetermined ',preStream size printString.	trusted _ SecurityManager default positionToSecureContentsOf: preStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) ifFalse:[		(preStream respondsTo: #close) ifTrue:[preStream close].		^self]].	morphOrList _ preStream asUnZippedStream.	preStream sleep.		"if ftp, let the connection close"	ProgressNotification  signal: '3:unzipped'.	morphOrList _ morphOrList fileInObjectAndCode.	ProgressNotification  signal: '4:filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj _ morphOrList arrayOfRoots 			detect: [:mm | mm class == Project] 			ifNone: [^self inform: 'No project found in this file'].		proj versionFrom: preStream.		proj lastDirectory: aDirectoryOrNil.		CurrentProjectRefactoring currentBeParentTo: proj.		existingView ifNil: [			Smalltalk isMorphic ifTrue: [				proj createViewIfAppropriate.			] ifFalse: [				ProjectView openAndEnter: proj.				"Note: in MVC we get no further than the above"			].		] ifNotNil: [			(existingView project isKindOf: DiskProxy) ifFalse: [				existingView project changeSet name: ChangeSet defaultName			].			"proj changeSet name: otherProjectName."	"<<< why would we need this?"			(existingView owner isKindOf: SystemWindow) ifTrue: [				existingView owner model: proj			].			existingView project: proj.		].		^ ProjectEntryNotification signal: proj	].	(morphOrList isKindOf: SqueakPage) ifTrue: [		morphOrList _ morphOrList contentsMorph	].	(morphOrList isKindOf: PasteUpMorph) ifFalse: [		^ self inform: 'This is not a PasteUpMorph or exported Project.'	].	(Project newMorphicOn: morphOrList) enter! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/17/2001 12:46'!currentNavigatorVersion	^20		"since these guys get saved, we fix them up if they are older versions"! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/6/2001 14:16'!retractIfAppropriate	mouseInside _ false.	self positionVertically.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/17/2001 12:44'!showMenuFor: aSymbol event: evt	(aSymbol == #publishProject or: [aSymbol == #publishProjectSimple]) ifTrue: [		self doPublishButtonMenuEvent: evt.		^true		"we did show the menu"	].	(aSymbol == #findAProject or: [aSymbol == #findAProjectSimple]) ifTrue: [		self doFindButtonMenuEvent: evt.		^true		"we did show the menu"	].	^false! !!ProjectNavigationMorph methodsFor: 'the buttons' stamp: 'RAA 2/17/2001 12:27'!buttonFind	^self makeButton: 'FIND' balloonText: 'Find a project' for: #findAProjectSimple! !!ProjectNavigationMorph methodsFor: 'the buttons' stamp: 'RAA 2/17/2001 12:43'!buttonPublish	^self makeButton: 'PUBLISH IT!!' balloonText: 'Publish this project. Save it where it came from (server, hard disk, etc.) ' for: #publishProjectSimple! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'RAA 2/17/2001 12:28'!doFindButtonMenuEvent: evt	| menu selection |	menu _ CustomMenu new.	menu 		add: 'find a project' action: [self findAProjectSimple];		add: 'find a project (more places)' action: [self findAProject];		add: 'find any file' action: [self findAnything];		add: 'search the SuperSwiki' action: [self findSomethingOnSuperSwiki].	selection _ menu build startUpCenteredWithCaption: 'Find options'.	selection ifNil: [^self].	selection value.! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'RAA 2/17/2001 12:43'!doPublishButtonMenuEvent: evt	| menu selection |	menu _ CustomMenu new.	menu 		add: 'publish normally' action: [self publishProjectSimple];		add: 'publish normally (more choices)' action: [self publishProject];		add: 'publish to different server' action: [self publishDifferent];		add: 'edit project info' action: [self editProjectInfo].	selection _ menu build startUpCenteredWithCaption: 'Publish options'.	selection ifNil: [^self].	selection value.! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'RAA 2/17/2001 12:27'!findAProject	FileList2 		morphicViewProjectLoader2InWorld: self world 		reallyLoad: true		dirFilterType: #initialDirectoryList! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'RAA 2/17/2001 12:27'!findAProjectSimple	FileList2 		morphicViewProjectLoader2InWorld: self world 		reallyLoad: true		dirFilterType: #limitedSuperSwikiDirectoryList! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'RAA 2/17/2001 12:55'!publishDifferent	self publishStyle: #initialDirectoryList forgetURL: true! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'RAA 2/17/2001 12:55'!publishProject	self publishStyle: #initialDirectoryList forgetURL: false! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'RAA 2/17/2001 12:55'!publishProjectSimple	self publishStyle: #limitedSuperSwikiPublishDirectoryList forgetURL: false! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'RAA 2/17/2001 12:54'!publishStyle: aSymbol forgetURL: aBoolean	| w |	w _ self world ifNil: [^1 beep].	w setProperty: #SuperSwikiPublishOptions toValue: aSymbol.	w project 		storeOnServerShowProgressOn: self 		forgetURL: aBoolean.! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/14/2001 16:30'!addControls	| b r partsBinButton newButton |	b _ SimpleButtonMorph new 		target: self;		color: self myColor darker;		borderColor: Color black.	newButton _ ImageMorph new image: (World project makeThumbnail scaledToSize: 24@18).	newButton on: #mouseDown send: #insertNewProject: to: self.	newButton setBalloonText: 'Make a new Project'.	(partsBinButton _ UpdatingThreePhaseButtonMorph checkBox)		target: self;		actionSelector: #togglePartsBinStatus;		arguments: #();		getSelector: #getPartsBinStatus.	r _ AlignmentMorph newRow		color: Color transparent;		borderWidth: 0;		layoutInset: 0;		wrapCentering: #center;		cellPositioning: #topCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		extent: 5@5;		addMorphBack: (self wrapperFor: (b fullCopy label: 'Okay';	actionSelector: #acceptSort));		addMorphBack: (self wrapperFor: (b fullCopy label: 'Cancel';	actionSelector: #delete));		addMorphBack: (self wrapperFor: (newButton));		addTransparentSpacerOfSize: 8 @ 0;		addMorphBack: (self wrapperFor: partsBinButton);		addMorphBack: (self wrapperFor: (StringMorph contents: 'Parts bin') lock).	self addMorphFront: r.! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/6/2001 14:24'!clickFromSorterEvent: evt morph: aMorph	(aMorph bounds containsPoint: evt cursorPoint) ifFalse: [^self].	evt isMouseUp ifFalse: [		evt shiftPressed ifFalse: [^evt hand grabMorph: aMorph].		^self	].	evt shiftPressed ifTrue: [		WorldState addDeferredUIMessage: [			InternalThreadNavigationMorph openThreadNamed: book threadName		].		(Project named: (aMorph valueOfProperty: #nameOfThisProject)) enter.	].! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 12:00'!initialize	super initialize.	self useRoundedCorners.	color _ self myColor.	borderWidth _ 0.	pageHolder 		useRoundedCorners;		borderWidth: 0;		color: (			self 				gridFormOrigin: 0@0 				grid: 16@16 				background: Color white 				line: Color blue muchLighter		)! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 15:55'!insertNewProject: evt	| newProj |	[newProj _ Project newMorphicOn: nil.]		on: ProjectViewOpenNotification		do: [ :ex | ex resume: false].		EToyProjectDetailsMorph 		getFullInfoFor: newProj		ifValid: [			evt hand attachMorph: (self sorterMorphForProjectNamed: newProj name)		]		expandedFormat: false.! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 15:40'!morphsForMyContentsFrom: listOfPages sizedTo: sz	| morphsForPageSorter |	'Assembling thumbnail images...'		displayProgressAt: self cursorPoint		from: 0 to: listOfPages size		during: [:bar |			morphsForPageSorter _ listOfPages withIndexCollect: [ :each :index | 				bar value: index.				self sorterMorphForProjectNamed: each first			].		].	^morphsForPageSorter! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 11:25'!myColor	^Color r: 0.365 g: 0.634 b: 0.729! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 16:20'!navigator: aThreadNavigator listOfPages: listOfPages	| morphsForPageSorter pixelsAvailable pixelsNeeded scale |	"a bit of fudging to try to outguess the layout mechanism and get best possible scale"	pixelsAvailable _ Display extent - 130.	pixelsAvailable _ pixelsAvailable x * pixelsAvailable y.	pixelsNeeded _ 100@75.	pixelsNeeded _ pixelsNeeded x * pixelsNeeded y  * listOfPages size.	scale _ (pixelsAvailable / pixelsNeeded min: 1) sqrt.	sizeOfEachMorph _ (100@75 * scale) rounded.	morphsForPageSorter _ self morphsForMyContentsFrom: listOfPages sizedTo: sizeOfEachMorph.	morphsForPageSorter _ morphsForPageSorter reject: [ :each | each isNil].	self changeExtent: Display extent.	self		book: aThreadNavigator 		morphsToSort: morphsForPageSorter.	pageHolder 		cursor: aThreadNavigator currentIndex;		fullBounds;		hResizing: #rigid..! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 15:38'!sorterMorphForProjectNamed: projName	| pvm proj |	(proj _ Project named: projName) ifNil: [^nil].	pvm _ ProjectViewMorph on: proj.	pvm _ pvm imageForm scaledToSize: sizeOfEachMorph.	pvm _ pvm asMorph.	pvm setProperty: #nameOfThisProject toValue: projName.	pvm setBalloonText: projName.	pvm on: #mouseDown send: #clickFromSorterEvent:morph: to: self.	pvm on: #mouseUp send: #clickFromSorterEvent:morph: to: self.	^pvm! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'RAA 2/12/2001 14:47'!borderColor	^Color black! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'RAA 2/12/2001 14:47'!borderWidthForRounding	^1! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'raa 2/8/2001 10:40'!ensureImageReady	self isTheRealProjectPresent ifFalse: [^self].	project thumbnail ifNil: [		image fill: image boundingBox rule: Form over 			fillColor: project defaultBackgroundColor.		^self	].	project thumbnail ~~ lastProjectThumbnail ifTrue: ["scale thumbnail to fit my bounds"		lastProjectThumbnail _ project thumbnail.		self updateImageFrom: lastProjectThumbnail.		project thumbnail ifNotNil: [project thumbnail hibernate].		image borderWidth: 1	].! !!RandomNumberTile methodsFor: 'initialization' stamp: 'sw 2/12/2001 21:00'!initialize	"Initialize the receiver fully, including adding all its relevant submorphs"	| m1 m2 |	super initialize.	self vResizing: #shrinkWrap.	self typeColor: (ScriptingSystem colorForType: #number).	self addArrows.	m1 _ StringMorph contents: 'random' font: ScriptingSystem fontForTiles.	self addMorph: m1.	m2 _ UpdatingStringMorph contents: '180' font: ScriptingSystem fontForTiles.	m2 target: self; getSelector: #literal; putSelector: #literal:.	m2 position: m1 topRight.	self addMorphBack: m2.	literal _ 180.	self updateLiteralLabel! !!RandomNumberTile methodsFor: 'as yet unclassified' stamp: 'sw 2/12/2001 21:41'!handlesMouseDown: evt	"Answer whether the receiver would handle the mouseDown represented by evt"	^ self inPartsBin		ifTrue:			[false]		ifFalse:			[super handlesMouseDown: evt]! !!RemoteCanvas methodsFor: 'accessing' stamp: 'di 2/6/2001 14:03'!roundCornersOf: aMorph during: aBlock	self flag: #roundedRudeness.		aMorph wantsRoundedCorners ifFalse:[^aBlock value].	(self seesNothingOutside: (CornerRounder rectWithinCornersOf: aMorph bounds))		ifTrue: ["Don't bother with corner logic if the region is inside them"				^ aBlock value].	CornerRounder roundCornersOf: aMorph on: self		displayBlock: aBlock		borderWidth: aMorph borderWidthForRounding		corners: aMorph roundedCorners! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 2/8/2001 14:44'!helpMenu 	"Answer the help menu to be put up as a screen submenu"	^ SelectionMenu labelList:		#(	'keep this menu up'			'about this system...'			'update code from server'			'preferences...'			'command-key help'			'font size summary'			'useful expressions'			'view graphical imports'			'standard graphics library'),			(Array with: (Preferences soundsEnabled							ifFalse: ['turn sound on']							ifTrue: ['turn sound off'])) ,		#(	'definition for...'			'set author initials...'			'vm statistics'			'space left')		lines: #(1 4 6 11)		selections: #(durableHelpMenu aboutThisSystem absorbUpdatesFromServereditPreferences  openCommandKeyHelp fontSizeSummary openStandardWorkspace viewImageImportsstandardGraphicsLibrary soundOnOrOff  lookUpDefinition setAuthorInitials vmStatistics garbageCollect)"ScreenController new helpMenu startUp"! !!ScriptActivationButton class methodsFor: 'viewer' stamp: 'sw 2/6/2001 23:24'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #((button (			(command fire 'trigger any and all of this object''s button actions')			(slot color 'The color of the object' color readWrite player getColor  player  setColor:)			(slot height  'The height' number readWrite player getHeight  player  setHeight:) 			(slot borderColor 'The color of the object''s border' color readWrite player getBorderColor player  setBorderColor:)			(slot borderWidth 'The width of the object''s border' number readWrite player getBorderWidth player setBorderWidth:)			(slot roundedCorners 'Whether corners should be rounded' boolean readWrite player getRoundedCorners player setRoundedCorners:) 			(slot actWhen 'When the script should fire' buttonPhase  readWrite player getActWhen player setActWhen: ))))! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'ar 2/7/2001 17:51'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add tiles and program fragments just by dropping them on this morph."	| i slideMorph p1 p2 |	self prepareToUndoDropOf: aMorph.	"Find where it will go, and prepare to animate the move..."	i _ self rowInsertionIndexFor: aMorph fullBounds center.	slideMorph _ aMorph imageForm offset: 0@0.	p1 _ aMorph screenRectangle topLeft.	aMorph delete.	self stopStepping.	self world displayWorld.  "Clear old image prior to animation"	(aMorph isKindOf: PhraseTileMorph) ifTrue:		[aMorph justGrabbedFromViewer: false].	aMorph tileRows do: [:tileList |		self insertTileRow: (Array with:				(tileList first rowOfRightTypeFor: owner forActor: aMorph associatedPlayer))			after: i.		i _ i + 1].	self removeSpaces.	self enforceTileColorPolicy.	self layoutChanged.	self fullBounds. "force layout"	"Now animate the move, before next Morphic update.		NOTE: This probably should use ZoomMorph instead"	p2 _ (self submorphs atPin: (i-1 max: firstTileRow)) screenRectangle topLeft.	slideMorph slideFrom: p1 to: p2 nSteps: 5 delay: 50 andStay: true.	self playSoundNamed: 'scritch'.	self topEditor install  "Keep me for editing, a copy goes into lastAcceptedScript"! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'ar 2/7/2001 17:46'!mouseEnter: evt	| hand tile |	self flag: #bob.		"needed renderedMorph due to transformations"	hand _ evt hand.	hand submorphs size = 1 ifFalse: [^self].	evt "hand lastEvent" redButtonPressed ifFalse: [^self].	tile _ hand firstSubmorph renderedMorph.	(self wantsDroppedMorph: tile event: evt) ifFalse: [^self].	handWithTile _ hand.	self startStepping! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'ar 2/7/2001 17:51'!mouseLeave: evt	owner ifNil: [^ self].	"left by being removed, not by mouse movement"	(self hasProperty: #justPickedUpPhrase) ifTrue:[		self removeProperty: #justPickedUpPhrase.		^self].	self stopStepping.	handWithTile _ nil.	self removeSpaces.! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'ar 2/7/2001 18:02'!step	| hand insertion i space1 d space2 insHt nxtHt prevBot ht2 c1 c2 ii where |	hand _ handWithTile ifNil: [self primaryHand].	(hand lastEvent redButtonPressed and: [(self hasOwner: hand) not]) ifTrue: [		hand submorphCount > 0 ifTrue: [			insertion _ hand firstSubmorph renderedMorph.			insHt _ insertion height.			self removeSpaces.			where _ self globalPointToLocal: hand position"insertion fullBounds topLeft".			i _ (ii _ self indexOfMorphAbove: where) min: submorphs size-1.			prevBot _ i <= 0 ifTrue: [(self innerBounds) top]							ifFalse: [(self submorphs at: i) bottom].			nxtHt _ (submorphs isEmpty				ifTrue: [insertion]				ifFalse: [self submorphs at: i+1]) height.			d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]					ifFalse: [0 max: (where y - prevBot min: nxtHt)].			"Top and bottom spacer heights cause continuous motion..."			c1 _ Color green.  c2 _ Color transparent.			ht2 _ d*insHt//nxtHt.			space1 _ Morph newBounds: (0@0 extent: 30@(insHt-ht2))                                        color: ((insHt-ht2) > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space1 atIndex: (i+1 max: 1).			space2 _ Morph newBounds: (0@0 extent: 30@ht2)                                        color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space2 atIndex: (i+3 min: submorphs size+1).		]	] ifFalse: [		self stopStepping.		self removeSpaces.	]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/12/2001 21:59'!handUserButtonDownTile	"Hand the user a button-down tile, presumably to drop in the script"			self currentHand attachMorph:		(self presenter systemQueryPhraseWithActionString: '(Sensor anyButtonPressed)' labelled: 'button down?')	! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/12/2001 22:07'!handUserButtonUpTile	"Hand the user a button-up tile, presumably to drop in the script"			self currentHand attachMorph:		(self presenter systemQueryPhraseWithActionString: '(Sensor noButtonPressed)' labelled: 'button up?')	! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/12/2001 21:50'!handUserRandomTile	"Hand the user a random-number tile, presumably to drop in the script"	self currentHand attachMorph: RandomNumberTile new markAsPartsDonor makeAllTilesGreen	! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/12/2001 22:24'!offerScriptorMenu	"Put up a menu in response to the user's clicking in the menu-request area of the scriptor's heaer"	| aMenu  count |	self modernize.	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: scriptName asString.	count _ self savedTileVersionsCount.	self showingMethodPane		ifFalse:				"currently showing tiles"			[aMenu add: 'show code textually' action: #showSourceInScriptor.			count > 0 ifTrue: 				[aMenu add: 'revert to tile version...' action:	 #revertScriptVersion].			aMenu add: 'save this version'	action: #saveScriptVersion]		ifTrue:				"current showing textual source"			[count >= 1 ifTrue:				[aMenu add: 'revert to tile version' action: #revertToTileVersion].			aMenu add: 'make tiles from this code' action: #recreateTileVersion].	Preferences noviceMode ifFalse: ["just for now, not for kids"		aMenu add: 'use new universal tiles' action: #useNewTiles].				aMenu addList: #(		-		('destroy this script'					destroyScript)		('rename this script'					renameScript)		('button to fire this script'			tearOfButtonToFireScript)		('edit balloon help for this script'	editMethodDescription)		-		('fires per tick...'					chooseFrequency)		('explain status alternatives' 		explainStatusAlternatives)		-		('hand me a tile for self'			tileForSelf)		('hand me a "random number" tile'	handUserRandomTile)		('hand me a "button down?" tile'		handUserButtonDownTile)		('hand me a "button up?" tile'		handUserButtonUpTile)		 ).	aMenu popUpInWorld: self currentWorld.	"		('add parameter to this script'	addParameter)"! !!ScriptEditorMorph methodsFor: 'other' stamp: 'ar 2/6/2001 22:07'!recompileScript	"A hook called in several places in the UI when something has been dragged & dropped into or out of the script."	self install.	"self stopScript"! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/5/2001 14:11'!tearOfButtonToFireScript	"Tear off a button to fire this script"	playerScripted tearOffButtonToFireScriptForSelector: scriptName! !!ScriptEditorMorph methodsFor: 'other' stamp: 'tk 2/13/2001 20:24'!unhibernate	| ww |	"Recreate my tiles from my method.  If I have new universal tiles."	(ww _ self world) 		ifNil: [playerScripted ifNil: [^ self].			playerScripted isUniversalTiles ifFalse: [^ self]]		ifNotNil: [			(ww valueOfProperty: #universalTiles ifAbsent: [false]) ifFalse: [^ self]].	self showSourceInScriptor. 	self hResizing: #shrinkWrap;				vResizing: #shrinkWrap;				cellPositioning: #topLeft.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'RAA 2/16/2001 10:37'!useNewTilesNow	| mp source aSelector aClass tree syn widget |	"First make it show source with a method pane, then substitute tiles!!"	(mp _ self findA: MethodMorph) ifNil: [^ self].	"code pane must be present"	aSelector _ mp model selectedMessageName.	aClass _ mp model selectedClassOrMetaClass.	source _ aClass sourceCodeAt: aSelector.    	tree _ Compiler new 		parse: source 		in: aClass 		notifying: nil.	(syn _ tree asMorphicSyntaxUsing: SyntaxMorph)		parsedInClass: aClass.	widget _ syn inAScrollPane.	widget color: Color transparent;		setProperty: #hideUnneededScrollbars toValue: true;		setProperty: #maxAutoFitSize toValue: 300@200.	mp delete.	self addMorphBack: widget.	widget extent: (self width - 10 @ 150).	syn finalAppearanceTweaks.! !!ScriptEditorMorph methodsFor: 'private' stamp: 'ar 2/6/2001 22:07'!scriptEdited	| anEditor |	(anEditor _ self topEditor) ifNotNil: [anEditor recompileScript]! !!ScriptEditorMorph methodsFor: 'testing' stamp: 'ar 2/7/2001 17:57'!isTileEditor	"Yes I am"	^true! !!ScriptInstantiation methodsFor: 'running' stamp: 'ar 2/12/2001 18:28'!runIfTicking: nowTick	| ticks rate |	status == #ticking ifFalse:[^self].	rate _ self tickingRate.	(lastTick == nil or:[nowTick < lastTick]) 		ifTrue:[lastTick _ nowTick.				ticks _ 1]		ifFalse:[ticks _ (nowTick - lastTick * rate / 1000) asInteger].	ticks <= 0 ifTrue:[^self].	1 to: ticks * self frequency do:[:i | player perform: selector].	lastTick _ nowTick.	ticks > 10 ifTrue:[		"check if we're lagging behind"		(ticks <= (Time millisecondClockValue - lastTick * rate / 1000) asInteger) ifTrue:[			"e.g., time to run script is higher than number of ticks"			self status: #paused.			self updateAllStatusMorphs.		].	].! !!ScriptInstantiation methodsFor: 'running' stamp: 'ar 2/12/2001 17:00'!startRunningIfPaused	"If the receiver is paused, start it ticking"	status == #paused ifTrue:		[self status: #ticking.		self updateAllStatusMorphs]! !!ScriptInstantiation methodsFor: 'running' stamp: 'ar 2/12/2001 17:00'!stopTicking	"If I'm ticking stop, else do nothing"	status == #ticking ifTrue:		[self status: #paused.		self updateAllStatusMorphs]! !!ScriptInstantiation methodsFor: 'misc' stamp: 'ar 2/12/2001 18:58'!prepareToBeRunning	lastTick _ nil.! !!ScriptInstantiation methodsFor: 'frequency' stamp: 'ar 2/12/2001 18:26'!tickingRate	"Return the number of ticks per second this script should get"	^tickingRate ifNil:[8]! !!ScriptInstantiation methodsFor: 'frequency' stamp: 'ar 2/12/2001 18:26'!tickingRate: aNumber	"See the comment in #tickingRate"	tickingRate _ aNumber.	self updateAllStatusMorphs.! !!ScriptInstantiation methodsFor: 'status control' stamp: 'sw 2/6/2001 23:16'!fireOnce	"Run this script once"	player perform: selector! !!ScriptInstantiation methodsFor: 'status control' stamp: 'ar 2/12/2001 18:46'!presentTickingMenu	"Put up a menu of status alternatives and carry out the request"	| aMenu ticks item any |	ticks _ self tickingRate.	ticks = ticks asInteger ifTrue:[ticks _ ticks asInteger].	aMenu _ MenuMorph new defaultTarget: self.	any _ false.	#(1 2 5 8 10 25 50 100) do:[:i | 		item _ aMenu addUpdating: nil target: self selector: #tickingRate: argumentList: {i}.		item contents:			((ticks = i) ifTrue:[ any _ true. '<on>', i printString]					ifFalse:['<off>', i printString])].	item _ aMenu addUpdating: nil target: self selector: #typeInTickingRate argumentList: #().	item contents: (any ifTrue:['<off>'] ifFalse:['<on>']), 'other...'.	aMenu addTitle: 'Ticks (now: ', ticks printString, '/sec)'.	aMenu  popUpEvent: self currentEvent in: self currentWorld! !!ScriptInstantiation methodsFor: 'status control' stamp: 'RAA 2/14/2001 11:20'!status: newStatus	| stati actualMorph |	actualMorph _ player costume renderedMorph.	stati _ ScriptingSystem standardEventStati.	(stati includes: status) ifTrue:[		actualMorph on: status send: nil to: nil.  			"remove old link in event handler"		status == #mouseStillDown ifTrue:[actualMorph on: #mouseDown send: nil to: nil]].	(stati includes: newStatus) ifTrue:[		actualMorph on: newStatus send: selector to: player.  "establish new link in evt handler"		newStatus == #mouseStillDown ifTrue:[actualMorph on: #mouseDown send: selector to: player]].	status _ newStatus.	(status == #ticking or:[status == #paused]) ifTrue: [lastTick _ nil].	self flag: #arNote.	self flag: #workaround. "Code below was in #chooseTriggerFrom: which did not reflect status changes from other places (e.g., the stepping/pause buttons). It is not clear why this is necessary though - theoretically, any morph should step when it has a player but alas!! something is broken and I have no idea why and where.""14 feb 2001 - bob - I reinstated this after alan noticed that a newly drawn car would not go until you picked it up and dropped it. The reason is that unscripted players have #wantSteps ^false. If a morph enters the world with an unscripted player and then acquires a scripted player, that would be a good time to change, but this will work too"	status == #ticking ifTrue: [		player costume isStepping ifFalse: [player costume arrangeToStartStepping]	].! !!ScriptInstantiation methodsFor: 'status control' stamp: 'ar 2/12/2001 16:58'!typeInTickingRate	| reply aNumber |	reply _ FillInTheBlank request: 'Number of ticks per second: ' initialAnswer: self tickingRate printString.	reply ifNotNil:		[aNumber _ reply asNumber.		aNumber > 0 ifTrue:			[self tickingRate: aNumber]]! !!ScriptStatusControl methodsFor: 'initialization' stamp: 'ar 2/12/2001 18:39'!assurePauseTickControlsShow	"Add two little buttons that allow the user quickly to toggle between paused and ticking state"	| colorSelector status |	self beTransparent.	(tickPauseWrapper isKindOf: TickIndicatorMorph) ifFalse:[		"this was an old guy"		tickPauseWrapper ifNotNil:[tickPauseWrapper delete].		tickPauseWrapper _ TickIndicatorMorph new.		tickPauseWrapper on: #mouseDown send: #mouseDownTick:onItem: to: self.		tickPauseWrapper on: #mouseUp send: #mouseUpTick:onItem: to: self.		tickPauseWrapper setBalloonText:'Press to toggle ticking state. Hold down to set tick rate.'.		self addMorphFront: tickPauseWrapper.	].	status _ scriptInstantiation status.	colorSelector _ ScriptingSystem statusColorSymbolFor: status.	tickPauseWrapper color: (Color perform: colorSelector) muchLighter.	tickPauseWrapper stepTime: (1000 // scriptInstantiation tickingRate max: 0).	tickPauseWrapper isTicking: status == #ticking.	tickPauseButtonsShowing _ true.! !!ScriptStatusControl methodsFor: 'initialization' stamp: 'ar 2/12/2001 18:19'!initializeFor: aScriptInstantiation	"Answer a control that will serve to reflect and allow the user to change the status of the receiver"	|  statusReadout |	self hResizing: #shrinkWrap.	self cellInset: 2@0.	scriptInstantiation _ aScriptInstantiation.	tickPauseButtonsShowing _ false.	self addMorphBack: (statusReadout _ UpdatingSimpleButtonMorph new).	statusReadout setNameTo: 'trigger'.	statusReadout target: aScriptInstantiation; wordingSelector: #status; actionSelector: #presentScriptStatusPopUp.	statusReadout setBalloonText: 'when this script should run'.	statusReadout actWhen: #buttonDown.	self assurePauseTickControlsShow.	aScriptInstantiation updateStatusMorph: self! !!ScriptStatusControl methodsFor: 'initialization' stamp: 'ar 2/12/2001 18:24'!maybeRemovePauseTickControls	"If we're in the business of removing pauseTick controls when we're neither paused nor ticking, then do it now.  The present take is not to remove these controls, which explains why the body of this method is currently commented out."	tickPauseButtonsShowing _ false.	"note: the following is to change color of the tick control appropriately"	self assurePauseTickControlsShow.! !!ScriptStatusControl methodsFor: 'mouse gestures' stamp: 'ar 2/11/2001 20:37'!mouseDownTick: evt onItem: aMorph	aMorph color: Color veryLightGray.	self addAlarm: #offerTickingMenu: with: aMorph after: 200.! !!ScriptStatusControl methodsFor: 'mouse gestures' stamp: 'ar 2/11/2001 21:02'!mouseUpTick: evt onItem: aMorph	self removeAlarm: #offerTickingMenu:.	aMorph color: (Color r: 0.767 g: 0.767 b: 1.0).	(scriptInstantiation status == #ticking) ifTrue:[		scriptInstantiation status: #paused. 		aMorph color: (Color r: 1.0 g: 0.774 b: 0.774).		aMorph isTicking: false.	] ifFalse:[		scriptInstantiation status: #ticking. 		aMorph color: (Color r: 0.767 g: 0.767 b: 1.0).		aMorph isTicking: true.	].	scriptInstantiation updateAllStatusMorphs.! !!ScriptStatusControl methodsFor: 'mouse gestures' stamp: 'ar 2/12/2001 18:40'!offerTickingMenu: aMorph	self assurePauseTickControlsShow. "to set the color"	^scriptInstantiation presentTickingMenu! !!ScriptableButton class methodsFor: 'viewer' stamp: 'sw 2/6/2001 23:25'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #((button (			(command fire 'trigger any and all of this object''s button actions')			(slot label 'The wording on the button' string readWrite player getLabel player setLabel:)			(slot color 'The color of the object' color readWrite player getColor  player  setColor:)			(slot height  'The height' number readWrite player getHeight  player  setHeight:) 			(slot borderColor 'The color of the object''s border' color readWrite player getBorderColor player  setBorderColor:)			(slot borderWidth 'The width of the object''s border' number readWrite player getBorderWidth player setBorderWidth:)			(slot  height  'The height' number readWrite player getHeight  player  setHeight:)			(slot roundedCorners 'Whether corners should be rounded' boolean readWrite player getRoundedCorners player setRoundedCorners:) 			(slot actWhen 'When the script should fire' buttonPhase  readWrite player getActWhen player setActWhen: ))))! !!SecurityManager methodsFor: 'initialize-release' stamp: 'ar 2/6/2001 16:24'!flushSecurityKey: aKey	"Flush a security key"	| n |	n _ aKey first.	1 to: n basicSize do:[:i| n basicAt: i put: 0].	n _ aKey second.	1 to: n basicSize do:[:i| n basicAt: i put: 0].! !!SecurityManager methodsFor: 'initialize-release' stamp: 'ar 2/6/2001 16:23'!flushSecurityKeys	"Flush all keys"	privateKeyPair ifNotNil:[		self flushSecurityKey: privateKeyPair first.		self flushSecurityKey: privateKeyPair last.	].	privateKeyPair _ nil.	trustedKeys do:[:key| self flushSecurityKey: key].	trustedKeys _ #().! !!SecurityManager methodsFor: 'initialize-release' stamp: 'ar 2/6/2001 16:20'!initialize	privateKeyPair _ nil.	trustedKeys _ #().	keysFileName _ 'Squeak.keys'.! !!SecurityManager methodsFor: 'initialize-release' stamp: 'ar 2/6/2001 16:22'!shutDown	"Flush existing keys"	self flushSecurityKeys.! !!SecurityManager methodsFor: 'initialize-release' stamp: 'ar 2/6/2001 18:28'!startUp	"Attempt to load existing keys"	self loadSecurityKeys.	(privateKeyPair == nil 		and:[self isInRestrictedMode not		and:[Preferences automaticKeyGeneration]]) ifTrue:[			self generateKeyPairInBackground.	].! !!SecurityManager methodsFor: 'accessing' stamp: 'ar 2/6/2001 16:19'!addTrustedKey: aPublicKey	"Add a public key to the list of trusted keys"	trustedKeys _ (trustedKeys copyWithout: aPublicKey) copyWith: aPublicKey.! !!SecurityManager methodsFor: 'accessing' stamp: 'ar 2/6/2001 16:17'!keysFileName	^keysFileName! !!SecurityManager methodsFor: 'accessing' stamp: 'ar 2/6/2001 16:17'!keysFileName: aFileName	keysFileName _ aFileName! !!SecurityManager methodsFor: 'accessing' stamp: 'ar 2/6/2001 18:33'!secureUserDirectory	"SecurityManager default secureUserDirectory"	"Primitive. Return the directory where we can securely store data that is not accessible in restricted mode."	<primitive: 'primitiveGetSecureUserDirectory' module: 'SecurityPlugin'>	^FileDirectory default pathName! !!SecurityManager methodsFor: 'accessing' stamp: 'ar 2/6/2001 16:20'!signingKey	"Return the key used for signing projects"	^privateKeyPair ifNotNil:[privateKeyPair first]! !!SecurityManager methodsFor: 'accessing' stamp: 'ar 2/6/2001 16:42'!trustedKeys	"Return an array of trusted public keys for verifying some project"	privateKeyPair ifNil:[^trustedKeys].	^{privateKeyPair second}, trustedKeys! !!SecurityManager methodsFor: 'accessing' stamp: 'ar 2/6/2001 18:33'!untrustedUserDirectory	"SecurityManager default untrustedUserDirectory"	"Primitive. Return the untrusted user directory that is the root directory for files that are visible even in restricted mode."	<primitive: 'primitiveGetUntrustedUserDirectory' module: 'SecurityPlugin'>	^FileDirectory default pathName! !!SecurityManager methodsFor: 'fileIn/out' stamp: 'ar 2/7/2001 12:39'!loadSecurityKeys	"SecurityManager default loadSecurityKeys"	"Load the keys file for the current user"	| fd loc file keys |	self isInRestrictedMode ifTrue:[^self]. "no point in even trying"	loc _ self secureUserDirectory. "where to get it from"	loc last = FileDirectory pathNameDelimiter ifFalse:[		loc _ loc copyWith: FileDirectory pathNameDelimiter.	].	fd _ FileDirectory on: loc.	file _ [fd readOnlyFileNamed: keysFileName] 			on: FileDoesNotExistException do:[:ex| ex resume: nil].	file ifNil:[^self]. "no keys file"	keys _ Object readFrom: file.	privateKeyPair _ keys first.	trustedKeys _ keys last.	file close.! !!SecurityManager methodsFor: 'fileIn/out' stamp: 'ar 2/6/2001 16:52'!storeSecurityKeys	"SecurityManager default storeSecurityKeys"	"Store the keys file for the current user"	| fd loc file |	self isInRestrictedMode ifTrue:[^self]. "no point in even trying"	loc _ self secureUserDirectory. "where to put it"	loc last = FileDirectory pathNameDelimiter ifFalse:[		loc _ loc copyWith: FileDirectory pathNameDelimiter.	].	fd _ FileDirectory on: loc.	fd assureExistance.	fd deleteFileNamed: self keysFileName ifAbsent:[].	file _ fd newFileNamed: self keysFileName.	{privateKeyPair. trustedKeys} storeOn: file.	file close.! !!SecurityManager methodsFor: 'testing' stamp: 'ar 2/6/2001 16:14'!canWriteImage	"SecurityManager default canWriteImage"	"Primitive. Return true if the right to write an image hasn't been revoked."	<primitive: 'primitiveCanWriteImage' module: 'SecurityPlugin'>	^true "assume so unless otherwise proven"! !!SecurityManager methodsFor: 'testing' stamp: 'ar 2/6/2001 16:16'!hasFileAccess	"SecurityManager default hasFileAccess"	"Return true if the right to access arbitrary files hasn't been revoked"	<primitive: 'primitiveHasFileAccess' module: 'FilePlugin'>	^true "assume so unless otherwise proven"! !!SecurityManager methodsFor: 'testing' stamp: 'ar 2/6/2001 16:16'!hasSocketAccess	"SecurityManager default hasSocketAccess"	"Return true if the right to access sockets hasn't been revoked"	<primitive: 'primitiveHasSocketAccess' module: 'SocketPlugin'>	^true "assume so unless otherwise proven"! !!SecurityManager methodsFor: 'testing' stamp: 'ar 2/6/2001 16:13'!isInRestrictedMode	"Return true if we're in restricted mode"	^(self canWriteImage 		or:[self hasFileAccess 		"or:[self hasSocketAccess]"]) not! !!SecurityManager methodsFor: 'security operations' stamp: 'ar 2/6/2001 16:14'!disableFileAccess	"SecurityManager default disableFileAccess"	"Primitive. Disable unlimited access to files.	Cannot be revoked from the image."	<primitive: 'primitiveDisableFileAccess' module: 'FilePlugin'>	^self primitiveFailed! !!SecurityManager methodsFor: 'security operations' stamp: 'ar 2/6/2001 16:15'!disableImageWrite	"SecurityManager default disableImageWrite"	"Primitive. Disable writing to an image file.	Cannot be revoked from the image."	<primitive: 'primitiveDisableImageWrite' module: 'SecurityPlugin'>	^self primitiveFailed! !!SecurityManager methodsFor: 'security operations' stamp: 'ar 2/6/2001 16:15'!disableSocketAccess	"SecurityManage default disableSocketAccess"	"Primitive. Disable access to sockets.	Cannot be revoked from the image."	<primitive: 'primitiveDisableSocketAccess' module: 'SocketPlugin'>	^self primitiveFailed! !!SecurityManager methodsFor: 'security operations' stamp: 'ar 2/12/2001 15:41'!enterRestrictedMode	"Some insecure contents was encountered. Close all doors and proceed."	self isInRestrictedMode ifTrue:[^true].	Preferences securityChecksEnabled ifFalse:[^true]. "it's been your choice..."	Preferences warnAboutInsecureContent ifTrue:[		(PopUpMenu confirm:'You are about to load some insecure content.If you continue, access to files as well assome other capabilities will be limited.'			trueChoice:'Load it anyways'			falseChoice:'Do not load it') ifFalse:[				"user doesn't really want it"				^false.			].	].	"here goes the actual restriction"	self flushSecurityKeys.	self disableFileAccess.	self disableImageWrite.	"self disableSocketAccess."	FileDirectory setDefaultDirectory: self untrustedUserDirectory.	^true! !!SecurityManager methodsFor: 'security operations' stamp: 'ar 2/7/2001 12:41'!fileInObjectAndCode: aStream	| trusted |	trusted _ self positionToSecureContentsOf: aStream.	trusted ifFalse:[self enterRestrictedMode ifFalse:[		(aStream respondsTo: #close) ifTrue:[aStream close].		^nil]].	^aStream fileInObjectAndCode! !!SecurityManager methodsFor: 'security operations' stamp: 'ar 2/6/2001 19:48'!positionToSecureContentsOf: aStream	| bytes trusted part1 part2 sig hash dsa okay pos |	aStream binary.	pos _ aStream position.	bytes _ aStream next: 4.	bytes = 'SPRJ' asByteArray ifFalse:[		"was not signed"		aStream position: pos.		^false].	part1 _ aStream nextInto: (LargePositiveInteger basicNew: 20).	part2 _ aStream nextInto: (LargePositiveInteger basicNew: 20).	sig _ Array with: part1 with: part2.	hash _ SecureHashAlgorithm new hashStream: aStream.	dsa _ DigitalSignatureAlgorithm new.	trusted _ self trustedKeys.	okay _ (trusted detect:[:key| dsa verifySignature: sig ofMessageHash: hash publicKey: key]			ifNone:[nil]) notNil.	aStream position: pos+44.	^okay! !!SecurityManager methodsFor: 'security operations' stamp: 'ar 2/6/2001 19:16'!signFile: fileName directory: fileDirectory	"Sign the given project in the directory"	| bytes file dsa hash sig key |	Preferences signProjectFiles ifFalse:[^self]. "signing turned off"	key _ self signingKey.	key ifNil:[^self].	file _ FileStream readOnlyFileNamed: (fileDirectory fullNameFor: fileName).	bytes _ file binary; contentsOfEntireFile.	fileDirectory deleteFileNamed: fileName ifAbsent:[].	dsa _ DigitalSignatureAlgorithm new.	dsa initRandom: Time millisecondClockValue + Date today julianDayNumber.	hash _ SecureHashAlgorithm new hashStream: (ReadStream on: bytes).	sig _ dsa computeSignatureForMessageHash: hash privateKey: key.	file _ FileStream newFileNamed: (fileDirectory fullNameFor: fileName).	file binary.	"store a header identifying the signed file first"	file nextPutAll: 'SPRJ' asByteArray.	"now the signature"	file nextPutAll: sig first; nextPutAll: sig last.	"now the contents"	file nextPutAll: bytes.	file close.! !!SecurityManager methodsFor: 'private' stamp: 'ar 2/6/2001 18:27'!generateKeyPairInBackground	"SecurityManager default generateKeyPairInBackground"	"Silently generate a key set on the local machine while running in the background."	| d scheduler |	d _ Delay forMilliseconds: 50.	scheduler _ [d wait] forkAt: Processor userInterruptPriority.	[self generateLocalKeyPair.	scheduler terminate] fork.! !!SecurityManager methodsFor: 'private' stamp: 'ar 2/6/2001 18:28'!generateLocalKeyPair	"SecurityManager default generateLocalKeyPair"	"Generate a key set on the local machine."	| dsa |	dsa _ DigitalSignatureAlgorithm new.	dsa initRandomFromString: 		Time millisecondClockValue printString, 		Date today printString, 		Smalltalk platformName printString.	privateKeyPair _ dsa generateKeySet.	self storeSecurityKeys.! !!SecurityManager class methodsFor: 'class initialization' stamp: 'ar 2/6/2001 17:12'!initialize	"SecurityManager initialize"	Default _ self new initialize.	Smalltalk addToStartUpList: self.	Smalltalk addToShutDownList: self.! !!SecurityManager class methodsFor: 'class initialization' stamp: 'ar 2/6/2001 16:46'!shutDown	self default shutDown.! !!SecurityManager class methodsFor: 'class initialization' stamp: 'ar 2/6/2001 17:12'!startUp	self default startUp.! !!SecurityManager class methodsFor: 'accessing' stamp: 'ar 2/6/2001 16:21'!default	^Default ifNil:[Default _ self new initialize].! !IMPLEMENTATION NOTES:The support should assume a trusted directory based on which access to files is granted when running in restricted mode. If necessary, links need to be resolved before granting access (currently, this applies only to platforms on which links can be created by simply creating the right kind of file).The untrusted user directory returned MUST be different from the image and VM location. Otherwise a Badlet could attempt to overwrite these by using simple file primitives. The secure directory location returned by the primitive is a place to store per-user security information. Again, this place needs to be outside the untrusted space. Examples:[Windows]	* VM+image location: "C:\Program Files\Squeak\"	* secure directory location: "C:\Program Files\Squeak\username\"	* untrusted user directory: "C:\My Squeak\username\"[Unix]	* VM+image location: "/user/local/squeak"	* secure directory location: "~username/.squeak/	* untrusted user directory: "~username/squeak/"[Mac]	* plugin VM location: "MacHD:Netscape:Plugins:"	* standalone VM and image location: "MacHD:Squeak:"	* secure directory location: "MacHD:Squeak:username:"	* untrusted user directory: "MacHD:My Squeak:username:"Restoring the rights revoked by an image might be possible by some interaction with the VM directly. Any such action should be preceeded by a BIG FAT WARNING - the average user will never need that ability (if she does, we did something wrong) so this is a last resort in cases where something fundamtally tricky happened.Note that ioInitSecurity needs to be called from the VM directly (after the image has loaded  but before running it). It needs to establish both, the untrusted and the secure user directory. Later we might think about manually changing it (which is possible if the VM is still in trusted mode) but for now we don't.!!SecurityPlugin methodsFor: 'primitives' stamp: 'ar 2/5/2001 20:56'!primitiveCanWriteImage	self export: true.	interpreterProxy pop: 1.	interpreterProxy pushBool: self ioCanWriteImage.! !!SecurityPlugin methodsFor: 'primitives' stamp: 'ar 2/6/2001 14:11'!primitiveDisableImageWrite	self export: true.	self ioDisableImageWrite.	interpreterProxy failed ifFalse:[interpreterProxy pop: 1].! !!SecurityPlugin methodsFor: 'primitives' stamp: 'ar 2/6/2001 00:33'!primitiveGetSecureUserDirectory	"Primitive. Return the secure directory for the current user."	| dirName dirLen dirOop dirPtr |	self export: true.	self var: #dirName type: 'char *'.	self var: #dirPtr type: 'char *'.	dirName _ self ioGetSecureUserDirectory.	(dirName == nil or:[interpreterProxy failed]) 		ifTrue:[^interpreterProxy primitiveFail].	dirLen _ self strlen: dirName.	dirOop _ interpreterProxy instantiateClass: interpreterProxy classString indexableSize: dirLen.	interpreterProxy failed ifTrue:[^nil].	dirPtr _ interpreterProxy firstIndexableField: dirOop.	0 to: dirLen-1 do:[:i|		dirPtr at: i put: (dirName at: i)].	interpreterProxy pop: 1.	interpreterProxy push: dirOop.! !!SecurityPlugin methodsFor: 'primitives' stamp: 'ar 2/6/2001 00:33'!primitiveGetUntrustedUserDirectory	"Primitive. Return the untrusted user directory name."	| dirName dirLen dirOop dirPtr |	self export: true.	self var: #dirName type: 'char *'.	self var: #dirPtr type: 'char *'.	dirName _ self ioGetUntrustedUserDirectory.	(dirName == nil or:[interpreterProxy failed]) 		ifTrue:[^interpreterProxy primitiveFail].	dirLen _ self strlen: dirName.	dirOop _ interpreterProxy instantiateClass: interpreterProxy classString indexableSize: dirLen.	interpreterProxy failed ifTrue:[^nil].	dirPtr _ interpreterProxy firstIndexableField: dirOop.	0 to: dirLen-1 do:[:i|		dirPtr at: i put: (dirName at: i)].	interpreterProxy pop: 1.	interpreterProxy push: dirOop.! !!SecurityPlugin class methodsFor: 'translation' stamp: 'ar 2/6/2001 14:14'!headerFile^'/* security plugin header file *//* image writing */int ioDisableImageWrite(void);int ioCanWriteImage(void);/* untrusted and secure directory locations */char *ioGetSecureUserDirectory(void);char *ioGetUntrustedUserDirectory(void);/* following must be called by the VM before interpret() */int ioInitSecurity(void);'! !!SelectionMorph methodsFor: 'geometry' stamp: 'jcg 2/14/2001 08:58'!bounds: newBounds	"Make sure position: gets called before extent:; Andreas' optimization for growing/shrinking in ChangeSet 3119 screwed up selection of morphs from underlying pasteup."	selectedItems _ OrderedCollection new.  "Avoid repostioning items during super position:"	self position: newBounds topLeft; extent: newBounds extent! !!ServerDirectory methodsFor: 'updates' stamp: 'di 2/6/2001 22:40'!putUpdateMulti: list fromDirectory: updateDirectory 	"Put these files out as an Update on the servers of my group.  List is an array of local file names without number prefixes.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm lastNum myName response restOfText newNames file numStr insertion |	(self checkNames: list) ifFalse: [^ nil].	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast ', list size printString, ' updates',			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	self openGroup.	(myServers _ self checkServers) size = 0 ifTrue: [self closeGroup.  ^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	lastNum _ Utilities lastUpdateNum: updateStrm.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [self closeGroup.  ^ nil	"abort"].		numStr _ FillInTheBlank 			request: 'Please confirm or change the starting update number' 			initialAnswer: (lastNum+1) printString.		lastNum _ numStr asNumber - 1].	newNames _ list with: (lastNum+1 to: lastNum+list size) collect:		[:each :num | (num printString padded: #left to: 4 with: $0) , each].	insertion _ String streamContents:		[:s | newNames do: [:n | s nextPutAll: n; cr]].	"append name to updates"	(updateStrm skip: -1; next) = Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: insertion; nextPutAll: restOfText.	myServers do: [:aServer |		list doWithIndex: [:local :ind |			file _ updateDirectory oldFileNamed: local.			aServer putFile: file named: (newNames at: ind) retry: true.			file close].		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list' retry: true.		Transcript cr; show: 'Updates succeeded on server ', aServer moniker].	self closeGroup.		Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally"	list with: newNames do:		[:local :newName | updateDirectory rename: local toBe: newName].! !!SharedQueue methodsFor: 'accessing' stamp: 'ar 12/5/2000 13:49'!flush	"Throw out all pending contents"	accessProtect critical: [		readPosition _ 1.		writePosition _ 1].! !A slight modification on TextMorph to show empty fields just as one would fields with data: with a cursor and without the pink field!!ShowEmptyTextMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/6/2001 14:09'!drawOn: aCanvas	self setDefaultContentsIfNil.	aCanvas paragraph: self paragraph bounds: bounds color: color.! !!SimpleButtonMorph class methodsFor: 'as yet unclassified' stamp: 'sw 2/6/2001 23:54'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #((button (			(command fire 'trigger any and all of this object''s button actions'))))! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 2/15/2001 07:19'!ellipse: evt	"Draw an ellipse from the center. "	| rect oldRect ww ext oldExt cColor sOrigin priorEvt |	sOrigin _ self get: #strokeOrigin for: evt.	cColor _ self getColorFor: evt.	ext _ (sOrigin - evt cursorPoint) abs * 2.	evt shiftPressed ifTrue: [ext _ self shiftConstrainPoint: ext].	rect _ Rectangle center: sOrigin extent: ext.	ww _ (self getNibFor: evt) width.	(priorEvt _ self get: #lastEvent for: evt) ifNotNil: [		oldExt _ (sOrigin - priorEvt cursorPoint) abs + ww * 2.		priorEvt shiftPressed ifTrue: [oldExt _ self shiftConstrainPoint: oldExt].		(oldExt < ext) ifFalse: ["Last draw sticks out, must erase the area"			oldRect _ Rectangle center: sOrigin extent: oldExt.			self restoreRect: oldRect]].	cColor == Color transparent	ifFalse:[	formCanvas fillOval: rect color: cColor 		borderWidth: 0 borderColor: Color transparent.]	ifTrue:[	formCanvas fillOval: rect color: cColor 		borderWidth: ww borderColor: Color black].	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 2/15/2001 07:18'!shiftConstrainPoint: aPoint	"answer a point with x and y equal for shift-constrained drawing"	^aPoint max: aPoint transposed! !!SocketPlugin methodsFor: 'primitives' stamp: 'ar 2/6/2001 13:43'!primitiveSocket: socket connectTo: address port: port	| addr s |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketConnectToPort'		parameters: #(Oop ByteArray SmallInteger).	addr _ self netAddressToInt: (self cCoerce: address to: 'unsigned char *').	(self ioCanConnectTo: addr Port: port)		ifFalse:[^interpreterProxy primitiveFail].	s _ self socketValueOf: socket.	interpreterProxy failed ifFalse: [		self sqSocket: s ConnectTo: addr Port: port]! !!SocketPlugin methodsFor: 'primitives' stamp: 'ar 2/6/2001 13:50'!primitiveSocket: socket listenOnPort: port"one part of the wierdass dual prim primitiveSocketListenOnPort which was warped by some demented evil person determined to twist the very nature of reality"	| s |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketListenOnPort'		parameters: #(Oop SmallInteger).	s _ self socketValueOf: socket.	(self ioCanListen: s OnPort: port)		ifFalse:[^interpreterProxy primitiveFail].	self sqSocket: s ListenOnPort: port.! !!SocketPlugin methodsFor: 'primitives' stamp: 'ar 2/6/2001 13:50'!primitiveSocket: socket listenOnPort: port backlogSize: backlog"second part of the wierdass dual prim primitiveSocketListenOnPort which was warped by some demented evil person determined to twist the very nature of reality"	| s |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketListenOnPortBacklog'		parameters: #(Oop SmallInteger SmallInteger).	s _ self socketValueOf: socket.	(self ioCanListen: s OnPort: port)		ifFalse:[^interpreterProxy primitiveFail].	self sqSocket: s ListenOnPort: port BacklogSize: backlog.! !!SocketPlugin methodsFor: 'primitives' stamp: 'ar 2/6/2001 13:47'!primitiveSocketCreateNetwork: netType type: socketType receiveBufferSize: recvBufSize sendBufSize: sendBufSize semaIndex: semaIndex	| socketOop s |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketCreate'		parameters: #(SmallInteger SmallInteger SmallInteger SmallInteger SmallInteger).	(self ioCanCreateSocket: netType OfType: socketType)		ifFalse:[^interpreterProxy primitiveFail].	socketOop _ interpreterProxy instantiateClass: interpreterProxy classByteArray					indexableSize: self socketRecordSize.	s _ self socketValueOf: socketOop.	self sqSocket: s CreateNetType: netType SocketType: socketType		RecvBytes: recvBufSize SendBytes: sendBufSize SemaID: semaIndex.	^socketOop! !!SocketPlugin methodsFor: 'primitives' stamp: 'ar 2/6/2001 13:47'!primitiveSocketCreateNetwork: netType type: socketType receiveBufferSize: recvBufSize sendBufSize: sendBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	| socketOop s |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketCreate3Semaphores'		parameters: #(SmallInteger SmallInteger SmallInteger SmallInteger SmallInteger SmallInteger SmallInteger).	(self ioCanCreateSocket: netType OfType: socketType)		ifFalse:[^interpreterProxy primitiveFail].	socketOop _ interpreterProxy instantiateClass: interpreterProxy classByteArray					indexableSize: self socketRecordSize.	s _ self socketValueOf: socketOop.	self sqSocket: s CreateNetType: netType SocketType: socketType		RecvBytes: recvBufSize SendBytes: sendBufSize SemaID: semaIndex ReadSemaID: aReadSema WriteSemaID: aWriteSema.	^socketOop! !!SocketPlugin methodsFor: 'security primitives' stamp: 'ar 2/6/2001 14:09'!primitiveDisableSocketAccess	self export: true.	self ioDisableSocketAccess.	interpreterProxy failed ifFalse:[interpreterProxy pop: 1].! !!SocketPlugin methodsFor: 'security primitives' stamp: 'ar 2/6/2001 13:56'!primitiveHasSocketAccess	self export: true.	interpreterProxy pop: 1.	interpreterProxy pushBool: self ioHasSocketAccess.! !!SocketPlugin class methodsFor: 'translation' stamp: 'ar 2/6/2001 14:21'!headerFile^'/* squeak socket record; see sqMacNetwork.c for details *//* module initialization/shutdown */int socketInit(void);int socketShutdown(void);typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* 	ar 7/16/1999: New primitives for accept().	Note: If accept() calls are not supported simply make the calls fail	and the old connection style will be used */void	sqSocketListenOnPortBacklogSize(SocketPtr s, int port, int backlogSize);void	sqSocketAcceptFromRecvBytesSendBytesSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex);int 		sqSocketReceiveUDPDataBufCountaddressportmoreFlag(SocketPtr s, int buf, int bufSize,  int *address,  int *port, int *moreFlag);int		sqSockettoHostportSendDataBufCount(SocketPtr s, int address, int port, int buf, int bufSize);int     	sqSocketSetOptionsoptionNameStartoptionNameSizeoptionValueStartoptionValueSizereturnedValue(			SocketPtr s,int optionName, int optionNameSize, int optionValue, int optionValueSize, int *result);int     	sqSocketGetOptionsoptionNameStartoptionNameSizereturnedValue(			SocketPtr s,int optionName, int optionNameSize, int *result);/*** security traps ***//* check if we are allowed to create the given socket */int ioCanCreateSocketOfType(int netType, int socketType);/* check if we are allowed to connect to the given port */int ioCanConnectToPort(int netAddr, int port);/* check if we are allowed to listen on the given port	Note: ability to listen applies also to setting ports of UDP sockets.	For TCP sockets, the ability to listen implies the ability to accept(). */int ioCanListenOnPort(SocketPtr s, int port);/* disable all use of sockets */int ioDisableSocketAccess(void);/* query for socket availability */int ioHasSocketAccess(void);#ifdef DISABLE_SECURITY#define ioCanCreateSocketOfType(netType, socketType) 1#define ioCanConnectToPort(netAddr, port) 1#define ioCanListenOnPort(s, port) 1#define ioDisableSocketAccess() 1#define ioHasSocketAccess() 1#endif'! !!SoundPlayer class methodsFor: 'snapshotting' stamp: 'ar 2/4/2001 17:59'!startUpWithSound: aSound	"Start up the player process."	SoundPlayer initialize.	SoundPlayer		startPlayerProcessBufferSize: (BufferMSecs * SamplingRate) // 1000		rate: SamplingRate		stereo: Stereo		sound: aSound.! !!SoundPlayer class methodsFor: 'playing' stamp: 'ar 2/4/2001 18:01'!resumePlaying: aSound quickStart: quickStart	"Start playing the given sound without resetting it; it will resume playing from where it last stopped. If quickStart is true, then try to start playing the given sound immediately."	| doQuickStart |	Preferences soundsEnabled ifFalse: [^ self].	doQuickStart _ quickStart.	Preferences soundQuickStart ifFalse: [doQuickStart _ false].	PlayerProcess == nil ifTrue: [		self canStartPlayer ifFalse: [^ self].		^self startUpWithSound: aSound].	PlayerSemaphore critical: [		(ActiveSounds includes: aSound)			ifTrue: [doQuickStart _ false]			ifFalse: [				doQuickStart ifFalse: [ActiveSounds add: aSound]]].	"quick-start the given sound, unless the sound player has just started"	doQuickStart ifTrue: [self startPlayingImmediately: aSound].! !!SoundPlayer class methodsFor: 'player process' stamp: 'nk 2/16/2001 13:26'!playerProcess	^PlayerProcess! !!SoundPlayer class methodsFor: 'player process' stamp: 'ar 2/4/2001 18:01'!startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start the sound player process. Terminate the old process, if any."	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"	^self startPlayerProcessBufferSize: bufferSize 			rate: samplesPerSecond 			stereo: stereoFlag 			sound: nil! !!SoundPlayer class methodsFor: 'player process' stamp: 'ar 2/4/2001 18:00'!startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag sound: aSound	"Start the sound player process. Terminate the old process, if any."	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"	self stopPlayerProcess.	aSound		ifNil:[ActiveSounds _ OrderedCollection new]		ifNotNil:[ActiveSounds _ OrderedCollection with: aSound].	Buffer _ SoundBuffer newStereoSampleCount: (bufferSize // 4) * 4.	PlayerSemaphore _ Semaphore forMutualExclusion.	SamplingRate _ samplesPerSecond.	Stereo _ stereoFlag.	ReadyForBuffer _ Semaphore new.	SoundSupported _ true. "Assume so"	UseReadySemaphore _ true.  "set to false if ready semaphore not supported by VM"	self primSoundStartBufferSize: Buffer stereoSampleCount		rate: samplesPerSecond		stereo: Stereo		semaIndex: (Smalltalk registerExternalObject: ReadyForBuffer).	"Check if sound start prim was successful"	SoundSupported ifFalse:[^self].	UseReadySemaphore		ifTrue: [PlayerProcess _ [SoundPlayer playLoop] newProcess]		ifFalse: [PlayerProcess _ [SoundPlayer oldStylePlayLoop] newProcess].	UseReverb ifTrue: [self startReverb].	PlayerProcess priority: Processor userInterruptPriority.	PlayerProcess resume.! !!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/4/2001 19:32'!startPlayingImmediately: aSound	"Private!! Start playing the given sound as soon as possible by mixing it into the sound output buffers of the underlying sound driver."	| totalSamples buf n leftover src rest |	"first, fill a double-size buffer with samples"	"Note: The code below assumes that totalSamples contains two	 buffers worth of samples, and the insertSamples primitive is	 expected to consume at least one buffer's worth of these	 samples. The remaining samples are guaranteed to fit into	 a single buffer."	totalSamples _ Buffer stereoSampleCount * 2.  "two buffer's worth"	buf _ SoundBuffer newStereoSampleCount: totalSamples.	aSound playSampleCount: totalSamples into: buf startingAt: 1.	ReverbState == nil ifFalse: [		ReverbState applyReverbTo: buf startingAt: 1 count: totalSamples].	PlayerSemaphore critical: [		"insert as many samples as possible into the sound driver's buffers"		n _ self primSoundInsertSamples: totalSamples			from: buf			samplesOfLeadTime: 1024.		n > 0 ifTrue:[			leftover _ totalSamples - n.			"copy the remainder of buf into Buffer"			"Note: the following loop iterates over 16-bit words, not two-word stereo slices"			"assert: 0 < leftover <= Buffer stereoSampleCount"			src _ 2 * n.			1 to: 2 * leftover do:				[:dst | Buffer at: dst put: (buf at: (src _ src + 1))].			"generate enough additional samples to finish filling Buffer"			rest _ Buffer stereoSampleCount - leftover.			aSound playSampleCount: rest into: Buffer startingAt: leftover + 1.			ReverbState == nil ifFalse: [				ReverbState applyReverbTo: Buffer startingAt: leftover + 1 count: rest].			"record the fact that this sound has already been played into Buffer so that we don't process it again this time around"			SoundJustStarted _ aSound.		] ifFalse:[			"quick start failed; reset the sound so we start over"			aSound reset.		].		ActiveSounds add: aSound].! !!SoundRecorder methodsFor: 'primitives' stamp: 'tpr 2/15/2001 17:13'!primStopRecording	"Stop sound recording. Does nothing if recording is not currently in progress. Do not fail if plugin is not available"	<primitive: 'primitiveSoundStopRecording' module: 'SoundPlugin'>! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'acg 2/4/2001 11:01'!initialize	super initialize.	borderWidth _ 2.	self listDirection: #topToBottom.	soundInput _ SoundInputStream new samplingRate: 22050.	fft _ FFT new: 512.	displayType _ 'sonogram'.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self addButtonRow.	self addLevelSlider.	self addMorphBack: self makeLevelMeter.	self addMorphBack: (Morph new extent: 10@10; color: Color transparent).  "spacer"	self resetDisplay.  "adds the display morph"! !!StackMorph methodsFor: 'menu' stamp: 'sw 2/12/2001 14:49'!addBookMenuItemsTo: aMenu hand: aHandMorph	"Add book-related items to the given menu"	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous card' action: #goToPreviousCardInStack.	subMenu add: 'next card' action: #goToNextCardInStack.	subMenu add: 'go to card...' action: #goToCard.	subMenu add: 'insert a card' action: #insertCard.	subMenu add: 'delete this card' action: #deleteCard.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue:			[subMenu add: 'hide card controls' action: #hidePageControls.			subMenu add: 'fewer card controls' action: #fewerPageControls]		ifFalse:			[subMenu add: 'show card controls' action: #showPageControls].	subMenu addLine.	subMenu add: 'sound effect for all backgrounds' action: #menuPageSoundForAll:.	subMenu add: 'sound effect this background only' action: #menuPageSoundForThisPage:.	subMenu add: 'visual effect for all backgrounds' action: #menuPageVisualForAll:.	subMenu add: 'visual effect this background only' action: #menuPageVisualForThisPage:.	subMenu addLine.	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'uncache page sorter' action: #uncachePageSorter.	(self hasProperty: #dontWrapAtEnd)		ifTrue: [subMenu add: 'wrap after last page' selector: #setWrapPages: argument: true]		ifFalse: [subMenu add: 'stop at last page' selector: #setWrapPages: argument: false].	subMenu  addUpdating: #showingFullScreenString action: #toggleFullScreen.	subMenu addLine.	subMenu add: 'search for text' action: #textSearch.	(self primaryHand pasteBuffer class isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	subMenu add: 'send all pages to server' action: #savePagesOnURL.	subMenu add: 'send this page to server' action: #saveOneOnURL.	subMenu add: 'reload all from server' action: #reload.	subMenu add: 'copy page url to clipboard' action: #copyUrl.	subMenu add: 'keep in one file' action: #keepTogether.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: 'book...' subMenu: subMenu! !!StackMorph methodsFor: 'menu' stamp: 'sw 2/12/2001 14:42'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'Stack'.	aMenu addStayUpItem.	aMenu addList: #(		('find...'								textSearch)		('show designations' 					showDesignationsOfObjects)		('explain designations'					explainDesignations)		('look inside'							openInsideLook)		-		('previous card' 						goToPreviousCardInStack)		('next card' 							goToNextCardInStack)		('first card' 							goToFirstCardOfStack)		('last card' 								goToLastCardOfStack)		('go to card...' 							goToCard)		-		('add a card of this background' 		insertCard)		('add a card of background...'		 	insertCardOfBackground)		('make a new background...' 			makeNewBackground)		-		('delete this card' 						deleteCard)		-		('scripts for this background'			browseCardClass)		-		('debug...'								offerStackDebugMenu)		('bookish items...' 						offerBookishMenu)).	aMenu addUpdating: #showingPageControlsString action: #toggleShowingOfPageControls.	aMenu addUpdating: #showingFullScreenString action: #toggleFullScreen.	aMenu popUpEvent: self world activeHand lastEvent in: self world! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ar 2/6/2001 17:59'!flush	"Flush pending changes"	^self primFlush: fileID! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/6/2001 17:58'!primFlush: id	"Flush pending changes to the disk"	| p |	<primitive: 'primitiveFileFlush' module: 'FilePlugin'>	"In some OS's seeking to 0 and back will do a flush"	p _ self position.	self position: 0; position: p! !!StrikeFont methodsFor: 'file in/out' stamp: 'nop 2/11/2001 00:22'!readBDFFromFile: fileName name: aString	"This builds a StrikeFont instance by reading the X11 Binary 	Distribution Format font source file.  See the BDFFontReader class	comment."	"StrikeFont new readBDFFromFile: 'helvR12' name: 'Helvetica12'."	| fontReader a |	fontReader _ BDFFontReader oldFileNamed: fileName.	a _ fontReader read.	fontReader close.	"{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize} _ fontReader read."	xTable _ a at: 1.	glyphs _ a at: 2.	minAscii _ a at: 3.		"See CharacterScanner>>characterNotInFont. maxAscii+1 must be a legal Character."	maxAscii _ (a at: 4) min: 254.	maxWidth _ a at: 5.	ascent _ a at: 6.	descent _ a at: 7.	pointSize _ a at: 8.	name _ aString.	type _ 0. "no one see this"	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ 0.	self reset.! !!StrikeFont class methodsFor: 'instance creation' stamp: 'nop 1/23/2000 19:21'!newFromBDFFile: aFileName name: aString  "StrikeFont newFromBDFFile: 'helvR12.bdf' name: 'Helvetica12'"	"Read a font from disk in the X11 Bitmap Distribution Format."	| n |	n _ self new.	n readBDFFromFile: aFileName name: aString.	^n.	"TextConstants at: #Helvetica put: (TextStyle fontArray: {StrikeFont newFromBDFFile: 'helvR12.bdf' name: 'Helvetica12'})"	"TextConstants at: #Lucida put: (TextStyle fontArray: {StrikeFont newFromBDFFile: 'luRS12.bdf' name: 'Lucida'})"	"TextStyle default fontAt: 5 put: (StrikeFont new readFromStrike2: 'helv12.sf2')."! !!StrikeFont class methodsFor: 'examples' stamp: 'nop 2/11/2001 13:35'!readStrikeFont2Family: familyName 	"StrikeFont readStrikeFont2Family: 'Lucida'"	"This utility reads all available .sf2 StrikeFont files for a given family from  	the current directory. It returns an Array, sorted by size, suitable for handing 	to TextStyle newFontArray: ."	"For this utility to work as is, the .sf2 files must be named 'familyNN.sf2'."	| fileNames strikeFonts fontArray |	fileNames _ FileDirectory default fileNamesMatching: familyName , '##.sf2'.	strikeFonts _ fileNames collect: [:fname | StrikeFont new readFromStrike2: fname].	strikeFonts do: [ :font | font reset ].	strikeFonts _ strikeFonts asSortedCollection: [:a :b | a height < b height].	fontArray _ strikeFonts asArray.	^ fontArray"TextConstants at: #Lucida put: (TextStyle fontArray: (StrikeFont 	readStrikeFont2Family: 'Lucida'))."! !!String methodsFor: 'internet' stamp: 'RAA 2/6/2001 09:37'!unescapePercents	"change each %XY substring to the character with ASCII value XY in hex.  This is the opposite of #encodeForHTTP"	| ans c asciiVal pos oldPos specialChars |	ans _ WriteStream on: String new.	oldPos _ 1.	specialChars _ '+%' asCharacterSet.	[pos _ self indexOfAnyOf: specialChars startingAt: oldPos. pos > 0]	whileTrue: [		ans nextPutAll: (self copyFrom: oldPos to: pos - 1).		c _ self at: pos.		c = $+ ifTrue: [ans nextPut: $ ] ifFalse: [			(c = $% and: [pos + 2 <= self size]) ifTrue: [				asciiVal _ (self at: pos+1) asUppercase digitValue * 16 +					(self at: pos+2) asUppercase digitValue.				pos _ pos + 2.				asciiVal > 255 ifTrue: [^self].	"not really an escaped string"				ans nextPut: (Character value: asciiVal)]			ifFalse: [ans nextPut: c]].		oldPos _ pos+1].	ans nextPutAll: (self copyFrom: oldPos to: self size).	^ ans contents! !!StringHolderView methodsFor: 'displaying' stamp: 'hmm 6/18/2000 19:24'!displayView 	"Refer to the comment in View|displayView."	Display deferUpdatesIn: self displayBox while: [		self clearInside.		(self controller isKindOf: ParagraphEditor)			ifTrue: [controller display]			ifFalse: [displayContents display]]! !!SuperSwikiServer methodsFor: 'for real' stamp: 'RAA 2/16/2001 18:22'!sendToSwikiProjectServer: anArray	| argsDict answer buildStream |	buildStream _ WriteStream on: String new.	anArray do: [ :each | 		buildStream 			nextPutAll: each size printString;			space;			nextPutAll: each	].	(argsDict _ Dictionary new)		at: 'swikicommands'		put: {buildStream contents}.	answer _ HTTPSocket 		httpPostToSuperSwiki: self url		args: argsDict		accept: 'application/octet-stream' 		request: ''.	^(answer isKindOf: MIMEDocument) ifTrue: [answer content] ifFalse: [answer]! !A single class of morph that holds any piece of Smalltalk, and allows it to be a tile.  Tiles can be dragged in or out of a method. In the message list pane of a Browser, choose 'tile scriptor'.  Bring up a second one to steal parts from.  Clicking multiple times selects enclosing phrases of code.  Dragging lets you take away a copy.  Any tile may be replaced by dropping on it.  Shift-click to edit the text of any tile.  Change variable and message names, but do not change the part-of-speech (objects to selector).Each SyntaxMorph holds a ParseNode.  After editing, the parseNode is only good as a part-of-speech indicator.  Only the classes of the parseNodes are important.  It's state is not kept up to date with the tile edits (but maybe it should be).The correspondence between SyntaxMorphs and parseNodes in the real parse tree is not one-to-one.  Several extra levels of SyntaxMorph were added as aligners to make the horizontal and vertical layout right.  These sometimes have nil for the parseNode.When accept the method, we pass over the tree of SyntaxMorphs, gathering their printStrings and inserting punctuation.  See (SyntaxMorph>>printOn:indent:).  We send the result to the compiler.  (We do not use the parse tree we already have.)To turn on type checking: Preferences enable: #eToyFriendlyor for testing:     World project projectParameters at: #fullCheck put: true.!!SyntaxMorph methodsFor: 'initialization' stamp: 'RAA 2/15/2001 19:43'!drawOn: aCanvas	super drawOn: aCanvas.	self isBlockNode ifFalse: [^self].	self immediatelyBelowTheMethodNode ifTrue: [		aCanvas fillRectangle: (self topLeft + (0@-1) extent: self width@1) color: Color gray	] ifFalse: [		self specialBlockFormatting ifFalse: [			aCanvas fillRectangle: (self topLeft + (1@1) extent: 2@(self height-2)) color: Color gray.			aCanvas fillRectangle: (self topLeft + (1@1) extent: 4@1) color: Color gray.			aCanvas fillRectangle: (self bottomLeft + (1@-1) extent: 4@1) color: Color gray		].	].! !!SyntaxMorph methodsFor: 'initialization' stamp: 'RAA 2/14/2001 20:34'!immediatelyBelowTheMethodNode	^(owner respondsTo: #isMethodNode) and: [owner isMethodNode]! !!SyntaxMorph methodsFor: 'accessing' stamp: 'RAA 2/13/2001 11:19'!actualObject	| sub |	"Who is self in these tiles?  Usually a Player."	(self nodeClassIs: VariableNode) ifTrue: [		(sub _ self findA: StringMorph) ifNil: [^ nil].		^ References at: (self cleanUpString: sub) asSymbol ifAbsent: [nil]].	(self nodeClassIs: LiteralNode) ifTrue: [		(sub _ self findA: StringMorph) ifNil: [^ nil].		^ Compiler evaluate: sub contents				for: nil				logged: false].	(sub _ self findA: SyntaxMorph) ifNil: [^ nil].	^ sub actualObject	"receiver"! !!SyntaxMorph methodsFor: 'accessing' stamp: 'RAA 2/13/2001 23:05'!cleanUpString: stringSubMorph	^ stringSubMorph 		valueOfProperty: #syntacticallyCorrectContents 		ifAbsent: [stringSubMorph contents]! !!SyntaxMorph methodsFor: 'accessing' stamp: 'RAA 2/16/2001 09:52'!specialColor: c1 andBorder: c2	self color: (self scaleColorByUserPref: c1).	self setProperty: #deselectedColor toValue: c1.	self borderColor: (self scaleColorByUserPref: c2).	self setProperty: #deselectedBorderColor toValue: c2.! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 2/13/2001 16:40'!acceptDroppingMorph: aMorph event: evt	| itNoun old |	"For the moment, you have to drop it the right place.  We do not look at enclosing morphs"	"Two ways to do this:  Must always destroy old node, then drag in new one.		Or, drop replaces what you drop on.  Nasty with blocks.  see wantsDroppedMorph:event:"	"We know it is acceptable.  Just a matter of which case"	itNoun _ aMorph isNoun.	self withAllOwnersDo:		[:m | (m isSyntaxMorph and: [m isBlockNode])			ifTrue: [m stopStepping; removeDropZones]].	self isBlockNode & itNoun		ifTrue:			[(aMorph nodeClassIs: TempVariableNode) ifTrue:				["If I am a BlockNode, and it is a TempVariableNode, add it into list"				^ (self addBlockArg: aMorph) ifFalse:					["if already declared, start new line of code with it"					self addToBlock: aMorph event: evt]]			ifFalse:			[^ self addToBlock: aMorph event: evt]].	"If I am a BlockNode and it is a noun add it as a new line"	self isBlockNode ifTrue: [		 (aMorph nodeClassIs: ReturnNode) ifTrue: [^ self addToBlock: aMorph event: evt]].	"Later add args and keywords.  later allow comments to be dropped"	"Can't put statement, literal, assignment, or cascade into left side of assignment"	(owner isSyntaxMorph) ifTrue:		[(owner nodeClassIs: AssignmentNode) ifTrue:			[(owner submorphIndexOf: self) = 1 ifTrue:				[((aMorph nodeClassIs: TempVariableNode)				or: [aMorph nodeClassIs: VariableNode])  ifFalse: [ ^ self]]]].	aMorph deselect.	(old _ owner) replaceSubmorph: self by: aMorph.	"do the normal replacement"	(old isSyntaxMorph) ifTrue: [old cleanupAfterItDroppedOnMe].	"now owned by no one"! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 2/13/2001 16:45'!morphToDropInPasteUp: aPasteUp	"If property #beScript is true, create a scriptor around me."	| actualObject itsSelector aScriptor adjustment handy tw blk |	self flag: #noteToTed.  "I changed PhraseTileMorph's version of this method to eliminate the flagshipInstance annoyance, and the below needs to be changed accordingly -- look at my method and notice diffs.  Besides eliminating the flagshipInstance test, one needs to be sure that the thing dropped is adjusted to reflect which instance of the uniclass is at hand.  sw 1/19/2001 02:30"	(self valueOfProperty: #beScript ifAbsent: [false]) ifFalse: [^ self].	self removeProperty: #beScript.	(actualObject _ self actualObject) ifNil: [^ self].	actualObject assureUniClass.	itsSelector _ self userScriptSelector.	aScriptor _ itsSelector isEmptyOrNil		ifFalse:			[adjustment _ 0@0.			actualObject scriptEditorFor: itsSelector]		ifTrue:			["It's a system-defined selector; construct an anonymous scriptor around it"			adjustment _ 60 @ 20.			actualObject newScriptorAround: self].	handy _ aPasteUp primaryHand.	aScriptor ifNotNil: [		aScriptor position: handy position - adjustment.		aPasteUp addMorphFront: aScriptor.	"do this early so can find World"		(tw _ aScriptor findA: TwoWayScrollPane) ifNil: [			aScriptor useNewTiles.			itsSelector ifNil: ["blank script"				tw _ aScriptor findA: TwoWayScrollPane.				blk _ tw scroller firstSubmorph "MethodNode" lastSubmorph "BlockNode".				blk addMorphFront: self.				"self position: self topLeft + (7@14)"]]].	aScriptor showSourceInScriptor.  "**This destroys most of the work done before**"	aScriptor hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		cellPositioning: #topLeft.	(aScriptor isKindOf: ScriptEditorMorph) ifTrue:		[aScriptor playerScripted expungeEmptyUnRenamedScripts].	^ aScriptor ifNil: [self]! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 2/12/2001 15:22'!structureMatchWith: aMorph	| meNoun itNoun |	"Return true if the node types would allow aMorph to replace me.  This tests the gross structure of the method only."	"If nodes are of equal class, replace me with new one."	(self nodeClassIs: MessageNode) ifFalse: [		(self nodeClassIs: aMorph parseNode class) ifTrue: [^ true]].	meNoun _ self isNoun.	itNoun _ aMorph isNoun.	"Consider these nouns to be equal:  TempVariableNode, LiteralNode, VariableNode, (MessageNode with receiver), CascadeNode, AssignmentNode"	meNoun & itNoun ifTrue: [^ true].	meNoun & aMorph isBlockNode ifTrue: [^ true].	"If I am a BlockNode, and it is a TempVariableNode, add it into list"	"If I am a BlockNode, and it is a noun, add it as a new line"	self isBlockNode ifTrue:		[itNoun ifTrue: [^ true].		(aMorph nodeClassIs: ReturnNode) ifTrue:			[^ (self submorphs				detect: [:mm | ((mm isSyntaxMorph) and: [mm nodeClassIs: ReturnNode])]				ifNone: [nil]) isNil]].	"none already in this block"				"If I am a BlockNode, and it is a ReturnNode, add to end"	(self isMethodNode) ifTrue: [^ false].	"Later add args and keywords"		"Later allow comments to be dropped in"		"Add MethodTemps by dropping into the main block"	^ false "otherwise reject"! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 2/12/2001 15:57'!wantsDroppedMorph: aMorph event: evt	"For the moment, you have to drop it the right place.  We do not look at enclosing morphs"	"Two ways to do this:  Must always destroy old node, then drag in new one.		Or, drop replaces what you drop on.  Nasty with blocks."	(aMorph isKindOf: SyntaxMorph) ifFalse: [^ false].	(self structureMatchWith: aMorph) ifFalse: [^ false].	"gross structure"	"Only look at types if NoviceMode -- building EToys"	^ self okToBeReplacedBy: aMorph.	"test the types"	"^ true"! !!SyntaxMorph methodsFor: 'highlighting' stamp: 'RAA 2/14/2001 19:44'!stdBorderColor 	"several choices of how to do the border"	self class noTileColor		ifTrue: [^self valueOfProperty: #deselectedBorderColor ifAbsent: [Color transparent]]		ifFalse: [^ self valueOfProperty: #deselectedBorderColor ifAbsent: [Color transparent]]! !!SyntaxMorph methodsFor: 'highlighting' stamp: 'RAA 2/15/2001 19:48'!unhighlight	self currentSelectionDo: [:innerMorph :mouseDownLoc :outerMorph |		self borderColor: (			(self == outerMorph or: [owner notNil and: [owner isSyntaxMorph not]])				ifTrue: [self valueOfProperty: #deselectedBorderColor ifAbsent: [#raised]]				ifFalse: [self stdBorderColor]		)	]! !!SyntaxMorph methodsFor: 'selection' stamp: 'RAA 2/14/2001 11:33'!deselect	self allMorphsDo:		[:m | m isSyntaxMorph ifTrue: [m setDeselectedColor]].	"Note following is wasteful because we do a deselect before each select, and it is often the same morph."	self deletePopup! !!SyntaxMorph methodsFor: 'selection' stamp: 'RAA 2/16/2001 10:41'!scaleColorByUserPref: aColor		| myRoot underLyingColor |	myRoot _ self rootTile.	underLyingColor _ myRoot ifNil: [Color transparent] ifNotNil: [myRoot color].	[underLyingColor isTransparent and: [(myRoot _ myRoot owner) notNil]] whileTrue: [		underLyingColor _ myRoot color.	].		"rude hack to get the desired effect before we have an owner"	underLyingColor isTransparent ifTrue: [underLyingColor _ Color r: 0.903 g: 1.0 b: 0.903].	^aColor mixed: (ContrastFactor ifNil: [0.3]) with: underLyingColor! !!SyntaxMorph methodsFor: 'selection' stamp: 'RAA 2/16/2001 09:52'!setDeselectedColor		| deselectedColor deselectedBorderColor |	deselectedColor _ self valueOfProperty: #deselectedColor ifAbsent: [nil].	deselectedBorderColor _ self valueOfProperty: #deselectedBorderColor ifAbsent: [nil].	deselectedColor ifNotNil: [		deselectedColor _ self scaleColorByUserPref: deselectedColor	].	deselectedBorderColor ifNotNil: [		deselectedBorderColor _ self scaleColorByUserPref: deselectedBorderColor	].	self 		color: (deselectedColor ifNil: [Color transparent]);		borderColor: (deselectedBorderColor ifNil: [Color transparent])! !!SyntaxMorph methodsFor: 'insertion drop zones' stamp: 'tk 2/13/2001 15:00'!trackDropZones	| hand i localPt insertion insHt ii prevBot nxtHt d c1 c2 ht2 spacer1 spacer2 wid ht1 |	hand _ self primaryHand.	(hand lastEvent redButtonPressed & hand hasSubmorphs		and: [(self hasOwner: hand) not]) ifFalse: [^ self].	insertion _ hand firstSubmorph renderedMorph.	insertion isSyntaxMorph ifFalse: [^ self].	insertion isNoun ifFalse: [^ self].	localPt _ self globalPointToLocal: hand position.	insHt _ insertion height.  "**just use standard line height here"	self removeDropZones.  "Maybe first check if in right place, then just tweak heights."	i _ (ii _ self indexOfMorphAbove: localPt) min: submorphs size-1.	prevBot _ i <= 0 ifTrue: [(self innerBounds) top]					ifFalse: [(self submorphs at: i) bottom].	nxtHt _ (submorphs isEmpty		ifTrue: [insertion]		ifFalse: [self submorphs at: i+1]) height.	d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]			ifFalse: [0 max: (localPt y - prevBot min: nxtHt)].	"Top and bottom spacer heights cause continuous motion..."	c1 _ Color yellow lighter.  c2 _ Color transparent.	ht2 _ d*insHt//nxtHt.  ht1 _ insHt - ht2.	wid _ 100 min: owner width - 10.	(spacer1 _ BorderedMorph newBounds: (0@0 extent: wid@ht1)					color: (ht1 > (insHt//2) ifTrue: [c1] ifFalse: [c2]))					borderWidth: 1; borderColor: spacer1 color.	self privateAddMorph: spacer1 atIndex: (i+1 max: 1).	(spacer2 _ BorderedMorph newBounds: (0@0 extent: wid@ht2)					color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]))					borderWidth: 1; borderColor: spacer2 color.	spacer1 setProperty: #dropZone toValue: true.	spacer2 setProperty: #dropZone toValue: true.	self privateAddMorph: spacer2 atIndex: (i+3 min: submorphs size+1).	self fullBounds.  "Force layout prior to testing for cursor containment"	"Maintain the drop target highlight -- highlight spacer if hand is in it."	{spacer1. spacer2} do:		[:spacer | (spacer containsPoint: localPt) ifTrue:			[spacer borderColor: self dropColor.			self borderColor = self dropColor				ifTrue: [self borderColor: self stdBorderColor]]].	"If no submorph (incl spacers) highlighted, then re-highlight the block."	((self wantsDroppedMorph: insertion event: hand lastEvent) and:		[(self submorphs anySatisfy: [:m | m containsPoint: localPt]) not])		ifTrue: [self borderColor: self dropColor]! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/15/2001 19:37'!addBlockArg: aMorph	"Add a temporary to a block or the method.  Return true if succeed"	"(aMorph nodeClassIs: TempVariableNode) is known to be true."	"***NOTE: This method should be combined with addTempVar:"	| tempHolder tt var nn |	owner isMethodNode ifTrue: [		^ (self addTempVar: aMorph)].	"Node for them is not inside the block"		"If exists, drop the temp in this block and let use extend it."	tt _ self firstSubmorph.	tempHolder _ tt firstSubmorph isSyntaxMorph 				ifTrue: [(tt nodeClassIs: BlockArgsNode) 							ifTrue: [tt] ifFalse: [nil]]				ifFalse: [nil].	nn _ aMorph parseNode key.	"name"	tempHolder ifNil: ["make whole row"		tempHolder _ self addRow: #blockarg1 on: (BlockArgsNode new).		self addMorphFront: tempHolder.		tempHolder addNoiseString: 'Use'.		aMorph parseNode name: nn key: nn code: nil.		var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.		var layoutInset: 1.		var addMorphBack: (self addString: nn).		self cleanupAfterItDroppedOnMe.		^ true].	tempHolder submorphsDo:		[:m | "if present. caller adds the temp as a new line of code to be extended"		m isSyntaxMorph and: [m parseNode key = nn ifTrue: [^ false]]].			"If this variable is not present, add it"	tempHolder addNoiseString: 'Use'.	aMorph parseNode name: nn key: nn code: nil.	tempHolder addMorphBack: (tempHolder transparentSpacerOfSize: 4@4).	var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.	var layoutInset: 1.	var addMorphBack: (StringMorph contents: nn).	var cleanupAfterItDroppedOnMe.	^ true! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/15/2001 19:39'!addNoiseString: aNoiseString	| sMorph |	self noiseWordsAdded ifFalse: [^self].	sMorph _ StringMorph contents: aNoiseString.	sMorph 		font: (self fontToUseForSpecialWord: aNoiseString) emphasis: 1; 		color: (self colorForKeywords: aNoiseString and: aNoiseString);		setProperty: #noiseWord toValue: true.	^(self addColumn: #keyword1 on: nil)		layoutInset: 1;		addMorphBack: sMorph.! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/15/2001 19:22'!addRow: aColorOrSymbol on: aNode	| row |	self addMorphBack: (row _ self class row: aColorOrSymbol on: aNode)."row setProperty: #howCreated toValue: thisContext longStack."	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/14/2001 19:12'!addSingleKeywordRow: aStringLikeItem	| row sMorph modifiedString fontToUse |	(row _ self class row: #text on: nil) borderWidth: 1.	modifiedString _ self substituteKeywordFor: aStringLikeItem.	sMorph _ self addString: modifiedString.	fontToUse _ self fontToUseForSpecialWord: modifiedString.	sMorph 		font: fontToUse emphasis: 1;		color: (self colorForKeywords: aStringLikeItem and: modifiedString);		setProperty: #syntacticallyCorrectContents toValue: aStringLikeItem.	row addMorph: sMorph.	self addMorphBack: row.	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/15/2001 19:38'!addTempVar: aMorph 	"know we are a block inside a MethodNode" 	"(aMorph nodeClassIs: TempVariableNode) is known to be true."	| tempHolder ii tt var nn |	tempHolder _ (ii _ owner submorphIndexOf: self) = 1				ifFalse: [tt _ owner submorphs at: ii - 1.						(tt isSyntaxMorph and: [tt nodeClassIs: MethodTempsNode])					 		ifTrue: [tt] ifFalse: [nil]]				ifTrue: [nil].	nn _ aMorph parseNode key.	"name"	tempHolder ifNil: [		tempHolder _ owner addRow: #tempVariable on: MethodTempsNode new.		tempHolder addNoiseString: 'Use'.		owner addMorph: tempHolder inFrontOf: self.		aMorph parseNode name: nn key: nn code: nil.		aMorph parseNode asMorphicSyntaxIn: tempHolder.		tempHolder cleanupAfterItDroppedOnMe.		^ true].	tempHolder submorphsDo:		[:m | m isSyntaxMorph and: [m parseNode key = nn ifTrue: [^ false]]].	aMorph parseNode name: nn key: nn code: nil.	tempHolder addNoiseString: 'Use'.	tempHolder addMorphBack: (tempHolder transparentSpacerOfSize: 4@4).	var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.	var layoutInset: 1.	var addMorphBack: (self addString: nn).	var cleanupAfterItDroppedOnMe.	^ true! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/15/2001 19:41'!addToken: aString type: aColorOrSymbol on: aNode	| sMorph modifiedString |	sMorph _ self addString: aString.	self specialBlockFormatting ifTrue: [		(aColorOrSymbol == #keyword2) ifTrue: [			modifiedString _ self substituteKeywordFor: aString.			sMorph 				font: (self fontToUseForSpecialWord: modifiedString) emphasis: 1; 				color: (self colorForKeywords: aString and: modifiedString);				setProperty: #syntacticallyCorrectContents toValue: aString;				contents: modifiedString.		].	].	^(self addColumn: aColorOrSymbol on: aNode)		layoutInset: 1;		addMorphBack: sMorph! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/15/2001 19:42'!colorForKeywords: original and: modified	(#('ifTrue:' 'ifFalse:' 'Test') includes: original asString) ifTrue: [		^Color black	].	^(Color r: 0.333 g: 0.333 b: 0.333)! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/15/2001 19:43'!foldMessage	"I am a message whose receiver is wide, and whose message part is a column.	Rearrange me so that the message part appears indented under the receiver part."	| messageRow node2 |	node2 _ parseNode copy receiver: nil.	messageRow _ SyntaxMorph row: #keyword1 on: node2.	messageRow 		addMorph: (self transparentSpacerOfSize: 20@10);		addMorphBack: submorphs last.		"<<handle noise words better"	self listDirection: #topToBottom;		wrapCentering: #topLeft;		addMorphBack: (self transparentSpacerOfSize: 4@4);		addMorphBack: messageRow.! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/14/2001 19:13'!fontToUseForSpecialWord: aString	^(#('Yes' 'No' 'Test') includes: aString) ifTrue: [		(StrikeFont familyName: 'Helvetica' size: 14)	] ifFalse: [		nil	]! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/13/2001 18:12'!substituteKeywordFor: aString	aString asString = 'ifTrue:' ifTrue: [^'Yes'].	aString asString = 'ifFalse:' ifTrue: [^'No'].	^String streamContents: [ :strm |		aString do: [ :each | 			each = $: ifFalse: [				each isUppercase ifTrue: [strm space; nextPut: each asLowercase]					ifFalse: [strm nextPut: each]			].		]	].! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 2/12/2001 14:39'!try	"Evaluate me once"	(#(MessageNode LiteralNode VariableNode) includes: parseNode class name) 		ifFalse: [^ Error new].	^ [Compiler evaluate: self decompile				for: self actualObject				logged: false.	"should do something to the player"		] ifError: [ :a :b | Error new].! !!SyntaxMorph methodsFor: 'printing' stamp: 'RAA 2/16/2001 18:13'!printOn: strm indent: level	| lev nodeClass parens cnt |	"Tree walk and produce text of the code.  #ST80.  Just do it in one big ugly method."	lev _ level.	(nodeClass _ parseNode class) == BlockNode ifTrue: [		owner isSyntaxMorph ifTrue: [			owner isMethodNode ifFalse: [strm nextPut: $[.  lev _ lev+1]]].				"normal block has []"	nodeClass == VariableNode ifTrue: ["nil out any old association"		parseNode key class == Association ifTrue: [			parseNode name: (parseNode name) key: nil code: (parseNode code)]].	(nodeClass == MessageNode or: [nodeClass == CascadeNode]) ifTrue: [		parseNode receiver ifNotNil: [parens _ true.  strm nextPut: $( ]].	"has a receiver"	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; space].	cnt _ 0.	submorphs do: [:sub |		sub isSyntaxMorph ifTrue: [cnt _ cnt + 1.			(nodeClass == CascadeNode "and: [sub isCascadePart]") ifTrue:				[cnt > 2 ifTrue: [strm nextPutAll: '; ']].			nodeClass == BlockArgsNode ifTrue: [strm nextPut: $:].			sub printOn: strm indent: lev.	"<<<<### install the subnode"			(nodeClass == BlockNode) & (sub parseNode class == BlockArgsNode) not	&				(sub parseNode class == ReturnNode) not					ifTrue: [strm nextPut: $.].			(nodeClass == BlockNode) & (sub parseNode class == BlockArgsNode) not				ifTrue: [strm crtab: lev]				ifFalse: [self isMethodNode ifTrue: [strm crtab: lev] ifFalse: [strm space]].			].		(sub isKindOf: StringMorph) ifTrue: [			self printSimpleStringMorph: sub on: strm		].		"return indent for ifTrue: ifFalse:"].	parens == true ifTrue: [strm nextPut: $) ].	"has a receiver"	nodeClass  == BlockNode ifTrue: [		owner isSyntaxMorph ifTrue: [			owner isMethodNode ifFalse: [strm nextPut: $] ]]].				"normal block has []"	nodeClass == BlockArgsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodNode ifTrue: [		strm contents last "ugh!!" == $. ifTrue: [strm skip: -1]].	"erase last period"! !!SyntaxMorph methodsFor: 'printing' stamp: 'RAA 2/16/2001 18:16'!printSimpleStringMorph: aMorph on: strm	| trialContents |	(aMorph hasProperty: #wordyVariantOfSelf) ifTrue: [		strm nextPutAll: 'self '.		strm nextPutAll: ((self translateToWordySelfVariant: aMorph contents) ifNil: [^self]).		^self	].	(aMorph hasProperty: #noiseWord) ifFalse: [		trialContents _ self cleanUpString: aMorph.		strm nextPutAll: trialContents	].! !!SyntaxMorph methodsFor: 'printing' stamp: 'RAA 2/13/2001 23:10'!printStatementsOn: aStream indent: indent	"seemed to be necessary to see top node in explorer"	^parseNode printStatementsOn: aStream indent: indent! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 2/13/2001 20:23'!accept	"Turn my current state into the text of a method.  Compile it in my class."	| cls sc |	self isMethodNode ifFalse: [		self rootTile == self ifTrue: [^ self].  "not in a script"		^ self rootTile accept  "always accept at the root"].	(cls _ self parsedInClass) ifNil: [^ self].	cls compile: self decompile notifying: nil.	(sc _ self firstOwnerSuchThat: [:mm | mm class == ScriptEditorMorph]) 		ifNotNil: [sc hibernate; unhibernate].	"rebuild the tiles"! !!SyntaxMorph methodsFor: 'menus' stamp: 'RAA 2/14/2001 15:40'!acceptIgnoring: aString	"If I am inside a ScriptEditorMorph, tell my root to accept the new changes.  Ignore the argument, which is the string whose conents just changed."	thisContext sender receiver removeProperty: #syntacticallyCorrectContents.	self acceptIfInScriptor! !!SyntaxMorph methodsFor: 'menus' stamp: 'RAA 2/15/2001 19:51'!addColumn: aColorOrSymbol on: aNode	| col |	self addMorphBack: (col _ self class column: aColorOrSymbol on: aNode)."col setProperty: #howCreated toValue: thisContext longStack."	self specialBlockFormatting ifTrue: [		(aColorOrSymbol == #block and: [self isMethodNode not]) ifTrue: [			self setConditionalPartStyle: col.		].	].	^ col! !!SyntaxMorph methodsFor: 'menus' stamp: 'RAA 2/15/2001 19:22'!addMorphBack: m"m setProperty: #howAdded toValue: thisContext longStack."	^super addMorphBack: m! !!SyntaxMorph methodsFor: 'menus' stamp: 'RAA 2/16/2001 17:08'!finalAppearanceTweaks	SizeScaleFactor ifNil: [SizeScaleFactor _ 1.0]. 	self allMorphsDo: [ :each |		(each respondsTo: #setDeselectedColor) ifTrue: [each setDeselectedColor].		(each hasProperty: #variableInsetSize) ifTrue: [			each layoutInset: 				((each valueOfProperty: #variableInsetSize) * SizeScaleFactor) rounded.		].	].! !!SyntaxMorph methodsFor: 'menus' stamp: 'RAA 2/14/2001 22:37'!setConditionalPartStyle: aMorph	aMorph specialColor: Color paleGreen andBorder: (Color r: 0.581 g: 0.774 b: 0.903).	aMorph useRoundedCorners.	aMorph borderWidth: 1.! !!SyntaxMorph methodsFor: 'type checking' stamp: 'tk 2/9/2001 10:07'!allSpecs	| all pairs clsName |	"Return all specs that the Viewer knows about.  Maybe cache it."	"SyntaxMorph new allSpecs"	all _ OrderedCollection new.	pairs _ Smalltalk allImplementorsOf: #additionsToViewerCategories.	pairs do: [:pp |		clsName _ (pp findTokens: ' ') first.		all addAll: (Smalltalk at: clsName asSymbol) additionsToViewerCategories].	^ all! !!SyntaxMorph methodsFor: 'type checking' stamp: 'tk 2/12/2001 16:26'!argTypeFor: aSelector	| where |	"Search for the type of the argument of this selector.  Return #unknown if not found."where _ aSelector numArgs = 0 	ifTrue: [self inform: aSelector, ' does not take an argument'. ^ #error "7"] 	ifFalse: [9].self class allSpecs do: [:catPair |	catPair second do: [:spec |		spec first == #command ifTrue: [			spec second == aSelector ifTrue: ["ours"				spec size < 4 ifTrue: [^ #unknown] ifFalse: [^ spec fourth]]].		spec first == #slot ifTrue: [			spec size >= where ifTrue: [				(spec at: where) == aSelector ifTrue: ["ours" ^ spec fourth]]].		]].^ #unknown"What if the same selector appears more than one time?"! !!SyntaxMorph methodsFor: 'type checking' stamp: 'tk 2/13/2001 20:25'!okToBeReplacedBy: aSyntaxMorph	| itsType myType |	"Return true if it is OK to replace me with aSyntaxMorph.  Enforce the type rules in the old EToy green tiles.	World project projectParameters at: #fullCheck put: true.	"	((Preferences eToyFriendly) or: 		[self world project projectParameters at: #fullCheck ifAbsent: [false]]) 			ifFalse: [^ true].	"not checking"	(parseNode class == BlockNode and: [aSyntaxMorph parseNode class == BlockNode]) 		ifTrue: [^ true].	(parseNode class == ReturnNode and: [aSyntaxMorph parseNode class == ReturnNode]) 		ifTrue: [^ true].	parseNode class == KeyWordNode ifTrue: [^ false].	aSyntaxMorph parseNode class == KeyWordNode ifTrue: [^ false].	parseNode class == SelectorNode ifTrue: [^ false].	aSyntaxMorph parseNode class == SelectorNode ifTrue: [^ false].	owner isSyntaxMorph ifFalse: [^ true].	"only within a script"		"Transcript show: aSyntaxMorph resultType printString, ' dropped on ', 			self receiverOrArgType printString; cr.		"	(itsType _ aSyntaxMorph resultType) == #unknown ifTrue: [^ true].	(myType _ self receiverOrArgType) == #unknown ifTrue: [^ true].		"my type in enclosing message"	^ myType = itsType! !!SyntaxMorph methodsFor: 'type checking' stamp: 'tk 2/9/2001 15:56'!receiverOrArgType	| ty |	"Return my type in my role as a receiver or as an argument.  Ask my enclosing message first, then ask myself.  (If owner accepts any #object, and I am a #point, do return #object.)"	^ (ty _ self receiverOrArgTypeAbove) == #unknown		ifTrue: [self resultType]		ifFalse: [ty]! !!SyntaxMorph methodsFor: 'type checking' stamp: 'tk 2/13/2001 15:33'!receiverOrArgTypeAbove	| enclosing sub list |	"Return the type for me according to the message that encloses me."	(self nodeClassIs: BlockNode) ifTrue: [^ #command].	enclosing _ owner.  sub _ self.	[enclosing isSyntaxMorph ifFalse: [^ #unknown].	 (enclosing nodeClassIs: MessageNode) ifTrue: [		 list _ enclosing submorphs select: [:ss | ss isSyntaxMorph and: [ss parseNode ~~ nil]].		 list size = 1 ifFalse: [			^ (list indexOf: sub) = 1 				ifTrue: [enclosing receiverTypeFor: enclosing selector]				ifFalse: [enclosing argTypeFor: enclosing selector]]].	 (enclosing nodeClassIs: BlockNode) ifTrue: [^ #command].	 sub _ enclosing. 	 enclosing _ enclosing owner.	 true] whileTrue.! !!SyntaxMorph methodsFor: 'type checking' stamp: 'tk 2/12/2001 16:26'!receiverTypeFor: aSelector	| where |	"Search for the type of the receiver of this selector.  Return #unknown if not found."where _ aSelector numArgs = 0 	ifTrue: [7] 	ifFalse: [9].self class allSpecs do: [:catPair |	catPair second do: [:spec |		spec first == #command ifTrue: [			spec second == aSelector ifTrue: ["ours" ^ #player]].		spec first == #slot ifTrue: [			spec size >= where ifTrue: [				(spec at: where) == aSelector ifTrue: ["ours"					^ spec at: where-1]]].		]].^ #unknown"What if the same selector appears more than one time?"! !!SyntaxMorph methodsFor: 'type checking' stamp: 'tk 2/12/2001 14:40'!resultType	| list value soundChoices |	"Look up my result type.  If I am a constant, use that class.  If I am a message, look up the selector."	parseNode class == BlockNode ifTrue: [^ #blockContext].	list _ submorphs select: [:ss | ss isSyntaxMorph and: [ss parseNode ~~ nil]].	list size > 1 ifTrue: [^ self resultTypeFor: self selector].	list size = 1 ifTrue: ["test for levels that are just for spacing in layout"		(list first isSyntaxMorph and: [list first nodeClassIs: MessageNode]) ifTrue: [			^ list first resultType]].	"go down one level"	value _ self try.	value class == Error ifTrue: [^ #unknown].	(value isKindOf: Number) ifTrue: [^ #number].	(value isKindOf: Boolean) ifTrue: [^ #boolean].	value class == String ifTrue: [		soundChoices _ #('silence').  "default, if no SampledSound class"		Smalltalk at: #SampledSound ifPresent:			[:sampledSound | soundChoices _ sampledSound soundNames].		(soundChoices includes: value) ifTrue: [^ #sound]].	(value isKindOf: Player) ifTrue: [^ #player].	^ value class name asLowercase "asSymbol (not needed)"! !!SyntaxMorph methodsFor: 'type checking' stamp: 'tk 2/13/2001 21:20'!resultTypeFor: aSelector	| where |	"Search for the type of the argument of this selector.  Return #unknown if not found."aSelector ifNil: [self inform: 'Please tell Ted how you caused this'.	^ #abs "a bogus type"].where _ aSelector numArgs = 0 	ifTrue: [7] 	ifFalse: [9].self class allSpecs do: [:catPair |	catPair second do: [:spec |		spec first == #command ifTrue: [			spec second == aSelector ifTrue: ["ours" ^ #command]].		spec first == #slot ifTrue: [			spec size >= where ifTrue: [				(spec at: where) == aSelector ifTrue: ["ours"					where = 9 						ifTrue: [^ #command]	"Not supposed to use a setter for its result"						ifFalse: [^ spec fourth]]]].		]].^ #unknown"What if the same selector appears more than one time?"! !!SyntaxMorph methodsFor: 'type checking' stamp: 'tk 2/13/2001 15:59'!selector	| sel cnt |	"Find the selector I represent, or have inside of me.  My parseNode is a SelectorNode or a MessageNode."	parseNode class == SelectorNode ifTrue: [		^ (self findA: StringMorph) contents asSymbol].	parseNode class == KeyWordNode ifTrue: [		^ (self findA: StringMorph) contents asSymbol].	sel _ ''.  cnt _ 0.	submorphs do: [:mm | 		mm isSyntaxMorph ifTrue: [ cnt _ cnt + 1.			(mm nodeClassIs: SelectorNode) ifTrue: [^ mm selector].			(mm nodeClassIs: MessagePartNode) ifTrue: [				sel _ sel, mm selector].			(mm nodeClassIs: KeyWordNode) ifTrue: [				sel _ sel, (mm findA: StringMorph) contents].			cnt = 2 ifTrue: ["not the receiver.  Selector and arg"				(mm nodeClassIs: MessageNode) ifTrue: [					sel _ mm selector]]]].	sel size > 0 ifTrue: [^ sel asSymbol].	^ nil! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/16/2001 17:02'!addTemporaryControls	| row stdSize |		stdSize _ 8@8.	row _ AlignmentMorph newRow		color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	self addMorph: row.	{		Morph new			extent: stdSize; 			setBalloonText: 'Change the contrast';			on: #mouseUp send: #controlContrast: to: self.		Morph new			extent: stdSize; 			color: Color green;			setBalloonText: 'Change basic spacing';			on: #mouseUp send: #controlSpacing: to: self.		Morph new			extent: stdSize; 			color: Color red;			setBalloonText: 'Change basic style';			on: #mouseUp send: #changeBasicStyle to: self.	} do: [ :each |		row addMorphBack: each.		row addMorphBack: (self transparentSpacerOfSize: stdSize).	].! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/15/2001 19:41'!blockNode: aNode arguments: arguments statements: statements	| row column |	(column _ self addColumn: #block on: aNode) layoutInset: 2@-1.	aNode addCommentToMorph: column.	arguments size > 0 ifTrue: [		row _ column addRow: #blockarg1 on: (BlockArgsNode new).		row addNoiseString: 'Use'.		arguments do: [:arg | (arg asMorphicSyntaxIn: row) color: #blockarg2]	].	statements do: [ :each | 		(each asMorphicSyntaxIn: column) borderWidth: 1.		each addCommentToMorph: column	].	^ column! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/16/2001 16:34'!changeBasicStyle	self removeAllMorphs.	self setProperty: #alansNewStyle toValue: self alansTest1 not.	self methodNodeOuter: parseNode! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/16/2001 17:49'!constructSelfVariant: receiver and: key	| wordy |	(receiver isKindOf: VariableNode) ifFalse: [^nil].	receiver name = 'self'  ifFalse: [^nil].	(wordy _ self translateFromWordySelfVariant: key) ifNil: [^nil].	^wordy! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/16/2001 19:35'!messageNode: aNode receiver: receiver selector: selector keywords: key arguments: args	| keywords column row receiverMorph firstArgMorph receiverWidth		messageWidth onlyOne nodeWithNilReceiver isAConditional 		testAndReceiver anotherSelf wordyMorph |	isAConditional _ #(ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:) includes: key.	receiver ifNotNil: ["i.e. not a cascade"		anotherSelf _ self constructSelfVariant: receiver and: key.		anotherSelf ifNotNil: [			wordyMorph _ self addString: anotherSelf.			wordyMorph setProperty: #wordyVariantOfSelf toValue: true.			self addMorph: wordyMorph. 			self layoutInset: 1.			^self		].		testAndReceiver _ self.		self specialBlockFormatting ifTrue: [			isAConditional ifTrue: [				testAndReceiver _ self addRow: #keyword1 on: nil.				self 					specialColor: (Color r: 1.0 g: 0.935 b: 0.774) 					andBorder: (Color r: 0.581 g: 0.774 b: 0.903).				self useRoundedCorners.				self layoutInset: 6.				self setProperty: #variableInsetSize toValue: 6.				testAndReceiver addNoiseString: 'Test'			].		].		receiverMorph _ receiver asMorphicSyntaxIn: testAndReceiver.		self specialBlockFormatting ifTrue: [			isAConditional ifTrue: [self setConditionalPartStyle: receiverMorph].		].	].	keywords _ key keywords.	args size = 0 ifTrue: [		row _ (self addSingleKeywordRow: key) layoutInset: 1.		^ row parseNode: selector	].	receiverWidth _ receiver				ifNil: [0]				ifNotNil: [receiverMorph fullBounds width].	onlyOne _ args size = 1.	(receiverWidth <= 80 and: [onlyOne]) ifTrue: [		row _ (self addSingleKeywordRow: keywords first) layoutInset: 1.		row parseNode: selector.		firstArgMorph _ args first asMorphicSyntaxIn: self.		receiver ifNil: [^ self].		(firstArgMorph fullBounds height > 100				or: [firstArgMorph fullBounds width > 250])			ifTrue: [self foldMessageOneArg].		^ self	].	nodeWithNilReceiver _ aNode copy receiver: nil.	isAConditional & self specialBlockFormatting ifTrue: [		self listDirection: #topToBottom.	].	column _ self addColumn: #keyword1 on: nodeWithNilReceiver.	messageWidth _ 0.	keywords		with: (args copyFrom: 1 to: keywords size)		do: [:kwd :arg |			isAConditional ifTrue: [				column addMorphBack: (column transparentSpacerOfSize: 3@3).			].			(row _ column addRow: #keyword2 on: nodeWithNilReceiver) borderWidth: 1;				parseNode: (nodeWithNilReceiver as: 						(onlyOne ifTrue: [MessageNode] ifFalse: [MessagePartNode]));				 borderColor: row stdBorderColor.			isAConditional ifTrue: [row addMorphBack: (row transparentSpacerOfSize: 20@6)].			row addToken: kwd				type: #keyword2				on: (onlyOne ifTrue: [SelectorNode new key: kwd code: nil "fill this in?"]								ifFalse: [KeyWordNode new]).			arg asMorphicSyntaxIn: row.			messageWidth _ messageWidth + row fullBounds width].	receiverMorph ifNil: [^self].	self alansTest1 ifTrue: [^self].	receiverWidth + messageWidth < 350 ifTrue: [		isAConditional ifFalse: [self unfoldMessage].		^self	].	((receiverWidth > 200						or: [receiverWidth > 80								and: [column fullBounds height > 20]])					or: [receiverMorph fullBounds width > 30							and: [column fullBounds height > 100									or: [column fullBounds width > 250]]])				ifTrue: [^ self foldMessage]! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/16/2001 15:43'!methodNodeInner: aNode selectorOrFalse: selectorOrFalse precedence: precedence arguments: arguments temporaries: temporaries primitive: primitive block: block	| header tempMorph selNode |	selNode _ selectorOrFalse class == SelectorNode 		ifTrue: [selectorOrFalse] 		ifFalse: [SelectorNode new key: selectorOrFalse code: nil].	header _ self addRow: Color white on: selNode.	precedence = 1		ifTrue: [header addToken: aNode selector type: #keyword1 on: selNode]		ifFalse: [aNode selector keywords with: arguments do:					[:kwd :arg | 					header addToken: kwd type: #keyword2 on: selNode.					(arg asMorphicSyntaxIn: header) color: #blockarg2]].	aNode addCommentToMorph: self.	temporaries size > 0 ifTrue: [		tempMorph _ self addRow: #tempVariable on: (MethodTempsNode new).		temporaries do: [:temp | temp asMorphicSyntaxIn: tempMorph ]				separatedBy: [tempMorph addMorphBack: (tempMorph transparentSpacerOfSize: 4@4)]].	(primitive > 0 and: [(primitive between: 255 and: 519) not]) ifTrue:		["Dont decompile <prim> for, eg, ^ self "		self addTextRow: (String streamContents: [ :strm | aNode printPrimitiveOn: strm])].	block asMorphicSyntaxIn: self.	^ self! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/16/2001 16:59'!methodNodeOuter: aNode	| block |		self borderWidth: 0.	self addTemporaryControls.	aNode asMorphicSyntaxIn: self.	block _ self submorphs last.	block submorphs size = 1 ifTrue: [^ self].	"keep '^ self' if that is the only thing in method"	block submorphs last decompile string = '^  self ' ifTrue: [		block submorphs last delete].	^ self! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/16/2001 17:48'!translateFromWordySelfVariant: key	#selfWrittenAsMe == key ifTrue: [^'me'].	#selfWrittenAsMy == key ifTrue: [^'my'].	#selfWrittenAsIll == key ifTrue: [^'I''ll'].	#selfWrittenAsIm == key ifTrue: [^'I''m'].	#selfWrittenAsThis == key ifTrue: [^'this'].	^nil! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/16/2001 18:06'!translateToWordySelfVariant: aString	| lc |	lc _ aString asLowercase.	lc = 'me' ifTrue: [^#selfWrittenAsMe].	lc = 'my' ifTrue: [^#selfWrittenAsMy].	lc = 'i''ll' ifTrue: [^#selfWrittenAsIll].	lc = 'i''m' ifTrue: [^#selfWrittenAsIm].	lc = 'this' ifTrue: [^#selfWrittenAsThis].	^nil! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/15/2001 19:49'!vanillaMessageNode: aNode receiver: receiver selector: selector arguments: arguments	| substitute row sel |	sel _ #message.	((self nodeClassIs: CascadeNode) and: [self parseNode receiver ~~ aNode]) ifTrue: [		sel _ #keyword2.		receiver ifNotNil: [self inform: 'receiver should be nil']].	row _ self addRow: sel on: aNode.	substitute _ aNode as: TileMessageNode.	(aNode macroPrinter == #printCaseOn:indent:) ifTrue: [		aNode asMorphicCaseOn: row indent: nil.		^ self].	aNode macroPrinter		ifNotNil: 			[substitute perform: aNode macroPrinter with: row with: nil]		ifNil: 			[substitute 				printKeywords: selector key				arguments: arguments				on: row				indent: nil].	^ row addTransparentSpacerOfSize: 3@0.	"horizontal spacing only"! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/16/2001 19:32'!wordyTestMethod	self selfWrittenAsMe = 1 ifTrue: [		self selfWrittenAsMy size.		self selfWrittenAsIll stop.		self selfWrittenAsIm large.		self selfWrittenAsThis helps.	].	! !!SyntaxMorph methodsFor: 'formatting options' stamp: 'RAA 2/16/2001 16:36'!alansTest1		| root |	root _ self rootTile ifNil: [self].	^root valueOfProperty: #alansNewStyle ifAbsent: [true]! !!SyntaxMorph methodsFor: 'formatting options' stamp: 'RAA 2/16/2001 11:35'!controlContrast: evt	| handle origin scale startingContrastX |	ContrastFactor ifNil: [ContrastFactor _ 0.5].	scale _ 200.0.	startingContrastX _ ContrastFactor * scale.	origin _ evt hand position.	handle _ HandleMorph new		forEachPointDo: [:newPoint | 			ContrastFactor _ (newPoint x - origin x + startingContrastX) / scale min: 1.0 max: 0.0.			self finalAppearanceTweaks.		]		lastPointDo: [:newPoint |			handle deleteBalloon.			self halo doIfNotNil: [:halo | halo addHandles].		].	evt hand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle setBalloonText:'Move cursor left or right to change contrast.Click when done.'.	handle startStepping! !!SyntaxMorph methodsFor: 'formatting options' stamp: 'RAA 2/16/2001 17:04'!controlSpacing: evt	| handle origin scale startingContrastX |	SizeScaleFactor ifNil: [SizeScaleFactor _ 1.0].	scale _ 200.0.	startingContrastX _ SizeScaleFactor * scale.	origin _ evt hand position.	handle _ HandleMorph new		forEachPointDo: [:newPoint | 			SizeScaleFactor _ (newPoint x - origin x + startingContrastX) / scale min: 1.0 max: 0.0.			self finalAppearanceTweaks.		]		lastPointDo: [:newPoint |			handle deleteBalloon.			self halo doIfNotNil: [:halo | halo addHandles].		].	evt hand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle setBalloonText:'Move cursor left or right to change contrast.Click when done.'.	handle startStepping! !!SyntaxMorph methodsFor: 'formatting options' stamp: 'RAA 2/15/2001 19:49'!noiseWordsAdded		^self alansTest1! !!SyntaxMorph methodsFor: 'formatting options' stamp: 'RAA 2/15/2001 19:49'!specialBlockFormatting		^self alansTest1! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'tk 2/12/2001 16:25'!allSpecs	AllSpecs ifNil: [self initialize].	^ AllSpecs! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'tk 2/12/2001 16:10'!initialize	"gather all the specs of all the kinds of EToy tiles."	AllSpecs _ self new allSpecs.! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 2/16/2001 15:37'!methodNodeOuter: aNode	^(self column: #method on: aNode) methodNodeOuter: aNode! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 2/5/2001 22:10'!condenseSources		"Smalltalk condenseSources"	"Move all the changes onto a compacted sources file."	| f classCount dir newVersionString |	dir _ FileDirectory default.	newVersionString _ FillInTheBlank request: 'Please designate the versionfor the new source code file...' initialAnswer: SourceFileVersionString.	newVersionString ifNil: [^ self].	newVersionString = SourceFileVersionString ifTrue:		[^ self error: 'The new source file must not be the same as the old.'].	SourceFileVersionString _ newVersionString.	"Write all sources with fileIndex 1"	f _ FileStream newFileNamed: self sourcesName.	f header; timeStamp.'Condensing Sources File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class fileOutOn: f moveSource: true toFile: 1]].	f trailer; close.	"Make a new empty changes file"	self closeSourceFiles.	dir rename: self changesName		toBe: self changesName , '.old'.	(FileStream newFileNamed: self changesName)		header; timeStamp; close.	LastQuitLogPosition _ 0.	self setMacFileInfoOn: self changesName.	self setMacFileInfoOn: self sourcesName.	self openSourceFiles.	SelectionMenu notify: 'Source files have been rewritten!!Check that all is well,and then save/quit.'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 11/8/2000 09:06'!findNamesLikeGeorge: pName  "Smalltalk findNamesLikeGeorge: 'george'"	"Will find personal names that perhaps don't belong in an official release."	"sometimes finds much more, unfortunately."	| pattern |	pattern _ '*' , pName , '*'.  "match string"	^ String streamContents:	[:s |	s nextPutAll: 'System categories...'; cr;		print: (SystemOrganization categories select: [:n | pattern match: n]). 	s cr; cr; nextPutAll: 'Class names...'; cr;		print: (Smalltalk classNames select: [:n | pattern match: n]). 	s cr; cr; nextPutAll: 'Class categories...'; cr;		print: ((Smalltalk allClasses collect:				[:c | (c organization categories select: [:n | pattern match: n]						thenCollect: [:cat | c name , ' <' , cat , '>']) ,					(c class organization categories select: [:n | pattern match: n]						thenCollect: [:cat | c class name , ' <' , cat , '>'])])				select: [:x | x size > 0]). 	s cr; cr; nextPutAll: 'Message names...'; cr;		print: ((Smalltalk allClasses collect:				[:c | (c selectors asArray select: [:n | pattern match: n]						thenCollect: [:sel | c name , '>>' , sel]) ,					(c class selectors asArray select: [:n | pattern match: n]						thenCollect: [:sel | c name , '>>' , sel])])				select: [:x | x size > 0]).	]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 2/5/2001 22:16'!makeExternalRelease		"Smalltalk makeExternalRelease"	(self confirm: self version , 'Is this the correct version designation?If not, choose no, and fix it.') ifFalse: [^ self].	"Object classPool at: #DependentsFields"	Smalltalk reclaimDependents.	Preferences enable: #mvcProjectsAllowed.	Preferences enable: #fastDragWindowForMorphic.	Browser initialize.	Undeclared isEmpty ifFalse: [self halt].	ScriptingSystem deletePrivateGraphics.	#(Helvetica Palatino Courier) do:		[:n | TextConstants removeKey: n ifAbsent: []].	(Utilities classPool at: #UpdateUrlLists) copy do:		[:pair | (pair first includesSubstring: 'Disney' caseSensitive: false) ifTrue: [			(Utilities classPool at: #UpdateUrlLists) remove: pair]].	(ServerDirectory serverNames copyWithoutAll: #('UCSBCreateArchive' 'UIUCArchive' 'UpdatesExtUIUC' 'UpdatesExtWebPage'))		do: [:sn | ServerDirectory removeServerNamed: sn].	Smalltalk garbageCollect.	Smalltalk obsoleteClasses isEmpty ifFalse: [self halt].	Symbol rehash.	self halt: 'Ready to condense changes or sources'.! !!SystemDictionary methodsFor: 'image, changes name' stamp: 'di 2/5/2001 21:43'!sourcesName	"Answer the full path to the version-stable source code"	^ self vmPath , SourceFileVersionString , FileDirectory dot , 'sources'! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 2/7/2001 12:41'!readDocumentFile	"Process system updates. Read a document file, if one was provided. Start application."	| fileName object |	StartupStamp _ '----STARTUP----', Time dateAndTimeNow printString, ' as ', Smalltalk imageName.	self processUpdates.	(Preferences valueOfFlag: #readDocumentAtStartup) ifFalse: [^ self].	fileName _ Smalltalk getSystemAttribute: 2.	((fileName ~~ nil) and: [fileName size > 0])		ifTrue: [			(fileName asLowercase beginsWith: 'http://')				ifTrue: [					"fetch remote file"					HTTPSocket httpFileIn: fileName]				ifFalse: [					"read local file"					object _ SecurityManager default fileInObjectAndCode:						(FileStream readOnlyFileNamed: fileName).					"if launching a .sqo document, send open to the final object"					(fileName endsWith: '.sqo') ifTrue: [object open]]]		ifFalse: [			(Preferences valueOfFlag: #startImagineeringStudio)				ifTrue: [ScriptingSystem openImagineeringStudio]]! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'ar 2/12/2001 15:24'!assureStartupStampLogged	"If there is a startup stamp not yet actually logged to disk, do it now."	| changesFile |	StartupStamp ifNil: [^ self].	(SourceFiles isNil or: [(changesFile _ SourceFiles at: 2) == nil]) ifTrue: [^ self].	changesFile isReadOnly ifTrue:[^self].	changesFile setToEnd; cr; cr.	changesFile nextChunkPut: StartupStamp asString; cr.	StartupStamp _ nil.	self forceChangesToDisk.! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'ar 2/6/2001 18:42'!forceChangesToDisk	"Ensure that the changes file has been fully written to disk by closing and re-opening it. This makes the system more robust in the face of a power failure or hard-reboot."	| changesFile |	changesFile _ SourceFiles at: 2.	(changesFile isKindOf: FileStream) ifTrue: [		changesFile flush.		SecurityManager default hasFileAccess ifTrue:[			changesFile close.			changesFile open: changesFile name forWrite: true].		changesFile setToEnd.	].! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'ar 2/12/2001 15:24'!logChange: aStringOrText 	"Write the argument, aString, onto the changes file."	| aString changesFile |	(SourceFiles isNil or: [(SourceFiles at: 2) == nil]) ifTrue: [^ self].	self assureStartupStampLogged.	aStringOrText isText		ifTrue: [aString _ aStringOrText string]		ifFalse: [aString _ aStringOrText].	(aString isMemberOf: String)		ifFalse: [self error: 'can''t log this change'].	(aString findFirst: [:char | char isSeparator not]) = 0		ifTrue: [^ self].  "null doits confuse replay"	(changesFile _ SourceFiles at: 2).	changesFile isReadOnly ifTrue:[^self].	changesFile setToEnd; cr; cr.	changesFile nextChunkPut: aString.		"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"	self forceChangesToDisk.! !!SystemQueryPhrase methodsFor: 'initialization' stamp: 'sw 2/12/2001 21:30'!initialize	"Initialize the receiver.  In this case we primarily seek to undo the damage done by inherited implementors of #initialize"	super initialize.	self removeAllMorphs.	resultType _ #boolean.	self vResizing: #shrinkWrap! !!SystemWindow methodsFor: 'initialization' stamp: 'di 2/18/2001 00:15'!addCloseBox	| frame |	closeBox _ SimpleButtonMorph new borderWidth: 0;			label: 'X' font: Preferences standardButtonFont; color: Color transparent;			actionSelector: #closeBoxHit; target: self; extent: 14@14;			setBalloonText: 'close this window'.	frame _ LayoutFrame new.	frame leftFraction: 0; leftOffset: 4; topFraction: 0; topOffset: 1.	closeBox layoutFrame: frame.	labelArea addMorph: closeBox.! !!SystemWindow methodsFor: 'initialization' stamp: 'di 2/18/2001 00:15'!initialize	| aFont |	super initialize.	allowReframeHandles := true.	labelString ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	borderColor _ Color black.	borderWidth _ 1.	color _ Color black.	self layoutPolicy: ProportionalLayout new.	label _ StringMorph new contents: labelString;			font: Preferences windowTitleFont emphasis: 1.	"Add collapse box so #labelHeight will work"	aFont _ Preferences standardButtonFont.	collapseBox _ SimpleButtonMorph new borderWidth: 0;			label: 'O' font: aFont; color: Color transparent;			actionSelector: #collapseOrExpand; target: self; extent: 14@14;			setBalloonText: 'collapse this window'.	stripes _ Array with: (RectangleMorph newBounds: bounds)  "see extent:"				with: (RectangleMorph newBounds: bounds).	self addLabelArea.	labelArea addMorph: (stripes first borderWidth: 1).	labelArea addMorph: (stripes second borderWidth: 2).	self setLabelWidgetAllowance.	self addCloseBox.	self addMenuControl.	labelArea addMorph: label.	labelArea addMorph: collapseBox.	self setFramesForLabelArea.	Preferences noviceMode ifTrue:		[closeBox ifNotNil: [closeBox setBalloonText: 'close window'].		menuBox ifNotNil: [menuBox setBalloonText: 'window menu'].		collapseBox ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].	self on: #mouseEnter send: #spawnReframeHandle: to: self.	self on: #mouseLeave send: #spawnReframeHandle: to: self.	label on: #mouseDown send: #relabelEvent: to: self.	self extent: 300@200.	mustNotClose _ false.	updatablePanes _ Array new.! !!SystemWindow methodsFor: 'geometry' stamp: 'di 2/12/2001 23:02'!borderWidthForRounding	"Pane borders effectively increase the border size.	This is a hack, but it usually looks good."	self isCollapsed ifTrue: [^ 2].	(paneMorphs ~~ nil and: [paneMorphs size >= 1 and: [paneMorphs first borderWidth > 0]])		ifTrue: [^ self borderWidth + paneMorphs first borderWidth]		ifFalse: [^ self borderWidth]! !!SystemWindow methodsFor: 'top window' stamp: 'RAA 2/7/2001 07:11'!lockInactivePortions	"Make me unable to respond to mouse and keyboard"	"Control boxes remain active, except in novice mode"	self submorphsDo: [:m |		m == labelArea ifFalse: [			m lock		]	].	labelArea submorphsDo: [:m |		(m == closeBox or: [m == collapseBox]) ifTrue: [			Preferences noviceMode ifTrue: [m lock]		] ifFalse: [			m lock		]	].! !!SystemWindow methodsFor: 'events' stamp: 'nk 2/16/2001 15:45'!doFastFrameDrag	| offset newBounds outerWorldBounds |	outerWorldBounds _ self boundsIn: nil.	offset _ outerWorldBounds origin - Sensor cursorPoint.	newBounds _ outerWorldBounds newRectFrom: [:f | 		Sensor cursorPoint + offset extent: outerWorldBounds extent	].	^ self position: (self globalPointToLocal: newBounds topLeft); comeToFront! !!SystemWindow methodsFor: 'events' stamp: 'RAA 2/7/2001 07:11'!handleListenEvent: evt	"Make sure we lock our contents after DnD has finished"	evt isMouse ifFalse:[^self].	evt hand hasSubmorphs ifTrue:[^self]. "still dragging"	self == TopWindow ifFalse:[self lockInactivePortions].	evt hand removeMouseListener: self.! !!SystemWindow methodsFor: 'events' stamp: 'RAA 2/7/2001 07:12'!mouseLeaveDragging: evt	"lock children after drop operations"	(self ~~ TopWindow and:[evt hand hasSubmorphs]) ifTrue:[		self lockInactivePortions.		evt hand removeMouseListener: self.	].! !!TestIndenting methodsFor: 'running' stamp: 'hmm 2/2/2001 14:29'!setUp	| text |	text _ 'p	' asText, (Text string: 'word word' attribute: (TextIndent tabs: 1)).	para _ text asParagraph! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:42'!testBreak1	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para compositionRectangle: (0@0 extent: para width - 1@100); updateCompositionHeight.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 8.	self assert: cb top > 0.	self assert: cb left = 24! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:45'!testBreak2	"When an indented line is broken at a space, the character block must still lie in the line crossing the right margin."	| cb |	para compositionRectangle: (0@0 extent: para width - 24 // 2 + 24@100); updateCompositionHeight.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 7.	self assert: cb top = 0.	self assert: cb left >= 24! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:41'!testCR	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para replaceFrom: 7 to: 7 with: (String with: Character cr) displaying: false.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 8.	self assert: cb top > 0.	self assert: cb left = 24! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:41'!testCR2	"Checks whether the drawing of indented text is really indented..."	| cb |	para replaceFrom: 7 to: 7 with: (String with: Character cr) displaying: false.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 8.	self assert: (para asForm copy: (0@cb top extent: 24@cb height)) isAllWhite! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 15:17'!testCR3	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para replaceFrom: 11 to: 11 with: (Text string: (String with: Character cr) attribute: (TextIndent tabs: 1)) displaying: false.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 12.	self assert: cb top > 0.	self assert: cb left = 24! !This class tests the same things as its superclass, but for NewParagraph which is used in the Morphic environment.!!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:42'!testCharacterBlockAfterReplacingAll	^super testCharacterBlockAfterReplacingAll! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:42'!testCharacterBlockAfterReplacingOther	^super testCharacterBlockAfterReplacingOther! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:42'!testCharacterBlockAfterReplacingSpace	^super testCharacterBlockAfterReplacingSpace! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:43'!testCharacterBlockNormal	^super testCharacterBlockNormal! !!TestNewParagraphFix methodsFor: 'running' stamp: 'hmm 10/1/2000 17:41'!setUp	| morph |	morph _ TextMorph new contents: 'i i'.	morph fit.	para _ morph paragraph! !This class tests whether locating characters past the end of a text is possible in all cases.!!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:52'!testCharacterBlockAfterReplacingAll	para replaceFrom: 1 to: 3 with: 'mmm' displaying: false.	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:05'!testCharacterBlockAfterReplacingOther	para replaceFrom: 3 to: 3 with: 'm' displaying: false.	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:05'!testCharacterBlockAfterReplacingSpace	para replaceFrom: 3 to: 3 with: ' ' displaying: false.	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:05'!testCharacterBlockNormal	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'running' stamp: 'hmm 10/1/2000 15:05'!setUp	para _ 'i i' asParagraph! !!TextLine methodsFor: 'accessing' stamp: 'di 10/21/97 20:42'!leftMargin	"This has to get fixed -- store during composition"	^ self left! !!TextLine methodsFor: 'accessing' stamp: 'hmm 2/9/2001 11:58'!leftMargin: lm	left _ lm! !!TextLine methodsFor: 'accessing' stamp: 'hmm 2/9/2001 11:58'!rectangle: lineRectangle	left _ lineRectangle left.	right _ lineRectangle right.	top _ lineRectangle top.	bottom _ lineRectangle bottom! !!TextMorph methodsFor: 'geometry' stamp: 'RAA 2/16/2001 08:14'!layoutChanged	"self releaseParagraph."	super layoutChanged! !!TextMorph methodsFor: 'private' stamp: 'RAA 2/16/2001 08:15'!installEditor	self flag: #bob.		"I don't see any senders (16 Feb 2001)"	"Install an editor for my paragraph.  This constitutes 'hasFocus'."	editor ifNotNil: [^ editor].	^ self installEditorToReplace: nil! !!TextMorph methodsFor: 'containment' stamp: 'RAA 2/16/2001 08:13'!ownerChanged	super ownerChanged.	"container ifNotNil:		[self releaseParagraph]"! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'ar 2/8/2001 21:46'!startMessageTally	(self confirm: 'MessageTally will start now,and stop when the cursor goesto the top of the screen') ifTrue:		[MessageTally spyOn:			[[Sensor peekMousePt y > 0] whileTrue: [Display doOneCycleMorphic]]]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'ar 2/8/2001 21:46'!startThenBrowseMessageTally	(self confirm: 'MessageTally will start now,and stop when the cursor goesto the top of the screen')		ifTrue: [TimeProfileBrowser				onBlock: [[Sensor peekMousePt y > 10]						whileTrue: [Display doOneCycleMorphic]]]! !!TheWorldMenu methodsFor: 'construction' stamp: 'sw 2/8/2001 14:43'!helpMenu        "Build the help menu for the world."        | screenCtrl |        screenCtrl _ ScreenController new.        ^self fillIn: (self menu: 'help...') from:        {                {'about this system...'. {Smalltalk. #aboutThisSystem}. 'current version information.'}.                {'update code from server'. {Utilities. #updateFromServer}. 'load latest code updates via the internet'}.                {'preferences...'. {Preferences. #openPreferencesInspector}. 'view and change various options.'}.                nil.                {'command-key help'. { Utilities . #openCommandKeyHelp}. 'summary of keyboard shortcuts.'}.                {'world menu help'. { self . #worldMenuHelp}. 'helps find menu items buried in submenus.'}.                        "{'info about flaps' . { Utilities . #explainFlaps}. 'describes how to enable and use flaps.'}."                {'font size summary' . { Utilities . #fontSizeSummary}.  'summary of names and sizes of available fonts.'}.                {'useful expressions' . { Utilities . #openStandardWorkspace}. 'a window full of useful expressions.'}.			 {'annotation setup...' . { Preferences . #editAnnotations}. 'Click here to get a little window that will allow you to specify which types of annotations, in which order, you wish to see in the annotation panes of browsers and other tools'}.			nil.                {'graphical imports' . { Smalltalk . #viewImageImports}.  'view the global repository called ImageImports; you can easily import external graphics into ImageImports via the FileList'}.                {'standard graphics library' . { ScriptingSystem . #inspectFormDictionary}.  'lets you view and change the system''s standard library of graphics.'}.                nil.                {'telemorphic...' . {self. #remoteDo}.  'commands for doing multi-machine "telemorphic" experiments'}.                {#soundEnablingString . { Preferences . #toggleSoundEnabling}. 'turning sound off will completely disable Squeak''s use of sound.'}.                {'definition for...' . { Utilities . #lookUpDefinition}.  'if connected to the internet, use this to look up the definition of an English word.'}.                nil.                {'set author initials...' . { screenCtrl . #setAuthorInitials }. 'supply initials to be used to identify the author of code and other content.'}.                {'vm statistics' . { screenCtrl . #vmStatistics}.  'obtain some intriguing data about the vm.'}.                {'space left' . { screenCtrl . #garbageCollect}. 'perform a full garbage-collection and report how many bytes of space remain in the image.'}.        }! !!TheWorldMenu methodsFor: 'windows & flaps menu' stamp: 'sw 2/5/2001 13:03'!windowsMenu        "Build the windows menu for the world."        ^ self fillIn: (self menu: 'windows & flaps...') from: {                  { 'find window' . { #myWorld . #findWindow: }. 'Presents a list of all windows; if you choose one from the list, it becomes the active window.'}.                { 'find changed browsers...' . { #myWorld . #findDirtyBrowsers: }. 'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.                { 'find changed windows...' . { #myWorld . #findDirtyWindows: }. 'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.			nil.                { 'find a transcript (t)' . { #myWorld . #findATranscript: }. 'Brings an open Transcript to the front, creating one if necessary, and makes it the active window'}.               { 'find a change sorter (C)' . { #myWorld . #findAChangeSorter: }. 'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'}.			 nil.                { #staggerPolicyString . { self . #toggleWindowPolicy }. 'stagger: new windows positioned so you can see a portion of each one.                tile: new windows positioned so that they do not overlap others, if possible.'}.                nil.                { 'collapse all windows' . { #myWorld . #collapseAll }. 'Reduce all open windows to collapsed forms that only show titles.'}.                { 'expand all windows' . { #myWorld . #expandAll }. 'Expand all collapsed windows back to their expanded forms.'}.                { 'close top window (w)' . { SystemWindow . #closeTopWindow }. 'Close the topmost window if possible.'}.                { 'send top window to back (\)' . { SystemWindow . #sendTopWindowToBack  }. 'Make the topmost window become the backmost one, and activate the window just beneath it.'}.			 { 'move windows onscreen' . { #myWorld . #bringWindowsFullOnscreen }. 'Make all windows fully visible on the screen'}.                nil.                { 'delete unchanged windows' . { #myWorld . #closeUnchangedWindows }. 'Deletes all windows that do not have unsaved text edits.'}.                { 'delete non-windows' . { #myWorld . #deleteNonWindows }. 'Deletes all non-window morphs lying on the world.'}.                { 'delete both of the above' . { self . #cleanUpWorld }. 'deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'}.                nil.            "    { #suppressFlapsString . { self . #toggleFlapSuppressionInProject }. 'Governs whether flaps should be shown in this project'}."                { #useGlobalFlapsString . { self. #toggleWhetherToUseGlobalFlaps }. 'Governs whether a universal set of "global" flaps should be sharable by all morphic projects.'}.			{ #whichGlobalFlapsString . { Utilities. #offerGlobalFlapsMenu }. 'Put up a menu that allows you to choose which global flaps to show in this project'. #globalFlapsEnabled}.                { #newGlobalFlapString  . { Utilities . #addGlobalFlap }. 'Create a new flap that will be shared by all morphic projects'.  #globalFlapsEnabled}.                nil.                { 'new project flap...'  . { Utilities . #addLocalFlap }. 'Create a new flap to be used only in this project.'}.                { 'add stack-tools flap'  . { Utilities . #addStackToolsFlap }. 'Add a flap in this project that offers tools for creating stacks and cards.'}.                { 'add menu flap'  . { Utilities . #addMenuFlap }. 'Add a flap in this project that shows most of the standard world menus all at once.'}.				nil.                { 'about flaps...' . { Utilities . #explainFlaps }. 'Gives a window full of details about how to use flaps.'}.        }! !!TickIndicatorMorph methodsFor: 'initialization' stamp: 'ar 2/12/2001 18:10'!initialize	super initialize.	self borderWidth: 1.	self borderColor: (Color r: 0.333 g: 0.667 b: 0.5).	self color: (Color r: 0.767 g: 0.767 b: 1.0).	self extent: 20@20.	index _ 0.! !!TickIndicatorMorph methodsFor: 'accessing' stamp: 'ar 2/11/2001 19:48'!color: aColor	super color: aColor.	self borderColor: aColor darker.! !!TickIndicatorMorph methodsFor: 'accessing' stamp: 'ar 2/11/2001 20:31'!isTicking	^isTicking ifNil:[false].! !!TickIndicatorMorph methodsFor: 'accessing' stamp: 'ar 2/11/2001 20:32'!isTicking: aBool	isTicking _ aBool.! !!TickIndicatorMorph methodsFor: 'accessing' stamp: 'ar 2/12/2001 17:40'!stepTime: aNumber	stepTime _ aNumber max: 1.! !!TickIndicatorMorph methodsFor: 'stepping' stamp: 'ar 2/12/2001 17:52'!stepAt: nowTick	| delta |	self isTicking ifTrue:[		(lastTick == nil or:[nowTick < lastTick]) ifTrue:[lastTick _ nowTick].		delta _ (nowTick - lastTick) // stepTime.		delta > 0 ifTrue:[			index _ index + delta.			lastTick _ nowTick.			self changed.		].	].! !!TickIndicatorMorph methodsFor: 'stepping' stamp: 'ar 2/12/2001 17:53'!stepTime	^(stepTime ifNil:[125]) max: 50! !!TickIndicatorMorph methodsFor: 'stepping' stamp: 'ar 2/11/2001 19:14'!wantsSteps	^true! !!TickIndicatorMorph methodsFor: 'drawing' stamp: 'ar 2/12/2001 17:50'!drawOn: aCanvas	| r center cc deg |	super drawOn: aCanvas.	corners ifNil:[		r _ (bounds topCenter - bounds center) r - 2.		corners _ Array new: 32.		1 to: corners size do:[:i|			deg _ 360.0 / corners size * (i-1).			corners at: i put: (Point r: r degrees: deg-90) asIntegerPoint]].	index _ index \\ corners size.	cc _ color darker.	center _ bounds center.	1 to: corners size by: 4 do:[:i|		aCanvas fillRectangle: (center + (corners at: i)-2  extent: 4@4) color: cc.	].	cc _ cc darker.	aCanvas line: center to: center + (corners at: index + 1) width: 2 color: cc.! !!TickIndicatorMorph methodsFor: 'geometry' stamp: 'ar 2/11/2001 20:12'!extent: aPoint	super extent: ((aPoint x max: aPoint y)  asInteger bitClear: 3) asPoint.	corners _ nil.! !!TickIndicatorMorph methodsFor: 'geometry' stamp: 'ar 2/11/2001 19:22'!privateMoveBy: delta	corners _ nil.	super privateMoveBy: delta! !!TileLikeMorph methodsFor: 'dropping/grabbing' stamp: 'ar 2/9/2001 23:57'!justGrabbedFrom: formerOwner	| editor |	formerOwner ifNil:[^self].	editor _ formerOwner topEditor.	editor ifNotNil:[editor scriptEdited].! !!TileMorph methodsFor: 'mouse handling' stamp: 'ar 2/8/2001 20:07'!handlesMouseDown: evt	"Answer whether the receiver would handle the mouseDown represented by evt"	| aPoint |	aPoint _ evt cursorPoint.	(operatorOrExpression notNil and: [upArrow notNil]) ifTrue: [^ true].		"Click on the operator presents list of alternatives"	upArrow ifNotNil: [^true].	suffixArrow ifNotNil: [^true].	retractArrow ifNotNil: [^true].	^ super handlesMouseDown: evt! !!TileMorph methodsFor: 'arrows' stamp: 'ar 2/12/2001 13:55'!variableDelay: aBlock	| now delay dt |	(self hasProperty: #inVariableDelay) ifTrue:[^self].	nArrowTicks ifNil: [nArrowTicks _ 1].	now _ Time millisecondClockValue.	aBlock value.	delay _ nArrowTicks > 5 ifTrue: [100] ifFalse: [300].	nArrowTicks _ nArrowTicks + 1.	dt _ Time millisecondClockValue - now max: 0.  "Time it took to do."	dt < delay ifTrue: [		self setProperty: #inVariableDelay toValue: true.		self addAlarm: #removeProperty: withArguments: #(inVariableDelay) after: (delay - dt)].! !!TileMorph methodsFor: 'dropping/grabbing' stamp: 'ar 2/9/2001 23:57'!justGrabbedFrom: formerOwner	| editor |	formerOwner ifNil:[^self].	editor _ formerOwner topEditor.	editor ifNotNil:[editor scriptEdited].! !!TilePadMorph methodsFor: 'mouse' stamp: 'ar 2/7/2001 17:55'!prepareToUndoDropOf: aMorph	| m |	m _ self owner.	[m == nil] whileFalse: [		(m isKindOf: ScriptEditorMorph) ifTrue: [^ m prepareToUndoDropOf: aMorph].		m _ m owner].! !!TilePadMorph methodsFor: 'events' stamp: 'ar 2/8/2001 19:54'!handlesMouseOverDragging: evt	^true! !!TilePadMorph methodsFor: 'events' stamp: 'ar 2/8/2001 19:56'!mouseEnterDragging: evt	evt hand hasSubmorphs ifFalse:[^self].	(self wantsDroppedMorph: evt hand firstSubmorph event: evt) ifTrue:[		self firstSubmorph color: Color green.	].! !!TilePadMorph methodsFor: 'events' stamp: 'ar 2/8/2001 19:59'!mouseLeaveDragging: evt	evt hand hasSubmorphs ifFalse:[^self].	(self wantsDroppedMorph: evt hand firstSubmorph event: evt) ifTrue:[		self firstSubmorph useUniformTileColor.	].! !!TrashCanMorph methodsFor: 'initialization' stamp: 'sw 2/7/2001 20:18'!initialize	"Initialize the receiver's graphics, name, and balloon-help"	super initialize.	self image: TrashPicOn;		offImage: TrashPic;		pressedImage: TrashPicOn.	self setNameTo: 'Trash'.	self setBalloonText:'To remove an object, drop it on any trash can. To view, and maybe retrieve, items that have been thrown away, double-click on any trash-can.  Things are retained in the trash-can if the "preserveTrash" preference is set, otherwise they are purged immediately'.! !!UniclassScript methodsFor: 'versions' stamp: 'sw 2/6/2001 20:12'!saveScriptVersion: timeStamp	"Save the tile script version by appending a pair of the form		<time stamp>     <morph list>to my list of former scripting tiles.  The morph-list will get copied back into the Scriptor following restoration."	(currentScriptEditor notNil and: [currentScriptEditor showingMethodPane not]) ifTrue:			[formerScriptingTiles ifNil: [formerScriptingTiles _ OrderedCollection new].			formerScriptingTiles add:				(Array with: timeStamp					with: (currentScriptEditor submorphs allButFirst collect: [:m | m fullCopyWithoutFormerOwner])).			formerScriptingTiles size > 100 ifTrue: [^ self halt: 'apparent runaway versions, proceed at your own risk.']]! !!Utilities class methodsFor: 'fetching updates' stamp: 'sr 2/12/2001 03:38'!applyUpdatesFromDisk	"Utilities applyUpdatesFromDisk"	"compute highest update number"	| updateDirectory updateNumbers |	updateDirectory _ self getUpdateDirectoryOrNil.	updateDirectory		ifNil: [^ self].	updateNumbers _ updateDirectory fileNames				collect: [:fn | fn initialIntegerOrNil]				thenSelect: [:fn | fn notNil].	self		applyUpdatesFromDiskToUpdateNumber: (updateNumbers				inject: 0				into: [:max :num | max max: num])		stopIfGap: false! !!Utilities class methodsFor: 'fetching updates' stamp: 'sr 2/12/2001 03:40'!applyUpdatesFromDiskToUpdateNumber: lastUpdateNumber stopIfGap: stopIfGapFlag 	"To use this mechanism, be sure all updates you want to have considered 	are in a folder named 'updates' which resides in the same directory as  	your image. Having done that, simply evaluate:  	 	Utilities applyUpdatesFromDiskToUpdateNumber: 1234 stopIfGap: false  	 	and all numbered updates <= lastUpdateNumber not yet in the image will 	be loaded in numerical order."	| previousHighest currentUpdateNumber done fileNames aMessage updateDirectory loaded |	updateDirectory _ self getUpdateDirectoryOrNil.	updateDirectory ifNil: [^ self].	previousHighest _ ChangeSorter highestNumberedChangeSet.	currentUpdateNumber _ previousHighest.	done _ false.	loaded _ 0.	[done]		whileFalse: [currentUpdateNumber _ currentUpdateNumber + 1.			currentUpdateNumber > lastUpdateNumber				ifTrue: [done _ true]				ifFalse: [fileNames _ updateDirectory fileNamesMatching: currentUpdateNumber printString , '*'.					fileNames size > 1						ifTrue: [^ self inform: 'ambiguity -- two files both start with ' , currentUpdateNumber printString , '(at this point it is probably best to remedythe situation on disk, then try again.)'].					fileNames size == 0						ifTrue: [Transcript cr; show: 'gap in updates from disk for update number '; print: currentUpdateNumber; show: ' found...'.							done _ stopIfGapFlag]						ifFalse: [ChangeSorter								newChangesFromStream: (updateDirectory readOnlyFileNamed: fileNames first)								named: fileNames first.							loaded _ loaded + 1]]].	aMessage _ loaded = 0				ifTrue: ['No new updates found.']				ifFalse: [loaded printString , ' update(s) loaded.'].	self inform: aMessage , 'Highest numbered update is now ' , (currentUpdateNumber - 1) printString , '.'! !!Utilities class methodsFor: 'fetching updates' stamp: 'sr 2/12/2001 03:36'!getUpdateDirectoryOrNil	^ (FileDirectory default directoryNames includes: 'updates')		ifTrue: [FileDirectory default directoryNamed: 'updates']		ifFalse: [self inform: 'Error: cannot find "updates" folder'.			nil]! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 2/5/2001 09:36'!readServer: serverList updatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.""Utilities readServer: Utilities serverUrls updatesThrough: 828 saveLocally: true updateImage: true"	| urls failed loaded docQueue this nextDoc docQueueSema str |	Cursor wait showWhile: [	urls _ self newUpdatesOn: (serverList collect: [:url | url, 'updates/']) 				throughNumber: maxNumber.	loaded _ 0.	failed _ nil.	"send downloaded documents throuh this queue"	docQueue := SharedQueue new.	"this semaphore keeps too many documents from beeing queueed up at a time"	docQueueSema := Semaphore new.	5 timesRepeat: [ docQueueSema signal ].	"fork a process to download the updates"	self retrieveUrls: urls ontoQueue: docQueue withWaitSema: docQueueSema.	"process downloaded updates in the foreground"	[ this _ docQueue next.	  nextDoc _ docQueue next.  	  nextDoc = #failed ifTrue: [ failed _ this ].	  (failed isNil and: [ nextDoc ~= #finished ])	] whileTrue: [		failed ifNil: [			nextDoc reset; text.			nextDoc size = 0 ifTrue: [ failed _ this ]. ].		failed ifNil: [			nextDoc peek asciiValue = 4	"pure object file"				ifTrue: [failed _ this]].	"Must be fileIn, not pure object file"		failed ifNil: [			"(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."				"HTML source code not supported here yet"			updateImage ifTrue:					[ChangeSorter newChangesFromStream: nextDoc					named: (this findTokens: '/') last].			saveLocally ifTrue:				[self saveUpdate: nextDoc onFile: (this findTokens: '/') last].	"if wanted"			loaded _ loaded + 1].		docQueueSema signal].	].	failed ~~ nil & (urls size - loaded > 0) ifTrue: [		str _ loaded printString ,' new update file(s) processed.'.		str _ str, '\Could not load ' withCRs, 			(urls size - loaded) printString ,' update file(s).',			'\Starting with "' withCRs, failed, '".'.		self inform: str].	^ Array with: failed with: loaded! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 2/5/2001 09:37'!readServerUpdatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.A file on the server called updates.list has the names of the last N update files.  We look backwards for the first one we do not have, and start there""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""Utilities readServerUpdatesThrough: 828 saveLocally: false updateImage: true""Utilities readServerUpdatesThrough: 828 saveLocally: true updateImage: true"	| failed loaded str res servers triple tryAgain |	Utilities chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"	servers _ Utilities serverUrls copy.	[servers isEmpty] whileFalse: [		triple _ self readServer: servers updatesThrough: maxNumber 					saveLocally: saveLocally updateImage: updateImage.		"report to user"		failed _ triple first.		loaded _ triple second.		tryAgain _ false.		failed ifNil: ["is OK"			loaded = 0 ifTrue: ["found no updates"				servers size > 1 ifTrue: ["not the last server"					res _ PopUpMenu withCaption: 'No new updates on the server', servers first, 'Would you like to try the next server?(Normally, all servers are identical, but sometimes aserver won''t let us store new files, and gets out of date.)' 						chooseFrom: 'Stop looking\Try next server'.					res = 2 ifFalse: [^ self]						 ifTrue: [servers _ servers allButFirst.	"try the next server"							tryAgain _ true]]]].		tryAgain ifFalse: [			str _ loaded printString ,' new update file(s) processed.'.			^ self inform: str].	].! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 2/4/2001 14:47'!retrieveUrls: urls ontoQueue: queue withWaitSema: waitSema 	"download the given list of URLs. The queue will be loaded alternately  	with url's and with the retrieved contents. If a download fails, the  	contents will be #failed. If all goes well, a special pair with an empty  	URL and the contents #finished will be put on the queue. waitSema is  	waited on every time before a new document is downloaded; this keeps 	the downloader from getting too far  ahead of the main process"	"kill the existing downloader if there is one"	| doc canPeek front |	UpdateDownloader		ifNotNil: [UpdateDownloader terminate].	"fork a new downloading process"	UpdateDownloader _ [urls				do: [:url | 					waitSema wait.					queue nextPut: url.					doc _ HTTPSocket httpGet: url accept: 'application/octet-stream'.					doc class == String						ifTrue: [queue nextPut: #failed.							UpdateDownloader _ nil.							Processor activeProcess terminate]						ifFalse: [canPeek _ 120 min: doc size.							front _ doc next: canPeek.  doc skip: -1 * canPeek.							(front beginsWith: '<!!DOCTYPE') ifTrue: [								(front includesSubString: 'Not Found') ifTrue: [									queue nextPut: #failed.									UpdateDownloader _ nil.									Processor activeProcess terminate]]].						UpdateDownloader ifNotNil: [queue nextPut: doc]].			queue nextPut: ''.			queue nextPut: #finished.			UpdateDownloader _ nil] newProcess.	UpdateDownloader priority: Processor userInterruptPriority.	"start the process running"	UpdateDownloader resume! !!Utilities class methodsFor: 'common requests' stamp: 'sw 2/10/2001 00:20'!eval: aString	"Evaluate the string in a neutral context, and under certain circumstances print the result in the transcript"	| result |	result _ self evaluate: aString in: nil to: nil.	(result isKindOf: Number) | (result isKindOf: String)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !!Utilities class methodsFor: 'common requests' stamp: 'sw 2/10/2001 00:32'!initializeCommonRequestStrings	"Initialize an array of common request strings.  2/1/96 sw"	CommonRequestStrings _ StringHolder new contents: 'Utilities emergencyCollapse.Utilities closeAllDebuggers.-Sensor keyboard.ParagraphEditor abandonChangeText.Cursor normal show.-Project allInstancesDo: [:p | p displayDepth: 16].ScriptingSystem inspectFormDictionary.Form fromUser bitEdit.Display border: (0@0 extent: 640@480) width: 2.-Undeclared inspect.Undeclared removeUnreferencedKeys; inspect.Transcript clear.Utilities grabScreenAndSaveOnDisk.FrameRateMorph new openInHand.-Utilities reconstructTextWindowsFromFileNamed: ''TW''.Utilities storeTextWindowContentsToFileNamed: ''TW''.ChangeSorter removeEmptyUnnamedChangeSets.ChangeSorter reorderChangeSets.'"Utilities initializeCommonRequestStrings"! !!Utilities class methodsFor: 'common requests' stamp: 'sw 2/10/2001 00:21'!offerCommonRequests	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is a number or string -- show it in the Transcript."	"Utilities offerCommonRequests"	| reply result aMenu index normalItemCount strings |	Smalltalk isMorphic ifTrue: [^ self offerCommonRequestsInMorphic].	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array])		ifTrue:			[self initializeCommonRequestStrings].	strings _ CommonRequestStrings contents.	normalItemCount _ strings asString lineCount.	aMenu _ PopUpMenu labels: (strings asString, 'edit this menu') lines: (Array with: normalItemCount).	index _ aMenu startUp.	index == 0 ifTrue: [^ self].	reply _ aMenu labelString lineNumber: index.	reply size == 0 ifTrue: [^ self].	index > normalItemCount ifTrue:		[^ self editCommonRequestStrings].	result _ self evaluate: reply in: nil to: nil.	(result isKindOf: Number) | (result isKindOf: String)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !!Utilities class methodsFor: 'common requests' stamp: 'sw 2/10/2001 00:31'!offerCommonRequestsInMorphic	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is a number or string -- show it in the Transcript."	"Utilities offerCommonRequests"	| aMenu  strings |	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array])		ifTrue:			[self initializeCommonRequestStrings].	strings _ CommonRequestStrings contents.	aMenu _ MenuMorph new.	aMenu title: 'Common Requests'.	aMenu addStayUpItem.	strings asString linesDo:		[:aString |			aString = '-'				ifTrue:					[aMenu addLine]				ifFalse:					[aMenu add: aString target: self selector: #eval: argument: aString]].	aMenu addLine.	aMenu add: 'edit this list' target: self action: #editCommonRequestStrings.	aMenu popUpInWorld: self currentWorld! !!Utilities class methodsFor: 'flaps'!addMenuFlap	"Add a flap with system menus aggregated on it.  This will be a local flap, though the user can later make it a global one if she prefers."	| aFlap aFlapTab aHolder verticalHolder aMenu |	aFlap _ PasteUpMorph newSticky color: Color transparent; extent: self currentWorld width @ 264; borderWidth: 0; padding: 0.	aFlapTab _ FlapTab new referent: aFlap.	aFlapTab color: Color brown lighter.	aFlapTab assumeString: 'Menus' font: Preferences standardFlapFont orientation: #horizontal color: Color blue muchLighter.	aFlapTab setToPopOutOnMouseOver: false.	aFlapTab setToPopOutOnDragOver: false.	aFlapTab edgeToAdhereTo: #top; inboard: false.	aFlapTab position: ((Display width - aFlapTab width) // 2) @ 0.	aFlap beFlap: true.	aFlap color: (Color blue muchLighter alpha: 0.6).	aFlap extent: self currentWorld width @ 267.	aHolder _ AlignmentMorph newRow beSticky beTransparent hResizing: #shrinkWrap; vResizing: #shrinkWrap; cellPositioning: #topLeft.	#(openMenu helpMenu windowsMenu (changesMenu debugMenu ) (playfieldMenu scriptingMenu )) do:		[:elem |			(elem isKindOf: Array)				ifTrue:					[verticalHolder _ AlignmentMorph newColumn beSticky beTransparent.					verticalHolder hResizing: #shrinkWrap; layoutInset: 0; wrapCentering: #center; cellPositioning: #topCenter.					elem do:						[:aMenuSymbol |							verticalHolder addMorphBack: ((aMenu _ self currentWorld getWorldMenu: aMenuSymbol) beSticky; stayUp: true).							aMenu beSticky.							aMenu borderWidth: 1.							aMenu submorphs second delete].					aHolder addMorphBack: verticalHolder]				ifFalse:					[aHolder addMorphBack: ((aMenu _ self currentWorld getWorldMenu: elem) beSticky; stayUp: true).					aMenu submorphs second delete.					aMenu beSticky.					aMenu borderWidth: 1]].	aFlap addMorphBack: aHolder.	self currentWorld addMorphFront: aFlapTab.  	"a local flap, but we could as easily make it global by:		self addGlobalFlap: aFlapTab.  self currentWorld addGlobalFlaps"! !!Utilities class methodsFor: 'flaps' stamp: 'sw 2/8/2001 14:33'!addSystemStatusLinesTo: aPlayfield	"Add system status info.  In this version, we just add a button which can be called to deliver up status information on demand"	| aButton |	aButton _ SimpleButtonMorph new target: Smalltalk; actionSelector: #aboutThisSystem;		label: 'about this system'.	aButton color: Color cyan muchLighter.	aButton setBalloonText: 'click here to find out version information'.	aPlayfield addCenteredAtBottom: aButton offset: 16.! !!Utilities class methodsFor: 'flaps'!currentMenuFlap	"answer a menu flap if there currently is at least one."	^ self currentWorld flapTabs detect: [:aTab | 		(aTab submorphs size > 0) and:  [(aTab submorphs first isKindOf: TextMorph) and: 			[(aTab submorphs first contents string copyWithout: $ ) = 'Menus']]] ifNone: [nil]! !!Utilities class methodsFor: 'flaps' stamp: 'sw 2/8/2001 14:31'!explainFlaps"Flaps are like drawers on the edge of the screen, which can be opened so that you can use what is inside them, and closed when you do not need them.  They have many possible uses, a few of which are illustrated by the default set of flaps you can get as described below.'Global flaps' are available in every morphic project.  As you move from project to project, you will see the same flaps in each.   To get started using global flaps, set the 'useGlobalFlaps' Preference to true, or choose 'start using global flaps' from the windows/flaps menu.You can fine-tine which global flaps show in which project by using the 'which global flaps...' menu item found in the 'windows & flaps' menu.'Project flaps' are flaps that belong to a single morphic project.If a flap is set up as a parts bin (such as the default Tools and Supplies flaps), you can use it to create new objects -- just open the flap, then find the object you want, and drag it out; when the cursor leaves the flap, the flap itself will snap closed, and you''ll be left holding the new object -- just click to place it exactly where you want it.If a flap is *not* set up as a parts bin (such as the default 'Squeak' flap at the left edge of the screen) you can park objects there (this is an easy way to move objects from project to project) and you can place your own private controls there, etc.  Everything in the default 'Squeak' flap (and all the other default flaps, for that matter) is there only for illustrative purposes -- every user will want to fine-tune the flaps to suit his/her own style and needs.Each flap may be set up to appear on mouseover, dragover, both, or neither.  See the menu items described below for more about these and other options.You can open a closed flap by clicking on its tab, or by dragging the tab toward the center of the screenYou can close an open flap by clicking on its tab or by dragging the tab back off the edge of the screen.Drag the tab of a flap to reposition the tab and to resize the flap itself.  Repositioning starts when you drag the cursor out of the original tab area.If flaps or their tabs seem wrongly positioned or lost, try issuing a restoreDisplay from the screen menu.The red-halo menu on a flap allows you to change the flap's properties.   For greatest ease of use, request 'keep this menu up' here -- that way, you can easily explore all the options in the menu.tab color...				Lets you change the color of the flap's tab.flap color...				Lets you change the color of the flap itself.use textual tab...		If the tab is not textual, makes it become textual.change tab wording...	If the tab is already textual, allows you to edit							its wording.use graphical tab...		If the tab is not graphical, makes it become							graphical.choose tab graphic...	If the tab is already graphical, allows you							to change the picture.use solid tab...			If the tab is not solid, makes it become solid, i.e.							appear as a solid band of color along the							entire length or width of the screen.parts-bin behavior		If set, then dragging an object from the flap							tears off a new copy of the object.dragover				If set, the flap opens on dragover and closes							again on drag-leave.mouseover				If set, the flap opens on mouseover and closes							again on mouse-leave. cling to edge...			Governs which edge (left, right, top, bottom)							the flap adheres to.global					If set, the same flap will be available in all projects; if not, the							flap will will occur only in one project.destroy this flap		Deletes the flap.To define a new flap, use 'new global flap...' or 'new project flap...', found in the 'windows and flaps' menu.To reinstate the default system flaps, evaluate 'Utilities reinstateDefaultFlaps'  (caveat -- this will first remove all existing flaps, including any that you may have manually added or edited.)If flaps that you wish to use appear to be buried behind other objects on your screen, simply clicking on the desktop background will bring all flap tabs to the front.To add, delete, or edit things on a given flap, it is often wise first to suspend the flap''s mouse-over and drag-over sensitivity, so it won''t keep disappearing on you while you''re trying to work with it.Besides the three standard flaps delivered with the default system, there are two other flaps readily available on demand from the 'windows & flaps' menu -- one is called 'Stack Tools', which provides some tools useful for building stack-like content, the other is called 'Menus', which provides a montage of many of the system menus"	  	"Open a window giving flap help."	(StringHolder new contents: (self class firstCommentAt: #explainFlaps))		openLabel: 'Flaps in Morphic'"Utilities explainFlaps"	! !!Utilities class methodsFor: 'flaps' stamp: 'sw 2/7/2001 20:20'!initializeStandardFlaps	"Initialize the standard default out-of-box set of global flaps. This method creates them and places them in my class variable #FlapTabs, but does not itself get them displayed."	FlapTabs _ OrderedCollection new.	FlapTabs add: self standardLeftFlap.	FlapTabs add: self standardBottomFlap.	FlapTabs add: self standardRightFlap.	FlapTabs do:		[:aFlapTab | 			aFlapTab setToPopOutOnMouseOver: false].	^ FlapTabs"Utilities reinstateDefaultFlaps"! !!Utilities class methodsFor: 'flaps'!removeFlapTab: aFlapTab keepInList: aBoolean	"Remove the given flap tab from the screen, and, if aBoolean is true, also from the global list"	(FlapTabs ~~ nil and: [FlapTabs includes: aFlapTab])		ifTrue:			[aBoolean ifFalse: [self removeFromGlobalFlapTabList: aFlapTab]].	aFlapTab ifNotNil:		[aFlapTab referent delete.		aFlapTab delete]! !!Utilities class methodsFor: 'flaps' stamp: 'sw 2/5/2001 17:12'!replaceBrowserInToolsFlap	"Replace the browsers shown in the Tools flap, if any, with updated versions"	self replacePartSatisfying: [:el |  (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented model isMemberOf: Browser]]]inGlobalFlapSatisfying: [:f1 | f1 wording = 'Tools'] with:  ((Browser new openAsMorphEditing: nil) applyModelExtent; setLabel: 'System Browser'; setBalloonText: 'System Browser'; yourself).	self replacePartSatisfying: [:el |  (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented model isMemberOf: PackagePaneBrowser]]]inGlobalFlapSatisfying: [:f1 | f1 wording = 'Tools'] with:  ((PackagePaneBrowser new openAsMorphEditing: nil) applyModelExtent; setLabel: 'Package Browser'; setBalloonText: 'Package browser'; yourself)	"Utilities replaceBrowserInToolsFlap"! !!Utilities class methodsFor: 'flaps' stamp: 'sw 2/5/2001 17:03'!replaceChangeSortersInToolsFlap	"Get prototypes of the latest versions of the the Change Sorters into the Tools flap"	self replacePartSatisfying: [:el |  (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented model isMemberOf: ChangeSorter]]]inGlobalFlapSatisfying: [:f1 | f1 wording = 'Tools'] with:  (ChangeSorter new morphicWindow applyModelExtent; setBalloonText: 'Single Change Sorter'; yourself).	self replacePartSatisfying: [:el |  (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented model isMemberOf: DualChangeSorter]]]inGlobalFlapSatisfying: [:f1 | f1 wording = 'Tools'] with:  (DualChangeSorter new morphicWindow applyModelExtent; setBalloonText: 'Dual Change Sorter'; yourself)! !!Utilities class methodsFor: 'flaps'!replaceMenuFlap 	"if there is a menu flap, replace it with an updated one." 	| aFlapTab wasGlobal |	aFlapTab _ self currentMenuFlap ifNil: [^ self].	wasGlobal _ aFlapTab isGlobal.	self removeFlapTab: aFlapTab keepInList: false.	self addMenuFlap.  "This will be project local"	wasGlobal ifTrue:		[self currentMenuFlap toggleIsGlobalFlap].	Smalltalk isMorphic ifTrue: [Display bestGuessOfCurrentWorld addGlobalFlaps]"Utilities replaceMenuFlap"! !!Utilities class methodsFor: 'flaps' stamp: 'sw 2/5/2001 17:11'!replaceScriptingAreaInToolsFlap	"Replace the scripting area in the tools flap with an updated one.  However, this is now obsolete because the scripting area in the Tools flap is no longer in a window and hence won't be found by this.  In any case, it was only called from do-its in postscripts of fileouts."	self replacePartSatisfying: [:el |  (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented model isKindOf: ScriptingDomain]]]inGlobalFlapSatisfying: [:f1 | f1 wording = 'Tools'] with:  ScriptingSystem newScriptingSpace	"Utilities replaceScriptingAreaInToolsFlap"! !!Utilities class methodsFor: 'flaps' stamp: 'sw 2/8/2001 14:44'!standardLeftFlap	| aFlap aFlapTab aButton aClock buttonColor anOffset |	aFlap _ PasteUpMorph newSticky borderWidth: 0.	aFlapTab _ FlapTab new referent: aFlap.	aFlapTab assumeString: 'Squeak' font: Preferences standardFlapFont orientation: #vertical color: Color brown lighter lighter.	aFlapTab edgeToAdhereTo: #left; inboard: false.	aFlapTab setToPopOutOnDragOver: true.	aFlapTab setToPopOutOnMouseOver: true.	aFlapTab position: (0 @ ((Display height - aFlapTab height) // 2)).	aFlap beFlap: true.	aFlap color: (Color brown muchLighter lighter "alpha: 0.3").	aFlap extent: 200 @ self currentWorld height.	self addProjectNavigationButtonsTo: aFlap.	anOffset _ 16.	buttonColor _ Color green muchLighter.	aButton _ SimpleButtonMorph new target: Smalltalk.	aButton color: buttonColor.	aButton actionSelector: #saveSession.	aButton setBalloonText: 'Make a complete snapshot of the current state of the image onto disk.'.	aButton label: 'snapshot'.	aFlap addCenteredAtBottom: aButton offset: anOffset.	aButton _ aButton fullCopy target: Utilities.	aButton actionSelector: #fileOutChanges.	aButton label: 'file out changes'.	aButton setBalloonText: 'File out the current change set to disk.'.	aFlap addMorph: aButton.	aFlap addCenteredAtBottom: aButton offset: anOffset.	aButton _ aButton fullCopy target: Utilities.	aButton actionSelector: #browseRecentSubmissions.	aButton setBalloonText: 'Open a message-list browser showing the 20 most-recently-submitted methods.'.	aButton label: 'recent submissions'.	aFlap addCenteredAtBottom: aButton offset: anOffset.	aClock _ ClockMorph newSticky.	aClock color: Color red.	aClock showSeconds: false.	aClock font: (TextStyle default fontAt: 3).	aClock step.	aClock setBalloonText: 'The time of day.  If you prefer to see seconds, check out my menu.'.	aFlap addCenteredAtBottom: aClock offset: anOffset.	aButton _ aButton fullCopy target: Preferences.	aButton actionSelector: #openPreferencesInspector.	aButton setBalloonText: 'Open a window allowing me to view and change various Preferences.'.	aButton label: 'preferences...'.	aButton color: Color cyan muchLighter.	aFlap addCenteredAtBottom: aButton offset: anOffset.	aButton _ aButton fullCopy target: Utilities.	aButton actionSelector: #updateFromServer.	aButton label: 'load code updates'.	aButton setBalloonText: 'Check the Squeak server for any new code updates, and load any that are found.'.	aFlap addCenteredAtBottom: aButton offset: anOffset.	self addSystemStatusLinesTo: aFlap.	aButton _ TrashCanMorph newSticky.	aFlap addCenteredAtBottom: aButton offset: anOffset.	aButton startStepping.	^ aFlapTab! !!Utilities class methodsFor: 'flaps' stamp: 'sw 2/5/2001 16:53'!standardRightFlap	"Answer a newly-created flap which adheres to the right edge of the screen and which holds prototypes of standard tools"	|  aFlapTab aPage |	aPage _ self newPartsFlapPage.	aFlapTab _ FlapTab new referent: aPage beSticky.	aFlapTab color: Color red lighter.	aFlapTab assumeString: 'Tools' font: Preferences standardFlapFont orientation: #vertical color: Color orange lighter.	aFlapTab edgeToAdhereTo: #right; inboard: false.	aFlapTab setToPopOutOnDragOver: true.	aFlapTab setToPopOutOnMouseOver: false.	aPage extent: (90 @ self currentWorld height).	self addSampleWindowsTo: aPage.	aPage addMorphBack: ScriptingSystem newScriptingSpace.	aPage addMorphBack: RecordingControlsMorph authoringPrototype.	aPage replaceTallSubmorphsByThumbnails.  "This hard-coded list is regrettable but expedient"	#('System Browser' 'Package-Pane Browser' 'Workspace' 'File List' 'Dual Change Sorter' 'Single Change Sorter' 'Selector Browser' 'Assembly Area' 'Scripting Area' 'Sound Recorder') doWithIndex: 		[:help :index |			(aPage submorphs at: index) setBalloonText: help].	aFlapTab position: (self currentWorld width - aFlapTab width) @ ((Display height - aFlapTab height) // 2).	aPage beFlap: true.	aPage color: (Color brown muchLighter alpha: 0.5).	aPage extent: (90 @ self currentWorld height).		^ aFlapTab! !!View methodsFor: 'displaying' stamp: 'hmm 6/27/2000 07:07'!display	"Display the receiver's border, display the receiver, then display the 	subViews of the receiver. Can be sent to the top View of a structured 	picture in order to display the entire structure, or to any particular View 	in the structure in order to display that View and its subViews. It is 	typically sent in response to an update request to a View."	Display deferUpdatesIn: self displayBox while: [		self displayBorder.		self displayView.		self displaySubViews]! !!Viewer methodsFor: 'dropping' stamp: 'ar 2/13/2001 19:58'!repelsMorph: aMorph event: ev	"viewers in flaps are resistant to drop gestures"	owner isFlap ifTrue:[^true].	^false! !Smalltalk condenseChanges!----QUIT----#(18 February 2001 1:12:39 am) priorSource: 882754!----STARTUP----#(18 February 2001 1:22:34 am) as Macintosh HD:Squeak 3.0:Squeak3.0gamma:Squeak3.0.image!Form allInstancesDo: [:f | f boundingBox area > 10000 ifTrue: [f display. Sensor waitClickButton]]!Project allInstances!ProjectViewMorph allInstances!StrikeFont allInstances!Form allInstancesDo: [:f | f boundingBox area > 10000 ifTrue: [f display. Sensor waitButton.  Sensor yellowButtonPressed ifTrue: [f inspect]. Sensor waitNoButton]]!self first who!ProjectHistory instanceCount!ProjectHistory currentHistory!ProjectHistory currentHistory cleanUp!ProjectHistory currentHistory!Form allInstancesDo: [:f | f boundingBox area > 10000 ifTrue: [f display. Sensor waitButton.  Sensor yellowButtonPressed ifTrue: [f inspect]. Sensor waitNoButton]]!	ProjectViewMorph allInstancesDo:		[:m | (m hasProperty: #deleteWorldsOfSqueak) ifTrue:			[Project deletingProject: m project. m delete]].	Project rebuildAllProjects.	ProjectHistory currentHistory cleanUp.	ScriptingSystem spaceReclaimed!----STARTUP----#(18 February 2001 1:44:46 am) as Macintosh HD:Squeak 3.0:Squeak3.0gamma:Squeak3.0.image!ProjectHistory currentHistory cleanUp!----QUIT----#(18 February 2001 1:45:34 am) priorSource: 882782!----STARTUP----#(18 February 2001 1:45:56 am) as Macintosh HD:Squeak 3.0:Squeak3.0gamma:Squeak3.0.image!Object classPool at: #DependentsFields!Smalltalk obsoleteClasses!Smalltalk obsoleteClasses!self first who!ScheduledControllers!Smalltalk keys select: [:k | ((Smalltalk at: k) isKindOf: Class) not]			thenCollect: [:k | k -> (Smalltalk at: k) class]!References!----QUIT----#(18 February 2001 1:52:53 am) priorSource: 884015!----STARTUP----#(18 February 2001 9:13:32 am) as Macintosh HD:Squeak 3.0:Squeak3.0gamma:Squeak3.0.image!----SNAPSHOT----#(18 February 2001 9:16:21 am) priorSource: 884462!----SNAPSHOT----#(18 February 2001 9:55:40 am) priorSource: 884634!----QUIT----#(18 February 2001 9:56:31 am) priorSource: 884703!----STARTUP----#(18 February 2001 10:58:49 am) as Macintosh HD:Squeak 3.0:Squeak3.0gamma:Squeak3.0.image!----SNAPSHOT----#(18 February 2001 11:12:01 am) priorSource: 884772!----STARTUP----#(18 February 2001 11:52:42 am) as Macintosh HD:Squeak 3.0:Squeak3.0gamma:Squeak3.0.image!----SNAPSHOT----#(18 February 2001 12:14:52 pm) priorSource: 884945!'From Squeak3.0 of 4 February 2001 [latest update: #3545] on 18 February 2001 at 11:46:18 am'!----QUIT----#(18 February 2001 12:20:07 pm) priorSource: 885123!----STARTUP----#(18 February 2001 1:58:18 pm) as Macintosh HD:Squeak 3.0:Squeak3.0gamma:Squeak3.0.image!----QUIT----#(18 February 2001 2:00:53 pm) priorSource: 885289!----STARTUP----#(25 June 2001 6:39:54 pm) as /Users/beoneel/Documents/tmp/Squeak3.0/Squeak3.0.image!'From Squeak3.0 of 4 February 2001 [latest update: #3522] on 18 February 2001 at 10:35:05 pm'!"Change Set:		WnldHalos-arDate:			18 February 2001Author:			Andreas RaabFix halo transfer in Wonderlands."!!WonderlandCameraMorph methodsFor: 'wrappers' stamp: 'ar 2/18/2001 22:16' prior: 31011536!addHalo: evt	"Add a halo to an object"	| actor wrapper root |	self removeAllWrappers. "Get rid of them"	evt == nil ifTrue:[^super addHalo: evt].	actor _ myCamera pickAt: evt cursorPoint.	actor == nil ifTrue:[^super addHalo: evt]. "Nothing hit"	wrapper _ WonderlandWrapperMorph on: actor.	root _ wrapper createHierarchy.	root computeFullBounds: self.	self addMorphFront: root.	"pass on the event as if it had been there"	root processEvent: evt copy resetHandlerFields.! !!WonderlandWrapperMorph methodsFor: 'accessing' stamp: 'ar 2/18/2001 22:32' prior: 31145942!hasHalo: aBool	super hasHalo: aBool.	aBool ifFalse:[		(self hasProperty: #surviveHaloLoss) ifFalse:[self delete].		self removeProperty: #surviveHaloLoss].! !!WonderlandWrapperMorph methodsFor: 'accessing' stamp: 'ar 2/18/2001 22:32'!transferHalo: event from: formerHaloOwner	"Progressively transfer the halo to the next likely recipient"	| localEvt |	formerHaloOwner == self ifTrue:[self setProperty: #surviveHaloLoss toValue: true].	"Never transfer halo to top-most world"	(self wantsHaloFromClick and:[formerHaloOwner ~~ self]) 		ifTrue:[^self addHalo: event from: formerHaloOwner].	event shiftPressed ifTrue:[		"Pass it outwards"		^owner ifNotNil:[owner transferHalo: event from: formerHaloOwner]].	self submorphsDo:[:m|		localEvt _ event transformedBy: (m transformedFrom: self).		(m fullContainsPoint: localEvt position) 			ifTrue:[^m transferHalo: event from: formerHaloOwner].	].	"We're at the bottom most level; throw the event back up to the root to find recipient"	^self getCameraMorph transferHalo: event from: formerHaloOwner.! !'From Squeak2.9alpha of 13 June 2000 [latest update: #3324] on 4 February 2001 at 10:22:03 am'!"Fixes bug that blocked painting on a Teddy 3-D object."!!WonderlandCameraMorph methodsFor: 'pooh-palette' stamp: 'laza 2/4/2001 10:06'!cancelPainting: aPaintBoxMorph evt: evt	^self cancel! !!WonderlandCameraMorph methodsFor: 'pooh-palette' stamp: 'laza 2/4/2001 10:07'!savePainting: aPaintBoxMorph evt: evt	"Save the image after user issued #keep in aPaintBoxMorph"	^self save! !!WonderlandCameraMorph methodsFor: 'pooh-palette' stamp: 'laza 2/4/2001 10:07'!undoPainting: pbox evt: evt	^self undo! !WonderlandCameraMorph removeSelector: #cancelPainting:!WonderlandCameraMorph removeSelector: #cancelPainting:!WonderlandCameraMorph removeSelector: #savePainting:!WonderlandCameraMorph removeSelector: #savePainting:!WonderlandCameraMorph removeSelector: #undoPainting:!WonderlandCameraMorph removeSelector: #undoPainting:!'From Squeak3.1alpha of 4 February 2001 [latest update: #3641] on 19 February 2001 at 12:26:11 am'!"Change Set:		GCDisplayFix-arDate:			19 February 2001Author:			Andreas RaabFixes an ugly little bug in #reverseDisplayFrom:to: that went unnoticed so far."!!Interpreter methodsFor: 'I/O primitives' stamp: 'ar 2/19/2001 00:22' prior: 22810477!reverseDisplayFrom: startIndex to: endIndex	"Reverse the given range of Display words (at different bit depths, this will reverse different numbers of pixels). Used to give feedback during VM activities such as garbage collection when debugging. It is assumed that the given word range falls entirely within the first line of the Display."	| displayObj dispBitsPtr w reversed |	displayObj _ self splObj: TheDisplay.	((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4])		ifFalse: [^ nil].	w _ self fetchInteger: 1 ofObject: displayObj.	dispBitsPtr _ (self fetchPointer: 0 ofObject: displayObj).	(self isIntegerObject: dispBitsPtr) ifTrue:[^nil].	dispBitsPtr _ dispBitsPtr + BaseHeaderSize.	dispBitsPtr + (startIndex * 4) to: dispBitsPtr + (endIndex * 4) by: 4 do: [:ptr |		reversed _ (self longAt: ptr) bitXor: 16rFFFFFFFF.		self longAt: ptr put: reversed].	self displayBitsOf: displayObj Left: 0 Top: 0 Right: w Bottom: 1.	self ioForceDisplayUpdate.! !'From Squeak3.1alpha of 4 February 2001 [latest update: #3641] on 18 February 2001 at 11:21:37 pm'!"Change Set:		SrcFileTweaks-arDate:			18 February 2001Author:			Andreas RaabFixes an error when changes file is absent. Fixes an error when attempting to saveAs with no changes file present."!!FileDirectory class methodsFor: 'system start up' stamp: 'ar 2/18/2001 23:20' prior: 33670373!openSources: sourcesName andChanges: changesName forImage: imageName 	"Initialize the default directory to the image directory and open the  	sources and changes files, if possible. Look for the changes file in  	image directory. Look for the system sources (or an alias to it) first in  	the VM directory, then in the image directory. Open the changes and  	sources files and install them in SourceFiles."	"Note: SourcesName and imageName are full paths; changesName is a  	local name."	| sources changes msg wmsg |	msg _ 'Squeak cannot locate &fileRef.Please check that the file is named properly and is in thesame directory as this image.  Further explanation can foundin the startup window, ''How Squeak Finds Source Code''.'.	wmsg _ 'Squeak cannot write to &fileRef.Please check that you have write permission for this file.You won''t be able to save this image correctly until you fix this.'.	sources _ self openSources: sourcesName forImage: imageName.	changes _ self openChanges: changesName forImage: imageName.	((sources == nil or: [sources atEnd])		and: [Preferences valueOfFlag: #warnIfNoSourcesFile])		ifTrue: 			[PopUpMenu notify: (msg copyReplaceAll: '&fileRef' with: 'the sources file named ' , sourcesName).			Smalltalk platformName = 'Mac OS'				ifTrue: [PopUpMenu notify: 'Make sure the sources file is not an Alias.']].	(changes == nil and: [Preferences valueOfFlag: #warnIfNoChangesFile])		ifTrue: [PopUpMenu notify: (msg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName)].	((Preferences valueOfFlag: #warnIfNoChangesFile) and:[changes notNil]) ifTrue: [		changes isReadOnly ifTrue:[			PopUpMenu notify: 				(wmsg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName)].		((changes next: 200) includesSubString: String crlf) ifTrue: [			PopUpMenu notify: 'The changes file named ' , changesName, 'has been injured by an unpacking utility.  Crs were changed to CrLfs.Please set the preferences in your decompressing program to "do not convert text files" and unpack the system again.']].	SourceFiles _ Array with: sources with: changes! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 2/18/2001 23:20' prior: 29122975!saveAs	| newName |	newName _ self getFileNameFromUser.	newName isNil ifTrue:[^self].	(SourceFiles at: 2) ifNotNil:[		self saveChangesInFileNamed: (self fullNameForChangesNamed: newName)].	self		saveImageInFileNamed: (self fullNameForImageNamed: newName);		logChange: '----SAVEAS ', newName, '----', Date dateAndTimeNow printString.! !'From Squeak3.0 of 4 February 2001 [latest update: #3545] on 18 February 2001 at 8:50:43 pm'!"Change Set:		MacVMSourceChanges3.0.7JMMDate:			18 February 2001Author:			johnmci@smalltalkconsulting.comBring mac source code upto 3.0.7"!!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/18/2001 20:49' prior: 33751755!macArchiveBinaryFile	"Answer the binary contents of a StuffIt archive file containing the CodeWarrier project files for the virtual machine. You will need to use a StuffIt unpacking utility such as StuffIt Expander to unpack the file. The result will be a folder containing the project files."	"To create the text for this method evaulate:		| in out |		in _ (FileStream oldFileNamed: 'projectArchive.sit') binary.		out _ WriteStream on: (String new: 100000).		out nextPutAll: '#('.		[in atEnd] whileFalse: [out nextPutAll: in next printString; space].		out skip: -1.		out nextPutAll: ')'.		in close.		Clipboard clipboardText: out contents asText	  and then do paste into this method."	^ #(83 116 117 102 102 73 116 32 40 99 41 49 57 57 55 45 49 57 57 56 32 65 108 97 100 100 105 110 32 83 121 115 116 101 109 115 44 32 73 110 99 46 44 32 104 116 116 112 58 47 47 119 119 119 46 97 108 97 100 100 105 110 115 121 115 46 99 111 109 47 83 116 117 102 102 73 116 47 13 10 26 0 5 16 0 0 109 103 0 0 0 114 0 10 0 0 0 114 96 160 0 43 0 5 1 96 1 255 0 0 0 0 0 0 165 165 165 165 1 0 0 62 0 16 181 144 51 21 182 158 25 127 0 0 0 0 0 0 11 3 0 0 0 0 0 14 47 50 0 0 37 20 0 0 9 183 0 0 0 0 15 0 109 121 77 97 99 72 101 97 100 101 114 115 46 99 0 1 249 212 84 69 88 84 67 87 73 69 1 0 1 128 1 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 106 0 0 0 0 15 0 66 193 212 138 116 88 41 37 231 118 79 249 86 183 220 130 201 119 237 194 11 107 95 101 129 233 78 237 233 41 2 10 134 65 190 14 57 147 88 117 246 30 129 230 100 86 124 160 181 213 228 113 176 242 110 15 116 236 78 49 113 111 82 137 215 100 243 164 56 26 150 173 165 69 200 187 255 179 112 28 55 170 135 33 198 200 235 206 99 142 62 109 255 116 149 57 0 236 41 186 92 188 174 38 174 192 66 193 212 132 70 70 86 227 229 250 240 216 108 46 2 127 7 118 93 193 98 100 220 19 200 129 89 135 89 82 22 238 49 159 133 108 171 14 212 223 34 215 77 208 114 160 164 237 185 214 129 65 199 201 45 211 163 103 203 58 2 85 140 45 151 178 152 115 9 199 215 95 96 151 105 218 21 183 124 139 66 246 165 122 233 239 249 49 33 230 241 98 152 155 66 5 97 56 210 80 40 74 50 161 38 49 191 246 13 248 37 22 30 82 47 247 193 20 8 253 47 112 160 72 112 53 215 204 3 97 248 96 8 243 221 18 149 108 14 129 125 171 25 125 64 92 146 29 121 208 175 185 114 183 252 116 88 47 20 203 91 54 195 197 212 254 215 49 246 175 214 179 20 62 218 106 240 184 65 250 38 189 140 67 51 74 95 30 3 237 219 189 131 26 139 234 59 182 38 237 228 223 81 228 70 109 151 93 182 102 227 203 12 157 152 107 15 98 148 171 41 204 102 172 62 195 233 155 129 52 241 31 197 124 118 99 45 58 83 248 22 215 210 251 42 253 224 32 223 130 124 29 99 117 213 224 39 13 123 115 248 26 221 26 239 139 238 20 111 20 56 127 75 111 87 227 74 59 31 173 85 118 51 26 21 56 145 199 107 6 134 163 54 13 38 143 9 8 177 101 138 176 126 236 42 83 222 165 174 137 128 18 108 62 172 104 206 82 31 153 2 182 57 73 14 84 208 156 251 177 59 232 160 12 252 203 218 179 103 69 40 108 127 129 76 239 43 241 84 12 202 12 118 247 134 247 28 5 26 17 8 152 197 86 37 168 231 169 178 114 72 86 108 222 32 244 59 133 232 143 193 13 133 147 126 127 149 24 121 2 38 68 52 152 209 111 150 184 27 137 253 238 123 197 0 118 134 239 237 36 138 92 9 194 243 159 213 60 212 20 229 59 28 20 233 18 161 31 106 165 1 110 83 216 106 180 249 207 9 174 17 94 185 168 244 3 4 168 140 63 65 99 190 250 119 64 70 17 171 160 166 169 104 159 33 175 236 14 164 90 174 65 175 124 152 30 15 87 146 118 109 236 131 130 220 219 214 112 125 170 137 231 54 250 21 145 43 231 188 66 60 145 144 78 191 182 237 122 40 55 70 174 38 200 113 225 103 84 13 29 121 130 211 114 223 222 52 197 13 242 137 125 59 249 152 208 14 117 204 232 95 173 10 254 158 64 113 32 71 211 118 10 37 152 22 6 193 1 255 147 16 255 96 95 2 197 244 163 41 80 165 64 231 82 177 26 111 196 195 16 244 124 241 119 42 72 98 152 240 138 13 187 140 50 8 203 25 228 139 176 231 43 188 185 2 244 190 171 127 194 95 139 23 204 75 146 60 62 27 80 38 93 38 145 109 19 117 6 190 225 110 85 211 48 214 67 194 48 118 230 103 121 110 231 193 135 164 195 102 232 253 49 148 47 128 195 236 125 10 219 186 74 154 99 167 196 60 86 195 220 106 181 140 85 69 75 218 24 134 11 31 42 184 151 115 226 63 107 52 127 87 90 27 209 125 49 244 52 72 106 47 168 194 221 133 102 80 172 93 30 180 148 98 219 250 1 131 80 231 16 175 251 155 120 51 58 133 74 44 194 98 69 220 203 116 191 232 6 60 149 104 160 232 101 60 176 56 85 193 184 154 196 187 176 181 220 6 241 108 26 22 183 125 180 240 179 101 192 98 125 237 3 89 114 235 91 209 164 113 1 58 129 69 227 29 19 29 199 223 52 106 86 210 28 98 88 130 229 148 120 16 129 14 17 4 222 44 49 251 34 155 53 1 122 248 192 61 173 28 105 15 199 20 82 30 53 37 81 146 117 100 246 78 108 152 234 93 106 164 44 100 57 126 9 134 155 27 184 21 148 185 94 106 50 113 228 79 94 34 151 21 160 54 33 4 249 230 134 176 70 241 249 85 152 252 212 193 251 181 238 242 57 219 252 62 154 74 65 219 88 115 39 77 236 5 188 230 126 109 127 233 91 10 224 186 224 60 237 252 238 150 54 161 201 94 8 244 145 47 44 217 137 239 234 201 42 8 178 49 89 199 176 56 165 31 101 19 109 234 101 137 162 10 229 183 144 68 242 150 52 133 117 88 173 140 84 230 109 53 133 118 31 127 28 54 7 230 85 169 251 254 192 6 169 172 189 140 22 174 91 19 91 125 223 162 84 237 230 213 183 153 250 131 177 111 6 84 183 247 13 76 39 186 31 198 85 4 65 32 19 1 99 145 201 225 227 243 17 214 185 26 33 101 205 44 160 34 195 147 137 18 207 88 193 239 159 19 49 180 186 110 34 91 81 126 47 101 10 118 12 117 42 111 147 156 94 195 157 204 248 229 229 155 103 232 66 107 220 242 138 252 243 151 217 136 131 173 212 193 219 166 253 173 88 80 220 63 46 109 88 232 90 249 96 67 199 255 136 27 154 43 84 216 241 187 178 227 175 65 114 73 13 15 98 255 39 134 162 119 232 163 16 23 93 129 62 166 157 15 154 27 26 22 115 8 168 226 84 233 64 121 6 75 60 59 127 229 225 29 214 193 226 73 79 102 74 60 56 130 137 229 133 2 50 59 52 230 115 36 203 162 101 18 167 216 183 101 153 45 171 24 125 246 212 22 150 51 149 179 153 191 89 161 218 135 97 19 194 50 34 223 113 101 103 136 83 76 55 48 36 80 56 226 27 48 120 156 42 19 32 20 17 57 39 33 219 123 249 192 127 10 182 75 171 92 189 220 14 220 60 159 227 228 14 241 235 112 90 20 251 157 160 3 36 236 95 173 58 230 127 69 243 123 75 97 113 205 83 246 125 11 125 96 36 176 106 177 61 42 181 20 175 94 167 143 126 251 254 160 166 65 77 62 9 249 97 143 85 228 244 116 212 36 139 27 39 2 205 126 120 142 16 221 171 238 9 71 136 127 183 207 62 15 86 53 15 2 102 101 179 61 141 49 213 40 141 163 67 190 184 255 243 129 31 131 167 254 204 179 48 58 103 182 95 167 251 52 47 18 107 18 137 227 164 93 85 188 234 111 109 2 84 181 250 201 87 56 179 139 122 116 9 72 150 26 201 3 16 131 116 158 40 94 162 107 116 254 167 70 163 135 76 238 186 199 185 34 229 206 216 82 176 11 88 86 57 139 30 2 208 123 57 141 221 171 211 186 142 118 126 139 154 109 57 79 1 35 167 40 44 39 213 242 211 220 168 159 200 169 179 212 88 68 78 200 147 37 40 78 169 30 98 229 242 15 101 5 179 4 239 182 164 66 15 21 205 242 169 118 60 166 24 139 110 88 102 100 95 76 164 156 185 94 78 122 188 84 74 244 3 153 155 54 89 214 52 181 186 49 248 74 61 63 130 1 251 48 92 241 131 25 214 90 146 245 111 208 0 200 130 56 240 165 169 148 206 222 128 170 66 144 165 235 199 35 41 172 79 16 73 84 79 60 126 86 20 84 57 189 173 108 83 108 81 41 110 196 34 198 64 130 167 53 95 252 127 145 160 17 25 107 30 200 4 122 235 171 27 245 83 163 114 251 243 83 92 90 202 225 71 136 233 48 236 166 227 153 9 44 86 152 46 157 33 106 211 38 217 131 189 158 77 118 186 137 83 106 231 38 183 90 52 35 137 96 149 252 106 81 140 59 206 123 111 194 70 128 243 110 236 189 248 13 44 218 175 155 189 61 117 24 11 169 190 120 244 49 97 84 33 238 113 123 121 234 200 117 143 213 164 67 118 136 81 156 181 97 170 195 15 90 84 197 162 128 180 123 146 157 140 166 23 62 191 219 207 52 11 47 102 15 132 239 222 55 33 195 105 219 7 235 139 152 116 60 25 96 195 178 61 14 158 181 173 197 130 3 51 243 102 76 103 143 10 245 92 220 236 141 223 116 227 66 7 57 153 114 238 10 230 232 176 12 175 132 255 205 252 18 152 205 169 191 124 59 188 115 70 80 37 198 61 238 169 19 8 73 36 110 103 133 105 74 11 15 219 222 225 80 37 208 46 80 225 212 115 148 86 235 203 83 7 141 117 136 142 4 23 62 124 10 94 45 49 81 53 68 172 40 141 44 61 248 53 189 171 93 232 151 125 187 242 44 48 78 122 14 155 71 149 26 249 110 4 137 252 232 107 95 133 111 248 39 32 216 250 139 71 199 65 188 109 185 222 173 38 154 41 26 203 164 65 78 224 92 171 208 90 72 55 177 173 76 81 231 243 216 204 118 128 229 102 224 120 76 223 0 232 167 190 139 96 143 251 23 60 117 73 185 52 25 41 30 92 16 109 65 55 254 254 173 95 201 191 193 56 212 8 23 212 173 150 167 92 25 22 96 99 170 165 164 40 36 195 183 62 219 4 67 46 22 63 222 5 189 85 231 135 117 193 81 183 28 185 150 204 45 138 16 29 249 195 34 17 152 49 55 161 150 67 67 238 114 100 72 91 0 22 231 161 15 143 49 222 113 6 12 169 143 119 228 135 153 170 60 177 165 119 120 180 81 178 118 192 182 42 171 188 123 62 224 76 89 178 221 232 21 1 32 55 48 174 83 32 204 196 152 115 160 94 162 76 36 234 130 46 208 158 156 130 16 2 200 63 214 12 68 238 216 11 69 230 210 144 197 49 0 137 72 242 7 201 79 14 15 92 223 226 57 137 113 156 96 94 22 62 239 156 25 246 159 72 150 236 47 148 93 81 82 160 65 193 218 226 5 173 68 149 131 185 38 21 54 28 45 163 133 100 249 71 53 193 81 236 219 46 36 117 122 241 67 70 160 158 137 200 28 140 228 117 216 92 197 139 107 45 76 132 225 120 25 241 135 183 155 93 124 61 178 162 153 124 169 222 88 143 122 87 102 247 47 37 141 255 232 110 183 43 235 205 24 115 77 112 204 130 226 183 244 107 237 88 133 215 112 156 91 244 40 149 126 211 18 61 248 243 242 234 1 67 155 205 165 46 241 183 45 57 192 220 209 108 240 103 75 84 225 56 241 98 50 22 74 38 110 229 178 174 113 149 105 219 99 204 9 187 142 57 11 80 19 222 31 78 163 164 81 225 238 93 139 39 45 77 116 191 122 147 93 63 47 1 43 54 59 33 120 183 197 115 221 125 55 140 107 197 207 252 168 189 93 204 160 15 6 92 87 21 69 13 171 60 68 240 229 169 136 185 10 16 114 157 62 4 62 98 10 25 57 208 210 238 206 221 244 23 46 24 203 6 182 53 192 196 161 244 15 113 51 114 84 111 207 79 49 240 83 61 153 132 114 177 48 194 95 237 67 44 187 237 135 159 159 33 223 31 214 108 74 197 120 50 91 204 64 45 244 193 54 170 53 199 41 10 70 220 145 68 218 10 32 158 205 48 186 18 120 100 158 47 3 157 62 91 7 54 31 217 83 233 226 95 125 28 51 6 123 194 39 147 63 52 100 201 220 96 226 242 131 85 96 214 22 71 194 69 5 99 37 88 48 22 245 153 70 245 85 38 116 133 224 61 191 197 143 169 70 94 167 89 162 114 248 119 73 40 186 97 52 83 229 239 50 37 67 25 0 165 165 165 165 1 0 0 64 0 16 181 144 51 13 182 158 25 127 0 0 0 114 0 0 13 78 0 0 0 0 0 16 118 69 0 0 3 20 0 0 1 114 0 0 0 0 15 0 109 121 77 97 99 72 101 97 100 101 114 115 46 112 99 104 0 1 88 136 84 69 88 84 67 87 73 69 1 0 0 192 2 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 103 0 0 0 0 15 0 66 193 212 165 47 158 101 143 90 111 232 62 137 252 56 69 246 56 222 197 11 110 186 70 46 68 245 227 157 58 176 118 108 255 85 62 40 178 85 18 69 169 203 40 18 219 49 207 252 15 57 78 136 238 192 137 69 135 101 84 46 156 13 5 175 9 5 162 245 172 207 165 169 206 88 73 211 171 164 174 112 63 71 184 31 221 37 166 79 5 131 15 114 244 238 207 216 239 17 227 177 67 160 66 193 212 154 175 240 32 110 231 176 220 75 122 67 45 140 218 152 26 188 19 16 70 46 100 12 102 162 171 207 147 232 46 129 230 224 142 44 70 162 102 82 16 65 169 232 58 197 1 226 230 247 241 20 175 215 67 32 203 217 208 134 187 150 162 63 110 169 185 56 142 225 246 180 33 114 124 5 37 84 212 128 30 164 229 208 216 224 187 2 126 209 51 142 7 56 139 220 232 168 56 210 119 197 236 95 113 121 147 62 5 16 6 102 148 120 76 237 88 4 46 152 207 227 190 58 105 25 63 228 30 242 145 30 205 193 119 28 65 161 6 85 113 254 35 25 218 241 155 57 46 34 101 87 219 177 175 90 37 23 192 16 110 135 14 201 90 113 155 204 60 215 16 232 111 135 218 123 36 119 224 93 163 67 233 232 62 127 241 177 118 93 131 253 225 94 147 211 226 106 223 56 140 40 243 210 212 240 205 25 69 158 223 23 7 45 121 161 103 21 93 76 191 131 11 37 220 95 159 108 53 71 237 228 38 192 96 36 234 168 14 101 68 218 187 125 239 67 136 208 224 145 202 41 73 44 92 125 93 164 127 252 148 199 42 76 2 0 50 102 61 155 95 144 49 242 226 212 139 39 169 250 165 133 244 188 11 198 113 244 133 255 208 95 234 165 90 112 27 52 250 90 78 166 0 202 127 35 59 223 131 14 154 81 218 181 53 29 254 103 48 33 191 225 6 186 233 121 161 97 169 147 218 120 247 111 39 193 212 57 27 102 129 167 141 48 58 146 236 83 180 135 36 193 196 77 181 97 218 24 94 119 88 225 88 61 107 38 42 0 165 165 165 165 1 0 0 70 0 16 181 144 51 13 182 158 25 125 0 0 11 3 0 0 15 252 0 0 0 0 0 22 20 235 0 0 3 180 0 0 1 205 0 0 0 0 15 0 109 121 77 97 99 72 101 97 100 101 114 115 67 97 114 98 111 110 46 112 99 104 0 1 219 219 84 69 88 84 67 87 73 69 1 0 0 16 0 16 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 105 0 0 0 0 15 0 66 193 212 165 47 158 104 163 81 45 121 217 33 168 151 12 136 51 216 133 159 78 214 216 43 6 93 88 173 49 224 16 210 176 244 190 46 112 249 208 12 31 155 208 114 175 160 237 166 80 129 149 37 165 111 12 49 64 250 168 169 159 82 99 244 238 46 66 203 196 69 63 252 89 175 97 38 187 103 169 162 122 93 198 238 248 174 171 90 231 91 24 116 109 194 102 235 220 101 188 198 239 167 48 0 66 193 212 247 142 41 244 252 170 32 131 125 120 226 219 34 155 40 95 65 156 245 152 111 218 35 102 116 216 131 145 17 84 107 97 158 240 249 195 150 60 120 140 104 228 134 193 204 31 57 215 166 99 44 206 176 32 16 144 208 6 248 187 61 109 226 227 51 211 25 218 191 40 12 114 22 28 230 0 112 11 172 202 32 219 160 175 46 72 139 187 24 169 29 138 113 109 138 194 65 131 26 203 70 229 19 88 5 218 129 23 174 244 179 27 110 213 99 88 249 52 149 107 131 128 11 191 219 77 60 140 147 221 41 5 154 71 244 111 11 122 216 102 224 199 124 224 181 243 197 90 177 66 36 17 3 41 236 155 135 117 157 197 125 86 112 49 216 189 27 139 184 235 236 11 77 248 224 96 79 164 194 90 103 41 162 119 82 173 71 116 83 120 63 237 133 59 95 243 179 182 38 66 89 112 120 57 175 247 2 86 164 221 215 242 66 72 241 206 94 82 185 213 183 84 158 243 111 184 131 123 154 113 69 129 63 216 193 18 183 237 229 86 226 139 223 239 210 173 153 53 67 49 7 198 215 211 213 85 237 110 87 144 203 47 169 210 32 17 124 119 167 84 218 32 64 80 64 213 139 46 73 67 237 85 242 129 68 80 18 116 121 38 21 132 110 38 88 152 155 85 234 152 132 14 186 223 127 213 177 161 118 126 164 93 140 86 9 39 140 158 128 15 121 128 22 82 198 32 125 160 105 176 229 213 67 60 105 93 166 53 20 133 196 110 63 239 200 252 182 252 210 104 194 171 61 38 193 140 109 223 92 105 43 228 169 222 61 252 104 255 66 238 34 62 131 239 211 193 88 118 48 247 65 45 181 8 92 165 55 106 219 2 60 38 114 62 64 145 43 151 179 227 59 232 214 164 43 226 209 187 193 230 212 51 34 107 155 72 0 26 242 4 241 9 64 80 182 179 217 254 181 123 67 245 13 80 221 209 230 9 60 229 105 10 138 253 27 231 68 155 196 137 233 97 229 82 175 213 222 96 165 165 165 165 1 0 0 61 0 0 172 94 103 33 181 100 42 6 0 0 13 78 0 0 28 169 0 0 0 0 0 13 171 241 0 0 7 218 0 0 2 139 0 0 0 0 15 0 77 121 80 108 117 103 105 110 46 112 114 111 106 0 1 46 58 77 77 80 82 67 87 73 69 1 0 3 64 1 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 43 27 0 0 9 179 0 0 0 0 15 0 66 193 212 194 19 180 140 109 220 205 78 57 63 90 66 84 57 156 71 10 240 179 194 234 180 76 49 136 61 86 193 33 87 165 51 39 174 141 114 32 57 229 43 22 87 128 72 84 38 117 129 4 182 215 234 186 97 240 130 6 7 168 37 149 122 3 125 3 195 87 185 151 254 22 251 249 238 210 167 130 219 121 155 186 134 229 95 75 152 58 93 250 123 38 106 43 222 218 75 149 20 150 219 56 44 81 228 23 54 251 165 214 237 251 0 192 205 43 113 64 228 181 201 133 51 84 209 66 37 59 176 144 234 4 186 142 81 128 228 2 55 216 158 134 41 177 194 7 95 252 212 255 73 83 237 231 200 33 245 234 99 190 79 33 76 97 115 253 35 55 46 42 13 118 116 73 161 215 249 23 162 74 26 161 34 208 52 177 148 31 2 225 128 147 212 218 175 235 77 215 179 45 41 42 83 138 73 222 20 4 247 49 227 152 237 224 96 210 249 218 162 93 24 168 187 8 67 87 106 36 240 23 14 253 32 32 233 250 182 103 110 104 23 208 218 230 121 74 225 57 124 53 128 60 111 91 170 168 211 245 68 13 214 181 216 230 12 119 31 218 154 171 103 239 30 230 22 188 226 29 238 162 224 59 253 70 31 56 103 224 36 245 159 238 139 104 201 201 132 39 227 128 0 62 234 60 136 63 255 195 11 172 202 17 37 216 84 146 63 219 54 56 151 166 38 241 106 221 197 103 27 237 182 165 6 183 114 101 218 141 240 64 148 45 222 37 21 103 254 127 46 56 173 37 215 210 155 156 143 214 184 249 118 238 209 196 193 63 132 149 152 85 92 181 13 27 221 176 225 145 152 79 7 62 97 181 120 39 91 165 74 115 184 46 199 3 192 153 218 145 229 140 225 48 115 235 24 105 61 157 168 6 39 4 200 157 182 175 112 130 106 48 11 175 17 0 192 51 97 61 92 231 192 128 4 202 158 82 84 178 6 244 58 194 143 198 197 84 245 194 178 69 38 193 153 99 228 73 197 137 51 95 234 74 220 141 111 161 135 191 121 33 201 254 51 7 28 164 179 195 57 17 73 210 193 161 123 149 11 73 41 75 25 196 86 100 212 137 148 255 191 61 249 212 167 243 124 178 252 243 230 210 105 103 137 88 244 8 170 166 127 33 239 33 76 177 46 165 94 119 60 57 69 82 53 93 97 113 18 211 180 59 221 195 107 202 4 125 117 172 218 169 252 32 46 1 54 41 228 135 201 89 109 105 202 112 20 196 166 41 173 208 173 27 148 202 143 245 25 142 72 111 18 240 135 44 9 113 199 4 252 36 142 207 253 43 184 119 116 86 138 249 177 138 141 63 33 191 93 190 139 209 129 212 216 83 151 194 200 24 252 41 196 242 80 71 41 30 226 43 28 209 35 219 218 177 65 128 188 55 183 237 64 231 242 161 168 189 135 114 61 217 9 64 19 4 196 99 134 88 34 235 184 97 44 234 25 195 176 83 127 209 207 190 234 196 243 14 19 177 134 74 190 120 202 207 65 100 1 59 62 46 48 80 135 3 9 73 242 18 57 109 183 245 222 178 216 183 84 76 56 208 27 8 158 248 66 214 155 165 188 137 94 194 111 156 211 2 200 53 127 166 203 170 79 164 98 8 33 169 242 184 152 189 171 140 226 112 193 38 34 179 149 178 39 37 88 11 56 158 240 172 153 69 71 107 203 187 140 154 176 235 8 151 194 172 241 194 59 173 162 204 166 181 114 97 224 92 71 116 144 235 121 221 159 124 218 189 170 239 83 135 28 243 178 223 131 227 17 146 169 220 93 31 64 246 60 114 194 162 48 94 192 255 37 210 128 223 90 148 255 167 134 204 96 230 126 180 73 114 139 161 17 171 76 130 56 199 160 130 180 229 165 79 185 10 128 134 241 79 80 147 118 89 165 116 61 94 67 177 61 154 226 10 230 26 219 235 251 35 12 194 40 38 35 252 251 191 11 198 3 254 127 229 204 232 61 105 255 53 135 108 128 24 78 193 229 23 109 141 167 141 113 72 6 184 7 83 149 143 141 161 13 193 130 105 121 159 72 83 255 218 246 207 168 2 188 251 220 106 202 121 24 137 85 236 151 184 191 38 29 12 123 142 42 244 196 40 124 66 26 203 78 220 166 73 142 150 63 166 17 119 99 243 166 176 210 220 215 118 253 59 143 35 122 222 50 58 29 51 211 19 174 220 236 227 198 71 227 70 156 97 25 76 78 210 252 109 98 200 134 0 148 114 221 154 66 23 196 248 37 253 225 184 18 33 116 236 252 67 236 135 114 205 157 120 160 155 132 133 60 83 40 206 205 65 122 27 3 244 137 119 158 91 42 59 189 57 230 202 3 71 214 181 17 91 237 71 219 25 87 69 187 54 79 222 40 229 9 229 71 160 174 72 187 107 25 142 156 159 128 201 103 230 130 228 230 37 21 220 76 245 164 173 70 236 120 248 32 0 235 8 226 156 150 195 159 49 115 251 27 199 242 115 185 77 140 190 205 244 7 223 191 94 162 200 1 170 101 82 196 36 62 145 104 149 184 123 177 153 15 220 14 50 253 40 5 192 198 227 129 195 234 3 23 1 199 104 182 67 51 17 31 177 252 147 96 76 24 221 202 12 236 136 115 123 75 165 115 55 2 242 194 9 252 13 250 160 95 132 217 253 162 222 168 205 117 26 224 163 41 136 164 32 42 40 60 7 24 87 230 249 31 58 236 150 135 184 249 22 205 31 97 180 112 137 182 250 89 4 221 38 113 74 247 168 206 215 112 54 174 17 124 134 22 229 141 40 117 220 60 36 142 159 28 196 12 79 250 234 136 200 220 192 151 253 59 63 143 176 44 197 118 7 251 9 88 225 69 165 197 229 146 92 13 230 142 60 188 7 204 81 241 42 116 68 128 100 171 169 163 137 188 9 17 212 4 231 195 226 170 216 196 24 94 172 65 211 52 75 97 206 167 143 24 61 168 230 229 31 239 42 70 74 67 179 96 52 199 96 80 117 42 122 92 36 146 138 21 213 65 96 75 175 232 31 107 43 33 91 231 154 123 5 24 28 139 122 138 127 91 147 185 79 21 150 196 39 242 145 196 148 195 22 235 187 30 46 175 109 249 30 33 44 231 138 19 255 207 171 119 184 201 171 190 52 6 187 143 13 176 206 38 141 52 54 14 234 19 13 72 228 115 134 239 231 78 161 68 240 39 189 238 92 137 134 220 92 228 98 165 0 223 127 16 233 228 150 150 183 157 213 170 18 108 187 193 244 40 94 214 27 214 103 133 11 23 106 140 153 150 249 216 192 173 245 226 15 71 223 152 10 15 241 34 209 142 177 116 19 237 153 115 235 149 33 51 8 136 185 42 26 124 13 143 64 6 191 151 249 2 34 136 141 198 23 227 78 45 51 175 180 143 131 177 93 122 47 116 190 243 99 42 32 159 106 87 251 223 159 179 37 63 143 200 173 119 171 27 79 79 149 2 209 224 156 255 224 213 5 208 114 14 166 128 135 141 222 107 146 148 60 212 87 95 249 62 108 29 151 193 171 48 111 202 218 27 135 180 253 254 184 223 129 63 91 60 123 221 98 165 199 70 36 4 155 209 197 95 213 90 27 172 67 75 182 52 134 225 138 50 128 100 245 153 1 73 95 228 92 254 186 19 225 208 85 38 151 24 215 131 149 191 230 74 57 107 248 227 229 111 209 108 16 211 152 104 163 251 128 215 147 85 150 15 43 134 83 159 42 239 54 28 40 73 52 207 84 129 239 98 214 179 21 102 137 178 110 247 152 202 120 33 245 91 121 128 234 177 58 4 101 109 183 205 222 157 164 79 7 109 210 19 253 233 66 110 212 180 156 55 124 37 83 157 36 52 71 108 27 185 118 84 11 222 1 186 180 176 54 75 2 134 10 200 41 247 243 115 198 166 236 142 190 189 239 126 125 106 88 219 213 89 86 112 164 28 237 40 73 163 214 41 167 51 226 144 185 109 128 31 24 46 11 81 151 124 82 134 29 127 35 25 190 38 212 98 223 126 203 32 60 74 103 251 72 156 19 78 206 72 239 13 5 249 184 234 54 28 128 245 0 249 90 69 3 123 98 160 210 186 41 73 17 3 28 112 129 216 217 199 108 97 59 3 225 73 152 69 217 146 229 62 27 45 119 23 226 20 9 145 94 46 115 121 134 233 179 133 155 94 199 108 100 28 131 175 206 140 90 173 14 18 76 19 202 83 159 22 214 223 144 183 119 149 129 120 70 181 99 68 133 35 149 192 17 182 40 216 129 186 185 222 109 72 135 219 119 115 196 249 44 150 83 58 212 26 210 154 53 109 49 36 39 146 188 84 202 107 117 165 30 161 103 160 138 30 154 85 67 10 214 221 117 225 102 176 143 120 211 187 176 196 245 60 28 179 165 154 167 22 55 97 242 45 252 235 170 218 20 43 72 243 201 54 123 101 20 33 48 168 180 233 60 232 203 7 66 56 124 146 214 112 254 140 37 96 243 38 179 116 69 25 227 129 70 166 160 195 95 119 149 251 212 214 138 62 183 247 149 85 11 116 61 189 17 187 149 100 21 248 121 103 245 72 14 36 248 191 128 103 91 132 118 39 131 121 52 247 206 93 47 82 113 11 31 148 91 121 169 110 211 31 34 248 177 165 90 108 123 99 171 35 104 32 238 176 63 65 30 99 58 169 225 58 211 237 4 229 142 123 59 108 223 136 197 220 218 91 179 0 121 93 76 67 65 204 151 161 33 65 74 212 79 82 70 71 34 30 120 110 193 0 36 170 193 44 45 143 228 131 205 150 244 160 150 106 22 65 152 121 20 125 25 104 52 133 104 165 184 88 121 83 121 93 99 250 114 15 118 56 143 178 96 88 189 162 5 211 244 73 153 40 207 205 71 138 167 60 186 201 213 118 68 181 199 75 78 195 34 132 17 127 183 98 72 65 22 255 140 196 232 205 157 2 110 42 175 37 4 30 101 25 242 48 107 25 105 159 30 213 210 157 118 121 51 157 187 180 131 3 44 5 185 15 215 79 162 2 26 65 168 188 175 126 122 46 117 97 63 225 223 18 22 211 203 44 218 82 158 29 119 110 57 91 14 143 66 109 2 240 56 94 247 35 47 101 146 49 98 29 193 204 226 150 16 203 189 11 251 203 208 29 186 250 218 53 107 74 41 140 45 140 4 31 27 113 69 36 188 128 46 81 132 34 77 101 50 169 28 156 133 164 129 253 215 241 194 174 172 194 42 220 190 205 227 223 125 42 185 109 222 61 100 144 193 147 66 193 232 72 220 164 225 179 24 189 206 106 11 94 84 43 63 244 25 229 114 152 79 232 252 147 54 43 138 6 104 248 81 78 162 136 226 36 206 113 106 248 66 115 193 28 216 164 130 112 222 54 251 213 143 169 214 127 195 37 79 48 191 31 239 222 47 54 197 188 194 74 4 90 50 70 38 100 59 49 223 218 178 37 231 49 12 152 217 227 91 99 20 154 159 152 122 106 149 86 103 187 70 156 1 251 186 172 207 166 67 51 147 24 159 0 66 193 212 209 173 202 54 121 186 247 106 241 139 248 136 144 151 199 247 80 188 144 101 75 21 223 57 158 220 219 236 232 23 100 202 212 173 34 206 147 90 245 218 205 94 143 37 178 123 245 10 207 222 177 255 205 243 59 2 92 205 14 246 210 227 42 114 60 115 43 247 225 110 54 179 180 171 8 226 94 227 206 84 12 108 245 165 220 186 62 202 190 198 31 48 221 104 253 145 8 22 239 235 157 224 89 115 154 66 225 233 26 132 65 101 103 113 198 133 195 218 235 163 15 66 48 130 138 254 104 191 21 132 73 188 3 18 49 233 212 33 173 203 85 255 167 237 129 60 173 232 204 54 14 112 18 11 20 121 253 133 205 30 128 169 42 1 114 138 184 35 247 111 197 232 255 8 125 197 39 27 123 188 217 183 113 101 115 55 200 76 41 136 182 194 36 115 226 46 180 223 15 180 184 199 127 207 175 183 18 108 253 224 68 225 189 230 145 197 113 58 99 64 169 236 231 55 89 138 194 172 139 126 15 235 114 7 190 146 185 206 38 26 160 116 201 4 85 157 75 151 138 219 4 150 5 192 67 120 123 231 151 29 125 34 237 37 125 175 14 219 63 40 148 37 198 227 142 220 5 165 190 80 20 226 226 188 106 110 189 68 213 83 144 111 161 33 212 140 77 52 244 117 247 254 247 134 221 112 95 223 125 162 95 247 113 127 148 138 20 251 103 234 125 73 19 94 81 44 249 114 11 173 196 15 63 229 13 115 251 195 11 98 206 183 202 33 193 89 219 11 110 155 116 53 252 253 48 32 153 170 120 19 185 239 38 248 134 53 99 79 234 178 251 112 68 87 151 119 91 159 228 132 234 207 90 233 251 86 23 140 87 198 204 228 239 33 97 205 23 105 57 191 169 94 234 175 182 54 157 209 165 39 1 23 153 99 4 83 250 118 150 110 225 141 205 108 23 85 157 117 151 134 213 237 178 162 80 51 220 165 2 220 8 167 35 52 225 141 195 156 254 21 76 95 231 237 249 231 199 223 249 56 16 105 49 246 179 86 86 199 222 103 162 50 165 41 77 133 132 4 246 90 221 161 237 175 20 1 224 5 208 134 151 85 245 81 241 166 113 128 176 170 18 208 148 167 107 165 84 201 247 77 110 178 243 212 76 28 185 151 25 3 254 91 135 233 7 181 194 191 189 100 178 100 20 92 126 239 85 113 127 203 20 251 252 161 1 63 35 197 97 30 51 62 136 236 104 162 216 84 86 49 130 181 92 215 169 183 20 181 106 88 75 233 118 139 43 234 2 58 27 15 194 152 140 103 217 39 100 170 4 96 201 205 75 153 189 203 211 117 177 25 176 204 93 16 68 7 53 84 183 210 189 91 68 187 188 136 34 168 145 152 249 26 42 26 225 31 239 15 249 137 120 247 29 172 107 103 137 180 207 217 121 27 149 32 90 137 141 176 165 165 165 165 1 0 0 64 0 0 172 94 103 33 181 100 23 240 0 0 15 252 0 0 40 248 0 0 0 0 0 16 180 253 0 0 7 90 0 0 2 148 0 0 0 0 15 0 77 121 80 108 117 103 105 110 54 56 75 46 112 114 111 106 0 1 162 139 77 77 80 82 67 87 73 69 1 0 3 128 0 129 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 37 135 0 0 9 73 0 0 0 0 15 0 66 193 212 169 9 210 149 55 104 18 166 123 198 254 115 231 189 56 26 63 233 107 89 215 26 41 64 39 168 254 239 247 106 245 213 179 37 162 85 150 47 25 75 142 73 147 42 103 39 18 89 87 185 158 183 144 191 121 197 58 247 237 47 168 4 250 221 80 196 140 250 2 153 82 24 7 101 152 165 56 154 236 133 124 32 161 65 134 202 240 234 38 74 220 207 29 183 187 78 143 128 78 228 25 224 83 50 226 241 200 15 193 111 178 15 246 78 206 228 147 246 197 203 10 10 242 105 41 4 66 205 9 1 225 252 22 138 140 209 6 181 240 179 154 27 24 6 94 118 33 215 71 251 65 6 46 194 156 224 245 152 248 245 163 117 106 184 81 55 44 43 63 12 15 131 173 177 63 58 108 90 116 237 57 130 18 45 207 39 168 184 124 14 234 151 77 158 24 238 174 149 45 154 30 127 131 200 231 47 199 96 208 217 78 147 104 4 219 175 174 33 142 236 210 130 219 100 211 116 254 15 231 119 8 95 0 178 98 122 210 142 229 104 67 70 12 175 141 92 58 110 110 125 213 36 115 84 117 144 245 75 148 181 55 130 172 219 99 192 169 188 102 174 245 3 98 201 249 187 198 155 60 173 205 234 41 227 58 211 109 39 124 98 234 206 156 15 73 86 25 233 109 125 254 184 178 214 178 133 136 246 117 48 173 55 248 26 8 190 78 97 200 67 23 26 223 148 9 135 229 250 93 43 221 207 238 48 11 146 126 167 202 57 129 122 208 16 68 11 171 85 193 55 197 75 206 6 101 225 159 104 37 53 24 149 113 98 108 118 35 180 159 124 25 241 188 82 51 147 186 228 19 144 214 103 241 33 199 95 1 89 148 121 49 217 177 30 75 206 83 68 131 49 235 210 72 87 124 132 117 54 28 248 36 131 82 144 238 147 41 18 75 146 21 97 35 176 24 27 156 45 171 65 232 213 217 183 86 97 199 127 122 105 229 192 146 21 171 163 104 83 164 85 85 159 97 16 133 250 117 123 35 109 109 221 183 95 120 25 237 167 23 213 43 6 178 186 44 154 201 162 86 26 136 87 11 90 163 230 224 102 104 162 19 246 228 233 218 91 12 199 141 183 74 205 224 12 153 150 177 85 0 41 202 28 63 57 160 34 129 152 15 10 240 140 213 45 91 151 230 63 252 32 81 62 58 251 113 147 52 74 212 214 30 114 32 135 185 204 7 224 181 26 172 91 169 81 65 140 201 52 185 195 170 193 233 103 214 112 109 65 219 94 83 253 182 167 152 47 211 90 104 203 34 241 216 55 162 73 128 24 254 18 243 43 51 199 224 93 181 216 4 195 100 21 1 142 111 89 99 181 120 228 69 89 150 166 67 160 133 83 74 25 120 228 202 151 213 197 238 169 7 25 75 215 132 139 13 128 148 42 185 174 244 128 76 188 161 166 164 16 51 147 115 251 235 205 105 232 86 142 76 237 244 167 29 43 177 248 156 194 246 97 15 7 255 213 141 41 156 105 175 207 13 3 192 68 119 2 85 97 230 126 53 40 79 97 45 221 168 205 66 34 36 28 180 173 22 22 180 51 194 56 193 255 243 75 101 57 141 155 154 6 150 42 8 180 204 128 177 95 60 122 220 131 125 225 225 49 227 224 60 187 72 148 80 225 109 173 250 161 103 80 190 248 119 106 225 182 172 156 189 14 39 39 172 51 134 119 87 74 119 174 13 184 80 179 206 211 203 197 4 98 108 88 244 9 167 90 0 179 111 74 175 93 37 151 71 255 226 242 57 3 70 223 10 238 143 109 72 108 218 5 38 140 97 70 133 196 185 229 124 137 190 203 76 81 53 60 4 82 244 201 125 216 66 13 237 218 214 208 120 143 242 251 23 135 220 72 32 82 237 68 189 70 62 224 254 70 62 224 229 134 119 188 130 31 152 255 212 226 149 189 221 60 223 148 73 202 157 18 249 54 56 126 101 207 255 58 91 68 133 67 118 98 230 235 242 45 38 75 183 17 235 204 212 204 222 45 249 140 101 163 86 59 125 195 111 43 228 127 205 120 199 85 241 203 115 36 38 114 138 200 134 12 65 52 23 170 58 186 89 15 23 144 208 141 125 252 131 154 213 103 133 164 20 24 181 20 212 220 255 114 55 158 205 47 147 146 107 120 61 236 170 84 104 212 61 32 201 252 208 92 120 214 182 30 6 28 5 1 22 67 109 244 114 222 27 168 58 178 108 199 187 12 57 225 72 255 253 245 130 250 31 222 250 246 10 101 46 52 182 55 251 253 245 81 49 245 105 93 45 82 221 74 249 125 1 22 82 12 24 109 64 86 153 199 117 92 85 16 118 131 199 159 35 198 115 25 194 53 204 76 60 91 61 99 94 137 235 45 223 47 205 83 53 161 9 165 132 157 86 145 51 163 200 190 148 205 153 118 167 140 3 86 133 127 81 179 26 56 173 105 221 157 174 25 29 252 191 134 231 205 247 66 63 40 168 20 174 40 253 99 88 50 93 57 46 77 42 38 230 44 152 237 96 246 158 174 127 80 223 21 171 208 218 64 83 60 6 39 178 161 246 16 149 28 35 238 182 210 44 48 166 87 16 17 60 128 20 135 242 84 199 79 197 192 216 159 45 88 172 97 28 155 254 95 247 229 19 84 119 64 208 127 23 119 239 50 27 133 55 86 37 222 63 40 63 237 92 219 43 139 185 171 144 78 174 41 45 134 33 179 81 222 241 244 47 230 107 206 53 93 206 223 25 220 198 187 145 188 22 208 189 21 158 201 29 156 207 162 236 106 151 65 58 250 220 39 200 228 244 143 101 56 32 72 194 32 92 161 170 95 226 91 247 74 68 91 243 111 13 53 30 159 155 43 194 142 72 76 100 240 231 155 202 2 170 87 103 101 137 13 158 138 204 152 21 128 163 227 158 239 113 74 203 205 138 28 253 172 176 47 237 128 246 167 129 252 181 12 189 44 9 25 249 55 100 198 20 247 11 221 58 43 244 154 235 66 177 195 182 215 227 81 34 233 12 208 171 215 60 228 237 247 68 237 254 101 72 11 189 214 132 0 237 192 83 247 146 44 29 115 128 161 61 99 89 134 224 142 199 58 193 76 75 167 233 190 242 240 211 62 140 149 132 19 231 30 187 11 119 216 16 130 123 220 109 76 105 8 8 51 177 93 127 176 168 236 224 185 239 147 241 252 89 235 117 89 232 240 134 105 5 97 209 251 211 122 163 130 146 101 27 0 163 26 227 99 143 189 100 252 184 92 204 15 249 41 66 137 162 186 236 108 107 110 37 6 27 122 43 43 183 9 177 188 52 107 174 190 52 142 8 234 72 246 140 207 86 16 62 58 111 246 174 164 206 167 225 25 226 156 194 36 44 43 216 74 52 246 175 115 93 50 77 141 193 52 62 121 123 202 32 231 159 172 154 127 94 71 139 59 99 60 95 93 5 219 230 131 152 119 71 166 108 172 186 159 236 122 151 241 89 190 225 248 70 6 59 222 41 63 1 165 51 242 86 140 13 190 182 4 62 76 202 29 142 235 136 247 213 221 89 87 129 198 64 125 243 139 125 99 248 77 77 161 154 149 206 132 228 19 219 21 20 117 100 106 17 25 129 82 47 223 238 149 91 209 180 62 152 199 225 74 120 88 182 193 105 50 55 18 249 249 177 21 79 110 42 239 129 88 200 29 133 34 98 15 45 175 191 221 140 248 216 149 245 89 166 178 80 182 78 190 69 50 222 205 239 161 190 224 7 58 209 212 252 3 217 253 195 183 64 52 49 155 161 91 219 253 14 98 134 170 152 67 190 151 34 0 244 30 29 40 140 166 74 48 227 156 179 126 37 235 250 104 255 27 136 65 183 130 244 43 240 35 123 226 134 15 235 124 3 209 133 214 35 208 2 203 15 238 71 79 163 249 77 38 232 160 127 174 99 90 151 104 248 47 21 102 40 10 75 7 38 213 12 191 187 208 175 51 104 120 67 247 117 94 241 128 200 6 166 210 115 55 169 169 217 14 21 75 98 182 140 181 241 103 66 242 210 58 92 215 100 223 168 223 224 23 185 68 213 123 36 81 24 49 168 209 69 245 79 245 26 172 28 132 233 201 18 122 188 2 206 212 185 33 163 205 123 122 253 31 107 244 225 171 154 126 238 192 76 97 3 130 6 136 89 106 53 55 117 226 25 20 196 35 147 112 210 205 162 106 50 158 32 159 46 222 213 182 51 197 240 80 51 244 161 110 150 205 10 210 29 211 191 134 8 62 165 173 11 212 161 149 21 59 192 148 10 206 136 162 153 70 254 239 231 184 38 59 63 15 77 159 36 158 37 220 110 219 185 101 189 130 102 113 59 89 8 251 111 16 111 199 206 9 183 37 71 67 15 254 146 122 128 22 246 172 83 255 83 89 0 246 254 92 199 238 49 177 50 56 60 7 47 70 50 98 209 93 12 210 64 75 186 162 82 59 16 42 28 252 150 217 13 179 131 109 44 168 155 109 124 107 172 34 39 56 93 136 156 226 51 195 139 240 86 22 205 163 244 246 122 13 115 134 172 202 203 8 83 178 251 160 6 219 89 67 181 18 209 214 63 231 59 24 227 158 23 7 240 58 71 177 7 113 158 183 64 244 85 7 107 227 60 68 82 254 89 181 121 244 154 127 239 164 100 253 201 24 40 247 95 2 117 74 39 105 8 93 65 60 200 39 164 174 113 104 28 234 29 2 248 240 139 89 240 62 145 199 95 144 239 95 112 133 161 248 7 69 77 160 179 10 214 118 130 47 36 196 113 185 107 12 184 128 166 184 156 240 64 39 22 137 148 42 166 209 186 106 148 29 222 181 182 12 140 98 107 232 202 192 126 214 67 12 90 3 7 248 95 36 76 59 188 66 63 98 47 55 72 103 196 189 55 155 89 36 43 7 171 26 228 14 129 26 180 143 57 83 243 131 55 10 86 141 23 182 84 53 42 118 71 72 221 140 17 103 43 14 243 168 38 236 161 104 222 196 131 99 100 2 95 182 238 89 158 129 168 152 135 33 197 190 201 123 56 211 17 219 71 63 164 17 28 210 229 135 70 215 21 37 111 40 118 238 71 231 185 92 225 238 138 15 196 191 125 76 175 41 229 73 155 45 56 91 234 166 249 104 4 179 127 38 179 30 101 157 148 54 199 109 249 21 239 65 56 118 173 182 77 172 225 67 185 168 180 146 85 179 50 125 131 216 129 42 197 47 124 221 171 199 98 155 4 245 181 64 165 225 148 159 88 65 126 225 27 188 72 65 126 66 80 88 14 250 23 35 36 212 224 92 173 32 66 193 212 120 244 150 156 45 75 143 253 186 160 103 148 110 138 210 209 163 125 11 126 208 172 225 255 129 97 133 7 117 173 34 14 198 74 241 119 114 179 69 78 241 172 212 89 124 91 120 8 205 235 82 98 142 194 32 245 179 201 44 162 110 214 68 254 158 4 147 19 254 191 118 156 232 12 254 184 209 40 217 121 173 182 158 0 168 203 19 227 183 248 42 166 119 134 20 184 72 174 2 197 58 133 29 213 233 74 101 1 85 71 25 150 55 32 225 207 234 168 1 132 48 188 104 84 53 145 212 222 88 12 164 128 218 29 207 78 77 249 16 88 28 232 164 142 192 159 5 8 135 38 217 75 132 1 169 131 180 254 194 85 160 186 146 180 24 82 91 133 163 169 12 134 152 70 138 133 74 186 173 245 88 137 116 233 235 3 118 28 107 126 133 54 54 53 235 170 9 149 65 194 190 72 136 43 247 87 106 245 14 28 216 174 131 61 75 2 32 48 18 90 42 185 42 139 107 94 143 236 239 204 214 131 5 194 198 84 239 253 129 60 182 156 134 15 194 224 152 87 64 148 238 6 49 222 188 124 178 199 34 127 212 174 139 147 19 174 19 177 25 35 173 239 20 162 133 142 35 21 226 49 117 215 117 82 150 137 206 32 224 106 132 88 229 130 225 121 252 199 118 93 193 14 161 171 76 13 36 30 78 89 226 51 243 117 178 220 71 194 253 155 147 117 169 112 214 170 151 80 176 47 113 137 200 71 128 223 66 205 149 141 14 174 254 215 224 212 209 129 71 42 114 80 117 179 6 107 207 86 126 92 5 186 201 125 182 1 242 50 66 210 232 200 192 245 137 242 31 142 235 147 161 97 3 161 124 80 122 86 211 86 19 222 78 188 48 94 226 5 28 139 115 71 189 71 214 76 63 3 208 118 242 103 42 218 166 31 193 172 90 1 221 207 45 41 132 69 109 253 53 20 18 46 39 129 112 108 97 15 218 100 16 0 87 235 39 246 68 156 112 218 135 240 49 235 29 171 113 255 41 197 77 237 159 181 64 19 122 215 56 164 218 187 2 68 137 251 240 202 132 181 223 81 212 100 47 233 101 78 16 141 85 48 151 108 6 121 86 47 13 210 187 225 178 157 228 22 177 139 131 77 189 136 67 214 106 21 35 156 24 206 241 20 160 172 42 105 163 82 42 95 198 28 128 214 182 183 18 226 9 84 238 73 67 7 6 79 149 143 81 6 165 26 204 217 230 127 245 25 64 156 2 31 40 230 31 152 83 16 27 19 48 88 183 13 234 44 214 230 142 115 130 245 184 253 244 91 188 169 175 129 42 172 27 94 36 204 250 103 164 187 225 237 171 117 127 191 201 200 10 17 53 9 251 134 12 155 134 192 93 150 96 13 18 25 200 160 243 9 207 137 253 198 235 76 86 159 204 94 141 69 7 244 119 142 65 54 80 199 204 199 217 168 184 53 128 33 0 165 165 165 165 1 0 0 59 0 16 181 174 127 194 181 175 1 132 0 0 28 169 0 0 43 74 0 0 0 0 0 11 142 68 0 0 2 170 0 0 1 124 0 0 0 0 15 0 83 113 117 101 97 107 65 112 112 46 114 0 1 36 38 84 69 88 84 67 87 73 69 1 0 3 192 0 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 105 0 0 0 0 15 0 66 193 212 165 47 158 101 198 187 5 232 62 137 252 56 69 246 56 206 7 115 110 186 70 46 70 112 68 98 27 12 96 93 177 126 138 205 129 15 225 200 70 141 184 144 238 51 187 21 2 100 253 33 237 17 99 201 74 232 168 36 57 93 93 223 103 146 181 14 19 20 203 255 77 196 6 172 46 213 244 253 180 118 156 135 21 216 169 140 101 119 170 86 133 3 176 82 146 129 56 164 43 198 114 16 66 193 212 157 170 210 35 52 27 93 136 197 106 52 54 31 166 122 205 231 32 32 112 160 40 138 126 3 77 99 4 251 242 199 125 87 169 103 99 226 123 60 70 128 113 18 28 85 6 189 121 109 31 26 249 161 83 169 157 62 74 239 8 51 45 186 94 58 49 252 46 209 169 153 202 106 248 205 178 15 4 139 59 160 209 168 125 168 73 48 103 120 110 199 109 171 159 179 239 33 94 118 136 247 133 234 179 177 46 218 151 77 116 44 159 93 94 44 99 70 93 125 137 53 84 131 32 59 239 13 28 34 65 92 91 104 119 79 119 174 134 219 228 67 30 37 182 200 207 220 0 237 187 20 146 233 200 152 182 39 167 14 242 53 180 240 195 154 154 94 91 182 52 134 249 136 119 67 194 147 228 97 60 211 48 22 65 190 202 99 103 114 208 10 131 161 3 87 31 64 250 4 254 133 169 217 77 183 225 106 142 240 240 180 146 248 39 192 170 88 102 69 95 13 89 148 174 206 78 162 131 133 161 167 150 32 158 248 178 173 101 227 217 102 143 206 171 62 75 41 237 239 9 58 126 14 226 107 122 250 208 40 209 10 252 105 101 26 155 10 18 126 136 104 210 186 8 64 134 82 245 212 110 151 241 61 69 16 181 128 165 251 123 137 63 121 161 161 183 56 176 164 4 136 161 23 48 88 225 129 48 129 37 151 67 233 215 152 90 89 82 27 227 240 224 102 238 138 80 14 201 181 17 19 136 193 127 207 108 171 212 101 238 237 175 10 248 251 8 248 107 203 87 203 119 235 140 103 161 208 168 170 55 199 88 185 214 52 170 233 214 179 94 170 196 230 181 174 40 0 165 165 165 165 1 0 0 68 0 0 181 174 119 219 181 183 37 82 0 0 40 248 0 0 43 246 0 0 0 0 0 20 128 249 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 67 97 114 98 111 110 65 112 112 46 114 115 114 99 0 1 224 122 114 115 114 99 82 83 69 68 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 56 0 0 0 54 0 0 0 0 15 0 66 193 212 120 70 64 63 99 16 59 255 97 202 132 145 70 204 255 242 147 131 117 178 216 188 111 47 148 73 157 252 231 185 213 153 225 248 22 106 46 220 74 229 99 130 75 44 98 229 175 219 67 79 64 165 165 165 165 1 0 0 62 0 0 181 174 119 219 182 181 222 19 0 0 43 74 0 0 57 140 0 0 0 0 0 14 144 83 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 65 112 112 46 114 115 114 99 0 1 110 44 114 115 114 99 82 83 69 68 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 40 111 0 0 13 38 0 0 0 0 15 0 66 193 213 19 32 207 221 161 198 69 165 49 49 163 44 68 182 220 208 98 3 104 90 104 50 121 149 179 221 229 227 218 24 177 155 55 76 59 170 223 31 186 42 107 230 227 232 78 210 112 78 144 78 101 153 20 100 21 113 34 86 121 4 82 215 232 227 236 158 8 177 190 230 223 83 84 237 148 7 170 219 251 49 107 209 121 95 19 142 221 245 229 208 93 102 171 66 93 51 91 15 192 115 41 146 47 38 44 128 149 206 19 73 214 243 63 134 185 162 63 190 209 118 46 232 38 160 233 103 92 179 67 170 147 238 96 5 178 108 31 198 142 27 71 0 252 18 157 84 217 115 240 55 138 8 134 100 181 201 91 154 43 221 56 198 203 54 203 223 246 78 211 75 62 202 147 101 108 145 98 255 87 81 19 116 84 105 20 53 35 186 106 250 114 137 91 30 167 101 76 166 46 241 174 167 210 92 15 66 47 106 89 111 95 216 169 157 97 204 203 175 67 131 100 228 115 101 202 102 201 85 197 128 102 224 152 248 208 22 182 13 65 185 43 236 146 8 103 164 68 199 167 90 161 44 115 100 75 148 212 133 205 185 240 91 254 62 54 53 239 150 84 98 211 70 114 120 183 103 103 115 93 178 126 224 111 251 255 187 2 190 193 166 28 139 27 108 150 55 252 38 95 40 204 61 107 175 207 110 195 169 32 120 204 107 253 57 197 232 114 108 33 166 115 221 202 25 154 147 237 211 246 212 49 74 55 186 91 190 105 219 116 226 226 36 175 193 108 174 164 118 229 107 74 31 1 243 123 184 154 227 118 219 112 165 164 185 116 70 7 186 27 160 3 238 43 56 239 52 158 217 130 219 45 109 54 78 222 17 74 25 52 114 1 227 42 217 72 253 223 216 56 77 220 203 181 240 246 160 86 241 58 137 154 1 231 100 197 96 17 176 142 199 47 194 252 250 110 162 91 79 145 135 5 163 208 132 42 60 79 75 147 68 55 152 119 214 213 47 14 150 27 193 38 43 165 127 127 75 132 242 209 231 232 90 64 116 45 168 194 225 211 19 208 32 57 244 252 94 120 52 175 230 215 78 241 93 119 194 210 157 180 253 119 241 7 213 75 242 2 157 31 49 39 20 118 10 91 175 196 156 140 234 100 50 42 96 137 208 103 228 4 225 22 74 130 9 205 18 214 147 75 49 187 43 227 152 76 179 172 183 117 13 251 110 75 224 79 217 217 214 227 177 150 96 91 183 106 137 241 0 235 38 172 39 184 9 195 11 116 2 112 250 7 141 126 202 122 7 182 180 100 247 29 140 118 221 194 141 156 254 197 57 27 154 80 4 218 198 134 36 58 37 182 11 191 30 48 96 99 49 71 11 247 48 134 26 75 23 248 169 148 192 232 136 52 190 9 106 180 116 177 13 29 70 152 222 130 64 89 126 27 36 195 52 68 129 99 185 158 76 202 155 145 145 96 197 229 234 10 34 12 222 208 145 197 41 18 66 206 87 174 41 75 241 145 156 36 214 28 80 128 64 122 182 236 168 100 34 205 66 23 47 104 44 153 163 250 100 6 68 188 208 49 136 156 155 115 13 32 5 138 145 156 36 6 11 221 40 154 194 218 29 1 109 133 109 254 242 28 147 241 20 50 193 90 176 112 117 224 60 208 178 120 233 217 18 74 197 232 110 76 29 180 175 66 70 8 220 11 123 121 138 85 17 22 34 148 136 193 221 117 101 205 217 109 4 10 10 65 66 68 175 123 154 170 174 199 231 184 25 226 33 154 114 79 3 153 4 0 62 134 60 239 236 226 75 31 214 96 45 220 244 237 230 8 76 0 192 141 154 200 74 225 104 207 176 208 254 250 148 25 227 146 222 226 151 193 235 210 96 88 215 249 244 107 255 115 54 241 227 92 32 255 77 149 152 114 54 145 39 240 163 57 73 53 63 143 39 125 158 82 161 237 101 170 95 128 10 235 248 70 177 214 75 129 238 125 85 57 178 142 204 242 173 222 166 98 187 187 125 211 154 80 113 197 20 119 9 146 96 99 144 22 242 112 129 170 244 42 101 206 190 197 244 148 115 57 69 51 241 102 26 83 232 148 216 207 165 246 140 155 19 43 229 194 125 119 141 162 77 52 142 110 231 121 214 216 184 130 187 147 208 75 162 216 177 142 105 114 229 13 169 48 19 158 91 11 206 150 59 115 132 12 211 120 8 46 229 28 205 130 70 224 95 83 157 228 170 120 15 162 167 8 172 104 162 98 182 2 181 178 136 95 82 215 162 125 149 208 59 68 162 221 58 71 225 223 67 148 159 164 179 10 179 177 104 82 55 41 75 67 52 44 34 117 214 229 137 25 60 228 94 30 99 244 23 15 202 222 234 31 234 59 231 206 96 121 127 225 208 104 214 84 199 99 171 165 242 165 120 144 122 192 140 77 43 15 174 36 17 147 218 164 245 199 228 104 241 162 91 96 135 12 227 181 183 235 13 242 224 136 136 129 245 176 206 165 165 64 110 66 168 139 8 90 142 102 70 6 153 68 241 74 56 65 117 191 164 16 94 234 52 20 187 70 233 98 140 204 87 193 52 225 33 209 80 151 207 85 183 118 135 239 187 57 14 120 196 217 215 127 8 90 51 234 66 89 75 57 250 9 195 159 178 218 116 61 172 116 127 224 132 77 251 99 238 201 235 43 13 217 243 205 250 118 218 254 191 31 26 242 230 159 112 122 39 80 186 185 233 65 160 60 101 136 95 12 221 4 127 253 231 143 215 152 41 27 30 142 228 95 129 33 192 222 173 189 95 223 146 175 190 41 125 152 1 45 128 119 18 116 190 190 44 118 65 45 147 21 181 9 155 71 227 71 248 192 239 115 51 239 104 153 241 158 102 3 46 25 185 30 8 115 118 246 221 139 33 155 210 149 201 252 253 176 49 97 209 41 147 191 203 176 234 255 208 254 79 100 22 115 82 241 185 32 150 244 141 155 124 177 152 147 127 220 211 34 8 186 96 219 246 136 12 97 75 135 153 232 112 3 188 100 93 127 66 188 204 80 146 107 142 255 233 218 135 85 177 253 166 64 34 137 121 69 35 181 183 176 217 87 208 228 115 147 72 32 199 221 66 201 187 105 143 245 222 217 229 119 32 11 134 27 154 14 181 166 205 66 79 133 83 86 225 4 176 89 108 235 215 24 61 153 165 28 118 133 206 221 90 25 36 7 220 188 170 197 250 251 220 236 10 80 113 224 124 174 72 49 141 125 102 25 239 130 252 66 142 134 26 164 191 89 81 255 171 92 2 215 221 17 152 120 127 239 71 129 106 118 190 90 37 122 93 52 34 195 12 195 72 43 248 190 233 185 183 16 53 30 82 120 130 25 178 57 183 21 19 54 38 171 240 10 128 55 43 130 139 47 232 253 202 88 207 45 105 231 20 141 143 241 164 3 184 128 21 61 17 76 181 214 2 34 126 92 154 124 231 24 121 54 158 234 108 112 36 4 103 162 128 27 154 3 203 92 71 156 198 202 3 49 226 189 13 2 58 178 113 118 34 75 75 146 6 233 37 21 24 65 215 167 26 70 150 217 193 195 252 191 90 248 253 61 186 181 78 230 14 109 147 205 111 64 40 252 206 41 138 26 134 72 77 38 232 118 90 30 41 58 25 53 79 119 161 189 4 237 31 60 195 185 176 34 208 231 29 122 62 39 252 111 120 220 41 90 83 72 179 170 171 37 25 190 53 116 80 108 76 153 189 103 122 66 86 179 214 90 106 210 59 105 222 15 107 72 236 103 116 52 30 221 147 57 240 254 104 101 238 177 9 63 134 100 198 114 190 121 21 147 144 201 113 70 103 26 142 13 77 95 181 176 20 100 195 216 4 192 169 1 112 129 118 1 121 22 146 75 160 90 63 5 52 5 35 186 175 209 158 209 104 200 154 72 95 19 46 40 224 125 120 206 32 137 236 162 68 113 228 97 186 230 97 12 19 225 22 232 194 152 204 67 19 157 127 185 212 139 53 182 66 6 144 98 244 8 244 74 179 209 151 239 21 211 255 205 150 137 46 154 43 224 119 181 7 33 254 194 153 191 9 145 248 63 219 250 148 231 60 138 6 31 117 167 143 224 50 0 59 27 2 57 70 111 6 234 242 251 115 236 210 233 117 77 122 123 193 160 6 242 220 68 231 15 252 208 28 26 14 235 11 96 135 50 62 50 203 205 8 62 188 225 34 102 68 115 46 130 218 132 10 172 164 110 210 177 94 40 153 48 13 175 83 103 5 23 104 114 21 4 131 178 52 6 58 29 98 139 131 65 5 96 106 119 68 204 118 5 56 14 65 132 126 111 96 201 62 71 69 138 29 182 220 122 158 155 200 171 115 41 176 87 13 30 175 170 38 151 166 187 61 31 231 50 99 93 50 216 201 138 193 145 249 254 205 187 222 126 137 188 174 83 108 99 66 110 101 78 5 6 233 117 126 191 97 18 34 148 67 33 23 54 150 81 99 105 97 83 186 248 44 75 248 155 70 227 83 68 223 175 44 163 195 88 54 97 60 8 10 2 91 71 97 16 174 51 161 123 80 53 252 155 136 98 77 238 7 11 195 38 78 151 3 128 90 74 103 211 31 95 140 124 135 68 244 84 128 148 204 43 191 87 17 8 116 61 248 193 146 164 169 200 140 249 63 208 143 62 215 217 94 91 76 233 72 89 35 173 169 152 110 79 22 178 33 213 146 191 43 123 91 133 9 85 206 233 135 198 212 43 120 105 76 174 227 3 106 58 39 236 7 111 204 119 245 204 124 6 50 162 243 142 2 220 121 197 136 193 16 32 99 251 21 149 240 205 110 161 188 236 100 6 9 6 227 208 39 5 170 161 54 167 251 146 229 233 138 141 216 126 171 144 176 146 79 123 239 117 174 170 228 172 217 132 204 105 7 205 150 34 124 94 250 6 113 146 163 102 189 196 105 111 26 21 192 57 52 10 131 62 40 183 106 226 216 23 24 255 236 121 171 149 110 53 212 178 128 91 105 136 188 52 207 34 80 124 97 98 145 89 10 9 13 37 80 3 106 223 21 232 73 185 249 233 139 215 241 23 113 162 99 238 99 130 183 79 90 132 85 197 105 245 144 112 12 126 135 140 185 16 146 32 69 21 253 109 197 84 137 106 105 252 38 250 183 145 114 218 17 59 173 58 27 52 116 197 53 219 74 147 249 217 0 138 34 112 37 43 98 66 5 241 3 225 248 238 67 99 216 85 235 220 24 89 34 204 182 113 174 240 159 198 39 239 74 247 34 185 9 169 158 236 249 56 203 206 52 239 24 24 198 185 112 114 242 96 141 104 118 246 173 207 219 49 74 28 91 121 90 48 160 43 239 157 7 237 38 95 95 102 146 200 101 170 162 218 248 52 202 159 239 30 77 43 84 148 175 173 59 126 153 168 8 63 87 151 114 31 103 162 99 124 101 51 197 114 207 48 205 32 130 107 167 234 174 145 166 109 160 64 25 36 199 29 62 102 217 27 250 43 56 155 142 158 230 33 184 51 83 137 157 117 158 63 60 171 210 244 173 157 102 173 76 64 104 74 248 116 37 161 130 249 62 243 23 176 210 95 2 19 243 208 167 10 252 99 246 92 201 112 255 98 64 227 83 121 234 133 111 222 175 104 204 22 162 154 50 197 30 131 163 127 185 160 78 98 43 19 156 120 20 100 153 99 90 171 12 19 83 131 117 247 22 162 74 16 192 183 237 4 88 186 70 144 216 14 29 84 85 164 177 38 171 209 72 154 42 209 195 215 134 180 175 246 109 72 138 47 68 204 157 150 171 207 209 161 137 19 178 28 65 45 243 151 168 151 18 114 234 75 181 209 155 152 117 17 106 137 171 54 27 215 60 53 249 96 171 65 228 157 108 77 151 60 139 252 199 183 229 246 250 178 85 199 128 15 245 151 60 107 178 217 217 201 191 10 245 102 125 105 86 65 232 163 153 78 111 221 25 31 109 8 187 206 123 15 62 163 128 113 39 249 43 210 124 81 146 108 205 222 60 3 112 43 120 176 157 164 82 127 125 103 128 116 191 140 233 33 51 19 208 17 195 56 244 3 47 197 111 193 0 234 140 59 226 202 112 247 166 118 171 57 181 209 39 4 138 170 124 30 15 249 15 47 179 146 5 131 241 96 31 117 148 188 54 102 34 195 224 6 31 207 207 159 231 122 235 149 115 13 136 36 171 65 114 189 172 67 195 217 215 234 246 24 192 30 237 203 65 189 241 85 229 18 198 135 202 134 176 41 243 12 62 104 189 154 63 65 204 155 111 123 149 22 224 137 49 46 175 145 10 188 36 239 29 209 242 2 234 76 235 212 187 225 32 99 230 189 249 167 203 16 235 143 72 81 240 131 165 118 17 91 196 184 31 72 77 90 23 9 128 88 252 160 94 27 155 53 225 235 11 199 246 225 84 210 127 196 45 131 95 91 115 238 143 129 151 176 109 45 206 249 133 0 75 175 110 120 200 165 243 78 193 1 22 113 187 115 221 180 251 77 124 173 1 108 148 75 163 216 106 27 31 152 43 68 58 45 0 118 129 51 215 116 30 222 159 96 141 239 188 104 73 163 173 126 90 189 113 65 153 237 192 161 181 237 196 87 137 165 106 58 153 32 157 59 215 233 45 40 219 249 75 33 21 16 42 133 215 255 99 184 130 104 49 64 204 103 178 166 139 119 10 122 141 1 0 16 138 28 63 118 125 16 200 65 190 71 168 30 242 209 91 66 28 53 214 170 36 102 84 157 226 16 185 156 136 194 141 207 155 11 153 167 19 223 105 23 59 226 182 171 178 252 199 56 108 170 104 43 61 2 234 73 29 7 157 94 106 188 78 188 209 93 31 248 253 130 184 47 160 223 187 240 118 67 176 185 67 144 215 49 44 29 90 48 8 39 255 94 49 228 174 96 203 63 20 188 40 168 9 12 145 100 93 0 149 110 35 170 45 220 77 119 207 130 74 195 241 2 125 126 22 104 11 42 111 12 110 101 35 88 200 218 2 22 182 173 9 132 240 234 179 1 14 192 189 121 151 255 162 182 118 88 252 83 149 77 168 192 59 182 100 85 165 188 170 104 167 130 131 197 144 198 239 231 220 232 28 136 138 12 193 209 171 190 243 138 212 191 195 10 173 93 25 236 1 244 12 124 157 32 38 243 229 162 205 154 74 126 64 145 113 145 166 142 39 140 94 6 130 50 102 171 10 238 67 151 243 5 95 252 78 208 60 212 1 204 99 84 59 127 210 163 254 129 165 108 244 147 229 117 18 154 123 4 241 49 246 204 210 121 93 221 138 99 239 180 151 192 17 94 122 221 190 34 94 77 214 232 70 108 106 185 0 114 25 189 119 7 234 111 123 92 171 0 209 193 145 116 134 221 204 44 217 119 138 3 152 15 59 55 112 60 2 202 97 134 181 14 84 12 166 21 76 87 255 78 190 120 24 242 218 87 220 242 197 187 208 94 228 236 59 111 31 14 25 55 30 146 175 74 254 60 181 113 56 77 150 1 125 56 20 176 12 64 165 165 165 165 1 0 0 68 0 0 180 207 51 128 182 181 222 33 0 0 43 246 0 0 59 144 0 0 0 0 0 20 52 110 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 114 115 114 99 0 1 254 72 114 115 114 99 82 83 69 68 1 0 4 0 0 129 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 255 0 0 1 142 0 0 0 0 15 0 66 193 212 190 116 19 225 40 139 5 15 124 31 121 65 93 191 123 136 162 116 53 92 1 197 135 82 6 245 120 174 219 1 70 16 90 193 224 123 209 27 81 145 247 226 208 172 53 145 77 4 43 45 38 172 37 50 85 219 49 69 124 31 56 50 227 91 86 106 252 66 58 198 109 167 189 105 176 165 246 141 12 92 161 87 74 179 89 217 29 1 2 115 221 66 144 116 50 211 176 7 129 85 209 108 135 224 48 252 181 201 109 103 82 159 145 129 57 217 239 78 190 169 131 80 77 42 57 127 117 104 178 251 59 50 180 16 129 100 197 169 12 177 132 49 171 94 212 56 84 221 228 120 170 17 144 211 192 0 168 178 162 133 150 48 225 69 174 12 140 63 48 109 207 204 111 242 102 215 3 115 49 143 93 227 109 96 233 39 19 138 181 78 119 88 80 179 104 52 97 7 160 234 71 180 176 40 175 188 17 97 140 124 59 209 227 0 26 127 240 130 141 241 138 58 255 174 241 161 60 78 178 50 72 5 12 229 217 23 167 106 164 140 14 164 80 122 173 208 123 59 170 145 176 114 87 157 161 206 154 1 233 111 111 6 35 109 107 26 85 1 255 200 2 197 252 196 136 196 219 62 104 62 59 29 96 127 213 223 221 96 36 62 73 133 154 163 251 182 12 71 44 122 244 105 153 132 197 191 34 56 128 5 136 158 40 49 173 64 161 209 3 138 72 46 164 84 9 255 29 108 89 251 240 103 85 91 82 170 199 61 189 109 120 32 137 53 64 123 219 49 66 36 221 73 35 69 152 174 174 129 2 117 56 179 113 113 179 155 218 109 139 224 57 253 246 194 221 134 62 144 20 18 1 35 76 134 122 169 51 115 128 106 188 17 70 222 112 165 165 165 165 1 0 0 62 0 16 182 181 229 175 182 181 229 175 0 0 57 140 0 0 0 0 0 0 0 0 0 14 10 208 0 12 205 109 0 0 49 117 0 0 0 0 15 0 83 113 117 101 97 107 80 114 111 53 46 120 109 108 0 0 99 190 84 69 88 84 67 87 73 69 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 66 193 212 188 248 62 52 173 136 218 110 164 104 187 92 91 33 229 57 30 159 225 15 247 45 53 143 52 125 46 13 154 130 10 230 178 102 160 91 146 16 50 214 205 70 222 253 170 0 72 88 17 78 253 0 105 238 116 244 182 142 220 218 37 123 87 194 186 132 82 163 213 44 217 96 188 30 253 95 96 99 167 32 86 123 110 200 19 93 170 172 122 234 223 63 140 152 225 206 155 57 162 146 49 252 251 195 90 8 194 135 47 232 49 146 95 44 182 237 181 226 227 229 71 130 99 246 134 247 70 193 119 164 112 64 251 238 85 208 179 167 25 227 185 214 249 187 50 83 97 248 88 3 253 235 132 3 250 115 74 26 119 182 254 169 242 84 239 220 27 86 35 114 45 88 60 151 76 80 185 174 132 226 233 195 224 116 152 160 189 135 204 150 14 69 225 48 231 118 165 14 108 222 175 19 189 101 118 116 139 103 148 215 48 9 249 205 228 191 116 142 188 160 65 177 14 100 63 198 86 64 162 185 98 191 36 174 255 235 72 190 251 59 12 160 18 3 27 160 139 233 195 97 24 78 181 254 225 248 126 216 179 190 97 199 152 168 53 204 97 15 127 87 94 89 28 217 229 126 251 166 159 45 78 118 175 144 197 38 10 146 116 152 216 37 27 23 152 187 161 10 131 233 73 247 225 127 151 187 128 216 186 183 19 190 143 225 69 175 142 155 32 167 233 233 30 153 213 135 184 168 22 9 111 94 155 31 99 157 132 162 127 64 221 118 134 198 182 111 251 96 50 26 5 18 87 136 230 146 88 44 163 245 122 194 228 142 243 9 8 202 136 224 69 191 227 245 157 101 179 15 156 18 58 139 134 144 82 147 244 241 183 125 75 187 126 128 111 28 130 86 215 243 9 198 58 56 153 216 179 94 161 67 112 33 81 16 145 3 114 102 90 145 51 86 227 45 170 249 20 41 16 108 249 51 241 40 30 80 113 149 1 10 250 219 71 140 128 255 92 177 225 61 175 185 207 188 175 104 87 170 186 136 229 66 16 90 162 77 186 226 183 246 34 138 152 20 236 248 107 117 130 141 67 221 150 198 29 78 42 133 210 107 196 194 69 2 132 4 236 246 58 56 30 198 228 114 171 184 27 180 26 214 125 21 82 118 99 141 69 18 221 215 55 141 147 226 45 116 52 182 70 14 76 237 157 22 151 157 198 218 153 93 73 74 126 250 228 32 78 118 78 189 33 123 109 61 226 48 163 191 92 105 60 187 154 220 224 182 127 101 106 249 233 178 191 162 121 188 201 13 253 105 239 173 32 34 246 109 131 69 86 38 170 131 212 45 118 11 102 35 101 5 88 85 21 106 116 18 10 52 100 241 54 228 249 205 243 170 132 74 156 155 39 253 50 119 245 200 170 51 179 228 30 90 240 33 127 83 245 167 119 78 206 225 200 26 211 239 40 114 134 156 221 103 250 232 140 58 7 98 83 121 134 175 169 19 237 155 125 17 177 174 226 2 68 62 125 142 160 60 138 115 232 13 75 8 49 147 231 149 46 112 100 79 158 230 128 205 57 0 19 132 133 0 140 44 86 252 148 214 35 114 106 55 208 240 32 46 183 15 126 218 213 50 16 23 57 123 10 99 111 247 234 250 88 81 138 47 167 206 41 92 140 52 251 160 34 143 162 239 204 234 125 56 47 182 198 169 102 239 76 73 221 254 212 10 111 57 244 111 36 108 122 175 142 58 123 17 131 125 180 177 70 29 171 92 34 171 115 126 170 21 72 37 91 220 44 120 250 242 55 149 230 127 55 52 153 137 164 32 242 152 84 229 191 216 251 63 58 104 110 135 87 211 21 129 12 21 218 30 177 1 41 111 219 17 13 65 250 219 251 176 175 195 187 111 119 241 158 120 233 14 36 47 166 6 90 92 135 97 231 38 94 189 250 59 101 42 167 212 208 54 128 181 25 156 75 66 114 212 159 106 94 60 105 104 130 127 157 243 16 51 67 205 96 112 108 221 197 196 22 16 75 33 224 2 116 185 50 250 188 110 126 183 7 84 59 226 223 220 220 210 51 138 206 222 8 12 234 215 53 252 81 143 101 96 29 246 2 84 215 69 149 233 102 182 45 151 115 156 183 198 42 161 56 141 105 203 139 58 15 250 24 248 16 2 89 106 187 149 80 119 92 255 244 218 100 239 96 32 215 101 53 34 187 176 165 192 243 6 164 149 98 76 223 16 208 174 161 153 169 233 124 154 191 91 152 170 251 31 156 129 61 11 212 136 144 200 91 230 193 145 12 223 98 70 41 103 18 233 111 118 63 148 106 29 140 25 242 100 142 86 109 79 158 116 194 3 119 219 216 101 27 120 216 43 101 28 226 7 112 74 224 32 97 38 132 148 241 234 239 183 196 239 155 225 46 100 78 66 47 94 22 38 4 218 17 31 138 236 167 124 225 115 123 0 9 169 211 111 102 38 41 161 191 161 110 194 95 138 47 56 205 45 118 249 207 237 194 178 87 104 214 80 8 118 133 167 198 45 247 167 238 79 56 70 113 247 231 6 31 214 213 112 118 30 82 36 8 244 103 185 118 64 161 155 224 90 193 209 188 83 49 199 96 26 79 21 83 18 225 160 144 185 182 115 226 152 172 33 86 180 168 49 9 131 223 86 179 209 244 7 245 49 75 225 24 211 172 50 76 245 248 183 77 192 196 8 64 248 91 198 195 94 72 132 191 82 118 35 61 30 168 1 234 91 58 157 247 227 243 1 117 240 103 109 245 32 182 70 107 135 34 43 174 230 190 121 239 186 71 142 65 244 163 111 248 19 28 228 62 173 42 68 52 242 51 3 195 140 237 117 75 59 99 135 189 170 123 142 116 51 122 171 206 105 95 87 47 244 91 109 86 194 62 117 248 244 72 176 159 83 231 131 202 68 187 183 133 119 93 23 153 143 236 245 3 212 68 130 63 69 74 205 146 216 61 120 249 152 195 51 80 212 178 136 174 119 153 200 77 37 145 221 15 227 130 6 247 209 95 9 13 28 48 181 34 48 33 246 41 82 74 165 219 86 134 223 59 78 148 35 105 194 27 65 51 0 120 236 49 57 106 0 60 8 159 219 3 57 33 154 148 137 93 162 190 199 85 19 247 135 23 251 242 43 45 190 104 122 152 98 162 67 81 176 216 200 91 115 20 183 120 240 96 77 117 187 141 77 248 6 83 126 162 219 192 83 36 134 252 161 114 82 76 12 32 24 26 190 127 92 51 65 54 165 160 142 47 10 116 102 153 6 102 111 46 208 103 251 196 114 189 44 87 7 119 78 131 169 21 199 179 67 195 78 201 250 25 235 145 198 124 70 47 6 162 97 101 111 227 230 100 115 36 30 123 122 219 81 95 222 186 213 121 151 141 235 234 133 238 18 46 18 123 55 14 170 62 52 160 121 174 127 255 5 146 143 174 186 192 220 232 163 142 161 195 248 202 163 213 163 233 119 110 208 122 242 59 18 66 197 95 10 81 204 234 53 48 101 59 111 70 207 142 49 97 78 37 114 250 203 234 231 227 240 61 253 190 98 249 45 224 225 61 138 246 24 164 196 85 196 197 162 35 226 134 122 238 3 69 184 42 165 152 159 131 168 198 136 178 71 239 225 137 197 94 21 172 42 120 123 46 241 125 162 69 71 66 240 71 49 5 23 233 114 192 87 239 97 162 192 235 108 103 204 169 132 142 115 107 66 99 191 154 112 99 120 63 197 150 230 117 106 225 61 123 95 26 36 116 152 190 113 66 104 98 223 152 154 223 226 121 46 145 99 184 194 141 114 209 130 47 215 174 201 149 235 181 67 219 221 149 114 44 21 230 31 21 242 213 231 178 178 238 178 105 209 239 235 32 5 123 16 116 6 119 186 174 254 103 70 202 20 142 224 83 99 142 254 251 187 89 217 251 30 93 69 136 52 76 112 155 199 183 141 251 169 218 147 227 37 26 88 98 112 137 29 163 31 224 199 224 133 193 143 245 159 246 252 62 15 125 110 85 206 110 238 117 253 102 240 30 90 53 83 199 32 240 80 67 139 30 145 221 118 50 10 216 54 181 160 68 26 0 83 67 78 55 65 94 250 190 204 135 32 153 140 135 80 190 53 195 116 34 46 156 237 248 205 252 168 117 207 125 92 126 228 84 25 204 196 219 231 106 19 131 165 42 94 45 100 44 49 61 55 35 201 22 14 128 222 152 48 85 2 23 80 233 243 212 205 173 76 160 242 197 235 199 13 94 40 232 91 33 235 6 6 28 11 64 19 16 49 102 19 132 48 233 193 196 186 136 216 75 168 216 93 193 185 241 134 80 3 87 139 244 25 37 183 90 116 87 84 221 1 90 20 111 124 149 33 241 183 25 146 97 42 70 171 56 11 134 5 255 240 167 164 82 11 72 100 122 116 28 254 24 77 35 23 137 139 249 70 80 182 30 169 223 152 140 193 226 84 189 8 19 179 188 178 39 8 168 225 137 209 173 188 162 192 56 117 199 182 137 132 204 177 192 199 140 10 137 97 98 116 88 206 242 152 3 86 150 208 30 72 244 3 162 39 75 152 95 50 127 248 149 90 239 160 25 153 69 6 113 166 44 231 89 118 255 159 47 34 179 83 191 14 231 131 136 251 126 106 104 29 116 170 46 227 135 217 129 179 235 170 22 5 173 85 251 132 51 206 151 73 232 246 48 87 63 213 149 208 155 238 206 23 14 216 133 202 143 46 184 167 185 43 243 139 32 170 124 20 162 225 147 64 124 120 166 128 87 62 34 27 211 174 23 168 175 194 172 180 62 20 227 209 188 24 105 219 49 58 6 123 243 185 246 46 55 85 60 90 120 82 135 91 215 147 211 172 189 216 109 154 36 96 215 50 211 118 159 112 183 233 30 130 161 101 131 22 104 62 62 46 229 229 68 154 161 72 248 10 67 254 171 130 23 50 55 26 37 74 15 51 242 100 187 55 194 243 58 15 32 248 177 116 145 140 179 95 82 183 238 118 196 230 48 238 208 222 208 15 181 216 11 228 205 25 202 189 48 242 76 154 36 127 16 171 77 60 146 87 191 224 218 229 20 249 17 185 222 20 64 219 108 156 230 167 119 186 244 140 255 48 28 30 93 54 99 60 242 59 226 29 179 239 172 48 75 116 193 199 212 215 161 210 221 200 236 238 202 81 111 172 65 150 183 41 21 178 16 56 222 191 200 213 186 64 177 26 201 253 209 82 103 246 42 82 99 200 225 124 220 215 211 173 65 101 181 143 126 195 244 126 163 34 132 126 94 3 126 222 26 164 2 23 87 234 163 213 250 12 49 33 85 253 91 214 204 175 24 0 182 55 44 168 217 50 116 9 254 87 188 124 30 243 47 83 196 156 120 151 143 125 236 188 250 97 99 51 71 182 16 4 135 175 1 35 225 63 49 55 124 255 211 153 28 177 54 102 109 128 232 33 220 181 79 12 194 84 239 49 104 251 25 35 53 28 89 226 199 238 34 124 205 192 177 135 47 175 9 76 246 178 102 59 251 212 123 15 213 166 125 103 100 139 81 245 14 91 232 91 35 93 244 21 13 117 85 49 204 185 131 193 250 75 53 45 36 144 83 69 199 28 11 159 103 132 28 126 234 156 52 37 160 79 247 180 209 130 51 154 21 177 111 91 0 125 145 218 132 224 218 34 89 124 83 255 146 181 12 214 185 132 89 156 166 93 197 241 246 51 166 95 168 211 58 16 47 165 133 58 156 37 148 235 104 18 21 98 170 123 183 103 177 58 175 164 157 77 179 199 57 51 141 48 121 102 51 22 69 193 188 195 106 100 209 121 135 236 41 147 67 187 22 204 120 76 23 233 130 219 198 200 194 223 249 96 82 212 20 186 188 130 206 60 101 205 193 111 109 15 1 168 178 252 136 131 232 175 31 56 245 125 121 171 20 122 193 116 185 34 107 203 5 167 196 155 135 183 132 220 94 118 186 19 242 208 164 95 73 247 149 94 148 58 223 132 78 175 50 15 138 241 76 253 196 211 104 156 135 131 143 23 199 45 184 90 22 183 75 51 102 126 107 172 44 159 162 159 242 145 93 231 107 66 222 27 108 111 162 200 68 14 9 250 56 0 109 78 143 107 134 122 184 132 206 180 163 102 96 149 20 218 28 43 1 152 163 159 95 117 145 200 197 169 9 150 254 173 52 47 120 45 152 52 97 185 192 217 109 75 147 23 250 68 87 176 29 42 212 204 153 119 55 246 134 243 28 17 32 105 223 95 191 237 156 169 231 221 73 245 232 245 90 10 210 133 159 254 191 169 142 181 237 228 69 20 176 37 182 67 214 42 78 212 62 99 198 168 130 34 164 8 79 195 93 90 175 134 92 1 71 140 226 213 196 14 111 242 77 32 143 32 84 192 42 152 151 33 70 178 116 20 164 144 92 137 207 12 185 49 173 23 19 76 232 191 198 94 223 76 0 122 110 182 226 28 87 78 69 156 38 239 3 158 9 35 173 45 117 97 211 64 99 112 24 30 17 102 185 78 20 31 64 215 114 86 157 162 34 62 83 77 52 107 138 211 238 191 197 140 46 81 180 104 121 105 245 89 207 101 52 130 225 219 212 159 91 200 125 160 202 172 240 114 1 122 46 232 219 77 130 25 247 142 138 228 75 234 244 114 61 29 76 252 255 46 132 185 49 206 191 10 207 95 123 56 190 86 253 168 116 147 134 174 225 95 35 43 67 38 35 224 105 49 21 231 235 166 198 107 73 2 229 233 148 122 131 186 130 171 25 6 100 93 204 231 194 54 66 172 155 44 208 197 82 63 164 8 159 109 247 223 132 93 88 103 37 245 109 223 254 94 37 41 41 53 234 233 186 176 178 213 167 199 89 220 107 11 72 148 117 133 176 11 66 76 85 105 103 182 107 214 90 58 47 11 213 112 23 121 169 91 5 100 50 85 7 207 47 25 3 0 222 32 86 15 47 96 72 46 120 202 34 2 23 242 144 240 240 61 233 44 248 145 40 28 163 181 128 107 229 102 25 117 145 117 79 93 184 58 220 143 142 195 247 140 24 41 150 255 218 139 35 55 150 181 137 144 82 219 155 44 25 137 20 70 207 198 100 85 11 28 8 48 209 158 64 31 243 67 39 86 12 106 29 15 58 150 123 192 63 248 242 194 145 189 110 40 34 154 67 231 65 224 185 75 115 204 80 34 74 7 196 241 40 114 79 249 34 38 71 46 130 242 192 101 120 38 159 107 179 95 210 227 7 201 184 235 212 132 116 209 226 163 69 33 141 101 99 162 206 76 216 4 178 147 230 11 129 249 249 231 58 39 42 135 226 51 187 126 190 105 181 158 12 37 241 153 210 31 109 166 238 153 78 238 158 47 134 211 227 220 24 17 221 251 210 191 220 159 117 223 27 54 123 12 145 54 71 82 42 15 52 50 49 98 219 210 72 101 56 139 57 6 135 193 45 54 37 36 16 76 97 43 181 140 159 54 173 2 230 170 8 103 226 18 33 239 155 3 113 148 201 64 206 63 114 127 196 164 192 132 182 3 236 239 220 5 73 193 96 147 244 210 66 22 203 170 31 58 35 40 182 132 52 242 79 233 254 227 118 180 8 53 131 95 34 87 14 39 93 160 12 155 191 45 171 46 54 140 80 126 79 177 77 129 49 139 191 119 160 104 130 244 192 244 35 110 252 225 120 146 42 183 34 114 14 131 42 44 5 113 132 186 234 247 56 40 213 28 169 61 236 71 212 141 92 127 37 139 159 59 210 229 133 183 38 191 143 89 102 123 130 90 70 139 170 85 110 99 59 28 123 156 65 254 46 216 220 19 171 94 41 200 230 225 223 157 210 53 117 187 7 231 18 112 142 106 206 143 64 122 59 133 194 114 6 251 199 217 83 146 156 144 174 80 109 86 90 244 240 118 9 199 19 161 90 64 228 174 37 125 139 111 215 90 79 135 136 202 80 90 202 216 15 177 177 63 237 51 99 56 237 76 19 178 39 179 39 58 44 134 191 9 169 92 244 50 222 165 79 54 105 140 47 77 44 162 81 132 214 166 60 240 26 15 2 77 53 246 76 122 188 191 147 89 131 6 32 98 134 165 84 160 195 211 185 133 95 104 65 0 31 132 33 243 238 231 136 70 229 77 121 203 0 113 219 248 169 47 233 223 141 244 66 211 254 226 85 98 162 235 178 209 170 100 131 62 64 90 87 233 229 98 69 115 146 78 4 189 17 99 174 121 153 243 161 149 203 17 101 213 124 174 5 220 221 212 75 181 40 105 74 227 109 77 151 187 50 80 96 156 162 132 60 221 5 230 128 155 46 164 61 113 123 193 219 127 17 17 9 46 110 90 163 129 67 27 68 62 101 93 73 123 146 21 81 155 52 233 55 28 130 241 143 171 72 112 87 0 245 121 39 235 29 241 236 115 139 176 193 157 89 196 183 175 42 19 226 41 231 129 159 164 46 117 251 143 191 172 221 95 219 60 171 35 251 185 8 142 238 184 176 214 88 64 198 85 91 38 176 195 203 181 70 215 255 127 10 55 193 95 230 178 19 23 217 227 31 247 211 29 25 98 209 17 96 66 249 171 126 33 91 96 144 67 17 21 198 122 11 53 115 214 182 93 236 8 42 254 115 40 55 52 57 179 21 184 231 240 121 103 60 126 228 28 62 225 85 87 8 135 150 180 155 140 250 49 88 122 199 35 23 27 143 212 87 133 210 145 112 36 160 49 101 145 70 178 9 45 122 157 106 214 133 174 171 88 52 3 141 219 110 238 170 165 143 128 94 21 61 149 13 160 144 38 179 55 19 237 71 111 114 10 179 108 86 19 36 226 231 247 166 82 97 194 142 84 115 211 186 206 8 135 13 249 76 8 160 51 61 171 7 165 101 134 53 106 126 130 183 233 54 150 52 223 50 134 234 162 157 189 251 84 201 238 155 228 94 22 145 226 60 41 50 159 113 191 233 186 217 1 229 135 125 110 210 98 102 178 124 40 33 229 148 198 190 207 192 143 43 201 114 216 145 64 103 204 134 87 133 165 80 101 131 213 120 5 4 61 251 97 20 76 51 255 200 63 44 33 7 37 94 197 240 234 69 240 113 22 222 93 43 255 117 38 25 222 245 254 254 217 190 235 162 79 148 182 106 67 93 184 232 186 138 159 179 188 172 119 96 205 126 189 249 128 246 34 164 217 2 109 27 61 78 25 107 205 214 55 206 209 146 133 194 189 198 175 253 57 112 194 180 196 74 107 86 104 126 107 183 139 212 23 164 234 33 244 252 192 241 114 107 197 219 1 35 120 194 192 113 129 72 178 136 240 161 158 42 115 128 43 185 94 221 33 50 129 96 57 64 74 34 32 94 109 30 224 197 211 165 206 59 212 3 194 83 253 7 181 8 218 243 35 83 182 225 141 52 99 197 54 93 163 70 92 29 121 245 168 110 80 208 219 123 215 149 230 210 66 45 219 210 231 22 149 29 51 59 170 173 19 138 167 103 7 118 50 126 10 212 146 91 188 11 137 162 118 173 178 25 47 220 85 147 53 97 92 248 91 105 221 143 5 185 197 156 214 110 91 220 112 68 225 131 244 26 9 111 227 194 102 251 35 131 177 148 5 173 190 61 254 155 182 97 235 47 77 199 3 133 100 119 231 152 134 142 146 170 200 121 35 247 67 237 254 21 158 6 37 142 92 98 147 150 119 217 47 134 66 69 56 121 167 54 126 130 226 3 222 70 145 209 82 150 180 68 149 61 204 181 173 244 188 207 117 3 162 37 90 69 49 151 128 34 185 228 106 105 60 246 229 118 224 173 135 199 166 241 239 96 108 31 214 165 124 71 66 187 29 178 126 124 120 12 84 78 229 211 35 166 133 224 17 251 25 91 59 45 64 77 48 157 84 249 200 217 69 73 162 212 238 147 154 190 211 237 160 159 88 166 138 62 115 228 53 124 106 86 80 137 242 26 5 104 169 105 88 28 139 147 22 183 207 13 240 89 191 234 49 44 228 197 54 46 187 134 169 169 177 43 34 239 107 204 16 99 236 14 14 178 12 234 92 162 241 191 125 249 141 105 211 117 134 162 40 199 34 68 200 179 24 55 40 204 166 80 92 17 245 77 194 15 66 159 129 187 224 193 251 32 55 194 219 185 66 152 0 8 4 243 86 29 107 124 199 152 172 192 227 85 218 192 225 33 241 83 154 65 241 211 245 27 29 247 115 210 140 200 203 220 121 127 12 18 180 52 5 205 163 194 31 237 1 87 117 187 50 102 25 39 143 151 59 43 31 236 229 100 119 160 223 29 159 185 38 86 245 232 74 140 93 93 81 216 209 194 198 155 171 20 180 81 202 88 215 121 169 127 65 163 6 47 61 96 28 101 226 150 47 195 201 238 93 119 24 28 42 66 92 192 133 221 90 96 13 162 233 210 184 137 109 170 72 211 182 127 239 153 98 12 108 32 60 77 89 106 248 16 183 122 120 209 162 40 146 168 58 114 27 214 183 216 22 215 231 144 193 99 153 174 84 208 103 25 23 194 233 238 188 117 201 194 204 179 169 70 169 194 33 97 193 241 57 117 136 93 9 25 79 81 185 10 93 155 237 26 137 181 31 127 123 24 132 163 219 137 223 125 103 225 174 102 47 192 229 119 130 26 204 28 200 101 78 105 212 101 111 232 29 35 55 143 144 153 23 24 94 242 31 67 85 67 187 201 94 54 168 92 88 63 249 17 110 15 23 99 7 218 31 57 178 230 57 100 168 181 222 200 148 254 35 251 23 228 48 230 109 10 127 193 229 21 44 178 92 65 60 193 233 131 172 102 172 125 11 125 43 207 162 168 147 65 91 237 91 253 104 16 82 124 211 4 79 33 204 78 246 86 229 146 246 235 181 124 223 255 71 13 149 12 81 172 64 115 119 228 36 156 126 86 152 141 225 130 82 79 178 187 139 206 229 0 157 211 248 90 109 98 178 68 103 168 218 16 60 36 18 243 6 67 132 46 79 187 45 99 142 181 195 78 221 71 104 43 132 142 17 150 132 124 9 113 219 220 157 122 16 244 63 164 194 59 161 0 231 246 200 36 178 205 233 31 167 182 234 185 9 127 233 245 112 109 97 31 218 154 218 31 196 56 238 222 206 141 202 153 202 201 250 128 164 241 17 106 37 99 93 225 46 90 198 188 28 177 114 183 85 44 48 170 50 229 206 56 101 8 3 50 50 10 8 194 238 117 229 56 113 71 60 174 226 63 226 45 252 143 8 247 218 204 54 92 181 92 202 111 219 175 90 195 158 170 96 149 183 107 60 135 91 113 233 46 115 19 75 143 208 177 209 210 100 32 174 224 53 93 249 37 164 166 138 59 247 234 39 211 184 56 36 40 13 221 178 104 29 103 140 215 255 143 156 104 65 0 17 220 97 11 239 201 170 193 222 10 127 101 132 22 77 226 14 18 172 170 169 45 158 134 181 186 120 146 86 190 52 52 27 91 182 12 83 233 145 66 74 120 198 104 250 164 175 97 77 162 187 81 217 10 96 42 94 87 5 74 152 10 234 68 172 14 226 156 157 180 114 68 142 126 234 214 158 42 203 247 14 189 22 166 200 144 73 53 58 56 146 97 150 66 219 241 78 150 13 87 208 70 200 153 208 189 199 58 22 151 162 40 231 15 194 122 138 41 65 84 124 50 246 202 45 83 180 61 44 219 236 73 3 134 68 191 46 146 123 131 110 15 210 21 245 108 40 213 139 11 113 49 104 42 112 155 4 158 77 188 129 81 160 85 160 80 185 231 221 237 189 180 63 72 154 250 115 61 229 54 96 174 150 138 18 53 208 92 10 168 121 240 71 44 150 211 196 116 249 74 174 9 58 16 94 32 102 213 183 64 21 223 237 194 98 251 194 97 60 19 185 161 248 253 243 157 147 208 13 209 11 229 94 235 11 97 84 12 190 106 234 184 163 58 25 79 132 33 148 66 65 174 43 137 236 96 169 117 197 135 212 80 167 20 168 63 174 3 61 56 206 53 62 140 133 41 135 203 250 54 21 125 226 239 135 128 82 214 25 139 150 199 15 253 184 97 85 61 25 122 155 26 222 204 70 52 78 58 219 207 250 14 135 178 102 125 77 98 87 71 250 103 188 81 59 6 224 229 4 231 164 100 61 213 165 21 97 69 27 99 205 114 252 172 115 195 128 34 106 114 55 122 207 209 43 155 66 225 84 194 153 34 15 125 253 78 9 224 152 60 119 41 223 107 104 13 85 177 28 144 26 149 79 21 247 9 8 16 74 56 127 206 194 137 66 247 45 86 218 132 120 63 111 54 230 238 181 235 18 243 80 70 176 216 70 215 62 40 74 53 96 35 102 76 85 205 75 205 91 65 206 232 204 93 244 169 69 170 107 98 57 142 9 171 46 89 145 210 93 51 202 62 86 50 181 98 35 156 137 205 42 3 156 205 220 2 9 83 38 48 147 23 152 213 78 230 108 106 18 63 208 55 15 27 55 136 156 154 192 249 91 254 5 174 41 255 128 206 51 75 152 174 3 18 82 250 187 50 41 135 38 107 107 125 166 14 120 190 4 150 23 192 229 22 66 179 42 151 235 86 217 60 140 132 105 163 125 9 231 171 44 216 43 64 41 87 169 136 104 101 214 234 65 193 164 119 227 5 7 27 104 40 95 50 6 199 150 59 219 151 154 153 17 118 190 160 40 156 214 168 0 234 197 85 15 227 193 104 106 39 197 8 111 147 160 188 243 82 162 86 220 96 40 211 249 176 196 175 173 189 72 180 86 195 242 215 209 102 43 77 93 229 235 29 211 42 144 205 74 74 67 75 96 30 109 155 98 211 185 86 149 253 219 136 7 94 143 142 177 162 164 218 120 197 105 105 51 247 107 106 174 87 131 152 210 216 140 11 45 171 130 137 118 20 162 167 104 53 103 193 179 196 150 138 101 240 235 167 20 182 89 135 77 23 18 116 16 96 235 111 5 80 174 163 118 206 210 205 122 122 67 94 224 76 209 113 252 206 66 38 172 203 206 73 146 174 20 226 119 3 172 194 109 60 223 38 81 235 247 26 249 166 189 20 229 107 165 116 219 135 39 9 196 19 147 140 201 157 122 132 66 112 165 18 94 86 226 192 234 131 250 232 251 53 149 207 148 80 53 2 243 170 73 181 122 201 180 21 6 173 112 14 215 215 40 207 237 216 170 121 50 204 19 115 213 115 251 161 197 190 124 54 105 18 243 48 199 161 25 29 83 152 176 222 254 192 12 151 101 195 165 181 195 53 84 247 77 121 122 68 20 190 140 217 246 199 195 80 46 135 245 179 118 40 152 141 219 76 192 248 161 68 241 229 160 120 87 145 118 76 46 44 89 69 161 10 240 6 88 147 204 197 185 99 57 205 114 158 243 60 163 47 147 57 236 173 238 103 188 7 193 143 229 148 228 26 227 57 54 101 167 132 144 173 158 132 232 94 15 63 241 191 93 4 39 29 89 225 50 194 114 31 139 46 238 222 116 170 215 216 5 184 170 31 163 70 56 186 234 141 3 201 201 96 189 106 217 82 23 234 245 248 140 224 106 17 211 224 162 218 219 112 198 74 81 35 109 141 111 101 131 248 102 194 148 150 105 114 157 220 156 97 139 174 49 21 50 148 52 144 29 6 93 26 232 253 78 83 75 155 143 123 33 1 63 152 136 223 87 138 186 150 140 57 211 89 106 105 220 58 182 222 115 174 139 162 52 186 126 43 161 46 10 100 4 241 164 77 82 216 4 116 213 195 62 74 123 97 255 126 192 105 225 57 57 131 147 208 124 149 73 184 96 107 176 200 12 230 200 118 41 109 179 100 146 82 121 80 236 189 209 68 219 102 6 81 252 251 168 29 159 179 194 196 90 20 8 31 224 226 165 111 139 102 119 160 148 112 44 214 73 117 135 202 217 128 66 186 229 45 184 12 191 217 153 252 94 211 145 81 3 101 243 103 238 255 35 249 149 126 231 199 85 212 242 135 60 177 68 105 55 189 155 225 174 97 169 43 208 109 226 101 89 86 42 222 123 168 255 95 18 95 124 20 231 209 49 66 205 142 106 240 227 10 42 69 71 35 89 210 148 32 58 255 104 127 189 181 94 228 163 5 104 7 109 26 4 223 60 248 120 125 254 10 115 177 70 100 150 65 208 197 38 174 182 40 176 102 133 44 79 28 122 110 88 122 184 86 46 42 203 116 104 5 42 89 177 231 152 247 116 145 81 118 246 102 33 9 200 43 157 173 66 206 41 18 153 205 59 107 14 195 203 69 9 58 252 20 163 217 145 88 243 237 126 118 105 63 82 221 177 190 247 119 123 206 45 118 44 140 111 41 221 37 99 63 33 181 89 26 225 158 42 13 254 190 204 192 163 148 163 197 152 184 206 243 144 127 126 193 215 246 98 170 253 176 43 184 50 144 40 142 215 180 6 231 29 116 127 31 39 249 168 32 194 173 96 100 207 218 209 15 169 196 147 94 144 249 135 48 165 112 249 206 165 99 195 231 127 41 109 203 80 251 1 45 172 90 38 48 33 106 11 175 142 97 211 201 242 75 211 41 212 91 121 117 103 249 154 198 228 50 186 34 22 57 216 253 84 69 123 191 97 23 28 20 12 51 6 219 14 200 71 173 55 86 94 35 242 75 120 198 48 179 24 137 98 149 31 23 35 204 10 4 112 149 36 74 229 41 94 125 168 142 6 152 23 220 190 109 199 232 251 193 93 236 189 69 142 240 186 130 108 253 188 207 174 61 224 205 224 123 225 221 50 61 75 122 154 175 229 202 102 194 239 199 221 140 160 205 151 198 12 4 88 57 19 198 79 181 226 27 85 195 110 47 176 211 222 36 234 29 25 146 159 194 31 211 168 199 207 176 35 144 239 18 226 38 108 157 126 138 98 45 230 6 191 19 160 29 165 177 92 154 81 200 25 26 182 184 133 113 18 36 71 102 89 247 250 3 34 45 9 83 92 24 194 167 151 214 237 161 51 47 38 113 90 135 37 117 160 147 63 186 153 110 119 238 221 163 155 153 79 202 173 2 180 74 206 143 247 56 83 62 172 234 254 126 136 167 219 110 63 185 102 230 67 248 110 50 103 120 34 44 34 35 226 138 34 137 248 18 243 10 214 158 78 115 40 79 16 45 11 106 159 42 226 135 184 248 31 49 197 168 171 140 8 254 118 222 245 232 5 121 87 160 243 78 167 180 201 233 160 63 210 29 129 87 78 154 247 254 13 123 38 144 97 27 215 76 13 159 101 22 217 65 141 188 177 107 229 252 6 61 101 104 135 253 94 25 63 225 132 43 200 7 238 42 239 185 222 74 26 163 174 96 145 172 40 249 33 62 44 130 167 51 137 155 59 173 105 241 67 63 103 69 253 194 121 163 224 142 48 249 149 76 52 120 161 238 19 237 250 38 11 46 191 193 11 11 172 27 155 72 127 202 102 69 180 9 61 88 10 207 87 135 220 55 174 17 71 165 162 197 221 1 0 116 97 4 7 165 15 205 25 68 236 179 230 178 40 54 218 185 88 188 174 199 246 180 129 18 55 211 135 236 122 127 56 169 205 207 4 97 36 182 37 74 146 15 117 166 101 213 131 91 74 78 177 9 0 117 78 199 190 253 127 239 0 64 140 38 178 49 168 128 139 95 246 62 162 200 75 22 170 76 114 147 222 26 7 7 199 121 33 50 102 222 41 144 107 145 37 32 254 238 125 169 82 48 45 185 79 2 159 152 170 159 134 101 83 149 41 192 114 71 191 193 57 219 198 131 136 61 133 137 252 116 99 4 245 238 185 57 169 44 67 145 207 153 213 77 198 6 19 169 75 29 182 82 197 42 149 52 95 135 221 13 183 183 242 154 196 60 166 64 162 153 90 98 135 51 110 34 35 236 122 101 224 228 196 228 29 121 192 226 131 9 50 189 213 251 168 107 60 102 71 39 94 221 167 200 200 214 3 17 95 170 194 183 58 105 229 10 39 244 164 74 131 165 125 33 121 28 117 141 128 46 166 132 149 122 5 110 47 158 30 195 209 169 6 213 77 201 9 128 224 137 215 163 46 200 148 76 146 187 36 169 199 12 18 234 135 157 46 105 210 4 204 108 97 184 197 36 43 99 174 50 209 197 45 203 38 157 120 46 173 113 193 28 21 15 69 234 49 182 82 179 13 168 129 207 181 100 215 225 188 166 123 146 249 186 168 119 10 174 45 14 15 101 197 57 210 17 46 241 20 9 60 196 107 98 65 60 205 31 235 187 132 124 15 143 63 121 4 100 220 229 210 122 215 130 226 12 38 106 177 97 184 109 217 172 77 88 50 116 78 181 36 162 2 238 23 146 94 242 99 156 154 221 147 59 28 107 232 75 113 237 178 60 217 91 48 12 129 55 22 141 7 68 224 146 26 102 249 206 244 102 179 253 221 235 208 100 168 184 192 211 78 144 110 118 96 46 191 202 23 77 55 166 44 188 238 96 41 234 103 254 30 204 209 83 156 143 222 51 249 233 52 136 90 162 137 130 64 251 98 188 247 238 196 108 192 105 48 247 161 214 224 217 72 30 150 178 116 221 94 67 103 136 16 191 230 143 253 71 21 4 204 158 4 136 185 17 106 231 231 203 204 141 178 216 208 157 65 144 171 144 215 84 76 92 199 185 114 4 63 189 222 43 81 58 58 102 234 15 44 150 33 189 65 13 67 64 176 104 181 187 74 207 254 96 157 118 216 146 19 128 218 228 121 25 3 78 148 227 252 107 195 97 248 128 198 129 65 178 149 223 161 250 53 135 130 95 118 245 132 248 128 30 241 210 67 194 72 164 19 253 96 173 67 85 224 250 218 144 113 159 92 88 188 117 189 12 40 94 79 34 225 113 23 95 172 27 64 58 87 39 181 134 222 89 141 106 242 146 67 28 49 15 217 110 202 137 134 184 81 149 57 176 18 141 73 158 246 72 123 102 204 132 77 25 50 199 178 74 84 69 222 84 186 220 8 60 96 244 164 249 245 11 44 90 96 170 204 105 177 28 234 248 147 28 254 239 63 18 104 114 8 114 48 176 102 71 176 93 21 166 50 166 114 206 80 1 177 113 165 177 208 181 135 54 178 167 203 155 78 113 62 23 224 165 31 35 35 221 19 160 49 237 73 111 112 70 220 129 162 240 12 45 49 43 156 43 165 232 62 184 162 156 176 189 73 230 41 91 6 68 119 103 28 144 27 240 229 83 72 154 204 57 161 114 53 119 60 141 129 3 213 214 77 109 104 158 79 27 46 215 189 161 108 150 67 87 214 114 69 119 181 165 213 96 226 142 252 196 74 115 73 239 110 171 84 11 85 89 74 40 127 231 220 11 128 73 41 106 130 193 142 129 208 220 151 38 24 117 196 64 46 50 186 191 67 73 114 129 255 26 129 191 175 134 96 244 63 206 60 173 5 37 104 152 221 189 238 181 231 223 180 13 105 64 4 151 34 35 86 168 208 3 143 70 199 15 100 190 229 3 195 177 2 107 110 86 103 9 77 32 208 254 51 34 250 140 109 232 149 189 237 175 51 114 154 64 101 63 79 103 183 55 3 244 197 16 63 22 45 72 79 65 204 118 198 213 152 95 139 233 15 62 203 245 137 120 160 165 37 178 251 218 35 90 77 42 71 44 236 209 193 69 25 223 227 144 167 38 58 249 94 123 247 64 12 78 119 128 237 237 118 24 2 4 190 212 101 239 45 111 71 218 180 56 117 225 40 93 167 38 183 20 74 239 195 109 8 237 198 158 232 31 234 232 240 150 129 73 73 96 91 211 105 134 67 170 181 241 249 248 139 43 113 87 241 247 33 168 212 179 59 153 66 135 105 134 222 247 109 215 157 35 155 87 82 123 220 226 249 72 68 234 198 113 231 23 104 31 118 253 211 22 234 222 43 40 249 62 195 241 232 254 90 84 91 137 60 116 107 202 141 219 191 169 102 124 25 20 190 182 66 212 81 26 211 192 113 63 247 72 94 13 7 67 149 30 188 112 38 53 215 66 130 214 79 133 0 81 84 180 66 228 162 122 237 128 31 33 236 155 82 240 198 220 148 144 212 5 235 129 3 21 176 221 22 36 79 91 142 8 52 134 72 3 104 220 173 246 184 77 39 147 116 7 241 253 136 227 177 241 26 60 86 16 65 30 142 212 199 30 86 128 8 231 233 219 12 217 148 153 112 146 81 109 161 20 191 208 192 62 3 96 220 96 225 77 45 131 43 245 92 196 33 107 157 95 175 112 222 47 166 241 91 98 216 163 213 72 149 57 197 195 68 36 245 189 1 121 76 133 128 239 103 210 109 135 40 8 100 162 213 89 31 91 19 116 246 12 173 83 250 191 195 133 192 201 27 194 131 208 117 233 143 22 216 189 161 39 184 38 22 50 99 208 22 65 39 183 27 25 84 60 173 104 166 252 96 139 164 20 118 250 204 234 91 62 179 158 33 244 57 52 159 36 24 48 206 140 172 157 188 82 78 55 1 146 56 217 196 103 230 38 162 194 126 168 84 106 111 220 42 227 180 210 203 79 72 124 47 107 90 14 139 166 107 216 87 124 212 83 32 246 181 69 75 119 111 203 52 115 16 210 13 1 42 143 123 15 93 59 149 220 253 171 3 21 155 35 110 211 41 241 208 131 136 126 30 119 250 66 251 219 226 142 51 157 146 40 54 22 197 212 227 134 170 169 30 170 57 20 160 95 141 135 209 152 93 195 170 156 163 175 16 191 79 143 118 68 254 187 214 189 55 104 174 60 223 84 72 216 115 155 126 170 68 4 227 52 134 44 68 136 2 98 117 81 228 49 222 26 105 19 65 48 70 9 220 195 118 74 31 160 68 185 122 202 9 155 13 162 104 187 148 117 165 2 88 116 233 218 42 94 212 149 222 169 189 208 245 172 199 79 120 248 197 233 176 250 177 19 98 51 211 188 127 221 7 106 112 42 139 94 59 134 188 232 147 139 36 13 235 80 133 163 217 37 139 81 138 56 72 238 200 89 164 172 88 191 27 116 20 74 125 213 208 99 183 94 218 17 57 96 253 110 249 131 101 152 162 198 111 74 132 92 28 30 193 24 1 183 248 33 127 174 97 50 191 236 195 221 173 6 12 109 104 171 14 117 188 178 67 215 31 27 88 226 148 0 119 248 3 173 244 182 136 30 221 180 30 161 193 28 164 28 69 162 23 52 215 148 118 175 128 51 189 2 18 107 142 175 166 216 210 59 132 146 144 22 54 214 161 174 144 155 135 52 145 92 176 147 143 195 77 78 242 136 36 7 222 121 32 210 6 145 150 136 71 98 28 230 248 135 125 157 144 243 243 198 18 15 135 32 244 131 44 109 252 19 203 129 227 216 77 54 46 224 19 214 97 57 175 124 239 65 247 22 234 165 97 9 186 46 181 102 215 2 17 72 7 24 182 50 229 149 121 151 194 156 4 55 41 177 179 170 255 47 75 12 115 32 212 26 179 55 19 218 87 23 176 250 84 158 57 221 107 225 70 133 123 30 135 198 114 120 63 72 21 176 247 40 18 212 25 24 189 205 71 226 127 117 104 151 12 136 108 47 105 190 58 175 7 140 195 252 156 193 104 98 198 5 202 115 186 239 131 168 180 94 197 74 178 87 132 168 237 171 243 177 168 156 91 222 22 15 250 16 62 207 114 200 17 119 91 231 89 232 36 51 160 222 204 13 238 57 196 24 54 202 247 3 119 135 199 174 14 27 98 242 235 243 179 14 65 39 171 5 19 180 243 181 74 54 7 72 193 29 82 161 54 100 126 140 8 91 24 247 231 111 41 245 227 55 117 118 54 141 8 220 52 227 220 214 86 175 184 7 108 225 16 255 111 146 111 56 180 208 242 253 219 94 131 67 132 249 78 85 205 238 4 223 15 66 197 118 18 168 133 238 13 227 136 6 66 55 161 63 154 101 207 119 66 145 235 31 194 243 71 47 34 76 18 197 216 175 211 106 176 96 155 175 166 79 28 246 76 235 5 26 227 212 25 231 199 81 52 186 154 132 29 202 176 67 244 146 65 146 222 103 45 22 21 67 51 74 119 98 181 17 87 191 150 168 181 138 249 172 195 45 22 51 36 129 243 202 86 149 189 168 129 243 36 0 115 239 70 55 95 158 203 226 255 142 211 185 152 226 97 229 83 64 108 186 241 69 234 0 236 112 200 235 50 245 102 193 166 226 3 222 68 34 74 129 222 111 133 96 144 163 0 7 163 115 236 23 151 24 251 23 241 162 161 138 92 79 190 64 132 246 11 196 253 179 112 208 136 172 115 208 162 252 25 163 171 113 172 60 5 74 34 76 57 115 127 130 249 204 160 127 95 187 58 125 197 23 240 217 75 34 38 52 236 100 59 24 111 33 114 163 156 22 250 197 28 54 201 74 7 117 169 163 159 172 18 67 78 67 33 61 48 70 126 223 128 136 128 183 223 46 12 78 164 29 59 33 188 131 120 169 22 66 227 75 55 117 141 204 184 136 26 68 37 206 248 217 8 100 105 200 7 132 21 226 189 98 156 146 202 40 103 162 249 69 20 138 87 29 225 3 75 55 168 194 124 45 41 222 17 125 187 172 27 135 204 84 237 124 62 203 77 72 237 169 224 49 46 187 231 227 78 182 132 242 228 16 226 139 223 52 184 133 151 210 112 19 93 1 23 244 12 137 246 150 184 131 77 204 127 207 86 48 142 77 89 240 6 9 102 26 202 115 139 183 30 29 224 17 107 235 67 114 173 87 75 144 90 98 219 76 133 191 74 228 79 103 185 33 32 127 216 153 21 6 164 12 186 126 81 3 62 31 228 120 108 120 151 55 149 22 158 3 80 100 11 19 251 42 166 0 95 125 253 102 171 129 91 204 149 255 28 139 210 243 84 44 15 129 224 146 177 150 251 19 86 5 232 192 9 208 179 93 233 102 105 8 165 185 113 83 41 57 42 140 167 43 145 21 72 247 183 223 181 24 45 43 134 88 25 153 197 140 68 218 37 225 76 220 146 137 124 178 45 245 29 91 205 232 38 72 204 214 86 186 127 80 226 48 244 98 211 171 213 26 33 250 95 47 67 113 134 249 190 186 136 199 195 70 210 187 163 168 167 29 67 38 100 201 104 64 201 53 82 174 203 76 110 40 60 89 166 80 66 242 17 66 157 127 54 68 62 109 153 85 76 10 227 22 90 112 11 28 164 237 161 26 210 208 203 111 15 238 15 220 70 113 191 187 240 150 150 234 159 47 238 29 16 185 179 206 206 244 90 61 194 14 130 125 30 91 12 58 57 176 143 181 207 64 214 94 127 193 99 203 32 172 171 119 54 136 159 141 241 80 157 147 220 169 119 135 71 214 142 177 60 227 23 34 64 48 135 107 24 205 212 69 225 164 191 80 234 158 34 151 162 192 82 168 69 79 163 36 23 146 160 221 152 69 143 205 87 141 236 159 11 36 72 196 156 95 250 148 186 177 131 31 234 183 130 61 143 35 202 24 135 84 187 203 93 170 134 12 15 237 30 171 155 140 44 150 91 234 175 120 144 88 11 72 57 198 95 241 54 70 152 57 233 231 252 221 60 134 240 209 37 105 236 18 182 188 38 35 144 94 140 95 137 71 230 56 16 17 124 129 239 182 92 34 53 37 179 102 145 184 189 36 170 54 24 35 43 123 249 156 54 0 81 2 215 104 22 178 107 182 68 211 47 93 28 214 250 222 244 50 110 215 47 203 136 73 31 38 123 140 77 58 116 44 102 119 45 203 31 241 108 101 11 222 2 47 157 118 251 242 38 47 137 11 7 219 132 12 207 167 81 233 54 19 23 187 234 143 254 2 160 53 117 50 109 177 4 225 160 48 234 127 244 78 220 252 63 205 102 78 249 78 111 133 55 54 41 161 149 169 200 109 144 111 40 235 69 83 46 215 197 2 74 103 57 48 96 155 136 109 201 99 228 69 150 15 253 74 141 253 182 19 96 161 221 251 62 62 178 205 87 109 25 11 64 139 70 184 189 203 192 228 252 213 174 44 158 1 239 35 6 155 134 63 80 160 218 54 62 33 23 128 93 1 148 124 5 164 55 188 86 222 228 221 102 32 208 224 121 124 218 41 141 230 76 118 240 13 19 255 229 11 9 22 188 153 21 38 190 9 80 90 11 148 62 117 231 104 95 228 51 175 233 21 41 111 86 234 159 12 36 76 216 188 203 181 176 247 135 162 67 202 25 12 199 144 226 161 118 87 145 87 183 7 255 97 129 184 170 236 40 21 174 50 2 23 234 85 216 181 235 0 35 169 138 172 139 249 107 40 95 242 64 15 73 57 77 133 50 47 118 169 181 222 247 69 90 3 134 62 197 104 149 10 251 181 241 159 157 18 116 191 224 43 98 126 160 97 104 105 200 14 20 73 150 183 127 76 80 88 189 114 47 196 166 106 129 54 109 122 180 70 80 250 121 200 150 79 231 100 63 147 182 189 53 157 123 44 20 143 221 165 17 255 114 167 23 207 174 180 196 120 173 53 9 139 186 82 209 234 40 8 9 45 61 155 51 244 8 102 206 196 29 160 136 27 182 179 141 230 251 244 75 14 120 212 102 110 82 214 38 247 211 90 140 199 228 140 165 175 212 208 141 234 80 182 224 113 171 66 93 3 187 77 136 240 94 19 209 246 2 35 249 92 238 146 123 254 52 89 72 67 122 179 193 165 49 186 245 178 27 43 47 239 62 141 231 247 203 90 205 69 38 213 104 4 218 131 205 22 255 215 237 167 211 198 68 150 158 50 67 57 241 103 148 24 40 213 149 169 55 183 229 19 188 57 220 124 215 65 125 142 82 235 165 5 243 166 47 151 163 93 203 184 245 162 76 84 146 124 198 239 111 63 117 10 225 102 168 122 187 98 101 177 69 61 151 45 101 171 231 25 83 226 41 16 68 73 212 209 49 224 179 1 3 74 109 127 13 6 31 225 143 156 91 36 4 208 186 76 153 249 212 217 78 130 201 56 255 157 107 155 127 212 232 40 50 62 67 175 30 166 142 205 56 112 112 6 208 248 113 96 132 57 186 233 59 66 123 162 213 121 76 64 49 149 38 100 147 203 33 141 210 181 166 245 76 108 20 108 173 178 161 194 218 125 150 82 101 41 1 157 36 141 52 9 67 116 95 161 54 250 232 26 36 15 233 223 36 68 164 180 87 54 242 90 19 212 24 37 141 225 101 220 143 234 5 58 159 129 90 4 40 24 75 161 246 38 249 177 244 219 211 18 136 119 148 84 209 161 101 179 75 229 219 24 144 184 230 167 153 254 31 242 156 212 51 133 240 45 183 79 50 128 254 190 216 212 120 68 33 5 234 228 16 14 43 238 25 52 248 124 4 101 151 198 59 68 17 173 167 159 158 34 219 63 98 167 233 53 233 233 143 52 52 208 110 183 101 77 139 55 108 244 113 17 181 52 153 175 147 228 147 215 236 105 166 242 126 9 57 131 72 9 134 97 54 175 41 200 120 224 20 182 128 186 125 10 17 15 190 53 151 168 206 13 24 98 160 21 178 225 229 50 142 160 219 220 22 184 143 203 152 248 22 249 198 159 182 208 222 244 149 168 116 180 87 158 176 229 158 239 240 85 205 216 125 62 136 182 146 210 150 71 38 115 187 114 220 42 220 246 77 224 237 190 143 148 218 155 133 34 192 96 82 80 227 180 112 220 62 252 128 64 149 47 228 71 254 139 85 246 77 223 149 87 152 151 46 248 252 67 59 206 221 199 209 63 92 214 233 11 239 90 52 126 217 171 143 90 64 114 249 58 86 33 236 114 168 75 161 90 212 79 148 22 16 74 54 100 104 4 227 26 223 115 117 105 123 131 123 50 73 66 175 171 69 16 46 164 221 160 120 5 152 22 122 72 92 169 248 162 218 84 55 209 125 243 70 251 52 52 201 72 217 173 82 160 20 238 96 229 171 219 56 103 180 233 3 70 14 206 112 117 14 38 110 211 155 101 196 251 154 89 27 105 6 68 132 124 160 237 33 189 18 251 27 211 150 247 34 150 250 88 210 240 217 125 163 213 166 122 51 18 13 207 36 246 125 128 239 124 88 179 6 193 189 42 18 170 75 24 207 96 101 78 36 42 87 183 181 147 1 136 185 0 143 46 138 192 245 228 115 232 22 212 209 6 212 132 174 58 6 30 6 36 115 35 9 122 71 205 131 16 114 230 30 68 153 220 113 93 124 187 47 107 41 128 64 72 253 170 131 22 163 193 131 111 236 91 11 68 187 183 182 81 126 182 161 162 255 65 151 74 13 195 251 32 52 85 214 187 36 180 61 194 141 171 161 129 22 0 196 195 66 15 144 168 80 58 179 153 120 199 153 16 229 42 99 5 10 82 14 241 78 27 0 123 96 224 57 200 9 147 149 133 203 84 172 32 215 21 104 147 251 169 250 142 35 170 130 254 186 250 196 238 198 118 181 229 254 226 206 50 222 192 128 118 128 18 211 204 39 236 112 145 15 228 117 18 162 235 189 217 5 237 134 186 168 249 196 159 233 55 128 193 234 40 34 10 75 207 20 3 227 115 31 162 160 108 93 62 252 167 58 196 163 71 100 1 237 171 68 217 7 131 124 201 237 252 82 127 163 21 169 94 106 11 4 55 104 241 243 217 173 161 60 175 92 93 188 93 208 127 130 94 54 227 97 191 229 97 170 51 89 127 220 205 86 58 135 34 114 183 184 4 49 6 192 191 9 180 60 176 156 227 124 16 254 104 105 131 255 63 136 89 61 188 170 173 167 51 227 32 10 130 255 19 69 19 95 191 155 173 173 132 249 254 229 32 50 237 255 52 203 205 55 100 208 11 36 224 120 229 196 178 213 118 105 123 51 231 50 4 127 135 237 62 66 185 186 122 244 88 184 32 138 169 171 187 224 83 232 88 156 228 147 143 229 78 89 59 95 81 192 106 2 110 242 79 222 79 128 130 89 50 70 11 176 74 177 177 140 147 197 1 195 212 40 205 23 197 40 224 42 222 101 206 211 62 196 108 229 55 31 20 125 190 129 11 41 67 232 87 23 115 20 179 139 157 85 93 122 244 63 84 21 214 71 71 170 23 161 101 253 117 13 56 237 39 214 61 140 182 175 124 123 162 211 183 216 250 178 209 244 34 27 55 117 83 168 92 217 150 188 100 53 172 34 62 161 215 69 162 164 185 233 211 108 97 117 83 58 0 123 140 149 132 200 223 221 13 112 215 77 51 93 177 122 122 160 107 237 167 110 76 129 119 151 14 47 38 202 68 147 52 22 141 210 231 131 109 67 29 0 209 89 97 12 67 241 40 62 23 255 145 39 131 62 249 145 33 116 33 7 28 211 141 12 31 33 24 128 190 17 230 245 163 27 221 26 116 6 171 232 100 218 26 116 236 212 153 148 87 252 31 163 101 76 252 130 41 100 101 144 126 8 77 25 113 149 200 255 31 66 119 153 26 36 206 73 103 193 212 4 98 2 230 101 245 15 181 105 149 227 106 134 238 66 188 175 129 168 124 149 127 148 232 16 220 5 0 94 89 117 93 5 110 24 202 61 245 173 206 159 69 101 79 182 54 196 66 232 156 17 102 82 165 176 84 80 246 6 252 57 146 38 173 37 172 76 161 204 249 145 207 85 186 1 45 64 188 88 53 224 81 158 231 121 119 185 138 248 225 194 49 86 109 202 196 83 107 150 193 58 172 196 188 86 242 24 152 196 178 27 34 129 8 169 157 23 60 141 29 121 33 249 224 139 219 47 230 193 9 74 245 34 119 76 6 94 183 59 55 245 155 176 190 225 86 60 17 71 88 249 104 112 23 197 233 166 14 241 213 111 208 127 25 95 22 182 46 105 17 127 220 146 110 252 116 242 160 229 201 6 186 164 121 173 99 121 230 104 48 180 73 177 29 150 48 142 70 79 254 209 226 121 97 135 183 231 156 189 249 97 48 234 69 9 205 214 159 42 35 80 134 183 111 65 96 132 32 113 61 169 11 253 172 154 110 159 178 82 16 63 199 238 251 15 59 25 102 148 236 38 207 48 9 96 147 167 81 134 183 181 165 235 181 205 132 165 125 192 88 64 36 162 19 207 28 19 147 150 168 254 129 18 245 44 214 31 30 208 25 9 84 253 183 32 200 193 205 100 200 187 134 170 182 58 93 35 238 16 248 58 180 174 230 214 11 63 98 173 53 1 224 133 66 166 175 44 83 73 179 156 14 195 84 128 133 60 51 153 22 198 217 71 59 113 167 228 190 104 205 196 204 24 86 195 12 205 63 121 84 15 40 93 172 82 77 129 250 93 65 13 58 214 151 20 154 186 16 145 222 134 27 143 43 161 47 70 85 118 5 203 103 0 238 195 91 85 98 47 86 21 52 78 83 19 241 202 226 137 181 203 52 222 57 14 62 1 63 40 253 126 94 96 103 121 36 35 47 181 143 231 106 0 200 222 190 29 191 153 107 212 168 58 138 22 75 177 16 167 132 21 221 89 138 191 32 31 176 33 65 202 163 180 155 131 159 110 60 201 3 49 94 7 86 59 118 64 132 1 129 150 93 127 132 207 251 92 133 121 202 124 22 46 199 180 236 133 230 199 203 52 190 5 86 236 188 53 137 7 38 53 215 47 63 139 97 204 63 250 172 191 8 31 92 4 25 214 140 192 32 160 48 33 121 195 83 154 226 162 193 52 199 144 166 126 131 61 84 157 165 198 197 236 16 221 32 46 33 60 218 158 133 173 33 87 183 3 54 138 236 106 231 18 205 106 120 156 62 3 229 191 56 18 30 86 178 184 231 40 113 64 55 184 201 148 253 203 10 66 137 25 33 204 165 217 131 184 116 217 75 129 168 191 77 38 192 246 29 56 31 31 242 41 121 80 2 194 207 138 210 77 140 90 168 151 109 39 28 210 251 103 168 95 242 55 253 186 198 37 154 243 210 183 62 126 53 49 217 50 211 49 72 138 8 45 117 126 98 60 244 197 42 113 123 95 140 189 112 107 72 132 137 119 226 123 242 51 161 233 45 15 16 243 167 120 134 225 184 1 115 129 42 28 174 136 173 159 1 6 27 41 45 164 221 115 126 187 156 206 32 22 171 124 232 12 185 174 120 155 254 162 146 181 244 178 47 242 22 99 113 108 143 101 133 45 42 92 91 55 200 144 12 45 87 68 65 36 156 95 183 247 172 245 17 236 7 160 113 127 218 127 20 6 107 134 223 45 27 165 73 0 83 220 60 244 160 185 143 27 48 210 34 120 29 246 103 187 55 201 249 68 172 139 20 81 158 52 22 14 23 96 44 125 200 149 218 203 29 228 113 175 114 15 121 7 228 183 126 234 212 237 1 35 166 217 231 250 168 230 44 95 85 157 51 115 129 20 123 19 221 200 142 255 121 38 12 83 36 46 78 190 205 23 222 14 244 79 38 45 171 107 236 85 218 77 241 145 172 20 124 163 235 191 199 74 217 138 195 204 81 166 206 241 160 219 203 203 73 7 82 123 189 166 165 16 184 164 88 15 79 121 112 165 251 69 179 212 51 141 10 238 85 251 109 207 4 24 196 154 121 79 57 95 119 187 89 61 212 105 36 185 92 222 46 2 107 64 156 197 240 128 2 59 51 22 225 234 14 168 17 60 161 179 126 186 219 155 120 199 54 171 189 253 169 45 106 250 145 252 184 145 165 232 187 193 106 249 29 255 68 255 115 54 53 7 17 152 4 255 102 251 1 39 77 204 95 165 83 184 163 247 124 22 163 84 255 210 252 40 245 146 27 248 86 156 220 127 158 135 120 143 186 183 21 210 96 21 118 87 251 51 207 180 6 211 187 67 228 82 204 122 20 142 137 67 33 39 112 124 217 112 37 189 38 13 251 132 35 111 231 49 107 242 30 84 92 102 199 47 236 165 111 7 95 60 91 151 233 33 116 208 255 33 58 170 71 159 251 229 78 136 73 203 243 97 94 84 242 143 85 137 72 112 57 197 119 149 250 155 183 196 134 207 171 150 206 117 55 18 186 122 144 107 75 125 197 85 217 204 24 136 122 120 25 53 4 224 58 11 248 49 189 39 18 79 111 78 203 255 210 146 21 64 152 63 73 247 93 9 30 127 138 203 118 183 133 27 8 53 105 162 66 146 59 33 112 135 66 82 100 208 205 93 194 45 176 182 38 178 39 182 199 6 173 41 16 197 30 117 194 192 111 212 93 36 83 67 19 7 179 240 9 13 10 114 101 115 75 17 14 84 55 32 220 140 186 66 35 187 214 131 197 44 33 163 9 86 93 96 139 73 140 110 181 125 56 175 16 77 132 43 241 163 25 228 9 226 74 157 99 250 116 86 188 130 167 53 40 90 155 143 77 148 90 242 35 115 187 55 126 153 231 175 190 137 73 64)! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/18/2001 20:45' prior: 33911911!macDirectoryFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism.  Feb 2nd 2001, JMM rewrote, using more current file manager logic. 3.0.7 return correct response on findimage */#include "sq.h"#include "FilePlugin.h"/* End of adjustments for pluginized VM */#include <Files.h>#include <Strings.h>#ifndef __MPW__#include <path2fss.h>#else#include <Aliases.h>#include <StandardFile.h>#include <Gestalt.h>#endif#include <Navigation.h>/***	The interface to the directory primitive is path based.	That is, the client supplies a Squeak string describing	the path to the directory on every call. To avoid traversing	this path on every call, a cache is maintained of the last	path seen, along with the Mac volume and folder reference	numbers corresponding to that path.***//*** Constants ***/#define ENTRY_FOUND     0#define NO_MORE_ENTRIES 1#define BAD_PATH        2#define DELIMITOR '':''#define MAX_PATH 2000/*** Variables ***/char lastPath[MAX_PATH + 1];int  lastPathValid = false;FSSpec lastSpec;/*** Functions ***/int convertToSqueakTime(int macTime);int equalsLastPath(char *pathString, int pathStringLength);int lookupPath(char *pathString, int pathStringLength, FSSpec *spec,Boolean noDrillDown);int recordPath(char *pathString, int pathStringLength, FSSpec *spec);void makePascalStringFromSqName(char *pathString, int pathStringLength,unsigned char *name);OSErr makeFSSpec(char *pathString, int pathStringLength,FSSpec *spec);OSErr getSpecAndFInfo(char *filename, int filenameSize,FSSpec *spec,FInfo *finderInfo);int fetchFileInfo(CInfoPBRec *pb,int dirIndex,FSSpec *spec,unsigned char *name, Boolean doAlias, Boolean *isFolder);int doItTheHardWay(unsigned char *pathString,FSSpec *spec,CInfoPBRec *pb,Boolean noDrillDown);pascal	OSErr	FSMakeFSSpecCompat(short vRefNum,								   long dirID,								   ConstStr255Param fileName,								   FSSpec *spec);OSErr FSpLocationFromFullPath(short fullPathLength,									 const void *fullPath,									 FSSpec *spec);									 pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath);pascal	OSErr	FSpGetFullPath(const FSSpec *spec,							   short *fullPathLength,							   Handle *fullPath);							   OSErr squeakFindImage(const FSSpecPtr defaultLocationfssPtr,FSSpecPtr documentfsSpec);pascal void findImageEventProc(NavEventCallbackMessage callBackSelector,                         NavCBRecPtr callBackParms,                         NavCallBackUserData callBackUD);pascal Boolean findImageFilterProc(AEDesc* theItem, void* info,                             NavCallBackUserData callBackUD,                            NavFilterModes filterMode);                        						pascal short DialogHook(short item, DialogPtr theDialog, 	void *userData);	OSErr __path2fss(const char * pathName, FSSpecPtr spec){    return lookupPath((char *) pathName, strlen(pathName),spec,true);}									 								 int convertToSqueakTime(int macTime) {	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than Mac one */	return macTime + (3 * 365 * 24 * 60 * 60);}void makePascalStringFromSqName(char *pathString, int pathStringLength,unsigned char *name){	/* copy file name into a Pascal string */		name[0] = pathStringLength;	strncpy((char *)name+1,pathString,pathStringLength);} OSErr makeFSSpec(char *pathString, int pathStringLength,FSSpec *spec){		char name[256];		if (pathStringLength > 255 ) 	    return -1;       strncpy((char *) name,pathString,pathStringLength);    name[pathStringLength] = 0x00;    return __path2fss((char *) name, spec);}int dir_Create(char *pathString, int pathStringLength) {	/* Create a new directory with the given path. By default, this	   directory is created in the current directory. Use	   a full path name such as "MyDisk:Working:New Folder" to	   create folders elsewhere. */    //JMM tests create file in Vm directory, other place, other volume        FSSpec spec;    OSErr  err;    long  createdDirID;        if ((err = makeFSSpec(pathString, pathStringLength,&spec)) == -1)        return false;           	return FSpDirCreate(&spec,smSystemScript,&createdDirID) == noErr;}int dir_Delete(char *pathString, int pathStringLength) {	/* Delete the existing directory with the given path. */    FSSpec spec;    OSErr  err;    if ((err = makeFSSpec(pathString, pathStringLength,&spec)) == -1)        return false;           	return FSpDelete(&spec) == noErr;}int dir_Delimitor(void) {	return DELIMITOR;}int dir_Lookup(char *pathString, int pathStringLength, int index,  /* outputs: */  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile) {	/* Lookup the index-th entry of the directory with the given path, starting	   at the root of the file system. Set the name, name length, creation date,	   creation time, directory flag, and file size (if the entry is a file).	   Return:	0 	if a entry is found at the given index	   			1	if the directory has fewer than index entries	   			2	if the given path has bad syntax or does not reach a directory	*/	int okay;	HVolumeParam volumeParams;	CInfoPBRec dirParams;    FSSpec      spec;    Boolean     isFolder;    OSErr       err;    	/* default return values */	*name             = 0;	*nameLength       = 0;	*creationDate     = 0;	*modificationDate = 0;	*isDirectory      = false;	*sizeIfFile       = 0;	if ((pathStringLength == 0)) {		/* get volume info */		volumeParams.ioNamePtr = (unsigned char *) name;		volumeParams.ioVRefNum = 0;		volumeParams.ioVolIndex = index;		okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;		if (okay) {			CopyPascalStringToC((ConstStr255Param) name,name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(volumeParams.ioVCrDate);			*modificationDate = convertToSqueakTime(volumeParams.ioVLsMod);			*isDirectory      = true;			*sizeIfFile       = 0;			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	} else {		/* get file or directory info */		if (!!equalsLastPath(pathString, pathStringLength)) {			/* lookup and cache the refNum for this path */			err = lookupPath(pathString, pathStringLength, &spec,false);			if (err == noErr) 				recordPath(pathString, pathStringLength, &spec);			else 				return BAD_PATH;		}	    spec = lastSpec;		okay = fetchFileInfo(&dirParams,index,&spec,(unsigned char *) name,true,&isFolder);		if (okay) {			CopyPascalStringToC((ConstStr255Param) name,name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(dirParams.hFileInfo.ioFlCrDat);			*modificationDate = convertToSqueakTime(dirParams.hFileInfo.ioFlMdDat);			if (((dirParams.hFileInfo.ioFlAttrib & kioFlAttribDirMask) !!= 0) || isFolder) {				*isDirectory  = true;				*sizeIfFile   = 0;			} else {				*isDirectory  = false;				*sizeIfFile   = dirParams.hFileInfo.ioFlLgLen;			}			return ENTRY_FOUND;		} else			return NO_MORE_ENTRIES;	}}OSErr getSpecAndFInfo(char *filename, int filenameSize,FSSpec *spec,FInfo *finderInfo) {    OSErr err;        if ((err = makeFSSpec(filename, filenameSize,spec)) !!= noErr)        return err;            if ((err= FSpGetFInfo(spec,finderInfo)) !!= noErr)         return err;            return noErr;}dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Set the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */    FSSpec spec;    FInfo   finderInfo;        if (getSpecAndFInfo(filename,filenameSize,&spec,&finderInfo) !!= noErr)        return false;       	finderInfo.fdType = *((int *) fType);	finderInfo.fdCreator = *((int *) fCreator);	    return FSpSetFInfo(&spec,&finderInfo) == noErr;}dir_GetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Get the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */    FSSpec spec;    FInfo   finderInfo;        if (getSpecAndFInfo(filename,filenameSize,&spec,&finderInfo) !!= noErr)        return false;       	*((int *) fType) = finderInfo.fdType;	*((int *) fCreator) = finderInfo.fdCreator;	return true;}int equalsLastPath(char *pathString, int pathStringLength) {	/* Return true if the lastPath cache is valid and the	   given Squeak string equals it. */	int i, ch;	if (!!lastPathValid ||		(pathStringLength > MAX_PATH)) {			return false;	}	for (i = 0; i < pathStringLength; i++) {		ch = lastPath[i];		if ((ch == 0) || (ch !!= pathString[i])) return false;	}	return lastPath[i] == 0;}/*JMM 2001/02/02 rewrote */int lookupPath(char *pathString, int pathStringLength, FSSpec *spec,Boolean noDrillDown) {	/* Resolve the given path and return the resulting folder or volume	   reference number in *refNumPtr. Return error if the path is bad. */	CInfoPBRec      pb;	Str255          tempName; 	OSErr		    err;    Boolean         ignore;     /* First locate by farily normal methods, with perhaps an alias lookup */    strncpy((char*)tempName,pathString,pathStringLength);    tempName[0] = pathStringLength;    err = FSMakeFSSpecCompat(0,0,tempName,spec);    if (err == noErr) {        if (noDrillDown == false) {            fetchFileInfo(&pb,0,spec,spec->name,true,&ignore);        }        return noErr;    }                      /* Than failed, we might have an alias chain, or other issue so     first setup for directory or file then do it the hard way */        strncpy((char *)tempName,pathString,pathStringLength);    if (noDrillDown) {        tempName[pathStringLength] = 0x00;    }    else {        tempName[pathStringLength] = '':'';        tempName[pathStringLength+1] = 0x00;    }    err = doItTheHardWay(tempName,spec,&pb,noDrillDown);    return err;}/* This method is used to lookup paths, chunk by chunk. It builds specs for each chuck and fetchs the file information, Note the special case when noDrilldown */int doItTheHardWay(unsigned char *pathString,FSSpec *spec,CInfoPBRec *pb,Boolean noDrillDown) {    char *token;    Str255 lookup;    Boolean ignore,firstTime=true;    OSErr   err;        token = strtok((char*) pathString,":");    if (token == 0) return -1;    while (token)     {        if (firstTime) {            strncpy((char*) lookup+1,(char*) token,63);            lookup[0] = strlen(token)+1;            lookup[lookup[0]] = '':'';            firstTime = false;        } else {            strncpy((char*) lookup+2,(char*) token,63);            lookup[0] = strlen(token)+1;            lookup[1] = '':'';        }        if ((err = FSMakeFSSpecCompat(spec->vRefNum,spec->parID, lookup, spec)) !!= noErr)             return err;                fetchFileInfo(pb,0,spec,spec->name,true,&ignore);        token = strtok(NULL,":");     }   if (noDrillDown)        spec->parID = pb->dirInfo.ioDrParID;     return noErr;}/*Get the file ID that unique IDs this file or directory, also resolve any alias if required */int fetchFileInfo(CInfoPBRec *pb,int dirIndex,FSSpec *spec,unsigned char *name,Boolean doAlias,Boolean *isFolder) {    int i;    long    aliasGestaltInfo;         *isFolder = false;    pb->hFileInfo.ioNamePtr = name;	pb->hFileInfo.ioFVersNum = 0;	pb->hFileInfo.ioFDirIndex = dirIndex;	pb->hFileInfo.ioVRefNum = spec->vRefNum;	pb->hFileInfo.ioDirID = spec->parID;	if (PBGetCatInfoSync(pb) == noErr) {		if ((pb->hFileInfo.ioFlFndrInfo.fdFlags & kIsAlias) && doAlias) {		    FSSpec spec2;		    Boolean isAlias;		    OSErr   err;		    		   		   err = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, name,&spec2);#if TARGET_CPU_PPC           if ((Gestalt(gestaltAliasMgrAttr, &aliasGestaltInfo) == noErr) &&                aliasGestaltInfo & (1<<gestaltAliasMgrResolveAliasFileWithMountOptions)  &&                ((Ptr) ResolveAliasFileWithMountFlags !!= (Ptr)kUnresolvedCFragSymbolAddress)) {                err = ResolveAliasFileWithMountFlags(&spec2,false,isFolder,&isAlias,kResolveAliasFileNoUI);            }             else #endif    			err = ResolveAliasFile(&spec2,false,isFolder,&isAlias);    		    			            if (err == noErr) {            	if (dirIndex == 0) {            	    fetchFileInfo(pb,dirIndex,&spec2,spec2.name,false,isFolder);            	    *spec = spec2;            	}        		return true;			}		}        spec->parID = pb->hFileInfo.ioDirID;		return true;	}	return false;}int recordPath(char *pathString, int pathStringLength, FSSpec *spec) {	/* Copy the given Squeak string into the lastPath cache. */	if (pathStringLength > MAX_PATH) {		lastPath[0] = 0; /* set to empty string */		lastPathValid = false;		lastSpec = *spec;		return;	}	strncpy(lastPath,pathString,pathStringLength);	lastPath[pathStringLength] = 0; /* string terminator */	lastPathValid = true;	lastSpec = *spec;}pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath){	OSErr		result;	FSSpec		spec;		*fullPathLength = 0;	*fullPath = NULL;		result = FSMakeFSSpecCompat(vRefNum, dirID, name, &spec);	if ( (result == noErr) || (result == fnfErr) )	{		result = FSpGetFullPath(&spec, fullPathLength, fullPath);	}		return ( result );}pascal	OSErr	FSpGetFullPath(const FSSpec *spec,							   short *fullPathLength,							   Handle *fullPath){	OSErr		result;	OSErr		realResult;	FSSpec		tempSpec;	CInfoPBRec	pb;		*fullPathLength = 0;	*fullPath = NULL;			/* Default to noErr */	realResult = result = noErr;	#if 0//The following code doesn''t seem to work in OS X, the BlockMoveData crashes the// machine, the the FSMakeFSSpecCompat works, so go figure...  KG 4/1/01	/* work around Nav Services "bug" (it returns invalid FSSpecs with empty names) */	if ( spec->name[0] == 0 )	{		result = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, spec->name, &tempSpec);	}	else	{		/* Make a copy of the input FSSpec that can be modified */		BlockMoveData(spec, &tempSpec, sizeof(FSSpec));	}#endif 0	result = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, spec->name, &tempSpec);	if ( result == noErr )	{		if ( tempSpec.parID == fsRtParID )		{			/* The object is a volume */						/* Add a colon to make it a full pathname */			++tempSpec.name[0];			tempSpec.name[tempSpec.name[0]] = '':'';						/* We''re done */			result = PtrToHand(&tempSpec.name[1], fullPath, tempSpec.name[0]);			*fullPathLength = tempSpec.name[0];		}		else		{			/* The object isn''t a volume */						/* Is the object a file or a directory? */			pb.dirInfo.ioNamePtr = tempSpec.name;			pb.dirInfo.ioVRefNum = tempSpec.vRefNum;			pb.dirInfo.ioDrDirID = tempSpec.parID;			pb.dirInfo.ioFDirIndex = 0;			result = PBGetCatInfoSync(&pb);			// Allow file/directory name at end of path to not exist.			realResult = result;			if ( (result == noErr) || (result == fnfErr) )			{				/* if the object is a directory, append a colon so full pathname ends with colon */				if ( (result == noErr) && (pb.hFileInfo.ioFlAttrib & kioFlAttribDirMask) !!= 0 )				{					++tempSpec.name[0];					tempSpec.name[tempSpec.name[0]] = '':'';				}								/* Put the object name in first */				result = PtrToHand(&tempSpec.name[1], fullPath, tempSpec.name[0]);				*fullPathLength = tempSpec.name[0];				if ( result == noErr )				{					/* Get the ancestor directory names */					pb.dirInfo.ioNamePtr = tempSpec.name;					pb.dirInfo.ioVRefNum = tempSpec.vRefNum;					pb.dirInfo.ioDrParID = tempSpec.parID;					do	/* loop until we have an error or find the root directory */					{						pb.dirInfo.ioFDirIndex = -1;						pb.dirInfo.ioDrDirID = pb.dirInfo.ioDrParID;						result = PBGetCatInfoSync(&pb);						if ( result == noErr )						{							/* Append colon to directory name */							++tempSpec.name[0];							tempSpec.name[tempSpec.name[0]] = '':'';														/* Add directory name to beginning of fullPath */							(void) Munger(*fullPath, 0, NULL, 0, &tempSpec.name[1], tempSpec.name[0]);							*fullPathLength += tempSpec.name[0];							result = MemError();						}					} while ( (result == noErr) && (pb.dirInfo.ioDrDirID !!= fsRtDirID) );				}			}		}	}		if ( result == noErr )	{		/* Return the length *////		*fullPathLength = GetHandleSize(*fullPath);		result = realResult;	// return realResult in case it was fnfErr	}	else	{		/* Dispose of the handle and return NULL and zero length */		if ( *fullPath !!= NULL )		{			DisposeHandle(*fullPath);		}		*fullPath = NULL;		*fullPathLength = 0;	}		return ( result );}pascal	OSErr	FSMakeFSSpecCompat(short vRefNum,								   long dirID,								   ConstStr255Param fileName,								   FSSpec *spec){	OSErr	result;		/* Let the file system create the FSSpec if it can since it does the job */	/* much more efficiently than I can. */	result = FSMakeFSSpec(vRefNum, dirID, fileName, spec);	/* Fix a bug in Macintosh PC Exchange''s MakeFSSpec code where 0 is */	/* returned in the parID field when making an FSSpec to the volume''s */	/* root directory by passing a full pathname in MakeFSSpec''s */	/* fileName parameter. Fixed in Mac OS 8.1 */	if ( (result == noErr) && (spec->parID == 0) )		spec->parID = fsRtParID;	return ( result );}OSErr FSpLocationFromFullPath(short fullPathLength,									 const void *fullPath,									 FSSpec *spec){	AliasHandle	alias;	OSErr		result;	Boolean		wasChanged;	Str32		nullString;		/* Create a minimal alias from the full pathname */	nullString[0] = 0;	/* null string to indicate no zone or server name */	result = NewAliasMinimalFromFullPath(fullPathLength, fullPath, nullString, nullString, &alias);	if ( result == noErr )	{		/* Let the Alias Manager resolve the alias. */		result = ResolveAlias(NULL, alias, spec, &wasChanged);				/* work around Alias Mgr sloppy volume matching bug */		if ( spec->vRefNum == 0 )		{			/* invalidate wrong FSSpec */			spec->parID = 0;			spec->name[0] =  0;			result = nsvErr;		}		DisposeHandle((Handle)alias);	/* Free up memory used */	}	return ( result );}typedef struct {	StandardFileReply *theSFR;	FSSpec *itemSpec;} HookRecord, *HookRecordPtr;OSErr squeakFindImage(const FSSpecPtr defaultLocationfssPtr,FSSpecPtr documentFSSpec){    NavDialogOptions    dialogOptions;    AEDesc              defaultLocation;    NavEventUPP         eventProc = NewNavEventUPP(findImageEventProc);    NavObjectFilterUPP  filterProc =  NewNavObjectFilterUPP(findImageFilterProc);    OSErr               anErr = noErr;    #if !!TARGET_API_MAC_CARBON    if ((Ptr) NavGetDefaultDialogOptions==(Ptr)kUnresolvedCFragSymbolAddress ) {      	//System pre 8.5 or system 7.x    	// point my hook data record at the reply record and at		// the file spec for the system file		     	StandardFileReply mySFR;    	HookRecord hookRec;	    DlgHookYDUPP	myDlgHookUPP;    	SFTypeList mySFTypeList;	    Point dialogPt;	    		hookRec.itemSpec = defaultLocationfssPtr;		hookRec.theSFR = &mySFR;		SetPt(&dialogPt, -1, -1);		// Set up the universal proc pointer to your hook routine with this 		// macro defined in StandardFile.h.  **NOTE** This is different		// from the macro used for System 6 dialog hooks, and you should get		// a compiler error if you try to use the wrong UPP with the wrong call.		myDlgHookUPP = NewDlgHookYDProc(DialogHook);				// call Std File		CustomGetFile(nil, -1, mySFTypeList, &mySFR, 0, dialogPt, myDlgHookUPP,			nil, nil, nil, &hookRec);					// Dispose of the routine descriptor, since they do allocate memory..		DisposeRoutineDescriptor(myDlgHookUPP);		*documentFSSpec = mySFR.sfFile; 		return !!mySFR.sfGood;	}#endif    //  Specify default options for dialog box    anErr = NavGetDefaultDialogOptions(&dialogOptions);    if (anErr == noErr)    {        //  Adjust the options to fit our needs        //  Set default location option        dialogOptions.dialogOptionFlags |= kNavSelectDefaultLocation;        dialogOptions.dialogOptionFlags |= kNavNoTypePopup;        //  Clear preview option        dialogOptions.dialogOptionFlags ^= kNavAllowPreviews;                // make descriptor for default location        anErr = AECreateDesc(typeFSS, defaultLocationfssPtr,                             sizeof(*defaultLocationfssPtr),                             &defaultLocation );        if (anErr == noErr)        {            // Get ''open'' resource. A nil handle being returned is OK,            // this simply means no automatic file filtering.            NavTypeListHandle typeList = (NavTypeListHandle)GetResource(                                        ''open'', 128);            NavReplyRecord reply;                        // Call NavGetFile() with specified options and            // declare our app-defined functions and type list            anErr = NavGetFile (&defaultLocation, &reply, &dialogOptions,                                eventProc, nil, filterProc,                                typeList, nil);            if (anErr == noErr && reply.validRecord)            {                //  Deal with multiple file selection                long    count;                                anErr = AECountItems(&(reply.selection), &count);                // Set up index for file list                if (anErr == noErr)                {                    long index;                                        for (index = 1; index <= 1; index++)                    {                        AEKeyword   theKeyword;                        DescType    actualType;                        Size        actualSize;                                                // Get a pointer to selected file                        anErr = AEGetNthPtr(&(reply.selection), index,                                            typeFSS, &theKeyword,                                            &actualType,documentFSSpec,                                            sizeof(FSSpec),                                            &actualSize);                     }                }                //  Dispose of NavReplyRecord, resources, descriptors                anErr = NavDisposeReply(&reply);            }            if (typeList !!= NULL)            {                ReleaseResource( (Handle)typeList);            }            (void) AEDisposeDesc(&defaultLocation);        }    }    DisposeNavEventUPP(eventProc);    DisposeNavObjectFilterUPP(filterProc);    return anErr;}pascal void findImageEventProc(NavEventCallbackMessage callBackSelector,                         NavCBRecPtr callBackParms,                         NavCallBackUserData callBackUD){   // WindowPtr window =    //                 (WindowPtr)callBackParms->eventData.event->message;    switch (callBackSelector)    {        case kNavCBEvent:            switch (((callBackParms->eventData)                    .eventDataParms).event->what)            {                case updateEvt:                   // MyHandleUpdateEvent(window,                     //    (EventRecord*)callBackParms->eventData.event);                    break;            }            break;    }}pascal Boolean findImageFilterProc(AEDesc* theItem, void* info,                             NavCallBackUserData callBackUD,                            NavFilterModes filterMode){    OSErr theErr = noErr;    Boolean display = true;    NavFileOrFolderInfo* theInfo = (NavFileOrFolderInfo*)info;        if (theItem->descriptorType == typeFSS)        if (!!theInfo->isFolder)            if (theInfo->fileAndFolder.fileInfo.finderInfo.fdType                 !!= ''STim'')                display = false;    return display;}#if !!TARGET_API_MAC_CARBON// this dialog hook for System 7 std file selects// the file specified by the hookRecord supplied as userDatapascal short DialogHook(short item, DialogPtr theDialog, 	void *userData){	HookRecordPtr hookRecPtr;		hookRecPtr = (HookRecordPtr) userData;		// hookRecPtr->itemSpec points to the FSSpec of the item to be selected	// hookRecPtr->theSFR points to the standard file reply record	// make sure we''re dealing with the proper dialog	if (GetWRefCon(theDialog) == sfMainDialogRefCon) {			// just when opening the dialog...		if (item == sfHookFirstCall) {				// make the reply record hold the spec of the specified item			hookRecPtr->theSFR->sfFile = *hookRecPtr->itemSpec;						// ThereÕs a gotcha in Standard File when using sfHookChangeSelection. 			// Even though New Inside Macintosh: Files has a sample that doesn''t set			// the sfScript field, it should be set, or the last object in the			// selected directory  will always be selected.			hookRecPtr->theSFR->sfScript = smSystemScript;			// tell std file to change the selection to that item			item = sfHookChangeSelection;		}	}						return item;}#endif#ifndef __MPW__#include <ansi_files.h>#include <buffer_io.h>int fflush(FILE * file){	fpos_t	position;                    /* mm 970708 */	ParamBlockRec pb;    OSErr error;		if (!!file)		return(__flush_all());		if (file->state.error || file->mode.file_kind == __closed_file)		return(EOF);		if (file->mode.io_mode == __read)		/* mm 980430 */		return 0;							/* mm 980430 */		if (file->state.io_state >= __rereading)		file->state.io_state = __reading;		if (file->state.io_state == __reading)		file->buffer_len = 0;		if (file->state.io_state !!= __writing)	{		file->state.io_state = __neutral;  /* mm 970905 */		return(0);	}	#ifndef _No_Disk_File_OS_Support	if (file->mode.file_kind !!= __disk_file || (position = ftell(file)) < 0)		position = 0;#else	position = 0;#endif		if (__flush_buffer(file, NULL))	{		set_error(file);		return(EOF);	}		file->state.io_state = __neutral;	file->position       = position;	file->buffer_len     = 0;		pb.ioParam.ioRefNum = file->handle;    error = PBFlushFileSync(&pb); 	return(0);}#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/18/2001 20:46' prior: 33997611!macWindowFile	^ '#include "sq.h"#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#ifndef __MPW__#include <profiler.h>#endif#include <sound.h>#include <Math64.h>#ifndef __MPW__#include <cstddef>#endif#include <processes.h>#include <OpenTransport.h>#include <Threads.h>#include <DriverServices.h>#include <stddef.h>/*** Compilation Options:**	define PLUGIN		to compile code for Netscape or IE Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE//#define IHAVENOHEAD//Aug 7th 2000,JMM Added logic for interrupt driven dispatching//Sept 1st 2000, JMM fix problem with modifier information being passed back incorrectly.//Sept 1st 2000, JMM use floating point for time versus 64bit math (faster!!)//Sept 1st 2000, JMM watch mouse movement foreground only, ignore when squeak in background.//Sept 18th 2000, JMM fix to cmpSize //Sept 19th 2000, JMM Sept 1st fix to keyboard modifier info broke cmd shift//Sept 27 2000, JMM fix to documentPath//Nov 13 2000, JMM logic to read/write image from VM. //Nov 22 2000, JMM Bob Arning found a bug with the duplicate mouse event logic (we were altering the event then recording the altered value)//Nov 30 2000, JMM Use Open Transport clock versus upTime, solves some issues for jitter and it''s faster//Dec 5th 2000, JMM poll 60 times a second... do event polling via checkForInterrupts and drive semaphore//Dec 6th 2000, JMM added logic to interface with power manger (1997 was there but dropped..., back again for ibooks)//Jan 14th 2001, KG Did some carbon porting.//Feb 2nd 2001, JMM V3.0 added zoom window support, full path support//Feb 2nd 2001, JMM V3.04 do an open window dialog at startup time if no image file//Feb 14th 2001, JMM V3.06 don''t cache image read/writes//Feb 17th 2001, JMM V3.07 fix OS bug in 7.5.5 on activate event#if TARGET_API_MAC_CARBON    #define EnableMenuItemCarbon(m1,v1)  EnableMenuItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableMenuItem(m1,v1);#else    #ifndef NewAEEventHandlerUPP    	#define NewAEEventHandlerUPP NewAEEventHandlerProc     #endif    #define EnableMenuItemCarbon(m1,v1)  EnableItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableItem(m1,v1);        inline Rect *GetPortBounds(CGrafPtr w,Rect *r) { *r = w->portRect; return &w->portRect;}          inline Rect *GetRegionBounds(RgnHandle region, Rect * bounds) { *bounds = (*region)->rgnBBox; return &(*region)->rgnBBox;}        inline BitMap *GetQDGlobalsScreenBits(BitMap *bm){*bm = qd.screenBits; return &qd.screenBits; }        inline BitMap * GetPortBitMapForCopyBits (CGrafPtr w) { return &((GrafPtr)w)->portBits;}        inline pascal long InvalWindowRect(WindowRef  window,  const Rect * bounds) {InvalRect (bounds);}#endif/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/* The following prototype is missing from the CW11 header files: */pascal void ExitToShell(void);/*** Variables -- Imported from Browser Plugin Module ***/#ifdef PLUGINextern int pluginArgCount;extern char *pluginArgName[100];extern char *pluginArgValue[100];#endif/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image file */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document file */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;OTTimeStamp     timeStart;Boolean         gTapPowerManager=false;Boolean         gDisablePowerManager=false;const long      gDisableIdleTickCount=60*10;long            gDisableIdleTickLimit=0;Boolean         gThreadManager=false;ThreadID        gSqueakThread = kNoThreadID;ThreadEntryUPP  gSqueakThreadUPP;Boolean         gAllowAccessToFilePlease=false;#ifdef __MPW__QDGlobals 		qd;#endif/*** Variables -- Event Recording ***/#define MAX_EVENT_BUFFER 1024int inputSemaphoreIndex = 0;/* if non-zero the event semaphore index */sqInputEvent eventBuffer[MAX_EVENT_BUFFER];int eventBufferGet = 0;int eventBufferPut = 0;/* declaration of the event message hook */typedef int (*eventMessageHook)(EventRecord* event);eventMessageHook messageHook = NULL;eventMessageHook postMessageHook = NULL;#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */int cachedButtonState = 0;	/* buffered mouse button and modifier state for							   last mouse click even if button has since gone up;							   this cache is kept until the next time ioGetButtonState()							   is called to avoid missing short clicks */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath);void MenuBarHide(void);void MenuBarRestore(void);int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID);int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short VolumeNumber,long directoryID);void SqueakTerminate();void ExitCleanup();int calculateStartLocationForImage();extern int dropInit(void);Boolean RunningOnCarbonX(void);void DoZoomWindow (EventRecord* theEvent, WindowPtr theWindow, short zoomDir, short hMax, short vMax);GDHandle getDominateDevice(WindowPtr theWindow,Rect *windRect);void getDominateGDeviceRect(GDHandle dominantGDevice,Rect *dGDRect,Boolean forgetMenuBar);int fetchFileInfo(CInfoPBRec *pb,int dirIndex,FSSpec *spec,unsigned char *name,Boolean doAlias,Boolean *isFolder);OSStatus GetApplicationDirectory(short *vRefNum, long *dirID);extern pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath);OSErr FSpLocationFromFullPath(short fullPathLength,									 const void *fullPath,									 FSSpec *spec);OSErr squeakFindImage(const FSSpecPtr defaultLocationfssPtr,FSSpecPtr documentFSSpec);int ioInitSecurity(void);/* event capture */sqInputEvent *nextEventPut(void);int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);int recordMouseEvent(EventRecord *theEvent, int theButtonState);int recordDragDropEvent(EventRecord *theEvent, int theButtonState, int numberOfItems, int dragType);int recordKeyboardEvent(EventRecord *theEvent, int keyType);int MouseModifierState(EventRecord *theEvent);WindowPtr getSTWindow(void);int setMessageHook(eventMessageHook theHook);int setPostMessageHook(eventMessageHook theHook);void PowerMgrCheck(void);static pascal void* squeakThread(void *threadParm);OSErr   createNewThread(); /*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);static pascal OSErr HandleOpenDocEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);static pascal OSErr HandlePrintDocEvent(const AEDescList *aevt, AEDescList *reply, long refCon);static pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerUPP(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerUPP(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerUPP(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */    int                 checkValueForEmbeddedImage;    OSErr               err;	Str32                name; 	/* record path to VM''s home folder */	short vRefNum;	long dirID;	// Get the Volume ref and Directory id of the Application''s directory.    err = GetApplicationDirectory(&vRefNum, &dirID);    if (err !!= noErr) return err;	// Convert that to a full path string.	PathToWorkingDir(vmPath, VMPATH_SIZE, vRefNum, dirID);	checkValueForEmbeddedImage = calculateStartLocationForImage();	if (checkValueForEmbeddedImage == 0) {	    /* use default image name in same directory as the VM */	    strcpy(shortImageName, "squeak.image");	    return noErr;	}	if (err !!= noErr) {		strcpy(shortImageName, "squeak.image");	    return noErr;	}		CopyPascalStringToC(name,shortImageName);	StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);    return noErr;}pascal OSErr HandleOpenDocEvent(const AEDescList *aevt, AEDescList *reply, long refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	FInfo		finderInformation;	char 		tempShortName[SHORTIMAGE_NAME_SIZE + 1];		short vRefNum;	long dirID;		reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */    err = GetApplicationDirectory(&vRefNum, &dirID);    if (err !!= noErr) return err;    	PathToWorkingDir(vmPath, VMPATH_SIZE, vRefNum, dirID);		/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) return errAEEventNotHandled;;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;		if (shortImageName[0] !!= 0) {#ifdef IHAVENOHEAD		/* get image name */		err = AEGetNthPtr(&fileList, 1, typeFSS,						  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);		if (err) goto done;				err = FSpGetFInfo(&fileSpec,&finderInformation);		if (err) goto done;					CopyPascalStringToC(fileSpec.name,tempShortName);		if (finderInformation.fdType == ''SOBJ'') {			StoreFullPathForLocalNameInto(tempShortName, documentName, DOCUMENT_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);		}#endif		goto done;	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;		err = FSpGetFInfo(&fileSpec,&finderInformation);	if (err) goto done;			CopyPascalStringToC(fileSpec.name,shortImageName);	if (!!(IsImageName(shortImageName) || finderInformation.fdType == ''STim'') || finderInformation.fdType == ''STch'') {		/* record the document name, but run the default image in VM directory */		if (finderInformation.fdType == ''SOBJ'')			StoreFullPathForLocalNameInto(shortImageName, documentName, DOCUMENT_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);	} else {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return noErr;  //Note under Carbon it sends us a Quit event, but we don''t process because image might not get saved?}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowRef		wp;	int				isDeskAccessory;	wp = FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = GetWindowKind(wp) < 0;	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableMenuItemCarbon(editMenu, 1);		EnableMenuItemCarbon(editMenu, 3);		EnableMenuItemCarbon(editMenu, 4);		EnableMenuItemCarbon(editMenu, 5);		EnableMenuItemCarbon(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableMenuItemCarbon(editMenu, 1);		DisableMenuItemCarbon(editMenu, 3);		DisableMenuItemCarbon(editMenu, 4);		DisableMenuItemCarbon(editMenu, 5);		DisableMenuItemCarbon(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	static EventRecord oldEvent;	int				ok;	Rect    bounds;	ok = WaitNextEvent(everyEvent, &theEvent,0,null);	if((messageHook) && (messageHook(&theEvent))) {        return ok;    }	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				if(postMessageHook) postMessageHook(&theEvent);				return false;			break;			case mouseUp:				if(inputSemaphoreIndex) {					recordMouseEvent(&theEvent,MouseModifierState(&theEvent));    				if(postMessageHook) postMessageHook(&theEvent);					return false;				}				recordModifierButtons(&theEvent);				if(postMessageHook) postMessageHook(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyDown);					break;				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;						case keyUp:				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyUp);				}			break;#ifndef IHAVENOHEAD			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				//GetPortBounds(GetWindowPort(stWindow),&bounds);				//InvalWindowRect(stWindow,&bounds);			break;#endif			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;						case osEvt: 				if (((theEvent.message>>24)& 0xFF) == suspendResumeMessage) {									//JMM July 4th 2000					//Fix for menu bar tabbing, thanks to Javier Diaz-Reinoso for pointing this out					//					if (fullScreenFlag) {						if ((theEvent.message & resumeFlag) == 0) {							MenuBarRestore();						}						else {							MenuBarHide();						}					}				}				break;		}	}	else {		if(inputSemaphoreIndex && windowActive && 		    !!((oldEvent.what == theEvent.what) &&  		    (oldEvent.message == theEvent.message) && 		    ((oldEvent.where.v == theEvent.where.v) && (oldEvent.where.h == theEvent.where.h)) && 		    (oldEvent.modifiers == theEvent.modifiers))) {    		oldEvent = theEvent; //JMM Nov 11th 2000 bug fix 			recordMouseEvent(&theEvent,MouseModifierState(&theEvent)); 		} 		else		 oldEvent = theEvent;	}	if(postMessageHook) postMessageHook(&theEvent); 	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);#if !!TARGET_API_MAC_CARBON			OpenDeskAcc(name);#endif 			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:#if !!TARGET_API_MAC_CARBON			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}#endif		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	static Rect		growLimits = { 20, 20, 10000, 10000 };	Rect        dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:#if !!TARGET_API_MAC_CARBON			SystemClick(theEvent, theWindow);#endif		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;#ifndef IHAVENOHEAD		case inDrag:			GetRegionBounds(GetGrayRgn(), &dragBounds);			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inZoomIn:		case inZoomOut:			if (theWindow == stWindow) {					DoZoomWindow(theEvent,stWindow, windowCode,10000, 10000);				}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				if(inputSemaphoreIndex) {					recordMouseEvent(theEvent,MouseModifierState(theEvent));					break;				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;#endif	}}#if TARGET_API_MAC_CARBONvoid InitMacintosh(void) {	FlushEvents(everyEvent, 0);	InitCursor();}void MenuBarHide(void) { 	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */    menuBarRegion = (RgnHandle) 1;    HideMenuBar();}void MenuBarRestore(void) {	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */    ShowMenuBar();    menuBarRegion = nil;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {}void FreeClipboard(void) {}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;       	clipSize = clipboardSize(); 	charsToMove = (count < clipSize) ? count : clipSize;    err = GetScrapFlavorData(scrap,kScrapFlavorTypeText,(long *) &charsToMove,(char *) byteArrayIndex + startIndex);    if (err !!= noErr) {         FreeClipboard();        return 0;           }	return charsToMove;}int clipboardSize(void) {	long count;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;           err = GetScrapFlavorSize (scrap, kScrapFlavorTypeText, &count); 	if (err !!= noErr) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ScrapRef scrap;	OSErr err;	err = ClearCurrentScrap();    err = GetCurrentScrap (&scrap);	err = PutScrapFlavor ( scrap, kScrapFlavorTypeText, kScrapFlavorMaskNone , count,  (const void *) (byteArrayIndex + startIndex));}#else void InitMacintosh(void) {#if TARGET_CPU_68K    long currentLimit;    currentLimit = (long) GetApplLimit();    SetApplLimit((char *) currentLimit-32*1024);#endif	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */  	WindowPtr win; 		if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	LMSetMBarHeight(menuBarHeight);		win = FrontWindow();	if (win) {		CalcVis(win);		CalcVisBehind(win,menuBarRegion);	}	HiliteMenu(0);	DisposeRgn(menuBarRegion);		menuBarRegion = nil;	DrawMenuBar();}/*** Clipboard Support (text only for now) ***/Handle			clipboardBuffer = nil;void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;    //JMM locking    HLock(clipboardBuffer); 	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}    HUnlock(clipboardBuffer); 	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}#endifvoid SetUpMenus(void) {	long decideOnQuitMenu;		InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();#if TARGET_API_MAC_CARBON    Gestalt( gestaltMenuMgrAttr, &decideOnQuitMenu);    if (!!(decideOnQuitMenu & gestaltMenuMgrAquaLayoutMask) || true)	        AppendMenu(fileMenu, "\pQuit");#else	AppendResMenu(appleMenu, ''DRVR'');    AppendMenu(fileMenu, "\pQuit");#endif 	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};#ifndef IHAVENOHEAD	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, zoomDocProc, (WindowPtr) -1L, false, 0);#endif}void SetWindowTitle(char *title) {    Str255 tempTitle;	CopyCStringToPascal(title,tempTitle);#ifndef IHAVENOHEAD	SetWTitle(stWindow, tempTitle);#endif}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int asciiChar, modifierBits, keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = modifierMap[(theEvent->modifiers >> 8) & 0x1F];	if ((modifierBits & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	keystate = (modifierBits << 8) | asciiChar;	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState = MouseModifierState(theEvent);	cachedButtonState = cachedButtonState | buttonState;}int MouseModifierState(EventRecord *theEvent) {	int stButtons;	stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {  /* is false if button is down */		stButtons = 4;		/* red button by default */		if ((theEvent->modifiers & optionKey) !!= 0) {			stButtons = 2;	/* yellow button if option down */		}		if ((theEvent->modifiers & cmdKey) !!= 0) {			stButtons = 1;	/* blue button if command down */		}	} 	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	return ((modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7));}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordMouseEvent(EventRecord *theEvent, int theButtonState) {	sqMouseEvent *evt;		evt = (sqMouseEvent*) nextEventPut();	/* first the basics */	evt->type = EventTypeMouse;	evt->timeStamp = ioMSecs(); 	GlobalToLocal((Point *) &theEvent->where);	evt->x = theEvent->where.h;	evt->y = theEvent->where.v;	/* then the buttons */	evt->buttons = theButtonState & 0x07;	/* then the modifiers */	evt->modifiers = theButtonState >> 3;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}int recordDragDropEvent(EventRecord *theEvent, int theButtonState, int numberOfItems, int dragType) {	sqDragDropFilesEvent *evt;		evt = (sqDragDropFilesEvent*) nextEventPut();	/* first the basics */	evt->type = EventTypeDragDropFiles;	evt->timeStamp = ioMSecs(); 	GlobalToLocal((Point *) &theEvent->where);	evt->x = theEvent->where.h;	evt->y = theEvent->where.v;	evt->numFiles = numberOfItems;	evt->dragType = dragType;		/* then the modifiers */	evt->modifiers = theButtonState >> 3;	/* clean up reserved */	evt->reserved1 = 0;//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}int recordKeyboardEvent(EventRecord *theEvent, int keyType) {	int stButtons = 0;	int asciiChar, modifierBits;	sqKeyboardEvent *evt, *extra;	evt = (sqKeyboardEvent*) nextEventPut();	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = MouseModifierState(theEvent); //Capture mouse/option states	if (((modifierBits >> 3) & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	/* first the basics */	evt->type = EventTypeKeyboard;	evt->timeStamp = ioMSecs();	/* now the key code */	/* press code must differentiate */	evt->charCode = (theEvent->message & keyCodeMask) >> 8;	evt->pressCode = keyType;	evt->modifiers = modifierBits >> 3;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;	/* generate extra character event */	if (keyType == EventKeyDown) {		extra = (sqKeyboardEvent*)nextEventPut();		*extra = *evt;		extra->charCode = asciiChar;		extra->pressCode = EventKeyChar;	}//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}static sqInputEvent *nextEventPut(void) {	sqInputEvent *evt;	evt = eventBuffer + eventBufferPut;	eventBufferPut = (eventBufferPut + 1) % MAX_EVENT_BUFFER;	if (eventBufferGet == eventBufferPut) {		/* buffer overflow; drop the last event */		eventBufferGet = (eventBufferGet + 1) % MAX_EVENT_BUFFER;	}	return evt;}int ioSetInputSemaphore(int semaIndex) {	inputSemaphoreIndex = semaIndex;	return 1;}int ioGetNextEvent(sqInputEvent *evt) {	if (eventBufferGet == eventBufferPut) {		if (gThreadManager)    		YieldToAnyThread();		else		    ioProcessEvents();	}	if (eventBufferGet == eventBufferPut) 		return false;	*evt = eventBuffer[eventBufferGet];	eventBufferGet = (eventBufferGet+1) % MAX_EVENT_BUFFER;	return true;}/*** Mac Specific External Primitive Support ***//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName) {	char pluginDirPath[1000];	CFragConnectionID libHandle;	Ptr mainAddr;	Str255 errorMsg,tempPluginName;	OSErr err;        	/* first, look in the "<Squeak VM directory>Plugins" directory for the library */	strcpy(pluginDirPath, vmPath);	#ifdef PLUGIN	strcat(pluginDirPath, ":Plugins");#else	strcat(pluginDirPath, "Plugins");#endif 	        libHandle = LoadLibViaPath(pluginName, pluginDirPath);	if (libHandle !!= nil) return (int) libHandle;#ifndef PLUGIN	/* second, look directly in Squeak VM directory for the library */	libHandle = LoadLibViaPath(pluginName, vmPath);	if (libHandle !!= nil) return (int) libHandle;        /* Lastly look for it as a shared import library */        CopyCStringToPascal(pluginName,tempPluginName);    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kLoadCFrag, &libHandle, &mainAddr, errorMsg);	if (err == noErr) 	    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kFindCFrag, &libHandle, &mainAddr, errorMsg);	if (libHandle !!= nil) return (int) libHandle;#endif    	return nil;}/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle) {	CFragSymbolClass ignored;	Ptr functionPtr = 0;	OSErr err;    Str255 tempLookupName;    	if (!!moduleHandle) return 0;	/* get the address of the desired primitive function */	CopyCStringToPascal(lookupName,tempLookupName);	err = FindSymbol(		(CFragConnectionID) moduleHandle, (unsigned char *) tempLookupName,		&functionPtr, &ignored);	if (err) return 0;	return (int) functionPtr;}/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle) {	CFragConnectionID libHandle;	OSErr err;	if (!!moduleHandle) return 0;	libHandle = (CFragConnectionID) moduleHandle;	err = CloseConnection(&libHandle);	return 0;}CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath) {	short 				vRefNum;	long				ignore;	CInfoPBRec 			pb;	FSSpec				fileSpec;	Str255				problemLibName,fileSpecName,tempPlugindirPath;    Ptr					junk;	CFragConnectionID	libHandle = 0;	OSErr				err = noErr;	/* get the default volume */	HGetVol( nil, &vRefNum, &ignore);	/* get the directory ID for the given path */	CopyCStringToPascal(pluginDirPath,tempPlugindirPath);	pb.hFileInfo.ioNamePtr = tempPlugindirPath;	pb.hFileInfo.ioVRefNum = 0;  /* use the default volume */	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	err = PBGetCatInfoSync(&pb);	if (err) return nil; /* bad plugin directory path */	/* make a file spec for the given file name in the plugin directory */	CopyCStringToPascal(libName,fileSpecName);	FSMakeFSSpec(vRefNum,pb.hFileInfo.ioDirID,fileSpecName,&fileSpec);	err = GetDiskFragment(		&fileSpec, 0, kCFragGoesToEOF, nil, kLoadCFrag, &libHandle, &junk, problemLibName);	if (err) return nil;	return libHandle;}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}#ifndef PLUGINint ioExit(void) {	ioShutdownAllModules();	MenuBarRestore();	ExitToShell();}#endifint ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();	if ((cachedButtonState & 0x7) !!= 0) {		int result = cachedButtonState;		cachedButtonState = 0;  /* clear cached button state */		return result;	}	cachedButtonState = 0;  /* clear cached button state */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioHasDisplayDepth(int depth) {	/* Return true if this platform supports the given color display depth. */	switch (depth) {	case 1:	case 2:	case 4:	case 8:	case 16:	case 32:		return true;	}	return false;}int ioMicroMSecsExpensive(void);int ioMicroMSecsExpensive(void) {	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}#if TARGET_CPU_PPC#if TARGET_API_MAC_CARBONint ioMicroMSecs(void) { //Some versions of mac os/x return 0 when using OTElapsedMilliseconds	Nanoseconds elapsedNanoseconds;   // an UnsignedWide integer	if((Ptr)UpTime!!=(Ptr)kUnresolvedCFragSymbolAddress){		elapsedNanoseconds=AbsoluteToNanoseconds(UpTime());		// NOTE: 4294967296.0 == (double)0x10000*0x10000		return (4294967296.0*elapsedNanoseconds.hi+elapsedNanoseconds.lo)*1e-6;	}else {	    return ioMicroMSecsExpensive();	}}#elseint ioMicroMSecs(void) {	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. */		register long check;		if((Ptr)OTElapsedMilliseconds!!=(Ptr)kUnresolvedCFragSymbolAddress){    	check = OTElapsedMilliseconds(&timeStart);    	if (check !!= -1)     	    return check;    	OTGetTimeStamp(&timeStart);	    return ioMicroMSecs();	}else {	    return ioMicroMSecsExpensive();	}}#endif#elseint ioMicroMSecs(void) {    return ioMicroMSecsExpensive();}#endifint ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	return ioMicroMSecs();}int ioMousePoint(void) {	Point p;	if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	const int nextPollOffsetCheck = CLOCKS_PER_SEC/60, nextPowerCheckOffset=CLOCKS_PER_SEC/2; 	static clock_t nextPollTick = 0, nextPowerCheck=0;	long    clockTime;#ifndef PLUGIN	if (clock() >= nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		        clockTime = clock();                if (gDisablePowerManager && gTapPowerManager) {            if (clockTime > gDisableIdleTickLimit)                gDisableIdleTickLimit = IdleUpdate() + gDisableIdleTickCount;                #if TARGET_CPU_PPC            if (clockTime > nextPowerCheck) {                 UpdateSystemActivity(UsrActivity);                 nextPowerCheck = clockTime + nextPowerCheckOffset;            }#endif        }        		/* wait a while before trying again */		nextPollTick = clockTime + nextPollOffsetCheck;	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. 	 */       microSeconds;    if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();}int ioScreenDepth(void) {    Rect ignore;        GDHandle mainDevice = getDominateDevice(stWindow,&ignore);    if (mainDevice == null)         return 8;        return (*(*mainDevice)->gdPMap)->pixelSize;}#ifndef PLUGINint ioScreenSize(void) {	int w = 10, h = 10;    Rect portRect;    #ifndef IHAVENOHEAD	if (stWindow !!= nil) {        GetPortBounds(GetWindowPort(stWindow),&portRect);		w =  portRect.right -  portRect.left;		h =  portRect.bottom - portRect.top;	}#endif	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}#endifint ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag) {	/* Set the window to the given width, height, and color depth. Put the window	   into the full screen mode specified by fullscreenFlag. */	/* Note: Changing display depth is not yet, and may never be, implemented	   on the Macintosh, where (a) it is considered inappropriate and (b) it may	   not even be a well-defined operation if the Squeak window spans several	   displays (which display''s depth should be changed?). */	depth;#ifndef IHAVENOHEAD	ioSetFullScreen(fullscreenFlag);	if (!!fullscreenFlag) {		SizeWindow(stWindow, width, height, true);	}#endif}#ifndef PLUGINint ioSetFullScreen(int fullScreen) {	Rect                screen,portRect,windRect;	int                 width, height, maxWidth, maxHeight;	int                 oldWidth, oldHeight;    static Rect		    rememberOldLocation = {44,8,0,0};		    GDHandle            	dominantGDevice;    dominantGDevice = getDominateDevice(stWindow,&windRect);    getDominateGDeviceRect(dominantGDevice,&screen,true);    	if (fullScreen) {		rememberOldLocation = windRect;		if (dominantGDevice == GetMainDevice()) {		    rememberOldLocation.top += GetMBarHeight();		    rememberOldLocation.bottom += GetMBarHeight();		}		MenuBarHide();		GetPortBounds(GetWindowPort(stWindow),&portRect);		oldWidth =  portRect.right -  portRect.left;		oldHeight =  portRect.bottom -  portRect.top;		width  = screen.right - screen.left; 		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, screen.left, screen.top, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, rememberOldLocation.left, rememberOldLocation.top, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;    if (depth<=8) { /*Duane Maxwell <dmaxwell@exobox.com> fix cmpSize Sept 18,2000 */    	(*stPixMap)->cmpSize = depth;    	(*stPixMap)->cmpCount = 1;    } else if (depth==16) {    	(*stPixMap)->cmpSize = 5;    	(*stPixMap)->cmpCount = 3;    } else if (depth==32) {    	(*stPixMap)->cmpSize = 8;    	(*stPixMap)->cmpCount = 3;    }	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPortWindowPort(stWindow);	CopyBits((BitMap *) *stPixMap, GetPortBitMapForCopyBits(GetWindowPort(stWindow)), &srcRect, &dstRect, srcCopy, maskRect);#if TARGET_API_MAC_CARBON	QDFlushPortBuffer (GetWindowPort(stWindow), maskRect);#endif	DisposeRgn(maskRect);}#endif/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short volumeNumber,long directoryID) {	int offset, sz, i;	offset = PathToWorkingDir(fullName, length, volumeNumber, directoryID);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*****************************************************************************************GetApplicationDirectoryGet the volume reference number and directory id of this application.Code taken from Apple:	Technical Q&As: FL 14 - Finding your application''s directory (19-June-2000)Karl Goiser 14/01/01*****************************************************************************************/        /* GetApplicationDirectory returns the volume reference number        and directory ID for the current application''s directory. */    OSStatus GetApplicationDirectory(short *vRefNum, long *dirID) {        ProcessSerialNumber PSN;        ProcessInfoRec pinfo;        FSSpec pspec;        OSStatus err;            /* valid parameters */        if (vRefNum == NULL || dirID == NULL) return paramErr;            /* set up process serial number */        PSN.highLongOfPSN = 0;        PSN.lowLongOfPSN = kCurrentProcess;            /* set up info block */        pinfo.processInfoLength = sizeof(pinfo);        pinfo.processName = NULL;        pinfo.processAppSpec = &pspec;            /* grab the vrefnum and directory */        err = GetProcessInformation(&PSN, &pinfo);        if (err == noErr) {            *vRefNum = pspec.vRefNum;            *dirID = pspec.parID;        }        return err;    }/*** Initializing the path to Working Dir ***/int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID) {	/* Fill in the given string with the full path from a root volume to	   to current working directory. (At startup time, the working directory	   is set to the application''s directory. Fails if the given string is not	   long enough to hold the entire path. (Use at least 1000 characters to	   be safe.)	*/	short	fullPathLength;	Handle	fullPathHandle;	if (GetFullPath(volumeNumber, directoryID, nil, &fullPathLength, &fullPathHandle) !!= noErr) {		//Some sort of random guff for failure:		pathName[0] = 1;		pathName[1] = (char)":";		return 1;	}	strncpy((char *) pathName, (char *) *fullPathHandle, fullPathLength);	DisposeHandle(fullPathHandle);	return fullPathLength;}/*****************************************************************************/int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {	/* Insert the given prefix C string plus a delimitor character at the	   beginning of the given C string. Return the new pathName size. Fails	   if pathName is does not have sufficient space for the result.	   Assume: pathName is null terminated.	*/	int offset, i;	offset = strlen(prefix) + 1;	if ((pathNameSize + offset) > pathNameMax) {		return pathNameSize;	}	for (i = pathNameSize; i >= 0; i--) {		/* make room in pathName for prefix (moving string terminator, too) */		pathName[i + offset] = pathName[i];	}	for (i = 0; i < offset; i++) {		/* make room in pathName for prefix */		pathName[i] = prefix[i];	}	pathName[offset - 1] = '':'';  /* insert delimitor */	return pathNameSize + offset;}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	fullImagePath;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;#if TARGET_CPU_PPC	if((Ptr)OTGetTimeStamp!!=(Ptr)kUnresolvedCFragSymbolAddress) 	    OTGetTimeStamp(&timeStart);#endif	PowerMgrCheck();	SetUpClipboard();	SetUpPixmap();}int plugInShutdown(void) {	ioShutdownAllModules();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {	    DisposeThread(gSqueakThread,null,true);		DisposePtr((void *) memory);		memory = nil;	}}/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	/* Note: 1.3x images will try to read the image as a document because they	   expect attribute #1 to be the document name. A 1.3x image can be patched	   using a VM of 2.6 or earlier. */	if (id == 1) return imageName;	if (id == 2) return documentName;#ifdef PLUGIN	/* When running in browser, return the EMBED tag info */	if ((id > 2) && (id <= (2 + (2 * pluginArgCount)))) {		int i = id - 3;		if ((i & 1) == 0) {  /* i is even */			return pluginArgName[i/2];		} else {			return pluginArgValue[i/2];		}	}#endif	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	Str255 tempPascalFileName;     FInfo fileInfo;	CopyCStringToPascal(fileName,tempPascalFileName);	if (strchr(mode, ''w'') !!= null) 	    err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);	 else	    err = HOpenDF(0,0,tempPascalFileName,fsRdPerm, &fRefNum);	    	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = HCreate(0,0,tempPascalFileName,  ''FAST'', ''STim'');		if (err2 == 0) {			err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);		}	}	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {        err = HGetFInfo(0,0,tempPascalFileName,&fileInfo);        if (err !!= noErr) return 0; //This should not happen                //On the mac we start at location 0 if this isn''t an VM            	if (!!(fileInfo.fdType == ''APPL'' && fileInfo.fdCreator == ''FAST'')){    		/* truncate non-VM file if opening in write mode */    		err = SetEOF(fRefNum, 0);    		if (err !!= 0) {    			FSClose(fRefNum);    			return null;    		}	    }	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	ParamBlockRec pb;    OSErr error;	pb.ioParam.ioRefNum = f;    pb.ioParam.ioCompletion = NULL;    pb.ioParam.ioBuffer = (Ptr)ptr;    pb.ioParam.ioReqCount = byteCount;    pb.ioParam.ioPosMode = fsAtMark + noCacheMask;    pb.ioParam.ioPosOffset = 0;    error = PBReadSync(&pb);    byteCount = pb.ioParam.ioActCount;           	if (error !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	ParamBlockRec pb;    OSErr error;    pb.ioParam.ioRefNum = f;    pb.ioParam.ioCompletion = NULL;    pb.ioParam.ioBuffer = (Ptr)ptr;    pb.ioParam.ioReqCount = byteCount;    pb.ioParam.ioPosMode = fsAtMark + noCacheMask;    pb.ioParam.ioPosOffset = 0;    error = PBWriteSync(&pb);    byteCount = pb.ioParam.ioActCount;           	if (error !!= 0) 	    return 0;	return byteCount / elementSize;}int calculateStartLocationForImage() { 	Handle cfrgResource;  	long	memberCount,i;	CFragResourceMember *target;		cfrgResource = GetResource(kCFragResourceType,0); 	if (cfrgResource == nil || ResError() !!= noErr) { return 0;};  		memberCount = ((CFragResource *)(*cfrgResource))->memberCount;	if (memberCount <= 1) {        ReleaseResource(cfrgResource);	    return 0; //Need FAT to get counters right	}		target = &((CFragResource *)(*cfrgResource))->firstMember;	for(i=0;i<memberCount;i++) {		if (target->architecture == ''FAST'') {					    ReleaseResource(cfrgResource);		    return target->offset;		}		target = NextCFragResourceMemberPtr(target); 	}    ReleaseResource(cfrgResource);	return 0;}int sqImageFileStartLocation(int fileRef, char *filename, int imageSize){    FInfo fileInfo;	Str255 tempPascalFileName;	OSErr   err;     int     resFileRef;	Handle  cfrgResource,newcfrgResource;  	UInt32	maxOffset=0,maxOffsetLength,targetOffset;	long    memberCount,i;	CFragResourceMember *target;      	CopyCStringToPascal(filename,tempPascalFileName);    err = HGetFInfo(0,0,tempPascalFileName,&fileInfo);    if (err !!= noErr) return 0; //This should not happen        //On the mac we start at location 0 if this isn''t an VM    	if (!!(fileInfo.fdType == ''APPL'' && fileInfo.fdCreator == ''FAST'')) return 0;        //Ok we have an application file, open the resource part and attempt to find the crfg        resFileRef = HOpenResFile(0,0,tempPascalFileName,fsWrPerm);    if (resFileRef == -1) return 0;    	cfrgResource = GetResource(kCFragResourceType,0);	if (cfrgResource == nil || ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};  		memberCount = ((CFragResource *)(*cfrgResource))->memberCount;	if (memberCount <= 1) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;};  //Need FAT to get counters right		target = &((CFragResource *)(*cfrgResource))->firstMember;	for(i=0;i<memberCount;i++) {		if (target->architecture == ''FAST'') {		    targetOffset = target->offset;		    target->length = imageSize;		    ChangedResource(cfrgResource);        	if (ResError() !!= noErr) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 		    UpdateResFile(resFileRef);        	if (ResError() !!= noErr) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;};             ReleaseResource(cfrgResource); 		    CloseResFile(resFileRef);			return targetOffset;		}		if (target->offset > maxOffset) {			maxOffset = target->offset;			maxOffsetLength = target->length;		}		target = NextCFragResourceMemberPtr(target);	}		//Ok at this point we need to alter the crfg to add the new tag for the image part		newcfrgResource = cfrgResource;	err = HandToHand(&newcfrgResource);	if (err !!= noErr || MemError() !!= noErr)  {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 	SetHandleSize(newcfrgResource,GetHandleSize(cfrgResource)+AlignToFour(kBaseCFragResourceMemberSize + 1));	if (MemError() !!= noErr)  {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 		target = &((CFragResource *)(*newcfrgResource))->firstMember; 	for(i=0;i<memberCount;i++) {		target = NextCFragResourceMemberPtr(target); 	}    target->architecture = ''FAST'';    target->reservedA = 0;                  /* !! Must be zero!!*/    target->reservedB = 0;                  /* !! Must be zero!!*/    target->updateLevel = 0;    target->currentVersion = 0;    target->oldDefVersion = 0;    target->uUsage1.appStackSize = 0;    target->uUsage2.appSubdirID = 0;    target->uUsage2.libFlags = 0;    target->usage = kApplicationCFrag;    target->where = kDataForkCFragLocator;    target->offset = maxOffset + maxOffsetLength;    targetOffset = target->offset;    target->length = imageSize;    target->uWhere1.spaceID = 0;    target->extensionCount = 0;             /* The number of extensions beyond the name.*/    target->memberSize = AlignToFour(kBaseCFragResourceMemberSize + 1);   /* Size in bytes, includes all extensions.*/    target->name[0] = 0x00;	((CFragResource *)(*newcfrgResource))->memberCount = memberCount+1;	RemoveResource(cfrgResource);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};  	AddResource(newcfrgResource,kCFragResourceType,0,nil);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};     UpdateResFile(resFileRef);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};     CloseResFile(resFileRef);    	return targetOffset;}#ifndef PLUGINvoid * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {	/* Application allocates Squeak object heap memory from its own heap. */		minHeapSize;	return NewPtr(desiredHeapSize);;}#endifvoid PowerMgrCheck(void) {	long pmgrAttributes;		gTapPowerManager = false;	gDisablePowerManager = false;	if (!! Gestalt(gestaltPowerMgrAttr, &pmgrAttributes))		if ((pmgrAttributes & (1<<gestaltPMgrExists)) 		    && (pmgrAttributes & (1<<gestaltPMgrDispatchExists))		    && (PMSelectorCount() >= 0x24)) {		    gTapPowerManager = true;			gDisableIdleTickLimit = clock();		}}int ioDisablePowerManager(int disableIfNonZero) {    gDisablePowerManager = disableIfNonZero;}Boolean RunningOnCarbonX(void){    UInt32 response;        return (Gestalt(gestaltSystemVersion,                     (SInt32 *) &response) == noErr)                && (response >= 0x01000);}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	short vRefNum;	long dirID;	OSErr err;    long threadGestaltInfo;    	InitMacintosh();	PowerMgrCheck();		SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	dropInit();	SetEventMask(everyEvent); // also get key up events	#if TARGET_CPU_PPC	if((Ptr)OTGetTimeStamp!!=(Ptr)kUnresolvedCFragSymbolAddress) 	    OTGetTimeStamp(&timeStart);#endif 	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		err = GetApplicationDirectory(&vRefNum, &dirID);		if (err !!= noErr) error("Could not obtain default directory");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */#ifdef JITTER	reservedMemory = 1000000;#else	reservedMemory = 500000;#endif	if (RunningOnCarbonX())	    availableMemory = 100*1024*1024 - reservedMemory;	else     	availableMemory = MaxBlock() - reservedMemory;		/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeak to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 50K to that.)	    	    JMM Note changed to 500k for Open Transport support on 68K machines	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	while (f == NULL) {	    //Failure attempt to ask the user to find the image file	    	    FSSpec vmfsSpec,imageFsSpec;	    WDPBRec wdPB;	    	    err =  FSpLocationFromFullPath(vmPathSize(),vmPath,&vmfsSpec);	    if (err) 	        ioExit();		err = squeakFindImage(&vmfsSpec,&imageFsSpec);	    if (err) 	        ioExit();	    CopyPascalStringToC(imageFsSpec.name,shortImageName);        StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, imageFsSpec.vRefNum, imageFsSpec.parID);			/* make the image or document directory the working directory */    	wdPB.ioNamePtr = NULL;    	wdPB.ioVRefNum = imageFsSpec.vRefNum;    	wdPB.ioWDDirID = imageFsSpec.parID;    	PBHSetVolSync(&wdPB);    	f = sqImageFileOpen(imageName, "rb"); 	}		readImageFromFileHeapSizeStartingAt(f, availableMemory, calculateStartLocationForImage());	sqImageFileClose(f);    ioInitSecurity();    #ifndef IHAVENOHEAD	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);#endif#if (!!(defined JITTER) && defined(__MPW__))	atexit(SqueakTerminate);#endif#if TARGET_CPU_PPC    if( Gestalt( gestaltThreadMgrAttr, &threadGestaltInfo) == noErr &&        threadGestaltInfo & (1<<gestaltThreadMgrPresent) &&        ((Ptr) NewThread !!= (Ptr)kUnresolvedCFragSymbolAddress)) {        gThreadManager = true;        err = createNewThread();        if (err == noErr) {            while(true)  {                ioProcessEvents();        		YieldToAnyThread();            }            return;        }    }        #endif    gThreadManager = false;    /* run Squeak */    squeakThread(0);}#endifOSErr createNewThread() {#if TARGET_CPU_PPC    gSqueakThreadUPP = NewThreadEntryUPP(squeakThread); //We should dispose of someday#else    gSqueakThreadUPP = (ThreadEntryProcPtr) NewRoutineDescriptor((ProcPtr)(squeakThread), uppThreadEntryProcInfo, GetCurrentArchitecture()); #endif	return NewThread( kCooperativeThread, gSqueakThreadUPP, nil, 80*1024, kCreateIfNeeded, 0L, &gSqueakThread);}static pascal void* squeakThread(void *threadParm) {	/* run Squeak */#	ifdef JITTER	j_interpret();#	else	interpret();#	endif}void SqueakTerminate() {#ifdef PLUGIN	ExitCleanup();#else	ioShutdownAllModules();#endif}WindowPtr getSTWindow(void) {    return stWindow;}int setMessageHook(eventMessageHook theHook) {    messageHook = theHook;}int setPostMessageHook(eventMessageHook theHook) {    postMessageHook = theHook;}#if !!TARGET_API_MAC_CARBON////	CopyPascalStringToC converts the source pascal string to a destination//	C string as it copies. //void CopyPascalStringToC(ConstStr255Param src, char* dst){	if ( src !!= NULL )	{		short   length  = *src++;			while ( length > 0 ) 		{			*dst++ = *(char*)src++;			--length;		}	}	*dst = ''\0'';}////	CopyCStringToPascal converts the source C string to a destination//	pascal string as it copies. The dest string will//	be truncated to fit into an Str255 if necessary.//  If the C String pointer is NULL, the pascal string''s length is set to zero//void CopyCStringToPascal(const char* src, Str255 dst){	short 	length  = 0;		// handle case of overlapping strings	if ( (void*)src == (void*)dst )	{		unsigned char*		curdst = &dst[1];		unsigned char		thisChar;						thisChar = *(const unsigned char*)src++;		while ( thisChar !!= ''\0'' ) 		{			unsigned char	nextChar;						// use nextChar so we don''t overwrite what we are about to read			nextChar = *(const unsigned char*)src++;			*curdst++ = thisChar;			thisChar = nextChar;						if ( ++length >= 255 )				break;		}	}	else if ( src !!= NULL )	{		unsigned char*		curdst = &dst[1];		short 				overflow = 255;		// count down so test it loop is faster		register char		temp;			// Can''t do the K&R C thing of Òwhile (*s++ = *t++)Ó because it will copy trailing zero		// which might overrun pascal buffer.  Instead we use a temp variable.		while ( (temp = *src++) !!= 0 ) 		{			*(char*)curdst++ = temp;							if ( --overflow <= 0 )				break;		}		length = 255 - overflow;	}	dst[0] = length;}#endif#define rectWidth(aRect) ((aRect).right - (aRect).left)#define rectHeight(aRect) ((aRect).bottom - (aRect).top)#define MinWindowWidth(foo) 72*3#define MinWindowHeight(foo) 72*3#define max(X, Y) ( ((X)>(Y)) ? (X) : (Y) )#define min(X, Y) (  ((X)>(Y)) ? (Y) : (X) )#define pin(VALUE, MIN, MAX) ( ((VALUE) < (MIN)) ? (MIN) : ( ((VALUE) > (MAX)) ? (MAX) : (VALUE) ) )void DoZoomWindow (EventRecord* theEvent, WindowPtr theWindow, short zoomDir, short hMax, short vMax){	Rect				zoomRect,windRect,globalPortRect, dGDRect;	GDHandle			dominantGDevice;   	if (TrackBox(theWindow, theEvent->where, zoomDir)) {		SetPortWindowPort(theWindow);		GetPortBounds(GetWindowPort(stWindow),&windRect);		EraseRect(&windRect);	// recommended for cosmetic reasons		if (zoomDir == inZoomOut) {			/*			 *	ZoomWindow() is a good basic tool, but it doesn''t do everything necessary to			 *	implement a good human interface when zooming. In fact it''s not even close for			 *	more high-end hardware configurations. We must help it along by calculating an			 *	appropriate window size and location any time a window zooms out.			 */            dominantGDevice = getDominateDevice(theWindow,&windRect);			/*			 *	At this point, we know the dimensions of the window we''re zooming, and we know			 *	what screen we''re going to put it on. To be more specific, however, we need a			 *	rectangle which defines the maximum dimensions of the resized window''s contents.			 *	This rectangle accounts for the thickness of the window frame, the menu bar, and			 *	one or two pixels around the edges for cosmetic compatibility with ZoomWindow().			 */            getDominateGDeviceRect(dominantGDevice,&dGDRect,false);            			GetPortBounds(GetWindowPort(theWindow),&globalPortRect);			LocalToGlobal(&(((Point *) &(globalPortRect))[0]));		// calculate the window''s portRect			LocalToGlobal(&(((Point *) &(globalPortRect))[1]));		// in global coordinates			// account for the window frame and inset it a few pixels			dGDRect.left	+= 2 + globalPortRect.left - windRect.left;			dGDRect.top		+= 2 + globalPortRect.top - windRect.top;			dGDRect.right	-= 1 + windRect.right - globalPortRect.right;			dGDRect.bottom	-= 1 + windRect.bottom - globalPortRect.bottom;			/*			 *	Now we know exactly what our limits are, and since there are input parameters			 *	specifying the dimensions we''d like to see, we can move and resize the zoom			 *	state rectangle for the best possible results. We have three goals in this:			 *	1. Display the window entirely visible on a single device.			 *	2. Resize the window to best represent the dimensions of the document itself.			 *	3. Move the window as short a distance as possible to achieve #1 and #2.			 */			GetWindowStandardState(theWindow, &zoomRect);			/*			 *	Initially set the zoom rectangle to the size requested by the input parameters,			 *	although not smaller than a minimum size. We do this without moving the origin.			 */			zoomRect.right = (zoomRect.left = globalPortRect.left) +									max(hMax, MinWindowWidth(theWindow));			zoomRect.bottom = (zoomRect.top = globalPortRect.top) +									max(vMax, MinWindowHeight(theWindow));			// Shift the entire rectangle if necessary to bring its origin inside dGDRect.			OffsetRect(&zoomRect,						max(dGDRect.left - zoomRect.left, 0),						max(dGDRect.top - zoomRect.top, 0));			/*			 *	Shift the rectangle up and/or to the left if necessary to accomodate the view,			 *	and if it is possible to do so. The rectangle may not be moved such that its			 *	origin would fall outside of dGDRect.			 */			OffsetRect(&zoomRect,						-pin(zoomRect.right - dGDRect.right, 0, zoomRect.left - dGDRect.left),						-pin(zoomRect.bottom - dGDRect.bottom, 0, zoomRect.top - dGDRect.top));			// Clip expansion to dGDRect, in case view is larger than dGDRect.			zoomRect.right = min(zoomRect.right, dGDRect.right);			zoomRect.bottom = min(zoomRect.bottom, dGDRect.bottom);			SetWindowStandardState(theWindow, &zoomRect);		}		ZoomWindow(theWindow, zoomDir, false);		// all it needed was a brain transplant	}}GDHandle getDominateDevice( WindowPtr theWindow,Rect *windRect) {	GDHandle			nthDevice, dominantGDevice;	long				sectArea, greatestArea;    long                quickDrawAttributes;	Rect				theSect;    RgnHandle           windowRegion;    #if TARGET_API_MAC_CARBON			windowRegion = NewRgn();			GetWindowRegion(theWindow,kWindowStructureRgn,windowRegion);			GetRegionBounds(windowRegion,windRect);#else			*windRect = (**((WindowPeek) theWindow)->strucRgn).rgnBBox;#endif			dominantGDevice = nil;    	    if (!! Gestalt(gestaltQuickdrawFeatures, &quickDrawAttributes) &&     	        (quickDrawAttributes & (1<<gestaltHasColor))) {				/*				 *	Color QuickDraw implies the possibility of multiple monitors. This is where				 *	zooming becomes more interesting. One should zoom onto the monitor containing				 *	the greatest portion of the window. This requires walking the gDevice list.				 */				nthDevice = GetDeviceList();				greatestArea = 0;				while (nthDevice !!= nil) {					if (TestDeviceAttribute(nthDevice, screenDevice)) {						if (TestDeviceAttribute(nthDevice, screenActive)) {							SectRect(windRect, &(**nthDevice).gdRect, &theSect);							sectArea = (long) rectWidth(theSect) * (long) rectHeight(theSect);							if (sectArea > greatestArea) {								greatestArea = sectArea;		// save the greatest intersection								dominantGDevice = nthDevice;	// and which device it belongs to							}						}					}					nthDevice = GetNextDevice(nthDevice);				}			}    return dominantGDevice;}void getDominateGDeviceRect(GDHandle dominantGDevice,Rect *dGDRect,Boolean forgetMenuBar) {    BitMap              bmap;	if (dominantGDevice !!= nil) {			*dGDRect = (**dominantGDevice).gdRect;			if (dominantGDevice == GetMainDevice())		// account for menu bar on main device				if (!!forgetMenuBar) 				        dGDRect->top += GetMBarHeight();		}		else {			GetQDGlobalsScreenBits(&bmap);			*dGDRect = bmap.bounds;				// if no gDevice, use default monitor			if (!!forgetMenuBar)			    dGDRect->top += GetMBarHeight();		}}'! !'From Squeak3.1alpha of 5 February 2001 [latest update: #3666] on 19 February 2001 at 9:27:25 pm'!"Change Set:		FixTextUpdateDate:			19 February 2001Author:			Dan IngallsRestore ability of test to recompose when its owner changes."!!TextMorph methodsFor: 'containment' stamp: 'di 2/19/2001 21:26' prior: 34394724!ownerChanged 	| priorEditor |	super ownerChanged.	container ifNotNil:		[editor == nil		ifTrue: [self releaseParagraph]		ifFalse: [priorEditor _ editor.				self releaseParagraph.				self installEditorToReplace: priorEditor]]! !'From Squeak3.0 of 4 February 2001 [latest update: #3545] on 19 February 2001 at 9:38:07 am'!"Change Set:		CelesteCompactFix-srDate:			19 February 2001Author:			Stephan RudlofRemoved a nasty Celeste bug and made some fixes/improvements.Compaction of database works now and results in a *valid* IndexFile.Works with Squeak3.0 of 4 February 2001 latest update: #3545."!!IndexFile methodsFor: 'file operations' stamp: 'sr 2/19/2001 07:36'!delete	| logFilename |	"delete logfile"	logFilename _ filename , '.log'.	FileDirectory		splitName: logFilename		to: [:dirPath :name | (FileDirectory forFileName: logFilename)				deleteFileNamed: name				ifAbsent: []].	"Delete this file."	super delete! !!IndexFile methodsFor: 'file operations' stamp: 'sr 2/19/2001 06:41'!openOn: aFileName messageFile: messageFile readLogFlag: readLogFlag	"Initialize myself from the file with the given name."	| fileStream |	filename _ aFileName.	fileStream _ FileStream fileNamed: aFileName.	self		readFrom: (ReadStream on: fileStream contentsOfEntireFile)		messageFile: messageFile.	readLogFlag ifTrue: [self readLogMessageFile: messageFile].	"close and release the file stream"	fileStream close.	fileStream _ nil! !!IndexFile methodsFor: 'file operations' stamp: 'sr 2/19/2001 09:19' prior: 22456865!readLogMessageFile: messageFile 	| file msgID entry |	file _ self logStream position: 0.	[file atEnd]		whileFalse: [(file peekFor: $r)				ifTrue: [MailDB readStringLineFrom: file.					self						privateRemove: (MailDB readIntegerLineFrom: file)]				ifFalse: [msgID _ MailDB readIntegerLineFrom: file.					entry _ IndexFileEntry								readFrom: file								messageFile: messageFile								msgID: msgID.					self privateAt: msgID put: entry]].	self logStream close! !!IndexFile methodsFor: 'file operations' stamp: 'sr 2/19/2001 07:28'!rename: newFileName 	"rename log file"	| logFilename newLogFilename |	logFilename _ filename , '.log'.	newLogFilename _ newFileName , '.log'.	FileDirectory		splitName: logFilename		to: [:dirPath :oldFileName | 			| fd | 			fd _ FileDirectory forFileName: logFilename.			(fd fileExists: logFilename)				ifTrue: [fd rename: oldFileName toBe: newLogFilename]].	"at last, it changes filename!!"	super rename: newFileName! !!IndexFile methodsFor: 'dictionary access' stamp: 'sr 2/19/2001 07:54' prior: 22457831!at: msgID put: anIndexFileEntry 	"Associate the given IndexFileEntry with the given message ID."	self privateAt: msgID put: anIndexFileEntry.	self logStream print: msgID;	 cr.	"message ID"	anIndexFileEntry writeOn: self logStream.	self logStream close! !!IndexFile class methodsFor: 'instance creation' stamp: 'sr 2/19/2001 06:46'!openOn: fileName messageFile: messageFile readLogFlag: readLogFlag 	"Answer a new instance of me for the given message file, backed by the 	file with the given name."	^ super new		openOn: fileName		messageFile: messageFile		readLogFlag: readLogFlag! !!MailDB methodsFor: 'open-create-save' stamp: 'sr 2/19/2001 06:49' prior: 24244295!openDB	"Open an existing mail database."	Transcript show: 'Opening mail database ''', rootFilename, '''...'.	messageFile _ MessageFile openOn: rootFilename, '.messages'.	indexFile _ IndexFile openOn: rootFilename, '.index' messageFile: messageFile readLogFlag: true.	categoriesFile _ CategoriesFile openOn: rootFilename, '.categories'.	Transcript show: 'Done.'; cr.! !!MailDB methodsFor: 'housekeeping' stamp: 'sr 2/19/2001 07:48' prior: 24253404!compact	"Compact the message file and rebuild the index file. Answer an array  	containing with the number of messages and the number of bytes  	recovered."	| newMessageFile newIndexFile stats |	newMessageFile _ MessageFile openOn: rootFilename , '.messages.tmp'.	"don't read log file here!!"	newIndexFile _ IndexFile				openOn: rootFilename , '.index.tmp'				messageFile: newMessageFile				readLogFlag: false.	stats _ self copyUndeletedTo: newMessageFile indexFile: newIndexFile.	newMessageFile save.	newIndexFile save.	messageFile rename: rootFilename , '.messages.bak'.	indexFile rename: rootFilename , '.index.bak'.	newMessageFile rename: rootFilename , '.messages'.	newIndexFile rename: rootFilename , '.index'.	indexFile delete.	messageFile delete.	messageFile _ MessageFile openOn: rootFilename , '.messages'.	"update messageFile in IndexFile entries by clean reopen of indexFile"	indexFile _ IndexFile				openOn: rootFilename , '.index'				messageFile: messageFile				readLogFlag: true.	self cleanUpCategories.	categoriesFile save.	^ stats! !IndexFile class removeSelector: #openOn:messageFile:!IndexFile class removeSelector: #openOn:messageFile:!IndexFile removeSelector: #openOn:messageFile:!IndexFile removeSelector: #openOn:messageFile:!'From Squeak3.1alpha of 5 February 2001 [latest update: #3591] on 14 February 2001 at 9:35:10 am'!"Change Set:		3499EndOfVersion3-0Date:			14 February 2001Author:			Dan IngallsThis is the last update for version 3.0.  In its postscript is an executable statement that will set the version if desired.If the user proceeds to update from 3.0 to 3.1, the NAME of this changeSet will be changed to '3617suntaxBob1-raa'.  This is a trick so that further updating will begin at the right place in the update stream for version 3.1."!"Postscript:Offer the chance to advance the version number."(self confirm: 'There are no further updates for Squeak 3.0.Do you wish to have your system marked as version 3.1alphaso that you may retrieve updates for version 3.1alpha and beyond?[Some updates to 3.1alpha may put you in the role of a test-pilot].You may choose NO now, save a backup copyof your image, and then call for updates again.Choose YES if you are adequately backed up andwish to convert this Squeak image to version 3.1alpha.DO YOU WANT TO ADVANCE to Version 3.1alpha now?')	ifTrue: [EToySystem eToyVersion: 'Squeak3.1alpha' date: Date today.			"Force 3.1 updates to start at the right place"			Smalltalk changes name: '3617suntaxBob1-raa'.			PopUpMenu notify: 'You may now save this Version 3.1alpha imageand retrieve updates again for Version 3.1alpha and beyond.']	ifFalse: ["Prevent advancement of update number."			Smalltalk changes name: 'Version30End' , (Time millisecondClockValue \\ 999999) printString.			PopUpMenu notify: 'You may request updates againto retrieve more recent updates for Version 3.0,or to later advance this image to Version 3.1alpha.'].!----QUIT----#(25 June 2001 6:42:19 pm) priorSource: 885462!